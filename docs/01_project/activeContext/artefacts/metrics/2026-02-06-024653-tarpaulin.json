{"files":[{"path":["/","app","kukuri-tauri","src-tauri","benches","command_optimization.rs"],"content":"use criterion::{BenchmarkId, Criterion, black_box, criterion_group, criterion_main};\r\nuse tokio::runtime::Runtime;\r\n\r\nfn benchmark_single_vs_batch_posts(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"post_retrieval\");\r\n\r\n    // 10, 50, 100個の投稿IDでテスト\r\n    for size in [10, 50, 100].iter() {\r\n        let post_ids: Vec<String> = (0..*size).map(|i| format!(\"post_{}\", i)).collect();\r\n\r\n        group.bench_with_input(BenchmarkId::new(\"individual\", size), size, |b, _| {\r\n            b.to_async(&rt).iter(|| async {\r\n                // 個別取得のシミュレーション\r\n                for id in &post_ids {\r\n                    // DBアクセスのシミュレーション\r\n                    tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\r\n                }\r\n            });\r\n        });\r\n\r\n        group.bench_with_input(BenchmarkId::new(\"batch\", size), size, |b, _| {\r\n            b.to_async(&rt).iter(|| async {\r\n                // バッチ取得のシミュレーション\r\n                tokio::time::sleep(tokio::time::Duration::from_micros(200)).await;\r\n            });\r\n        });\r\n    }\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_cache_vs_no_cache(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"cache_performance\");\r\n\r\n    group.bench_function(\"without_cache\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // DBアクセスのシミュレーション\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await;\r\n            black_box(\"post_content\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"with_cache_miss\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // キャッシュチェック + DBアクセス\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await; // キャッシュチェック\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await; // DBアクセス\r\n            black_box(\"post_content\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"with_cache_hit\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // キャッシュヒット（DBアクセスなし）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await;\r\n            black_box(\"cached_post_content\");\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_parallel_npub_conversion(c: &mut Criterion) {\r\n    use nostr_sdk::prelude::*;\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"npub_conversion\");\r\n\r\n    let pubkeys: Vec<String> = (0..100)\r\n        .map(|i| {\r\n            format!(\r\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa{:03}\",\r\n                i\r\n            )\r\n        })\r\n        .collect();\r\n\r\n    group.bench_function(\"serial\", |b| {\r\n        b.iter(|| {\r\n            for pubkey in &pubkeys {\r\n                let _ = PublicKey::from_hex(pubkey)\r\n                    .ok()\r\n                    .and_then(|pk| pk.to_bech32().ok())\r\n                    .unwrap_or_else(|| pubkey.clone());\r\n            }\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"parallel\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            use futures::future::join_all;\r\n\r\n            let futures = pubkeys.iter().map(|pubkey| {\r\n                let pk = pubkey.clone();\r\n                async move {\r\n                    tokio::task::spawn_blocking(move || {\r\n                        PublicKey::from_hex(&pk)\r\n                            .ok()\r\n                            .and_then(|pk| pk.to_bech32().ok())\r\n                            .unwrap_or(pk)\r\n                    })\r\n                    .await\r\n                    .unwrap_or_else(|_| pubkey.clone())\r\n                }\r\n            });\r\n\r\n            let _ = join_all(futures).await;\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_handler_reuse(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"handler_initialization\");\r\n\r\n    group.bench_function(\"new_handler_each_time\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // ハンドラーを毎回生成（最適化前）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(50)).await;\r\n            black_box(\"handler_created\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"reused_handler\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // ハンドラーを再利用（最適化後）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(1)).await;\r\n            black_box(\"handler_reused\");\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    benchmark_single_vs_batch_posts,\r\n    benchmark_cache_vs_no_cache,\r\n    benchmark_parallel_npub_conversion,\r\n    benchmark_handler_reuse\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","build.rs"],"content":"fn main() {\n    tauri_build::build();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","mod.rs"],"content":"pub mod ports;\npub mod services;\npub mod shared;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","auth_lifecycle.rs"],"content":"use crate::application::ports::key_manager::KeyPair;\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\npub struct AuthAccountContext {\n    pub npub: String,\n    pub public_key: String,\n}\n\nimpl AuthAccountContext {\n    pub fn new(npub: impl Into<String>, public_key: impl Into<String>) -> Self {\n        Self {\n            npub: npub.into(),\n            public_key: public_key.into(),\n        }\n    }\n}\n\nimpl From<&KeyPair> for AuthAccountContext {\n    fn from(keypair: &KeyPair) -> Self {\n        Self {\n            npub: keypair.npub.clone(),\n            public_key: keypair.public_key.clone(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AuthLifecycleStage {\n    AccountCreated,\n    Login,\n}\n\n#[derive(Debug, Clone)]\npub struct AuthLifecycleEvent {\n    pub stage: AuthLifecycleStage,\n    pub account: AuthAccountContext,\n}\n\nimpl AuthLifecycleEvent {\n    pub fn new(stage: AuthLifecycleStage, account: AuthAccountContext) -> Self {\n        Self { stage, account }\n    }\n\n    pub fn account_created(account: AuthAccountContext) -> Self {\n        Self::new(AuthLifecycleStage::AccountCreated, account)\n    }\n\n    pub fn login(account: AuthAccountContext) -> Self {\n        Self::new(AuthLifecycleStage::Login, account)\n    }\n}\n\n#[async_trait]\npub trait AuthLifecyclePort: Send + Sync {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n}\n","traces":[{"line":13,"address":[15218288,15218539],"length":1,"stats":{"Line":1}},{"line":15,"address":[15174614],"length":1,"stats":{"Line":1}},{"line":16,"address":[15216735],"length":1,"stats":{"Line":1}},{"line":22,"address":[15181972,15181808],"length":1,"stats":{"Line":2}},{"line":24,"address":[15174903],"length":1,"stats":{"Line":2}},{"line":25,"address":[15174941],"length":1,"stats":{"Line":2}},{"line":43,"address":[15213184],"length":1,"stats":{"Line":2}},{"line":47,"address":[12950512],"length":1,"stats":{"Line":2}},{"line":48,"address":[15107343],"length":1,"stats":{"Line":2}},{"line":51,"address":[15313664],"length":1,"stats":{"Line":2}},{"line":52,"address":[15175199],"length":1,"stats":{"Line":2}}],"covered":11,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","cache.rs"],"content":"use crate::domain::entities::Post;\nuse async_trait::async_trait;\n\n/// 投稿エンティティ用のキャッシュポート\n#[async_trait]\npub trait PostCache: Send + Sync {\n    /// 投稿をキャッシュに追加\n    async fn add(&self, post: Post);\n\n    /// ID でキャッシュを検索\n    async fn get(&self, id: &str) -> Option<Post>;\n\n    /// キャッシュから投稿を削除\n    async fn remove(&self, id: &str) -> Option<Post>;\n\n    /// トピック単位で投稿を取得（新しい順）\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post>;\n\n    /// トピックの投稿キャッシュを丸ごと差し替え\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>);\n\n    /// トピックに紐づく投稿キャッシュを無効化\n    async fn invalidate_topic(&self, topic_id: &str);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","direct_message_notifier.rs"],"content":"use crate::domain::entities::DirectMessage;\nuse crate::shared::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait DirectMessageNotifier: Send + Sync {\n    async fn notify(&self, owner_npub: &str, message: &DirectMessage) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","event_gateway.rs"],"content":"use crate::domain::entities::{DomainEvent, ProfileMetadata};\r\nuse crate::domain::value_objects::{EventId, PublicKey, ReactionValue, TopicContent, TopicId};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\n\r\n/// EventManager 縺ｪ縺ｩ縺ｮ蜈ｷ菴灘ｮ溯｣・↓萓晏ｭ倥○縺壹、pplication 螻､縺九ｉ繧､繝吶Φ繝磯・菫｡繧呈桶縺・◆繧√・繝昴・繝医・///\r\n/// 險ｭ險医ラ繧ｭ繝･繝｡繝ｳ繝・ `docs/01_project/activeContext/artefacts/phase5_event_gateway_design.md`\r\n#[async_trait]\r\npub trait EventGateway: Send + Sync {\r\n    /// P2P 繧・Gossip 縺ｪ縺ｩ螟夜Κ繧ｽ繝ｼ繧ｹ縺九ｉ蜿嶺ｿ｡縺励◆繧､繝吶Φ繝医ｒ蜃ｦ逅・☆繧九・\r\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\r\n\r\n    /// 閾ｪ霄ｫ縺ｮ繝弱・繝峨→縺励※繝・く繧ｹ繝医ヮ繝ｼ繝医ｒ逋ｺ陦後☆繧九・\r\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\r\n\r\n    /// 繝医ヴ繝・け縺ｫ邏舌▼縺乗兜遞ｿ繧貞・髢九☆繧九Ａreply_to` 縺ｫ繧医ｊ繧ｹ繝ｬ繝・ラ霑比ｿ｡繧呈欠遉ｺ縺ｧ縺阪ｋ縲・\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError>;\n\r\n    /// 莉ｻ諢上う繝吶Φ繝医∈繝ｪ繧｢繧ｯ繧ｷ繝ｧ繝ｳ繧帝∽ｿ｡縺吶ｋ縲・\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &EventId,\r\n        reaction: &ReactionValue,\r\n    ) -> Result<EventId, AppError>;\r\n\r\n    /// 繝励Ο繝輔ぅ繝ｼ繝ｫ繝｡繧ｿ繝・・繧ｿ繧呈峩譁ｰ縺励∵眠縺励＞繧､繝吶Φ繝・ID 繧定ｿ泌唆縺吶ｋ縲・\r\n    async fn update_profile_metadata(\r\n        &self,\r\n        metadata: &ProfileMetadata,\r\n    ) -> Result<EventId, AppError>;\r\n\r\n    /// 謖・ｮ壹＆繧後◆繧､繝吶Φ繝育ｾ､繧貞炎髯､縺励∝炎髯､繧､繝吶Φ繝医・ ID 繧定ｿ泌唆縺吶ｋ縲・\r\n    async fn delete_events(\r\n        &self,\r\n        targets: &[EventId],\r\n        reason: Option<&str>,\r\n    ) -> Result<EventId, AppError>;\r\n    async fn publish_repost(&self, target: &EventId) -> Result<EventId, AppError>;\r\n\r\n    /// 繝阪ャ繝医Ρ繝ｼ繧ｯ謗･邯壹ｒ蛻・妙縺吶ｋ縲・\r\n    async fn disconnect(&self) -> Result<(), AppError>;\r\n\r\n    /// 繝弱・繝峨′蛻ｩ逕ｨ縺吶ｋ蜈ｬ髢矩嵯繧貞叙蠕励☆繧九・\r\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\r\n\r\n    /// 譌｢螳壹・雉ｼ隱ｭ繝医ヴ繝・け繧呈峩譁ｰ縺吶ｋ縲・\r\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\r\n\r\n    /// 譌｢螳壹・雉ｼ隱ｭ繝医ヴ繝・け繧剃ｸ隕ｧ縺吶ｋ縲・\r\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","event_topic_store.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n/// EventManager が参照するイベントとトピックの対応情報を\n/// アプリケーション層に閉じ込めるためのポート。\n#[async_trait]\npub trait EventTopicStore: Send + Sync {\n    /// イベントとトピックの関連を保存する（冪等）\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError>;\n\n    /// イベントが属するトピック一覧を取得する\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","group_key_store.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct GroupKeyEntry {\n    pub topic_id: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub stored_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct GroupKeyRecord {\n    pub topic_id: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub key_b64: String,\n    pub stored_at: i64,\n}\n\n#[async_trait]\npub trait GroupKeyStore: Send + Sync {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError>;\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError>;\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError>;\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","join_request_store.rs"],"content":"use crate::domain::entities::Event;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestRecord {\n    pub event: Event,\n    pub topic_id: String,\n    pub scope: String,\n    pub requester_pubkey: String,\n    pub target_pubkey: Option<String>,\n    pub requested_at: Option<i64>,\n    pub received_at: i64,\n    pub invite_event_json: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InviteUsageRecord {\n    pub invite_event_id: String,\n    pub max_uses: i64,\n    pub used_count: i64,\n    pub last_used_at: i64,\n}\n\n#[async_trait]\npub trait JoinRequestStore: Send + Sync {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError>;\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError>;\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError>;\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError>;\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError>;\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","key_manager.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyPair {\n    pub public_key: String,\n    pub private_key: String,\n    pub npub: String,\n    pub nsec: String,\n}\n\n#[async_trait]\npub trait KeyManager: Send + Sync {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError>;\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError>;\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError>;\n    async fn current_keypair(&self) -> Result<KeyPair, AppError>;\n}\n\n#[async_trait]\npub trait KeyMaterialStore: Send + Sync {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError>;\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError>;\n    async fn set_current(&self, npub: &str) -> Result<(), AppError>;\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","messaging_gateway.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\npub struct MessagingSendResult {\n    pub event_id: Option<String>,\n    pub ciphertext: String,\n    pub created_at_millis: i64,\n    pub delivered: bool,\n}\n\n#[async_trait]\npub trait MessagingGateway: Send + Sync {\n    async fn encrypt_and_send(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<MessagingSendResult, AppError>;\n\n    async fn encrypt_only(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<String, AppError>;\n\n    async fn decrypt_with_counterparty(\n        &self,\n        owner_npub: &str,\n        counterparty_npub: &str,\n        ciphertext: &str,\n    ) -> Result<String, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","mod.rs"],"content":"pub mod auth_lifecycle;\npub mod cache;\npub mod direct_message_notifier;\npub mod event_gateway;\npub mod event_topic_store;\npub mod group_key_store;\npub mod join_request_store;\npub mod key_manager;\npub mod messaging_gateway;\npub mod offline_store;\npub mod repositories;\npub mod secure_storage;\npub mod subscription_invoker;\npub mod subscription_state_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","offline_store.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft,\n    OfflineActionFilter, OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord,\n    SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusRecord,\n    SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait OfflinePersistence: Send + Sync {\n    async fn save_action(&self, draft: OfflineActionDraft) -> Result<SavedOfflineAction, AppError>;\n\n    async fn list_actions(\n        &self,\n        filter: OfflineActionFilter,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n\n    async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError>;\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError>;\n\n    async fn pending_sync_items(&self) -> Result<Vec<SyncQueueItem>, AppError>;\n\n    async fn stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError>;\n\n    async fn unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError>;\n\n    async fn sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","repositories.rs"],"content":"use crate::domain::entities::{\n    Bookmark, DirectMessage, Event, MetricsWindow, NewDirectMessage, PendingTopic,\n    PendingTopicStatus, Post, Topic, TopicActivityRow, TopicMetricsSnapshot, TopicMetricsUpsert,\n    User,\n};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};\nuse std::fmt;\n\n#[derive(Debug, Clone)]\npub struct UserCursorPage {\n    pub users: Vec<User>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FollowListSort {\n    Recent,\n    Oldest,\n    NameAsc,\n    NameDesc,\n}\n\nimpl FollowListSort {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::Recent => \"recent\",\n            Self::Oldest => \"oldest\",\n            Self::NameAsc => \"name_asc\",\n            Self::NameDesc => \"name_desc\",\n        }\n    }\n}\n\nimpl TryFrom<&str> for FollowListSort {\n    type Error = ();\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        match value {\n            \"recent\" => Ok(Self::Recent),\n            \"oldest\" => Ok(Self::Oldest),\n            \"name_asc\" => Ok(Self::NameAsc),\n            \"name_desc\" => Ok(Self::NameDesc),\n            _ => Err(()),\n        }\n    }\n}\n\n#[async_trait]\npub trait PostRepository: Send + Sync {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError>;\n    async fn get_posts_by_topic(&self, topic_id: &str, limit: usize)\n    -> Result<Vec<Post>, AppError>;\n    async fn update_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn delete_post(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError>;\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError>;\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError>;\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError>;\n    async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<PostFeedCursor>,\n        limit: usize,\n    ) -> Result<PostFeedPage, AppError>;\n}\n\n#[derive(Debug, Clone)]\npub struct PostFeedCursor {\n    pub created_at: i64,\n    pub event_id: String,\n}\n\nimpl PostFeedCursor {\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(2, ':');\n        let created_at = parts.next()?.parse().ok()?;\n        let event_id = parts.next()?.to_string();\n        if event_id.is_empty() {\n            return None;\n        }\n        Some(Self {\n            created_at,\n            event_id,\n        })\n    }\n}\n\nimpl fmt::Display for PostFeedCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}:{}\", self.created_at, self.event_id)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PostFeedPage {\n    pub items: Vec<Post>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[async_trait]\npub trait TopicRepository: Send + Sync {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn update_topic_stats(\n        &self,\n        topic_id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait PendingTopicRepository: Send + Sync {\n    async fn insert_pending_topic(&self, topic: &PendingTopic) -> Result<(), AppError>;\n    async fn list_pending_topics(&self, user_pubkey: &str) -> Result<Vec<PendingTopic>, AppError>;\n    async fn get_pending_topic(&self, pending_id: &str) -> Result<Option<PendingTopic>, AppError>;\n    async fn update_pending_topic_status(\n        &self,\n        pending_id: &str,\n        status: PendingTopicStatus,\n        synced_topic_id: Option<&str>,\n        error_message: Option<&str>,\n    ) -> Result<(), AppError>;\n    async fn delete_pending_topic(&self, pending_id: &str) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait TopicMetricsRepository: Send + Sync {\n    async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError>;\n    async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError>;\n    async fn collect_activity(\n        &self,\n        window: MetricsWindow,\n    ) -> Result<Vec<TopicActivityRow>, AppError>;\n    async fn latest_window_end(&self) -> Result<Option<i64>, AppError>;\n    async fn list_recent_metrics(\n        &self,\n        limit: usize,\n    ) -> Result<Option<TopicMetricsSnapshot>, AppError>;\n}\n\n#[async_trait]\npub trait UserRepository: Send + Sync {\n    async fn create_user(&self, user: &User) -> Result<(), AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError>;\n    async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError>;\n    async fn update_user(&self, user: &User) -> Result<(), AppError>;\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_followers_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError>;\n    async fn get_following_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError>;\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError>;\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError>;\n    async fn list_following_pubkeys(&self, follower_pubkey: &str) -> Result<Vec<String>, AppError>;\n    async fn list_follower_pubkeys(&self, followed_pubkey: &str) -> Result<Vec<String>, AppError>;\n}\n\n#[async_trait]\npub trait EventRepository: Send + Sync {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError>;\n    async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n\n    /// イベントとトピックのマッピングを登録（冪等）\n    async fn add_event_topic(&self, _event_id: &str, _topic_id: &str) -> Result<(), AppError> {\n        // 既定実装: 実装なし\n        Ok(())\n    }\n\n    /// イベントが属するトピックID一覧を取得\n    async fn get_event_topics(&self, _event_id: &str) -> Result<Vec<String>, AppError> {\n        // 既定実装: 空\n        Ok(vec![])\n    }\n}\n\n#[async_trait]\npub trait BookmarkRepository: Send + Sync {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError>;\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError>;\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError>;\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageCursor {\n    pub created_at: i64,\n    pub event_id: Option<String>,\n}\n\nimpl DirectMessageCursor {\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(2, ':');\n        let created_at = parts.next()?.parse().ok()?;\n        let event_id = parts\n            .next()\n            .filter(|s| !s.is_empty())\n            .map(|s| s.to_string());\n        Some(Self {\n            created_at,\n            event_id,\n        })\n    }\n}\n\nimpl fmt::Display for DirectMessageCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let event_part = self.event_id.as_deref().unwrap_or_default();\n        write!(f, \"{}:{}\", self.created_at, event_part)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationCursor {\n    pub last_message_created_at: Option<i64>,\n    pub conversation_npub: String,\n}\n\nimpl DirectMessageConversationCursor {\n    pub fn new(last_message_created_at: Option<i64>, conversation_npub: String) -> Self {\n        Self {\n            last_message_created_at,\n            conversation_npub,\n        }\n    }\n\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(3, ':');\n        let bucket = parts.next()?.parse::<i64>().ok()?;\n        if bucket != 0 && bucket != 1 {\n            return None;\n        }\n        let timestamp = parts.next()?.parse::<i64>().ok()?;\n        let encoded_npub = parts.next()?;\n        let npub_bytes = URL_SAFE_NO_PAD.decode(encoded_npub).ok()?;\n        let conversation_npub = String::from_utf8(npub_bytes).ok()?;\n        let last_message_created_at = if bucket == 0 { Some(timestamp) } else { None };\n        Some(Self {\n            last_message_created_at,\n            conversation_npub,\n        })\n    }\n\n    pub fn bucket(&self) -> i64 {\n        if self.last_message_created_at.is_some() {\n            0\n        } else {\n            1\n        }\n    }\n}\n\nimpl fmt::Display for DirectMessageConversationCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let encoded_npub = URL_SAFE_NO_PAD.encode(self.conversation_npub.as_bytes());\n        let timestamp = self.last_message_created_at.unwrap_or(0);\n        write!(f, \"{}:{}:{}\", self.bucket(), timestamp, encoded_npub)\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum DirectMessageListDirection {\n    Backward,\n    Forward,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessagePageRaw {\n    pub items: Vec<DirectMessage>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationRecord {\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub last_message: Option<DirectMessage>,\n    pub last_message_created_at: Option<i64>,\n    pub last_read_at: i64,\n    pub unread_count: i64,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationPageRaw {\n    pub items: Vec<DirectMessageConversationRecord>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[async_trait]\npub trait DirectMessageRepository: Send + Sync {\n    async fn insert_direct_message(\n        &self,\n        message: &NewDirectMessage,\n    ) -> Result<DirectMessage, AppError>;\n\n    async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<DirectMessageCursor>,\n        limit: usize,\n        direction: DirectMessageListDirection,\n    ) -> Result<DirectMessagePageRaw, AppError>;\n\n    async fn mark_delivered_by_client_id(\n        &self,\n        owner_npub: &str,\n        client_message_id: &str,\n        event_id: Option<String>,\n        delivered: bool,\n    ) -> Result<(), AppError>;\n\n    async fn upsert_conversation_metadata(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        last_message_id: i64,\n        last_message_created_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<DirectMessageConversationCursor>,\n        limit: usize,\n    ) -> Result<DirectMessageConversationPageRaw, AppError>;\n}\n","traces":[{"line":29,"address":[23861408],"length":1,"stats":{"Line":0}},{"line":30,"address":[23761045],"length":1,"stats":{"Line":0}},{"line":31,"address":[23655156],"length":1,"stats":{"Line":0}},{"line":32,"address":[23761099],"length":1,"stats":{"Line":0}},{"line":33,"address":[23765058],"length":1,"stats":{"Line":0}},{"line":34,"address":[23765081],"length":1,"stats":{"Line":0}},{"line":42,"address":[23766768],"length":1,"stats":{"Line":0}},{"line":44,"address":[23766791,23766844],"length":1,"stats":{"Line":0}},{"line":45,"address":[23655387,23655317],"length":1,"stats":{"Line":0}},{"line":46,"address":[23730100,23730170],"length":1,"stats":{"Line":0}},{"line":47,"address":[23766915,23766960],"length":1,"stats":{"Line":0}},{"line":48,"address":[23730185],"length":1,"stats":{"Line":0}},{"line":84,"address":[23766035,23765344],"length":1,"stats":{"Line":1}},{"line":85,"address":[23655521],"length":1,"stats":{"Line":1}},{"line":86,"address":[14312151,14312425],"length":1,"stats":{"Line":1}},{"line":87,"address":[23662878,23662719,23662805],"length":1,"stats":{"Line":2}},{"line":88,"address":[14312492,14312566],"length":1,"stats":{"Line":2}},{"line":89,"address":[23730875],"length":1,"stats":{"Line":0}},{"line":91,"address":[23761949],"length":1,"stats":{"Line":1}},{"line":93,"address":[23765837],"length":1,"stats":{"Line":1}},{"line":99,"address":[23656208],"length":1,"stats":{"Line":1}},{"line":100,"address":[23862535],"length":1,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[23762304],"length":1,"stats":{"Line":0}},{"line":249,"address":[23766273],"length":1,"stats":{"Line":0}},{"line":250,"address":[23762716,23762359],"length":1,"stats":{"Line":0}},{"line":251,"address":[23731372],"length":1,"stats":{"Line":0}},{"line":253,"address":[23766672,23766684],"length":1,"stats":{"Line":0}},{"line":254,"address":[14313494,14313472],"length":1,"stats":{"Line":0}},{"line":255,"address":[17904206],"length":1,"stats":{"Line":0}},{"line":263,"address":[23863200],"length":1,"stats":{"Line":0}},{"line":264,"address":[23863233],"length":1,"stats":{"Line":0}},{"line":265,"address":[23766834],"length":1,"stats":{"Line":0}},{"line":276,"address":[23657120],"length":1,"stats":{"Line":1}},{"line":283,"address":[23726272,23724976,23726304],"length":1,"stats":{"Line":0}},{"line":284,"address":[23768705],"length":1,"stats":{"Line":0}},{"line":285,"address":[23768942,23768735],"length":1,"stats":{"Line":0}},{"line":286,"address":[23650743,23650641],"length":1,"stats":{"Line":0}},{"line":287,"address":[23763458],"length":1,"stats":{"Line":0}},{"line":289,"address":[23664425,23664741,23664526],"length":1,"stats":{"Line":0}},{"line":290,"address":[23769422,23769280,23769191],"length":1,"stats":{"Line":0}},{"line":291,"address":[14314531,14314671,14314412],"length":1,"stats":{"Line":0}},{"line":292,"address":[23658276,23658452,23658001,23658121],"length":1,"stats":{"Line":0}},{"line":293,"address":[23726102,23726071],"length":1,"stats":{"Line":0}},{"line":294,"address":[23726157],"length":1,"stats":{"Line":0}},{"line":295,"address":[14314930],"length":1,"stats":{"Line":0}},{"line":300,"address":[23733248],"length":1,"stats":{"Line":1}},{"line":301,"address":[23768396,23768377],"length":1,"stats":{"Line":1}},{"line":302,"address":[23770046],"length":1,"stats":{"Line":1}},{"line":304,"address":[23665507],"length":1,"stats":{"Line":0}},{"line":310,"address":[23865257,23864864],"length":1,"stats":{"Line":1}},{"line":311,"address":[23764529],"length":1,"stats":{"Line":1}},{"line":312,"address":[23733393,23733471],"length":1,"stats":{"Line":2}},{"line":313,"address":[23764660],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","secure_storage.rs"],"content":"use crate::domain::entities::{AccountMetadata, AccountRegistration, CurrentAccountSecret};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SecureAccountStore: Send + Sync {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError>;\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError>;\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError>;\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError>;\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError>;\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_invoker.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\n\n/// 購読復元や加入リクエストを実行するためのポート。\n///\n/// EventService など Application 層はこの trait を通じて購読処理を発行し、\n/// 具体的な実装（EventManager など）は Infrastructure 層に閉じ込める。\n#[async_trait]\npub trait SubscriptionInvoker: Send + Sync {\n    /// 指定トピックに対する購読を開始する。\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError>;\n\n    /// 指定ユーザー（公開鍵）に対する購読を開始する。\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_state_repository.rs"],"content":"use crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SubscriptionStateRepository: Send + Sync {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError>;\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError>;\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","access_control_service.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyRecord, GroupKeyStore};\nuse crate::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::application::ports::repositories::UserRepository;\nuse crate::application::shared::nostr::to_nostr_event;\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::crypto::SignatureService;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::{AppError, RateLimiter, ValidationFailureKind};\nuse base64::Engine;\nuse base64::engine::general_purpose::STANDARD as BASE64_STANDARD;\nuse chrono::Utc;\nuse nostr_sdk::prelude::{PublicKey, SecretKey, nip44};\nuse rand::rngs::OsRng;\nuse rand_core::TryRngCore;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse uuid::Uuid;\n\nconst KIP_NAMESPACE: &str = \"kukuri\";\nconst KIP_VERSION: &str = \"1\";\nconst KIND_KEY_ENVELOPE: u32 = 39020;\nconst KIND_INVITE_CAPABILITY: u32 = 39021;\nconst KIND_JOIN_REQUEST: u32 = 39022;\nconst JOIN_REQUEST_RATE_LIMIT_MAX: usize = 3;\nconst JOIN_REQUEST_RATE_LIMIT_WINDOW: Duration = Duration::from_secs(60);\n\n#[derive(Debug, Clone)]\npub struct JoinRequestInput {\n    pub topic_id: Option<String>,\n    pub scope: Option<String>,\n    pub invite_event_json: Option<serde_json::Value>,\n    pub target_pubkey: Option<String>,\n    pub broadcast_to_topic: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestResult {\n    pub event_id: String,\n    pub sent_topics: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestApprovalResult {\n    pub event_id: String,\n    pub key_envelope_event_id: String,\n    pub recipient_pubkey: String,\n    pub topic_id: String,\n    pub scope: String,\n}\n\npub struct AccessControlService {\n    key_manager: Arc<dyn KeyManager>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n    join_request_store: Arc<dyn JoinRequestStore>,\n    user_repository: Arc<dyn UserRepository>,\n    signature_service: Arc<dyn SignatureService>,\n    gossip_service: Arc<dyn GossipService>,\n    join_request_rate_limiter: RateLimiter,\n}\n\nimpl AccessControlService {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n        join_request_store: Arc<dyn JoinRequestStore>,\n        user_repository: Arc<dyn UserRepository>,\n        signature_service: Arc<dyn SignatureService>,\n        gossip_service: Arc<dyn GossipService>,\n    ) -> Self {\n        Self {\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository,\n            signature_service,\n            gossip_service,\n            join_request_rate_limiter: RateLimiter::new(\n                JOIN_REQUEST_RATE_LIMIT_MAX,\n                JOIN_REQUEST_RATE_LIMIT_WINDOW,\n            ),\n        }\n    }\n\n    pub async fn issue_invite(\n        &self,\n        topic_id: &str,\n        expires_in: Option<i64>,\n        max_uses: Option<i64>,\n        nonce: Option<String>,\n    ) -> Result<serde_json::Value, AppError> {\n        if topic_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Topic ID is required\",\n            ));\n        }\n\n        let keypair = self.current_keypair().await?;\n        let now = Utc::now().timestamp();\n        let expires_in = expires_in.unwrap_or(86_400).max(60);\n        let expires_at = now.saturating_add(expires_in);\n        let max_uses = max_uses.unwrap_or(1).max(1);\n        let nonce = nonce.unwrap_or_else(|| Uuid::new_v4().to_string());\n\n        let _ = self.ensure_group_key(topic_id, \"invite\").await?;\n\n        let content = json!({\n            \"schema\": \"kukuri-invite-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"invite\",\n            \"expires\": expires_at,\n            \"max_uses\": max_uses,\n            \"nonce\": nonce,\n            \"issuer\": format!(\"pubkey:{}\", keypair.public_key),\n        })\n        .to_string();\n\n        let tags = vec![\n            vec![\"t\".to_string(), topic_id.to_string()],\n            vec![\"scope\".to_string(), \"invite\".to_string()],\n            vec![\"d\".to_string(), format!(\"invite:{nonce}\")],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n            vec![\"exp\".to_string(), expires_at.to_string()],\n        ];\n\n        let event = self\n            .build_signed_event(KIND_INVITE_CAPABILITY, content, tags)\n            .await?;\n        let nostr_event = to_nostr_event(&event)?;\n        serde_json::to_value(nostr_event)\n            .map_err(|err| AppError::SerializationError(err.to_string()))\n    }\n\n    pub async fn request_join(\n        &self,\n        input: JoinRequestInput,\n    ) -> Result<JoinRequestResult, AppError> {\n        let keypair = self.current_keypair().await?;\n        let requester_pubkey = keypair.public_key.clone();\n        let now = Utc::now().timestamp();\n        let broadcast_to_topic = input.broadcast_to_topic;\n\n        let (topic_id, scope, invite_event_json, issuer_pubkey) =\n            self.resolve_join_request_input(&input)?;\n        if let Some(issuer) = issuer_pubkey.as_ref() {\n            PublicKey::from_hex(issuer).map_err(|err| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid target pubkey: {err}\"),\n                )\n            })?;\n        }\n\n        let mut tags = vec![\n            vec![\"t\".to_string(), topic_id.clone()],\n            vec![\"scope\".to_string(), scope.clone()],\n            vec![\n                \"d\".to_string(),\n                format!(\"join:{topic_id}:{}:{requester_pubkey}\", Uuid::new_v4()),\n            ],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n        ];\n\n        if let Some(invite_event) = invite_event_json.as_ref() {\n            if let Some(invite_id) = invite_event.get(\"id\").and_then(|v| v.as_str()) {\n                tags.push(vec![\"e\".to_string(), invite_id.to_string()]);\n            }\n        }\n        if let Some(issuer) = issuer_pubkey.as_ref() {\n            tags.push(vec![\"p\".to_string(), issuer.to_string()]);\n        }\n\n        let mut content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": scope,\n            \"requester\": format!(\"pubkey:{requester_pubkey}\"),\n            \"requested_at\": now,\n        });\n        if let Some(invite_event) = invite_event_json {\n            content[\"invite_event_json\"] = invite_event;\n        }\n\n        let event = self\n            .build_signed_event(KIND_JOIN_REQUEST, content.to_string(), tags)\n            .await?;\n\n        let mut topics = HashSet::new();\n        if let Some(issuer) = issuer_pubkey {\n            topics.insert(user_topic_id(&issuer));\n        }\n        if broadcast_to_topic {\n            topics.insert(topic_id.clone());\n        }\n\n        if topics.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request target is missing\",\n            ));\n        }\n\n        let sent_topics: Vec<String> = topics.into_iter().collect();\n        self.broadcast_event(&event, &sent_topics).await?;\n\n        Ok(JoinRequestResult {\n            event_id: event.id.clone(),\n            sent_topics,\n        })\n    }\n\n    pub async fn list_pending_join_requests(&self) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let keypair = self.current_keypair().await?;\n        self.join_request_store\n            .list_requests(&keypair.public_key)\n            .await\n    }\n\n    pub async fn approve_join_request(\n        &self,\n        event_id: &str,\n    ) -> Result<JoinRequestApprovalResult, AppError> {\n        let keypair = self.current_keypair().await?;\n        if event_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request event_id is required\",\n            ));\n        }\n\n        let Some(record) = self\n            .join_request_store\n            .get_request(&keypair.public_key, event_id)\n            .await?\n        else {\n            return Err(AppError::NotFound(\"Join request not found\".to_string()));\n        };\n\n        let Some(context) = self\n            .validate_join_request_event(&record.event, &keypair.public_key)\n            .await?\n        else {\n            return Err(AppError::NotFound(\n                \"Join request is not available\".to_string(),\n            ));\n        };\n\n        let group_key = self\n            .ensure_group_key(&context.topic_id, &context.scope)\n            .await?;\n        let envelope_event = self\n            .build_key_envelope_event(&context.requester_pubkey, &group_key)\n            .await?;\n        let topics = vec![user_topic_id(&context.requester_pubkey)];\n        self.broadcast_event(&envelope_event, &topics).await?;\n\n        self.join_request_store\n            .delete_request(&keypair.public_key, event_id)\n            .await?;\n\n        Ok(JoinRequestApprovalResult {\n            event_id: record.event.id,\n            key_envelope_event_id: envelope_event.id,\n            recipient_pubkey: context.requester_pubkey,\n            topic_id: context.topic_id,\n            scope: context.scope,\n        })\n    }\n\n    pub async fn reject_join_request(&self, event_id: &str) -> Result<(), AppError> {\n        let keypair = self.current_keypair().await?;\n        if event_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request event_id is required\",\n            ));\n        }\n        self.join_request_store\n            .delete_request(&keypair.public_key, event_id)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn handle_incoming_event(&self, event: &Event) -> Result<(), AppError> {\n        match event.kind {\n            KIND_JOIN_REQUEST => self.handle_join_request(event).await?,\n            KIND_KEY_ENVELOPE => self.handle_key_envelope(event).await?,\n            _ => {}\n        }\n        Ok(())\n    }\n\n    async fn handle_join_request(&self, event: &Event) -> Result<(), AppError> {\n        let keypair = match self.key_manager.current_keypair().await {\n            Ok(pair) => pair,\n            Err(_) => return Ok(()),\n        };\n        let Some(context) = self\n            .validate_join_request_event(event, &keypair.public_key)\n            .await?\n        else {\n            return Ok(());\n        };\n\n        if self\n            .join_request_store\n            .get_request(&keypair.public_key, &event.id)\n            .await?\n            .is_some()\n        {\n            return Ok(());\n        }\n\n        let rate_key = format!(\n            \"join:{}:{}:{}\",\n            context.topic_id, context.scope, context.requester_pubkey\n        );\n        self.join_request_rate_limiter\n            .check_and_record(\n                &rate_key,\n                \"join.request の受信が多すぎます。しばらく待ってください\",\n            )\n            .await?;\n\n        if context.scope == \"invite\" {\n            let invite_event_id = context.invite_event_id.as_deref().ok_or_else(|| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invite event_id is missing\")\n            })?;\n            let max_uses = context.invite_max_uses.unwrap_or(1);\n            self.consume_invite_usage(&keypair.public_key, invite_event_id, max_uses)\n                .await?;\n        }\n\n        let record = JoinRequestRecord {\n            event: event.clone(),\n            topic_id: context.topic_id,\n            scope: context.scope,\n            requester_pubkey: context.requester_pubkey,\n            target_pubkey: context.target_pubkey,\n            requested_at: context.requested_at,\n            received_at: Utc::now().timestamp(),\n            invite_event_json: context.invite_event_json,\n        };\n\n        self.join_request_store\n            .upsert_request(&keypair.public_key, record)\n            .await?;\n        Ok(())\n    }\n\n    async fn validate_join_request_event(\n        &self,\n        event: &Event,\n        current_pubkey: &str,\n    ) -> Result<Option<JoinRequestContext>, AppError> {\n        if event.pubkey == current_pubkey {\n            return Ok(None);\n        }\n        if let Ok(nostr_event) = to_nostr_event(event) {\n            if nostr_event.verify().is_err() {\n                return Ok(None);\n            }\n        }\n\n        let tags = event.tags.clone();\n        let topic_id = require_tag_value(&tags, \"t\")?;\n        let scope = require_tag_value(&tags, \"scope\")?;\n        let _ = require_tag_value(&tags, \"d\")?;\n        validate_kip_tags(&tags)?;\n        match scope.as_str() {\n            \"invite\" | \"friend\" => {}\n            \"friend_plus\" => {}\n            _ => {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid join scope: {scope}\"),\n                ));\n            }\n        }\n        let target_pubkey = tag_value(&tags, \"p\");\n        if let Some(target) = target_pubkey.as_ref() {\n            if target != current_pubkey {\n                return Ok(None);\n            }\n        }\n\n        let content: JoinRequestPayload = serde_json::from_str(&event.content)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        if content.schema != \"kukuri-join-request-v1\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid join.request schema\",\n            ));\n        }\n        if let Some(topic) = content.topic.as_ref() {\n            if topic != &topic_id {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request topic mismatch\",\n                ));\n            }\n        }\n        if let Some(scope_value) = content.scope.as_ref() {\n            if scope_value != &scope {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request scope mismatch\",\n                ));\n            }\n        }\n        if let Some(requester) = content.requester.as_ref() {\n            if let Some(hex) = requester.strip_prefix(\"pubkey:\") {\n                if hex != event.pubkey {\n                    return Err(AppError::validation(\n                        ValidationFailureKind::Generic,\n                        \"Join.request requester mismatch\",\n                    ));\n                }\n            }\n        }\n        if let Some(requested_at) = content.requested_at {\n            if requested_at < 0 {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request requested_at is invalid\",\n                ));\n            }\n        }\n\n        let mut invite_event_id = None;\n        let mut invite_max_uses = None;\n        if scope == \"invite\" {\n            let invite_json = content.invite_event_json.clone().ok_or_else(|| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invite payload is missing\")\n            })?;\n            let invite = validate_invite_event(&invite_json, Some(&topic_id))?;\n            invite_event_id = Some(invite.event_id.clone());\n            invite_max_uses = Some(invite.max_uses);\n            if let Some(target) = target_pubkey.as_ref() {\n                if invite.issuer_pubkey != *target {\n                    return Ok(None);\n                }\n            }\n        }\n        if scope == \"friend_plus\" {\n            let is_fof = self\n                .is_friend_of_friend(current_pubkey, &event.pubkey)\n                .await?;\n            if !is_fof {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"friend_plus join.request requires FoF\",\n                ));\n            }\n        }\n\n        Ok(Some(JoinRequestContext {\n            topic_id,\n            scope,\n            target_pubkey,\n            requester_pubkey: event.pubkey.clone(),\n            invite_event_json: content.invite_event_json,\n            invite_event_id,\n            invite_max_uses,\n            requested_at: content.requested_at,\n        }))\n    }\n\n    async fn handle_key_envelope(&self, event: &Event) -> Result<(), AppError> {\n        let keypair = match self.key_manager.current_keypair().await {\n            Ok(pair) => pair,\n            Err(_) => return Ok(()),\n        };\n        if let Ok(nostr_event) = to_nostr_event(event) {\n            if nostr_event.verify().is_err() {\n                return Ok(());\n            }\n        }\n\n        let tags = event.tags.clone();\n        validate_kip_tags(&tags)?;\n        let recipient = require_tag_value(&tags, \"p\")?;\n        if recipient != keypair.public_key {\n            return Ok(());\n        }\n        let topic_tag = require_tag_value(&tags, \"t\")?;\n        let scope_tag = require_tag_value(&tags, \"scope\")?;\n        let epoch_tag = require_tag_value(&tags, \"epoch\")?\n            .parse::<i64>()\n            .map_err(|_| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invalid epoch tag\")\n            })?;\n        if epoch_tag <= 0 {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid epoch tag\",\n            ));\n        }\n\n        let secret_key = SecretKey::from_hex(&keypair.private_key)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid private key: {err}\")))?;\n        let sender_pubkey = PublicKey::from_hex(&event.pubkey)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid sender pubkey: {err}\")))?;\n        let decrypted = nip44::decrypt(&secret_key, &sender_pubkey, event.content.clone())\n            .map_err(|err| AppError::Crypto(format!(\"NIP-44 decrypt failed: {err}\")))?;\n        let payload: KeyEnvelopePayload = serde_json::from_str(&decrypted)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n        if payload.schema != \"kukuri-key-envelope-v1\" && payload.schema != \"kukuri-keyenv-v1\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid key envelope schema\",\n            ));\n        }\n        if payload.topic != topic_tag || payload.scope != scope_tag || payload.epoch != epoch_tag {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Key envelope payload mismatch\",\n            ));\n        }\n\n        let stored_at = payload.issued_at.unwrap_or_else(|| Utc::now().timestamp());\n        let record = GroupKeyRecord {\n            topic_id: payload.topic,\n            scope: payload.scope,\n            epoch: payload.epoch,\n            key_b64: payload.key_b64,\n            stored_at,\n        };\n        self.group_key_store.store_key(record).await?;\n        Ok(())\n    }\n\n    async fn ensure_group_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<GroupKeyRecord, AppError> {\n        if let Some(record) = self.group_key_store.get_latest_key(topic_id, scope).await? {\n            return Ok(record);\n        }\n\n        let mut key_bytes = [0u8; 32];\n        OsRng\n            .try_fill_bytes(&mut key_bytes)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to generate group key: {err}\")))?;\n        let key_b64 = BASE64_STANDARD.encode(key_bytes);\n        let record = GroupKeyRecord {\n            topic_id: topic_id.to_string(),\n            scope: scope.to_string(),\n            epoch: 1,\n            key_b64,\n            stored_at: Utc::now().timestamp(),\n        };\n        self.group_key_store.store_key(record.clone()).await?;\n        Ok(record)\n    }\n\n    async fn build_key_envelope_event(\n        &self,\n        recipient_pubkey: &str,\n        record: &GroupKeyRecord,\n    ) -> Result<Event, AppError> {\n        let keypair = self.current_keypair().await?;\n        let secret_key = SecretKey::from_hex(&keypair.private_key)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid private key: {err}\")))?;\n        let recipient = PublicKey::from_hex(recipient_pubkey)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid recipient pubkey: {err}\")))?;\n\n        let payload = json!({\n            \"schema\": \"kukuri-key-envelope-v1\",\n            \"topic\": record.topic_id.clone(),\n            \"scope\": record.scope.clone(),\n            \"epoch\": record.epoch,\n            \"key_b64\": record.key_b64.clone(),\n            \"issued_at\": Utc::now().timestamp()\n        });\n        let encrypted = nip44::encrypt(\n            &secret_key,\n            &recipient,\n            payload.to_string(),\n            nip44::Version::V2,\n        )\n        .map_err(|err| AppError::Crypto(format!(\"NIP-44 encrypt failed: {err}\")))?;\n\n        let d_tag = format!(\n            \"keyenv:{}:{}:{}:{}\",\n            record.topic_id.as_str(),\n            record.scope.as_str(),\n            record.epoch,\n            recipient_pubkey\n        );\n        let tags = vec![\n            vec![\"p\".to_string(), recipient_pubkey.to_string()],\n            vec![\"t\".to_string(), record.topic_id.clone()],\n            vec![\"scope\".to_string(), record.scope.clone()],\n            vec![\"epoch\".to_string(), record.epoch.to_string()],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n            vec![\"d\".to_string(), d_tag],\n        ];\n\n        self.build_signed_event(KIND_KEY_ENVELOPE, encrypted, tags)\n            .await\n    }\n\n    async fn build_signed_event(\n        &self,\n        kind: u32,\n        content: String,\n        tags: Vec<Vec<String>>,\n    ) -> Result<Event, AppError> {\n        let keypair = self.current_keypair().await?;\n        let mut event = Event::new(kind, content, keypair.public_key.clone()).with_tags(tags);\n        self.signature_service\n            .sign_event(&mut event, &keypair.private_key)\n            .await\n            .map_err(|err| AppError::Crypto(err.to_string()))?;\n        Ok(event)\n    }\n\n    async fn broadcast_event(&self, event: &Event, topics: &[String]) -> Result<(), AppError> {\n        let mut uniq: HashSet<String> = HashSet::new();\n        for topic in topics {\n            let trimmed = topic.trim();\n            if !trimmed.is_empty() {\n                uniq.insert(trimmed.to_string());\n            }\n        }\n\n        for topic in uniq {\n            self.gossip_service.join_topic(&topic, Vec::new()).await?;\n            self.gossip_service.broadcast(&topic, event).await?;\n        }\n        Ok(())\n    }\n\n    async fn collect_mutual_follow_pubkeys(\n        &self,\n        pubkey: &str,\n    ) -> Result<HashSet<String>, AppError> {\n        let following = self.user_repository.list_following_pubkeys(pubkey).await?;\n        let followers = self.user_repository.list_follower_pubkeys(pubkey).await?;\n        let following_set: HashSet<String> = following.into_iter().collect();\n        let mut mutual = HashSet::new();\n        for follower in followers {\n            if following_set.contains(&follower) {\n                mutual.insert(follower);\n            }\n        }\n        Ok(mutual)\n    }\n\n    async fn is_friend_of_friend(\n        &self,\n        current_pubkey: &str,\n        requester_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        if current_pubkey == requester_pubkey {\n            return Ok(false);\n        }\n        let current_friends = self.collect_mutual_follow_pubkeys(current_pubkey).await?;\n        if current_friends.is_empty() {\n            return Ok(false);\n        }\n        let requester_friends = self\n            .collect_mutual_follow_pubkeys(requester_pubkey)\n            .await?;\n        if requester_friends.is_empty() {\n            return Ok(false);\n        }\n        Ok(current_friends\n            .intersection(&requester_friends)\n            .next()\n            .is_some())\n    }\n\n    async fn consume_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n        max_uses: i64,\n    ) -> Result<(), AppError> {\n        let now = Utc::now().timestamp();\n        let incoming_max = max_uses.max(1);\n        let mut record = match self\n            .join_request_store\n            .get_invite_usage(owner_pubkey, invite_event_id)\n            .await?\n        {\n            Some(record) => record,\n            None => InviteUsageRecord {\n                invite_event_id: invite_event_id.to_string(),\n                max_uses: incoming_max,\n                used_count: 0,\n                last_used_at: now,\n            },\n        };\n\n        let existing_max = record.max_uses.max(1);\n        let effective_max = existing_max.min(incoming_max);\n        if record.used_count >= effective_max {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite max_uses exceeded\",\n            ));\n        }\n\n        record.used_count += 1;\n        record.max_uses = effective_max;\n        record.last_used_at = now;\n        self.join_request_store\n            .upsert_invite_usage(owner_pubkey, record)\n            .await?;\n        Ok(())\n    }\n\n    fn resolve_join_request_input(\n        &self,\n        input: &JoinRequestInput,\n    ) -> Result<(String, String, Option<serde_json::Value>, Option<String>), AppError> {\n        if let Some(invite_json) = input.invite_event_json.as_ref() {\n            let invite = validate_invite_event(invite_json, None)?;\n            let topic_id = invite.topic_id;\n            let scope = \"invite\".to_string();\n            let issuer_pubkey = Some(invite.issuer_pubkey);\n            return Ok((topic_id, scope, Some(invite_json.clone()), issuer_pubkey));\n        }\n\n        let topic_id = input.topic_id.clone().ok_or_else(|| {\n            AppError::validation(ValidationFailureKind::Generic, \"Topic ID is required\")\n        })?;\n        let scope = input.scope.clone().unwrap_or_else(|| \"friend\".to_string());\n        if scope == \"invite\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite JSON is required for invite scope\",\n            ));\n        }\n        if scope != \"friend\" && scope != \"friend_plus\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unsupported join scope: {scope}\"),\n            ));\n        }\n\n        let issuer_pubkey = input\n            .target_pubkey\n            .as_ref()\n            .map(|value| value.trim().to_string())\n            .filter(|value| !value.is_empty());\n        if issuer_pubkey.is_none() && !input.broadcast_to_topic {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Target pubkey or broadcast_to_topic is required\",\n            ));\n        }\n\n        Ok((topic_id, scope, None, issuer_pubkey))\n    }\n\n    async fn current_keypair(\n        &self,\n    ) -> Result<crate::application::ports::key_manager::KeyPair, AppError> {\n        self.key_manager.current_keypair().await\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct JoinRequestContext {\n    topic_id: String,\n    scope: String,\n    target_pubkey: Option<String>,\n    requester_pubkey: String,\n    invite_event_json: Option<serde_json::Value>,\n    invite_event_id: Option<String>,\n    invite_max_uses: Option<i64>,\n    requested_at: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct JoinRequestPayload {\n    schema: String,\n    topic: Option<String>,\n    scope: Option<String>,\n    invite_event_json: Option<serde_json::Value>,\n    requester: Option<String>,\n    requested_at: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct KeyEnvelopePayload {\n    schema: String,\n    topic: String,\n    scope: String,\n    epoch: i64,\n    key_b64: String,\n    issued_at: Option<i64>,\n}\n\nstruct InviteValidation {\n    topic_id: String,\n    issuer_pubkey: String,\n    event_id: String,\n    max_uses: i64,\n}\n\nfn validate_invite_event(\n    value: &serde_json::Value,\n    expected_topic: Option<&str>,\n) -> Result<InviteValidation, AppError> {\n    let event: nostr_sdk::Event = serde_json::from_value(value.clone())\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n    if event.kind.as_u16() as u32 != KIND_INVITE_CAPABILITY {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid invite event kind\",\n        ));\n    }\n    let tags = event\n        .tags\n        .iter()\n        .map(|tag| tag.clone().to_vec())\n        .collect::<Vec<_>>();\n    validate_kip_tags(&tags)?;\n    let topic_id = require_tag_value(&tags, \"t\")?;\n    if let Some(expected) = expected_topic {\n        if expected != topic_id {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite topic mismatch\",\n            ));\n        }\n    }\n    let scope = require_tag_value(&tags, \"scope\")?;\n    if scope != \"invite\" {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite scope must be invite\",\n        ));\n    }\n    let invite_d = require_tag_value(&tags, \"d\")?;\n    if !invite_d.starts_with(\"invite:\") {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite d tag is invalid\",\n        ));\n    }\n    if event.verify().is_err() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite signature is invalid\",\n        ));\n    }\n\n    let payload: InvitePayload = serde_json::from_str(&event.content)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    if payload.schema != \"kukuri-invite-v1\" {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid invite schema\",\n        ));\n    }\n    if let Some(topic) = payload.topic.as_ref() {\n        if topic != &topic_id {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite topic mismatch\",\n            ));\n        }\n    }\n    if let Some(scope) = payload.scope.as_ref() {\n        if scope != \"invite\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite scope mismatch\",\n            ));\n        }\n    }\n    if let Some(expires) = payload.expires {\n        if expires <= Utc::now().timestamp() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite has expired\",\n            ));\n        }\n    }\n    let max_uses = payload.max_uses.unwrap_or(1);\n    if max_uses <= 0 {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite max_uses must be positive\",\n        ));\n    }\n    if let Some(nonce) = payload.nonce.as_ref() {\n        if nonce.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite nonce is empty\",\n            ));\n        }\n        let expected = format!(\"invite:{nonce}\");\n        if invite_d != expected {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite nonce mismatch\",\n            ));\n        }\n    }\n\n    if let Some(issuer) = payload.issuer.as_ref() {\n        if let Some(hex) = issuer.strip_prefix(\"pubkey:\") {\n            if hex != event.pubkey.to_string() {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Invite issuer mismatch\",\n                ));\n            }\n        }\n    }\n\n    Ok(InviteValidation {\n        topic_id,\n        issuer_pubkey: event.pubkey.to_string(),\n        event_id: event.id.to_string(),\n        max_uses,\n    })\n}\n\n#[derive(Debug, Deserialize)]\nstruct InvitePayload {\n    schema: String,\n    topic: Option<String>,\n    scope: Option<String>,\n    expires: Option<i64>,\n    max_uses: Option<i64>,\n    nonce: Option<String>,\n    issuer: Option<String>,\n}\n\nfn validate_kip_tags(tags: &[Vec<String>]) -> Result<(), AppError> {\n    let namespace = require_tag_value(tags, \"k\")?;\n    if namespace != KIP_NAMESPACE {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid k tag\",\n        ));\n    }\n    let ver = require_tag_value(tags, \"ver\")?;\n    if ver != KIP_VERSION {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid ver tag\",\n        ));\n    }\n    Ok(())\n}\n\nfn tag_value(tags: &[Vec<String>], name: &str) -> Option<String> {\n    tags.iter()\n        .find(|tag| tag.first().map(|v| v.as_str()) == Some(name))\n        .and_then(|tag| tag.get(1))\n        .cloned()\n}\n\nfn require_tag_value(tags: &[Vec<String>], name: &str) -> Result<String, AppError> {\n    tag_value(tags, name).ok_or_else(|| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Missing {name} tag\"),\n        )\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::group_key_store::GroupKeyEntry;\n    use crate::application::ports::join_request_store::{InviteUsageRecord, JoinRequestStore};\n    use crate::application::ports::key_manager::KeyPair;\n    use crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\n    use crate::domain::entities::User;\n    use crate::infrastructure::crypto::DefaultSignatureService;\n    use async_trait::async_trait;\n    use chrono::{TimeZone, Utc};\n    use nostr_sdk::ToBech32;\n    use nostr_sdk::prelude::{EventBuilder, Keys, Kind, Tag};\n    use std::collections::{HashMap, HashSet};\n    use tokio::sync::RwLock;\n\n    #[derive(Clone)]\n    struct TestKeyManager {\n        keypair: KeyPair,\n    }\n\n    impl TestKeyManager {\n        fn new(keypair: KeyPair) -> Self {\n            Self { keypair }\n        }\n    }\n\n    #[async_trait]\n    impl KeyManager for TestKeyManager {\n        async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n            Err(AppError::NotImplemented(\"generate_keypair\".into()))\n        }\n\n        async fn import_private_key(&self, _nsec: &str) -> Result<KeyPair, AppError> {\n            Err(AppError::NotImplemented(\"import_private_key\".into()))\n        }\n\n        async fn export_private_key(&self, _npub: &str) -> Result<String, AppError> {\n            Err(AppError::NotImplemented(\"export_private_key\".into()))\n        }\n\n        async fn get_public_key(&self, _npub: &str) -> Result<String, AppError> {\n            Err(AppError::NotImplemented(\"get_public_key\".into()))\n        }\n\n        async fn store_keypair(&self, _keypair: &KeyPair) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"store_keypair\".into()))\n        }\n\n        async fn delete_keypair(&self, _npub: &str) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"delete_keypair\".into()))\n        }\n\n        async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n            Ok(vec![self.keypair.npub.clone()])\n        }\n\n        async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n            Ok(self.keypair.clone())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestGroupKeyStore {\n        records: Arc<RwLock<Vec<GroupKeyRecord>>>,\n    }\n\n    impl TestGroupKeyStore {\n        async fn latest_key(&self, topic_id: &str, scope: &str) -> Option<GroupKeyRecord> {\n            let records = self.records.read().await;\n            records\n                .iter()\n                .filter(|record| record.topic_id == topic_id && record.scope == scope)\n                .max_by_key(|record| record.epoch)\n                .cloned()\n        }\n    }\n\n    #[async_trait]\n    impl GroupKeyStore for TestGroupKeyStore {\n        async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            records.retain(|existing| {\n                !(existing.topic_id == record.topic_id\n                    && existing.scope == record.scope\n                    && existing.epoch == record.epoch)\n            });\n            records.push(record);\n            Ok(())\n        }\n\n        async fn get_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n            epoch: i64,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .iter()\n                .find(|record| {\n                    record.topic_id == topic_id && record.scope == scope && record.epoch == epoch\n                })\n                .cloned())\n        }\n\n        async fn get_latest_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            Ok(self.latest_key(topic_id, scope).await)\n        }\n\n        async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .iter()\n                .map(|record| GroupKeyEntry {\n                    topic_id: record.topic_id.clone(),\n                    scope: record.scope.clone(),\n                    epoch: record.epoch,\n                    stored_at: record.stored_at,\n                })\n                .collect())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestJoinRequestStore {\n        records: Arc<RwLock<HashMap<String, HashMap<String, JoinRequestRecord>>>>,\n        invite_usage: Arc<RwLock<HashMap<String, HashMap<String, InviteUsageRecord>>>>,\n    }\n\n    #[async_trait]\n    impl JoinRequestStore for TestJoinRequestStore {\n        async fn upsert_request(\n            &self,\n            owner_pubkey: &str,\n            record: JoinRequestRecord,\n        ) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            let owner = records.entry(owner_pubkey.to_string()).or_default();\n            owner.insert(record.event.id.clone(), record);\n            Ok(())\n        }\n\n        async fn list_requests(\n            &self,\n            owner_pubkey: &str,\n        ) -> Result<Vec<JoinRequestRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .map(|owner| owner.values().cloned().collect())\n                .unwrap_or_default())\n        }\n\n        async fn get_request(\n            &self,\n            owner_pubkey: &str,\n            event_id: &str,\n        ) -> Result<Option<JoinRequestRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .and_then(|owner| owner.get(event_id).cloned()))\n        }\n\n        async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            if let Some(owner) = records.get_mut(owner_pubkey) {\n                owner.remove(event_id);\n            }\n            Ok(())\n        }\n\n        async fn get_invite_usage(\n            &self,\n            owner_pubkey: &str,\n            invite_event_id: &str,\n        ) -> Result<Option<InviteUsageRecord>, AppError> {\n            let records = self.invite_usage.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .and_then(|owner| owner.get(invite_event_id).cloned()))\n        }\n\n        async fn upsert_invite_usage(\n            &self,\n            owner_pubkey: &str,\n            record: InviteUsageRecord,\n        ) -> Result<(), AppError> {\n            let mut records = self.invite_usage.write().await;\n            let owner = records.entry(owner_pubkey.to_string()).or_default();\n            owner.insert(record.invite_event_id.clone(), record);\n            Ok(())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestUserRepository {\n        follows: Arc<RwLock<HashSet<(String, String)>>>,\n    }\n\n    impl TestUserRepository {\n        async fn seed_follow(&self, follower: &str, followed: &str) {\n            let mut follows = self.follows.write().await;\n            follows.insert((follower.to_string(), followed.to_string()));\n        }\n    }\n\n    #[async_trait]\n    impl UserRepository for TestUserRepository {\n        async fn create_user(&self, _user: &User) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"create_user\".into()))\n        }\n\n        async fn get_user(&self, _npub: &str) -> Result<Option<User>, AppError> {\n            Err(AppError::NotImplemented(\"get_user\".into()))\n        }\n\n        async fn get_user_by_pubkey(&self, _pubkey: &str) -> Result<Option<User>, AppError> {\n            Err(AppError::NotImplemented(\"get_user_by_pubkey\".into()))\n        }\n\n        async fn search_users(&self, _query: &str, _limit: usize) -> Result<Vec<User>, AppError> {\n            Err(AppError::NotImplemented(\"search_users\".into()))\n        }\n\n        async fn update_user(&self, _user: &User) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"update_user\".into()))\n        }\n\n        async fn delete_user(&self, _npub: &str) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"delete_user\".into()))\n        }\n\n        async fn get_followers_paginated(\n            &self,\n            _npub: &str,\n            _cursor: Option<&str>,\n            _limit: usize,\n            _sort: FollowListSort,\n            _search: Option<&str>,\n        ) -> Result<UserCursorPage, AppError> {\n            Err(AppError::NotImplemented(\"get_followers_paginated\".into()))\n        }\n\n        async fn get_following_paginated(\n            &self,\n            _npub: &str,\n            _cursor: Option<&str>,\n            _limit: usize,\n            _sort: FollowListSort,\n            _search: Option<&str>,\n        ) -> Result<UserCursorPage, AppError> {\n            Err(AppError::NotImplemented(\"get_following_paginated\".into()))\n        }\n\n        async fn add_follow_relation(\n            &self,\n            follower_pubkey: &str,\n            followed_pubkey: &str,\n        ) -> Result<bool, AppError> {\n            let mut follows = self.follows.write().await;\n            Ok(follows.insert((\n                follower_pubkey.to_string(),\n                followed_pubkey.to_string(),\n            )))\n        }\n\n        async fn remove_follow_relation(\n            &self,\n            follower_pubkey: &str,\n            followed_pubkey: &str,\n        ) -> Result<bool, AppError> {\n            let mut follows = self.follows.write().await;\n            Ok(follows.remove(&(\n                follower_pubkey.to_string(),\n                followed_pubkey.to_string(),\n            )))\n        }\n\n        async fn list_following_pubkeys(\n            &self,\n            follower_pubkey: &str,\n        ) -> Result<Vec<String>, AppError> {\n            let follows = self.follows.read().await;\n            Ok(follows\n                .iter()\n                .filter_map(|(follower, followed)| {\n                    if follower == follower_pubkey {\n                        Some(followed.clone())\n                    } else {\n                        None\n                    }\n                })\n                .collect())\n        }\n\n        async fn list_follower_pubkeys(\n            &self,\n            followed_pubkey: &str,\n        ) -> Result<Vec<String>, AppError> {\n            let follows = self.follows.read().await;\n            Ok(follows\n                .iter()\n                .filter_map(|(follower, followed)| {\n                    if followed == followed_pubkey {\n                        Some(follower.clone())\n                    } else {\n                        None\n                    }\n                })\n                .collect())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestGossipService {\n        joined: Arc<RwLock<HashSet<String>>>,\n        broadcasts: Arc<RwLock<Vec<(String, Event)>>>,\n    }\n\n    impl TestGossipService {\n        async fn broadcasts(&self) -> Vec<(String, Event)> {\n            self.broadcasts.read().await.clone()\n        }\n    }\n\n    #[async_trait]\n    impl GossipService for TestGossipService {\n        async fn join_topic(\n            &self,\n            topic: &str,\n            _initial_peers: Vec<String>,\n        ) -> Result<(), AppError> {\n            self.joined.write().await.insert(topic.to_string());\n            Ok(())\n        }\n\n        async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n            self.joined.write().await.remove(topic);\n            Ok(())\n        }\n\n        async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n            self.broadcasts\n                .write()\n                .await\n                .push((topic.to_string(), event.clone()));\n            Ok(())\n        }\n\n        async fn subscribe(\n            &self,\n            _topic: &str,\n        ) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError> {\n            Err(AppError::NotImplemented(\"subscribe\".into()))\n        }\n\n        async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n            Ok(self.joined.read().await.iter().cloned().collect())\n        }\n\n        async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n            Err(AppError::NotImplemented(\"get_topic_peers\".into()))\n        }\n\n        async fn get_topic_stats(\n            &self,\n            _topic: &str,\n        ) -> Result<Option<crate::domain::p2p::TopicStats>, AppError> {\n            Err(AppError::NotImplemented(\"get_topic_stats\".into()))\n        }\n\n        async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"broadcast_message\".into()))\n        }\n    }\n\n    fn make_keypair() -> (Keys, KeyPair) {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_string();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let npub = keys\n            .public_key()\n            .to_bech32()\n            .unwrap_or_else(|_| public_key.clone());\n        let nsec = format!(\"nsec1{private_key}\");\n        let keypair = KeyPair {\n            public_key,\n            private_key,\n            npub,\n            nsec,\n        };\n        (keys, keypair)\n    }\n\n    fn domain_event_from_nostr(event: &nostr_sdk::Event) -> Event {\n        let created_at = Utc\n            .timestamp_opt(event.created_at.as_secs() as i64, 0)\n            .single()\n            .expect(\"timestamp\");\n        Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn issue_invite_creates_event_and_group_key() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let invite_json = service\n            .issue_invite(\"kukuri:topic1\", Some(600), Some(2), Some(\"nonce-1\".into()))\n            .await\n            .expect(\"invite\");\n\n        let event: nostr_sdk::Event = serde_json::from_value(invite_json).expect(\"nostr event\");\n        assert_eq!(event.kind.as_u16() as u32, KIND_INVITE_CAPABILITY);\n\n        let tags = event\n            .tags\n            .iter()\n            .map(|tag| tag.clone().to_vec())\n            .collect::<Vec<_>>();\n        assert_eq!(tag_value(&tags, \"t\"), Some(\"kukuri:topic1\".to_string()));\n        assert_eq!(tag_value(&tags, \"scope\"), Some(\"invite\".to_string()));\n        assert_eq!(tag_value(&tags, \"k\"), Some(KIP_NAMESPACE.to_string()));\n        assert_eq!(tag_value(&tags, \"ver\"), Some(KIP_VERSION.to_string()));\n        assert_eq!(tag_value(&tags, \"d\"), Some(\"invite:nonce-1\".to_string()));\n\n        let stored = group_key_store\n            .get_latest_key(\"kukuri:topic1\", \"invite\")\n            .await\n            .expect(\"store\")\n            .expect(\"group key\");\n        assert_eq!(stored.scope, \"invite\");\n    }\n\n    #[tokio::test]\n    async fn request_join_with_invite_broadcasts_to_issuer_topic() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let invite_json = service\n            .issue_invite(\"kukuri:topic1\", Some(600), Some(1), Some(\"nonce-2\".into()))\n            .await\n            .expect(\"invite\");\n        let invite_event: nostr_sdk::Event =\n            serde_json::from_value(invite_json.clone()).expect(\"nostr event\");\n\n        let result = service\n            .request_join(JoinRequestInput {\n                topic_id: None,\n                scope: None,\n                invite_event_json: Some(invite_json),\n                target_pubkey: None,\n                broadcast_to_topic: false,\n            })\n            .await\n            .expect(\"join request\");\n\n        let issuer_topic = user_topic_id(&invite_event.pubkey.to_string());\n        assert!(result.sent_topics.contains(&issuer_topic));\n\n        let broadcasts = gossip_service.broadcasts().await;\n        assert_eq!(broadcasts.len(), 1);\n        let (topic, event) = &broadcasts[0];\n        assert_eq!(topic, &issuer_topic);\n        assert_eq!(event.kind, KIND_JOIN_REQUEST);\n\n        let tags = event.tags.clone();\n        assert_eq!(tag_value(&tags, \"e\"), Some(invite_event.id.to_string()));\n        assert_eq!(tag_value(&tags, \"p\"), Some(invite_event.pubkey.to_string()));\n    }\n\n    #[tokio::test]\n    async fn validate_invite_event_rejects_nonce_mismatch() {\n        let (keys, keypair) = make_keypair();\n        let topic_id = \"kukuri:topic1\";\n\n        let content = json!({\n            \"schema\": \"kukuri-invite-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"invite\",\n            \"expires\": Utc::now().timestamp() + 600,\n            \"max_uses\": 1,\n            \"nonce\": \"nonce-1\",\n            \"issuer\": format!(\"pubkey:{}\", keypair.public_key),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"invite\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"invite:nonce-2\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_INVITE_CAPABILITY as u16), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"signed\");\n\n        let value = serde_json::to_value(nostr_event).expect(\"value\");\n        let err = match validate_invite_event(&value, Some(topic_id)) {\n            Ok(_) => panic!(\"should fail\"),\n            Err(err) => err,\n        };\n        assert_eq!(err.validation_message(), Some(\"Invite nonce mismatch\"));\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_stores_pending_request() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let topic_id = \"kukuri:topic1\";\n        group_key_store\n            .store_key(GroupKeyRecord {\n                topic_id: topic_id.to_string(),\n                scope: \"friend\".to_string(),\n                epoch: 1,\n                key_b64: \"aGVsbG8=\".to_string(),\n                stored_at: Utc::now().timestamp(),\n            })\n            .await\n            .expect(\"store\");\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": Utc::now().timestamp(),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        service.handle_incoming_event(&event).await.expect(\"handle\");\n\n        let broadcasts = gossip_service.broadcasts().await;\n        assert!(\n            broadcasts\n                .iter()\n                .all(|(_, event)| event.kind != KIND_KEY_ENVELOPE)\n        );\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert_eq!(pending.len(), 1);\n        assert_eq!(pending[0].requester_pubkey, requester_keypair.public_key);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_detects_two_hop_mutual_follow() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let friend_pubkey = \"friend_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        user_repository\n            .seed_follow(owner_pubkey, friend_pubkey)\n            .await;\n        user_repository\n            .seed_follow(friend_pubkey, owner_pubkey)\n            .await;\n        user_repository\n            .seed_follow(friend_pubkey, requester_pubkey)\n            .await;\n        user_repository\n            .seed_follow(requester_pubkey, friend_pubkey)\n            .await;\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(is_fof);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_rejects_direct_mutual_follow_only() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        user_repository\n            .seed_follow(owner_pubkey, requester_pubkey)\n            .await;\n        user_repository\n            .seed_follow(requester_pubkey, owner_pubkey)\n            .await;\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(!is_fof);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_rejects_when_no_mutual_friend_exists() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(!is_fof);\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_rejects_invite_reuse() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n        let (requester_keys_2, requester_keypair_2) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let topic_id = \"kukuri:topic1\";\n        let invite_json = service\n            .issue_invite(topic_id, Some(600), Some(1), Some(\"nonce-reuse\".into()))\n            .await\n            .expect(\"invite\");\n        let invite_event: nostr_sdk::Event =\n            serde_json::from_value(invite_json.clone()).expect(\"nostr event\");\n        let invite_id = invite_event.id.to_string();\n        let issuer_pubkey = invite_event.pubkey.to_string();\n\n        let build_join_request = |keys: &Keys, requester_pubkey: &str, nonce: &str| {\n            let content = json!({\n                \"schema\": \"kukuri-join-request-v1\",\n                \"topic\": topic_id,\n                \"scope\": \"invite\",\n                \"requester\": format!(\"pubkey:{requester_pubkey}\"),\n                \"requested_at\": Utc::now().timestamp(),\n                \"invite_event_json\": invite_json.clone(),\n            })\n            .to_string();\n\n            let d_tag = format!(\"join:{topic_id}:{nonce}:{requester_pubkey}\");\n            let tags = vec![\n                Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n                Tag::parse([\"scope\", \"invite\"]).expect(\"tag\"),\n                Tag::parse([\"d\", d_tag.as_str()]).expect(\"tag\"),\n                Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n                Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n                Tag::parse([\"e\", invite_id.as_str()]).expect(\"tag\"),\n                Tag::parse([\"p\", issuer_pubkey.as_str()]).expect(\"tag\"),\n            ];\n\n            EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n                .tags(tags)\n                .sign_with_keys(keys)\n                .expect(\"signed\")\n        };\n\n        let event_first = domain_event_from_nostr(&build_join_request(\n            &requester_keys,\n            &requester_keypair.public_key,\n            \"nonce-1\",\n        ));\n        service\n            .handle_incoming_event(&event_first)\n            .await\n            .expect(\"first join\");\n\n        let event_second = domain_event_from_nostr(&build_join_request(\n            &requester_keys_2,\n            &requester_keypair_2.public_key,\n            \"nonce-2\",\n        ));\n        let err = service\n            .handle_incoming_event(&event_second)\n            .await\n            .expect_err(\"should reject reuse\");\n        assert_eq!(err.validation_message(), Some(\"Invite max_uses exceeded\"));\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert_eq!(pending.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn approve_join_request_sends_key_envelope_and_clears_pending() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let topic_id = \"kukuri:topic1\";\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": Utc::now().timestamp(),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        service.handle_incoming_event(&event).await.expect(\"handle\");\n\n        let approval = service\n            .approve_join_request(&event.id)\n            .await\n            .expect(\"approve\");\n        assert_eq!(approval.event_id, event.id);\n\n        let broadcasts = gossip_service.broadcasts().await;\n        let expected_topic = user_topic_id(&requester_keypair.public_key);\n        assert!(\n            broadcasts\n                .iter()\n                .any(|(topic, event)| *topic == expected_topic && event.kind == KIND_KEY_ENVELOPE)\n        );\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert!(pending.is_empty());\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_rejects_negative_requested_at() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": \"kukuri:topic1\",\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": -1,\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", \"kukuri:topic1\"]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        let err = service\n            .handle_incoming_event(&event)\n            .await\n            .expect_err(\"should fail\");\n        assert_eq!(\n            err.validation_message(),\n            Some(\"Join.request requested_at is invalid\")\n        );\n    }\n}\n","traces":[{"line":69,"address":[22108209,22107744,22108298],"length":1,"stats":{"Line":2}},{"line":84,"address":[16287704],"length":1,"stats":{"Line":2}},{"line":91,"address":[22150368],"length":1,"stats":{"Line":1}},{"line":98,"address":[22048163,22047972],"length":1,"stats":{"Line":2}},{"line":99,"address":[22048403,22048229],"length":1,"stats":{"Line":0}},{"line":100,"address":[22152749],"length":1,"stats":{"Line":0}},{"line":105,"address":[11695939],"length":1,"stats":{"Line":2}},{"line":106,"address":[22248344,22248502],"length":1,"stats":{"Line":2}},{"line":107,"address":[22116993],"length":1,"stats":{"Line":1}},{"line":108,"address":[22153857],"length":1,"stats":{"Line":1}},{"line":109,"address":[22148329],"length":1,"stats":{"Line":1}},{"line":110,"address":[22257629,22248813,22257616],"length":1,"stats":{"Line":1}},{"line":112,"address":[22117355,22115825,22117458,22117566,22124724],"length":1,"stats":{"Line":2}},{"line":114,"address":[22149405,22155711,22149454,22151307,22151163],"length":1,"stats":{"Line":3}},{"line":121,"address":[22156713,22156791],"length":1,"stats":{"Line":2}},{"line":125,"address":[22256069,22252205,22255930,22252599,22255453,22253686,22253617,22254946,22252668,22252149,22254130,22255577,22255782,22255997,22254571,22253058,22253127,22254064,22254505],"length":1,"stats":{"Line":1}},{"line":126,"address":[22120705,22124512,22120638],"length":1,"stats":{"Line":2}},{"line":127,"address":[22121101,22121165,22124421],"length":1,"stats":{"Line":2}},{"line":128,"address":[22152808,22155557,22152744],"length":1,"stats":{"Line":2}},{"line":129,"address":[22040599,22040663,22042686],"length":1,"stats":{"Line":2}},{"line":130,"address":[22115638,22115696,22117073],"length":1,"stats":{"Line":2}},{"line":131,"address":[22254559,22255448,22254617],"length":1,"stats":{"Line":2}},{"line":134,"address":[22154895,22155013,22156085,22154946,22156367,22157053,22156155],"length":1,"stats":{"Line":5}},{"line":135,"address":[16296507],"length":1,"stats":{"Line":1}},{"line":136,"address":[11657876],"length":1,"stats":{"Line":3}},{"line":137,"address":[22156665,22156297,22156456],"length":1,"stats":{"Line":2}},{"line":138,"address":[22118506,22118679],"length":1,"stats":{"Line":2}},{"line":139,"address":[22044608,22044626],"length":1,"stats":{"Line":0}},{"line":142,"address":[22161408],"length":1,"stats":{"Line":1}},{"line":146,"address":[11696511],"length":1,"stats":{"Line":2}},{"line":147,"address":[22059834],"length":1,"stats":{"Line":1}},{"line":148,"address":[22127769,22127836],"length":1,"stats":{"Line":2}},{"line":149,"address":[22163024],"length":1,"stats":{"Line":1}},{"line":151,"address":[22127927,22128359,22136170],"length":1,"stats":{"Line":1}},{"line":153,"address":[22121879,22121597,22121394],"length":1,"stats":{"Line":3}},{"line":154,"address":[22174656,22163980,22163698,22163765],"length":1,"stats":{"Line":2}},{"line":155,"address":[16312450],"length":1,"stats":{"Line":0}},{"line":156,"address":[22139553],"length":1,"stats":{"Line":0}},{"line":157,"address":[22132630],"length":1,"stats":{"Line":0}},{"line":162,"address":[16308944,16302207,16302666,16308867,16301781,16303448,16308719,16304297,16301814,16303379,16302276,16301395,16302735,16308514,16308915,16303838,16303907],"length":1,"stats":{"Line":2}},{"line":163,"address":[22267707,22260567,22260634],"length":1,"stats":{"Line":2}},{"line":164,"address":[22261029,22261093,22267678],"length":1,"stats":{"Line":2}},{"line":165,"address":[16302886,16308862,16302720,16302823,16303196,16302784],"length":1,"stats":{"Line":3}},{"line":166,"address":[22166776],"length":1,"stats":{"Line":1}},{"line":167,"address":[15093947,15094007],"length":1,"stats":{"Line":2}},{"line":169,"address":[22165769,22171031,22165833],"length":1,"stats":{"Line":2}},{"line":170,"address":[22063412,22063348,22067946],"length":1,"stats":{"Line":2}},{"line":173,"address":[22057191,22057101],"length":1,"stats":{"Line":2}},{"line":174,"address":[22058176,22050460,22058185,22050536],"length":1,"stats":{"Line":4}},{"line":175,"address":[22263748,22264193],"length":1,"stats":{"Line":1}},{"line":178,"address":[16305438,16304795],"length":1,"stats":{"Line":2}},{"line":179,"address":[22057979,22058052],"length":1,"stats":{"Line":2}},{"line":182,"address":[16305950,16305554,16308347,16306884,16307028],"length":1,"stats":{"Line":3}},{"line":186,"address":[15097980,15097902],"length":1,"stats":{"Line":2}},{"line":189,"address":[22127924,22128358],"length":1,"stats":{"Line":2}},{"line":190,"address":[15099115,15098769,15098901],"length":1,"stats":{"Line":1}},{"line":193,"address":[22170549,22171495,22170151,22172847,22171575,22171791,22170616],"length":1,"stats":{"Line":5}},{"line":194,"address":[22067616,22067288],"length":1,"stats":{"Line":2}},{"line":195,"address":[22166653,22166713,22167561,22157980,22167413,22167807],"length":1,"stats":{"Line":3}},{"line":197,"address":[22173362],"length":1,"stats":{"Line":1}},{"line":198,"address":[22136774],"length":1,"stats":{"Line":1}},{"line":199,"address":[16309789,16309668],"length":1,"stats":{"Line":2}},{"line":201,"address":[15100688],"length":1,"stats":{"Line":1}},{"line":202,"address":[22137148],"length":1,"stats":{"Line":0}},{"line":205,"address":[22137118,22137226],"length":1,"stats":{"Line":2}},{"line":206,"address":[22137335,22137653],"length":1,"stats":{"Line":0}},{"line":207,"address":[22069567],"length":1,"stats":{"Line":0}},{"line":212,"address":[22062496,22062641],"length":1,"stats":{"Line":2}},{"line":213,"address":[11658448],"length":1,"stats":{"Line":2}},{"line":215,"address":[16310984],"length":1,"stats":{"Line":1}},{"line":216,"address":[16310827],"length":1,"stats":{"Line":1}},{"line":217,"address":[22269714],"length":1,"stats":{"Line":1}},{"line":221,"address":[22271296,22271439,22271280,22271655,22271497,22271288,22271334,22272591],"length":1,"stats":{"Line":0}},{"line":222,"address":[22174976,22175034,22175255,22175112,22175804,22176109],"length":1,"stats":{"Line":0}},{"line":223,"address":[15104296,15104774,15104523,15104578],"length":1,"stats":{"Line":0}},{"line":224,"address":[22177605],"length":1,"stats":{"Line":0}},{"line":225,"address":[22141048,22141249,22139932,22140961,22140914],"length":1,"stats":{"Line":0}},{"line":228,"address":[22272896],"length":1,"stats":{"Line":1}},{"line":232,"address":[11699154],"length":1,"stats":{"Line":2}},{"line":233,"address":[22068077,22067884],"length":1,"stats":{"Line":2}},{"line":234,"address":[22075134,22075477],"length":1,"stats":{"Line":0}},{"line":235,"address":[22179654],"length":1,"stats":{"Line":0}},{"line":240,"address":[22143178,22142840,22143512,22143095,22143592,22143776,22144320],"length":1,"stats":{"Line":5}},{"line":242,"address":[22179778],"length":1,"stats":{"Line":1}},{"line":243,"address":[22174556,22174912,22174384,22172939,22174319,22174698],"length":1,"stats":{"Line":3}},{"line":245,"address":[22275732],"length":1,"stats":{"Line":0}},{"line":248,"address":[22062342,22062962,22063042,22063226,22063948,22062575,22062529],"length":1,"stats":{"Line":5}},{"line":249,"address":[22175069],"length":1,"stats":{"Line":1}},{"line":250,"address":[11742900],"length":1,"stats":{"Line":3}},{"line":252,"address":[22145338],"length":1,"stats":{"Line":0}},{"line":253,"address":[22077499],"length":1,"stats":{"Line":0}},{"line":257,"address":[16318596,16318960,16319215,16317649,16317928,16317882,16318422],"length":1,"stats":{"Line":5}},{"line":258,"address":[22180140,22180008],"length":1,"stats":{"Line":2}},{"line":259,"address":[16314581,16318301,16318518,16318912,16317901,16317961],"length":1,"stats":{"Line":3}},{"line":260,"address":[22064798,22065423,22064844,22064552,22065091,22065171,22066055],"length":1,"stats":{"Line":5}},{"line":261,"address":[22139167,22139375],"length":1,"stats":{"Line":2}},{"line":262,"address":[22146613,22146397,22146895,22146337,22141818,22146462],"length":1,"stats":{"Line":3}},{"line":263,"address":[22279122,22278429,22278588],"length":1,"stats":{"Line":2}},{"line":264,"address":[16320731,16320244,16320111,16321014,16320405,16314623],"length":1,"stats":{"Line":2}},{"line":266,"address":[22183614,22185503,22183488,22183298,22184294,22183239,22183027],"length":1,"stats":{"Line":5}},{"line":267,"address":[22073316],"length":1,"stats":{"Line":1}},{"line":268,"address":[22173044,22179331,22179384,22179445,22179600,22180310],"length":1,"stats":{"Line":3}},{"line":270,"address":[22081052],"length":1,"stats":{"Line":1}},{"line":271,"address":[22183670],"length":1,"stats":{"Line":1}},{"line":272,"address":[15111937],"length":1,"stats":{"Line":1}},{"line":273,"address":[22148653],"length":1,"stats":{"Line":1}},{"line":274,"address":[22185474],"length":1,"stats":{"Line":1}},{"line":275,"address":[22074023],"length":1,"stats":{"Line":1}},{"line":279,"address":[22144128,22145652,22144301,22144080,22144359,22144172,22144098,22144517],"length":1,"stats":{"Line":0}},{"line":280,"address":[11037553],"length":1,"stats":{"Line":0}},{"line":281,"address":[22183182,22183361],"length":1,"stats":{"Line":0}},{"line":282,"address":[22070955,22070723],"length":1,"stats":{"Line":0}},{"line":283,"address":[22283787],"length":1,"stats":{"Line":0}},{"line":287,"address":[15115487,15116076,15116186,15115706,15115651,15115954],"length":1,"stats":{"Line":0}},{"line":288,"address":[22183489],"length":1,"stats":{"Line":0}},{"line":289,"address":[11701797],"length":1,"stats":{"Line":0}},{"line":290,"address":[22187975],"length":1,"stats":{"Line":0}},{"line":293,"address":[22184192,22184481,22184160,22184682,22184173,22184227,22185085,22184352],"length":1,"stats":{"Line":5}},{"line":294,"address":[22153136],"length":1,"stats":{"Line":3}},{"line":295,"address":[22184379,22184714,22184525,22184433],"length":1,"stats":{"Line":5}},{"line":296,"address":[19404949],"length":1,"stats":{"Line":0}},{"line":299,"address":[15116474],"length":1,"stats":{"Line":1}},{"line":302,"address":[16327040,16327088,16327385,16327150,16327738,16327533,16328775,16327053],"length":1,"stats":{"Line":12}},{"line":303,"address":[16327343,16327415,16327770,16327599],"length":1,"stats":{"Line":6}},{"line":304,"address":[22286958],"length":1,"stats":{"Line":3}},{"line":305,"address":[22073975],"length":1,"stats":{"Line":0}},{"line":307,"address":[15119350,15118959,15119514,15118989,15120174,15118707,15119268],"length":1,"stats":{"Line":13}},{"line":308,"address":[16328351],"length":1,"stats":{"Line":3}},{"line":309,"address":[22187184,22187002,22187062,22187530,22185836,22187326],"length":1,"stats":{"Line":8}},{"line":311,"address":[22075528],"length":1,"stats":{"Line":0}},{"line":314,"address":[15119939,15120018,15121303,15119656,15120746,15120385,15120467,15120666],"length":1,"stats":{"Line":6}},{"line":316,"address":[22288237],"length":1,"stats":{"Line":2}},{"line":317,"address":[11699556],"length":1,"stats":{"Line":3}},{"line":320,"address":[22289776],"length":1,"stats":{"Line":0}},{"line":323,"address":[16330512],"length":1,"stats":{"Line":1}},{"line":327,"address":[22195391,22194925,22196030,22194737,22194866,22195139,22195255],"length":1,"stats":{"Line":5}},{"line":329,"address":[22289545],"length":1,"stats":{"Line":1}},{"line":332,"address":[16327478,16330974,16331359,16330914,16331044,16331203],"length":1,"stats":{"Line":3}},{"line":334,"address":[22290219,22291095,22290091],"length":1,"stats":{"Line":3}},{"line":335,"address":[16334896,16332015,16331752,16331487],"length":1,"stats":{"Line":1}},{"line":336,"address":[15125052],"length":1,"stats":{"Line":0}},{"line":338,"address":[22152085,22151952],"length":1,"stats":{"Line":2}},{"line":339,"address":[22196259,22196143,22195789,22195932,22196364,22197476],"length":1,"stats":{"Line":6}},{"line":340,"address":[11618086],"length":1,"stats":{"Line":4}},{"line":344,"address":[22151745],"length":1,"stats":{"Line":1}},{"line":345,"address":[22091915],"length":1,"stats":{"Line":1}},{"line":346,"address":[22159728],"length":1,"stats":{"Line":1}},{"line":347,"address":[15122762],"length":1,"stats":{"Line":1}},{"line":348,"address":[22159834],"length":1,"stats":{"Line":1}},{"line":349,"address":[16332671],"length":1,"stats":{"Line":1}},{"line":350,"address":[22092162,22092225],"length":1,"stats":{"Line":2}},{"line":351,"address":[22291561],"length":1,"stats":{"Line":1}},{"line":354,"address":[22191698,22191493,22191757,22192005,22192270,22192121],"length":1,"stats":{"Line":5}},{"line":355,"address":[15123391],"length":1,"stats":{"Line":1}},{"line":356,"address":[22079349,22079518,22079075,22079022,22079193,22073216],"length":1,"stats":{"Line":3}},{"line":357,"address":[22196109],"length":1,"stats":{"Line":1}},{"line":360,"address":[15125104],"length":1,"stats":{"Line":3}},{"line":365,"address":[22197614,22197747],"length":1,"stats":{"Line":6}},{"line":366,"address":[22162667],"length":1,"stats":{"Line":0}},{"line":368,"address":[15125634,15125561],"length":1,"stats":{"Line":6}},{"line":369,"address":[22088063,22088136],"length":1,"stats":{"Line":6}},{"line":370,"address":[22294731],"length":1,"stats":{"Line":0}},{"line":374,"address":[22081593],"length":1,"stats":{"Line":2}},{"line":375,"address":[22088988,22088646,22088770,22094431],"length":1,"stats":{"Line":6}},{"line":376,"address":[15126958,15126555,15126756,15131820],"length":1,"stats":{"Line":6}},{"line":377,"address":[22101359,22096301,22096495],"length":1,"stats":{"Line":6}},{"line":378,"address":[22087594,22082987,22083154],"length":1,"stats":{"Line":3}},{"line":379,"address":[22164636,22164775],"length":1,"stats":{"Line":6}},{"line":380,"address":[22097037,22097170],"length":1,"stats":{"Line":5}},{"line":381,"address":[22090216],"length":1,"stats":{"Line":0}},{"line":383,"address":[22296685],"length":1,"stats":{"Line":0}},{"line":384,"address":[22200111],"length":1,"stats":{"Line":0}},{"line":385,"address":[22097239],"length":1,"stats":{"Line":0}},{"line":389,"address":[22083777,22083358],"length":1,"stats":{"Line":3}},{"line":390,"address":[15128159,15128249],"length":1,"stats":{"Line":3}},{"line":391,"address":[22202345,22202262],"length":1,"stats":{"Line":2}},{"line":392,"address":[22084063],"length":1,"stats":{"Line":0}},{"line":396,"address":[22196850,22196712,22197129,22200293],"length":1,"stats":{"Line":3}},{"line":397,"address":[15133312,15128686,15133330],"length":1,"stats":{"Line":0}},{"line":398,"address":[22297589,22297413],"length":1,"stats":{"Line":6}},{"line":399,"address":[22297634,22300614],"length":1,"stats":{"Line":0}},{"line":400,"address":[22159146],"length":1,"stats":{"Line":0}},{"line":404,"address":[15128909,15128824],"length":1,"stats":{"Line":6}},{"line":405,"address":[22202953,22203050],"length":1,"stats":{"Line":6}},{"line":406,"address":[22091560],"length":1,"stats":{"Line":0}},{"line":407,"address":[22166288],"length":1,"stats":{"Line":0}},{"line":412,"address":[22091505,22091675],"length":1,"stats":{"Line":6}},{"line":413,"address":[15129230,15129324],"length":1,"stats":{"Line":6}},{"line":414,"address":[15129338],"length":1,"stats":{"Line":0}},{"line":415,"address":[16339348],"length":1,"stats":{"Line":0}},{"line":420,"address":[22298218,22298072],"length":1,"stats":{"Line":6}},{"line":421,"address":[22159791,22159848],"length":1,"stats":{"Line":6}},{"line":422,"address":[22202016],"length":1,"stats":{"Line":3}},{"line":423,"address":[22092219],"length":1,"stats":{"Line":0}},{"line":424,"address":[22085427],"length":1,"stats":{"Line":0}},{"line":430,"address":[22085219,22085521],"length":1,"stats":{"Line":6}},{"line":431,"address":[22085541],"length":1,"stats":{"Line":3}},{"line":432,"address":[16339939],"length":1,"stats":{"Line":1}},{"line":433,"address":[22202267],"length":1,"stats":{"Line":1}},{"line":439,"address":[22085547],"length":1,"stats":{"Line":2}},{"line":440,"address":[22160164],"length":1,"stats":{"Line":2}},{"line":441,"address":[22160368,22160183],"length":1,"stats":{"Line":4}},{"line":442,"address":[22162132,22163872,22160410,22160667],"length":1,"stats":{"Line":1}},{"line":443,"address":[22302364],"length":1,"stats":{"Line":0}},{"line":445,"address":[16340470,16341810,16340296,16340785],"length":1,"stats":{"Line":2}},{"line":446,"address":[22093243,22093394],"length":1,"stats":{"Line":2}},{"line":447,"address":[22203426],"length":1,"stats":{"Line":1}},{"line":448,"address":[22161444],"length":1,"stats":{"Line":1}},{"line":449,"address":[22168461,22168507],"length":1,"stats":{"Line":2}},{"line":450,"address":[22205281],"length":1,"stats":{"Line":0}},{"line":454,"address":[22198486,22199806],"length":1,"stats":{"Line":4}},{"line":455,"address":[22170520,22169473,22168913,22168959,22169353,22169602],"length":1,"stats":{"Line":0}},{"line":456,"address":[22087312],"length":1,"stats":{"Line":0}},{"line":457,"address":[22300484,22300797,22300953,22301106,22294109,22300544],"length":1,"stats":{"Line":0}},{"line":458,"address":[22169544],"length":1,"stats":{"Line":0}},{"line":459,"address":[22088127],"length":1,"stats":{"Line":0}},{"line":460,"address":[22204759],"length":1,"stats":{"Line":0}},{"line":466,"address":[16342667],"length":1,"stats":{"Line":1}},{"line":467,"address":[22199816],"length":1,"stats":{"Line":2}},{"line":468,"address":[22161757],"length":1,"stats":{"Line":2}},{"line":469,"address":[22094002],"length":1,"stats":{"Line":2}},{"line":470,"address":[15131499],"length":1,"stats":{"Line":2}},{"line":471,"address":[22088257],"length":1,"stats":{"Line":2}},{"line":472,"address":[22162887],"length":1,"stats":{"Line":1}},{"line":473,"address":[16342637],"length":1,"stats":{"Line":1}},{"line":474,"address":[22204995],"length":1,"stats":{"Line":1}},{"line":478,"address":[22096160,22096450,22096386,22096207,22096141,22096128,22096643,22097908],"length":1,"stats":{"Line":0}},{"line":479,"address":[11732033],"length":1,"stats":{"Line":0}},{"line":480,"address":[22164894],"length":1,"stats":{"Line":0}},{"line":481,"address":[22207038],"length":1,"stats":{"Line":0}},{"line":483,"address":[22172071,22171970],"length":1,"stats":{"Line":0}},{"line":484,"address":[22208928,22209001],"length":1,"stats":{"Line":0}},{"line":485,"address":[22304086],"length":1,"stats":{"Line":0}},{"line":489,"address":[22209242],"length":1,"stats":{"Line":0}},{"line":490,"address":[16345562,16345672,16345459,16350447],"length":1,"stats":{"Line":0}},{"line":491,"address":[22091329,22091469,22091660,22096115],"length":1,"stats":{"Line":0}},{"line":492,"address":[22105377,22105560],"length":1,"stats":{"Line":0}},{"line":493,"address":[22098629],"length":1,"stats":{"Line":0}},{"line":495,"address":[16346110,16346368,16346178,16350394],"length":1,"stats":{"Line":0}},{"line":496,"address":[22173733,22173542,22173926,22177585],"length":1,"stats":{"Line":0}},{"line":497,"address":[22214351,22211359,22210652,22211170,22210843],"length":1,"stats":{"Line":0}},{"line":499,"address":[22214000],"length":1,"stats":{"Line":0}},{"line":500,"address":[22104163],"length":1,"stats":{"Line":0}},{"line":502,"address":[22093116],"length":1,"stats":{"Line":0}},{"line":503,"address":[22106928,22109776],"length":1,"stats":{"Line":0}},{"line":504,"address":[22306232],"length":1,"stats":{"Line":0}},{"line":509,"address":[22211768,22211410,22211522,22214279],"length":1,"stats":{"Line":0}},{"line":510,"address":[22178944,22178960,22174952],"length":1,"stats":{"Line":0}},{"line":511,"address":[22093584,22095989,22093390,22093869],"length":1,"stats":{"Line":0}},{"line":512,"address":[16348125,16351904,16351888],"length":1,"stats":{"Line":0}},{"line":513,"address":[22094175,22095961,22093756,22093916],"length":1,"stats":{"Line":0}},{"line":514,"address":[22214384,22214406,22210767],"length":1,"stats":{"Line":0}},{"line":515,"address":[22212380,22214185,22212597,22213081],"length":1,"stats":{"Line":0}},{"line":516,"address":[15141922,15138714,15141904],"length":1,"stats":{"Line":0}},{"line":518,"address":[22101493,22101669,22101712],"length":1,"stats":{"Line":0}},{"line":519,"address":[22213267,22214157],"length":1,"stats":{"Line":0}},{"line":520,"address":[22211611],"length":1,"stats":{"Line":0}},{"line":524,"address":[22213410,22213179,22213313],"length":1,"stats":{"Line":0}},{"line":525,"address":[22308886,22308148],"length":1,"stats":{"Line":0}},{"line":526,"address":[22095068],"length":1,"stats":{"Line":0}},{"line":531,"address":[22104948,22104944,22101937],"length":1,"stats":{"Line":0}},{"line":533,"address":[22169803],"length":1,"stats":{"Line":0}},{"line":534,"address":[22211901],"length":1,"stats":{"Line":0}},{"line":535,"address":[22095311],"length":1,"stats":{"Line":0}},{"line":536,"address":[15139279],"length":1,"stats":{"Line":0}},{"line":539,"address":[11735989],"length":1,"stats":{"Line":0}},{"line":540,"address":[22214779],"length":1,"stats":{"Line":0}},{"line":543,"address":[22179712],"length":1,"stats":{"Line":1}},{"line":548,"address":[11609201],"length":1,"stats":{"Line":2}},{"line":549,"address":[22212032],"length":1,"stats":{"Line":0}},{"line":552,"address":[22106213],"length":1,"stats":{"Line":1}},{"line":553,"address":[22218776,22217770,22217976],"length":1,"stats":{"Line":1}},{"line":554,"address":[22099454],"length":1,"stats":{"Line":1}},{"line":555,"address":[22217648,22217669,22216280],"length":1,"stats":{"Line":0}},{"line":556,"address":[22181088,22181284],"length":1,"stats":{"Line":2}},{"line":558,"address":[22099776],"length":1,"stats":{"Line":1}},{"line":559,"address":[22099852],"length":1,"stats":{"Line":1}},{"line":562,"address":[22216612,22216675],"length":1,"stats":{"Line":2}},{"line":564,"address":[11715141],"length":1,"stats":{"Line":2}},{"line":565,"address":[22175373],"length":1,"stats":{"Line":1}},{"line":568,"address":[15145008],"length":1,"stats":{"Line":1}},{"line":573,"address":[19416623],"length":1,"stats":{"Line":2}},{"line":574,"address":[22109559,22109117,22117683,22109318],"length":1,"stats":{"Line":2}},{"line":575,"address":[22229680,22229664,22221015],"length":1,"stats":{"Line":0}},{"line":576,"address":[22109647,22117652,22109474,22109859],"length":1,"stats":{"Line":2}},{"line":577,"address":[22228176,22228192,22219667],"length":1,"stats":{"Line":0}},{"line":579,"address":[22223336,22223252,22221809,22222208,22221400,22221308,22228935,22222869],"length":1,"stats":{"Line":3}},{"line":581,"address":[22178082],"length":1,"stats":{"Line":1}},{"line":582,"address":[22110669],"length":1,"stats":{"Line":1}},{"line":584,"address":[22317618],"length":1,"stats":{"Line":1}},{"line":585,"address":[22186525,22186465],"length":1,"stats":{"Line":2}},{"line":588,"address":[22119020],"length":1,"stats":{"Line":1}},{"line":589,"address":[22318357],"length":1,"stats":{"Line":1}},{"line":590,"address":[22186822],"length":1,"stats":{"Line":1}},{"line":591,"address":[22218111],"length":1,"stats":{"Line":1}},{"line":593,"address":[22186288,22180236,22186310],"length":1,"stats":{"Line":0}},{"line":595,"address":[22218620,22218522],"length":1,"stats":{"Line":2}},{"line":597,"address":[15149322,15149514],"length":1,"stats":{"Line":2}},{"line":598,"address":[22180437],"length":1,"stats":{"Line":1}},{"line":602,"address":[16364301,16360580,16362820,16364797,16361495,16362754,16363621,16364158,16364544,16364874,16362379,16360479,16361871,16361937,16361429,16363261,16364730,16364845,16362313,16360973,16360547,16363195,16361042],"length":1,"stats":{"Line":2}},{"line":603,"address":[15154221,15150036,15149973],"length":1,"stats":{"Line":2}},{"line":604,"address":[22106787,22110536,22106723],"length":1,"stats":{"Line":2}},{"line":605,"address":[22323560,22320309,22320251],"length":1,"stats":{"Line":2}},{"line":606,"address":[22114463,22117205,22114405],"length":1,"stats":{"Line":2}},{"line":607,"address":[22222920,22220767,22220825],"length":1,"stats":{"Line":2}},{"line":608,"address":[22190082,22190024,22191493],"length":1,"stats":{"Line":2}},{"line":609,"address":[22109849,22108945,22109003],"length":1,"stats":{"Line":2}},{"line":612,"address":[22191184,22191299,22192635],"length":1,"stats":{"Line":3}},{"line":613,"address":[11754370],"length":1,"stats":{"Line":3}},{"line":616,"address":[22230240],"length":1,"stats":{"Line":1}},{"line":622,"address":[22119091,22119152,22119395,22119234,22120043,22120702],"length":1,"stats":{"Line":2}},{"line":623,"address":[22231632,22231442,22232165],"length":1,"stats":{"Line":1}},{"line":624,"address":[22226528,22226744,22226290,22226469,22227091,22226874],"length":1,"stats":{"Line":5}},{"line":625,"address":[22231985],"length":1,"stats":{"Line":1}},{"line":626,"address":[15156017,15157373,15157422,15157646,15157518],"length":1,"stats":{"Line":3}},{"line":627,"address":[22114872,22114848,22114339],"length":1,"stats":{"Line":0}},{"line":628,"address":[22121025],"length":1,"stats":{"Line":1}},{"line":631,"address":[22227823,22230406,22227712,22227735,22228100,22228021,22228754,22227776],"length":1,"stats":{"Line":4}},{"line":632,"address":[22115291],"length":1,"stats":{"Line":1}},{"line":633,"address":[22115568,22115742,22115462],"length":1,"stats":{"Line":3}},{"line":634,"address":[22115758,22115855],"length":1,"stats":{"Line":2}},{"line":635,"address":[22115932],"length":1,"stats":{"Line":1}},{"line":636,"address":[22190571],"length":1,"stats":{"Line":1}},{"line":640,"address":[22232296,22232421,22233342,22233281],"length":1,"stats":{"Line":4}},{"line":641,"address":[15161130,15160230,15158883,15159610,15160384,15160882],"length":1,"stats":{"Line":3}},{"line":642,"address":[11672059],"length":1,"stats":{"Line":4}},{"line":644,"address":[22233424],"length":1,"stats":{"Line":1}},{"line":647,"address":[22124576],"length":1,"stats":{"Line":3}},{"line":651,"address":[11098559],"length":1,"stats":{"Line":6}},{"line":652,"address":[11729922],"length":1,"stats":{"Line":6}},{"line":653,"address":[22133309,22133112],"length":1,"stats":{"Line":5}},{"line":654,"address":[22119576],"length":1,"stats":{"Line":1}},{"line":655,"address":[22333005,22332951,22333427,22332708,22332816],"length":1,"stats":{"Line":13}},{"line":656,"address":[22134020,22133733],"length":1,"stats":{"Line":4}},{"line":657,"address":[15163646],"length":1,"stats":{"Line":2}},{"line":660,"address":[22238295],"length":1,"stats":{"Line":1}},{"line":663,"address":[22127312],"length":1,"stats":{"Line":3}},{"line":668,"address":[15164228,15164091],"length":1,"stats":{"Line":6}},{"line":669,"address":[16375214],"length":1,"stats":{"Line":0}},{"line":671,"address":[11738319],"length":1,"stats":{"Line":6}},{"line":672,"address":[15164735,15164886],"length":1,"stats":{"Line":2}},{"line":673,"address":[22121600],"length":1,"stats":{"Line":1}},{"line":675,"address":[22121581,22121645,22121932,22122158,22121564,22121831,22122446],"length":1,"stats":{"Line":10}},{"line":676,"address":[22128357],"length":1,"stats":{"Line":2}},{"line":677,"address":[22203630,22203260,22203195,22202327,22203138,22203399],"length":1,"stats":{"Line":6}},{"line":678,"address":[22238724,22238883],"length":1,"stats":{"Line":4}},{"line":679,"address":[22196877],"length":1,"stats":{"Line":0}},{"line":681,"address":[22240537,22240611],"length":1,"stats":{"Line":4}},{"line":687,"address":[22197056],"length":1,"stats":{"Line":1}},{"line":693,"address":[22197364,22197494],"length":1,"stats":{"Line":2}},{"line":694,"address":[22136736],"length":1,"stats":{"Line":1}},{"line":695,"address":[22198002,22197752,22197811,22197631,22198112,22198285,22199087],"length":1,"stats":{"Line":5}},{"line":697,"address":[16377441],"length":1,"stats":{"Line":1}},{"line":698,"address":[11742081],"length":1,"stats":{"Line":3}},{"line":700,"address":[22137525],"length":1,"stats":{"Line":1}},{"line":702,"address":[22240370],"length":1,"stats":{"Line":1}},{"line":709,"address":[22198614,22198535],"length":1,"stats":{"Line":2}},{"line":710,"address":[22124030],"length":1,"stats":{"Line":1}},{"line":711,"address":[22130855],"length":1,"stats":{"Line":1}},{"line":712,"address":[22198708,22199041],"length":1,"stats":{"Line":2}},{"line":713,"address":[22236812],"length":1,"stats":{"Line":1}},{"line":718,"address":[22138001,22137928,22137841],"length":1,"stats":{"Line":2}},{"line":719,"address":[22205696],"length":1,"stats":{"Line":1}},{"line":720,"address":[22205704],"length":1,"stats":{"Line":1}},{"line":721,"address":[22242916,22242693,22243026,22243236,22243148,22242492,22242626],"length":1,"stats":{"Line":5}},{"line":722,"address":[16378575],"length":1,"stats":{"Line":1}},{"line":723,"address":[16377146,16378827,16378980,16379116,16378678,16378725],"length":1,"stats":{"Line":3}},{"line":724,"address":[22337862],"length":1,"stats":{"Line":1}},{"line":727,"address":[16380570,16379312,16380711],"length":1,"stats":{"Line":1}},{"line":731,"address":[22125054],"length":1,"stats":{"Line":1}},{"line":732,"address":[22338647,22338209,22338410],"length":1,"stats":{"Line":2}},{"line":733,"address":[22125502],"length":1,"stats":{"Line":1}},{"line":734,"address":[15168740],"length":1,"stats":{"Line":1}},{"line":735,"address":[22207202],"length":1,"stats":{"Line":1}},{"line":736,"address":[22207795,22207268],"length":1,"stats":{"Line":1}},{"line":739,"address":[22201030,22201148,22199838,22202448],"length":1,"stats":{"Line":0}},{"line":740,"address":[22127868],"length":1,"stats":{"Line":0}},{"line":742,"address":[22127932,22126502,22127920,22126626],"length":1,"stats":{"Line":0}},{"line":743,"address":[16380964,16381035],"length":1,"stats":{"Line":0}},{"line":744,"address":[22140531,22141549],"length":1,"stats":{"Line":0}},{"line":745,"address":[22239467],"length":1,"stats":{"Line":0}},{"line":749,"address":[22201329,22201409,22201440],"length":1,"stats":{"Line":0}},{"line":750,"address":[22202291],"length":1,"stats":{"Line":0}},{"line":751,"address":[15170070],"length":1,"stats":{"Line":0}},{"line":752,"address":[22245180,22245887],"length":1,"stats":{"Line":0}},{"line":756,"address":[22201420,22201519],"length":1,"stats":{"Line":0}},{"line":759,"address":[22246286,22246256],"length":1,"stats":{"Line":0}},{"line":760,"address":[15171225,15171216],"length":1,"stats":{"Line":0}},{"line":761,"address":[22340045,22340116,22340519],"length":1,"stats":{"Line":0}},{"line":762,"address":[22134249],"length":1,"stats":{"Line":0}},{"line":763,"address":[15170635],"length":1,"stats":{"Line":0}},{"line":768,"address":[22340131],"length":1,"stats":{"Line":0}},{"line":771,"address":[22244720],"length":1,"stats":{"Line":1}},{"line":774,"address":[11714484],"length":1,"stats":{"Line":2}},{"line":817,"address":[16388898,16387471,16383056],"length":1,"stats":{"Line":1}},{"line":821,"address":[22210605,22210334],"length":1,"stats":{"Line":1}},{"line":822,"address":[22245687,22251248,22251266],"length":1,"stats":{"Line":0}},{"line":824,"address":[22203755,22203616],"length":1,"stats":{"Line":2}},{"line":825,"address":[22142972,22148309],"length":1,"stats":{"Line":0}},{"line":826,"address":[22129204],"length":1,"stats":{"Line":0}},{"line":830,"address":[22203773,22203862],"length":1,"stats":{"Line":2}},{"line":833,"address":[15177744,15177790],"length":1,"stats":{"Line":2}},{"line":835,"address":[15172477,15172568,15177485,15172662],"length":1,"stats":{"Line":3}},{"line":836,"address":[22143258,22148259,22143628,22143394],"length":1,"stats":{"Line":4}},{"line":837,"address":[22246466,22246585],"length":1,"stats":{"Line":3}},{"line":838,"address":[22242797,22242697],"length":1,"stats":{"Line":2}},{"line":839,"address":[22211627],"length":1,"stats":{"Line":0}},{"line":840,"address":[22143859],"length":1,"stats":{"Line":0}},{"line":845,"address":[15173509,15173120,15173332,15177427],"length":1,"stats":{"Line":2}},{"line":846,"address":[22212071,22211903],"length":1,"stats":{"Line":3}},{"line":847,"address":[22343672,22347489],"length":1,"stats":{"Line":0}},{"line":848,"address":[22212112],"length":1,"stats":{"Line":0}},{"line":852,"address":[22343730,22343920,22347479,22343629],"length":1,"stats":{"Line":4}},{"line":853,"address":[22205577,22205406],"length":1,"stats":{"Line":4}},{"line":854,"address":[22212626,22212556],"length":1,"stats":{"Line":0}},{"line":855,"address":[22243732],"length":1,"stats":{"Line":0}},{"line":859,"address":[15174146,15174234],"length":1,"stats":{"Line":4}},{"line":860,"address":[22252578],"length":1,"stats":{"Line":0}},{"line":861,"address":[22148042],"length":1,"stats":{"Line":0}},{"line":866,"address":[22215797,22212815,22213137],"length":1,"stats":{"Line":1}},{"line":867,"address":[22253152,22253170,22249857],"length":1,"stats":{"Line":0}},{"line":868,"address":[22213049,22213217],"length":1,"stats":{"Line":2}},{"line":869,"address":[22215749,22213258],"length":1,"stats":{"Line":0}},{"line":870,"address":[22138514],"length":1,"stats":{"Line":0}},{"line":874,"address":[22213308,22213223],"length":1,"stats":{"Line":2}},{"line":875,"address":[22206441,22206520],"length":1,"stats":{"Line":3}},{"line":876,"address":[22244646],"length":1,"stats":{"Line":0}},{"line":877,"address":[22248574],"length":1,"stats":{"Line":0}},{"line":882,"address":[16386195,16386366],"length":1,"stats":{"Line":2}},{"line":883,"address":[16386419,16386469],"length":1,"stats":{"Line":2}},{"line":884,"address":[22132179],"length":1,"stats":{"Line":0}},{"line":885,"address":[22138955],"length":1,"stats":{"Line":0}},{"line":890,"address":[22206737,22206866],"length":1,"stats":{"Line":3}},{"line":891,"address":[22213815,22213874],"length":1,"stats":{"Line":3}},{"line":892,"address":[16386705],"length":1,"stats":{"Line":0}},{"line":893,"address":[22206985],"length":1,"stats":{"Line":0}},{"line":898,"address":[22250789,22250602],"length":1,"stats":{"Line":3}},{"line":899,"address":[22250797],"length":1,"stats":{"Line":2}},{"line":900,"address":[22246877,22245251],"length":1,"stats":{"Line":0}},{"line":901,"address":[22345611],"length":1,"stats":{"Line":0}},{"line":905,"address":[22132515,22132594],"length":1,"stats":{"Line":3}},{"line":906,"address":[22214229,22214167],"length":1,"stats":{"Line":3}},{"line":907,"address":[22245496,22245888],"length":1,"stats":{"Line":0}},{"line":908,"address":[16387088],"length":1,"stats":{"Line":0}},{"line":912,"address":[22251045,22251122],"length":1,"stats":{"Line":3}},{"line":913,"address":[22214454,22214533],"length":1,"stats":{"Line":3}},{"line":914,"address":[22249689],"length":1,"stats":{"Line":1}},{"line":915,"address":[22249681],"length":1,"stats":{"Line":1}},{"line":921,"address":[22146997,22146432],"length":1,"stats":{"Line":2}},{"line":922,"address":[22207979,22207882],"length":1,"stats":{"Line":2}},{"line":923,"address":[22215031],"length":1,"stats":{"Line":1}},{"line":924,"address":[22133668],"length":1,"stats":{"Line":0}},{"line":925,"address":[22147420],"length":1,"stats":{"Line":0}},{"line":932,"address":[22147648],"length":1,"stats":{"Line":1}},{"line":933,"address":[22251595],"length":1,"stats":{"Line":1}},{"line":934,"address":[22140131],"length":1,"stats":{"Line":1}},{"line":935,"address":[22346879],"length":1,"stats":{"Line":1}},{"line":951,"address":[22348096,22348921,22348957],"length":1,"stats":{"Line":3}},{"line":952,"address":[22141851,22141988],"length":1,"stats":{"Line":3}},{"line":953,"address":[22142087,22141965],"length":1,"stats":{"Line":6}},{"line":954,"address":[22149119,22149625],"length":1,"stats":{"Line":0}},{"line":955,"address":[22348423],"length":1,"stats":{"Line":0}},{"line":959,"address":[22149308,22149079,22149618,22149161],"length":1,"stats":{"Line":6}},{"line":960,"address":[22248221,22248377],"length":1,"stats":{"Line":6}},{"line":961,"address":[22348854,22348786],"length":1,"stats":{"Line":0}},{"line":962,"address":[16390010],"length":1,"stats":{"Line":0}},{"line":966,"address":[22253972],"length":1,"stats":{"Line":3}},{"line":969,"address":[16390208],"length":1,"stats":{"Line":3}},{"line":970,"address":[22149734],"length":1,"stats":{"Line":3}},{"line":971,"address":[22248880,22248768,22248889,22248786],"length":1,"stats":{"Line":12}},{"line":972,"address":[22254505,22254496],"length":1,"stats":{"Line":6}},{"line":976,"address":[22150016],"length":1,"stats":{"Line":3}},{"line":977,"address":[22349361,22349424],"length":1,"stats":{"Line":3}},{"line":978,"address":[22143276],"length":1,"stats":{"Line":0}},{"line":979,"address":[15179318],"length":1,"stats":{"Line":0}},{"line":980,"address":[22143163],"length":1,"stats":{"Line":0}}],"covered":320,"coverable":476},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","auth_lifecycle.rs"],"content":"use super::{TopicService, UserService};\nuse crate::application::ports::auth_lifecycle::{\n    AuthAccountContext, AuthLifecycleEvent, AuthLifecyclePort, AuthLifecycleStage,\n};\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse tracing::debug;\n\npub struct DefaultAuthLifecycle {\n    user_service: Arc<UserService>,\n    topic_service: Arc<TopicService>,\n    default_topics: Vec<String>,\n}\n\nimpl DefaultAuthLifecycle {\n    pub fn new(user_service: Arc<UserService>, topic_service: Arc<TopicService>) -> Self {\n        Self {\n            user_service,\n            topic_service,\n            default_topics: vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()],\n        }\n    }\n\n    pub fn with_default_topics(mut self, topics: Vec<String>) -> Self {\n        if topics.is_empty() {\n            return self;\n        }\n        self.default_topics = topics;\n        self\n    }\n\n    async fn ensure_topics_ready(&self) -> Result<(), AppError> {\n        self.topic_service.ensure_public_topic().await\n    }\n\n    async fn join_default_topics(&self, user_pubkey: &str) {\n        for topic in &self.default_topics {\n            if let Err(err) = self.topic_service.join_topic(topic, user_pubkey).await {\n                debug!(\n                    topic = %topic,\n                    pubkey = %user_pubkey,\n                    error = %err,\n                    \"failed to join default topic (ignored)\"\n                );\n            }\n        }\n    }\n\n    async fn provision_account(&self, account: AuthAccountContext) -> Result<User, AppError> {\n        self.ensure_topics_ready().await?;\n        let user = self\n            .user_service\n            .create_user(account.npub.clone(), account.public_key.clone())\n            .await?;\n        self.join_default_topics(&account.public_key).await;\n        Ok(user)\n    }\n\n    async fn handle_login(&self, account: AuthAccountContext) -> Result<User, AppError> {\n        self.ensure_topics_ready().await?;\n        let user = match self.user_service.get_user(&account.npub).await? {\n            Some(existing) => existing,\n            None => {\n                self.user_service\n                    .create_user(account.npub.clone(), account.public_key.clone())\n                    .await?\n            }\n        };\n        self.join_default_topics(&account.public_key).await;\n        Ok(user)\n    }\n}\n\n#[async_trait]\nimpl AuthLifecyclePort for DefaultAuthLifecycle {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError> {\n        match event.stage {\n            AuthLifecycleStage::AccountCreated => self.provision_account(event.account).await,\n            AuthLifecycleStage::Login => self.handle_login(event.account).await,\n        }\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        self.user_service.get_user(npub).await\n    }\n}\n","traces":[{"line":19,"address":[13893227,13893257,13892864],"length":1,"stats":{"Line":0}},{"line":23,"address":[19720127,19720452,19720182],"length":1,"stats":{"Line":0}},{"line":27,"address":[19653192,19652736,19653125],"length":1,"stats":{"Line":0}},{"line":28,"address":[19757296,19757377],"length":1,"stats":{"Line":0}},{"line":29,"address":[19645937],"length":1,"stats":{"Line":0}},{"line":31,"address":[19751809,19751905],"length":1,"stats":{"Line":0}},{"line":32,"address":[19639294],"length":1,"stats":{"Line":0}},{"line":35,"address":[19853162,19852700,19852544,19852880,19852576,19852737,19852552,19852611],"length":1,"stats":{"Line":0}},{"line":36,"address":[19752421,19752359,19752544,19752312],"length":1,"stats":{"Line":0}},{"line":39,"address":[13894797,13894434,13894464,13894495,13894638,13894681,13897333,13894416],"length":1,"stats":{"Line":0}},{"line":40,"address":[23902275,23899643,23899495,23902198],"length":1,"stats":{"Line":0}},{"line":41,"address":[11654711],"length":1,"stats":{"Line":0}},{"line":42,"address":[19640896,19852105,19640997,19852239,19641498],"length":1,"stats":{"Line":0}},{"line":52,"address":[19657123,19657357,19658298,19657088,19657212,19657566,19658995,19657168],"length":1,"stats":{"Line":0}},{"line":53,"address":[11584364],"length":1,"stats":{"Line":0}},{"line":54,"address":[19658478,19658218,19658140,19657875,19658552,19658780,19658990],"length":1,"stats":{"Line":0}},{"line":56,"address":[19719108,19718824,19719015],"length":1,"stats":{"Line":0}},{"line":57,"address":[11645216],"length":1,"stats":{"Line":0}},{"line":58,"address":[11688935],"length":1,"stats":{"Line":0}},{"line":59,"address":[19763803],"length":1,"stats":{"Line":0}},{"line":62,"address":[19764443,19763955,19765060,19764000,19764210,19764059,19766644,19763920],"length":1,"stats":{"Line":0}},{"line":63,"address":[11665980],"length":1,"stats":{"Line":0}},{"line":64,"address":[19659727,19660541,19661490,19660233,19660350],"length":1,"stats":{"Line":0}},{"line":65,"address":[19763949],"length":1,"stats":{"Line":0}},{"line":67,"address":[19861207,19861423,19860953,19860349,19860597,19861033,19860675],"length":1,"stats":{"Line":0}},{"line":68,"address":[23906321,23906599,23906508],"length":1,"stats":{"Line":0}},{"line":69,"address":[19654519,19654667,19654420,19652769,19654360,19654866],"length":1,"stats":{"Line":0}},{"line":72,"address":[19648463,19646003,19648238,19647689],"length":1,"stats":{"Line":0}},{"line":73,"address":[19761355],"length":1,"stats":{"Line":0}},{"line":79,"address":[19970928,19972406,19971285,19970981,19972140,19971116,19970847,19971244,19971831],"length":1,"stats":{"Line":0}},{"line":80,"address":[23967301],"length":1,"stats":{"Line":0}},{"line":81,"address":[19971655,19971143,19971508,19971863],"length":1,"stats":{"Line":0}},{"line":82,"address":[11267524],"length":1,"stats":{"Line":0}},{"line":86,"address":[14108735,14108467,14108512,14108758,14108646,14109254,14108994,14108547],"length":1,"stats":{"Line":0}},{"line":87,"address":[11799652],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","auth_service.rs"],"content":"use crate::application::ports::auth_lifecycle::{\r\n    AuthAccountContext, AuthLifecycleEvent, AuthLifecyclePort,\r\n};\r\nuse crate::application::ports::key_manager::{KeyManager, KeyPair};\nuse crate::domain::entities::User;\r\nuse crate::infrastructure::storage::SecureStorage;\r\nuse crate::shared::error::AppError;\r\nuse std::sync::Arc;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct AuthStatus {\r\n    pub is_authenticated: bool,\r\n    pub current_user: Option<User>,\r\n    pub npub: Option<String>,\r\n}\r\n\r\npub struct AuthService {\r\n    key_manager: Arc<dyn KeyManager>,\r\n    secure_storage: Arc<dyn SecureStorage>,\r\n    lifecycle_port: Arc<dyn AuthLifecyclePort>,\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::auth_lifecycle::AuthLifecycleStage;\r\n    use async_trait::async_trait;\r\n    use mockall::{mock, predicate::*};\r\n\r\n    mock! {\r\n        pub KeyManager {}\r\n\r\n        #[async_trait]\r\n        impl KeyManager for KeyManager {\r\n            async fn generate_keypair(&self) -> Result<KeyPair, AppError>;\r\n            async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError>;\r\n            async fn export_private_key(&self, npub: &str) -> Result<String, AppError>;\r\n            async fn get_public_key(&self, npub: &str) -> Result<String, AppError>;\r\n            async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\r\n            async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\r\n            async fn list_npubs(&self) -> Result<Vec<String>, AppError>;\r\n            async fn current_keypair(&self) -> Result<KeyPair, AppError>;\r\n        }\r\n    }\r\n\r\n    mock! {\r\n        pub SecureStorage {}\r\n\r\n        #[async_trait]\r\n        impl SecureStorage for SecureStorage {\r\n            async fn store(&self, key: &str, value: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn retrieve(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n        }\r\n    }\r\n\r\n    mock! {\r\n        pub Lifecycle {}\r\n\r\n        #[async_trait]\r\n        impl AuthLifecyclePort for Lifecycle {\r\n            async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError>;\r\n            async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\r\n        }\r\n    }\r\n\r\n    use crate::application::ports::key_manager::KeyPair;\r\n\r\n    fn sample_keypair() -> KeyPair {\r\n        KeyPair {\r\n            public_key: \"pub\".into(),\r\n            private_key: \"priv\".into(),\r\n            npub: \"npub1\".into(),\r\n            nsec: \"nsec1\".into(),\r\n        }\r\n    }\r\n\r\n    fn sample_user() -> User {\r\n        User::new(\"npub1\".into(), \"pub\".into())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn create_account_dispatches_lifecycle_event() {\r\n        let mut key_manager = MockKeyManager::new();\r\n        key_manager\r\n            .expect_generate_keypair()\r\n            .times(1)\r\n            .returning(|| Ok(sample_keypair()));\r\n        key_manager\r\n            .expect_store_keypair()\r\n            .times(1)\r\n            .returning(|_| Ok(()));\r\n        let mut storage = MockSecureStorage::new();\r\n        storage\r\n            .expect_store()\r\n            .with(eq(\"current_npub\"), eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_, _| Ok(()));\r\n\r\n        let mut lifecycle = MockLifecycle::new();\r\n        lifecycle\r\n            .expect_handle()\r\n            .times(1)\r\n            .withf(|event| event.stage == AuthLifecycleStage::AccountCreated)\r\n            .returning(|_| Ok(sample_user()));\r\n\r\n        let service = AuthService::new(\r\n            Arc::new(key_manager),\r\n            Arc::new(storage),\r\n            Arc::new(lifecycle),\r\n        );\r\n\r\n        let user = service.create_account().await.expect(\"create account\");\r\n        assert_eq!(user.npub, \"npub1\");\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn login_with_npub_uses_lifecycle_login() {\r\n        let mut key_manager = MockKeyManager::new();\r\n        key_manager\r\n            .expect_export_private_key()\r\n            .with(eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_| Ok(\"nsec\".into()));\r\n        key_manager\r\n            .expect_get_public_key()\r\n            .with(eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_| Ok(\"pub\".into()));\r\n        let mut storage = MockSecureStorage::new();\r\n        storage\r\n            .expect_store()\r\n            .with(eq(\"current_npub\"), eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_, _| Ok(()));\r\n        let mut lifecycle = MockLifecycle::new();\r\n        lifecycle\r\n            .expect_handle()\r\n            .times(1)\r\n            .withf(|event| event.stage == AuthLifecycleStage::Login)\r\n            .returning(|_| Ok(sample_user()));\r\n\r\n        let service = AuthService::new(\r\n            Arc::new(key_manager),\r\n            Arc::new(storage),\r\n            Arc::new(lifecycle),\r\n        );\r\n\r\n        let user = service\r\n            .login_with_npub(\"npub1\")\r\n            .await\r\n            .expect(\"login success\");\r\n        assert_eq!(user.pubkey, \"pub\");\r\n    }\r\n}\r\n\r\nimpl AuthService {\r\n    pub fn new(\r\n        key_manager: Arc<dyn KeyManager>,\r\n        secure_storage: Arc<dyn SecureStorage>,\r\n        lifecycle_port: Arc<dyn AuthLifecyclePort>,\r\n    ) -> Self {\r\n        Self {\r\n            key_manager,\r\n            secure_storage,\r\n            lifecycle_port,\r\n        }\r\n    }\r\n\r\n    pub async fn create_account_with_keys(&self) -> Result<(User, KeyPair), AppError> {\n        let keypair = self.key_manager.generate_keypair().await?;\n\n        self.key_manager.store_keypair(&keypair).await?;\n        self.secure_storage\n            .store(\"current_npub\", &keypair.npub)\n            .await?;\n\n        let context = AuthAccountContext::from(&keypair);\n        let user = self\n            .lifecycle_port\n            .handle(AuthLifecycleEvent::account_created(context))\n            .await?;\n\n        Ok((user, keypair))\n    }\n\n    pub async fn create_account(&self) -> Result<User, AppError> {\n        let (user, _) = self.create_account_with_keys().await?;\n        Ok(user)\n    }\n\r\n    pub async fn login_with_nsec(&self, nsec: &str) -> Result<User, AppError> {\r\n        // Import private key\r\n        let keypair = self.key_manager.import_private_key(nsec).await?;\r\n\r\n        // Store securely\r\n        self.key_manager.store_keypair(&keypair).await?;\r\n        self.secure_storage\r\n            .store(\"current_npub\", &keypair.npub)\r\n            .await?;\r\n\r\n        let context = AuthAccountContext::from(&keypair);\r\n        self.lifecycle_port\r\n            .handle(AuthLifecycleEvent::login(context))\r\n            .await\r\n    }\r\n\r\n    pub async fn login_with_npub(&self, npub: &str) -> Result<User, AppError> {\r\n        // Check if we have the private key stored\r\n        let _private_key = self.key_manager.export_private_key(npub).await?;\r\n\r\n        let public_key = self.key_manager.get_public_key(npub).await?;\r\n        let context = AuthAccountContext::new(npub.to_string(), public_key);\r\n        let user = self\r\n            .lifecycle_port\r\n            .handle(AuthLifecycleEvent::login(context))\r\n            .await?;\r\n\r\n        self.secure_storage.store(\"current_npub\", npub).await?;\r\n\r\n        Ok(user)\r\n    }\r\n\r\n    pub async fn logout(&self) -> Result<(), AppError> {\r\n        self.secure_storage.delete(\"current_npub\").await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn get_current_user(&self) -> Result<Option<User>, AppError> {\r\n        if let Some(npub) = self.secure_storage.retrieve(\"current_npub\").await? {\r\n            self.lifecycle_port.get_user(&npub).await\r\n        } else {\r\n            Ok(None)\r\n        }\r\n    }\r\n\r\n    pub async fn is_authenticated(&self) -> bool {\r\n        self.secure_storage\r\n            .retrieve(\"current_npub\")\r\n            .await\r\n            .unwrap_or(None)\r\n            .is_some()\r\n    }\r\n\r\n    pub async fn get_auth_status(&self) -> Result<AuthStatus, AppError> {\n        let current_user = self.get_current_user().await?;\n        let npub = self.secure_storage.retrieve(\"current_npub\").await?;\n\n        Ok(AuthStatus {\n            is_authenticated: current_user.is_some(),\r\n            current_user,\n            npub,\n        })\n    }\n\n    pub async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        self.key_manager.current_keypair().await\n    }\n\n    pub async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_manager.export_private_key(npub).await\n    }\n\r\n    pub async fn list_accounts(&self) -> Result<Vec<String>, AppError> {\r\n        self.key_manager.list_npubs().await\r\n    }\r\n\r\n    pub async fn switch_account(&self, npub: &str) -> Result<User, AppError> {\r\n        self.login_with_npub(npub).await\r\n    }\r\n}\r\n","traces":[{"line":161,"address":[22976208],"length":1,"stats":{"Line":2}},{"line":173,"address":[23011432,23012880,23011424,23011503,23011635,23011937,23011456,23011741],"length":1,"stats":{"Line":8}},{"line":174,"address":[22908785,22909658,22909944,22908713,22908924,22909089],"length":1,"stats":{"Line":4}},{"line":176,"address":[11633845],"length":1,"stats":{"Line":4}},{"line":177,"address":[22971437,22971348,22971723,22971858,22972248,22971121,22971599],"length":1,"stats":{"Line":10}},{"line":178,"address":[24674054],"length":1,"stats":{"Line":2}},{"line":179,"address":[22910624,22910568,22910809,22910994,22908827,22910676],"length":1,"stats":{"Line":6}},{"line":181,"address":[23010038,23009911],"length":1,"stats":{"Line":4}},{"line":182,"address":[22897878,22897609,22897542,22897346,22897804,22898146],"length":1,"stats":{"Line":10}},{"line":184,"address":[22972037],"length":1,"stats":{"Line":2}},{"line":185,"address":[17149392,17151882,17152110,17151932,17152402,17151965],"length":1,"stats":{"Line":6}},{"line":187,"address":[22979490],"length":1,"stats":{"Line":2}},{"line":190,"address":[23016512,23016579,23016520,23016830,23017466,23016704,23016544,23016667],"length":1,"stats":{"Line":8}},{"line":191,"address":[22979880,22979983,22980707,22980094,22979926],"length":1,"stats":{"Line":4}},{"line":192,"address":[17153385],"length":1,"stats":{"Line":2}},{"line":195,"address":[22905984,22906265,22906032,22906371,22906002,22906592,22906079,22907553],"length":1,"stats":{"Line":4}},{"line":197,"address":[22982230,22981189,22981938,22981360,22980959,22981031],"length":1,"stats":{"Line":2}},{"line":200,"address":[19286523],"length":1,"stats":{"Line":2}},{"line":201,"address":[24678467,24678845,24678976,24678719,24678248,24679364,24678558],"length":1,"stats":{"Line":5}},{"line":202,"address":[22901227],"length":1,"stats":{"Line":1}},{"line":203,"address":[11593090],"length":1,"stats":{"Line":3}},{"line":205,"address":[17156206,17156076],"length":1,"stats":{"Line":2}},{"line":206,"address":[24679252,24679521,24679315,24679058],"length":1,"stats":{"Line":4}},{"line":207,"address":[22983539],"length":1,"stats":{"Line":1}},{"line":208,"address":[22902244,22902430,22899574,22902155,22902208],"length":1,"stats":{"Line":3}},{"line":211,"address":[23020864,23021440,23022220,23020882,23020959,23021232,23020912,23021126],"length":1,"stats":{"Line":4}},{"line":213,"address":[19286097],"length":1,"stats":{"Line":2}},{"line":215,"address":[22910725,22911118,22909673,22911712,22910515,22910312],"length":1,"stats":{"Line":2}},{"line":216,"address":[24681516,24681341],"length":1,"stats":{"Line":2}},{"line":217,"address":[23118186,23118260,23118490,23117862,23118721,23117953,23117639],"length":1,"stats":{"Line":5}},{"line":219,"address":[22986207],"length":1,"stats":{"Line":1}},{"line":220,"address":[11627801],"length":1,"stats":{"Line":3}},{"line":222,"address":[11623888],"length":1,"stats":{"Line":2}},{"line":224,"address":[22905959],"length":1,"stats":{"Line":1}},{"line":227,"address":[23120084,23119304,23119312,23119350,23119296,23119487,23119659,23119447],"length":1,"stats":{"Line":4}},{"line":228,"address":[11452086],"length":1,"stats":{"Line":2}},{"line":229,"address":[24683814],"length":1,"stats":{"Line":1}},{"line":232,"address":[22981624,22982990,22981679,22981799,22982065,22981632,22981616,22981863],"length":1,"stats":{"Line":0}},{"line":233,"address":[23023877,23024145,23023804,23023974,23025036],"length":1,"stats":{"Line":0}},{"line":234,"address":[10884590],"length":1,"stats":{"Line":0}},{"line":236,"address":[23121370],"length":1,"stats":{"Line":0}},{"line":240,"address":[22915529,22915496,22915660,22915488,22916194,22915620,22915823,22915504],"length":1,"stats":{"Line":0}},{"line":241,"address":[23021974,23021881,23021705,23021634,23021515],"length":1,"stats":{"Line":0}},{"line":243,"address":[22915647,22915754,22915990,22915855,22915798],"length":1,"stats":{"Line":0}},{"line":244,"address":[23025902],"length":1,"stats":{"Line":0}},{"line":248,"address":[24686590,24686411,24686272,24686310,24686256,24687278,24686264,24686466],"length":1,"stats":{"Line":0}},{"line":249,"address":[22991072,22991130,22991205,22991709,22991967,22991322],"length":1,"stats":{"Line":0}},{"line":250,"address":[17164810,17164636,17164453,17165176,17163929],"length":1,"stats":{"Line":0}},{"line":252,"address":[22992579],"length":1,"stats":{"Line":0}},{"line":253,"address":[22992365],"length":1,"stats":{"Line":0}},{"line":254,"address":[22910977],"length":1,"stats":{"Line":0}},{"line":255,"address":[17165315],"length":1,"stats":{"Line":0}},{"line":259,"address":[22992895,22992771,22992858,22993377,22993045,22992728,22992736,22992720],"length":1,"stats":{"Line":0}},{"line":260,"address":[23029845,23029653,23029717,23029605],"length":1,"stats":{"Line":0}},{"line":263,"address":[22986713,22986482,22986512,22986547,22986874,22986673,22987142,22986464],"length":1,"stats":{"Line":4}},{"line":264,"address":[17166412,17166618,17166364,17166489],"length":1,"stats":{"Line":2}},{"line":267,"address":[23031174,23030899,23031023,23030856,23030848,23030986,23031439,23030864],"length":1,"stats":{"Line":0}},{"line":268,"address":[22912918,22912677,22912789,22912725],"length":1,"stats":{"Line":0}},{"line":271,"address":[17167672,17167490,17167555,17167472,17168112,17167709,17167828,17167520],"length":1,"stats":{"Line":0}},{"line":272,"address":[23026156,23026099,23026053,23026260],"length":1,"stats":{"Line":0}}],"covered":39,"coverable":60},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","direct_message_service","tests.rs"],"content":"use super::*;\nuse crate::application::ports::{\n    direct_message_notifier::DirectMessageNotifier,\n    repositories::{\n        DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n        DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n        DirectMessagePageRaw,\n    },\n};\nuse async_trait::async_trait;\nuse mockall::mock;\nuse std::sync::Arc;\n\nmock! {\n    pub Repo {}\n\n    #[async_trait]\n    impl DirectMessageRepository for Repo {\n        async fn insert_direct_message(\n            &self,\n            message: &NewDirectMessage,\n        ) -> Result<DirectMessage, AppError>;\n\n        async fn list_direct_messages(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            cursor: Option<DirectMessageCursor>,\n            limit: usize,\n            direction: DirectMessageListDirection,\n        ) -> Result<DirectMessagePageRaw, AppError>;\n\n        async fn mark_delivered_by_client_id(\n            &self,\n            owner_npub: &str,\n            client_message_id: &str,\n            event_id: Option<String>,\n            delivered: bool,\n        ) -> Result<(), AppError>;\n\n        async fn upsert_conversation_metadata(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            last_message_id: i64,\n            last_message_created_at: i64,\n        ) -> Result<(), AppError>;\n\n        async fn mark_conversation_as_read(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            read_at: i64,\n        ) -> Result<(), AppError>;\n\n        async fn list_direct_message_conversations(\n            &self,\n            owner_npub: &str,\n            cursor: Option<DirectMessageConversationCursor>,\n            limit: usize,\n        ) -> Result<DirectMessageConversationPageRaw, AppError>;\n    }\n}\n\nmock! {\n    pub Gateway {}\n\n    #[async_trait]\n    impl MessagingGateway for Gateway {\n        async fn encrypt_and_send(\n            &self,\n            owner_npub: &str,\n            recipient_npub: &str,\n            plaintext: &str,\n        ) -> Result<MessagingSendResult, AppError>;\n\n        async fn encrypt_only(\n            &self,\n            owner_npub: &str,\n            recipient_npub: &str,\n            plaintext: &str,\n        ) -> Result<String, AppError>;\n\n        async fn decrypt_with_counterparty(\n            &self,\n            owner_npub: &str,\n            counterparty_npub: &str,\n            ciphertext: &str,\n        ) -> Result<String, AppError>;\n    }\n}\n\nmock! {\n    pub Notifier {}\n\n    #[async_trait]\n    impl DirectMessageNotifier for Notifier {\n        async fn notify(\n            &self,\n            owner_npub: &str,\n            message: &DirectMessage,\n        ) -> Result<(), AppError>;\n    }\n}\n\n#[tokio::test]\nasync fn send_direct_message_success() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .withf(|message| {\n            message.owner_npub == \"npub_sender\"\n                && message.recipient_npub == \"npub_recipient\"\n                && message.payload_cipher_base64 == \"cipher\"\n        })\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .withf(|owner, conv, _, _| owner == \"npub_sender\" && conv == \"npub_recipient\")\n        .returning(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .returning(|_, _, _| {\n            Ok(MessagingSendResult {\n                event_id: Some(\"event1\".to_string()),\n                ciphertext: \"cipher\".to_string(),\n                created_at_millis: 1000,\n                delivered: true,\n            })\n        });\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .send_direct_message(\n            \"npub_sender\",\n            \"npub_recipient\",\n            \" hello world \",\n            Some(\"client-1\".to_string()),\n        )\n        .await\n        .expect(\"success\");\n\n    assert_eq!(result.event_id.as_deref(), Some(\"event1\"));\n    assert!(!result.queued);\n    assert_eq!(result.message.decrypted_content.unwrap(), \"hello world\");\n}\n\n#[tokio::test]\nasync fn send_direct_message_propagates_gateway_errors() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message().never();\n    repo.expect_upsert_conversation_metadata().never();\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .return_once(|_, _, _| Err(AppError::Crypto(\"failed to encrypt\".into())));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let err = service\n        .send_direct_message(\"npub_sender\", \"npub_recipient\", \"hello\", None)\n        .await\n        .expect_err(\"gateway error should bubble\");\n    assert!(matches!(err, AppError::Crypto(_)));\n}\n\n#[tokio::test]\nasync fn send_direct_message_marks_queued_when_delivery_pending() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .return_once(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .returning(|_, _, _| {\n            Ok(MessagingSendResult {\n                event_id: None,\n                ciphertext: \"cipher\".to_string(),\n                created_at_millis: 2000,\n                delivered: false,\n            })\n        });\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .send_direct_message(\"npub_sender\", \"npub_recipient\", \"hi\", None)\n        .await\n        .expect(\"queued ok\");\n    assert!(result.queued);\n    assert_eq!(result.message.decrypted_content.as_deref(), Some(\"hi\"));\n}\n\n#[tokio::test]\nasync fn list_direct_messages_decrypts_payloads() {\n    let mut repo = MockRepo::new();\n    let page_raw = DirectMessagePageRaw {\n        items: vec![DirectMessage::new(\n            1,\n            \"npub_owner\".to_string(),\n            \"npub_partner\".to_string(),\n            \"npub_owner\".to_string(),\n            \"npub_partner\".to_string(),\n            Some(\"event1\".to_string()),\n            Some(\"client-1\".to_string()),\n            \"cipher\".to_string(),\n            1000,\n            true,\n            MessageDirection::Outbound,\n        )],\n        next_cursor: Some(\"1000:event1\".to_string()),\n        has_more: false,\n    };\n\n    repo.expect_list_direct_messages()\n        .times(1)\n        .returning(move |_, _, _, _, _| Ok(page_raw.clone()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"decrypted\".to_string()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let page = service\n        .list_direct_messages(\n            \"npub_owner\",\n            \"npub_partner\",\n            None,\n            Some(20),\n            MessagePageDirection::Backward,\n        )\n        .await\n        .expect(\"list succeeds\");\n\n    assert_eq!(page.items.len(), 1);\n    assert_eq!(\n        page.items[0].decrypted_content.as_deref(),\n        Some(\"decrypted\")\n    );\n    assert_eq!(page.next_cursor.as_deref(), Some(\"1000:event1\"));\n    assert!(!page.has_more);\n}\n\n#[tokio::test]\nasync fn send_direct_message_rejects_empty_content() {\n    let repo = MockRepo::new();\n    let gateway = MockGateway::new();\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let error = service\n        .send_direct_message(\"npub_owner\", \"npub_partner\", \"   \", None)\n        .await\n        .expect_err(\"validation error\");\n\n    assert_eq!(\n        error.validation_kind(),\n        Some(ValidationFailureKind::Generic)\n    );\n}\n\n#[tokio::test]\nasync fn ingest_incoming_message_stores_and_notifies() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .withf(|message| {\n            message.owner_npub == \"npub_owner\"\n                && message.conversation_npub == \"npub_sender\"\n                && message.direction == MessageDirection::Inbound\n                && message.delivered\n        })\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .withf(|owner, conv, _, _| owner == \"npub_owner\" && conv == \"npub_sender\")\n        .returning(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"hello inbound\".to_string()));\n\n    let mut notifier = MockNotifier::new();\n    notifier\n        .expect_notify()\n        .times(1)\n        .withf(|owner, message| {\n            owner == \"npub_owner\"\n                && message.conversation_npub == \"npub_sender\"\n                && message.direction == MessageDirection::Inbound\n        })\n        .return_once(|_, _| Ok(()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let notifier: Arc<dyn DirectMessageNotifier> = Arc::new(notifier);\n    let service = DirectMessageService::new(repo, gateway, Some(notifier));\n\n    let stored = service\n        .ingest_incoming_message(\n            \"npub_owner\",\n            \"npub_sender\",\n            \"ciphertext\",\n            Some(\"event1\".to_string()),\n            1_730_000_000_000,\n        )\n        .await\n        .expect(\"ingest succeeds\");\n\n    let message = stored.expect(\"message stored\");\n    assert_eq!(message.decrypted_content.as_deref(), Some(\"hello inbound\"));\n    assert_eq!(message.direction, MessageDirection::Inbound);\n}\n\n#[tokio::test]\nasync fn ingest_incoming_message_ignores_duplicates() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message().times(1).returning(|_| {\n        Err(AppError::Database(\n            \"UNIQUE constraint failed: direct_messages.owner_npub, event_id\".to_string(),\n        ))\n    });\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"ignored\".to_string()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .ingest_incoming_message(\n            \"npub_owner\",\n            \"npub_sender\",\n            \"cipher\",\n            Some(\"evt\".into()),\n            10,\n        )\n        .await\n        .expect(\"duplicate ignored\");\n\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn list_direct_message_conversations_returns_decrypted_last_message() {\n    let mut repo = MockRepo::new();\n    repo.expect_list_direct_message_conversations()\n        .times(1)\n        .withf(|owner, cursor, limit| owner == \"npub_owner\" && cursor.is_none() && *limit == 20)\n        .returning(|_, _, _| {\n            Ok(DirectMessageConversationPageRaw {\n                items: vec![DirectMessageConversationRecord {\n                    owner_npub: \"npub_owner\".into(),\n                    conversation_npub: \"npub_friend\".into(),\n                    last_message: Some(DirectMessage::new(\n                        42,\n                        \"npub_owner\".into(),\n                        \"npub_friend\".into(),\n                        \"npub_owner\".into(),\n                        \"npub_friend\".into(),\n                        Some(\"evt\".into()),\n                        Some(\"client\".into()),\n                        \"cipher\".into(),\n                        1_700_000_000_000,\n                        true,\n                        MessageDirection::Outbound,\n                    )),\n                    last_message_created_at: Some(1_700_000_000_000),\n                    last_read_at: 0,\n                    unread_count: 3,\n                }],\n                next_cursor: Some(\n                    DirectMessageConversationCursor::new(\n                        Some(1_700_000_000_000),\n                        \"npub_friend\".into(),\n                    )\n                    .to_string(),\n                ),\n                has_more: true,\n            })\n        });\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"hello friend\".into()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let page = service\n        .list_direct_message_conversations(\"npub_owner\", None, Some(20))\n        .await\n        .expect(\"list succeeds\");\n\n    assert_eq!(page.items.len(), 1);\n    assert_eq!(page.items[0].conversation_npub, \"npub_friend\");\n    assert_eq!(page.items[0].unread_count, 3);\n    assert_eq!(\n        page.items[0]\n            .last_message\n            .as_ref()\n            .and_then(|message| message.decrypted_content.clone()),\n        Some(\"hello friend\".into())\n    );\n    assert!(page.has_more);\n    assert!(page.next_cursor.is_some());\n}\n\n#[tokio::test]\nasync fn mark_conversation_as_read_clamps_negative_timestamps() {\n    let mut repo = MockRepo::new();\n    repo.expect_mark_conversation_as_read()\n        .times(1)\n        .withf(|_, _, read_at| *read_at == 0)\n        .returning(|_, _, _| Ok(()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway = MockGateway::new();\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    service\n        .mark_conversation_as_read(\"npub_owner\", \"npub_friend\", -100)\n        .await\n        .expect(\"mark succeeds\");\n}\n","traces":[{"line":14,"address":[23105567,23110288,23108883,23103451,23109693,23108693,23110736,23106671,23110958,23109331,23110912,23102015,23105680,23102896,23104896,23108797,23110112,23103220,23106555,23105615,23105024,23108608,23104637,23108628,23108245,23110653,23102081,23102648,23105134,23108581,23110376,23101632,23109477,23104285,23103600,23105600,23109076,23104812,23104455,23107226,23101953,23106160,23107360,23103838,23105167,23110906,23108160,23105232,23110256,23110309,23104864,23110704,23108435,23102206,23110640,23101675,23102486,23110032,23110438,23105152,23108006,23110176,23102624,23110481,23102928,23107184,23110224,23106286,23104723,23104905,23107654,23110237,23110773,23110149,23110610,23109970,23106048,23101912,23103370,23102608,23110880,23106067,23105424,23110064,23102292,23108180,23109589,23101789,23106015,23109141,23109029,23104969,23105033,23103873,23109524,23110144,23102912,23110496,23109245,23108349,23106180,23110194,23104844,23109504,23110005,23109952,23105120,23102906,23111008,23105336,23111017,23104960,23105784,23103856,23104869,23107431,23107480,23110464,23104432,23109779,23109925,23105872,23102961,23110515,23103630,23104688,23109056,23103576,23103555,23103344,23102611,23102320,23107456,23110712,23104624,23110120,23110046,23101841,23102915,23103934,23110269,23107632,23103697,23110000,23110078],"length":1,"stats":{"Line":455}},{"line":17,"address":[24844581,24843843,24844777,24843776,24844480,24843485,24845987,24843193,24842695,24842976,24843066,24844207,24845059,24845610,24842503,24842432,24845731,24845284,24844531,24842559,24845008,24845520,24843939,24845109],"length":1,"stats":{"Line":15}},{"line":19,"address":[24842368,24842481,24842334,24842398,24842552,24842721,24842571],"length":1,"stats":{"Line":5}},{"line":20,"address":[24842655],"length":1,"stats":{"Line":1}},{"line":21,"address":[23110909],"length":1,"stats":{"Line":2}},{"line":24,"address":[24842827,24843511,24842942,24843044,24842912,24843200,24843176],"length":1,"stats":{"Line":4}},{"line":25,"address":[24843327],"length":1,"stats":{"Line":1}},{"line":26,"address":[24831246,24843423],"length":1,"stats":{"Line":2}},{"line":27,"address":[24843436,24831253],"length":1,"stats":{"Line":2}},{"line":28,"address":[24821574,24822180,24827851,24831061,24821239,24820749,24843344],"length":1,"stats":{"Line":4}},{"line":29,"address":[24843380],"length":1,"stats":{"Line":1}},{"line":30,"address":[24843397,24843407],"length":1,"stats":{"Line":2}},{"line":33,"address":[24843821,24843626,24843712,24844233,24843946,24843742,24843918],"length":1,"stats":{"Line":0}},{"line":34,"address":[24844073],"length":1,"stats":{"Line":0}},{"line":35,"address":[19386126],"length":1,"stats":{"Line":0}},{"line":36,"address":[24844164],"length":1,"stats":{"Line":0}},{"line":37,"address":[24844090],"length":1,"stats":{"Line":0}},{"line":38,"address":[24844126,24844135],"length":1,"stats":{"Line":0}},{"line":41,"address":[24844346,24844416,24844509,24844446,24844574,24844803,24844593],"length":1,"stats":{"Line":5}},{"line":42,"address":[24844677],"length":1,"stats":{"Line":1}},{"line":43,"address":[15452526],"length":1,"stats":{"Line":2}},{"line":44,"address":[15452533],"length":1,"stats":{"Line":2}},{"line":45,"address":[24844693],"length":1,"stats":{"Line":1}},{"line":46,"address":[24844710],"length":1,"stats":{"Line":1}},{"line":49,"address":[24845121,24845310,24844974,24845037,24845102,24844944,24844882],"length":1,"stats":{"Line":5}},{"line":50,"address":[24845205],"length":1,"stats":{"Line":1}},{"line":51,"address":[24841021,24845242],"length":1,"stats":{"Line":2}},{"line":52,"address":[24845255,24841028],"length":1,"stats":{"Line":2}},{"line":53,"address":[24845221],"length":1,"stats":{"Line":1}},{"line":56,"address":[24845738,24846013,24845588,24845456,24845384,24845714,24845486],"length":1,"stats":{"Line":4}},{"line":57,"address":[24845865],"length":1,"stats":{"Line":1}},{"line":58,"address":[24845951],"length":1,"stats":{"Line":2}},{"line":59,"address":[24845882],"length":1,"stats":{"Line":4}},{"line":60,"address":[24845930],"length":1,"stats":{"Line":1}},{"line":65,"address":[23979168,23983860,23976650,23977520,23984816,23976346,23978275,23984894,23978582,23977642,23980608,23984960,23976588,23979123,23980208,23986016,23977536,23978256,23984563,23985488,23976547,23979144,23980391,23985267,23979019,23981012,23985405,23983925,23984709,23980581,23977062,23980992,23983412,23980832,23983392,23978288,23976741,23979440,23981503,23985975,23985128,23984936,23984373,23985899,23985061,23978321,23978272,23983477,23980016,23985040,23980681,23980745,23983581,23978266,23985233,23984928,23980221,23980552,23981387,23985362,23980511,23983667,23977523,23975904,23985216,23983238,23982305,23984880,23980736,23979457,23980617,23980272,23984965,23984477,23982016,23985190,23983813,23979260,23984115,23981118,23985456,23976183,23980576,23979869,23982886,23985248,23985010,23982448,23984789,23985464,23979193,23985392,23984261,23977090,23979518,23980864,23985598,23984029,23984992,23982126,23979423,23982864,23984736,23985925,23986027,23980846,23980672,23977279,23978912,23984754,23980039,23985872,23983840,23984308,23982418,23984288,23976976,23978938,23980878,23982478,23976044,23984860,23984784],"length":1,"stats":{"Line":226}},{"line":68,"address":[24846873,24847039,24847381,24847331,24846752,24847280,24847893,24847551,24848063,24847843,24846823,24847792],"length":1,"stats":{"Line":8}},{"line":70,"address":[24846866,24846885,24847065,24846801,24846718,24846623,24846688],"length":1,"stats":{"Line":8}},{"line":71,"address":[24846969],"length":1,"stats":{"Line":2}},{"line":72,"address":[24846985],"length":1,"stats":{"Line":4}},{"line":73,"address":[24846998],"length":1,"stats":{"Line":4}},{"line":74,"address":[24847006],"length":1,"stats":{"Line":4}},{"line":77,"address":[24847151,24847374,24847393,24847246,24847577,24847216,24847309],"length":1,"stats":{"Line":0}},{"line":78,"address":[24847477],"length":1,"stats":{"Line":0}},{"line":79,"address":[19395294],"length":1,"stats":{"Line":0}},{"line":80,"address":[19395301],"length":1,"stats":{"Line":0}},{"line":81,"address":[19395309],"length":1,"stats":{"Line":0}},{"line":84,"address":[24847905,24847663,24847821,24847758,24847728,24847886,24848089],"length":1,"stats":{"Line":5}},{"line":85,"address":[24847989],"length":1,"stats":{"Line":1}},{"line":86,"address":[16476430],"length":1,"stats":{"Line":2}},{"line":87,"address":[16476437],"length":1,"stats":{"Line":2}},{"line":88,"address":[16476445],"length":1,"stats":{"Line":2}},{"line":93,"address":[24848268,24848368,24848357,24848205,24848304,24848128,24848320,24848352,24848141,24848309,24848328,24848747,24848192,24848256],"length":1,"stats":{"Line":83}},{"line":96,"address":[24848613,24848563,24848512,24848754],"length":1,"stats":{"Line":3}},{"line":98,"address":[24848448,24848392,24848625,24848777,24848478,24848541,24848606],"length":1,"stats":{"Line":5}},{"line":99,"address":[24848709],"length":1,"stats":{"Line":1}},{"line":100,"address":[24848725],"length":1,"stats":{"Line":2}},{"line":101,"address":[24848738],"length":1,"stats":{"Line":2}}],"covered":46,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","direct_message_service.rs"],"content":"#[cfg(test)]\nuse crate::application::ports::messaging_gateway::MessagingSendResult;\nuse crate::application::ports::repositories::{\n    DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n    DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n    DirectMessagePageRaw, DirectMessageRepository,\n};\nuse crate::application::ports::{\n    direct_message_notifier::DirectMessageNotifier, messaging_gateway::MessagingGateway,\n};\nuse crate::domain::entities::{DirectMessage, MessageDirection, NewDirectMessage};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, TimeZone, Utc};\nuse nostr_sdk::prelude::nip04;\nuse nostr_sdk::prelude::{FromBech32, Keys, PublicKey, SecretKey, ToBech32};\nuse std::sync::Arc;\nuse tracing::{debug, error};\n\npub struct DirectMessageService {\n    repository: Arc<dyn DirectMessageRepository>,\n    messaging_gateway: Arc<dyn MessagingGateway>,\n    notifier: Option<Arc<dyn DirectMessageNotifier>>,\n}\n\n#[derive(Debug)]\npub struct SendDirectMessageResult {\n    pub event_id: Option<String>,\n    pub queued: bool,\n    pub message: DirectMessage,\n}\n\n#[derive(Debug)]\npub struct DirectMessagePageResult {\n    pub items: Vec<DirectMessage>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug)]\npub struct DirectMessageConversationSummary {\n    pub conversation_npub: String,\n    pub unread_count: u64,\n    pub last_read_at: i64,\n    pub last_message: Option<DirectMessage>,\n}\n\n#[derive(Debug)]\npub struct DirectMessageConversationPageResult {\n    pub items: Vec<DirectMessageConversationSummary>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum MessagePageDirection {\n    #[default]\n    Backward,\n    Forward,\n}\n\nimpl From<MessagePageDirection> for DirectMessageListDirection {\n    fn from(value: MessagePageDirection) -> Self {\n        match value {\n            MessagePageDirection::Backward => DirectMessageListDirection::Backward,\n            MessagePageDirection::Forward => DirectMessageListDirection::Forward,\n        }\n    }\n}\n\nimpl DirectMessageService {\n    pub fn new(\n        repository: Arc<dyn DirectMessageRepository>,\n        messaging_gateway: Arc<dyn MessagingGateway>,\n        notifier: Option<Arc<dyn DirectMessageNotifier>>,\n    ) -> Self {\n        Self {\n            repository,\n            messaging_gateway,\n            notifier,\n        }\n    }\n\n    pub async fn send_direct_message(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        content: &str,\n        client_message_id: Option<String>,\n    ) -> Result<SendDirectMessageResult, AppError> {\n        let trimmed = content.trim();\n        if trimmed.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Direct message content must not be empty\",\n            ));\n        }\n\n        let messaging_result = self\n            .messaging_gateway\n            .encrypt_and_send(owner_npub, recipient_npub, trimmed)\n            .await?;\n\n        let created_at =\n            millis_to_datetime(messaging_result.created_at_millis).unwrap_or_else(Utc::now);\n\n        let generated_client_id = client_message_id\n            .filter(|id| !id.trim().is_empty())\n            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());\n\n        let new_message = NewDirectMessage {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: recipient_npub.to_string(),\n            sender_npub: owner_npub.to_string(),\n            recipient_npub: recipient_npub.to_string(),\n            event_id: messaging_result.event_id.clone(),\n            client_message_id: Some(generated_client_id.clone()),\n            payload_cipher_base64: messaging_result.ciphertext.clone(),\n            created_at,\n            delivered: messaging_result.delivered,\n            direction: MessageDirection::Outbound,\n        };\n\n        let stored = self\n            .repository\n            .insert_direct_message(&new_message)\n            .await?\n            .with_decrypted_content(trimmed.to_string());\n\n        self.persist_conversation_snapshot(owner_npub, &stored)\n            .await?;\n        self.dispatch_notification(owner_npub, &stored).await;\n\n        Ok(SendDirectMessageResult {\n            event_id: messaging_result.event_id,\n            queued: !messaging_result.delivered,\n            message: stored,\n        })\n    }\n\n    pub async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<&str>,\n        limit: Option<usize>,\n        direction: MessagePageDirection,\n    ) -> Result<DirectMessagePageResult, AppError> {\n        let limit = limit.unwrap_or(50).clamp(1, 200);\n        let parsed_cursor = parse_cursor(cursor)?;\n\n        let raw_page: DirectMessagePageRaw = self\n            .repository\n            .list_direct_messages(\n                owner_npub,\n                conversation_npub,\n                parsed_cursor,\n                limit,\n                direction.into(),\n            )\n            .await?;\n\n        let mut items = Vec::with_capacity(raw_page.items.len());\n        for message in raw_page.items {\n            let plaintext = self\n                .messaging_gateway\n                .decrypt_with_counterparty(\n                    owner_npub,\n                    message.counterparty_npub(),\n                    &message.payload_cipher_base64,\n                )\n                .await?;\n            items.push(message.with_decrypted_content(plaintext));\n        }\n\n        Ok(DirectMessagePageResult {\n            items,\n            next_cursor: raw_page.next_cursor,\n            has_more: raw_page.has_more,\n        })\n    }\n\n    pub async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<&str>,\n        limit: Option<usize>,\n    ) -> Result<DirectMessageConversationPageResult, AppError> {\n        let limit = limit.unwrap_or(50).clamp(1, 200);\n        let parsed_cursor = parse_conversation_cursor(cursor)?;\n        let page: DirectMessageConversationPageRaw = self\n            .repository\n            .list_direct_message_conversations(owner_npub, parsed_cursor, limit)\n            .await?;\n\n        let mut summaries = Vec::with_capacity(page.items.len());\n        for record in page.items {\n            let DirectMessageConversationRecord {\n                conversation_npub,\n                last_message,\n                last_read_at,\n                unread_count,\n                ..\n            } = record;\n\n            let decrypted = if let Some(message) = last_message {\n                let plaintext = self\n                    .messaging_gateway\n                    .decrypt_with_counterparty(\n                        owner_npub,\n                        message.counterparty_npub(),\n                        &message.payload_cipher_base64,\n                    )\n                    .await?;\n                Some(message.with_decrypted_content(plaintext))\n            } else {\n                None\n            };\n\n            summaries.push(DirectMessageConversationSummary {\n                conversation_npub,\n                unread_count: unread_count.max(0) as u64,\n                last_read_at,\n                last_message: decrypted,\n            });\n        }\n\n        Ok(DirectMessageConversationPageResult {\n            items: summaries,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n        })\n    }\n\n    pub async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at_millis: i64,\n    ) -> Result<(), AppError> {\n        let normalized = read_at_millis.max(0);\n        self.repository\n            .mark_conversation_as_read(owner_npub, conversation_npub, normalized)\n            .await\n    }\n\n    pub async fn ingest_incoming_message(\n        &self,\n        owner_npub: &str,\n        sender_npub: &str,\n        ciphertext: &str,\n        event_id: Option<String>,\n        created_at_millis: i64,\n    ) -> Result<Option<DirectMessage>, AppError> {\n        let plaintext = self\n            .messaging_gateway\n            .decrypt_with_counterparty(owner_npub, sender_npub, ciphertext)\n            .await?;\n\n        let created_at = millis_to_datetime(created_at_millis).unwrap_or_else(chrono::Utc::now);\n\n        let new_message = NewDirectMessage {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: sender_npub.to_string(),\n            sender_npub: sender_npub.to_string(),\n            recipient_npub: owner_npub.to_string(),\n            event_id: event_id.clone(),\n            client_message_id: None,\n            payload_cipher_base64: ciphertext.to_string(),\n            created_at,\n            delivered: true,\n            direction: MessageDirection::Inbound,\n        };\n\n        match self.repository.insert_direct_message(&new_message).await {\n            Ok(record) => {\n                let stored = record.with_decrypted_content(plaintext);\n                self.persist_conversation_snapshot(owner_npub, &stored)\n                    .await?;\n                self.dispatch_notification(owner_npub, &stored).await;\n                Ok(Some(stored))\n            }\n            Err(err) => {\n                if is_unique_violation(&err) {\n                    debug!(\n                        event_id = event_id.as_deref().unwrap_or(\"\"),\n                        owner_npub, \"Duplicate direct message detected; skipping insertion\"\n                    );\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n\n    pub async fn seed_incoming_message_for_e2e(\n        &self,\n        owner_npub: &str,\n        content: &str,\n        created_at_millis: Option<i64>,\n        owner_nsec: Option<&str>,\n    ) -> Result<DirectMessage, AppError> {\n        let owner_keys = if let Some(nsec) = owner_nsec {\n            let secret_key =\n                SecretKey::from_bech32(nsec).map_err(|err| AppError::ValidationError {\n                    kind: ValidationFailureKind::Generic,\n                    message: format!(\"Invalid owner nsec for seeded direct message: {err}\"),\n                })?;\n            Some(Keys::new(secret_key))\n        } else {\n            None\n        };\n\n        let owner_pk = match &owner_keys {\n            Some(keys) => keys.public_key(),\n            None => {\n                PublicKey::from_bech32(owner_npub).map_err(|err| AppError::ValidationError {\n                    kind: ValidationFailureKind::Generic,\n                    message: format!(\"Invalid owner npub {owner_npub}: {err}\"),\n                })?\n            }\n        };\n\n        let sender_keys = Keys::generate();\n        let sender_pk = sender_keys.public_key();\n        let ciphertext =\n            nip04::encrypt(sender_keys.secret_key(), &owner_pk, content).map_err(|err| {\n                AppError::Crypto(format!(\"Failed to encrypt seeded direct message: {err}\"))\n            })?;\n        let sender_npub = sender_pk\n            .to_bech32()\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encode seeded npub: {err}\")))?;\n        let created_at = created_at_millis.unwrap_or_else(|| Utc::now().timestamp_millis());\n\n        if let Some(keys) = owner_keys {\n            let plaintext =\n                nip04::decrypt(keys.secret_key(), &sender_pk, &ciphertext).map_err(|err| {\n                    AppError::Crypto(format!(\n                        \"Failed to decrypt seeded direct message with provided nsec: {err}\"\n                    ))\n                })?;\n\n            let new_message = NewDirectMessage {\n                owner_npub: owner_npub.to_string(),\n                conversation_npub: sender_npub.clone(),\n                sender_npub: sender_npub.clone(),\n                recipient_npub: owner_npub.to_string(),\n                event_id: None,\n                client_message_id: None,\n                payload_cipher_base64: ciphertext.clone(),\n                created_at: millis_to_datetime(created_at).unwrap_or_else(chrono::Utc::now),\n                delivered: true,\n                direction: MessageDirection::Inbound,\n            };\n\n            match self.repository.insert_direct_message(&new_message).await {\n                Ok(record) => {\n                    let stored = record.with_decrypted_content(plaintext);\n                    self.persist_conversation_snapshot(owner_npub, &stored)\n                        .await?;\n                    self.dispatch_notification(owner_npub, &stored).await;\n                    Ok(stored)\n                }\n                Err(err) => {\n                    if is_unique_violation(&err) {\n                        debug!(\n                            owner_npub,\n                            conversation = sender_npub,\n                            \"Duplicate seeded direct message detected; skipping insertion\"\n                        );\n                        Err(AppError::Internal(\n                            \"Failed to persist seeded direct message conversation\".into(),\n                        ))\n                    } else {\n                        Err(err)\n                    }\n                }\n            }\n        } else {\n            self.ingest_incoming_message(owner_npub, &sender_npub, &ciphertext, None, created_at)\n                .await?\n                .ok_or_else(|| {\n                    AppError::Internal(\n                        \"Failed to persist seeded direct message conversation\".into(),\n                    )\n                })\n        }\n    }\n\n    async fn dispatch_notification(&self, owner_npub: &str, message: &DirectMessage) {\n        if let Some(notifier) = &self.notifier {\n            if let Err(err) = notifier.notify(owner_npub, message).await {\n                error!(\n                    error = %err,\n                    owner_npub,\n                    conversation = message.conversation_npub,\n                    \"Failed to emit direct message notification\"\n                );\n            }\n        }\n    }\n\n    async fn persist_conversation_snapshot(\n        &self,\n        owner_npub: &str,\n        message: &DirectMessage,\n    ) -> Result<(), AppError> {\n        self.repository\n            .upsert_conversation_metadata(\n                owner_npub,\n                &message.conversation_npub,\n                message.id,\n                message.created_at_millis(),\n            )\n            .await\n    }\n}\n\nfn parse_cursor(cursor: Option<&str>) -> Result<Option<DirectMessageCursor>, AppError> {\n    match cursor {\n        None => Ok(None),\n        Some(raw) => DirectMessageCursor::parse(raw)\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid cursor format: {raw}\"),\n                )\n            })\n            .map(Some),\n    }\n}\n\nfn parse_conversation_cursor(\n    cursor: Option<&str>,\n) -> Result<Option<DirectMessageConversationCursor>, AppError> {\n    match cursor {\n        None => Ok(None),\n        Some(raw) => DirectMessageConversationCursor::parse(raw)\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid conversation cursor format: {raw}\"),\n                )\n            })\n            .map(Some),\n    }\n}\n\nfn millis_to_datetime(millis: i64) -> Option<DateTime<Utc>> {\n    Utc.timestamp_millis_opt(millis).single()\n}\n\nfn is_unique_violation(error: &AppError) -> bool {\n    match error {\n        AppError::Database(message) => {\n            message.contains(\"UNIQUE constraint failed: direct_messages.owner_npub, event_id\")\n                || message.contains(\n                    \"UNIQUE constraint failed: direct_messages.owner_npub, client_message_id\",\n                )\n        }\n        _ => false,\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":62,"address":[23865280],"length":1,"stats":{"Line":1}},{"line":63,"address":[23726809],"length":1,"stats":{"Line":1}},{"line":64,"address":[23659016],"length":1,"stats":{"Line":1}},{"line":65,"address":[23764943],"length":1,"stats":{"Line":0}},{"line":71,"address":[23768896],"length":1,"stats":{"Line":1}},{"line":83,"address":[23768992],"length":1,"stats":{"Line":2}},{"line":90,"address":[23771058,23771282],"length":1,"stats":{"Line":4}},{"line":91,"address":[23653001],"length":1,"stats":{"Line":2}},{"line":92,"address":[23727973,23727690],"length":1,"stats":{"Line":2}},{"line":93,"address":[23727682],"length":1,"stats":{"Line":1}},{"line":98,"address":[26449632,26450060,26451433,26449786,26449273,26449095,26449358],"length":1,"stats":{"Line":12}},{"line":100,"address":[23659982],"length":1,"stats":{"Line":2}},{"line":101,"address":[11738780],"length":1,"stats":{"Line":7}},{"line":103,"address":[23867205,23867035],"length":1,"stats":{"Line":2}},{"line":106,"address":[23728759],"length":1,"stats":{"Line":1}},{"line":107,"address":[23739296,23739305],"length":1,"stats":{"Line":2}},{"line":108,"address":[23671597,23671584],"length":1,"stats":{"Line":2}},{"line":111,"address":[23766992],"length":1,"stats":{"Line":1}},{"line":112,"address":[23735894],"length":1,"stats":{"Line":1}},{"line":113,"address":[23654450],"length":1,"stats":{"Line":1}},{"line":114,"address":[23772814],"length":1,"stats":{"Line":1}},{"line":115,"address":[23772890],"length":1,"stats":{"Line":1}},{"line":116,"address":[23654752,23654677],"length":1,"stats":{"Line":2}},{"line":117,"address":[23736304],"length":1,"stats":{"Line":1}},{"line":119,"address":[23771499],"length":1,"stats":{"Line":1}},{"line":123,"address":[23668920,23669122,23669381,23669800,23669722,23669496,23669025],"length":1,"stats":{"Line":6}},{"line":125,"address":[26451242],"length":1,"stats":{"Line":1}},{"line":126,"address":[23659651,23662407,23662698,23662259,23662115,23662168],"length":1,"stats":{"Line":3}},{"line":127,"address":[11695286],"length":1,"stats":{"Line":2}},{"line":129,"address":[23656614,23656488,23656222,23656760,23656098],"length":1,"stats":{"Line":4}},{"line":130,"address":[23663320,23663039,23662979,23659672,23663164,23663496],"length":1,"stats":{"Line":3}},{"line":131,"address":[11037832],"length":1,"stats":{"Line":3}},{"line":133,"address":[23770190],"length":1,"stats":{"Line":2}},{"line":134,"address":[23773990],"length":1,"stats":{"Line":2}},{"line":135,"address":[23731995],"length":1,"stats":{"Line":2}},{"line":136,"address":[23671183],"length":1,"stats":{"Line":2}},{"line":140,"address":[26453760],"length":1,"stats":{"Line":1}},{"line":148,"address":[23771250,23771107],"length":1,"stats":{"Line":2}},{"line":149,"address":[23775247,23775475,23776084,23775305],"length":1,"stats":{"Line":2}},{"line":151,"address":[23775868,23776389,23776675,23777027,23775433,23775993,23776253],"length":1,"stats":{"Line":5}},{"line":154,"address":[17913320],"length":1,"stats":{"Line":1}},{"line":156,"address":[17913352],"length":1,"stats":{"Line":1}},{"line":158,"address":[23733684],"length":1,"stats":{"Line":1}},{"line":160,"address":[23659987,23659310,23659369,23658457,23659495,23659677],"length":1,"stats":{"Line":3}},{"line":162,"address":[26455777,26455938],"length":1,"stats":{"Line":2}},{"line":163,"address":[17915545,17915613,17914584,17915489,17914462],"length":1,"stats":{"Line":5}},{"line":164,"address":[26457117,26457656,26457717,26456524,26456336,26456826],"length":1,"stats":{"Line":5}},{"line":167,"address":[23661761],"length":1,"stats":{"Line":1}},{"line":168,"address":[23778427],"length":1,"stats":{"Line":1}},{"line":169,"address":[26457584],"length":1,"stats":{"Line":1}},{"line":171,"address":[11639426],"length":1,"stats":{"Line":4}},{"line":172,"address":[23667639,23667923],"length":1,"stats":{"Line":2}},{"line":175,"address":[23736118],"length":1,"stats":{"Line":1}},{"line":176,"address":[17915710],"length":1,"stats":{"Line":1}},{"line":177,"address":[23779747],"length":1,"stats":{"Line":1}},{"line":178,"address":[17915816],"length":1,"stats":{"Line":1}},{"line":182,"address":[23662288],"length":1,"stats":{"Line":1}},{"line":188,"address":[23875903,23875760],"length":1,"stats":{"Line":2}},{"line":189,"address":[23775596,23775654,23775846,23776218],"length":1,"stats":{"Line":2}},{"line":190,"address":[23781388,23781971,23781664,23781755,23782742,23782390,23782107],"length":1,"stats":{"Line":5}},{"line":192,"address":[23670092],"length":1,"stats":{"Line":1}},{"line":193,"address":[23776187,23776269,23776758,23776128,23775446,23776451],"length":1,"stats":{"Line":3}},{"line":195,"address":[23738612,23738784],"length":1,"stats":{"Line":2}},{"line":196,"address":[23780865,23782604,23782542,23780987],"length":1,"stats":{"Line":4}},{"line":198,"address":[17920308],"length":1,"stats":{"Line":1}},{"line":199,"address":[23679834],"length":1,"stats":{"Line":1}},{"line":200,"address":[23778834],"length":1,"stats":{"Line":1}},{"line":201,"address":[23740752],"length":1,"stats":{"Line":1}},{"line":205,"address":[26461807,26462181,26462306],"length":1,"stats":{"Line":2}},{"line":206,"address":[17921236,17918931,17921171,17919107,17919415,17920931],"length":1,"stats":{"Line":5}},{"line":209,"address":[23673505],"length":1,"stats":{"Line":1}},{"line":210,"address":[23779451],"length":1,"stats":{"Line":1}},{"line":211,"address":[23748315],"length":1,"stats":{"Line":1}},{"line":213,"address":[11114510],"length":1,"stats":{"Line":4}},{"line":214,"address":[26460572,26460822],"length":1,"stats":{"Line":2}},{"line":216,"address":[23784955],"length":1,"stats":{"Line":0}},{"line":219,"address":[23672027,23672302],"length":1,"stats":{"Line":2}},{"line":220,"address":[23665269],"length":1,"stats":{"Line":1}},{"line":221,"address":[17919615],"length":1,"stats":{"Line":1}},{"line":222,"address":[23665393],"length":1,"stats":{"Line":1}},{"line":223,"address":[23782056],"length":1,"stats":{"Line":1}},{"line":227,"address":[26461972],"length":1,"stats":{"Line":1}},{"line":228,"address":[23747761],"length":1,"stats":{"Line":1}},{"line":229,"address":[23747814],"length":1,"stats":{"Line":1}},{"line":230,"address":[23666341],"length":1,"stats":{"Line":1}},{"line":234,"address":[26463120],"length":1,"stats":{"Line":1}},{"line":240,"address":[23667993,23667876],"length":1,"stats":{"Line":2}},{"line":241,"address":[26463676,26463845,26463569],"length":1,"stats":{"Line":3}},{"line":243,"address":[11719924],"length":1,"stats":{"Line":3}},{"line":246,"address":[26464016],"length":1,"stats":{"Line":1}},{"line":254,"address":[23683553,23684695,23682917,23682645,23683205,23683331,23683006],"length":1,"stats":{"Line":5}},{"line":256,"address":[23743711],"length":1,"stats":{"Line":1}},{"line":257,"address":[23781972,23781907,23782197,23782449,23781665,23782038],"length":1,"stats":{"Line":3}},{"line":259,"address":[23669708,23669878],"length":1,"stats":{"Line":2}},{"line":262,"address":[23751432],"length":1,"stats":{"Line":1}},{"line":263,"address":[23788235],"length":1,"stats":{"Line":1}},{"line":264,"address":[23676810],"length":1,"stats":{"Line":1}},{"line":265,"address":[17924406],"length":1,"stats":{"Line":1}},{"line":266,"address":[23676962],"length":1,"stats":{"Line":1}},{"line":268,"address":[23751791],"length":1,"stats":{"Line":1}},{"line":274,"address":[17925051,17925285,17923286,17924945],"length":1,"stats":{"Line":2}},{"line":275,"address":[23787961],"length":1,"stats":{"Line":1}},{"line":276,"address":[23784078],"length":1,"stats":{"Line":1}},{"line":277,"address":[23681107,23678335,23680835,23678459,23680961],"length":1,"stats":{"Line":4}},{"line":278,"address":[11717419],"length":1,"stats":{"Line":3}},{"line":279,"address":[23781728,23787317,23787061,23786933],"length":1,"stats":{"Line":2}},{"line":280,"address":[23787505],"length":1,"stats":{"Line":1}},{"line":282,"address":[23784165],"length":1,"stats":{"Line":1}},{"line":283,"address":[23884956,23884594,23885528,23884868],"length":1,"stats":{"Line":3}},{"line":284,"address":[23685646,23828521,23828655,23687367,23685700,23686228,23686945],"length":1,"stats":{"Line":0}},{"line":288,"address":[23785116],"length":1,"stats":{"Line":1}},{"line":290,"address":[23678586],"length":1,"stats":{"Line":0}},{"line":296,"address":[23793296],"length":1,"stats":{"Line":0}},{"line":303,"address":[23792369,23792288,23792148],"length":1,"stats":{"Line":0}},{"line":304,"address":[26471995,26480831,26480887,26471648,26480656,26471753],"length":1,"stats":{"Line":0}},{"line":306,"address":[23802661],"length":1,"stats":{"Line":0}},{"line":307,"address":[23801077,23801018],"length":1,"stats":{"Line":0}},{"line":309,"address":[23792753,23792564],"length":1,"stats":{"Line":0}},{"line":311,"address":[23675699],"length":1,"stats":{"Line":0}},{"line":314,"address":[23889265],"length":1,"stats":{"Line":0}},{"line":315,"address":[23793461,23793015],"length":1,"stats":{"Line":0}},{"line":317,"address":[23889532,23889404,23889865,23897696,23889809,23897984,23897928],"length":1,"stats":{"Line":0}},{"line":318,"address":[23698411],"length":1,"stats":{"Line":0}},{"line":319,"address":[17939030,17938960],"length":1,"stats":{"Line":0}},{"line":324,"address":[26472715],"length":1,"stats":{"Line":0}},{"line":325,"address":[23690583],"length":1,"stats":{"Line":0}},{"line":326,"address":[23795516,23795194,23797970,23803232],"length":1,"stats":{"Line":0}},{"line":328,"address":[23684960],"length":1,"stats":{"Line":0}},{"line":330,"address":[17931447,17933958,17931620,17931862],"length":1,"stats":{"Line":0}},{"line":332,"address":[23691270,23698864,23698881],"length":1,"stats":{"Line":0}},{"line":333,"address":[23890553,23898352,23890726,23898356],"length":1,"stats":{"Line":0}},{"line":335,"address":[23684446],"length":1,"stats":{"Line":0}},{"line":336,"address":[23678208,23679314,23677914,23685312,23677730],"length":1,"stats":{"Line":0}},{"line":338,"address":[26481616],"length":1,"stats":{"Line":0}},{"line":344,"address":[23790826],"length":1,"stats":{"Line":0}},{"line":345,"address":[23794933],"length":1,"stats":{"Line":0}},{"line":346,"address":[23791072],"length":1,"stats":{"Line":0}},{"line":347,"address":[23795083],"length":1,"stats":{"Line":0}},{"line":350,"address":[23791249],"length":1,"stats":{"Line":0}},{"line":351,"address":[23891703,23891763],"length":1,"stats":{"Line":0}},{"line":356,"address":[23892082,23892188,23888644,23892817],"length":1,"stats":{"Line":0}},{"line":357,"address":[23796725],"length":1,"stats":{"Line":0}},{"line":358,"address":[23761658],"length":1,"stats":{"Line":0}},{"line":359,"address":[23761835,23761959,23764238,23764364,23764510],"length":1,"stats":{"Line":0}},{"line":360,"address":[23689391,23689726,23687196,23687256,23689550,23682377],"length":1,"stats":{"Line":0}},{"line":361,"address":[23793902,23801312,23801490,23801184],"length":1,"stats":{"Line":0}},{"line":362,"address":[23697150],"length":1,"stats":{"Line":0}},{"line":364,"address":[17934529],"length":1,"stats":{"Line":0}},{"line":365,"address":[23893720,23895581,23893358,23893632],"length":1,"stats":{"Line":0}},{"line":366,"address":[23933679,23798992,23799512,23798938,23933545],"length":1,"stats":{"Line":0}},{"line":371,"address":[23799045],"length":1,"stats":{"Line":0}},{"line":372,"address":[23681176],"length":1,"stats":{"Line":0}},{"line":375,"address":[23793270],"length":1,"stats":{"Line":0}},{"line":380,"address":[23794403,23800385,23800465,23796032,23800884,23796224,23800634],"length":1,"stats":{"Line":0}},{"line":381,"address":[11737258],"length":1,"stats":{"Line":0}},{"line":382,"address":[23699232],"length":1,"stats":{"Line":0}},{"line":383,"address":[23699286],"length":1,"stats":{"Line":0}},{"line":384,"address":[23898558],"length":1,"stats":{"Line":0}},{"line":390,"address":[23695263,23692400,23692951,23692610,23692352,23692375,23692431,23692701],"length":1,"stats":{"Line":4}},{"line":391,"address":[17940181,17940088,17940216],"length":1,"stats":{"Line":4}},{"line":392,"address":[11643860],"length":1,"stats":{"Line":3}},{"line":393,"address":[23700397,23829513,23700898,23700296,23829647],"length":1,"stats":{"Line":0}},{"line":403,"address":[23806784],"length":1,"stats":{"Line":1}},{"line":408,"address":[23688745,23689262,23689081,23689016],"length":1,"stats":{"Line":4}},{"line":411,"address":[23695680],"length":1,"stats":{"Line":1}},{"line":412,"address":[23702705],"length":1,"stats":{"Line":1}},{"line":413,"address":[23805597],"length":1,"stats":{"Line":1}},{"line":415,"address":[11737060],"length":1,"stats":{"Line":3}},{"line":419,"address":[23703200],"length":1,"stats":{"Line":1}},{"line":420,"address":[23806106],"length":1,"stats":{"Line":1}},{"line":421,"address":[23806136],"length":1,"stats":{"Line":1}},{"line":422,"address":[23696336],"length":1,"stats":{"Line":0}},{"line":423,"address":[23802352],"length":1,"stats":{"Line":0}},{"line":424,"address":[23703548],"length":1,"stats":{"Line":0}},{"line":425,"address":[23703430],"length":1,"stats":{"Line":0}},{"line":426,"address":[17943979],"length":1,"stats":{"Line":0}},{"line":433,"address":[23703584],"length":1,"stats":{"Line":1}},{"line":436,"address":[23689851],"length":1,"stats":{"Line":1}},{"line":437,"address":[23703642],"length":1,"stats":{"Line":1}},{"line":438,"address":[23696708],"length":1,"stats":{"Line":0}},{"line":439,"address":[23764624],"length":1,"stats":{"Line":0}},{"line":440,"address":[23696956],"length":1,"stats":{"Line":0}},{"line":441,"address":[23903126],"length":1,"stats":{"Line":0}},{"line":442,"address":[23806699],"length":1,"stats":{"Line":0}},{"line":449,"address":[23771728],"length":1,"stats":{"Line":1}},{"line":450,"address":[23703989],"length":1,"stats":{"Line":1}},{"line":453,"address":[17944576],"length":1,"stats":{"Line":1}},{"line":454,"address":[23697070],"length":1,"stats":{"Line":1}},{"line":455,"address":[23704060],"length":1,"stats":{"Line":1}},{"line":456,"address":[17944617,17944700],"length":1,"stats":{"Line":2}},{"line":457,"address":[23697143],"length":1,"stats":{"Line":0}},{"line":461,"address":[23771868],"length":1,"stats":{"Line":0}}],"covered":129,"coverable":192},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","core.rs"],"content":"use super::distribution::distribute_hybrid;\nuse super::factory::build_deletion_event;\nuse crate::application::ports::event_gateway::EventGateway;\nuse crate::application::ports::repositories::EventRepository;\nuse crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::application::services::{SubscriptionRecord, SubscriptionStateStore};\nuse crate::application::shared::mappers::{\n    domain_event_from_event, dto_to_profile_metadata, parse_event_id, parse_event_ids,\n    parse_optional_event_id,\n};\nuse crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::event_gateway::{ReactionValue, TopicContent};\nuse crate::domain::value_objects::{EventId, TopicId};\nuse crate::infrastructure::crypto::SignatureService;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::presentation::dto::event::NostrMetadataDto;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\npub struct EventService {\n    pub(crate) repository: Arc<dyn EventRepository>,\n    pub(crate) signature_service: Arc<dyn SignatureService>,\n    pub(crate) distributor: Arc<dyn EventDistributor>,\n    pub(crate) event_gateway: Arc<dyn EventGateway>,\n    pub(crate) subscription_state: Arc<dyn SubscriptionStateStore>,\n    pub(crate) subscription_invoker: Option<Arc<dyn SubscriptionInvoker>>,\n}\n\nimpl EventService {\n    pub fn new(\n        repository: Arc<dyn EventRepository>,\n        signature_service: Arc<dyn SignatureService>,\n        distributor: Arc<dyn EventDistributor>,\n        event_gateway: Arc<dyn EventGateway>,\n        subscription_state: Arc<dyn SubscriptionStateStore>,\n    ) -> Self {\n        Self {\n            repository,\n            signature_service,\n            distributor,\n            event_gateway,\n            subscription_state,\n            subscription_invoker: None,\n        }\n    }\n\n    /// Attach the subscription invoker used to execute subscriptions.\n    pub fn set_subscription_invoker(&mut self, invoker: Arc<dyn SubscriptionInvoker>) {\n        self.subscription_invoker = Some(invoker);\n    }\n\n    pub(crate) fn subscription_invoker(&self) -> Result<&Arc<dyn SubscriptionInvoker>, AppError> {\n        self.subscription_invoker\n            .as_ref()\n            .ok_or_else(|| AppError::ConfigurationError(\"Subscription invoker not set\".to_string()))\n    }\n\n    pub async fn create_event(\n        &self,\n        kind: u32,\n        content: String,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<Event, AppError> {\n        let mut event = Event::new(kind, content, pubkey);\n\n        self.signature_service\n            .sign_event(&mut event, private_key)\n            .await?;\n\n        self.repository.create_event(&event).await?;\n        distribute_hybrid(&self.distributor, &event).await?;\n\n        Ok(event)\n    }\n\n    pub async fn process_received_event(&self, event: Event) -> Result<(), AppError> {\n        if !self.signature_service.verify_event(&event).await? {\n            return Err(\"Invalid event signature\".into());\n        }\n\n        self.repository.create_event(&event).await?;\n\n        if matches!(\n            EventKind::from_u32(event.kind),\n            Some(EventKind::TextNote)\n                | Some(EventKind::Metadata)\n                | Some(EventKind::Reaction)\n                | Some(EventKind::Repost)\n        ) {\n            let domain_event = domain_event_from_event(&event)?;\n            self.event_gateway\n                .handle_incoming_event(domain_event)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        self.repository.get_event(id).await\n    }\n\n    pub async fn get_events_by_kind(\n        &self,\n        kind: u32,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_kind(kind, limit).await\n    }\n\n    pub async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_author(pubkey, limit).await\n    }\n\n    pub async fn delete_event(\n        &self,\n        id: &str,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<(), AppError> {\n        let mut deletion_event = build_deletion_event(id, pubkey);\n\n        self.signature_service\n            .sign_event(&mut deletion_event, private_key)\n            .await?;\n        self.repository.create_event(&deletion_event).await?;\n        distribute_hybrid(&self.distributor, &deletion_event).await?;\n\n        self.repository.delete_event(id).await\n    }\n\n    pub async fn sync_pending_events(&self) -> Result<u32, AppError> {\n        let unsync_events = self.repository.get_unsync_events().await?;\n        let mut synced_count = 0;\n\n        for event in unsync_events {\n            distribute_hybrid(&self.distributor, &event).await?;\n            self.repository.mark_event_synced(&event.id).await?;\n            synced_count += 1;\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[async_trait]\npub trait EventServiceTrait: Send + Sync {\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError>;\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError>;\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError>;\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError>;\n    async fn get_public_key(&self) -> Result<Option<String>, AppError>;\n    async fn boost_post(&self, event_id: &str) -> Result<EventId, AppError>;\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[async_trait]\nimpl EventServiceTrait for EventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\n        self.event_gateway.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        let topic = TopicId::new(topic_id.to_string()).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic ID: {err}\"),\n            )\n        })?;\n        let topic_content = TopicContent::parse(content).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic content: {err}\"),\n            )\n        })?;\n        let reply_to_id = parse_optional_event_id(reply_to)?;\n        self.event_gateway\n            .publish_topic_post(&topic, &topic_content, reply_to_id.as_ref(), scope, epoch)\n            .await\n    }\n\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError> {\n        let event_id = parse_event_id(event_id)?;\n        let reaction_value = ReactionValue::parse(reaction).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid reaction value: {err}\"),\n            )\n        })?;\n        self.event_gateway\n            .send_reaction(&event_id, &reaction_value)\n            .await\n    }\n\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError> {\n        let profile = dto_to_profile_metadata(metadata)?;\n        self.event_gateway.update_profile_metadata(&profile).await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_topic_internal(self, topic_id).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_user_internal(self, pubkey).await\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        self.event_gateway\n            .get_public_key()\n            .await\n            .map(|key| key.map(|pk| pk.as_hex().to_string()))\n    }\n\n    async fn boost_post(&self, event_id: &str) -> Result<EventId, AppError> {\n        let target_id = parse_event_id(event_id)?;\n        self.event_gateway.publish_repost(&target_id).await\n    }\n\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        if event_ids.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"No event IDs provided\",\n            ));\n        }\n\n        let parsed_ids = parse_event_ids(&event_ids)?;\n        let deletion_event_id = self\n            .event_gateway\n            .delete_events(&parsed_ids, reason.as_deref())\n            .await?;\n\n        for event_id in event_ids {\n            self.repository.delete_event(&event_id).await?;\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        self.event_gateway.disconnect().await\n    }\n\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        if topic_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Topic ID is required\",\n            ));\n        }\n        let topic = TopicId::new(topic_id.to_string()).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic ID: {err}\"),\n            )\n        })?;\n        self.event_gateway\n            .set_default_topics(std::slice::from_ref(&topic))\n            .await?;\n        Ok(())\n    }\n\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        super::subscription::list_subscriptions_internal(self).await\n    }\n}\n\n#[async_trait]\nimpl super::super::sync_service::SyncParticipant for EventService {\n    async fn sync_pending(&self) -> Result<u32, AppError> {\n        self.sync_pending_events().await\n    }\n}\n","traces":[{"line":31,"address":[12673824],"length":1,"stats":{"Line":0}},{"line":49,"address":[12672424,12672352],"length":1,"stats":{"Line":0}},{"line":50,"address":[12630328,12630407],"length":1,"stats":{"Line":0}},{"line":53,"address":[12555840],"length":1,"stats":{"Line":0}},{"line":54,"address":[12569632],"length":1,"stats":{"Line":0}},{"line":56,"address":[12672560,12672574],"length":1,"stats":{"Line":0}},{"line":59,"address":[12562800],"length":1,"stats":{"Line":0}},{"line":66,"address":[12563188],"length":1,"stats":{"Line":0}},{"line":68,"address":[26488824,26488394,26488333,26488561,26488209,26488687,26488972],"length":1,"stats":{"Line":0}},{"line":69,"address":[12563485],"length":1,"stats":{"Line":0}},{"line":70,"address":[12669180,12669504,12669567,12669451,12669900,12669703],"length":1,"stats":{"Line":0}},{"line":72,"address":[12770825,12770339,12769569,12770235,12770500,12770997],"length":1,"stats":{"Line":0}},{"line":73,"address":[26489937,26489404,26488146,26489275,26489802,26489475],"length":1,"stats":{"Line":0}},{"line":75,"address":[12632807],"length":1,"stats":{"Line":0}},{"line":78,"address":[12558467,12558559,12558742,12559048,12561236,12558432,12558512,12559704],"length":1,"stats":{"Line":0}},{"line":79,"address":[12771765,12772771,12771844,12771966,12772152],"length":1,"stats":{"Line":0}},{"line":80,"address":[26490959,26490887],"length":1,"stats":{"Line":0}},{"line":83,"address":[12678310,12679141,12677081,12677729,12677842,12678001],"length":1,"stats":{"Line":0}},{"line":85,"address":[12634740,12634757,12635741],"length":1,"stats":{"Line":0}},{"line":86,"address":[12641674,12641635,12641509],"length":1,"stats":{"Line":0}},{"line":92,"address":[12642351,12642041,12641771,12641847],"length":1,"stats":{"Line":0}},{"line":93,"address":[12574842,12574479,12575103,12574538,12574238,12574726,12574962],"length":1,"stats":{"Line":0}},{"line":94,"address":[12635246],"length":1,"stats":{"Line":0}},{"line":95,"address":[12679442,12679035,12677102,12679146,12679302,12679088],"length":1,"stats":{"Line":0}},{"line":98,"address":[12566998],"length":1,"stats":{"Line":0}},{"line":101,"address":[12575136,12575219,12575385,12575345,12575814,12575154,12575545,12575184],"length":1,"stats":{"Line":0}},{"line":102,"address":[12568396,12568601,12568348,12568473],"length":1,"stats":{"Line":0}},{"line":105,"address":[12636656],"length":1,"stats":{"Line":0}},{"line":110,"address":[12678926,12679002,12679131,12678878],"length":1,"stats":{"Line":0}},{"line":113,"address":[12569520],"length":1,"stats":{"Line":0}},{"line":118,"address":[12569988,12569730,12569778,12569860],"length":1,"stats":{"Line":0}},{"line":121,"address":[12776528],"length":1,"stats":{"Line":0}},{"line":127,"address":[12638391],"length":1,"stats":{"Line":0}},{"line":129,"address":[12682285,12682685,12682500,12682817,12682417,12682970,12683133],"length":1,"stats":{"Line":0}},{"line":130,"address":[12680757],"length":1,"stats":{"Line":0}},{"line":131,"address":[26495745,26495195,26495546,26495942,26495485,26495608],"length":1,"stats":{"Line":0}},{"line":132,"address":[12564721,12565197,12563892,12564617,12565370,12564882],"length":1,"stats":{"Line":0}},{"line":133,"address":[12572468,12572063,12572159,12571942,12570697,12572691],"length":1,"stats":{"Line":0}},{"line":135,"address":[12579729,12579539,12579411,12577694],"length":1,"stats":{"Line":0}},{"line":138,"address":[12566304,12567513,12566492,12566272,12566351,12566592,12566788,12566280],"length":1,"stats":{"Line":0}},{"line":139,"address":[12642083,12641042,12641866,12641250,12641114,12641412],"length":1,"stats":{"Line":0}},{"line":140,"address":[12641771],"length":1,"stats":{"Line":0}},{"line":142,"address":[12581904,12580957,12581167,12581962],"length":1,"stats":{"Line":0}},{"line":143,"address":[11581243],"length":1,"stats":{"Line":0}},{"line":144,"address":[12643452,12642454,12642148,12642540,12643618,12643314,12641156],"length":1,"stats":{"Line":0}},{"line":145,"address":[12581674,12581797,12581840],"length":1,"stats":{"Line":0}},{"line":148,"address":[20343256],"length":1,"stats":{"Line":0}},{"line":182,"address":[26673585,26673438,26673501,26673713,26673369,26673408,26673566],"length":1,"stats":{"Line":0}},{"line":183,"address":[12798745],"length":1,"stats":{"Line":0}},{"line":186,"address":[12866723,12866802,12866914,12866688,12867417,12867159,12866643,12866891],"length":1,"stats":{"Line":0}},{"line":187,"address":[11822772],"length":1,"stats":{"Line":0}},{"line":190,"address":[26674832,26675052,26676528,26676859,26674784,26674932,26674688],"length":1,"stats":{"Line":0}},{"line":198,"address":[12800412,12800703,12801700,12802080,12802299],"length":1,"stats":{"Line":0}},{"line":199,"address":[12913759],"length":1,"stats":{"Line":0}},{"line":200,"address":[12809077],"length":1,"stats":{"Line":0}},{"line":201,"address":[26676906,26676965],"length":1,"stats":{"Line":0}},{"line":204,"address":[12800788,12800617,12802336,12802555,12801016,12801698],"length":1,"stats":{"Line":0}},{"line":205,"address":[20570703],"length":1,"stats":{"Line":0}},{"line":206,"address":[20570549],"length":1,"stats":{"Line":0}},{"line":207,"address":[26677146,26677205],"length":1,"stats":{"Line":0}},{"line":210,"address":[12868909,12869064,12868766],"length":1,"stats":{"Line":0}},{"line":211,"address":[13007516,13007881,13008133,13007812],"length":1,"stats":{"Line":0}},{"line":212,"address":[13007700],"length":1,"stats":{"Line":0}},{"line":213,"address":[11894055],"length":1,"stats":{"Line":0}},{"line":216,"address":[12802633,12802930,12802739,12802704,12804093,12803795,12802818],"length":1,"stats":{"Line":0}},{"line":217,"address":[12870843,12871019,12871598],"length":1,"stats":{"Line":0}},{"line":218,"address":[12877912,12878077,12878298,12878848,12879067],"length":1,"stats":{"Line":0}},{"line":219,"address":[20572479],"length":1,"stats":{"Line":0}},{"line":220,"address":[12871941],"length":1,"stats":{"Line":0}},{"line":221,"address":[12804138,12804197],"length":1,"stats":{"Line":0}},{"line":224,"address":[12878222,12878406,12878665,12878465],"length":1,"stats":{"Line":0}},{"line":225,"address":[12878390],"length":1,"stats":{"Line":0}},{"line":226,"address":[12810718,12810803,12810953,12809821,12810674],"length":1,"stats":{"Line":0}},{"line":229,"address":[12805789,12804502,12804383,12805372,12804629,12804464,12804742],"length":1,"stats":{"Line":0}},{"line":230,"address":[13011650,13011195,13011374],"length":1,"stats":{"Line":0}},{"line":231,"address":[13011346,13010944,13011807,13011520],"length":1,"stats":{"Line":0}},{"line":234,"address":[13012431,13012644,13012905,13012243,13012408,13012325,13012159,13012208],"length":1,"stats":{"Line":0}},{"line":235,"address":[11936391],"length":1,"stats":{"Line":0}},{"line":238,"address":[12813696,12813647,12813813,12814393,12813896,12813919,12814132,12813731],"length":1,"stats":{"Line":0}},{"line":239,"address":[20575056,20575380,20575241],"length":1,"stats":{"Line":0}},{"line":242,"address":[12800704,12800739,12800818,12801445,12800907,12800665,12800930,12801161],"length":1,"stats":{"Line":0}},{"line":243,"address":[12801124,12801294,12801392,12801030],"length":1,"stats":{"Line":0}},{"line":245,"address":[11921492],"length":1,"stats":{"Line":0}},{"line":246,"address":[12876123,12876076,12876064,12876096],"length":1,"stats":{"Line":0}},{"line":249,"address":[12876562,12876275,12876336,12876371,12876450,12877092,12877370],"length":1,"stats":{"Line":0}},{"line":250,"address":[12808859,12809033,12809279],"length":1,"stats":{"Line":0}},{"line":251,"address":[12915236,12914925,12915093,12914589],"length":1,"stats":{"Line":0}},{"line":254,"address":[11813676,11813882],"length":1,"stats":{"Line":0}},{"line":259,"address":[12878114,12878029],"length":1,"stats":{"Line":0}},{"line":260,"address":[12920215,12920925],"length":1,"stats":{"Line":0}},{"line":261,"address":[12817327],"length":1,"stats":{"Line":0}},{"line":266,"address":[12885048,12885161,12885333,12885777],"length":1,"stats":{"Line":0}},{"line":267,"address":[12810920,12810985,12811604,12811799,12811237,12811353,12810551],"length":1,"stats":{"Line":0}},{"line":269,"address":[13017050],"length":1,"stats":{"Line":0}},{"line":270,"address":[11880991],"length":1,"stats":{"Line":0}},{"line":272,"address":[12811479,12811692,12812427,12812359],"length":1,"stats":{"Line":0}},{"line":273,"address":[26687112,26684353,26686169,26686536,26686475,26686772],"length":1,"stats":{"Line":0}},{"line":276,"address":[12887235],"length":1,"stats":{"Line":0}},{"line":279,"address":[12920092,12919337,12919411,12919834,12919490,12919579,12919602,12919376],"length":1,"stats":{"Line":0}},{"line":280,"address":[12806998,12806813,12807162],"length":1,"stats":{"Line":0}},{"line":283,"address":[12807738,12808983,12808521,12808952,12807427,12807488,12807526,12807620],"length":1,"stats":{"Line":0}},{"line":284,"address":[12889372],"length":1,"stats":{"Line":0}},{"line":285,"address":[26688952,26689467],"length":1,"stats":{"Line":0}},{"line":286,"address":[12882516],"length":1,"stats":{"Line":0}},{"line":290,"address":[12890731,12889494,12890005,12889409,12889745,12890512],"length":1,"stats":{"Line":0}},{"line":291,"address":[26690127],"length":1,"stats":{"Line":0}},{"line":292,"address":[12822773],"length":1,"stats":{"Line":0}},{"line":293,"address":[12883669,12883610],"length":1,"stats":{"Line":0}},{"line":296,"address":[12921361,12921087,12921465,12920853,12921146,12921596],"length":1,"stats":{"Line":0}},{"line":297,"address":[12921034],"length":1,"stats":{"Line":0}},{"line":298,"address":[12040390],"length":1,"stats":{"Line":0}},{"line":299,"address":[20583789],"length":1,"stats":{"Line":0}},{"line":302,"address":[20584386,20584307,20584233,20584970,20584712,20584272,20584469,20584492],"length":1,"stats":{"Line":0}},{"line":303,"address":[12816408,12816221,12816552],"length":1,"stats":{"Line":0}},{"line":309,"address":[12928795,12928368,12928403,12928319,12928485,12929056,12928591,12928568],"length":1,"stats":{"Line":0}},{"line":310,"address":[11860599],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":116},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","distribution.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::p2p::DistributionStrategy;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub(crate) async fn distribute_hybrid(\n    distributor: &Arc<dyn EventDistributor>,\n    event: &Event,\n) -> Result<(), AppError> {\n    distributor\n        .distribute(event, DistributionStrategy::Hybrid)\n        .await?;\n    Ok(())\n}\n","traces":[{"line":7,"address":[13488448],"length":1,"stats":{"Line":0}},{"line":11,"address":[13549827,13549935,13549661,13550053,13550127,13549594,13549453],"length":1,"stats":{"Line":0}},{"line":12,"address":[13591634],"length":1,"stats":{"Line":0}},{"line":13,"address":[11743654],"length":1,"stats":{"Line":0}},{"line":14,"address":[13593707],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","factory.rs"],"content":"pub(crate) use crate::application::shared::nostr::build_deletion_event;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","mod.rs"],"content":"pub mod core;\npub mod distribution;\npub mod factory;\npub mod subscription;\n\npub use core::{EventService, EventServiceTrait};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","subscription.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::Utc;\nuse tracing::warn;\n\nuse super::EventService;\n\nimpl EventService {\n    pub async fn handle_network_disconnected(&self) -> Result<(), AppError> {\n        self.subscription_state.mark_all_need_resync().await\n    }\n\n    pub async fn handle_network_connected(&self) -> Result<(), AppError> {\n        self.restore_subscriptions().await\n    }\n\n    async fn restore_subscriptions(&self) -> Result<(), AppError> {\n        let invoker = self.subscription_invoker()?;\n\n        let records = self.subscription_state.list_for_restore().await?;\n        let mut failure_message: Option<String> = None;\n\n        for record in records {\n            let target = record.target.clone();\n            let since = record.since_timestamp();\n            let target_label = match &target {\n                SubscriptionTarget::Topic(t) => format!(\"topic:{t}\"),\n                SubscriptionTarget::User(u) => format!(\"user:{u}\"),\n            };\n\n            let result = match &target {\n                SubscriptionTarget::Topic(topic_id) => {\n                    invoker.subscribe_topic(topic_id, since).await\n                }\n                SubscriptionTarget::User(pubkey) => invoker.subscribe_user(pubkey, since).await,\n            };\n\n            match result {\n                Ok(_) => {\n                    self.subscription_state\n                        .mark_subscribed(&target, Utc::now().timestamp())\n                        .await?;\n                }\n                Err(err) => {\n                    let err_message = err.to_string();\n                    if let Err(store_err) = self\n                        .subscription_state\n                        .mark_failure(&target, &err_message)\n                        .await\n                    {\n                        warn!(\n                            \"Failed to record subscription failure for {}: {}\",\n                            target_label, store_err\n                        );\n                    }\n                    warn!(\n                        \"Failed to restore subscription for {}: {}\",\n                        target_label, err_message\n                    );\n                    failure_message = Some(err_message);\n                }\n            }\n        }\n\n        if let Some(message) = failure_message {\n            Err(AppError::NostrError(message))\n        } else {\n            Ok(())\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_topic_internal(\n    service: &EventService,\n    topic_id: &str,\n) -> Result<(), AppError> {\n    if topic_id.is_empty() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Topic ID is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::Topic(topic_id.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_topic(topic_id, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for topic {}: {}\",\n                    topic_id, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_user_internal(\n    service: &EventService,\n    pubkey: &str,\n) -> Result<(), AppError> {\n    if pubkey.is_empty() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Public key is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::User(pubkey.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_user(pubkey, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for user {}: {}\",\n                    pubkey, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn list_subscriptions_internal(\n    service: &EventService,\n) -> Result<Vec<SubscriptionRecord>, AppError> {\n    service.subscription_state.list_all().await\n}\n","traces":[{"line":9,"address":[12643680,12644259,12643672,12643843,12643806,12643994,12643664,12643715],"length":1,"stats":{"Line":0}},{"line":10,"address":[12682138,12682009,12681893,12681945],"length":1,"stats":{"Line":0}},{"line":13,"address":[12569688,12570275,12569712,12569992,12569747,12569680,12569835,12569872],"length":1,"stats":{"Line":0}},{"line":14,"address":[20344792,20344838,20345000,20344895],"length":1,"stats":{"Line":0}},{"line":17,"address":[12570288,12570320,12570367,12570296,12571921,12571174,12570530,12570657],"length":1,"stats":{"Line":0}},{"line":18,"address":[12577899,12577280,12577614,12577491],"length":1,"stats":{"Line":0}},{"line":20,"address":[12689970,12689494,12688848,12690187,12689075,12689261],"length":1,"stats":{"Line":0}},{"line":21,"address":[12689856],"length":1,"stats":{"Line":0}},{"line":23,"address":[12784677,12789638,12784887,12789690],"length":1,"stats":{"Line":0}},{"line":24,"address":[12576726],"length":1,"stats":{"Line":0}},{"line":25,"address":[12590889],"length":1,"stats":{"Line":0}},{"line":26,"address":[12590963],"length":1,"stats":{"Line":0}},{"line":27,"address":[20352217,20352306],"length":1,"stats":{"Line":0}},{"line":28,"address":[12584072,12584258],"length":1,"stats":{"Line":0}},{"line":31,"address":[12690143],"length":1,"stats":{"Line":0}},{"line":32,"address":[12577594],"length":1,"stats":{"Line":0}},{"line":33,"address":[11805736],"length":1,"stats":{"Line":0}},{"line":35,"address":[11917265],"length":1,"stats":{"Line":0}},{"line":38,"address":[12696512],"length":1,"stats":{"Line":0}},{"line":40,"address":[12592533,12592857,12593111,12592798,12593216,12592995],"length":1,"stats":{"Line":0}},{"line":41,"address":[12585721],"length":1,"stats":{"Line":0}},{"line":42,"address":[11805786],"length":1,"stats":{"Line":0}},{"line":44,"address":[12592576],"length":1,"stats":{"Line":0}},{"line":45,"address":[12586477,12585650],"length":1,"stats":{"Line":0}},{"line":46,"address":[12690474,12690686,12698179,12698122,12697996],"length":1,"stats":{"Line":0}},{"line":48,"address":[12692469],"length":1,"stats":{"Line":0}},{"line":49,"address":[12792985,12785354,12785113,12792934,12783716],"length":1,"stats":{"Line":0}},{"line":51,"address":[20598239,20461268,20461175,20598105,20461765],"length":1,"stats":{"Line":0}},{"line":56,"address":[20350476,20586461,20349504,20349907,20349256,20350162,20586327,20349659],"length":1,"stats":{"Line":0}},{"line":60,"address":[12574813,12576129],"length":1,"stats":{"Line":0}},{"line":65,"address":[12693582,12693398],"length":1,"stats":{"Line":0}},{"line":66,"address":[12576860],"length":1,"stats":{"Line":0}},{"line":68,"address":[12658464],"length":1,"stats":{"Line":0}},{"line":73,"address":[12661504],"length":1,"stats":{"Line":0}},{"line":77,"address":[20355374,20355178],"length":1,"stats":{"Line":0}},{"line":78,"address":[12794155],"length":1,"stats":{"Line":0}},{"line":79,"address":[12580435],"length":1,"stats":{"Line":0}},{"line":80,"address":[20355419],"length":1,"stats":{"Line":0}},{"line":84,"address":[20355568,20355380,20356000,20355453],"length":1,"stats":{"Line":0}},{"line":86,"address":[12580677,12580557],"length":1,"stats":{"Line":0}},{"line":87,"address":[20470559,20469136,20469286,20469878,20470214,20469686,20469373],"length":1,"stats":{"Line":0}},{"line":89,"address":[12594595],"length":1,"stats":{"Line":0}},{"line":90,"address":[11582290],"length":1,"stats":{"Line":0}},{"line":91,"address":[12588531,12588722],"length":1,"stats":{"Line":0}},{"line":93,"address":[11688232],"length":1,"stats":{"Line":0}},{"line":95,"address":[12583478,12583594,12583704,12582909,12582826,12582547],"length":1,"stats":{"Line":0}},{"line":97,"address":[20357702],"length":1,"stats":{"Line":0}},{"line":98,"address":[12664386,12661827,12665176,12665046,12664887,12664451],"length":1,"stats":{"Line":0}},{"line":99,"address":[20471943],"length":1,"stats":{"Line":0}},{"line":101,"address":[12596350],"length":1,"stats":{"Line":0}},{"line":102,"address":[12795727],"length":1,"stats":{"Line":0}},{"line":103,"address":[12696605,12695720,12695929,12696012,12696769],"length":1,"stats":{"Line":0}},{"line":105,"address":[12657731],"length":1,"stats":{"Line":0}},{"line":106,"address":[19350551],"length":1,"stats":{"Line":0}},{"line":108,"address":[12696842,12924701,12696943,12924567,12697156,12697311,12697955,12697698,12697470],"length":1,"stats":{"Line":0}},{"line":113,"address":[12585837],"length":1,"stats":{"Line":0}},{"line":118,"address":[20361056],"length":1,"stats":{"Line":0}},{"line":122,"address":[12699198,12699002],"length":1,"stats":{"Line":0}},{"line":123,"address":[12587179],"length":1,"stats":{"Line":0}},{"line":124,"address":[12799603],"length":1,"stats":{"Line":0}},{"line":125,"address":[12586539],"length":1,"stats":{"Line":0}},{"line":129,"address":[12600260,12600333,12600448,12600880],"length":1,"stats":{"Line":0}},{"line":131,"address":[12600413,12600533],"length":1,"stats":{"Line":0}},{"line":132,"address":[20475542,20475734,20475142,20476415,20475229,20476070,20474992],"length":1,"stats":{"Line":0}},{"line":134,"address":[12668451],"length":1,"stats":{"Line":0}},{"line":135,"address":[11689250],"length":1,"stats":{"Line":0}},{"line":136,"address":[12601794,12601603],"length":1,"stats":{"Line":0}},{"line":138,"address":[11645576],"length":1,"stats":{"Line":0}},{"line":140,"address":[12707978,12706931,12707210,12707293,12708088,12707862],"length":1,"stats":{"Line":0}},{"line":142,"address":[12701526],"length":1,"stats":{"Line":0}},{"line":143,"address":[12706103,12703043,12706392,12705602,12705667,12706262],"length":1,"stats":{"Line":0}},{"line":144,"address":[12708030],"length":1,"stats":{"Line":0}},{"line":146,"address":[12705326],"length":1,"stats":{"Line":0}},{"line":147,"address":[20476848],"length":1,"stats":{"Line":0}},{"line":148,"address":[12705752,12706637,12705961,12706044,12706801],"length":1,"stats":{"Line":0}},{"line":150,"address":[20477316],"length":1,"stats":{"Line":0}},{"line":151,"address":[10963051],"length":1,"stats":{"Line":0}},{"line":153,"address":[12604308,12826269,12603994,12604850,12604095,12604463,12604622,12605107,12826135],"length":1,"stats":{"Line":0}},{"line":158,"address":[12666525],"length":1,"stats":{"Line":0}},{"line":163,"address":[12605936],"length":1,"stats":{"Line":0}},{"line":166,"address":[12667001,12667130,12666885,12666937],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","mod.rs"],"content":"pub mod access_control_service;\npub mod auth_lifecycle;\npub mod auth_service;\npub mod direct_message_service;\npub mod event_service;\npub mod offline_service;\npub mod p2p_service;\npub mod post_service;\npub mod profile_avatar_service;\nmod subscription_state;\npub mod sync_service;\npub mod topic_service;\npub mod user_search_service;\npub mod user_service;\n\npub use crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use access_control_service::{\n    AccessControlService, JoinRequestApprovalResult, JoinRequestInput, JoinRequestResult,\n};\npub use auth_lifecycle::DefaultAuthLifecycle;\npub use auth_service::AuthService;\npub use direct_message_service::{\n    DirectMessageConversationPageResult, DirectMessagePageResult, DirectMessageService,\n    MessagePageDirection as DirectMessageServiceDirection, SendDirectMessageResult,\n};\npub use event_service::EventService;\npub use offline_service::OfflineService;\npub use p2p_service::P2PService;\npub use post_service::PostService;\npub use profile_avatar_service::{\n    ProfileAvatarFetchResult, ProfileAvatarService, UploadProfileAvatarInput,\n};\npub use subscription_state::{SubscriptionStateMachine, SubscriptionStateStore};\npub use sync_service::{SyncService, SyncServiceTrait};\npub use topic_service::TopicService;\npub use user_search_service::UserSearchService;\npub use user_service::UserService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","offline_service.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft, OfflineActionFilter,\n    OfflineActionRecord, OptimisticUpdateDraft, SavedOfflineAction, SyncQueueItem,\n    SyncQueueItemDraft, SyncResult, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, OptimisticUpdateId, SyncQueueId,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct SaveOfflineActionParams {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub payload: OfflinePayload,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct OfflineActionsQuery {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\n#[async_trait]\npub trait OfflineServiceTrait: Send + Sync {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError>;\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError>;\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n}\n\npub struct OfflineService {\n    persistence: Arc<dyn OfflinePersistence>,\n}\n\nimpl OfflineService {\n    pub fn new(persistence: Arc<dyn OfflinePersistence>) -> Self {\n        Self { persistence }\n    }\n\n    fn build_action_draft(\n        params: &SaveOfflineActionParams,\n    ) -> Result<OfflineActionDraft, AppError> {\n        let payload_value = params.payload.clone().into_inner();\n        let mut map = match payload_value {\n            Value::Object(map) => map,\n            _ => {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Offline action payload must be a JSON object\",\n                ));\n            }\n        };\n\n        map.insert(\n            \"entityType\".to_string(),\n            Value::String(params.entity_type.to_string()),\n        );\n        map.insert(\n            \"entityId\".to_string(),\n            Value::String(params.entity_id.to_string()),\n        );\n\n        let enriched_payload = OfflinePayload::new(Value::Object(map))\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err.to_string()))?;\n\n        Ok(OfflineActionDraft::new(\n            params.user_pubkey.clone(),\n            params.action_type.clone(),\n            Some(params.entity_id.clone()),\n            enriched_payload,\n        ))\n    }\n\n    fn filter_from_query(query: &OfflineActionsQuery) -> OfflineActionFilter {\n        OfflineActionFilter::new(query.user_pubkey.clone(), query.include_synced, query.limit)\n    }\n}\n\n#[async_trait]\nimpl OfflineServiceTrait for OfflineService {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError> {\n        let draft = Self::build_action_draft(&params)?;\n        self.persistence.save_action(draft).await\n    }\n\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError> {\n        let filter = Self::filter_from_query(&query);\n        self.persistence.list_actions(filter).await\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        self.persistence.sync_actions(user_pubkey).await\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        self.persistence.cache_status().await\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        self.persistence.enqueue_sync(draft).await\n    }\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError> {\n        self.persistence.recent_sync_queue_items(limit).await\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        self.persistence.upsert_cache_metadata(update).await\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        self.persistence.save_optimistic_update(draft).await\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        self.persistence.confirm_optimistic_update(update_id).await\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        self.persistence.rollback_optimistic_update(update_id).await\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        self.persistence.cleanup_expired_cache().await\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        self.persistence.update_sync_status(update).await\n    }\n}\n","traces":[{"line":71,"address":[18798944],"length":1,"stats":{"Line":5}},{"line":75,"address":[18814585,18812736,18814263],"length":1,"stats":{"Line":1}},{"line":78,"address":[18880526],"length":1,"stats":{"Line":1}},{"line":79,"address":[18799100],"length":1,"stats":{"Line":1}},{"line":80,"address":[18915751],"length":1,"stats":{"Line":1}},{"line":82,"address":[19012290,19013771],"length":1,"stats":{"Line":0}},{"line":83,"address":[26500489],"length":1,"stats":{"Line":0}},{"line":89,"address":[18799415],"length":1,"stats":{"Line":1}},{"line":90,"address":[18912010,18911883],"length":1,"stats":{"Line":2}},{"line":91,"address":[18917602,18917663],"length":1,"stats":{"Line":2}},{"line":93,"address":[13053938],"length":1,"stats":{"Line":1}},{"line":94,"address":[18916126],"length":1,"stats":{"Line":1}},{"line":95,"address":[18916170,18916234],"length":1,"stats":{"Line":2}},{"line":98,"address":[18881550,18881225],"length":1,"stats":{"Line":1}},{"line":99,"address":[13055168,13054286,13055187],"length":1,"stats":{"Line":0}},{"line":101,"address":[18874904,18874992],"length":1,"stats":{"Line":2}},{"line":102,"address":[19013042,19013177],"length":1,"stats":{"Line":2}},{"line":103,"address":[18918463,18918401],"length":1,"stats":{"Line":2}},{"line":104,"address":[18912944,18912887],"length":1,"stats":{"Line":2}},{"line":105,"address":[19013344],"length":1,"stats":{"Line":1}},{"line":109,"address":[18807792],"length":1,"stats":{"Line":1}},{"line":110,"address":[18882551],"length":1,"stats":{"Line":1}},{"line":116,"address":[11906090,11906045],"length":1,"stats":{"Line":5}},{"line":120,"address":[18993434,18993347,18993765],"length":1,"stats":{"Line":2}},{"line":121,"address":[11874801],"length":1,"stats":{"Line":3}},{"line":124,"address":[11288076,11288111],"length":1,"stats":{"Line":4}},{"line":128,"address":[18913696,18913779],"length":1,"stats":{"Line":2}},{"line":129,"address":[11802414],"length":1,"stats":{"Line":3}},{"line":132,"address":[26696907,26696509,26697153,26696243,26696153,26696482,26696717,26696208,26696352],"length":1,"stats":{"Line":4}},{"line":133,"address":[18921403,18921805,18921732,18921983],"length":1,"stats":{"Line":3}},{"line":136,"address":[19128832,19129344,19129082,19128624,19128659,19128855,19128585,19128743],"length":1,"stats":{"Line":10}},{"line":137,"address":[19032682,19032523,19032338],"length":1,"stats":{"Line":4}},{"line":140,"address":[18917143,18916297,18916512,18917401,18916677,18916642,18916913,18916403,18916368],"length":1,"stats":{"Line":4}},{"line":141,"address":[18930299,18930935,18930725,18930652],"length":1,"stats":{"Line":3}},{"line":144,"address":[19030370,19030209,19030482,19030291,19030459,19030750,19031007,19030256],"length":1,"stats":{"Line":5}},{"line":148,"address":[18918078,18917693,18917911],"length":1,"stats":{"Line":2}},{"line":151,"address":[19031155,19032163,19031409,19031444,19031896,19031276,19031039,19031683,19031120],"length":1,"stats":{"Line":12}},{"line":152,"address":[11932977],"length":1,"stats":{"Line":7}},{"line":155,"address":[13173984,13174305,13174270,13173871,13174879,13174592,13174140,13174019,13175140],"length":1,"stats":{"Line":0}},{"line":159,"address":[11826657],"length":1,"stats":{"Line":0}},{"line":162,"address":[19039801,19039225,19039424,19040257,19039280,19039554,19039589,19039315,19039999],"length":1,"stats":{"Line":0}},{"line":166,"address":[11827502],"length":1,"stats":{"Line":0}},{"line":169,"address":[18996848,18996649,18996704,18996978,18997013,18996739,18997225,18997423,18997681],"length":1,"stats":{"Line":0}},{"line":173,"address":[11946094],"length":1,"stats":{"Line":0}},{"line":176,"address":[18998262,18997769,18997922,18998034,18997843,18997808,18998011,18998520],"length":1,"stats":{"Line":5}},{"line":177,"address":[19591188],"length":1,"stats":{"Line":2}},{"line":180,"address":[19006790,19006225,19005600,19005635,19005756,19005487,19005886,19005921,19006530],"length":1,"stats":{"Line":4}},{"line":181,"address":[11822673],"length":1,"stats":{"Line":3}}],"covered":39,"coverable":48},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","bootstrap.rs"],"content":"use super::core::{P2PService, P2PServiceTrait};\nuse crate::domain::p2p::events::P2PEvent;\nuse crate::infrastructure::p2p::{\n    DiscoveryOptions, GossipService, NetworkService, iroh_gossip_service::IrohGossipService,\n    iroh_network_service::IrohNetworkService,\n};\nuse crate::shared::config::NetworkConfig as AppNetworkConfig;\nuse crate::shared::error::AppError;\nuse iroh::SecretKey;\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\n\npub struct P2PStack {\n    pub network_service: Arc<dyn NetworkService>,\n    pub gossip_service: Arc<dyn GossipService>,\n    pub p2p_service: Arc<dyn P2PServiceTrait>,\n}\n\npub struct P2PServiceBuilder {\n    secret_key: SecretKey,\n    network_config: AppNetworkConfig,\n    discovery_options: DiscoveryOptions,\n    event_sender: Option<broadcast::Sender<P2PEvent>>,\n}\n\nimpl P2PServiceBuilder {\n    pub(crate) fn new(\n        secret_key: SecretKey,\n        network_config: AppNetworkConfig,\n        discovery_options: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender: None,\n        }\n    }\n\n    pub fn with_discovery_options(mut self, options: DiscoveryOptions) -> Self {\n        self.discovery_options = options;\n        self\n    }\n\n    pub fn enable_mainline(mut self, enabled: bool) -> Self {\n        self.discovery_options = self.discovery_options.with_mainline(enabled);\n        self\n    }\n\n    pub fn with_event_sender(mut self, sender: broadcast::Sender<P2PEvent>) -> Self {\n        self.event_sender = Some(sender);\n        self\n    }\n\n    pub fn discovery_options(&self) -> DiscoveryOptions {\n        self.discovery_options\n    }\n\n    pub async fn build(self) -> Result<P2PStack, AppError> {\n        let P2PServiceBuilder {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender,\n        } = self;\n\n        let (network_event_sender, gossip_event_sender) = match event_sender {\n            Some(sender) => (Some(sender.clone()), Some(sender)),\n            None => (None, None),\n        };\n\n        let iroh_network = Arc::new(\n            IrohNetworkService::new(\n                secret_key,\n                network_config,\n                discovery_options,\n                network_event_sender,\n            )\n            .await?,\n        );\n        let endpoint_arc = iroh_network.endpoint().clone();\n        let static_discovery = iroh_network.static_discovery();\n        let mut gossip_inner = IrohGossipService::new(endpoint_arc, static_discovery)?;\n        if let Some(tx) = gossip_event_sender {\n            gossip_inner.set_event_sender(tx);\n        }\n        let iroh_gossip = Arc::new(gossip_inner);\n\n        let network_service_dyn: Arc<dyn NetworkService> = iroh_network.clone();\n        let gossip_service_dyn: Arc<dyn GossipService> = iroh_gossip.clone();\n        let p2p_service: Arc<dyn P2PServiceTrait> = Arc::new(P2PService::with_discovery(\n            Arc::clone(&network_service_dyn),\n            Arc::clone(&gossip_service_dyn),\n            discovery_options,\n        ));\n\n        Ok(P2PStack {\n            network_service: network_service_dyn,\n            gossip_service: gossip_service_dyn,\n            p2p_service,\n        })\n    }\n}\n","traces":[{"line":27,"address":[13550144],"length":1,"stats":{"Line":0}},{"line":40,"address":[13550304],"length":1,"stats":{"Line":0}},{"line":41,"address":[13594047],"length":1,"stats":{"Line":0}},{"line":42,"address":[13482565],"length":1,"stats":{"Line":0}},{"line":45,"address":[13489795,13489568],"length":1,"stats":{"Line":0}},{"line":46,"address":[21250814,21250936],"length":1,"stats":{"Line":0}},{"line":47,"address":[13476015],"length":1,"stats":{"Line":0}},{"line":50,"address":[13489961,13489824],"length":1,"stats":{"Line":0}},{"line":51,"address":[13594457,13594382],"length":1,"stats":{"Line":0}},{"line":52,"address":[13592821],"length":1,"stats":{"Line":0}},{"line":55,"address":[13689296],"length":1,"stats":{"Line":0}},{"line":56,"address":[13592869],"length":1,"stats":{"Line":0}},{"line":59,"address":[20482676,20482711,20481441,20481424,20481938,20481488,20485294,20481580],"length":1,"stats":{"Line":0}},{"line":61,"address":[13558123],"length":1,"stats":{"Line":0}},{"line":62,"address":[20481800],"length":1,"stats":{"Line":0}},{"line":63,"address":[21251665],"length":1,"stats":{"Line":0}},{"line":64,"address":[20481877],"length":1,"stats":{"Line":0}},{"line":67,"address":[13593388,13593580],"length":1,"stats":{"Line":0}},{"line":68,"address":[21251863,21252249],"length":1,"stats":{"Line":0}},{"line":69,"address":[13476829],"length":1,"stats":{"Line":0}},{"line":73,"address":[13484264,13484655,13484879,13486868,13484487,13483976],"length":1,"stats":{"Line":0}},{"line":74,"address":[13551601],"length":1,"stats":{"Line":0}},{"line":75,"address":[13551662],"length":1,"stats":{"Line":0}},{"line":76,"address":[13593773],"length":1,"stats":{"Line":0}},{"line":77,"address":[13477169],"length":1,"stats":{"Line":0}},{"line":79,"address":[11547489],"length":1,"stats":{"Line":0}},{"line":81,"address":[13478145,13478226],"length":1,"stats":{"Line":0}},{"line":82,"address":[20483444,20483386],"length":1,"stats":{"Line":0}},{"line":83,"address":[13591154,13591311,13591087],"length":1,"stats":{"Line":0}},{"line":84,"address":[20483766,20483644],"length":1,"stats":{"Line":0}},{"line":85,"address":[13691942,13691802],"length":1,"stats":{"Line":0}},{"line":87,"address":[13595517,13595389],"length":1,"stats":{"Line":0}},{"line":89,"address":[13478885,13478955],"length":1,"stats":{"Line":0}},{"line":90,"address":[13553570,13553640],"length":1,"stats":{"Line":0}},{"line":91,"address":[21254261,21254365,21254438],"length":1,"stats":{"Line":0}},{"line":92,"address":[21254121,21254047],"length":1,"stats":{"Line":0}},{"line":93,"address":[13560689],"length":1,"stats":{"Line":0}},{"line":94,"address":[13560769],"length":1,"stats":{"Line":0}},{"line":97,"address":[21254493],"length":1,"stats":{"Line":0}},{"line":98,"address":[13592189],"length":1,"stats":{"Line":0}},{"line":99,"address":[13493261],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","core.rs"],"content":"use super::bootstrap::P2PServiceBuilder;\nuse super::metrics::GossipMetricsSummary;\nuse super::status::{ConnectionStatus, P2PStatus, PeerStatus, TopicInfo};\nuse crate::infrastructure::p2p::{DiscoveryOptions, GossipService, NetworkService, metrics};\nuse crate::shared::config::{BootstrapSource, NetworkConfig as AppNetworkConfig};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse iroh::SecretKey;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct P2PService {\n    network_service: Arc<dyn NetworkService>,\n    gossip_service: Arc<dyn GossipService>,\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\n}\n\n#[async_trait]\npub trait P2PServiceTrait: Send + Sync {\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError>;\n    async fn get_status(&self) -> Result<P2PStatus, AppError>;\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError>;\n    fn generate_topic_id(&self, topic_name: &str) -> String;\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError>;\n}\n\nimpl P2PService {\n    pub fn new(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n    ) -> Self {\n        Self::with_discovery(network_service, gossip_service, DiscoveryOptions::default())\n    }\n\n    pub fn with_discovery(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n        discovery: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            network_service,\n            gossip_service,\n            discovery_options: Arc::new(RwLock::new(discovery)),\n        }\n    }\n\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\n        *self.discovery_options.read().await\n    }\n\n    pub async fn set_mainline_enabled(&self, enabled: bool) {\n        let mut options = self.discovery_options.write().await;\n        *options = options.with_mainline(enabled);\n    }\n\n    async fn mainline_enabled(&self) -> bool {\n        self.discovery_options.read().await.enable_mainline()\n    }\n\n    async fn ensure_topic_joined(&self, topic_id: &str) -> Result<(), AppError> {\n        let joined_topics = self\n            .gossip_service\n            .get_joined_topics()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if !joined_topics.iter().any(|topic| topic == topic_id) {\n            self.gossip_service\n                .join_topic(topic_id, Vec::new())\n                .await\n                .map_err(|e| AppError::P2PError(e.to_string()))?;\n        }\n\n        if self.mainline_enabled().await {\n            self.network_service.join_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    pub fn builder(secret_key: SecretKey, network_config: AppNetworkConfig) -> P2PServiceBuilder {\n        let discovery_options = DiscoveryOptions::from(&network_config);\n        P2PServiceBuilder::new(secret_key, network_config, discovery_options)\n    }\n}\n\n#[async_trait]\nimpl P2PServiceTrait for P2PService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.gossip_service\n            .join_topic(topic_id, initial_peers)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service.join_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        self.gossip_service\n            .leave_topic(topic_id)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service.leave_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError> {\n        self.ensure_topic_joined(topic_id).await?;\n\n        self.gossip_service\n            .broadcast_message(topic_id, content.as_bytes())\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service\n                .broadcast_dht(topic_id, content.as_bytes().to_vec())\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn get_status(&self) -> Result<P2PStatus, AppError> {\n        let endpoint_id = self\n            .network_service\n            .get_node_id()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let joined_topics = self\n            .gossip_service\n            .get_joined_topics()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let mut active_topics = Vec::new();\n        let mut total_peer_count = 0;\n\n        for topic_id in joined_topics {\n            let stats = self\n                .gossip_service\n                .get_topic_stats(&topic_id)\n                .await\n                .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n            let (peer_count, message_count, last_activity) = if let Some(stats) = stats {\n                (stats.peer_count, stats.message_count, stats.last_activity)\n            } else {\n                let peers = self\n                    .gossip_service\n                    .get_topic_peers(&topic_id)\n                    .await\n                    .map_err(|e| AppError::P2PError(e.to_string()))?;\n                (peers.len(), 0, chrono::Utc::now().timestamp())\n            };\n\n            total_peer_count += peer_count;\n\n            active_topics.push(TopicInfo {\n                id: topic_id,\n                peer_count,\n                message_count,\n                last_activity,\n            });\n        }\n\n        let peers = self\n            .network_service\n            .get_peers()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let network_connected = self.network_service.is_connected().await && !peers.is_empty();\n\n        let peer_status: Vec<PeerStatus> = peers\n            .into_iter()\n            .map(|peer| PeerStatus {\n                node_id: peer.id,\n                address: peer.address,\n                connected_at: peer.connected_at,\n                last_seen: peer.last_seen,\n            })\n            .collect();\n\n        let metrics_summary = GossipMetricsSummary::from_snapshot(&metrics::snapshot());\n\n        Ok(P2PStatus {\n            connected: network_connected,\n            connection_status: if network_connected {\n                ConnectionStatus::Connected\n            } else {\n                ConnectionStatus::Disconnected\n            },\n            endpoint_id,\n            active_topics,\n            peer_count: total_peer_count,\n            peers: peer_status,\n            metrics_summary,\n        })\n    }\n\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError> {\n        self.network_service\n            .get_addresses()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    fn generate_topic_id(&self, topic_name: &str) -> String {\n        crate::domain::p2p::generate_topic_id(topic_name)\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        self.network_service\n            .apply_bootstrap_nodes(nodes, source)\n            .await\n    }\n}\n","traces":[{"line":35,"address":[13693722,13693440],"length":1,"stats":{"Line":2}},{"line":39,"address":[13494429,13494161,13494385],"length":1,"stats":{"Line":2}},{"line":42,"address":[14316263,14315936,14316242],"length":1,"stats":{"Line":2}},{"line":50,"address":[13593629,13593493],"length":1,"stats":{"Line":4}},{"line":54,"address":[13593768,13593887,13593776,13593801,13593924,13594489,13594064,13593760],"length":1,"stats":{"Line":0}},{"line":55,"address":[13481269,13481392,13481163,13481210],"length":1,"stats":{"Line":0}},{"line":58,"address":[13598467,13598791,13598622,13598659,13599339,13598448,13598496,13598521],"length":1,"stats":{"Line":0}},{"line":59,"address":[13495828,13495722,13495769,13495943],"length":1,"stats":{"Line":0}},{"line":60,"address":[13595091,13595158],"length":1,"stats":{"Line":0}},{"line":63,"address":[13695792,13695800,13695956,13696096,13695808,13696479,13695833,13695919],"length":1,"stats":{"Line":4}},{"line":64,"address":[13557648,13557419,13557466,13557525],"length":1,"stats":{"Line":2}},{"line":67,"address":[13490256,13491788,13490748,13490556,13490450,13490208,13490226,13490303],"length":1,"stats":{"Line":4}},{"line":68,"address":[14319295,14319982,14319504,14319173,14318919,14318708,14318998],"length":1,"stats":{"Line":5}},{"line":71,"address":[13497756,13497635,13497456,13497912,13497694],"length":1,"stats":{"Line":3}},{"line":72,"address":[14321232,14319456,14321255],"length":1,"stats":{"Line":0}},{"line":74,"address":[13565877,13567950,13566827,13567936,13566068],"length":1,"stats":{"Line":5}},{"line":75,"address":[21260094,21260336,21260454,21259814,21260204,21259634,21259881],"length":1,"stats":{"Line":5}},{"line":76,"address":[13498521],"length":1,"stats":{"Line":1}},{"line":77,"address":[11562101],"length":1,"stats":{"Line":3}},{"line":78,"address":[14321424,14320326,14321447],"length":1,"stats":{"Line":0}},{"line":81,"address":[11622953],"length":1,"stats":{"Line":4}},{"line":82,"address":[13565279,13567424,13567695,13567264],"length":1,"stats":{"Line":2}},{"line":85,"address":[13567230],"length":1,"stats":{"Line":2}},{"line":88,"address":[13599312,13599708],"length":1,"stats":{"Line":0}},{"line":89,"address":[13605028,13604931],"length":1,"stats":{"Line":0}},{"line":90,"address":[13603425],"length":1,"stats":{"Line":0}},{"line":96,"address":[13660846,13660997,13660909,13661125,13660777,13660816,13660974],"length":1,"stats":{"Line":5}},{"line":97,"address":[13600265],"length":1,"stats":{"Line":1}},{"line":100,"address":[14457621,14458872,14458923,14457079,14458111,14456896,14458363,14456831,14457233,14457408,14456943],"length":1,"stats":{"Line":7}},{"line":101,"address":[13800374,13800889,13801007,13800621,13800731,13800224,13800441],"length":1,"stats":{"Line":10}},{"line":102,"address":[13601010],"length":1,"stats":{"Line":1}},{"line":103,"address":[13594228,13594169,13594381,13594122,13593669],"length":1,"stats":{"Line":6}},{"line":104,"address":[13662361,13663538,13663520],"length":1,"stats":{"Line":3}},{"line":106,"address":[13706251,13705194,13706026,13706934,13706139],"length":1,"stats":{"Line":3}},{"line":107,"address":[11797412],"length":1,"stats":{"Line":1}},{"line":110,"address":[13594951],"length":1,"stats":{"Line":1}},{"line":113,"address":[21364175,21364079,21365495,21364720,21365248,21364128,21364275,21364441],"length":1,"stats":{"Line":7}},{"line":114,"address":[13708279,13708169,13708437,13708555,13707861,13707930,13707989],"length":1,"stats":{"Line":12}},{"line":115,"address":[13664218],"length":1,"stats":{"Line":2}},{"line":116,"address":[13664368,13663921,13664262,13664521,13664309],"length":1,"stats":{"Line":6}},{"line":117,"address":[21366032,21365077,21366050],"length":1,"stats":{"Line":3}},{"line":119,"address":[11786149],"length":1,"stats":{"Line":3}},{"line":120,"address":[14459499,14460996,14460590],"length":1,"stats":{"Line":1}},{"line":123,"address":[13597269],"length":1,"stats":{"Line":1}},{"line":126,"address":[13591359,13591247,13591312,13591876,13591459,13592583,13593329,13591646],"length":1,"stats":{"Line":7}},{"line":127,"address":[13666813,13667170,13666081,13666346,13666500],"length":1,"stats":{"Line":1}},{"line":129,"address":[14462804,14463041,14462183,14462446,14462682,14462934,14462525],"length":1,"stats":{"Line":10}},{"line":130,"address":[21367314],"length":1,"stats":{"Line":2}},{"line":131,"address":[11914533],"length":1,"stats":{"Line":6}},{"line":132,"address":[13606680,13607728,13607746],"length":1,"stats":{"Line":0}},{"line":134,"address":[13804603,13805961,13806074,13806936,13806163],"length":1,"stats":{"Line":6}},{"line":135,"address":[21368463,21368310,21368678,21368893,21368788,21368530],"length":1,"stats":{"Line":10}},{"line":136,"address":[13593387],"length":1,"stats":{"Line":2}},{"line":137,"address":[13710509,13710210,13708192,13710390,13710237,13710163],"length":1,"stats":{"Line":6}},{"line":140,"address":[13674815],"length":1,"stats":{"Line":2}},{"line":143,"address":[13601179,13600911,13607760,13601408,13601718,13601007,13602482,13600960],"length":1,"stats":{"Line":7}},{"line":144,"address":[13669472,13669334,13669795,13670032,13669669,13670285],"length":1,"stats":{"Line":4}},{"line":147,"address":[13595125,13594425,13594837,13594902,13594966],"length":1,"stats":{"Line":3}},{"line":148,"address":[13675650,13669984,13675632],"length":1,"stats":{"Line":0}},{"line":150,"address":[14465418,14465804,14466307,14465497,14465216,14465666,14466008],"length":1,"stats":{"Line":5}},{"line":153,"address":[13808733,13808779,13808938,13807518,13808668],"length":1,"stats":{"Line":3}},{"line":154,"address":[13607986,13602912,13607968],"length":1,"stats":{"Line":0}},{"line":156,"address":[13714390],"length":1,"stats":{"Line":1}},{"line":157,"address":[13610021],"length":1,"stats":{"Line":1}},{"line":159,"address":[21372693,21372635,21371375,21371253,21372586],"length":1,"stats":{"Line":5}},{"line":160,"address":[13812109,13810831,13811434,13811213,13811560,13811296,13811767],"length":1,"stats":{"Line":5}},{"line":162,"address":[13672666],"length":1,"stats":{"Line":1}},{"line":163,"address":[11895556],"length":1,"stats":{"Line":4}},{"line":164,"address":[13717968,13717986,13715287],"length":1,"stats":{"Line":0}},{"line":166,"address":[21373607,21373708,21372265,21373804],"length":1,"stats":{"Line":4}},{"line":167,"address":[21373756],"length":1,"stats":{"Line":1}},{"line":169,"address":[13597099,13599010,13596704,13598833,13598951,13599062,13596878],"length":1,"stats":{"Line":5}},{"line":171,"address":[13598902],"length":1,"stats":{"Line":1}},{"line":172,"address":[14468722,14464392,14468771,14466564,14466383],"length":1,"stats":{"Line":4}},{"line":173,"address":[13615232,13610811,13615250],"length":1,"stats":{"Line":0}},{"line":174,"address":[14466821,14466973],"length":1,"stats":{"Line":2}},{"line":177,"address":[13679095,13678881],"length":1,"stats":{"Line":1}},{"line":179,"address":[21372412,21372469],"length":1,"stats":{"Line":2}},{"line":180,"address":[13672043],"length":1,"stats":{"Line":1}},{"line":187,"address":[13714445,13714542,13716314,13714625,13715940,13716066],"length":1,"stats":{"Line":5}},{"line":190,"address":[11901190],"length":1,"stats":{"Line":3}},{"line":191,"address":[13714338,13712330,13714320],"length":1,"stats":{"Line":0}},{"line":193,"address":[13674491,13674838,13669122,13674182,13674361],"length":1,"stats":{"Line":3}},{"line":195,"address":[13613922,13614019],"length":1,"stats":{"Line":2}},{"line":197,"address":[14471480,14471408],"length":1,"stats":{"Line":2}},{"line":198,"address":[13676363],"length":1,"stats":{"Line":1}},{"line":199,"address":[21376773],"length":1,"stats":{"Line":1}},{"line":200,"address":[14471472],"length":1,"stats":{"Line":1}},{"line":201,"address":[13676420],"length":1,"stats":{"Line":1}},{"line":205,"address":[13600313,13600376],"length":1,"stats":{"Line":3}},{"line":207,"address":[13607438],"length":1,"stats":{"Line":2}},{"line":208,"address":[13718751],"length":1,"stats":{"Line":2}},{"line":209,"address":[13718762,13718780],"length":1,"stats":{"Line":3}},{"line":210,"address":[14470147],"length":1,"stats":{"Line":1}},{"line":212,"address":[13713188],"length":1,"stats":{"Line":1}},{"line":214,"address":[13682026],"length":1,"stats":{"Line":1}},{"line":215,"address":[13713254],"length":1,"stats":{"Line":2}},{"line":216,"address":[13614354],"length":1,"stats":{"Line":2}},{"line":217,"address":[13607390],"length":1,"stats":{"Line":2}},{"line":222,"address":[13815227,13815250,13814985,13815760,13815059,13815476,13815024,13815138],"length":1,"stats":{"Line":5}},{"line":223,"address":[13676870,13676960,13677227,13677129],"length":1,"stats":{"Line":4}},{"line":225,"address":[21377069,21377313,21377357,21377561,21377412],"length":1,"stats":{"Line":3}},{"line":226,"address":[13715426,13715408],"length":1,"stats":{"Line":0}},{"line":229,"address":[13721136],"length":1,"stats":{"Line":1}},{"line":230,"address":[13677493],"length":1,"stats":{"Line":1}},{"line":233,"address":[13609727,13610332,13610066,13610101,13610795,13609936,13610538,13609827,13609792],"length":1,"stats":{"Line":4}},{"line":238,"address":[13816717,13816959,13816599,13816790],"length":1,"stats":{"Line":4}},{"line":239,"address":[13678196],"length":1,"stats":{"Line":1}},{"line":240,"address":[11920110],"length":1,"stats":{"Line":3}}],"covered":92,"coverable":109},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","metrics.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::infrastructure::p2p::metrics::GossipMetricsSnapshot;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummary {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n\nimpl GossipMetricsSummary {\n    pub fn from_snapshot(snapshot: &GossipMetricsSnapshot) -> Self {\n        Self {\n            joins: snapshot.joins,\n            leaves: snapshot.leaves,\n            broadcasts_sent: snapshot.broadcasts_sent,\n            messages_received: snapshot.messages_received,\n        }\n    }\n}\n","traces":[{"line":14,"address":[13055392],"length":1,"stats":{"Line":2}},{"line":16,"address":[18814859],"length":1,"stats":{"Line":2}},{"line":17,"address":[18919394],"length":1,"stats":{"Line":2}},{"line":18,"address":[18917753],"length":1,"stats":{"Line":2}},{"line":19,"address":[19014192],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","mod.rs"],"content":"mod bootstrap;\nmod core;\nmod metrics;\nmod status;\n\npub use bootstrap::{P2PServiceBuilder, P2PStack};\npub use core::{P2PService, P2PServiceTrait};\npub use metrics::GossipMetricsSummary;\npub use status::{ConnectionStatus, P2PStatus, PeerStatus, TopicInfo};\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","status.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse super::metrics::GossipMetricsSummary;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ConnectionStatus {\n    Connected,\n    Connecting,\n    #[default]\n    Disconnected,\n    Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerStatus {\n    pub node_id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatus {\n    pub connected: bool,\n    pub connection_status: ConnectionStatus,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicInfo>,\n    pub peer_count: usize,\n    pub peers: Vec<PeerStatus>,\n    pub metrics_summary: GossipMetricsSummary,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicInfo {\n    pub id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","tests.rs"],"content":"use super::core::{P2PService, P2PServiceTrait};\nuse crate::application::services::p2p_service::status::ConnectionStatus;\nuse crate::domain::constants::TOPIC_NAMESPACE;\nuse crate::domain::p2p::TopicStats;\nuse crate::infrastructure::p2p::network_service::Peer;\nuse crate::infrastructure::p2p::{GossipService, NetworkService, metrics};\nuse crate::shared::{AppError, config::BootstrapSource};\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse mockall::{mock, predicate::*};\nuse std::sync::{Arc, Mutex};\n\npub struct MockNetworkServ {\n    node_id: Mutex<Option<String>>,\n    addresses: Mutex<Option<Vec<String>>>,\n    join_dht: Mutex<Vec<String>>,\n    leave_dht: Mutex<Vec<String>>,\n    broadcast_dht: Mutex<Vec<(String, Vec<u8>)>>,\n    connected: Mutex<bool>,\n    peers: Mutex<Vec<Peer>>,\n    applied_bootstrap_nodes: Mutex<Vec<String>>,\n    applied_bootstrap_source: Mutex<Option<BootstrapSource>>,\n}\n\nimpl MockNetworkServ {\n    pub fn new() -> Self {\n        Self {\n            node_id: Mutex::new(None),\n            addresses: Mutex::new(None),\n            join_dht: Mutex::new(Vec::new()),\n            leave_dht: Mutex::new(Vec::new()),\n            broadcast_dht: Mutex::new(Vec::new()),\n            connected: Mutex::new(true),\n            peers: Mutex::new(Vec::new()),\n            applied_bootstrap_nodes: Mutex::new(Vec::new()),\n            applied_bootstrap_source: Mutex::new(None),\n        }\n    }\n\n    pub fn expect_get_node_id(&mut self) -> &mut Self {\n        self\n    }\n\n    pub fn returning<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce() -> Result<String, AppError> + 'static,\n    {\n        if let Ok(value) = f() {\n            *self.node_id.lock().unwrap() = Some(value);\n        }\n        self\n    }\n\n    pub fn expect_get_addresses(&mut self) -> &mut Self {\n        self\n    }\n\n    pub fn returning_addresses<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce() -> Result<Vec<String>, AppError> + 'static,\n    {\n        if let Ok(value) = f() {\n            *self.addresses.lock().unwrap() = Some(value);\n        }\n        self\n    }\n\n    pub fn join_dht_calls(&self) -> Vec<String> {\n        self.join_dht.lock().unwrap().clone()\n    }\n\n    pub fn leave_dht_calls(&self) -> Vec<String> {\n        self.leave_dht.lock().unwrap().clone()\n    }\n\n    pub fn broadcast_dht_calls(&self) -> Vec<(String, Vec<u8>)> {\n        self.broadcast_dht.lock().unwrap().clone()\n    }\n\n    pub fn set_connected(&self, connected: bool) {\n        *self.connected.lock().unwrap() = connected;\n    }\n\n    pub fn set_peers(&self, peers: Vec<Peer>) {\n        *self.peers.lock().unwrap() = peers;\n    }\n\n    pub fn applied_bootstrap_nodes(&self) -> Vec<String> {\n        self.applied_bootstrap_nodes.lock().unwrap().clone()\n    }\n\n    pub fn applied_bootstrap_source(&self) -> Option<BootstrapSource> {\n        *self.applied_bootstrap_source.lock().unwrap()\n    }\n}\n\n#[async_trait]\nimpl NetworkService for MockNetworkServ {\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n\n    async fn connect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_peers(\n        &self,\n    ) -> Result<Vec<crate::infrastructure::p2p::network_service::Peer>, AppError> {\n        Ok(self.peers.lock().unwrap().clone())\n    }\n\n    async fn add_peer(&self, _address: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn remove_peer(&self, _peer_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_stats(\n        &self,\n    ) -> Result<crate::infrastructure::p2p::network_service::NetworkStats, AppError> {\n        Ok(crate::infrastructure::p2p::network_service::NetworkStats {\n            connected_peers: 0,\n            total_messages_sent: 0,\n            total_messages_received: 0,\n            bandwidth_up: 0,\n            bandwidth_down: 0,\n        })\n    }\n\n    async fn is_connected(&self) -> bool {\n        *self.connected.lock().unwrap()\n    }\n\n    async fn get_node_id(&self) -> Result<String, AppError> {\n        let node_id = self.node_id.lock().unwrap();\n        Ok(node_id\n            .clone()\n            .unwrap_or_else(|| \"default_node_id\".to_string()))\n    }\n\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\n        let addresses = self.addresses.lock().unwrap();\n        Ok(addresses.clone().unwrap_or_else(std::vec::Vec::new))\n    }\n\n    async fn join_dht_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.join_dht.lock().unwrap().push(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_dht_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.leave_dht.lock().unwrap().push(topic.to_string());\n        Ok(())\n    }\n\n    async fn broadcast_dht(&self, topic: &str, message: Vec<u8>) -> Result<(), AppError> {\n        self.broadcast_dht\n            .lock()\n            .unwrap()\n            .push((topic.to_string(), message));\n        Ok(())\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        *self.applied_bootstrap_nodes.lock().unwrap() = nodes;\n        *self.applied_bootstrap_source.lock().unwrap() = Some(source);\n        Ok(())\n    }\n}\n\nmock! {\n    pub GossipServ {}\n\n    #[async_trait]\n    impl GossipService for GossipServ {\n        fn local_peer_hint(&self) -> Option<String>;\n        async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n        async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\n        async fn broadcast(&self, topic: &str, event: &crate::domain::entities::Event) -> Result<(), AppError>;\n        async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<crate::domain::entities::Event>, AppError>;\n        async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n        async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n        async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n        async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n    }\n}\n\n#[tokio::test]\nasync fn test_initialize() {\n    let network = Arc::new(MockNetworkServ::new());\n    let gossip = Arc::new(MockGossipServ::new());\n\n    let service = P2PService::new(network, gossip);\n\n    let result = service.initialize().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_apply_bootstrap_nodes_forwards_to_network() {\n    let network = Arc::new(MockNetworkServ::new());\n    let gossip = Arc::new(MockGossipServ::new());\n    let service = P2PService::new(\n        Arc::clone(&network) as Arc<dyn NetworkService>,\n        gossip as Arc<dyn GossipService>,\n    );\n\n    let nodes = vec![\n        \"node1@127.0.0.1:44001\".to_string(),\n        \"node2@127.0.0.1:44002\".to_string(),\n    ];\n\n    service\n        .apply_bootstrap_nodes(nodes.clone(), BootstrapSource::User)\n        .await\n        .expect(\"apply bootstrap nodes\");\n\n    assert_eq!(network.applied_bootstrap_nodes(), nodes);\n    assert_eq!(\n        network.applied_bootstrap_source(),\n        Some(BootstrapSource::User)\n    );\n}\n\n#[tokio::test]\nasync fn test_join_topic_success() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_join_topic()\n        .with(\n            eq(\"test_topic\"),\n            eq(vec![\"peer1\".to_string(), \"peer2\".to_string()]),\n        )\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service\n        .join_topic(\"test_topic\", vec![\"peer1\".to_string(), \"peer2\".to_string()])\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(network.join_dht_calls(), vec![\"test_topic\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_join_topic_failure() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_join_topic()\n        .with(eq(\"fail_topic\"), eq(Vec::<String>::new()))\n        .times(1)\n        .returning(|_, _| Err(AppError::P2PError(\"join failed\".into())));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.join_topic(\"fail_topic\", Vec::new()).await;\n    assert!(result.is_err());\n    assert!(network.join_dht_calls().is_empty());\n}\n\n#[tokio::test]\nasync fn test_leave_topic_success() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_leave_topic()\n        .with(eq(\"test_topic\"))\n        .times(1)\n        .returning(|_| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.leave_topic(\"test_topic\").await;\n    assert!(result.is_ok());\n    assert_eq!(network.leave_dht_calls(), vec![\"test_topic\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_leave_topic_failure() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_leave_topic()\n        .with(eq(\"fail_topic\"))\n        .times(1)\n        .returning(|_| Err(AppError::P2PError(\"leave failed\".into())));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.leave_topic(\"fail_topic\").await;\n    assert!(result.is_err());\n    assert!(network.leave_dht_calls().is_empty());\n}\n\n#[tokio::test]\nasync fn test_broadcast_message() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"test_topic\".to_string()]));\n\n    let test_content = \"Test message\";\n    mock_gossip\n        .expect_broadcast_message()\n        .with(eq(\"test_topic\"), eq(test_content.as_bytes()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.broadcast_message(\"test_topic\", test_content).await;\n    assert!(result.is_ok());\n    assert_eq!(network.join_dht_calls(), vec![\"test_topic\".to_string()]);\n    let broadcast_calls = network.broadcast_dht_calls();\n    assert_eq!(broadcast_calls.len(), 1);\n    assert_eq!(broadcast_calls[0].0, \"test_topic\".to_string());\n    assert_eq!(String::from_utf8_lossy(&broadcast_calls[0].1), test_content);\n}\n\n#[tokio::test]\nasync fn test_broadcast_message_auto_join_when_not_joined() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![]));\n\n    mock_gossip\n        .expect_join_topic()\n        .with(eq(\"auto_topic\"), eq(Vec::<String>::new()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    mock_gossip\n        .expect_broadcast_message()\n        .with(eq(\"auto_topic\"), eq(\"auto payload\".as_bytes()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n    let result = service\n        .broadcast_message(\"auto_topic\", \"auto payload\")\n        .await;\n    assert!(result.is_ok());\n\n    assert_eq!(network.join_dht_calls(), vec![\"auto_topic\".to_string()]);\n    let broadcast_calls = network.broadcast_dht_calls();\n    assert_eq!(broadcast_calls.len(), 1);\n    assert_eq!(broadcast_calls[0].0, \"auto_topic\".to_string());\n    assert_eq!(\n        String::from_utf8_lossy(&broadcast_calls[0].1),\n        \"auto payload\"\n    );\n}\n\n#[tokio::test]\nasync fn test_get_status() {\n    metrics::reset_all();\n    let mut mock_network = MockNetworkServ::new();\n    mock_network\n        .expect_get_node_id()\n        .returning(|| Ok(\"node123\".to_string()));\n    let network = Arc::new(mock_network);\n    network.set_connected(false);\n    network.set_peers(Vec::new());\n    assert!(!network.is_connected().await);\n\n    network.set_connected(true);\n    let now = Utc::now().timestamp();\n    network.set_peers(vec![\n        Peer {\n            id: \"peer-1\".to_string(),\n            address: \"/ip4/127.0.0.1/tcp/4001\".to_string(),\n            connected_at: now,\n            last_seen: now,\n        },\n        Peer {\n            id: \"peer-2\".to_string(),\n            address: \"/ip4/127.0.0.1/tcp/4002\".to_string(),\n            connected_at: now,\n            last_seen: now,\n        },\n    ]);\n\n    let mut mock_gossip = MockGossipServ::new();\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"topic1\".to_string(), \"topic2\".to_string()]));\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| {\n            Ok(Some(TopicStats {\n                peer_count: 5,\n                message_count: 12,\n                last_activity: 1_700_000_000,\n            }))\n        });\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic2\"))\n        .times(1)\n        .returning(|_| {\n            Ok(Some(TopicStats {\n                peer_count: 3,\n                message_count: 4,\n                last_activity: 1_700_000_100,\n            }))\n        });\n\n    let service = P2PService::new(network, Arc::new(mock_gossip));\n\n    let result = service.get_status().await;\n    assert!(result.is_ok());\n\n    let status = result.unwrap();\n    assert_eq!(status.endpoint_id, \"node123\");\n    assert!(status.connected);\n    assert_eq!(status.connection_status, ConnectionStatus::Connected);\n    assert_eq!(status.active_topics.len(), 2);\n    assert_eq!(status.peer_count, 8);\n    assert_eq!(status.metrics_summary.joins, 0);\n    assert_eq!(status.metrics_summary.leaves, 0);\n    assert_eq!(status.metrics_summary.broadcasts_sent, 0);\n    assert_eq!(status.metrics_summary.messages_received, 0);\n    assert_eq!(status.active_topics[0].message_count, 12);\n    assert_eq!(status.active_topics[0].last_activity, 1_700_000_000);\n    assert_eq!(status.active_topics[1].message_count, 4);\n    assert_eq!(status.active_topics[1].last_activity, 1_700_000_100);\n    assert_eq!(status.peers.len(), 2);\n    assert_eq!(status.peers[0].node_id, \"peer-1\");\n}\n\n#[tokio::test]\nasync fn test_get_status_fallback_to_peers_when_stats_missing() {\n    metrics::reset_all();\n    let mut mock_network = MockNetworkServ::new();\n    mock_network\n        .expect_get_node_id()\n        .returning(|| Ok(\"node123\".to_string()));\n    let network = Arc::new(mock_network);\n\n    let mut mock_gossip = MockGossipServ::new();\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"topic1\".to_string()]));\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| Ok(None));\n\n    mock_gossip\n        .expect_get_topic_peers()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| Ok(vec![\"peer1\".to_string(), \"peer2\".to_string()]));\n\n    let service = P2PService::new(network, Arc::new(mock_gossip));\n\n    let before = Utc::now().timestamp();\n    let status = service.get_status().await.unwrap();\n    let after = Utc::now().timestamp();\n\n    assert_eq!(status.active_topics.len(), 1);\n    let topic = &status.active_topics[0];\n    assert_eq!(topic.peer_count, 2);\n    assert_eq!(topic.message_count, 0);\n    assert!(topic.last_activity >= before);\n    assert!(topic.last_activity <= after);\n    assert_eq!(status.connection_status, ConnectionStatus::Disconnected);\n}\n\n#[tokio::test]\nasync fn test_get_node_addresses() {\n    let mut mock_network = MockNetworkServ::new();\n    mock_network.expect_get_addresses().returning_addresses(|| {\n        Ok(vec![\n            \"/ip4/127.0.0.1/tcp/4001\".to_string(),\n            \"/ip4/192.168.1.10/tcp/4001\".to_string(),\n        ])\n    });\n\n    let mock_gossip = MockGossipServ::new();\n\n    let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n    let result = service.get_node_addresses().await;\n    assert!(result.is_ok());\n\n    let addresses = result.unwrap();\n    assert_eq!(addresses.len(), 2);\n    assert!(addresses.contains(&\"/ip4/127.0.0.1/tcp/4001\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_generate_topic_id() {\n    let mock_network = MockNetworkServ::new();\n    let mock_gossip = MockGossipServ::new();\n\n    let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n    let topic_id1 = service.generate_topic_id(\"test_topic\");\n    let topic_id2 = service.generate_topic_id(\"test_topic\");\n    let topic_id3 = service.generate_topic_id(\"different_topic\");\n\n    assert_eq!(topic_id1, topic_id2);\n    assert_ne!(topic_id1, topic_id3);\n    assert!(topic_id1.starts_with(TOPIC_NAMESPACE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","post_service.rs"],"content":"use crate::application::ports::cache::PostCache;\nuse crate::application::ports::group_key_store::GroupKeyStore;\nuse crate::application::ports::repositories::{BookmarkRepository, PostFeedCursor, PostRepository};\nuse crate::application::services::event_service::EventServiceTrait;\nuse crate::domain::entities::{Post, User};\nuse crate::domain::value_objects::{EncryptedPostPayload, EventId, PublicKey};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::STANDARD};\nuse chrono::Utc;\nuse nostr_sdk::prelude::nip44;\nuse nostr_sdk::prelude::nip44::v2::ConversationKey;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse tracing::warn;\n\nconst ENCRYPTED_PLACEHOLDER: &str = \"[Encrypted post]\";\nconst PRIVATE_SCOPES: [&str; 3] = [\"friend\", \"friend_plus\", \"invite\"];\n\npub struct PostService {\n    repository: Arc<dyn PostRepository>,\n    bookmark_repository: Arc<dyn BookmarkRepository>,\n    event_service: Arc<dyn EventServiceTrait>,\n    cache: Arc<dyn PostCache>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n}\n\n#[derive(Debug, Clone)]\npub struct FollowingFeedPage {\n    pub items: Vec<Post>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub server_time: i64,\n}\n\nimpl PostService {\n    fn normalize_scope(scope: Option<String>) -> Result<Option<String>, AppError> {\n        let scope = scope\n            .map(|value| value.trim().to_string())\n            .filter(|value| !value.is_empty());\n        let Some(value) = scope.as_deref() else {\n            return Ok(None);\n        };\n        if value == \"public\" {\n            return Ok(None);\n        }\n        if PRIVATE_SCOPES.contains(&value) {\n            return Ok(Some(value.to_string()));\n        }\n        Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid scope: {value}\"),\n        ))\n    }\n\n    fn conversation_key_from_b64(key_b64: &str) -> Result<ConversationKey, AppError> {\n        let bytes = STANDARD\n            .decode(key_b64)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid group key: {err}\")))?;\n        ConversationKey::from_slice(&bytes)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid group key: {err}\")))\n    }\n\n    fn encrypt_with_group_key(key_b64: &str, plaintext: &str) -> Result<String, AppError> {\n        let conversation_key = Self::conversation_key_from_b64(key_b64)?;\n        let payload = nip44::v2::encrypt_to_bytes(&conversation_key, plaintext.as_bytes())\n            .map_err(|err| AppError::Crypto(format!(\"Encrypt failed: {err}\")))?;\n        Ok(STANDARD.encode(payload))\n    }\n\n    fn decrypt_with_group_key(key_b64: &str, payload_b64: &str) -> Result<String, AppError> {\n        let conversation_key = Self::conversation_key_from_b64(key_b64)?;\n        let payload = STANDARD\n            .decode(payload_b64)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid payload: {err}\")))?;\n        let decrypted = nip44::v2::decrypt_to_bytes(&conversation_key, &payload)\n            .map_err(|err| AppError::Crypto(format!(\"Decrypt failed: {err}\")))?;\n        String::from_utf8(decrypted)\n            .map_err(|err| AppError::Crypto(format!(\"Decrypt failed: {err}\")))\n    }\n\n    async fn encrypt_post_content(\n        &self,\n        content: &str,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<(String, i64), AppError> {\n        let record = self\n            .group_key_store\n            .get_latest_key(topic_id, scope)\n            .await?\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Group key not found for {topic_id}:{scope}\"),\n                )\n            })?;\n        let payload_b64 = Self::encrypt_with_group_key(&record.key_b64, content)?;\n        let payload = EncryptedPostPayload::new(\n            topic_id.to_string(),\n            scope.to_string(),\n            record.epoch,\n            payload_b64,\n        );\n        let json = serde_json::to_string(&payload)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        Ok((json, record.epoch))\n    }\n\n    async fn prepare_post(&self, mut post: Post) -> Result<Post, AppError> {\n        let Some(payload) = EncryptedPostPayload::try_parse(&post.content) else {\n            return Ok(post);\n        };\n        post.is_encrypted = true;\n        if post.scope.is_none() {\n            post.scope = Some(payload.scope.clone());\n        }\n        if post.epoch.is_none() {\n            post.epoch = Some(payload.epoch);\n        }\n\n        let record = self\n            .group_key_store\n            .get_key(&payload.topic, &payload.scope, payload.epoch)\n            .await?;\n        let Some(record) = record else {\n            post.content = ENCRYPTED_PLACEHOLDER.to_string();\n            return Ok(post);\n        };\n\n        match Self::decrypt_with_group_key(&record.key_b64, &payload.payload_b64) {\n            Ok(content) => {\n                post.content = content;\n            }\n            Err(_) => {\n                post.content = ENCRYPTED_PLACEHOLDER.to_string();\n            }\n        }\n\n        Ok(post)\n    }\n\n    async fn prepare_posts(&self, posts: Vec<Post>) -> Result<Vec<Post>, AppError> {\n        let mut prepared = Vec::with_capacity(posts.len());\n        for post in posts {\n            prepared.push(self.prepare_post(post).await?);\n        }\n        Ok(prepared)\n    }\n\n    pub fn new(\n        repository: Arc<dyn PostRepository>,\n        bookmark_repository: Arc<dyn BookmarkRepository>,\n        event_service: Arc<dyn EventServiceTrait>,\n        cache: Arc<dyn PostCache>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n    ) -> Self {\n        Self {\n            repository,\n            bookmark_repository,\n            event_service,\n            cache,\n            group_key_store,\n        }\n    }\n\n    pub async fn create_post(\n        &self,\n        content: String,\n        author: User,\n        topic_id: String,\n        scope: Option<String>,\n    ) -> Result<Post, AppError> {\n        let scope = Self::normalize_scope(scope)?;\n        let mut post = Post::new(content.clone(), author, topic_id.clone());\n\n        if let Some(ref scope_value) = scope {\n            let (encrypted_content, epoch) = self\n                .encrypt_post_content(&content, &topic_id, scope_value)\n                .await?;\n            post.content = encrypted_content;\n            post.scope = Some(scope_value.clone());\n            post.epoch = Some(epoch);\n            post.is_encrypted = true;\n        }\n\n        self.repository.create_post(&post).await?;\n\n        match self\n            .event_service\n            .publish_topic_post(\n                &topic_id,\n                &post.content,\n                None,\n                post.scope.as_deref(),\n                post.epoch,\n            )\n            .await\n        {\n            Ok(event_id) => {\n                let event_hex = event_id.to_string();\n                post.mark_as_synced(event_hex.clone());\n                self.repository\n                    .mark_post_synced(&post.id, &event_hex)\n                    .await?;\n            }\n            Err(err) => {\n                self.cache.add(post.clone()).await;\n                return Err(err);\n            }\n        }\n\n        let prepared = self.prepare_post(post.clone()).await?;\n        self.cache.add(prepared.clone()).await;\n        Ok(prepared)\n    }\n\n    pub async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        // キャッシュから取得を試みる\n        if let Some(post) = self.cache.get(id).await {\n            return Ok(Some(self.prepare_post(post).await?));\n        }\n\n        // キャッシュにない場合はDBから取得\n        let post = self.repository.get_post(id).await?;\n\n        // キャッシュに保存\n        if let Some(post) = post {\n            let prepared = self.prepare_post(post).await?;\n            self.cache.add(prepared.clone()).await;\n            return Ok(Some(prepared));\n        }\n\n        Ok(None)\n    }\n\n    pub async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        if limit == 0 {\n            return Ok(Vec::new());\n        }\n\n        let cached_all = self.cache.get_by_topic(topic_id, usize::MAX).await;\n        if cached_all.len() >= limit {\n            return Ok(cached_all.into_iter().take(limit).collect());\n        }\n\n        let mut posts = self.repository.get_posts_by_topic(topic_id, limit).await?;\n\n        if !cached_all.is_empty() {\n            let mut seen: HashSet<String> = posts.iter().map(|post| post.id.clone()).collect();\n            for cached in cached_all {\n                if seen.insert(cached.id.clone()) {\n                    posts.push(cached);\n                }\n            }\n        }\n\n        posts.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n\n        let prepared = self.prepare_posts(posts).await?;\n\n        // キャッシュにも最新の取得結果を反映\n        self.cache.set_topic_posts(topic_id, prepared.clone()).await;\n\n        Ok(prepared.into_iter().take(limit).collect())\n    }\n\n    pub async fn like_post(&self, post_id: &str) -> Result<(), AppError> {\n        self.react_to_post(post_id, \"+\").await\n    }\n\n    pub async fn boost_post(&self, post_id: &str) -> Result<(), AppError> {\n        self.event_service.boost_post(post_id).await?;\n\n        if let Some(mut post) = self.repository.get_post(post_id).await? {\n            post.increment_boosts();\n            self.repository.update_post(&post).await?;\n            self.cache.remove(post_id).await;\n        }\n\n        Ok(())\n    }\n\n    pub async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        self.event_service\n            .delete_events(vec![id.to_string()], Some(\"Post deleted\".to_string()))\n            .await?;\n        self.repository.delete_post(id).await?;\n        self.cache.remove(id).await;\n        Ok(())\n    }\n\n    pub async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let posts = self\n            .repository\n            .get_posts_by_author(author_pubkey, limit)\n            .await?;\n        self.prepare_posts(posts).await\n    }\n\n    pub async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        let posts = self.repository.get_recent_posts(limit).await?;\n        self.prepare_posts(posts).await\n    }\n\n    pub async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<&str>,\n        limit: usize,\n    ) -> Result<FollowingFeedPage, AppError> {\n        let limit = limit.clamp(1, 100);\n        let parsed_cursor = cursor.and_then(PostFeedCursor::parse);\n        let page = self\n            .repository\n            .list_following_feed(follower_pubkey, parsed_cursor, limit)\n            .await?;\n        let items = self.prepare_posts(page.items).await?;\n\n        Ok(FollowingFeedPage {\n            items,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            server_time: Utc::now().timestamp_millis(),\n        })\n    }\n\n    pub async fn react_to_post(&self, post_id: &str, reaction: &str) -> Result<(), AppError> {\n        self.event_service.send_reaction(post_id, reaction).await?;\n\n        if reaction == \"+\" {\n            if let Some(mut post) = self.repository.get_post(post_id).await? {\n                post.increment_likes();\n                self.repository.update_post(&post).await?;\n                self.cache.remove(post_id).await;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub async fn bookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        self.bookmark_repository\n            .create_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn unbookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        self.bookmark_repository\n            .delete_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn get_bookmarked_post_ids(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        let bookmarks = self.bookmark_repository.list_bookmarks(&public_key).await?;\n\n        Ok(bookmarks\n            .into_iter()\n            .map(|bookmark| bookmark.post_id().as_str().to_string())\n            .collect())\n    }\n\n    pub async fn sync_pending_posts(&self) -> Result<u32, AppError> {\n        let unsynced_posts = self.repository.get_unsync_posts().await?;\n        let mut synced_count = 0;\n\n        for mut post in unsynced_posts {\n            match self\n                .event_service\n                .publish_topic_post(\n                    &post.topic_id,\n                    &post.content,\n                    None,\n                    post.scope.as_deref(),\n                    post.epoch,\n                )\n                .await\n            {\n                Ok(event_id) => {\n                    let event_hex = event_id.to_string();\n                    post.mark_as_synced(event_hex.clone());\n                    self.repository\n                        .mark_post_synced(&post.id, &event_hex)\n                        .await?;\n                    synced_count += 1;\n                }\n                Err(err) => {\n                    warn!(\"failed to sync post {post_id}: {err}\", post_id = post.id);\n                }\n            }\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[async_trait]\nimpl super::sync_service::SyncParticipant for PostService {\n    async fn sync_pending(&self) -> Result<u32, AppError> {\n        self.sync_pending_posts().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::cache::PostCache;\n    use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord};\n    use crate::application::ports::repositories::{\n        BookmarkRepository, PostRepository, UserRepository,\n    };\n    use crate::application::services::SubscriptionRecord;\n    use crate::infrastructure::cache::PostCacheService;\n    use crate::infrastructure::database::Repository;\n    use crate::infrastructure::database::{\n        connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\n    };\n    use crate::presentation::dto::event::NostrMetadataDto;\n    use chrono::{TimeZone, Utc};\n    use std::sync::Arc;\n    use std::time::Duration;\n    use tokio::sync::Mutex;\n    use tokio::time::sleep;\n\n    struct TestGroupKeyStore {\n        records: Mutex<Vec<GroupKeyRecord>>,\n    }\n\n    impl TestGroupKeyStore {\n        fn new() -> Self {\n            Self {\n                records: Mutex::new(Vec::new()),\n            }\n        }\n    }\n\n    #[async_trait]\n    impl GroupKeyStore for TestGroupKeyStore {\n        async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n            let mut guard = self.records.lock().await;\n            if let Some(existing) = guard.iter_mut().find(|entry| {\n                entry.topic_id == record.topic_id\n                    && entry.scope == record.scope\n                    && entry.epoch == record.epoch\n            }) {\n                *existing = record;\n            } else {\n                guard.push(record);\n            }\n            Ok(())\n        }\n\n        async fn get_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n            epoch: i64,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .find(|entry| {\n                    entry.topic_id == topic_id && entry.scope == scope && entry.epoch == epoch\n                })\n                .cloned())\n        }\n\n        async fn get_latest_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .filter(|entry| entry.topic_id == topic_id && entry.scope == scope)\n                .max_by_key(|entry| entry.epoch)\n                .cloned())\n        }\n\n        async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .map(|entry| GroupKeyEntry {\n                    topic_id: entry.topic_id.clone(),\n                    scope: entry.scope.clone(),\n                    epoch: entry.epoch,\n                    stored_at: entry.stored_at,\n                })\n                .collect())\n        }\n    }\n\n    struct TestEventService {\n        publish_topic_post_result: Mutex<Option<Result<EventId, AppError>>>,\n    }\n\n    impl TestEventService {\n        fn new() -> Self {\n            Self {\n                publish_topic_post_result: Mutex::new(None),\n            }\n        }\n\n        fn with_publish_result(result: Result<EventId, AppError>) -> Self {\n            Self {\n                publish_topic_post_result: Mutex::new(Some(result)),\n            }\n        }\n\n        async fn next_publish_result(&self) -> Result<EventId, AppError> {\n            let mut guard = self.publish_topic_post_result.lock().await;\n            guard.take().unwrap_or_else(|| Ok(EventId::generate()))\n        }\n    }\n\n    impl Default for TestEventService {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n\n    #[async_trait]\n    impl EventServiceTrait for TestEventService {\n        async fn initialize(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn publish_text_note(&self, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn publish_topic_post(\n            &self,\n            _: &str,\n            _: &str,\n            _: Option<&str>,\n            _: Option<&str>,\n            _: Option<i64>,\n        ) -> Result<EventId, AppError> {\n            self.next_publish_result().await\n        }\n        async fn send_reaction(&self, _: &str, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn update_metadata(&self, _: NostrMetadataDto) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn subscribe_to_topic(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn subscribe_to_user(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n            Ok(None)\n        }\n        async fn boost_post(&self, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn delete_events(\n            &self,\n            _: Vec<String>,\n            _: Option<String>,\n        ) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn disconnect(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn set_default_p2p_topic(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n            Ok(vec![])\n        }\n    }\n\n    async fn setup_post_service_with_deps(\n        event_service: Arc<dyn EventServiceTrait>,\n    ) -> (PostService, Arc<SqliteRepository>, Arc<PostCacheService>) {\n        let (service, repository, cache, _group_key_store) =\n            setup_post_service_with_group_store(event_service).await;\n\n        (service, repository, cache)\n    }\n\n    async fn setup_post_service_with_group_store(\n        event_service: Arc<dyn EventServiceTrait>,\n    ) -> (\n        PostService,\n        Arc<SqliteRepository>,\n        Arc<PostCacheService>,\n        Arc<TestGroupKeyStore>,\n    ) {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            )\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create bookmarks table\");\n\n        let repository = Arc::new(SqliteRepository::new(pool));\n        repository\n            .initialize()\n            .await\n            .expect(\"failed to initialize repository schema\");\n        let cache = Arc::new(PostCacheService::new());\n        let group_key_store = Arc::new(TestGroupKeyStore::new());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n\n        let service = PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            event_service,\n            Arc::clone(&cache) as Arc<dyn PostCache>,\n            group_key_store_trait,\n        );\n\n        (service, repository, cache, group_key_store)\n    }\n\n    async fn setup_post_service() -> PostService {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        setup_post_service_with_deps(event_service).await.0\n    }\n\n    fn sample_user() -> User {\n        User {\n            npub: \"npub1test\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: \"Test User\".to_string(),\n                bio: \"Test bio\".to_string(),\n                avatar_url: None,\n            },\n            name: Some(\"Test User\".to_string()),\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        }\n    }\n\n    const SAMPLE_PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    #[tokio::test]\n    async fn bookmark_flow_roundtrip() {\n        let service = setup_post_service().await;\n        let event_id = EventId::generate();\n        let event_hex = event_id.to_hex();\n\n        service\n            .bookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"bookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks\");\n        assert_eq!(bookmarked, vec![event_hex.clone()]);\n\n        service\n            .unbookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"unbookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks after removal\");\n        assert!(bookmarked.is_empty());\n    }\n\n    #[tokio::test]\n    async fn create_post_marks_synced_after_publish() {\n        let expected_event = EventId::generate();\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(\n            TestEventService::with_publish_result(Ok(expected_event.clone())),\n        );\n\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let expected_event_hex = expected_event.to_string();\n\n        let post = service\n            .create_post(\n                \"hello world\".into(),\n                sample_user(),\n                \"topic-sync\".into(),\n                None,\n            )\n            .await\n            .expect(\"post creation succeeds\");\n\n        assert!(post.is_synced);\n        assert_eq!(post.event_id.as_deref(), Some(expected_event_hex.as_str()));\n\n        let stored = repository\n            .get_post(&post.id)\n            .await\n            .expect(\"db query succeeds\")\n            .expect(\"post present in db\");\n        assert_eq!(stored.id, post.id);\n\n        let unsynced = repository\n            .get_unsync_posts()\n            .await\n            .expect(\"unsynced query succeeds\");\n        assert!(unsynced.is_empty(), \"all posts should be marked synced\");\n\n        let cached = cache\n            .get(&post.id)\n            .await\n            .expect(\"post cached after creation\");\n        assert_eq!(cached.event_id.as_deref(), post.event_id.as_deref());\n    }\n\n    #[tokio::test]\n    async fn create_private_post_encrypts_and_decrypts() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, _cache, group_key_store) =\n            setup_post_service_with_group_store(event_service).await;\n\n        let key_b64 = STANDARD.encode([7u8; 32]);\n        let record = GroupKeyRecord {\n            topic_id: \"topic-private\".to_string(),\n            scope: \"friend\".to_string(),\n            epoch: 2,\n            key_b64,\n            stored_at: Utc::now().timestamp(),\n        };\n        group_key_store\n            .store_key(record.clone())\n            .await\n            .expect(\"store group key\");\n\n        let post = service\n            .create_post(\n                \"secret message\".into(),\n                sample_user(),\n                \"topic-private\".into(),\n                Some(\"friend\".into()),\n            )\n            .await\n            .expect(\"create private post\");\n\n        assert_eq!(post.content, \"secret message\");\n        assert!(post.is_encrypted);\n        assert_eq!(post.scope.as_deref(), Some(\"friend\"));\n        assert_eq!(post.epoch, Some(record.epoch));\n\n        let stored = repository\n            .get_post(&post.id)\n            .await\n            .expect(\"db fetch\")\n            .expect(\"stored post\");\n        assert_ne!(stored.content, \"secret message\");\n        let payload =\n            EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n        assert_eq!(payload.scope, \"friend\");\n        assert_eq!(payload.epoch, record.epoch);\n    }\n\n    #[tokio::test]\n    async fn create_post_caches_on_publish_failure() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(\n            TestEventService::with_publish_result(Err(AppError::NostrError(\"failed\".into()))),\n        );\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n\n        let err = service\n            .create_post(\n                \"offline\".into(),\n                sample_user(),\n                \"topic-offline\".into(),\n                None,\n            )\n            .await\n            .expect_err(\"publish failure propagates\");\n        assert!(matches!(err, AppError::NostrError(_)));\n\n        let stored = repository\n            .get_posts_by_topic(\"topic-offline\", 10)\n            .await\n            .expect(\"query succeeds\");\n        assert_eq!(stored.len(), 1);\n        let stored_post = &stored[0];\n        assert!(!stored_post.is_synced);\n        assert!(stored_post.event_id.is_none());\n\n        let unsynced = repository\n            .get_unsync_posts()\n            .await\n            .expect(\"unsynced query succeeds\");\n        assert_eq!(\n            unsynced.len(),\n            1,\n            \"failed publish should remain in unsynced queue\"\n        );\n\n        let cached = cache\n            .get(&stored_post.id)\n            .await\n            .expect(\"unsynced post cached for retry\");\n        assert_eq!(cached.id, stored_post.id);\n        assert!(!cached.is_synced);\n    }\n\n    #[tokio::test]\n    async fn list_following_feed_returns_posts_in_desc_order() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, _cache) = setup_post_service_with_deps(event_service).await;\n\n        let follower_pubkey = \"followerpub\";\n        let followed_pubkey = \"followedpub\";\n\n        repository\n            .add_follow_relation(follower_pubkey, followed_pubkey)\n            .await\n            .expect(\"follow relation\");\n\n        let mut author = sample_user();\n        author.pubkey = followed_pubkey.to_string();\n        author.npub = format!(\"npub_{followed_pubkey}\");\n\n        let first_post = service\n            .create_post(\"first\".into(), author.clone(), \"trend\".into(), None)\n            .await\n            .expect(\"create first post\");\n        sleep(Duration::from_millis(5)).await;\n        let second_post = service\n            .create_post(\"second\".into(), author.clone(), \"trend\".into(), None)\n            .await\n            .expect(\"create second post\");\n\n        assert_ne!(first_post.id, second_post.id);\n\n        let raw_page = repository\n            .list_following_feed(follower_pubkey, None, 5)\n            .await\n            .expect(\"raw page\");\n        assert_eq!(raw_page.items.len(), 2);\n\n        let page_one = service\n            .list_following_feed(follower_pubkey, None, 1)\n            .await\n            .expect(\"page one\");\n        assert_eq!(page_one.items.len(), 1);\n        let newest_id = page_one.items[0].id.clone();\n        assert_eq!(newest_id, second_post.id);\n        assert!(page_one.has_more);\n        let next_cursor = page_one.next_cursor.clone();\n\n        let page_two = service\n            .list_following_feed(follower_pubkey, next_cursor.as_deref(), 1)\n            .await\n            .expect(\"page two\");\n        assert_eq!(page_two.items.len(), 1);\n        assert_eq!(page_two.items[0].id, first_post.id);\n        assert!(!page_two.has_more);\n    }\n\n    #[tokio::test]\n    async fn get_posts_by_topic_prefers_cache_when_available() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let topic_id = \"topic-cache\";\n\n        let mut posts = Vec::new();\n        for (idx, ts) in [10_i64, 20, 30].into_iter().enumerate() {\n            let mut post = Post::new(format!(\"post-{idx}\"), sample_user(), topic_id.to_string());\n            post.created_at = Utc.timestamp_opt(ts, 0).unwrap();\n            post.is_synced = true;\n            posts.push(post);\n        }\n\n        for post in &posts {\n            repository.create_post(post).await.expect(\"seed repository\");\n        }\n\n        let initial = service\n            .get_posts_by_topic(topic_id, 3)\n            .await\n            .expect(\"initial fetch\");\n        assert_eq!(initial.len(), 3);\n\n        // DBから削除してもキャッシュから取得できることを確認\n        for post in &initial {\n            repository\n                .delete_post(&post.id)\n                .await\n                .expect(\"delete seeded post\");\n        }\n\n        let cached = service\n            .get_posts_by_topic(topic_id, 2)\n            .await\n            .expect(\"fetch from cache\");\n        assert_eq!(cached.len(), 2);\n        assert_eq!(cached[0].id, initial[0].id);\n        assert_eq!(cached[1].id, initial[1].id);\n\n        let cached_full = cache.get_by_topic(topic_id, 5).await;\n        assert_eq!(cached_full.len(), 3);\n    }\n\n    #[tokio::test]\n    async fn get_posts_by_topic_merges_cached_entries_not_in_db() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let topic_id = \"topic-cache-merge\";\n\n        let mut db_post = Post::new(\"db-post\".into(), sample_user(), topic_id.to_string());\n        db_post.created_at = Utc.timestamp_opt(50, 0).unwrap();\n        db_post.is_synced = true;\n        repository\n            .create_post(&db_post)\n            .await\n            .expect(\"seed repository with db post\");\n\n        let mut cached_only = Post::new(\"cached-only\".into(), sample_user(), topic_id.to_string());\n        cached_only.created_at = Utc.timestamp_opt(200, 0).unwrap();\n        cache.add(cached_only.clone()).await;\n\n        let result = service\n            .get_posts_by_topic(topic_id, 2)\n            .await\n            .expect(\"fetch posts should include cached-only entry\");\n\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].content, \"cached-only\");\n        assert_eq!(result[1].content, \"db-post\");\n\n        let cached_snapshot = cache.get_by_topic(topic_id, 5).await;\n        assert!(\n            cached_snapshot.iter().any(|post| post.id == cached_only.id),\n            \"cached-only post should remain cached after merge\"\n        );\n    }\n\n    #[tokio::test]\n    async fn delete_post_removes_from_cache() {\n        let (service, _repository, cache) =\n            setup_post_service_with_deps(Arc::new(TestEventService::default())).await;\n\n        let post = service\n            .create_post(\"to delete\".into(), sample_user(), \"topic-del\".into(), None)\n            .await\n            .expect(\"post creation succeeds\");\n\n        assert!(\n            cache.get(&post.id).await.is_some(),\n            \"post should be present in cache after creation\"\n        );\n\n        service\n            .delete_post(&post.id)\n            .await\n            .expect(\"delete_post should succeed\");\n\n        assert!(\n            cache.get(&post.id).await.is_none(),\n            \"post should be evicted from cache after deletion\"\n        );\n    }\n}\n","traces":[{"line":37,"address":[19015008,19014224],"length":1,"stats":{"Line":3}},{"line":38,"address":[18814929],"length":1,"stats":{"Line":3}},{"line":39,"address":[18876560,18876587],"length":1,"stats":{"Line":2}},{"line":40,"address":[18883664,18883673],"length":1,"stats":{"Line":2}},{"line":41,"address":[18875881,18875809],"length":1,"stats":{"Line":4}},{"line":42,"address":[18918041],"length":1,"stats":{"Line":2}},{"line":44,"address":[18801366,18801458],"length":1,"stats":{"Line":2}},{"line":45,"address":[18914208],"length":1,"stats":{"Line":0}},{"line":47,"address":[18801570,18801464],"length":1,"stats":{"Line":2}},{"line":48,"address":[13056140,13055915],"length":1,"stats":{"Line":2}},{"line":50,"address":[13056053],"length":1,"stats":{"Line":0}},{"line":51,"address":[19014648],"length":1,"stats":{"Line":0}},{"line":52,"address":[18883104,18883169],"length":1,"stats":{"Line":0}},{"line":56,"address":[18919171,18918816],"length":1,"stats":{"Line":1}},{"line":57,"address":[18802398,18802215],"length":1,"stats":{"Line":1}},{"line":59,"address":[18915280,18915264,18915074],"length":1,"stats":{"Line":0}},{"line":60,"address":[18876937,18877068],"length":1,"stats":{"Line":2}},{"line":61,"address":[13057046,13057024],"length":1,"stats":{"Line":0}},{"line":64,"address":[18920350,18919616,18920318],"length":1,"stats":{"Line":1}},{"line":65,"address":[19016389,19016107],"length":1,"stats":{"Line":1}},{"line":66,"address":[18920011,18919849,18920188],"length":1,"stats":{"Line":2}},{"line":67,"address":[18885037,18885270,18885248],"length":1,"stats":{"Line":0}},{"line":68,"address":[18878035,18878210],"length":1,"stats":{"Line":2}},{"line":71,"address":[18917752,18916688,18917719],"length":1,"stats":{"Line":1}},{"line":72,"address":[18878635,18878910],"length":1,"stats":{"Line":1}},{"line":73,"address":[18804496,18804223,18804372],"length":1,"stats":{"Line":2}},{"line":75,"address":[18805088,18804465,18805072],"length":1,"stats":{"Line":0}},{"line":76,"address":[18886391,18885956,18886096],"length":1,"stats":{"Line":2}},{"line":77,"address":[18886774,18886752,18886343],"length":1,"stats":{"Line":0}},{"line":78,"address":[18818515,18818699],"length":1,"stats":{"Line":2}},{"line":79,"address":[18918192,18918214],"length":1,"stats":{"Line":0}},{"line":82,"address":[14326544],"length":1,"stats":{"Line":1}},{"line":88,"address":[18919105,18919871,18918923,18919504,18921042,18919429,18918724,18918864,18919251],"length":1,"stats":{"Line":6}},{"line":90,"address":[18806139],"length":1,"stats":{"Line":1}},{"line":91,"address":[11749572],"length":1,"stats":{"Line":3}},{"line":92,"address":[18924997,18926640],"length":1,"stats":{"Line":1}},{"line":93,"address":[18808546],"length":1,"stats":{"Line":0}},{"line":94,"address":[14329082],"length":1,"stats":{"Line":0}},{"line":95,"address":[19021455],"length":1,"stats":{"Line":0}},{"line":98,"address":[18889856,18888970,18888782,18888620],"length":1,"stats":{"Line":2}},{"line":100,"address":[18888938,18889090],"length":1,"stats":{"Line":2}},{"line":101,"address":[18882170],"length":1,"stats":{"Line":1}},{"line":102,"address":[18889168],"length":1,"stats":{"Line":1}},{"line":103,"address":[18821416],"length":1,"stats":{"Line":1}},{"line":105,"address":[18814539,18814880,18814610],"length":1,"stats":{"Line":2}},{"line":106,"address":[13062880,13062898,13062352],"length":1,"stats":{"Line":0}},{"line":107,"address":[18889461],"length":1,"stats":{"Line":1}},{"line":110,"address":[18927104,18927059,18930550,18927024,18928739,18927415,18931807,18927151],"length":1,"stats":{"Line":4}},{"line":111,"address":[14329793,14329946],"length":1,"stats":{"Line":2}},{"line":112,"address":[19023393],"length":1,"stats":{"Line":1}},{"line":114,"address":[13063709],"length":1,"stats":{"Line":1}},{"line":115,"address":[18927821,18928118,18927708],"length":1,"stats":{"Line":2}},{"line":116,"address":[18884167],"length":1,"stats":{"Line":0}},{"line":118,"address":[14330644,14330530,14330231],"length":1,"stats":{"Line":2}},{"line":119,"address":[18823647],"length":1,"stats":{"Line":0}},{"line":122,"address":[18926840,18926496,18927409,18927241,18927619,18926905,18929297],"length":1,"stats":{"Line":5}},{"line":124,"address":[18884621],"length":1,"stats":{"Line":1}},{"line":125,"address":[11608545],"length":1,"stats":{"Line":3}},{"line":126,"address":[19024088,19023963],"length":1,"stats":{"Line":2}},{"line":127,"address":[18923849,18924975],"length":1,"stats":{"Line":0}},{"line":128,"address":[18812445],"length":1,"stats":{"Line":0}},{"line":131,"address":[18811128,18811243],"length":1,"stats":{"Line":2}},{"line":132,"address":[13065643],"length":1,"stats":{"Line":1}},{"line":133,"address":[18892951,18892891],"length":1,"stats":{"Line":1}},{"line":135,"address":[18893390],"length":1,"stats":{"Line":0}},{"line":136,"address":[19024753,19024469],"length":1,"stats":{"Line":0}},{"line":140,"address":[18811875],"length":1,"stats":{"Line":1}},{"line":143,"address":[18888848,18888800,18889033,18890249,18890270,18888808,18889325,18888898],"length":1,"stats":{"Line":4}},{"line":144,"address":[18895936,18896051],"length":1,"stats":{"Line":2}},{"line":145,"address":[18927262,18927947,18927366,18927994],"length":1,"stats":{"Line":4}},{"line":146,"address":[18896285,18897058,18895988,18896550,18896851],"length":1,"stats":{"Line":4}},{"line":148,"address":[18889973],"length":1,"stats":{"Line":1}},{"line":151,"address":[18822512],"length":1,"stats":{"Line":4}},{"line":167,"address":[14336384],"length":1,"stats":{"Line":2}},{"line":174,"address":[18816832,18816426,18816676,18817810],"length":1,"stats":{"Line":4}},{"line":175,"address":[18816798,18817759,18817708,18816917],"length":1,"stats":{"Line":2}},{"line":177,"address":[13073191,13071474],"length":1,"stats":{"Line":2}},{"line":178,"address":[14337733,14338070,14338587,14338448,14338118,14338836,14339538],"length":1,"stats":{"Line":5}},{"line":179,"address":[18831178,18831020],"length":1,"stats":{"Line":2}},{"line":180,"address":[11530831],"length":1,"stats":{"Line":3}},{"line":181,"address":[18899937,18899783],"length":1,"stats":{"Line":1}},{"line":182,"address":[19031604,19031679],"length":1,"stats":{"Line":2}},{"line":183,"address":[18832566],"length":1,"stats":{"Line":1}},{"line":184,"address":[18825648],"length":1,"stats":{"Line":1}},{"line":187,"address":[13073212,13071594,13073429,13073765,13074339,13070811],"length":1,"stats":{"Line":5}},{"line":189,"address":[18833911,18833739,18834091,18833175,18833618],"length":1,"stats":{"Line":5}},{"line":192,"address":[13073882],"length":1,"stats":{"Line":1}},{"line":193,"address":[18937936],"length":1,"stats":{"Line":1}},{"line":194,"address":[19032790],"length":1,"stats":{"Line":1}},{"line":195,"address":[18819730],"length":1,"stats":{"Line":1}},{"line":196,"address":[18932540],"length":1,"stats":{"Line":1}},{"line":198,"address":[18891120,18894593,18894844,18894528,18894632],"length":1,"stats":{"Line":3}},{"line":200,"address":[18933067],"length":1,"stats":{"Line":1}},{"line":201,"address":[18894991],"length":1,"stats":{"Line":1}},{"line":202,"address":[18820695,18820588],"length":1,"stats":{"Line":2}},{"line":203,"address":[13075780,13075907,13075331,13076033,13075018,13075248],"length":1,"stats":{"Line":6}},{"line":204,"address":[18939076],"length":1,"stats":{"Line":1}},{"line":205,"address":[18903044,18898069,18903201,18902504,18902885,18902569],"length":1,"stats":{"Line":5}},{"line":207,"address":[18895030],"length":1,"stats":{"Line":1}},{"line":208,"address":[14337078,14340880,14342348,14341533],"length":1,"stats":{"Line":2}},{"line":209,"address":[18940510],"length":1,"stats":{"Line":1}},{"line":213,"address":[11530956],"length":1,"stats":{"Line":1}},{"line":214,"address":[11573029],"length":1,"stats":{"Line":2}},{"line":215,"address":[14343897],"length":1,"stats":{"Line":1}},{"line":218,"address":[13078192,13078162,13078452,13078799,13078284,13078579,13079589,13078144],"length":1,"stats":{"Line":0}},{"line":220,"address":[18940742,18940981,18941167,18940818],"length":1,"stats":{"Line":0}},{"line":221,"address":[18825780,18824199,18824883,18824937,18825294],"length":1,"stats":{"Line":0}},{"line":225,"address":[18938862,18939289,18938486,18936924,18937738,18937835],"length":1,"stats":{"Line":0}},{"line":228,"address":[18900835,18900712],"length":1,"stats":{"Line":0}},{"line":229,"address":[18840748,18838001,18840065,18840367,18841064,18840234],"length":1,"stats":{"Line":0}},{"line":230,"address":[18943949,18943784,18943588,18940902],"length":1,"stats":{"Line":0}},{"line":231,"address":[18841251],"length":1,"stats":{"Line":0}},{"line":234,"address":[18840099],"length":1,"stats":{"Line":0}},{"line":237,"address":[13081936],"length":1,"stats":{"Line":1}},{"line":242,"address":[18946215],"length":1,"stats":{"Line":1}},{"line":243,"address":[18828162,18828050],"length":1,"stats":{"Line":0}},{"line":246,"address":[19041141,19041046,19041399,19041586],"length":1,"stats":{"Line":2}},{"line":247,"address":[18903362,18903446],"length":1,"stats":{"Line":2}},{"line":248,"address":[18941611,18941895],"length":1,"stats":{"Line":2}},{"line":251,"address":[11636357],"length":1,"stats":{"Line":3}},{"line":253,"address":[18947979,18948149],"length":1,"stats":{"Line":2}},{"line":254,"address":[14352224,14349928,14352259,14350017],"length":1,"stats":{"Line":4}},{"line":255,"address":[18844124,18843944,18844409,18843829,18844079],"length":1,"stats":{"Line":5}},{"line":256,"address":[18830492,18830402],"length":1,"stats":{"Line":2}},{"line":257,"address":[13084855],"length":1,"stats":{"Line":1}},{"line":262,"address":[18846144,18843666,18844503,18846112],"length":1,"stats":{"Line":4}},{"line":264,"address":[11636377],"length":1,"stats":{"Line":2}},{"line":267,"address":[11523696],"length":1,"stats":{"Line":2}},{"line":269,"address":[18950223],"length":1,"stats":{"Line":1}},{"line":272,"address":[18913936,18913984,18913954,18914019,18914186,18914149,18914306,18914589],"length":1,"stats":{"Line":0}},{"line":273,"address":[18914176,18914233,18914338,18914117],"length":1,"stats":{"Line":0}},{"line":276,"address":[18951424,18951471,18951376,18951394,18951621,18951727,18951948,18952696],"length":1,"stats":{"Line":0}},{"line":277,"address":[18907879,18907955,18908284,18908941,18908097],"length":1,"stats":{"Line":0}},{"line":279,"address":[18951672,18953498,18952705,18952427],"length":1,"stats":{"Line":0}},{"line":280,"address":[18953206],"length":1,"stats":{"Line":0}},{"line":281,"address":[19046477,19048600,19048287,19048093],"length":1,"stats":{"Line":0}},{"line":282,"address":[13089795,13087730,13090084,13089927],"length":1,"stats":{"Line":0}},{"line":285,"address":[13089501],"length":1,"stats":{"Line":0}},{"line":288,"address":[14355888,14355840,14356889,14356171,14356086,14356875,14355858,14355935],"length":1,"stats":{"Line":4}},{"line":289,"address":[19050646,19050857,19050120,19049356,19050005,19050353,19050463],"length":1,"stats":{"Line":5}},{"line":290,"address":[18843288,18843781,18843920,18843879],"length":1,"stats":{"Line":2}},{"line":291,"address":[18953969,18953000,18954147,18953645,18953704,18953813],"length":1,"stats":{"Line":4}},{"line":292,"address":[18838359,18837611,18838145,18836381,18837841],"length":1,"stats":{"Line":2}},{"line":293,"address":[13092544,13092668,13092412,13090706],"length":1,"stats":{"Line":2}},{"line":294,"address":[18845405],"length":1,"stats":{"Line":1}},{"line":297,"address":[18956928],"length":1,"stats":{"Line":0}},{"line":302,"address":[18852781,18852840,18852615,18853110,18853359,18853012],"length":1,"stats":{"Line":0}},{"line":305,"address":[18846335,18845696,18845877,18845833,18846084,18845934],"length":1,"stats":{"Line":0}},{"line":306,"address":[18846459,18846600,18846263,18845714],"length":1,"stats":{"Line":0}},{"line":309,"address":[19053184,19053597,19054280,19053251,19053374,19053441,19053216,19053197],"length":1,"stats":{"Line":0}},{"line":310,"address":[18958716,18958845,18959240,18958617,18958560],"length":1,"stats":{"Line":0}},{"line":311,"address":[18922596,18922403,18922737,18921867],"length":1,"stats":{"Line":0}},{"line":314,"address":[18916096],"length":1,"stats":{"Line":1}},{"line":320,"address":[18958679,18958527],"length":1,"stats":{"Line":2}},{"line":321,"address":[14361634,14361591],"length":1,"stats":{"Line":2}},{"line":322,"address":[18849796,18849971,18849324,18849460,18848898,18849066,18849133],"length":1,"stats":{"Line":5}},{"line":324,"address":[18855998],"length":1,"stats":{"Line":1}},{"line":325,"address":[11612399],"length":1,"stats":{"Line":4}},{"line":326,"address":[18857473,18856862,18856999,18855724,18856646],"length":1,"stats":{"Line":2}},{"line":328,"address":[13098179],"length":1,"stats":{"Line":1}},{"line":329,"address":[18850376],"length":1,"stats":{"Line":1}},{"line":330,"address":[18960272],"length":1,"stats":{"Line":1}},{"line":331,"address":[18961964],"length":1,"stats":{"Line":1}},{"line":332,"address":[18956395,18956546],"length":1,"stats":{"Line":2}},{"line":336,"address":[14364025,14364352,14363855,14363744,14364131,14363808,14363772,14365127],"length":1,"stats":{"Line":0}},{"line":337,"address":[18858303,18858716,18859436,18858521,18858379],"length":1,"stats":{"Line":0}},{"line":339,"address":[13099707],"length":1,"stats":{"Line":0}},{"line":340,"address":[11583976],"length":1,"stats":{"Line":0}},{"line":341,"address":[18962885],"length":1,"stats":{"Line":0}},{"line":342,"address":[18851445,18853632,18853319,18853132],"length":1,"stats":{"Line":0}},{"line":343,"address":[11502503],"length":1,"stats":{"Line":0}},{"line":347,"address":[18920045],"length":1,"stats":{"Line":0}},{"line":350,"address":[14366752,14366979,14367887,14368709,14367043,14366716,14366688,14366799],"length":1,"stats":{"Line":4}},{"line":351,"address":[18965956,18966901,18966102,18966331],"length":1,"stats":{"Line":2}},{"line":352,"address":[13104160,13104175,13102299],"length":1,"stats":{"Line":0}},{"line":353,"address":[13102432,13102666,13102277,13102892],"length":1,"stats":{"Line":2}},{"line":354,"address":[18922906,18924496,18924511],"length":1,"stats":{"Line":0}},{"line":356,"address":[18849299,18848479,18848816,18848974,18848538,18848271],"length":1,"stats":{"Line":5}},{"line":357,"address":[13102764],"length":1,"stats":{"Line":1}},{"line":358,"address":[18854517,18855696,18855291,18855485,18855341,18856016],"length":1,"stats":{"Line":5}},{"line":360,"address":[11620082],"length":1,"stats":{"Line":1}},{"line":361,"address":[18863555],"length":1,"stats":{"Line":1}},{"line":364,"address":[18964496,18963917,18962684,18962656,18962720,18962767,18963015,18962951],"length":1,"stats":{"Line":4}},{"line":365,"address":[13104891,13104662,13105461,13104516],"length":1,"stats":{"Line":2}},{"line":366,"address":[14371167,14369672,14371152],"length":1,"stats":{"Line":0}},{"line":367,"address":[19063978,19063744,19064204,19063589],"length":1,"stats":{"Line":2}},{"line":368,"address":[18968831,18967498,18968816],"length":1,"stats":{"Line":0}},{"line":370,"address":[18969885,18969103,18969748,18969311,18969370,18969638],"length":1,"stats":{"Line":5}},{"line":371,"address":[14370106],"length":1,"stats":{"Line":1}},{"line":372,"address":[11624577],"length":1,"stats":{"Line":4}},{"line":374,"address":[18857082,18858585,18858428,18858296],"length":1,"stats":{"Line":2}},{"line":375,"address":[19065128],"length":1,"stats":{"Line":1}},{"line":378,"address":[18852224],"length":1,"stats":{"Line":1}},{"line":382,"address":[18852933,18852727,18852415,18852518],"length":1,"stats":{"Line":2}},{"line":383,"address":[18934202,18935248,18935263],"length":1,"stats":{"Line":0}},{"line":385,"address":[11666916],"length":1,"stats":{"Line":3}},{"line":387,"address":[18966044,18966237],"length":1,"stats":{"Line":2}},{"line":389,"address":[18972096,18972064],"length":1,"stats":{"Line":2}},{"line":393,"address":[18966983,18966883,18966664,18967188,18967923,18966742,18966656,18966688],"length":1,"stats":{"Line":0}},{"line":394,"address":[11737170],"length":1,"stats":{"Line":0}},{"line":395,"address":[18936405],"length":1,"stats":{"Line":0}},{"line":397,"address":[18930661,18929705,18929495,18930612],"length":1,"stats":{"Line":0}},{"line":398,"address":[18863352,18863473,18862889,18863611,18863787],"length":1,"stats":{"Line":0}},{"line":401,"address":[19069360],"length":1,"stats":{"Line":0}},{"line":402,"address":[18930950],"length":1,"stats":{"Line":0}},{"line":403,"address":[18974716],"length":1,"stats":{"Line":0}},{"line":404,"address":[13110744],"length":1,"stats":{"Line":0}},{"line":405,"address":[18938066],"length":1,"stats":{"Line":0}},{"line":407,"address":[18936748,18935750,18938231,18938166,18938448],"length":1,"stats":{"Line":0}},{"line":409,"address":[18870795],"length":1,"stats":{"Line":0}},{"line":410,"address":[14375887],"length":1,"stats":{"Line":0}},{"line":411,"address":[13111495],"length":1,"stats":{"Line":0}},{"line":412,"address":[18974009,18975557,18975867,18973698,18975784,18973872],"length":1,"stats":{"Line":0}},{"line":413,"address":[19070412],"length":1,"stats":{"Line":0}},{"line":414,"address":[14376340,14376401,14373175,14374149,14374330,14374537],"length":1,"stats":{"Line":0}},{"line":415,"address":[18968340,18968509,18968469],"length":1,"stats":{"Line":0}},{"line":417,"address":[18857107],"length":1,"stats":{"Line":0}},{"line":418,"address":[18931752,18932750,19000937,19001071,18932249],"length":1,"stats":{"Line":0}},{"line":423,"address":[13110452],"length":1,"stats":{"Line":0}},{"line":429,"address":[19001867,19001663,19001557,19001391,19001640,19001440,19001475,19002128],"length":1,"stats":{"Line":0}},{"line":430,"address":[11984279],"length":1,"stats":{"Line":0}}],"covered":139,"coverable":221},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","profile_avatar_service.rs"],"content":"use std::{path::PathBuf, str::FromStr};\n\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64_STANDARD};\nuse blake3::Hasher as Blake3;\nuse rand::TryRngCore;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\nuse crate::{\n    domain::entities::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry},\n    infrastructure::{\n        crypto::{CapabilityEncryptor, EncryptedSessionKey, StreamEncryptor},\n        storage::profile_avatar_store::{ProfileAvatarStore, ProfileAvatarSyncPackage},\n    },\n    shared::AppError,\n};\n\nconst MAX_AVATAR_BYTES: usize = 2 * 1024 * 1024;\nconst AES_KEY_SIZE: usize = 32;\nconst AES_NONCE_SIZE: usize = 12;\n\n#[derive(Debug)]\npub struct UploadProfileAvatarInput {\n    pub npub: String,\n    pub bytes: Vec<u8>,\n    pub format: String,\n    pub access_level: ProfileAvatarAccessLevel,\n}\n\n#[derive(Debug)]\npub struct ProfileAvatarFetchResult {\n    pub bytes: Vec<u8>,\n    pub metadata: ProfileAvatarDocEntry,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct ShareTicketPayload {\n    version: u8,\n    access_level: String,\n    capability_secret: String,\n}\n\npub struct ProfileAvatarService {\n    store: ProfileAvatarStore,\n}\n\nimpl ProfileAvatarService {\n    pub async fn new(root_dir: PathBuf) -> Result<Self, AppError> {\n        let store = ProfileAvatarStore::new(root_dir).await?;\n        Ok(Self { store })\n    }\n\n    pub async fn upload_avatar(\n        &self,\n        input: UploadProfileAvatarInput,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        validate_format(&input.format)?;\n        validate_size(input.bytes.len())?;\n\n        let encrypted = StreamEncryptor::encrypt(&input.bytes)?;\n        let blob_hash = compute_blob_hash(&encrypted.ciphertext);\n        let content_sha256 = compute_content_sha256(&input.bytes);\n\n        self.store\n            .write_encrypted_blob(&blob_hash, &encrypted.ciphertext)\n            .await?;\n\n        let mut capability_secret = [0u8; AES_KEY_SIZE];\n        rand::rngs::OsRng\n            .try_fill_bytes(&mut capability_secret)\n            .map_err(|err| {\n                AppError::Crypto(format!(\"Failed to generate capability secret: {err}\"))\n            })?;\n\n        let encrypted_session_key =\n            CapabilityEncryptor::encrypt_session_key(&encrypted.session_key, &capability_secret)?;\n\n        let share_ticket = encode_share_ticket(input.access_level, &capability_secret)?;\n        let key_nonce_b64 = BASE64_STANDARD.encode(encrypted_session_key.nonce);\n        let encrypted_key_b64 = BASE64_STANDARD.encode(encrypted_session_key.ciphertext);\n        let encryption_nonce_b64 = BASE64_STANDARD.encode(encrypted.nonce);\n\n        let entry = ProfileAvatarDocEntry {\n            npub: input.npub,\n            blob_hash,\n            format: input.format,\n            size_bytes: input.bytes.len() as u64,\n            access_level: input.access_level,\n            share_ticket,\n            encrypted_key: encrypted_key_b64,\n            key_nonce: key_nonce_b64,\n            encryption_nonce: encryption_nonce_b64,\n            content_sha256,\n            updated_at: chrono::Utc::now(),\n            version: 0,\n        };\n\n        self.store.upsert_entry(entry).await\n    }\n\n    pub async fn fetch_avatar(&self, npub: &str) -> Result<ProfileAvatarFetchResult, AppError> {\n        let metadata =\n            self.store.get_entry(npub).await?.ok_or_else(|| {\n                AppError::NotFound(format!(\"Profile avatar not found for {npub}\"))\n            })?;\n\n        let ticket = decode_share_ticket(&metadata.share_ticket)?;\n        if ticket.access_level != metadata.access_level {\n            return Err(AppError::validation(\n                crate::shared::validation::ValidationFailureKind::Generic,\n                format!(\n                    \"share ticket access level mismatch (ticket={}, metadata={})\",\n                    ticket.access_level.as_str(),\n                    metadata.access_level.as_str()\n                ),\n            ));\n        }\n        let capability_secret = ticket.capability_secret;\n        let encrypted_key = BASE64_STANDARD\n            .decode(metadata.encrypted_key.as_bytes())\n            .map_err(|err| {\n                AppError::DeserializationError(format!(\"Invalid encrypted key: {err}\"))\n            })?;\n        let mut key_nonce = [0u8; AES_NONCE_SIZE];\n        let decoded_key_nonce = BASE64_STANDARD\n            .decode(metadata.key_nonce.as_bytes())\n            .map_err(|err| AppError::DeserializationError(format!(\"Invalid key nonce: {err}\")))?;\n        if decoded_key_nonce.len() != AES_NONCE_SIZE {\n            return Err(AppError::DeserializationError(\n                \"Key nonce has invalid length\".to_string(),\n            ));\n        }\n        key_nonce.copy_from_slice(&decoded_key_nonce);\n\n        let encrypted_session_key = EncryptedSessionKey {\n            ciphertext: encrypted_key,\n            nonce: key_nonce,\n        };\n        let session_key =\n            CapabilityEncryptor::decrypt_session_key(&encrypted_session_key, &capability_secret)?;\n\n        let mut encryption_nonce = [0u8; AES_NONCE_SIZE];\n        let decoded_encryption_nonce = BASE64_STANDARD\n            .decode(metadata.encryption_nonce.as_bytes())\n            .map_err(|err| {\n                AppError::DeserializationError(format!(\"Invalid encryption nonce: {err}\"))\n            })?;\n        if decoded_encryption_nonce.len() != AES_NONCE_SIZE {\n            return Err(AppError::DeserializationError(\n                \"Encryption nonce has invalid length\".to_string(),\n            ));\n        }\n        encryption_nonce.copy_from_slice(&decoded_encryption_nonce);\n\n        let encrypted_blob = self.store.read_encrypted_blob(&metadata.blob_hash).await?;\n        let plaintext = StreamEncryptor::decrypt(&encrypted_blob, &session_key, &encryption_nonce)?;\n\n        Ok(ProfileAvatarFetchResult {\n            bytes: plaintext,\n            metadata,\n        })\n    }\n\n    pub async fn export_sync_package(\n        &self,\n        npub: &str,\n    ) -> Result<Option<ProfileAvatarSyncPackage>, AppError> {\n        self.store.export_sync_package(npub).await\n    }\n\n    pub async fn import_sync_package(\n        &self,\n        package: ProfileAvatarSyncPackage,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        self.store.import_sync_package(package).await\n    }\n\n    pub async fn entries_snapshot(&self) -> Vec<ProfileAvatarDocEntry> {\n        self.store.entries_snapshot().await\n    }\n}\n\nfn validate_format(format: &str) -> Result<(), AppError> {\n    if !format.starts_with(\"image/\") {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::Generic,\n            \"Profile avatar must be an image format\",\n        ));\n    }\n    Ok(())\n}\n\nfn validate_size(size: usize) -> Result<(), AppError> {\n    if size == 0 {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::Generic,\n            \"Profile avatar file is empty\",\n        ));\n    }\n    if size > MAX_AVATAR_BYTES {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::ContentTooLarge,\n            format!(\"Profile avatar size exceeds limit ({size} bytes > {MAX_AVATAR_BYTES} bytes)\"),\n        ));\n    }\n    Ok(())\n}\n\nfn compute_blob_hash(data: &[u8]) -> String {\n    let mut hasher = Blake3::new();\n    hasher.update(data);\n    hasher.finalize().to_hex().to_string()\n}\n\nfn compute_content_sha256(data: &[u8]) -> String {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hex::encode(hasher.finalize())\n}\n\nfn encode_share_ticket(\n    access_level: ProfileAvatarAccessLevel,\n    capability_secret: &[u8; AES_KEY_SIZE],\n) -> Result<String, AppError> {\n    let payload = ShareTicketPayload {\n        version: 1,\n        access_level: access_level.as_str().to_string(),\n        capability_secret: BASE64_STANDARD.encode(capability_secret),\n    };\n    let json = serde_json::to_string(&payload).map_err(|err| {\n        AppError::SerializationError(format!(\"Failed to encode share ticket: {err}\"))\n    })?;\n    Ok(BASE64_STANDARD.encode(json))\n}\n\nstruct DecodedShareTicket {\n    pub access_level: ProfileAvatarAccessLevel,\n    pub capability_secret: [u8; AES_KEY_SIZE],\n}\n\nfn decode_share_ticket(ticket: &str) -> Result<DecodedShareTicket, AppError> {\n    let json_bytes = BASE64_STANDARD\n        .decode(ticket.as_bytes())\n        .map_err(|err| AppError::DeserializationError(format!(\"Invalid share ticket: {err}\")))?;\n    let payload: ShareTicketPayload = serde_json::from_slice(&json_bytes).map_err(|err| {\n        AppError::DeserializationError(format!(\"Failed to parse share ticket payload: {err}\"))\n    })?;\n    let access_level = ProfileAvatarAccessLevel::from_str(&payload.access_level).map_err(|_| {\n        AppError::DeserializationError(\"Unknown access level in share ticket\".to_string())\n    })?;\n    let secret_bytes = BASE64_STANDARD\n        .decode(payload.capability_secret.as_bytes())\n        .map_err(|err| {\n            AppError::DeserializationError(format!(\"Invalid capability secret: {err}\"))\n        })?;\n    if secret_bytes.len() != AES_KEY_SIZE {\n        return Err(AppError::DeserializationError(\n            \"Capability secret has invalid length\".to_string(),\n        ));\n    }\n    let mut capability_secret = [0u8; AES_KEY_SIZE];\n    capability_secret.copy_from_slice(&secret_bytes);\n    Ok(DecodedShareTicket {\n        access_level,\n        capability_secret,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn upload_and_fetch_roundtrip() {\n        let temp = tempdir().unwrap();\n        let service = ProfileAvatarService::new(temp.path().to_path_buf())\n            .await\n            .expect(\"service init\");\n        let npub = \"npub1avataruser\";\n        let bytes = vec![1, 2, 3, 4, 5, 6, 7, 8];\n\n        let entry = service\n            .upload_avatar(UploadProfileAvatarInput {\n                npub: npub.to_string(),\n                bytes: bytes.clone(),\n                format: \"image/png\".to_string(),\n                access_level: ProfileAvatarAccessLevel::Public,\n            })\n            .await\n            .expect(\"upload\");\n\n        assert_eq!(entry.npub, npub);\n        assert_eq!(entry.size_bytes, bytes.len() as u64);\n\n        let fetched = service.fetch_avatar(npub).await.expect(\"fetch\");\n        assert_eq!(fetched.metadata.blob_hash, entry.blob_hash);\n        assert_eq!(fetched.bytes, bytes);\n    }\n}\n","traces":[{"line":48,"address":[12600404,12599616,12599912,12599750,12599651,12599787,12599568,12599571],"length":1,"stats":{"Line":8}},{"line":49,"address":[11626033],"length":1,"stats":{"Line":6}},{"line":50,"address":[12711731],"length":1,"stats":{"Line":2}},{"line":53,"address":[16418416],"length":1,"stats":{"Line":2}},{"line":57,"address":[12675770,12675872,12675604,12677140],"length":1,"stats":{"Line":4}},{"line":58,"address":[12710961,12712258,12711085,12711195],"length":1,"stats":{"Line":4}},{"line":60,"address":[12669541,12670182,12669108,12669248],"length":1,"stats":{"Line":4}},{"line":61,"address":[16419860,16419656],"length":1,"stats":{"Line":4}},{"line":62,"address":[20370245,20370133],"length":1,"stats":{"Line":4}},{"line":64,"address":[12712711,12715353,12712166,12712528,12712120,12711950,12712402],"length":1,"stats":{"Line":10}},{"line":65,"address":[12670011,12669919],"length":1,"stats":{"Line":4}},{"line":66,"address":[10994779,10994846],"length":1,"stats":{"Line":10}},{"line":68,"address":[20371084],"length":1,"stats":{"Line":2}},{"line":69,"address":[12603123,12605495,12602945],"length":1,"stats":{"Line":2}},{"line":70,"address":[12809205],"length":1,"stats":{"Line":2}},{"line":71,"address":[12716336],"length":1,"stats":{"Line":0}},{"line":72,"address":[12681237],"length":1,"stats":{"Line":0}},{"line":75,"address":[16421118,16421298,16420939,16423323],"length":1,"stats":{"Line":4}},{"line":78,"address":[12678290,12678096,12678498],"length":1,"stats":{"Line":4}},{"line":79,"address":[12810198,12809977],"length":1,"stats":{"Line":4}},{"line":80,"address":[12713781,12713931],"length":1,"stats":{"Line":4}},{"line":81,"address":[12710143,12710010],"length":1,"stats":{"Line":4}},{"line":84,"address":[12672046],"length":1,"stats":{"Line":2}},{"line":86,"address":[20372530],"length":1,"stats":{"Line":2}},{"line":87,"address":[12810679],"length":1,"stats":{"Line":2}},{"line":88,"address":[12597679],"length":1,"stats":{"Line":2}},{"line":94,"address":[12679450],"length":1,"stats":{"Line":2}},{"line":98,"address":[11603206],"length":1,"stats":{"Line":5}},{"line":101,"address":[12599998,12599936,12600372,12599888,12600161,12599906,12604447,12600237],"length":1,"stats":{"Line":8}},{"line":102,"address":[12712895,12717130,12717149,12712827,12718320,12713108,12713810,12712988],"length":1,"stats":{"Line":4}},{"line":104,"address":[12687157],"length":1,"stats":{"Line":0}},{"line":107,"address":[12615167,12614964,12614777,12618184],"length":1,"stats":{"Line":4}},{"line":108,"address":[12682887,12683019],"length":1,"stats":{"Line":4}},{"line":109,"address":[12604315],"length":1,"stats":{"Line":0}},{"line":110,"address":[16426130],"length":1,"stats":{"Line":0}},{"line":111,"address":[12610867,12610956],"length":1,"stats":{"Line":0}},{"line":113,"address":[12683101,12685587],"length":1,"stats":{"Line":0}},{"line":114,"address":[16428580],"length":1,"stats":{"Line":0}},{"line":118,"address":[12601505],"length":1,"stats":{"Line":2}},{"line":119,"address":[16428502,16426231,16426513],"length":1,"stats":{"Line":2}},{"line":120,"address":[20376511],"length":1,"stats":{"Line":2}},{"line":121,"address":[12612576],"length":1,"stats":{"Line":0}},{"line":122,"address":[16430224],"length":1,"stats":{"Line":0}},{"line":124,"address":[12720151],"length":1,"stats":{"Line":2}},{"line":125,"address":[12718713,12718967,12720650],"length":1,"stats":{"Line":2}},{"line":126,"address":[12615646],"length":1,"stats":{"Line":2}},{"line":127,"address":[12714983,12718656,12718672],"length":1,"stats":{"Line":0}},{"line":128,"address":[12718885,12719060],"length":1,"stats":{"Line":4}},{"line":129,"address":[12716587],"length":1,"stats":{"Line":0}},{"line":130,"address":[12684000],"length":1,"stats":{"Line":0}},{"line":133,"address":[12609322,12609210],"length":1,"stats":{"Line":4}},{"line":139,"address":[12815773,12816953,12815868,12816052],"length":1,"stats":{"Line":4}},{"line":142,"address":[12815994],"length":1,"stats":{"Line":2}},{"line":143,"address":[12719718,12720493,12719975],"length":1,"stats":{"Line":2}},{"line":144,"address":[20377921],"length":1,"stats":{"Line":2}},{"line":145,"address":[12606112],"length":1,"stats":{"Line":0}},{"line":146,"address":[12606128],"length":1,"stats":{"Line":0}},{"line":148,"address":[20378404,20378229],"length":1,"stats":{"Line":4}},{"line":149,"address":[12617483],"length":1,"stats":{"Line":0}},{"line":150,"address":[12716186],"length":1,"stats":{"Line":0}},{"line":153,"address":[12716138,12716235],"length":1,"stats":{"Line":4}},{"line":155,"address":[12718233,12716258,12717160,12712916,12717539],"length":1,"stats":{"Line":4}},{"line":156,"address":[12619029,12618734,12618563],"length":1,"stats":{"Line":4}},{"line":158,"address":[12618940],"length":1,"stats":{"Line":2}},{"line":160,"address":[12686623],"length":1,"stats":{"Line":2}},{"line":164,"address":[12606272],"length":1,"stats":{"Line":1}},{"line":168,"address":[12620259,12620420,12620316,12620213],"length":1,"stats":{"Line":3}},{"line":171,"address":[12613712],"length":1,"stats":{"Line":1}},{"line":175,"address":[12607160,12607263,12607380,12607206],"length":1,"stats":{"Line":3}},{"line":178,"address":[12614744,12614464,12614432,12614624,12614587,12614499,12615048,12614440],"length":1,"stats":{"Line":0}},{"line":179,"address":[12724527,12724470,12724632,12724424],"length":1,"stats":{"Line":0}},{"line":183,"address":[12622048],"length":1,"stats":{"Line":2}},{"line":184,"address":[12724978],"length":1,"stats":{"Line":2}},{"line":185,"address":[12615149],"length":1,"stats":{"Line":0}},{"line":186,"address":[12726648],"length":1,"stats":{"Line":0}},{"line":190,"address":[16432771],"length":1,"stats":{"Line":2}},{"line":193,"address":[12726736],"length":1,"stats":{"Line":2}},{"line":194,"address":[12608469],"length":1,"stats":{"Line":2}},{"line":195,"address":[12608482],"length":1,"stats":{"Line":0}},{"line":196,"address":[12608477],"length":1,"stats":{"Line":0}},{"line":200,"address":[12821603],"length":1,"stats":{"Line":2}},{"line":201,"address":[12683336],"length":1,"stats":{"Line":0}},{"line":202,"address":[12721270],"length":1,"stats":{"Line":0}},{"line":203,"address":[12821643],"length":1,"stats":{"Line":0}},{"line":206,"address":[12690081],"length":1,"stats":{"Line":2}},{"line":209,"address":[12683620,12683392],"length":1,"stats":{"Line":2}},{"line":210,"address":[12821915],"length":1,"stats":{"Line":2}},{"line":211,"address":[12690397],"length":1,"stats":{"Line":2}},{"line":212,"address":[12622689],"length":1,"stats":{"Line":2}},{"line":215,"address":[12609056],"length":1,"stats":{"Line":2}},{"line":216,"address":[12683691],"length":1,"stats":{"Line":2}},{"line":217,"address":[20384096],"length":1,"stats":{"Line":2}},{"line":218,"address":[12690651],"length":1,"stats":{"Line":2}},{"line":221,"address":[20384192,20384893,20384923],"length":1,"stats":{"Line":2}},{"line":227,"address":[12609260],"length":1,"stats":{"Line":2}},{"line":228,"address":[12690816],"length":1,"stats":{"Line":2}},{"line":230,"address":[12822545,12822826,12823040,12823271,12822480],"length":1,"stats":{"Line":4}},{"line":231,"address":[12722694,12722759],"length":1,"stats":{"Line":0}},{"line":233,"address":[12722332,12722528],"length":1,"stats":{"Line":4}},{"line":241,"address":[12724686,12722928,12724720],"length":1,"stats":{"Line":2}},{"line":242,"address":[12691821,12692035],"length":1,"stats":{"Line":2}},{"line":243,"address":[12610283],"length":1,"stats":{"Line":2}},{"line":244,"address":[12624244,12625792,12625808],"length":1,"stats":{"Line":0}},{"line":245,"address":[12617379,12618798,12617697,12618976,12619207,12617239],"length":1,"stats":{"Line":4}},{"line":246,"address":[12728919,12728854],"length":1,"stats":{"Line":0}},{"line":248,"address":[12685782,12686585,12687040,12685435,12685588],"length":1,"stats":{"Line":4}},{"line":249,"address":[12725176],"length":1,"stats":{"Line":0}},{"line":251,"address":[12730279,12729517,12729763],"length":1,"stats":{"Line":2}},{"line":252,"address":[12692632],"length":1,"stats":{"Line":2}},{"line":253,"address":[12825616],"length":1,"stats":{"Line":0}},{"line":254,"address":[20387536],"length":1,"stats":{"Line":0}},{"line":256,"address":[12692918,12693073],"length":1,"stats":{"Line":4}},{"line":257,"address":[12693389],"length":1,"stats":{"Line":0}},{"line":258,"address":[12693127],"length":1,"stats":{"Line":0}},{"line":261,"address":[12824631],"length":1,"stats":{"Line":2}},{"line":262,"address":[12618435,12618362],"length":1,"stats":{"Line":4}},{"line":263,"address":[16435971],"length":1,"stats":{"Line":2}},{"line":265,"address":[12724395],"length":1,"stats":{"Line":2}}],"covered":84,"coverable":118},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","subscription_state.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse std::sync::Arc;\n\n#[async_trait]\npub trait SubscriptionStateStore: Send + Sync {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError>;\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[derive(Clone)]\npub struct SubscriptionStateMachine {\n    repository: Arc<dyn SubscriptionStateRepository>,\n}\n\nimpl SubscriptionStateMachine {\n    pub fn new(repository: Arc<dyn SubscriptionStateRepository>) -> Self {\n        Self { repository }\n    }\n\n    async fn load_or_initialize(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        match self.repository.find(target).await? {\n            Some(record) => Ok(record),\n            None => Ok(SubscriptionRecord::new(target.clone())),\n        }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateStore for SubscriptionStateMachine {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self\n            .repository\n            .find(&target)\n            .await?\n            .unwrap_or_else(|| SubscriptionRecord::new(target.clone()));\n\n        record.mark_requested(now_secs);\n\n        self.repository.upsert(&record).await\n    }\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError> {\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_subscribed(synced_at);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_failure(now_secs, error);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\n        let now_ms = Utc::now().timestamp_millis();\n        self.repository.mark_all_need_resync(now_ms).await\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_for_restore().await\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_all().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::value_objects::subscription::SubscriptionStatus;\n    use crate::infrastructure::database::{\n        SqliteSubscriptionStateRepository, connection_pool::ConnectionPool,\n    };\n\n    async fn setup_state_machine() -> SubscriptionStateMachine {\n        let pool = ConnectionPool::from_memory().await.unwrap();\n        sqlx::migrate!(\"./migrations\")\n            .run(pool.get_pool())\n            .await\n            .unwrap();\n        let repository = Arc::new(SqliteSubscriptionStateRepository::new(pool));\n        SubscriptionStateMachine::new(repository)\n    }\n\n    #[tokio::test]\n    async fn record_request_inserts_and_updates() {\n        let machine = setup_state_machine().await;\n        let record = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record.failure_count, 0);\n        assert_eq!(record.status, SubscriptionStatus::Pending);\n\n        let record_again = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record_again.status, SubscriptionStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn mark_subscribed_updates_status() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 100).await.unwrap();\n        let all = machine.list_all().await.unwrap();\n        assert_eq!(all[0].status, SubscriptionStatus::Subscribed);\n        assert_eq!(all[0].last_synced_at, Some(100));\n    }\n\n    #[tokio::test]\n    async fn mark_failure_increments_counter() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"fail_topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_failure(&target, \"error\").await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(|record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"fail_topic\"))\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n        assert_eq!(record.failure_count, 1);\n        assert_eq!(record.error_message.as_deref(), Some(\"error\"));\n    }\n\n    #[tokio::test]\n    async fn mark_all_need_resync_updates_subscribed() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"resync\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 200).await.unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(\n                |record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"resync\"),\n            )\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n    }\n\n    #[tokio::test]\n    async fn list_for_restore_filters_status() {\n        let machine = setup_state_machine().await;\n        let pending_target = SubscriptionTarget::Topic(\"pending\".into());\n        machine.record_request(pending_target).await.unwrap();\n        let subscribed_target = SubscriptionTarget::User(\"user\".into());\n        machine\n            .record_request(subscribed_target.clone())\n            .await\n            .unwrap();\n        machine\n            .mark_subscribed(&subscribed_target, 100)\n            .await\n            .unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n\n        let restore = machine.list_for_restore().await.unwrap();\n        assert_eq!(restore.len(), 2);\n    }\n}\n","traces":[{"line":36,"address":[16572960],"length":1,"stats":{"Line":1}},{"line":40,"address":[16463136],"length":1,"stats":{"Line":2}},{"line":44,"address":[16538270,16538018,16538066,16538895,16538133],"length":1,"stats":{"Line":5}},{"line":45,"address":[16457223],"length":1,"stats":{"Line":2}},{"line":46,"address":[16573917,16573839],"length":1,"stats":{"Line":0}},{"line":53,"address":[15453309,15453183,15453087,15453136,15453580,15454653,15453442,15455213,15453830],"length":1,"stats":{"Line":5}},{"line":57,"address":[16614317,16614384],"length":1,"stats":{"Line":2}},{"line":58,"address":[16614444,16615106,16614922,16614744,16615184,16614558,16614499],"length":1,"stats":{"Line":7}},{"line":60,"address":[16675319],"length":1,"stats":{"Line":1}},{"line":61,"address":[11956457],"length":1,"stats":{"Line":5}},{"line":62,"address":[19613216],"length":1,"stats":{"Line":3}},{"line":64,"address":[16814533],"length":1,"stats":{"Line":1}},{"line":66,"address":[11954828],"length":1,"stats":{"Line":3}},{"line":69,"address":[16715444,16717263,16715235,16716544,16715660,16715151,16715314,16715200],"length":1,"stats":{"Line":7}},{"line":74,"address":[16685355,16684369,16684157,16685071,16684508],"length":1,"stats":{"Line":3}},{"line":75,"address":[16617281],"length":1,"stats":{"Line":2}},{"line":76,"address":[19614978,19615035,19615080],"length":1,"stats":{"Line":4}},{"line":77,"address":[16721145],"length":1,"stats":{"Line":2}},{"line":80,"address":[16723220,16724385,16723493,16723011,16722919,16723090,16725104,16722976],"length":1,"stats":{"Line":5}},{"line":81,"address":[16686548],"length":1,"stats":{"Line":1}},{"line":82,"address":[11339295],"length":1,"stats":{"Line":2}},{"line":83,"address":[16724058],"length":1,"stats":{"Line":1}},{"line":84,"address":[11917874,11917931,11917976],"length":1,"stats":{"Line":2}},{"line":85,"address":[16819834],"length":1,"stats":{"Line":1}},{"line":88,"address":[16681488,16681449,16682013,16681691,16681523,16681602,16681714,16682271],"length":1,"stats":{"Line":10}},{"line":89,"address":[16723867],"length":1,"stats":{"Line":2}},{"line":90,"address":[16719992,16720157,16719741],"length":1,"stats":{"Line":4}},{"line":93,"address":[16689299,16689490,16689264,16689378,16689718,16689467,16689976,16689225],"length":1,"stats":{"Line":5}},{"line":94,"address":[11848868],"length":1,"stats":{"Line":2}},{"line":97,"address":[16725282,16725203,16725371,16725622,16725394,16725129,16725168,16725880],"length":1,"stats":{"Line":5}},{"line":98,"address":[16622429,16622614,16622774],"length":1,"stats":{"Line":2}}],"covered":30,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","sync_service.rs"],"content":"use crate::infrastructure::p2p::NetworkService;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[async_trait]\npub trait SyncParticipant: Send + Sync {\n    async fn sync_pending(&self) -> Result<u32, AppError>;\n}\n\n#[async_trait]\npub trait SyncServiceTrait: Send + Sync {\n    async fn start_sync(&self) -> Result<(), AppError>;\n    async fn stop_sync(&self) -> Result<(), AppError>;\n    async fn get_status(&self) -> SyncStatus;\n    async fn reset_sync(&self) -> Result<(), AppError>;\n    async fn schedule_sync(&self, interval_secs: u64);\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct SyncStatus {\n    pub is_syncing: bool,\n    pub pending_posts: u32,\n    pub pending_events: u32,\n    pub last_sync: Option<i64>,\n    pub sync_errors: u32,\n}\n\npub struct SyncService {\n    network: Arc<dyn NetworkService>,\n    post_participant: Arc<dyn SyncParticipant>,\n    event_participant: Arc<dyn SyncParticipant>,\n    status: Arc<RwLock<SyncStatus>>,\n}\n\nimpl SyncService {\n    pub fn new(\n        network: Arc<dyn NetworkService>,\n        post_participant: Arc<dyn SyncParticipant>,\n        event_participant: Arc<dyn SyncParticipant>,\n    ) -> Self {\n        Self {\n            network,\n            post_participant,\n            event_participant,\n            status: Arc::new(RwLock::new(SyncStatus {\n                is_syncing: false,\n                pending_posts: 0,\n                pending_events: 0,\n                last_sync: None,\n                sync_errors: 0,\n            })),\n        }\n    }\n\n    pub async fn start_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n\n        if status.is_syncing {\n            return Ok(());\n        }\n\n        status.is_syncing = true;\n        drop(status);\n\n        if !self.network.is_connected().await {\n            self.network.connect().await?;\n        }\n\n        let synced_posts = self.post_participant.sync_pending().await?;\n        let synced_events = self.event_participant.sync_pending().await?;\n\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        status.last_sync = Some(chrono::Utc::now().timestamp());\n        status.pending_posts = status.pending_posts.saturating_sub(synced_posts);\n        status.pending_events = status.pending_events.saturating_sub(synced_events);\n\n        Ok(())\n    }\n\n    pub async fn stop_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        Ok(())\n    }\n\n    pub async fn get_status(&self) -> SyncStatus {\n        self.status.read().await.clone()\n    }\n\n    pub async fn reset_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n        status.pending_posts = 0;\n        status.pending_events = 0;\n        status.sync_errors = 0;\n        Ok(())\n    }\n\n    pub async fn schedule_sync(&self, interval_secs: u64) {\n        let service = Arc::new(self.clone());\n        tokio::spawn(async move {\n            let mut interval =\n                tokio::time::interval(tokio::time::Duration::from_secs(interval_secs));\n\n            loop {\n                interval.tick().await;\n\n                if let Err(e) = service.start_sync().await {\n                    tracing::error!(\"Sync error: {}\", e);\n                    let mut status = service.status.write().await;\n                    status.sync_errors += 1;\n                }\n            }\n        });\n    }\n}\n\nimpl Clone for SyncService {\n    fn clone(&self) -> Self {\n        Self {\n            network: self.network.clone(),\n            post_participant: self.post_participant.clone(),\n            event_participant: self.event_participant.clone(),\n            status: self.status.clone(),\n        }\n    }\n}\n\n#[async_trait]\nimpl SyncServiceTrait for SyncService {\n    async fn start_sync(&self) -> Result<(), AppError> {\n        SyncService::start_sync(self).await\n    }\n\n    async fn stop_sync(&self) -> Result<(), AppError> {\n        SyncService::stop_sync(self).await\n    }\n\n    async fn get_status(&self) -> SyncStatus {\n        SyncService::get_status(self).await\n    }\n\n    async fn reset_sync(&self) -> Result<(), AppError> {\n        SyncService::reset_sync(self).await\n    }\n\n    async fn schedule_sync(&self, interval_secs: u64) {\n        SyncService::schedule_sync(self, interval_secs).await\n    }\n}\n","traces":[{"line":38,"address":[17945079,17945120,17944720],"length":1,"stats":{"Line":0}},{"line":47,"address":[14378259,14378398],"length":1,"stats":{"Line":0}},{"line":57,"address":[14379055,14378544,14378552,14378905,14378576,14378745,14378623,14379717],"length":1,"stats":{"Line":0}},{"line":58,"address":[11570145],"length":1,"stats":{"Line":0}},{"line":60,"address":[23705401,23705485],"length":1,"stats":{"Line":0}},{"line":61,"address":[23810050],"length":1,"stats":{"Line":0}},{"line":64,"address":[23691783,23691731],"length":1,"stats":{"Line":0}},{"line":65,"address":[23705547],"length":1,"stats":{"Line":0}},{"line":67,"address":[11570168],"length":1,"stats":{"Line":0}},{"line":68,"address":[11451903],"length":1,"stats":{"Line":0}},{"line":71,"address":[11465686],"length":1,"stats":{"Line":0}},{"line":72,"address":[11458733],"length":1,"stats":{"Line":0}},{"line":74,"address":[11568612],"length":1,"stats":{"Line":0}},{"line":75,"address":[14381944,14382001],"length":1,"stats":{"Line":0}},{"line":76,"address":[23812781],"length":1,"stats":{"Line":0}},{"line":77,"address":[23694613],"length":1,"stats":{"Line":0}},{"line":78,"address":[23694703],"length":1,"stats":{"Line":0}},{"line":80,"address":[17949095],"length":1,"stats":{"Line":0}},{"line":83,"address":[17949176,17949342,17949483,17949168,17949219,17949184,17949305,17949867],"length":1,"stats":{"Line":0}},{"line":84,"address":[11462916],"length":1,"stats":{"Line":0}},{"line":85,"address":[23709185,23709250],"length":1,"stats":{"Line":0}},{"line":86,"address":[14382946],"length":1,"stats":{"Line":0}},{"line":89,"address":[23770350,23770491,23770227,23770184,23770923,23770313,23770192,23770176],"length":1,"stats":{"Line":0}},{"line":90,"address":[23695701,23695748,23695931,23695807],"length":1,"stats":{"Line":0}},{"line":93,"address":[23710120,23710112,23710249,23710880,23710286,23710427,23710128,23710163],"length":1,"stats":{"Line":0}},{"line":94,"address":[11568372],"length":1,"stats":{"Line":0}},{"line":95,"address":[23778433,23778500],"length":1,"stats":{"Line":0}},{"line":96,"address":[23813627],"length":1,"stats":{"Line":0}},{"line":97,"address":[17951324],"length":1,"stats":{"Line":0}},{"line":98,"address":[23815339],"length":1,"stats":{"Line":0}},{"line":101,"address":[23815437,23815424,23815456,23815564,23815476,23815767],"length":1,"stats":{"Line":0}},{"line":102,"address":[23704044,23704126],"length":1,"stats":{"Line":0}},{"line":103,"address":[23771973,23772239,23772438,23775438,23772112,23772143],"length":1,"stats":{"Line":0}},{"line":105,"address":[23704564,23704397],"length":1,"stats":{"Line":0}},{"line":108,"address":[11636585],"length":1,"stats":{"Line":0}},{"line":110,"address":[23910968,23911831,23910759],"length":1,"stats":{"Line":0}},{"line":111,"address":[18071295,17953547,17953486,17954056,18071161],"length":1,"stats":{"Line":0}},{"line":112,"address":[11650386],"length":1,"stats":{"Line":0}},{"line":113,"address":[23779888,23779833,23779757],"length":1,"stats":{"Line":0}},{"line":121,"address":[14388112,14388449],"length":1,"stats":{"Line":0}},{"line":123,"address":[14388147],"length":1,"stats":{"Line":0}},{"line":124,"address":[23707723,23707801],"length":1,"stats":{"Line":0}},{"line":125,"address":[14388314,14388247],"length":1,"stats":{"Line":0}},{"line":126,"address":[23813816],"length":1,"stats":{"Line":0}},{"line":133,"address":[24030383,24030432,24030859,24030467,24030632,24031120,24030655,24030549],"length":1,"stats":{"Line":0}},{"line":134,"address":[11844679],"length":1,"stats":{"Line":0}},{"line":137,"address":[23825132,23825026,23825330,23824863,23824947,23825109,23824912,23825588],"length":1,"stats":{"Line":0}},{"line":138,"address":[23832208,23832029,23832338],"length":1,"stats":{"Line":0}},{"line":141,"address":[23935487,23935536,23935571,23935790,23935837,23935658,23936017,23936301],"length":1,"stats":{"Line":0}},{"line":142,"address":[11982932],"length":1,"stats":{"Line":0}},{"line":145,"address":[23936498,23936419,23936604,23936335,23937060,23936802,23936581,23936384],"length":1,"stats":{"Line":0}},{"line":146,"address":[24032957,24033136,24033266],"length":1,"stats":{"Line":0}},{"line":149,"address":[23895104,23895222,23895054,23895126,23895256,23895378,23895553],"length":1,"stats":{"Line":0}},{"line":150,"address":[11887142],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","topic_service.rs"],"content":"use super::offline_service::{OfflineServiceTrait, SaveOfflineActionParams};\nuse super::p2p_service::P2PServiceTrait;\nuse crate::application::ports::repositories::{\n    PendingTopicRepository, TopicMetricsRepository, TopicRepository,\n};\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::offline::OfflineActionRecord;\nuse crate::domain::entities::{\n    PendingTopic, PendingTopicStatus, Topic, TopicMetricsRecord, TopicVisibility,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload,\n};\nuse crate::shared::{ValidationFailureKind, error::AppError};\nuse chrono::Utc;\nuse serde_json::json;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse uuid::Uuid;\n\n#[derive(Debug, Clone)]\npub struct TopicTrendingEntry {\n    pub topic: Topic,\n    pub trending_score: f64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TrendingDataSource {\n    Metrics,\n    Legacy,\n}\n\npub struct TrendingTopicsResult {\n    pub generated_at: i64,\n    pub entries: Vec<TopicTrendingEntry>,\n    pub data_source: TrendingDataSource,\n}\n\npub struct EnqueuedTopicCreation {\n    pub pending_topic: PendingTopic,\n    pub offline_action: OfflineActionRecord,\n}\n\npub struct TopicService {\n    repository: Arc<dyn TopicRepository>,\n    pending_repository: Arc<dyn PendingTopicRepository>,\n    metrics_repository: Arc<dyn TopicMetricsRepository>,\n    metrics_enabled: bool,\n    p2p: Arc<dyn P2PServiceTrait>,\n    offline_service: Arc<dyn OfflineServiceTrait>,\n}\n\nimpl TopicService {\n    pub fn new(\n        repository: Arc<dyn TopicRepository>,\n        pending_repository: Arc<dyn PendingTopicRepository>,\n        metrics_repository: Arc<dyn TopicMetricsRepository>,\n        metrics_enabled: bool,\n        p2p: Arc<dyn P2PServiceTrait>,\n        offline_service: Arc<dyn OfflineServiceTrait>,\n    ) -> Self {\n        Self {\n            repository,\n            pending_repository,\n            metrics_repository,\n            metrics_enabled,\n            p2p,\n            offline_service,\n        }\n    }\n\n    pub async fn create_topic(\n        &self,\n        name: String,\n        description: Option<String>,\n        visibility: TopicVisibility,\n        creator_pubkey: &str,\n    ) -> Result<Topic, AppError> {\n        let mut topic = Topic::new(name, description);\n        topic.visibility = visibility;\n        self.repository.create_topic(&topic).await?;\n        self.join_topic(&topic.id, creator_pubkey).await?;\n\n        if let Some(mut stored) = self.get_topic(&topic.id).await? {\n            stored.is_joined = true;\n            return Ok(stored);\n        }\n\n        topic.is_joined = true;\n        topic.member_count = topic.member_count.saturating_add(1);\n        Ok(topic)\n    }\n\n    pub async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        self.repository.get_topic(id).await\n    }\n\n    pub async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_all_topics().await\n    }\n\n    pub async fn list_topics_with_membership(\n        &self,\n        user_pubkey: Option<&str>,\n    ) -> Result<Vec<Topic>, AppError> {\n        let mut topics = self.repository.get_all_topics().await?;\n\n        if let Some(pubkey) = user_pubkey {\n            let joined = self.repository.get_joined_topics(pubkey).await?;\n            let joined_ids: HashSet<String> = joined.into_iter().map(|topic| topic.id).collect();\n\n            for topic in topics.iter_mut() {\n                if joined_ids.contains(&topic.id) {\n                    topic.is_joined = true;\n                }\n            }\n        }\n\n        Ok(topics)\n    }\n\n    pub async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_joined_topics(user_pubkey).await\n    }\n\n    pub async fn join_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.join_topic(id, user_pubkey).await?;\n        self.p2p.join_topic(id, Vec::new()).await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.leave_topic(id, user_pubkey).await?;\n        self.p2p.leave_topic(id).await?;\n        Ok(())\n    }\n\n    pub async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        self.repository.update_topic(topic).await\n    }\n\n    pub async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        // Prevent deletion of public topic\n        if id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"Cannot delete public topic\".into());\n        }\n\n        self.p2p.leave_topic(id).await?;\n        self.repository.delete_topic(id).await\n    }\n\n    pub async fn get_topic_stats(&self, id: &str) -> Result<(u32, u32), AppError> {\n        if let Some(topic) = self.repository.get_topic(id).await? {\n            Ok((topic.member_count, topic.post_count))\n        } else {\n            Ok((0, 0))\n        }\n    }\n\n    pub async fn ensure_public_topic(&self) -> Result<(), AppError> {\n        if self\n            .repository\n            .get_topic(DEFAULT_PUBLIC_TOPIC_ID)\n            .await?\n            .is_none()\n        {\n            let public_topic = Topic::public_topic();\n            self.repository.create_topic(&public_topic).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn enqueue_topic_creation(\n        &self,\n        user_pubkey: &str,\n        name: String,\n        description: Option<String>,\n        visibility: TopicVisibility,\n    ) -> Result<EnqueuedTopicCreation, AppError> {\n        let public_key = PublicKey::from_hex_str(user_pubkey).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid pubkey: {err}\"),\n            )\n        })?;\n\n        let pending_id = Uuid::new_v4().to_string();\n        let payload = OfflinePayload::new(json!({\n            \"pendingId\": pending_id,\n            \"name\": name,\n            \"description\": description,\n            \"visibility\": visibility.as_str(),\n        }))\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let action_type = OfflineActionType::new(\"topic_create\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let entity_type = EntityType::new(\"topic\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let entity_id = EntityId::new(pending_id.clone())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n\n        let saved = self\n            .offline_service\n            .save_action(SaveOfflineActionParams {\n                user_pubkey: public_key.clone(),\n                action_type,\n                entity_type,\n                entity_id,\n                payload,\n            })\n            .await?;\n\n        let now = Utc::now();\n        let pending_topic = PendingTopic::new(\n            pending_id,\n            public_key.as_hex().to_string(),\n            name,\n            description,\n            PendingTopicStatus::Queued,\n            saved.local_id.to_string(),\n            None,\n            None,\n            now,\n            now,\n        );\n\n        self.pending_repository\n            .insert_pending_topic(&pending_topic)\n            .await?;\n\n        Ok(EnqueuedTopicCreation {\n            pending_topic,\n            offline_action: saved.action,\n        })\n    }\n\n    pub async fn list_pending_topics(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<PendingTopic>, AppError> {\n        self.pending_repository\n            .list_pending_topics(user_pubkey)\n            .await\n    }\n\n    pub async fn get_pending_topic(\n        &self,\n        pending_id: &str,\n    ) -> Result<Option<PendingTopic>, AppError> {\n        self.pending_repository.get_pending_topic(pending_id).await\n    }\n\n    pub async fn mark_pending_topic_synced(\n        &self,\n        pending_id: &str,\n        topic_id: &str,\n    ) -> Result<(), AppError> {\n        self.pending_repository\n            .update_pending_topic_status(\n                pending_id,\n                PendingTopicStatus::Synced,\n                Some(topic_id),\n                None,\n            )\n            .await\n    }\n\n    pub async fn mark_pending_topic_failed(\n        &self,\n        pending_id: &str,\n        error_message: Option<String>,\n    ) -> Result<(), AppError> {\n        self.pending_repository\n            .update_pending_topic_status(\n                pending_id,\n                PendingTopicStatus::Failed,\n                None,\n                error_message.as_deref(),\n            )\n            .await\n    }\n\n    pub async fn list_trending_topics(\n        &self,\n        limit: usize,\n    ) -> Result<TrendingTopicsResult, AppError> {\n        if limit == 0 {\n            return Ok(TrendingTopicsResult {\n                generated_at: Utc::now().timestamp_millis(),\n                entries: Vec::new(),\n                data_source: TrendingDataSource::Legacy,\n            });\n        }\n\n        if self.metrics_enabled {\n            if let Some(snapshot) = self.metrics_repository.list_recent_metrics(limit).await? {\n                let entries = self\n                    .build_entries_from_metrics(&snapshot.metrics, limit)\n                    .await?;\n\n                if !entries.is_empty() || !snapshot.metrics.is_empty() {\n                    return Ok(TrendingTopicsResult {\n                        generated_at: snapshot.window_end,\n                        entries,\n                        data_source: TrendingDataSource::Metrics,\n                    });\n                }\n            }\n        }\n\n        let mut entries: Vec<TopicTrendingEntry> = self\n            .repository\n            .get_all_topics()\n            .await?\n            .into_iter()\n            .map(|topic| TopicTrendingEntry {\n                trending_score: Self::calculate_trending_score(&topic),\n                topic,\n            })\n            .collect();\n\n        entries.sort_by(|a, b| {\n            b.trending_score\n                .partial_cmp(&a.trending_score)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| b.topic.updated_at.cmp(&a.topic.updated_at))\n                .then_with(|| a.topic.name.cmp(&b.topic.name))\n        });\n\n        entries.truncate(limit);\n        Ok(TrendingTopicsResult {\n            generated_at: Utc::now().timestamp_millis(),\n            entries,\n            data_source: TrendingDataSource::Legacy,\n        })\n    }\n\n    pub async fn latest_metrics_generated_at(&self) -> Result<Option<i64>, AppError> {\n        if !self.metrics_enabled {\n            return Ok(None);\n        }\n        self.metrics_repository.latest_window_end().await\n    }\n\n    async fn build_entries_from_metrics(\n        &self,\n        metrics: &[TopicMetricsRecord],\n        limit: usize,\n    ) -> Result<Vec<TopicTrendingEntry>, AppError> {\n        if limit == 0 {\n            return Ok(Vec::new());\n        }\n        let mut entries = Vec::new();\n        for record in metrics {\n            if entries.len() >= limit {\n                break;\n            }\n            if let Some(topic) = self.repository.get_topic(&record.topic_id).await? {\n                entries.push(TopicTrendingEntry {\n                    trending_score: record.score_24h,\n                    topic,\n                });\n            }\n        }\n        Ok(entries)\n    }\n\n    fn calculate_trending_score(topic: &Topic) -> f64 {\n        if topic.member_count == 0 && topic.post_count == 0 {\n            0.0\n        } else {\n            (topic.post_count as f64 * 0.6) + (topic.member_count as f64 * 0.4)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::repositories::{\n        PendingTopicRepository as PortPendingTopicRepository,\n        TopicMetricsRepository as PortTopicMetricsRepository,\n        TopicRepository as PortTopicRepository,\n    };\n    use crate::application::services::offline_service::{\n        OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n    };\n    use crate::application::services::p2p_service::{P2PServiceTrait, P2PStatus};\n    use crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\n    use crate::domain::entities::offline::{\n        CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateDraft,\n        SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusUpdate,\n    };\n    use crate::domain::entities::{\n        MetricsWindow, PendingTopic, TopicActivityRow, TopicMetricsSnapshot, TopicMetricsUpsert,\n        TopicVisibility,\n    };\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\n    use crate::shared::config::BootstrapSource;\n    use async_trait::async_trait;\n    use mockall::{mock, predicate::*};\n\n    mock! {\n        pub TopicRepo {}\n\n        #[async_trait]\n        impl PortTopicRepository for TopicRepo {\n            async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n            async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n            async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n            async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n            async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn update_topic_stats(\n                &self,\n                topic_id: &str,\n                member_count: u32,\n                post_count: u32,\n            ) -> Result<(), AppError>;\n        }\n    }\n\n    mock! {\n        pub P2P {}\n\n        #[async_trait]\n        impl P2PServiceTrait for P2P {\n            async fn initialize(&self) -> Result<(), AppError>;\n            async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError>;\n            async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError>;\n            async fn get_status(&self) -> Result<P2PStatus, AppError>;\n            async fn get_node_addresses(&self) -> Result<Vec<String>, AppError>;\n            fn generate_topic_id(&self, topic_name: &str) -> String;\n            async fn apply_bootstrap_nodes(\n                &self,\n                nodes: Vec<String>,\n                source: BootstrapSource,\n            ) -> Result<(), AppError>;\n        }\n    }\n\n    mock! {\n        pub TopicMetricsRepo {}\n\n        #[async_trait]\n        impl PortTopicMetricsRepository for TopicMetricsRepo {\n            async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError>;\n            async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError>;\n            async fn collect_activity(\n                &self,\n                window: MetricsWindow,\n            ) -> Result<Vec<TopicActivityRow>, AppError>;\n            async fn latest_window_end(&self) -> Result<Option<i64>, AppError>;\n            async fn list_recent_metrics(\n                &self,\n                limit: usize,\n            ) -> Result<Option<TopicMetricsSnapshot>, AppError>;\n        }\n    }\n\n    #[derive(Clone)]\n    struct NoopPendingRepo;\n\n    #[async_trait]\n    impl PortPendingTopicRepository for NoopPendingRepo {\n        async fn insert_pending_topic(&self, _topic: &PendingTopic) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn list_pending_topics(\n            &self,\n            _user_pubkey: &str,\n        ) -> Result<Vec<PendingTopic>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn get_pending_topic(\n            &self,\n            _pending_id: &str,\n        ) -> Result<Option<PendingTopic>, AppError> {\n            Ok(None)\n        }\n\n        async fn update_pending_topic_status(\n            &self,\n            _pending_id: &str,\n            _status: PendingTopicStatus,\n            _synced_topic_id: Option<&str>,\n            _error_message: Option<&str>,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn delete_pending_topic(&self, _pending_id: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n    }\n\n    #[derive(Clone)]\n    struct StubOfflineService;\n\n    #[async_trait]\n    impl OfflineServiceTrait for StubOfflineService {\n        async fn save_action(\n            &self,\n            _params: SaveOfflineActionParams,\n        ) -> Result<SavedOfflineAction, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn list_actions(\n            &self,\n            _query: OfflineActionsQuery,\n        ) -> Result<Vec<OfflineActionRecord>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn sync_actions(&self, _user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn enqueue_sync(&self, _draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn recent_sync_queue_items(\n            &self,\n            _limit: Option<u32>,\n        ) -> Result<Vec<SyncQueueItem>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn upsert_cache_metadata(\n            &self,\n            _update: CacheMetadataUpdate,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn save_optimistic_update(\n            &self,\n            _draft: OptimisticUpdateDraft,\n        ) -> Result<OptimisticUpdateId, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn confirm_optimistic_update(\n            &self,\n            _update_id: OptimisticUpdateId,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn rollback_optimistic_update(\n            &self,\n            _update_id: OptimisticUpdateId,\n        ) -> Result<Option<OfflinePayload>, AppError> {\n            Ok(None)\n        }\n\n        async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n            Ok(0)\n        }\n\n        async fn update_sync_status(&self, _update: SyncStatusUpdate) -> Result<(), AppError> {\n            Ok(())\n        }\n    }\n\n    fn build_topic_service(\n        repo: Arc<dyn PortTopicRepository>,\n        metrics_repo: Arc<dyn PortTopicMetricsRepository>,\n        p2p: Arc<dyn P2PServiceTrait>,\n        metrics_enabled: bool,\n    ) -> TopicService {\n        let pending_repo: Arc<dyn PortPendingTopicRepository> = Arc::new(NoopPendingRepo);\n        let offline_service: Arc<dyn OfflineServiceTrait> = Arc::new(StubOfflineService);\n        TopicService::new(\n            repo,\n            pending_repo,\n            metrics_repo,\n            metrics_enabled,\n            p2p,\n            offline_service,\n        )\n    }\n\n    fn topic_with_counts(id: &str, name: &str, members: u32, posts: u32) -> Topic {\n        let mut topic = Topic::new(name.to_string(), Some(format!(\"{name} desc\")));\n        topic.id = id.to_string();\n        topic.member_count = members;\n        topic.post_count = posts;\n        topic\n    }\n\n    #[tokio::test]\n    async fn test_join_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_join_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut p2p = MockP2P::new();\n        p2p.expect_join_topic()\n            .with(eq(\"tech\"), eq(Vec::<String>::new()))\n            .times(1)\n            .returning(|_, _| Ok(()));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service.join_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_leave_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_leave_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut p2p = MockP2P::new();\n        p2p.expect_leave_topic()\n            .with(eq(\"tech\"))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service.leave_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn list_trending_topics_orders_by_score_without_metrics() {\n        let mut repo = MockTopicRepo::new();\n        let topic_alpha = topic_with_counts(\"alpha\", \"Alpha\", 5, 20);\n        let topic_beta = topic_with_counts(\"beta\", \"Beta\", 15, 10);\n        let topic_gamma = topic_with_counts(\"gamma\", \"Gamma\", 2, 5);\n\n        repo.expect_get_all_topics().times(1).returning(move || {\n            Ok(vec![\n                topic_alpha.clone(),\n                topic_beta.clone(),\n                topic_gamma.clone(),\n            ])\n        });\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service\n            .list_trending_topics(3)\n            .await\n            .expect(\"trending topics\");\n\n        assert_eq!(result.entries.len(), 3);\n        assert_eq!(result.entries[0].topic.id, \"alpha\");\n        assert!(result.entries[0].trending_score >= result.entries[1].trending_score);\n        assert_eq!(result.data_source, TrendingDataSource::Legacy);\n    }\n\n    #[tokio::test]\n    async fn list_trending_topics_prefers_metrics_snapshot() {\n        let mut repo = MockTopicRepo::new();\n        let topic_a = topic_with_counts(\"alpha\", \"Alpha\", 5, 10);\n        let topic_b = topic_with_counts(\"beta\", \"Beta\", 3, 15);\n        repo.expect_get_topic()\n            .with(eq(\"alpha\"))\n            .return_once(move |_| Ok(Some(topic_a.clone())));\n        repo.expect_get_topic()\n            .with(eq(\"beta\"))\n            .return_once(move |_| Ok(Some(topic_b.clone())));\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n\n        let mut metrics_repo = MockTopicMetricsRepo::new();\n        metrics_repo\n            .expect_list_recent_metrics()\n            .with(eq(2))\n            .return_once(|_| {\n                Ok(Some(TopicMetricsSnapshot {\n                    window_start: 100,\n                    window_end: 200,\n                    metrics: vec![\n                        TopicMetricsRecord {\n                            topic_id: \"alpha\".into(),\n                            window_start: 100,\n                            window_end: 200,\n                            posts_24h: 10,\n                            posts_6h: 4,\n                            unique_authors: 3,\n                            boosts: 1,\n                            replies: 0,\n                            bookmarks: 0,\n                            participant_delta: 1,\n                            score_24h: 42.0,\n                            score_6h: 21.0,\n                            updated_at: 200,\n                        },\n                        TopicMetricsRecord {\n                            topic_id: \"beta\".into(),\n                            window_start: 100,\n                            window_end: 200,\n                            posts_24h: 5,\n                            posts_6h: 2,\n                            unique_authors: 2,\n                            boosts: 0,\n                            replies: 0,\n                            bookmarks: 0,\n                            participant_delta: 0,\n                            score_24h: 30.0,\n                            score_6h: 15.0,\n                            updated_at: 200,\n                        },\n                    ],\n                }))\n            });\n        metrics_repo\n            .expect_latest_window_end()\n            .returning(|| Ok(Some(200)));\n\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> = Arc::new(metrics_repo);\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, true);\n\n        let result = service\n            .list_trending_topics(2)\n            .await\n            .expect(\"trending topics\");\n\n        assert_eq!(result.generated_at, 200);\n        assert_eq!(result.data_source, TrendingDataSource::Metrics);\n        assert_eq!(result.entries.len(), 2);\n        assert_eq!(result.entries[0].topic.id, \"alpha\");\n        assert_eq!(result.entries[0].trending_score, 42.0);\n    }\n\n    #[tokio::test]\n    async fn list_topics_with_membership_marks_joined_flags() {\n        let mut repo = MockTopicRepo::new();\n        let public = topic_with_counts(DEFAULT_PUBLIC_TOPIC_ID, \"Public\", 0, 0);\n        let private = topic_with_counts(\"private\", \"Private\", 0, 0);\n\n        let public_for_all = public.clone();\n        let private_for_all = private.clone();\n        repo.expect_get_all_topics()\n            .times(1)\n            .returning(move || Ok(vec![public_for_all.clone(), private_for_all.clone()]));\n        let public_for_joined = public.clone();\n        repo.expect_get_joined_topics()\n            .with(eq(\"pubkey1\"))\n            .times(1)\n            .returning(move |_| Ok(vec![public_for_joined.clone()]));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let topics = service\n            .list_topics_with_membership(Some(\"pubkey1\"))\n            .await\n            .expect(\"topics with membership\");\n\n        assert_eq!(topics.len(), 2);\n        assert!(\n            topics\n                .iter()\n                .any(|topic| topic.id == DEFAULT_PUBLIC_TOPIC_ID && topic.is_joined)\n        );\n        assert!(\n            topics\n                .iter()\n                .any(|topic| topic.id == \"private\" && !topic.is_joined)\n        );\n    }\n\n    #[tokio::test]\n    async fn test_get_joined_topics_passes_user_pubkey() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_get_joined_topics()\n            .with(eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_| Ok(vec![]));\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n        let result = service.get_joined_topics(\"pubkey1\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().len(), 0);\n    }\n\n    #[tokio::test]\n    async fn latest_metrics_generated_at_handles_disabled_metrics() {\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(MockTopicRepo::new());\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        assert!(\n            service\n                .latest_metrics_generated_at()\n                .await\n                .unwrap()\n                .is_none()\n        );\n    }\n\n    #[tokio::test]\n    async fn latest_metrics_generated_at_reads_from_repo() {\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(MockTopicRepo::new());\n        let mut metrics_repo = MockTopicMetricsRepo::new();\n        metrics_repo\n            .expect_latest_window_end()\n            .return_once(|| Ok(Some(999)));\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> = Arc::new(metrics_repo);\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, true);\n\n        assert_eq!(\n            service.latest_metrics_generated_at().await.unwrap(),\n            Some(999)\n        );\n    }\n\n    #[tokio::test]\n    async fn create_topic_returns_joined_topic_with_repo_state() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_create_topic().times(1).returning(|_| Ok(()));\n        repo.expect_join_topic()\n            .times(1)\n            .withf(|topic_id, user| !topic_id.is_empty() && user == \"creator\")\n            .return_once(|_, _| Ok(()));\n        repo.expect_get_topic().times(1).returning(|id| {\n            let mut topic = Topic::new(\"My Topic\".to_string(), Some(\"desc\".to_string()));\n            topic.id = id.to_string();\n            topic.member_count = 1;\n            topic.visibility = TopicVisibility::Public;\n            Ok(Some(topic))\n        });\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let mut p2p = MockP2P::new();\n        p2p.expect_join_topic()\n            .times(1)\n            .withf(|topic_id, peers| !topic_id.is_empty() && peers.is_empty())\n            .return_once(|_, _| Ok(()));\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let topic = service\n            .create_topic(\n                \"My Topic\".to_string(),\n                Some(\"desc\".to_string()),\n                TopicVisibility::Public,\n                \"creator\",\n            )\n            .await\n            .expect(\"topic created\");\n\n        assert!(topic.is_joined);\n        assert!(topic.member_count >= 1);\n    }\n}\n","traces":[{"line":55,"address":[20485408],"length":1,"stats":{"Line":1}},{"line":73,"address":[24715088],"length":1,"stats":{"Line":1}},{"line":80,"address":[24717125],"length":1,"stats":{"Line":1}},{"line":81,"address":[24812093],"length":1,"stats":{"Line":1}},{"line":82,"address":[24718123,24717326,24717197,24717417,24717573,24717897],"length":1,"stats":{"Line":2}},{"line":83,"address":[19281877],"length":1,"stats":{"Line":2}},{"line":85,"address":[18853255,18854712,18854462,18854597,18855463],"length":1,"stats":{"Line":2}},{"line":86,"address":[24813971],"length":1,"stats":{"Line":1}},{"line":87,"address":[24600907],"length":1,"stats":{"Line":1}},{"line":90,"address":[18855287],"length":1,"stats":{"Line":0}},{"line":91,"address":[24607782],"length":1,"stats":{"Line":0}},{"line":92,"address":[20488097],"length":1,"stats":{"Line":0}},{"line":95,"address":[24814240,24814288,24814449,24814918,24814489,24814323,24814258,24814649],"length":1,"stats":{"Line":4}},{"line":96,"address":[24675948,24675996,24676073,24676201],"length":1,"stats":{"Line":2}},{"line":99,"address":[24715151,24714735,24714560,24714886,24714576,24714611,24714698,24714568],"length":1,"stats":{"Line":0}},{"line":100,"address":[18856325,18856389,18856277,18856518],"length":1,"stats":{"Line":0}},{"line":103,"address":[24683984],"length":1,"stats":{"Line":1}},{"line":107,"address":[24609780,24610184,24609452,24609521,24609618,24610643],"length":1,"stats":{"Line":2}},{"line":109,"address":[24816557,24817887,24816434],"length":1,"stats":{"Line":3}},{"line":110,"address":[18858228,18857062,18857831,18858638,18858060],"length":1,"stats":{"Line":2}},{"line":111,"address":[24678859,24679504,24679532,24679052],"length":1,"stats":{"Line":4}},{"line":113,"address":[24611548,24611298,24611385],"length":1,"stats":{"Line":3}},{"line":114,"address":[24723072,24723132,24723112],"length":1,"stats":{"Line":3}},{"line":115,"address":[24618597],"length":1,"stats":{"Line":1}},{"line":120,"address":[24720209],"length":1,"stats":{"Line":1}},{"line":123,"address":[20492147,20492082,20492064,20492718,20492112,20492269,20492309,20492462],"length":1,"stats":{"Line":4}},{"line":124,"address":[24718108,24718314,24718060,24718185],"length":1,"stats":{"Line":2}},{"line":127,"address":[24612640,24612704,24612751,24612939,24613880,24612668,24613003,24613207],"length":1,"stats":{"Line":4}},{"line":128,"address":[24725328,24724586,24724743,24724404,24724473,24725047],"length":1,"stats":{"Line":2}},{"line":129,"address":[24723504,24723362,24722846,24723745,24724025],"length":1,"stats":{"Line":2}},{"line":130,"address":[24725660],"length":1,"stats":{"Line":1}},{"line":133,"address":[24689020,24689346,24690141,24689103,24689056,24689282,24688992,24689535],"length":1,"stats":{"Line":4}},{"line":134,"address":[24720600,24721269,24720430,24721055,24720496,24720751],"length":1,"stats":{"Line":2}},{"line":135,"address":[10864817],"length":1,"stats":{"Line":2}},{"line":136,"address":[18863201],"length":1,"stats":{"Line":1}},{"line":139,"address":[24683971,24683667,24683816,24683613,24683632,24683776,24684235,24683600],"length":1,"stats":{"Line":0}},{"line":140,"address":[11625700],"length":1,"stats":{"Line":0}},{"line":143,"address":[24624065,24623718,24623519,24623442,24624616,24623424,24623654,24623472],"length":1,"stats":{"Line":0}},{"line":145,"address":[24722564,24722713],"length":1,"stats":{"Line":0}},{"line":146,"address":[24684817,24684644],"length":1,"stats":{"Line":0}},{"line":149,"address":[11619969],"length":1,"stats":{"Line":0}},{"line":150,"address":[24610732,24610604,24610865,24609945],"length":1,"stats":{"Line":0}},{"line":153,"address":[24692739,24692656,24692905,24692674,24692704,24693714,24693066,24692865],"length":1,"stats":{"Line":0}},{"line":154,"address":[24625338,24625084,24625950,24625209,24625132],"length":1,"stats":{"Line":0}},{"line":155,"address":[24686641],"length":1,"stats":{"Line":0}},{"line":157,"address":[24612160],"length":1,"stats":{"Line":0}},{"line":161,"address":[24693791,24693728,24694155,24693971,24693907,24693736,24693744,24694972],"length":1,"stats":{"Line":0}},{"line":162,"address":[18866652,18866818,18867114,18867471,18866895,18867765,18867178,18867386],"length":1,"stats":{"Line":0}},{"line":165,"address":[24694332,24693937,24694127,24694554,24694187,24694080],"length":1,"stats":{"Line":0}},{"line":168,"address":[24626984],"length":1,"stats":{"Line":0}},{"line":169,"address":[11657749],"length":1,"stats":{"Line":0}},{"line":171,"address":[24826283],"length":1,"stats":{"Line":0}},{"line":174,"address":[24726624],"length":1,"stats":{"Line":0}},{"line":181,"address":[24614540,24622491,24614890,24614671,24619295,24622272],"length":1,"stats":{"Line":0}},{"line":182,"address":[24697039],"length":1,"stats":{"Line":0}},{"line":183,"address":[24696885],"length":1,"stats":{"Line":0}},{"line":184,"address":[24740645,24740586],"length":1,"stats":{"Line":0}},{"line":188,"address":[24614820,24614990],"length":1,"stats":{"Line":0}},{"line":189,"address":[24632892,24629790,24630187,24628849,24630506,24630233,24630323,24629863,24632957,24628807],"length":1,"stats":{"Line":0}},{"line":193,"address":[24732628,24732727],"length":1,"stats":{"Line":0}},{"line":195,"address":[24829537,24828126,24829770,24829417,24832247],"length":1,"stats":{"Line":0}},{"line":196,"address":[24623602,24625854,24624035,24623852,24623762,24623716,24623451],"length":1,"stats":{"Line":0}},{"line":197,"address":[18871274,18871507,18871157,18871087,18873414],"length":1,"stats":{"Line":0}},{"line":198,"address":[20504013,20505408,20503795,20503632,20503943,20503885,20504199],"length":1,"stats":{"Line":0}},{"line":199,"address":[24617711,24619048,24617288,24617475,24617358],"length":1,"stats":{"Line":0}},{"line":200,"address":[24734721,24734919,24734471,24734317,24734585,24734631,24735577],"length":1,"stats":{"Line":0}},{"line":201,"address":[24625761,24625015,24624650,24624580,24624767],"length":1,"stats":{"Line":0}},{"line":203,"address":[24618878,24619569,24618787,24619787,24618185,24620914,24619495],"length":1,"stats":{"Line":0}},{"line":205,"address":[24632387],"length":1,"stats":{"Line":0}},{"line":206,"address":[24625180],"length":1,"stats":{"Line":0}},{"line":207,"address":[24731143],"length":1,"stats":{"Line":0}},{"line":208,"address":[24700006],"length":1,"stats":{"Line":0}},{"line":209,"address":[24700053],"length":1,"stats":{"Line":0}},{"line":210,"address":[24693172],"length":1,"stats":{"Line":0}},{"line":212,"address":[24737643,24737123,24737188,24737785,24732877,24738027],"length":1,"stats":{"Line":0}},{"line":214,"address":[20506089],"length":1,"stats":{"Line":0}},{"line":216,"address":[24832947],"length":1,"stats":{"Line":0}},{"line":217,"address":[24732640,24732744],"length":1,"stats":{"Line":0}},{"line":218,"address":[24736707],"length":1,"stats":{"Line":0}},{"line":219,"address":[24626906],"length":1,"stats":{"Line":0}},{"line":220,"address":[24833249],"length":1,"stats":{"Line":0}},{"line":221,"address":[24833257],"length":1,"stats":{"Line":0}},{"line":222,"address":[24738558],"length":1,"stats":{"Line":0}},{"line":223,"address":[24694870],"length":1,"stats":{"Line":0}},{"line":228,"address":[24695739,24695619,24695131,24695315,24695256,24696046],"length":1,"stats":{"Line":0}},{"line":229,"address":[24634409],"length":1,"stats":{"Line":0}},{"line":230,"address":[11665369],"length":1,"stats":{"Line":0}},{"line":232,"address":[18875619],"length":1,"stats":{"Line":0}},{"line":233,"address":[24634963],"length":1,"stats":{"Line":0}},{"line":234,"address":[24739548],"length":1,"stats":{"Line":0}},{"line":238,"address":[20508768],"length":1,"stats":{"Line":0}},{"line":242,"address":[24629500,24629854,24629688,24629629],"length":1,"stats":{"Line":0}},{"line":244,"address":[11622836],"length":1,"stats":{"Line":0}},{"line":247,"address":[24741520],"length":1,"stats":{"Line":0}},{"line":251,"address":[11643844],"length":1,"stats":{"Line":0}},{"line":254,"address":[24736640],"length":1,"stats":{"Line":0}},{"line":259,"address":[24637961,24638248,24638429,24638139],"length":1,"stats":{"Line":0}},{"line":262,"address":[24705863],"length":1,"stats":{"Line":0}},{"line":263,"address":[24737055],"length":1,"stats":{"Line":0}},{"line":264,"address":[24631151],"length":1,"stats":{"Line":0}},{"line":266,"address":[10958260],"length":1,"stats":{"Line":0}},{"line":269,"address":[24699424],"length":1,"stats":{"Line":0}},{"line":274,"address":[24742034,24742215,24741941,24741725],"length":1,"stats":{"Line":0}},{"line":277,"address":[24743506],"length":1,"stats":{"Line":0}},{"line":278,"address":[24632010],"length":1,"stats":{"Line":0}},{"line":279,"address":[20511394],"length":1,"stats":{"Line":0}},{"line":281,"address":[19342878],"length":1,"stats":{"Line":0}},{"line":284,"address":[24744112],"length":1,"stats":{"Line":1}},{"line":288,"address":[24742652],"length":1,"stats":{"Line":1}},{"line":289,"address":[24738973],"length":1,"stats":{"Line":0}},{"line":290,"address":[24744495,24744402],"length":1,"stats":{"Line":0}},{"line":291,"address":[24742874],"length":1,"stats":{"Line":0}},{"line":292,"address":[24640021],"length":1,"stats":{"Line":0}},{"line":296,"address":[24632917],"length":1,"stats":{"Line":1}},{"line":297,"address":[24700651,24702047,24701071,24701295],"length":1,"stats":{"Line":1}},{"line":298,"address":[24740278,24740101,24740055,24740392,24739912,24741091,24740582],"length":1,"stats":{"Line":5}},{"line":299,"address":[24740043,24739929],"length":1,"stats":{"Line":2}},{"line":300,"address":[24641382,24639840,24641187,24641229,24641590,24641130],"length":1,"stats":{"Line":3}},{"line":302,"address":[24641723,24641917,24641564],"length":1,"stats":{"Line":2}},{"line":303,"address":[20514090],"length":1,"stats":{"Line":1}},{"line":304,"address":[24740677],"length":1,"stats":{"Line":1}},{"line":305,"address":[24634769],"length":1,"stats":{"Line":1}},{"line":306,"address":[24702625],"length":1,"stats":{"Line":1}},{"line":312,"address":[24626437,24628343,24628284,24628497,24628611,24628770,24629209],"length":1,"stats":{"Line":5}},{"line":315,"address":[24635176,24635329,24635143,24635506,24635096,24632885],"length":1,"stats":{"Line":3}},{"line":317,"address":[24842402,24842288,24842449],"length":1,"stats":{"Line":2}},{"line":318,"address":[20515236],"length":1,"stats":{"Line":1}},{"line":319,"address":[24745950],"length":1,"stats":{"Line":1}},{"line":323,"address":[20514929,20515376,20514862],"length":1,"stats":{"Line":3}},{"line":324,"address":[18883752,18883776,18883766],"length":1,"stats":{"Line":3}},{"line":325,"address":[24704047],"length":1,"stats":{"Line":1}},{"line":326,"address":[24636251],"length":1,"stats":{"Line":1}},{"line":327,"address":[20515518,20515504],"length":1,"stats":{"Line":0}},{"line":328,"address":[24643374,24643360],"length":1,"stats":{"Line":0}},{"line":331,"address":[24635739],"length":1,"stats":{"Line":1}},{"line":332,"address":[24745730],"length":1,"stats":{"Line":1}},{"line":333,"address":[24703578],"length":1,"stats":{"Line":1}},{"line":334,"address":[18883338],"length":1,"stats":{"Line":1}},{"line":335,"address":[20515059],"length":1,"stats":{"Line":1}},{"line":339,"address":[20515608,20515651,20515616,20516289,20516028,20515730,20515600,20515886],"length":1,"stats":{"Line":4}},{"line":340,"address":[24742474],"length":1,"stats":{"Line":1}},{"line":341,"address":[24711338],"length":1,"stats":{"Line":1}},{"line":343,"address":[19351092],"length":1,"stats":{"Line":2}},{"line":346,"address":[24747024],"length":1,"stats":{"Line":1}},{"line":351,"address":[24747276],"length":1,"stats":{"Line":1}},{"line":352,"address":[24747336,24747428],"length":1,"stats":{"Line":0}},{"line":354,"address":[24705307],"length":1,"stats":{"Line":1}},{"line":355,"address":[24749202,24750049,24749293,24750191],"length":1,"stats":{"Line":4}},{"line":356,"address":[24713443],"length":1,"stats":{"Line":1}},{"line":359,"address":[11684276],"length":1,"stats":{"Line":2}},{"line":360,"address":[24645438,24645508,24645387],"length":1,"stats":{"Line":3}},{"line":361,"address":[24713167],"length":1,"stats":{"Line":1}},{"line":366,"address":[24706390],"length":1,"stats":{"Line":1}},{"line":369,"address":[24645952],"length":1,"stats":{"Line":1}},{"line":370,"address":[24713722,24713806],"length":1,"stats":{"Line":2}},{"line":371,"address":[20518144],"length":1,"stats":{"Line":0}},{"line":373,"address":[24645990],"length":1,"stats":{"Line":1}}],"covered":72,"coverable":157},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","user_search_service.rs"],"content":"use crate::application::ports::repositories::UserRepository;\r\nuse crate::domain::entities::User;\r\nuse crate::shared::{AppError, RateLimiter, ValidationFailureKind};\r\nuse chrono::Utc;\r\nuse std::cmp::Ordering;\r\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\r\nuse std::sync::Arc;\r\nuse std::time::{Duration, Instant};\n\r\npub(crate) const DEFAULT_LIMIT: usize = 20;\r\npub(crate) const MAX_LIMIT: usize = 50;\r\npub(crate) const MAX_FETCH: usize = 250;\r\nconst RATE_LIMIT_MAX_REQUESTS: usize = 30;\r\nconst RATE_LIMIT_WINDOW: Duration = Duration::from_secs(10);\r\n\r\n#[derive(Clone, Copy)]\r\npub enum SearchSort {\r\n    Relevance,\r\n    Recency,\r\n}\r\n\r\nimpl SearchSort {\r\n    pub fn try_from_str(value: Option<&str>) -> Result<Self, AppError> {\r\n        match value.unwrap_or(\"relevance\").to_lowercase().as_str() {\r\n            \"relevance\" => Ok(SearchSort::Relevance),\r\n            \"recency\" => Ok(SearchSort::Recency),\r\n            other => Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Unsupported search sort: {other}\"),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\npub struct SearchUsersParams {\r\n    pub query: String,\r\n    pub cursor: Option<String>,\r\n    pub limit: usize,\r\n    pub sort: SearchSort,\r\n    pub allow_incomplete: bool,\r\n    pub viewer_pubkey: Option<String>,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct SearchUsersResult {\r\n    pub users: Vec<User>,\r\n    pub next_cursor: Option<String>,\r\n    pub has_more: bool,\r\n    pub total_count: usize,\r\n    pub took_ms: u128,\r\n}\r\n\r\npub struct UserSearchService {\r\n    repository: Arc<dyn UserRepository>,\r\n    rate_limiter: RateLimiter,\r\n}\r\n\r\nimpl UserSearchService {\r\n    pub fn new(repository: Arc<dyn UserRepository>) -> Self {\r\n        Self {\r\n            repository,\r\n            rate_limiter: RateLimiter::new(RATE_LIMIT_MAX_REQUESTS, RATE_LIMIT_WINDOW),\r\n        }\r\n    }\r\n\r\n    pub async fn search(&self, params: SearchUsersParams) -> Result<SearchUsersResult, AppError> {\r\n        let normalized_query = params.query.trim();\r\n        if normalized_query.len() < 2 && !params.allow_incomplete {\r\n            return Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                \"検索キーワードは2文字以上で入力してください\",\r\n            ));\r\n        }\r\n\r\n        let rate_key = params\r\n            .viewer_pubkey\r\n            .clone()\r\n            .unwrap_or_else(|| format!(\"anon:{}\", normalized_query.to_lowercase()));\r\n        self.rate_limiter\r\n            .check_and_record(&rate_key, \"一定時間内に繰り返し検索が実行されています\")\r\n            .await?;\r\n\r\n        let start = Instant::now();\r\n        let fetch_limit = MAX_FETCH.min(params.limit + MAX_LIMIT);\r\n        let raw_users = self\r\n            .repository\r\n            .search_users(normalized_query, fetch_limit)\r\n            .await?;\r\n\r\n        let (following, followers) = if let Some(pubkey) = params.viewer_pubkey.as_ref() {\r\n            let following = self.repository.list_following_pubkeys(pubkey).await?;\r\n            let followers = self.repository.list_follower_pubkeys(pubkey).await?;\r\n            (\r\n                HashSet::from_iter(following.into_iter()),\r\n                HashSet::from_iter(followers.into_iter()),\r\n            )\r\n        } else {\r\n            (HashSet::new(), HashSet::new())\r\n        };\r\n\r\n        let query_lower = normalized_query.to_lowercase();\r\n        let mut ranked: Vec<RankedUser> = raw_users\r\n            .into_iter()\r\n            .map(|user| {\r\n                let rank = compute_rank(&user, &query_lower, &following, &followers);\r\n                RankedUser { user, rank }\r\n            })\r\n            .collect();\r\n\r\n        match params.sort {\r\n            SearchSort::Relevance => ranked.sort_by(|a, b| {\r\n                b.rank\r\n                    .partial_cmp(&a.rank)\r\n                    .unwrap_or(Ordering::Equal)\r\n                    .then_with(|| a.user.npub.cmp(&b.user.npub))\r\n            }),\r\n            SearchSort::Recency => ranked.sort_by(|a, b| {\r\n                b.user\r\n                    .updated_at\r\n                    .cmp(&a.user.updated_at)\r\n                    .then_with(|| a.user.npub.cmp(&b.user.npub))\r\n            }),\r\n        }\r\n\r\n        let total_count = ranked.len();\r\n        let start_index = cursor_start_index(&ranked, &params)?;\r\n        let end_index = (start_index + params.limit).min(total_count);\r\n        let has_more = end_index < total_count;\r\n\r\n        let users: Vec<User> = ranked[start_index..end_index]\r\n            .iter()\r\n            .map(|entry| entry.user.clone())\r\n            .collect();\r\n\r\n        let next_cursor = if has_more && !users.is_empty() {\r\n            Some(encode_cursor(params.sort, &ranked[end_index - 1]))\r\n        } else {\r\n            None\r\n        };\r\n\r\n        Ok(SearchUsersResult {\r\n            users,\r\n            next_cursor,\r\n            has_more,\r\n            total_count,\r\n            took_ms: start.elapsed().as_millis(),\r\n        })\r\n    }\r\n}\r\n\r\nstruct RankedUser {\r\n    user: User,\r\n    rank: f64,\r\n}\r\n\r\nfn cursor_start_index(\r\n    ranked: &[RankedUser],\r\n    params: &SearchUsersParams,\r\n) -> Result<usize, AppError> {\r\n    if let Some(cursor) = params.cursor.as_ref() {\r\n        match parse_cursor(cursor)? {\r\n            Cursor::Relevance { rank, npub } => {\r\n                if matches!(params.sort, SearchSort::Relevance) {\r\n                    if let Some(pos) = ranked.iter().position(|entry| {\r\n                        entry.user.npub == npub && (entry.rank - rank).abs() < f64::EPSILON\r\n                    }) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                    if let Some(pos) = ranked.iter().position(|entry| entry.user.npub == npub) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                }\r\n            }\r\n            Cursor::Recency { updated_at, npub } => {\r\n                if matches!(params.sort, SearchSort::Recency) {\r\n                    if let Some(pos) = ranked.iter().position(|entry| {\r\n                        entry.user.npub == npub\r\n                            && entry.user.updated_at.timestamp_millis() == updated_at\r\n                    }) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Ok(0)\r\n}\r\n\r\nfn compute_rank(\r\n    user: &User,\r\n    query: &str,\r\n    following: &HashSet<String>,\r\n    followers: &HashSet<String>,\r\n) -> f64 {\r\n    let text_score = compute_text_score(user, query);\r\n    let mutual_score = compute_mutual_score(user, following, followers);\r\n    let recency_score = compute_recency_score(user);\r\n    text_score * 0.7 + mutual_score * 0.2 + recency_score * 0.1\r\n}\r\n\r\nfn compute_text_score(user: &User, query: &str) -> f64 {\r\n    let lowered = query.to_lowercase();\r\n    let mut score = 0.0;\r\n\r\n    let name = user.profile.display_name.to_lowercase();\r\n    if name.starts_with(&lowered) {\r\n        score += 4.0;\r\n    } else if name.contains(&lowered) {\r\n        score += 3.0;\r\n    }\r\n\r\n    if user.npub.to_lowercase().contains(&lowered) {\r\n        score += 2.0;\r\n    }\r\n\r\n    if user.profile.bio.to_lowercase().contains(&lowered) {\r\n        score += 1.0;\r\n    }\r\n\r\n    score\r\n}\r\n\r\nfn compute_mutual_score(\r\n    user: &User,\r\n    following: &HashSet<String>,\r\n    followers: &HashSet<String>,\r\n) -> f64 {\r\n    let mut score = 0.0;\r\n    if following.contains(user.pubkey()) {\r\n        score += 1.0;\r\n    }\r\n    if followers.contains(user.pubkey()) {\r\n        score += 1.0;\r\n    }\r\n    score\r\n}\r\n\r\nfn compute_recency_score(user: &User) -> f64 {\r\n    let now = Utc::now();\r\n    let elapsed = now\r\n        .signed_duration_since(user.updated_at)\r\n        .num_seconds()\r\n        .max(0) as f64;\r\n    let hours = elapsed / 3600.0;\r\n    1.0 / (1.0 + hours)\r\n}\r\n\r\nenum Cursor {\r\n    Relevance { rank: f64, npub: String },\r\n    Recency { updated_at: i64, npub: String },\r\n}\r\n\r\nfn encode_cursor(sort: SearchSort, entry: &RankedUser) -> String {\r\n    match sort {\r\n        SearchSort::Relevance => format!(\"rel:{:.5}:{}\", entry.rank, entry.user.npub),\r\n        SearchSort::Recency => format!(\r\n            \"rec:{}:{}\",\r\n            entry.user.updated_at.timestamp_millis(),\r\n            entry.user.npub\r\n        ),\r\n    }\r\n}\r\n\r\nfn parse_cursor(cursor: &str) -> Result<Cursor, AppError> {\r\n    let mut parts = cursor.splitn(3, ':');\r\n    match parts.next() {\r\n        Some(\"rel\") => {\r\n            let rank = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?\r\n                .parse::<f64>()\r\n                .map_err(|_| AppError::InvalidInput(\"Invalid cursor rank\".into()))?;\r\n            let npub = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?;\r\n            Ok(Cursor::Relevance {\r\n                rank,\r\n                npub: npub.to_string(),\r\n            })\r\n        }\r\n        Some(\"rec\") => {\r\n            let timestamp = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?\r\n                .parse::<i64>()\r\n                .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\r\n            let npub = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?;\r\n            Ok(Cursor::Recency {\r\n                updated_at: timestamp,\r\n                npub: npub.to_string(),\r\n            })\r\n        }\r\n        _ => Err(AppError::InvalidInput(\"Invalid cursor prefix\".into())),\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::repositories::UserRepository;\r\n    use crate::infrastructure::database::{\r\n        connection_pool::ConnectionPool, repository::Repository,\r\n        sqlite_repository::SqliteRepository,\r\n    };\r\n    use chrono::{Duration as ChronoDuration, Utc};\r\n\r\n    async fn setup_service() -> (UserSearchService, Arc<SqliteRepository>) {\r\n        let pool = ConnectionPool::from_memory().await.unwrap();\r\n        let repository = Arc::new(SqliteRepository::new(pool.clone()));\r\n        repository.initialize().await.unwrap();\r\n        let service = UserSearchService::new(Arc::clone(&repository) as Arc<dyn UserRepository>);\r\n        (service, repository)\r\n    }\r\n\r\n    async fn insert_user(\r\n        repository: &Arc<SqliteRepository>,\r\n        npub: &str,\r\n        display_name: &str,\r\n        bio: &str,\r\n        updated_offset_secs: i64,\r\n    ) -> User {\r\n        let pubkey = format!(\"pubkey_{npub}\");\r\n        let mut user = User::new(npub.to_string(), pubkey.clone());\r\n        user.profile.display_name = display_name.to_string();\r\n        user.profile.bio = bio.to_string();\r\n        user.updated_at = Utc::now() - ChronoDuration::seconds(updated_offset_secs);\r\n        repository.create_user(&user).await.unwrap();\r\n        user\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_returns_ranked_results_with_cursor() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 10).await;\r\n        insert_user(&repository, \"npub1alicia\", \"Alicia\", \"nostr dev\", 20).await;\r\n        insert_user(&repository, \"npub1bob\", \"Bob\", \"rustacean\", 5).await;\r\n\r\n        let first = service\r\n            .search(SearchUsersParams {\r\n                query: \"ali\".to_string(),\r\n                cursor: None,\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"first page\");\r\n\r\n        assert_eq!(first.users.len(), 1);\r\n        assert!(first.has_more);\r\n        let cursor = first.next_cursor.clone().expect(\"cursor present\");\r\n\r\n        let second = service\r\n            .search(SearchUsersParams {\r\n                query: \"ali\".to_string(),\r\n                cursor: Some(cursor),\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"second page\");\r\n\r\n        assert_eq!(second.users.len(), 1);\r\n        assert_ne!(first.users[0].npub, second.users[0].npub);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_prioritizes_follow_relationships() {\r\n        let (service, repository) = setup_service().await;\r\n        let viewer = insert_user(&repository, \"npub1viewer\", \"Viewer\", \"viewer\", 1).await;\r\n        let alice = insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 10).await;\r\n        let bob = insert_user(&repository, \"npub1bob\", \"Bob\", \"nostr dev\", 5).await;\r\n\r\n        repository\r\n            .add_follow_relation(viewer.pubkey(), alice.pubkey())\r\n            .await\r\n            .unwrap();\r\n        repository\r\n            .add_follow_relation(alice.pubkey(), viewer.pubkey())\r\n            .await\r\n            .unwrap();\r\n\r\n        let result = service\r\n            .search(SearchUsersParams {\r\n                query: \"nostr\".to_string(),\r\n                cursor: None,\r\n                limit: 5,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: Some(viewer.pubkey().to_string()),\r\n            })\r\n            .await\r\n            .expect(\"search\");\r\n\r\n        assert_eq!(result.users.first().unwrap().npub, alice.npub);\r\n        assert!(result.users.iter().any(|user| user.npub == bob.npub));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn rate_limiter_blocks_excess_requests() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 1).await;\r\n\r\n        for _ in 0..RATE_LIMIT_MAX_REQUESTS {\r\n            service\r\n                .search(SearchUsersParams {\r\n                    query: \"alice\".to_string(),\r\n                    cursor: None,\r\n                    limit: 1,\r\n                    sort: SearchSort::Relevance,\r\n                    allow_incomplete: false,\r\n                    viewer_pubkey: None,\r\n                })\r\n                .await\r\n                .expect(\"search within limit\");\r\n        }\r\n\r\n        let err = service\r\n            .search(SearchUsersParams {\r\n                query: \"alice\".to_string(),\r\n                cursor: None,\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect_err(\"rate limit triggered\");\r\n        assert!(matches!(err, AppError::RateLimited { .. }));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn allow_incomplete_accepts_short_queries() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 1).await;\r\n\r\n        let result = service\r\n            .search(SearchUsersParams {\r\n                query: \"a\".to_string(),\r\n                cursor: None,\r\n                limit: 5,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: true,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"short query allowed\");\r\n\r\n        assert_eq!(result.total_count, 1);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[24691058,24690496],"length":1,"stats":{"Line":0}},{"line":25,"address":[15217455,15217339],"length":1,"stats":{"Line":0}},{"line":26,"address":[24690687,24690758],"length":1,"stats":{"Line":0}},{"line":27,"address":[15313946,15314001,15314073],"length":1,"stats":{"Line":0}},{"line":28,"address":[22875921,22876100],"length":1,"stats":{"Line":0}},{"line":29,"address":[22875937],"length":1,"stats":{"Line":0}},{"line":30,"address":[15217664,15217609],"length":1,"stats":{"Line":0}},{"line":60,"address":[15213936,15214099],"length":1,"stats":{"Line":1}},{"line":63,"address":[15108059],"length":1,"stats":{"Line":1}},{"line":67,"address":[15102573,15108299,15101424,15101551,15101459,15101791,15101504,15103454],"length":1,"stats":{"Line":7}},{"line":68,"address":[15101753,15101961],"length":1,"stats":{"Line":3}},{"line":69,"address":[22877101,22877013],"length":1,"stats":{"Line":3}},{"line":70,"address":[15108934],"length":1,"stats":{"Line":0}},{"line":71,"address":[22877118],"length":1,"stats":{"Line":0}},{"line":76,"address":[15315357,15315160],"length":1,"stats":{"Line":2}},{"line":79,"address":[22883707,22877239,22883680],"length":1,"stats":{"Line":5}},{"line":80,"address":[15116078,15117183,15116603,15116207,15116751,15116266,15116476],"length":1,"stats":{"Line":11}},{"line":81,"address":[24692182],"length":1,"stats":{"Line":1}},{"line":82,"address":[15184284,15184463,15184125,15183341,15184059,15183999],"length":1,"stats":{"Line":4}},{"line":84,"address":[15215599,15215755],"length":1,"stats":{"Line":3}},{"line":85,"address":[15103057],"length":1,"stats":{"Line":1}},{"line":86,"address":[15110068,15109941,15110151,15110358,15110485,15111466,15110707],"length":1,"stats":{"Line":9}},{"line":88,"address":[15215966],"length":1,"stats":{"Line":1}},{"line":89,"address":[15103875,15103622,15103324,15101842,15103389,15103463],"length":1,"stats":{"Line":9}},{"line":91,"address":[15185536,15185358,15187861,15186062],"length":1,"stats":{"Line":5}},{"line":92,"address":[10904767],"length":1,"stats":{"Line":3}},{"line":93,"address":[11605940],"length":1,"stats":{"Line":3}},{"line":95,"address":[15105891,15106097],"length":1,"stats":{"Line":2}},{"line":96,"address":[15222764,15222875],"length":1,"stats":{"Line":2}},{"line":99,"address":[15216819,15217127],"length":1,"stats":{"Line":2}},{"line":102,"address":[15222926],"length":1,"stats":{"Line":1}},{"line":103,"address":[15120322,15120150],"length":1,"stats":{"Line":2}},{"line":105,"address":[24698640,24698857,24696222],"length":1,"stats":{"Line":2}},{"line":106,"address":[15322147,15322228],"length":1,"stats":{"Line":2}},{"line":107,"address":[24698791],"length":1,"stats":{"Line":3}},{"line":111,"address":[15319696],"length":1,"stats":{"Line":3}},{"line":112,"address":[15188169,15188299,15190816],"length":1,"stats":{"Line":4}},{"line":113,"address":[15123096,15123110,15123120],"length":1,"stats":{"Line":3}},{"line":114,"address":[22884319],"length":1,"stats":{"Line":1}},{"line":115,"address":[15183947],"length":1,"stats":{"Line":1}},{"line":116,"address":[15190942,15190928],"length":1,"stats":{"Line":0}},{"line":118,"address":[15219388,15219539,15222160],"length":1,"stats":{"Line":0}},{"line":119,"address":[22884488,22884474],"length":1,"stats":{"Line":0}},{"line":121,"address":[15191025],"length":1,"stats":{"Line":0}},{"line":122,"address":[15116350,15116336],"length":1,"stats":{"Line":0}},{"line":126,"address":[15188376,15188312],"length":1,"stats":{"Line":4}},{"line":127,"address":[15106864,15107052],"length":1,"stats":{"Line":2}},{"line":128,"address":[15120913,15120782],"length":1,"stats":{"Line":3}},{"line":129,"address":[24696877],"length":1,"stats":{"Line":2}},{"line":131,"address":[15114030,15114111],"length":1,"stats":{"Line":3}},{"line":133,"address":[24699219,24699184],"length":1,"stats":{"Line":3}},{"line":136,"address":[15225708,15225730,15225803],"length":1,"stats":{"Line":4}},{"line":137,"address":[15220233],"length":1,"stats":{"Line":1}},{"line":139,"address":[15188944],"length":1,"stats":{"Line":2}},{"line":142,"address":[15182519],"length":1,"stats":{"Line":1}},{"line":143,"address":[24697328],"length":1,"stats":{"Line":2}},{"line":144,"address":[15189264],"length":1,"stats":{"Line":2}},{"line":147,"address":[15182456,15182368],"length":1,"stats":{"Line":4}},{"line":157,"address":[15192241,15191184],"length":1,"stats":{"Line":2}},{"line":161,"address":[15109746],"length":1,"stats":{"Line":2}},{"line":162,"address":[24699393,24699472],"length":1,"stats":{"Line":2}},{"line":163,"address":[15116791],"length":1,"stats":{"Line":1}},{"line":164,"address":[22885049],"length":1,"stats":{"Line":1}},{"line":165,"address":[15228491,15229344,15228585],"length":1,"stats":{"Line":3}},{"line":166,"address":[15229381],"length":1,"stats":{"Line":1}},{"line":168,"address":[15124171,15124237],"length":1,"stats":{"Line":0}},{"line":170,"address":[22886160,22885419,22886185,22885511],"length":1,"stats":{"Line":4}},{"line":171,"address":[15228933],"length":1,"stats":{"Line":1}},{"line":175,"address":[24699682],"length":1,"stats":{"Line":0}},{"line":176,"address":[15226804],"length":1,"stats":{"Line":0}},{"line":177,"address":[15185442,15185824,15185351],"length":1,"stats":{"Line":0}},{"line":178,"address":[15118053],"length":1,"stats":{"Line":0}},{"line":179,"address":[15118077],"length":1,"stats":{"Line":0}},{"line":181,"address":[15124728,15124781],"length":1,"stats":{"Line":0}},{"line":187,"address":[22884849],"length":1,"stats":{"Line":2}},{"line":190,"address":[15185936],"length":1,"stats":{"Line":1}},{"line":196,"address":[15324459],"length":1,"stats":{"Line":1}},{"line":197,"address":[15192938],"length":1,"stats":{"Line":1}},{"line":198,"address":[15118224],"length":1,"stats":{"Line":3}},{"line":199,"address":[15118250],"length":1,"stats":{"Line":3}},{"line":202,"address":[22886496,22887456],"length":1,"stats":{"Line":1}},{"line":203,"address":[15324631],"length":1,"stats":{"Line":1}},{"line":204,"address":[15186176],"length":1,"stats":{"Line":1}},{"line":206,"address":[15324755,15324668],"length":1,"stats":{"Line":2}},{"line":207,"address":[15324865,15324949,15324782],"length":1,"stats":{"Line":3}},{"line":208,"address":[15224555],"length":1,"stats":{"Line":2}},{"line":209,"address":[15224538,15224593,15224677],"length":1,"stats":{"Line":2}},{"line":210,"address":[15111947],"length":1,"stats":{"Line":0}},{"line":213,"address":[24701482,24701761,24701537],"length":1,"stats":{"Line":4}},{"line":214,"address":[15224887],"length":1,"stats":{"Line":3}},{"line":217,"address":[15187042,15186754,15186813],"length":1,"stats":{"Line":4}},{"line":218,"address":[15225128],"length":1,"stats":{"Line":1}},{"line":221,"address":[15119174],"length":1,"stats":{"Line":2}},{"line":224,"address":[15230800],"length":1,"stats":{"Line":2}},{"line":229,"address":[22887521],"length":1,"stats":{"Line":1}},{"line":230,"address":[15112554,15112628],"length":1,"stats":{"Line":3}},{"line":231,"address":[15325680],"length":1,"stats":{"Line":1}},{"line":233,"address":[15325733,15325654],"length":1,"stats":{"Line":4}},{"line":234,"address":[24702191],"length":1,"stats":{"Line":1}},{"line":236,"address":[15225334],"length":1,"stats":{"Line":3}},{"line":239,"address":[15225376],"length":1,"stats":{"Line":3}},{"line":240,"address":[15229326],"length":1,"stats":{"Line":3}},{"line":241,"address":[15187316],"length":1,"stats":{"Line":3}},{"line":242,"address":[15112702],"length":1,"stats":{"Line":3}},{"line":245,"address":[15126562],"length":1,"stats":{"Line":3}},{"line":246,"address":[15119604],"length":1,"stats":{"Line":3}},{"line":254,"address":[15229504],"length":1,"stats":{"Line":1}},{"line":255,"address":[15112903],"length":1,"stats":{"Line":1}},{"line":256,"address":[15231215],"length":1,"stats":{"Line":1}},{"line":257,"address":[15113443],"length":1,"stats":{"Line":0}},{"line":259,"address":[22888398],"length":1,"stats":{"Line":0}},{"line":265,"address":[15120416],"length":1,"stats":{"Line":1}},{"line":266,"address":[24703201],"length":1,"stats":{"Line":1}},{"line":267,"address":[15188279],"length":1,"stats":{"Line":1}},{"line":268,"address":[15188329],"length":1,"stats":{"Line":1}},{"line":269,"address":[22888928,22889798,22889959,22889647],"length":1,"stats":{"Line":2}},{"line":271,"address":[15114791,15115232,15115246],"length":1,"stats":{"Line":0}},{"line":273,"address":[15328024,15328400,15328423],"length":1,"stats":{"Line":0}},{"line":274,"address":[15128965,15128632,15128769],"length":1,"stats":{"Line":2}},{"line":276,"address":[15190032,15190046,15189766],"length":1,"stats":{"Line":0}},{"line":277,"address":[15231706],"length":1,"stats":{"Line":1}},{"line":279,"address":[15115041],"length":1,"stats":{"Line":1}},{"line":282,"address":[15230553],"length":1,"stats":{"Line":0}},{"line":283,"address":[15227124,15226740,15226966],"length":1,"stats":{"Line":0}},{"line":285,"address":[15195751,15197070,15197056],"length":1,"stats":{"Line":0}},{"line":287,"address":[15328704,15328725,15327461],"length":1,"stats":{"Line":0}},{"line":288,"address":[15188901,15189038,15189229],"length":1,"stats":{"Line":0}},{"line":290,"address":[15232894,15234030,15234016],"length":1,"stats":{"Line":0}},{"line":291,"address":[15227206],"length":1,"stats":{"Line":0}},{"line":293,"address":[15121262],"length":1,"stats":{"Line":0}},{"line":296,"address":[15232068],"length":1,"stats":{"Line":0}}],"covered":95,"coverable":131},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","user_service.rs"],"content":"use crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\r\nuse crate::domain::entities::{User, UserMetadata};\r\nuse crate::shared::{AppError, ValidationFailureKind};\r\nuse chrono::Utc;\r\nuse std::sync::Arc;\r\n\r\npub struct UserService {\r\n    repository: Arc<dyn UserRepository>,\r\n}\r\n\r\nimpl UserService {\r\n    pub fn new(repository: Arc<dyn UserRepository>) -> Self {\r\n        Self { repository }\r\n    }\r\n\r\n    pub async fn create_user(&self, npub: String, pubkey: String) -> Result<User, AppError> {\r\n        let user = User::new(npub, pubkey);\r\n        self.repository.create_user(&user).await?;\r\n        Ok(user)\r\n    }\r\n\r\n    pub async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\r\n        self.repository.get_user(npub).await\r\n    }\r\n\r\n    pub async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\r\n        self.repository.get_user_by_pubkey(pubkey).await\r\n    }\r\n\r\n    pub async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\r\n        if query.trim().is_empty() {\r\n            return Ok(vec![]);\r\n        }\r\n        self.repository.search_users(query, limit).await\r\n    }\r\n\r\n    pub async fn update_profile(&self, npub: &str, metadata: UserMetadata) -> Result<(), AppError> {\r\n        if let Some(mut user) = self.repository.get_user(npub).await? {\r\n            user.update_metadata(metadata);\r\n            self.repository.update_user(&user).await?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn update_privacy_settings(\r\n        &self,\r\n        npub: &str,\r\n        public_profile: bool,\r\n        show_online_status: bool,\r\n    ) -> Result<(), AppError> {\r\n        let mut user = self\r\n            .repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))?;\r\n\r\n        user.public_profile = public_profile;\r\n        user.show_online_status = show_online_status;\r\n        user.updated_at = Utc::now();\r\n\r\n        self.repository.update_user(&user).await\r\n    }\r\n\r\n    pub async fn update_user(&self, user: User) -> Result<(), AppError> {\r\n        self.repository.update_user(&user).await\r\n    }\r\n\r\n    pub async fn follow_user(\r\n        &self,\r\n        follower_npub: &str,\r\n        target_npub: &str,\r\n    ) -> Result<(), AppError> {\r\n        if follower_npub == target_npub {\r\n            return Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                \"Cannot follow yourself\",\r\n            ));\r\n        }\r\n\r\n        let follower = self.resolve_user_by_npub(follower_npub).await?;\r\n        let target = self.resolve_user_by_npub(target_npub).await?;\r\n\r\n        self.repository\r\n            .add_follow_relation(follower.pubkey(), target.pubkey())\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn unfollow_user(\r\n        &self,\r\n        follower_npub: &str,\r\n        target_npub: &str,\r\n    ) -> Result<(), AppError> {\r\n        let follower = self.resolve_user_by_npub(follower_npub).await?;\r\n        let target = self.resolve_user_by_npub(target_npub).await?;\r\n\r\n        let removed = self\r\n            .repository\r\n            .remove_follow_relation(follower.pubkey(), target.pubkey())\r\n            .await?;\r\n\r\n        if removed {\r\n            Ok(())\r\n        } else {\r\n            Err(AppError::NotFound(format!(\r\n                \"{follower_npub} is not following {target_npub}\"\r\n            )))\r\n        }\r\n    }\r\n\r\n    pub async fn get_followers_paginated(\r\n        &self,\r\n        npub: &str,\r\n        cursor: Option<&str>,\r\n        limit: usize,\r\n        sort: FollowListSort,\r\n        search: Option<&str>,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<UserCursorPage, AppError> {\r\n        self.ensure_profile_visibility(npub, viewer_npub).await?;\r\n        self.repository\r\n            .get_followers_paginated(npub, cursor, limit, sort, search)\r\n            .await\r\n    }\r\n\r\n    pub async fn get_following_paginated(\r\n        &self,\r\n        npub: &str,\r\n        cursor: Option<&str>,\r\n        limit: usize,\r\n        sort: FollowListSort,\r\n        search: Option<&str>,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<UserCursorPage, AppError> {\r\n        self.ensure_profile_visibility(npub, viewer_npub).await?;\r\n        self.repository\r\n            .get_following_paginated(npub, cursor, limit, sort, search)\r\n            .await\r\n    }\r\n\r\n    pub async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError> {\r\n        let mut all_users = Vec::new();\r\n        let mut cursor: Option<String> = None;\r\n\r\n        loop {\r\n            let UserCursorPage {\r\n                users,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: _,\r\n            } = self\r\n                .get_followers_paginated(\r\n                    npub,\r\n                    cursor.as_deref(),\r\n                    100,\r\n                    FollowListSort::Recent,\r\n                    None,\r\n                    Some(npub),\r\n                )\r\n                .await?;\r\n\r\n            all_users.extend(users.into_iter());\r\n\r\n            if !has_more || next_cursor.is_none() {\r\n                break;\r\n            }\r\n\r\n            cursor = next_cursor;\r\n        }\r\n\r\n        Ok(all_users)\r\n    }\r\n\r\n    pub async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError> {\r\n        let mut all_users = Vec::new();\r\n        let mut cursor: Option<String> = None;\r\n\r\n        loop {\r\n            let UserCursorPage {\r\n                users,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: _,\r\n            } = self\r\n                .get_following_paginated(\r\n                    npub,\r\n                    cursor.as_deref(),\r\n                    100,\r\n                    FollowListSort::Recent,\r\n                    None,\r\n                    Some(npub),\r\n                )\r\n                .await?;\r\n\r\n            all_users.extend(users.into_iter());\r\n\r\n            if !has_more || next_cursor.is_none() {\r\n                break;\r\n            }\r\n\r\n            cursor = next_cursor;\r\n        }\r\n\r\n        Ok(all_users)\r\n    }\r\n\r\n    pub async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\r\n        self.repository.delete_user(npub).await\r\n    }\r\n\r\n    async fn resolve_user_by_npub(&self, npub: &str) -> Result<User, AppError> {\r\n        self.repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))\r\n    }\r\n\r\n    async fn ensure_profile_visibility(\r\n        &self,\r\n        npub: &str,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<(), AppError> {\r\n        let user = self\r\n            .repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))?;\r\n\r\n        if !user.public_profile {\r\n            let viewer_matches = viewer_npub\r\n                .map(|viewer| viewer == user.npub)\r\n                .unwrap_or(false);\r\n            if !viewer_matches {\r\n                return Err(AppError::Unauthorized(format!(\"Profile {npub} is private\")));\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::repositories::UserRepository;\r\n    use async_trait::async_trait;\r\n    use std::collections::{HashMap, HashSet};\r\n    use std::sync::Arc;\r\n    use tokio::sync::RwLock;\r\n\r\n    const ALICE_NPUB: &str = \"npub1alice\";\r\n    const ALICE_PUB: &str = \"alice_pub\";\r\n    const BOB_NPUB: &str = \"npub1bob\";\r\n    const BOB_PUB: &str = \"bob_pub\";\r\n\r\n    fn parse_offset_cursor(cursor: &str) -> Result<usize, AppError> {\r\n        cursor\r\n            .strip_prefix(\"offset:\")\r\n            .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?\r\n            .parse::<usize>()\r\n            .map_err(|_| AppError::InvalidInput(\"Invalid cursor offset\".into()))\r\n    }\r\n\r\n    fn name_key(user: &User) -> String {\r\n        let display_name = user.profile.display_name.trim();\r\n        if display_name.is_empty() {\r\n            user.npub.to_lowercase()\r\n        } else {\r\n            display_name.to_lowercase()\r\n        }\r\n    }\r\n    #[derive(Default)]\r\n    struct InMemoryUserRepository {\r\n        users: RwLock<HashMap<String, User>>,\r\n        follows: RwLock<HashSet<(String, String)>>,\r\n    }\r\n\r\n    enum FollowRelationKind {\r\n        Followers,\r\n        Following,\r\n    }\r\n\r\n    impl InMemoryUserRepository {\r\n        async fn paginate_relation(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n            kind: FollowRelationKind,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            let users = self.users.read().await;\r\n            let target_pubkey = match users.get(npub) {\r\n                Some(user) => user.pubkey.clone(),\r\n                None => {\r\n                    return Ok(UserCursorPage {\r\n                        users: vec![],\r\n                        next_cursor: None,\r\n                        has_more: false,\r\n                        total_count: 0,\r\n                    });\r\n                }\r\n            };\r\n            let follows = self.follows.read().await;\r\n            let mut entries: Vec<User> = follows\r\n                .iter()\r\n                .filter_map(|(follower, followed)| match kind {\r\n                    FollowRelationKind::Followers if followed == &target_pubkey => {\r\n                        Some(follower.clone())\r\n                    }\r\n                    FollowRelationKind::Following if follower == &target_pubkey => {\r\n                        Some(followed.clone())\r\n                    }\r\n                    _ => None,\r\n                })\r\n                .filter_map(|pubkey| users.values().find(|u| u.pubkey == pubkey).cloned())\r\n                .collect();\r\n\r\n            let search_lower = search.map(|s| s.to_lowercase());\r\n            if let Some(search_value) = search_lower.as_ref() {\r\n                entries.retain(|user| {\r\n                    let display = user.profile.display_name.to_lowercase();\r\n                    let npub_value = user.npub.to_lowercase();\r\n                    let pubkey = user.pubkey.to_lowercase();\r\n                    display.contains(search_value)\r\n                        || npub_value.contains(search_value)\r\n                        || pubkey.contains(search_value)\r\n                });\r\n            }\r\n\r\n            match sort {\r\n                FollowListSort::Recent => {\r\n                    entries.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));\r\n                }\r\n                FollowListSort::Oldest => {\r\n                    entries.sort_by(|a, b| a.updated_at.cmp(&b.updated_at));\r\n                }\r\n                FollowListSort::NameAsc => {\r\n                    entries.sort_by(|a, b| name_key(a).cmp(&name_key(b)));\r\n                }\r\n                FollowListSort::NameDesc => {\r\n                    entries.sort_by(|a, b| name_key(b).cmp(&name_key(a)));\r\n                }\r\n            }\r\n\r\n            let total_entries = entries.len();\r\n            let mut offset = 0usize;\r\n            if let Some(cursor) = cursor {\r\n                offset = parse_offset_cursor(cursor)?;\r\n            }\r\n            offset = offset.min(total_entries);\r\n\r\n            let end = offset.saturating_add(limit);\r\n            let has_more = end < total_entries;\r\n            let next_cursor = if has_more {\r\n                Some(format!(\"offset:{}\", end))\r\n            } else {\r\n                None\r\n            };\r\n\r\n            let items: Vec<User> = entries.into_iter().skip(offset).take(limit).collect();\r\n\r\n            Ok(UserCursorPage {\r\n                users: items,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: total_entries as u64,\r\n            })\r\n        }\r\n    }\r\n\r\n    #[async_trait]\r\n    impl UserRepository for InMemoryUserRepository {\r\n        async fn create_user(&self, user: &User) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            users.insert(user.npub.clone(), user.clone());\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\r\n            let users = self.users.read().await;\r\n            Ok(users.get(npub).cloned())\r\n        }\r\n\r\n        async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\r\n            let users = self.users.read().await;\r\n            Ok(users.values().find(|u| u.pubkey == pubkey).cloned())\r\n        }\r\n\r\n        async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\r\n            if query.trim().is_empty() {\r\n                return Ok(vec![]);\r\n            }\r\n\r\n            let query_lower = query.to_lowercase();\r\n            let users = self.users.read().await;\r\n            let mut results: Vec<User> = users\r\n                .values()\r\n                .filter(|user| {\r\n                    let display_name = user.profile.display_name.to_lowercase();\r\n                    let bio = user.profile.bio.to_lowercase();\r\n                    display_name.contains(&query_lower)\r\n                        || bio.contains(&query_lower)\r\n                        || user.npub.to_lowercase().contains(&query_lower)\r\n                        || user.pubkey.to_lowercase().contains(&query_lower)\r\n                })\r\n                .cloned()\r\n                .collect();\r\n\r\n            results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));\r\n            if results.len() > limit {\r\n                results.truncate(limit);\r\n            }\r\n\r\n            Ok(results)\r\n        }\r\n\r\n        async fn update_user(&self, user: &User) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            users.insert(user.npub.clone(), user.clone());\r\n            Ok(())\r\n        }\r\n\r\n        async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            if let Some(user) = users.remove(npub) {\r\n                let mut follows = self.follows.write().await;\r\n                follows.retain(|(follower, followed)| {\r\n                    follower != &user.pubkey && followed != &user.pubkey\r\n                });\r\n            }\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_followers_paginated(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            self.paginate_relation(\r\n                npub,\r\n                cursor,\r\n                limit,\r\n                sort,\r\n                search,\r\n                FollowRelationKind::Followers,\r\n            )\r\n            .await\r\n        }\r\n\r\n        async fn get_following_paginated(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            self.paginate_relation(\r\n                npub,\r\n                cursor,\r\n                limit,\r\n                sort,\r\n                search,\r\n                FollowRelationKind::Following,\r\n            )\r\n            .await\r\n        }\r\n\r\n        async fn add_follow_relation(\r\n            &self,\r\n            follower_pubkey: &str,\r\n            followed_pubkey: &str,\r\n        ) -> Result<bool, AppError> {\r\n            let mut follows = self.follows.write().await;\r\n            Ok(follows.insert((follower_pubkey.to_string(), followed_pubkey.to_string())))\r\n        }\r\n\r\n        async fn remove_follow_relation(\r\n            &self,\r\n            follower_pubkey: &str,\r\n            followed_pubkey: &str,\r\n        ) -> Result<bool, AppError> {\r\n            let mut follows = self.follows.write().await;\r\n            Ok(follows.remove(&(follower_pubkey.to_string(), followed_pubkey.to_string())))\r\n        }\r\n\r\n        async fn list_following_pubkeys(\r\n            &self,\r\n            follower_pubkey: &str,\r\n        ) -> Result<Vec<String>, AppError> {\r\n            let follows = self.follows.read().await;\r\n            Ok(follows\r\n                .iter()\r\n                .filter(|(follower, _)| follower == follower_pubkey)\r\n                .map(|(_, followed)| followed.clone())\r\n                .collect())\r\n        }\r\n\r\n        async fn list_follower_pubkeys(\r\n            &self,\r\n            followed_pubkey: &str,\r\n        ) -> Result<Vec<String>, AppError> {\r\n            let follows = self.follows.read().await;\r\n            Ok(follows\r\n                .iter()\r\n                .filter(|(_, target)| target == followed_pubkey)\r\n                .map(|(follower, _)| follower.clone())\r\n                .collect())\r\n        }\r\n    }\r\n\r\n    async fn setup_service() -> UserService {\r\n        let repository: Arc<dyn UserRepository> = Arc::new(InMemoryUserRepository::default());\r\n        UserService::new(repository)\r\n    }\r\n\r\n    async fn seed_user(service: &UserService, npub: &str, pubkey: &str) {\r\n        service\r\n            .create_user(npub.to_string(), pubkey.to_string())\r\n            .await\r\n            .expect(\"create user\");\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_and_unfollow_flow() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .follow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect(\"follow\");\r\n\r\n        let following = service\r\n            .get_following(ALICE_NPUB)\r\n            .await\r\n            .expect(\"following list\");\r\n        assert_eq!(following.len(), 1);\r\n        assert_eq!(following[0].npub, BOB_NPUB);\r\n\r\n        let followers = service\r\n            .get_followers(BOB_NPUB)\r\n            .await\r\n            .expect(\"followers list\");\r\n        assert_eq!(followers.len(), 1);\r\n        assert_eq!(followers[0].npub, ALICE_NPUB);\r\n\r\n        service\r\n            .unfollow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect(\"unfollow\");\r\n\r\n        assert!(\r\n            service\r\n                .get_following(ALICE_NPUB)\r\n                .await\r\n                .expect(\"following after unfollow\")\r\n                .is_empty()\r\n        );\r\n        assert!(\r\n            service\r\n                .get_followers(BOB_NPUB)\r\n                .await\r\n                .expect(\"followers after unfollow\")\r\n                .is_empty()\r\n        );\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_user_validates_identity() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        let err = service\r\n            .follow_user(ALICE_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect_err(\"self follow should fail\");\r\n        assert!(matches!(err, AppError::ValidationError { .. }));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_user_requires_existing_target() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        let err = service\r\n            .follow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect_err(\"missing target\");\r\n        assert!(matches!(err, AppError::NotFound(_)));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn followers_paginated_respects_cursor_boundaries() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n        seed_user(&service, \"npub1carol\", \"carol_pub\").await;\r\n        seed_user(&service, \"npub1dave\", \"dave_pub\").await;\r\n\r\n        service\r\n            .follow_user(BOB_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect(\"bob follows\");\r\n        service\r\n            .follow_user(\"npub1carol\", ALICE_NPUB)\r\n            .await\r\n            .expect(\"carol follows\");\r\n        service\r\n            .follow_user(\"npub1dave\", ALICE_NPUB)\r\n            .await\r\n            .expect(\"dave follows\");\r\n\r\n        let page1 = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                2,\r\n                FollowListSort::NameAsc,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"page1\");\r\n        assert_eq!(page1.users.len(), 2);\r\n        assert_eq!(page1.total_count, 3);\r\n        assert!(page1.has_more);\r\n        let cursor = page1.next_cursor.as_deref().expect(\"cursor present\");\r\n\r\n        let page2 = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                Some(cursor),\r\n                2,\r\n                FollowListSort::NameAsc,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"page2\");\r\n        assert_eq!(page2.users.len(), 1);\r\n        assert_eq!(page2.total_count, 3);\r\n        assert!(!page2.has_more);\r\n        assert!(page2.next_cursor.is_none());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn followers_paginated_private_profile_requires_matching_viewer() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .follow_user(BOB_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect(\"bob follows\");\r\n\r\n        service\r\n            .update_privacy_settings(ALICE_NPUB, false, true)\r\n            .await\r\n            .expect(\"set private\");\r\n\r\n        let err = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                10,\r\n                FollowListSort::Recent,\r\n                None,\r\n                Some(BOB_NPUB),\r\n            )\r\n            .await\r\n            .expect_err(\"private profile should reject viewer\");\r\n        assert!(matches!(err, AppError::Unauthorized(_)));\r\n\r\n        let owner_view = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                10,\r\n                FollowListSort::Recent,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"owner can view\");\r\n        assert_eq!(owner_view.total_count, 1);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_users_returns_matching_records() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .update_profile(\r\n                ALICE_NPUB,\r\n                UserMetadata {\r\n                    name: Some(\"alice\".to_string()),\r\n                    display_name: Some(\"Alice Wonderland\".to_string()),\r\n                    about: Some(\"nostr developer\".to_string()),\r\n                    picture: None,\r\n                    banner: None,\r\n                    nip05: None,\r\n                    lud16: None,\r\n                    public_profile: None,\r\n                    show_online_status: None,\r\n                },\r\n            )\r\n            .await\r\n            .expect(\"update alice profile\");\r\n\r\n        service\r\n            .update_profile(\r\n                BOB_NPUB,\r\n                UserMetadata {\r\n                    name: Some(\"bob\".to_string()),\r\n                    display_name: Some(\"Bob Smith\".to_string()),\r\n                    about: Some(\"bitcoin enthusiast\".to_string()),\r\n                    picture: None,\r\n                    banner: None,\r\n                    nip05: None,\r\n                    lud16: None,\r\n                    public_profile: None,\r\n                    show_online_status: None,\r\n                },\r\n            )\r\n            .await\r\n            .expect(\"update bob profile\");\r\n\r\n        let results = service\r\n            .search_users(\"alice\", 10)\r\n            .await\r\n            .expect(\"search users\");\r\n        assert_eq!(results.len(), 1);\r\n        assert_eq!(results[0].npub, ALICE_NPUB);\r\n\r\n        let bio_match = service\r\n            .search_users(\"bitcoin\", 10)\r\n            .await\r\n            .expect(\"search by bio\");\r\n        assert_eq!(bio_match.len(), 1);\r\n        assert_eq!(bio_match[0].npub, BOB_NPUB);\r\n\r\n        let none = service\r\n            .search_users(\"charlie\", 10)\r\n            .await\r\n            .expect(\"empty search\");\r\n        assert!(none.is_empty());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn update_privacy_settings_persists_flags() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        service\r\n            .update_privacy_settings(ALICE_NPUB, false, true)\r\n            .await\r\n            .expect(\"update privacy settings\");\r\n\r\n        let updated = service\r\n            .get_user(ALICE_NPUB)\r\n            .await\r\n            .expect(\"fetch user\")\r\n            .expect(\"user exists\");\r\n\r\n        assert!(!updated.public_profile);\r\n        assert!(updated.show_online_status);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn update_privacy_settings_missing_user_returns_error() {\r\n        let service = setup_service().await;\r\n\r\n        let err = service\r\n            .update_privacy_settings(\"npub1missing\", true, false)\r\n            .await\r\n            .expect_err(\"missing user should error\");\r\n\r\n        assert!(matches!(err, AppError::NotFound(_)));\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[16390832],"length":1,"stats":{"Line":1}},{"line":16,"address":[16391181,16390979,16390864,16391421,16391929,16390872,16390944,16391141],"length":1,"stats":{"Line":4}},{"line":17,"address":[22143588],"length":1,"stats":{"Line":1}},{"line":18,"address":[11576084],"length":1,"stats":{"Line":2}},{"line":19,"address":[15181368],"length":1,"stats":{"Line":1}},{"line":22,"address":[22255936,22255984,22256145,22256345,22256019,22255954,22256614,22256185],"length":1,"stats":{"Line":4}},{"line":23,"address":[19219620],"length":1,"stats":{"Line":2}},{"line":26,"address":[22251123,22251718,22251449,22251289,22251040,22251088,22251058,22251249],"length":1,"stats":{"Line":0}},{"line":27,"address":[22138524,22138649,22138777,22138572],"length":1,"stats":{"Line":0}},{"line":30,"address":[22139024,22139047,22139323,22139690,22139988,22139072,22139283,22139116],"length":1,"stats":{"Line":4}},{"line":31,"address":[15183284,15183170],"length":1,"stats":{"Line":2}},{"line":32,"address":[22139580,22139427],"length":1,"stats":{"Line":0}},{"line":34,"address":[22139722,22139406,22139310,22139474],"length":1,"stats":{"Line":2}},{"line":37,"address":[22221632,22221921,22222174,22223606,22221520,22221565,22221679,22223150],"length":1,"stats":{"Line":4}},{"line":38,"address":[22353503,22353431,22353758,22354674,22353614],"length":1,"stats":{"Line":2}},{"line":39,"address":[22222750],"length":1,"stats":{"Line":1}},{"line":40,"address":[15185224,15185455,15184320,15185739],"length":1,"stats":{"Line":1}},{"line":42,"address":[22223088],"length":1,"stats":{"Line":1}},{"line":45,"address":[22260592],"length":1,"stats":{"Line":1}},{"line":51,"address":[22356309,22356135,22355916,22356942,22356663,22355670,22356998,22355851,22356199,22356376],"length":1,"stats":{"Line":8}},{"line":53,"address":[22217356],"length":1,"stats":{"Line":1}},{"line":54,"address":[11665807],"length":1,"stats":{"Line":3}},{"line":55,"address":[11665841],"length":1,"stats":{"Line":4}},{"line":57,"address":[22356553],"length":1,"stats":{"Line":1}},{"line":58,"address":[22356573],"length":1,"stats":{"Line":1}},{"line":59,"address":[22143521,22143676],"length":1,"stats":{"Line":2}},{"line":61,"address":[11623778],"length":1,"stats":{"Line":1}},{"line":64,"address":[22261136,22261865,22261171,22261091,22261770,22261304,22261056,22261519],"length":1,"stats":{"Line":0}},{"line":65,"address":[22357983,22357715,22357834,22357763],"length":1,"stats":{"Line":0}},{"line":68,"address":[22261888],"length":1,"stats":{"Line":1}},{"line":73,"address":[16399791,16399973],"length":1,"stats":{"Line":2}},{"line":74,"address":[16400026,16400162],"length":1,"stats":{"Line":2}},{"line":75,"address":[16400018],"length":1,"stats":{"Line":1}},{"line":80,"address":[11532658],"length":1,"stats":{"Line":2}},{"line":81,"address":[11471848],"length":1,"stats":{"Line":4}},{"line":83,"address":[22360451,22360640,22360392,22360756,22360906,22360069],"length":1,"stats":{"Line":6}},{"line":84,"address":[22228721],"length":1,"stats":{"Line":1}},{"line":85,"address":[22358671,22360420,22360473,22360532,22360688,22360858],"length":1,"stats":{"Line":3}},{"line":87,"address":[22229272],"length":1,"stats":{"Line":2}},{"line":90,"address":[22229456],"length":1,"stats":{"Line":1}},{"line":95,"address":[22361319,22361550,22361247,22361969,22362196,22361424],"length":1,"stats":{"Line":2}},{"line":96,"address":[11584664],"length":1,"stats":{"Line":2}},{"line":98,"address":[15192999,15193302,15193357,15193528,15193656,15193761],"length":1,"stats":{"Line":5}},{"line":100,"address":[15193191],"length":1,"stats":{"Line":1}},{"line":101,"address":[11716238],"length":1,"stats":{"Line":3}},{"line":103,"address":[22150436,22150306],"length":1,"stats":{"Line":2}},{"line":104,"address":[22263132],"length":1,"stats":{"Line":1}},{"line":106,"address":[22150441,22150397],"length":1,"stats":{"Line":0}},{"line":112,"address":[22232272],"length":1,"stats":{"Line":1}},{"line":121,"address":[11667108],"length":1,"stats":{"Line":4}},{"line":122,"address":[22364989,22365069,22364817,22365309],"length":1,"stats":{"Line":4}},{"line":123,"address":[22165633],"length":1,"stats":{"Line":1}},{"line":124,"address":[11562603],"length":1,"stats":{"Line":3}},{"line":127,"address":[22159232],"length":1,"stats":{"Line":1}},{"line":136,"address":[22271323,22271176,22271762,22271446,22272034,22271242],"length":1,"stats":{"Line":2}},{"line":137,"address":[22160477,22160225,22160397,22160717],"length":1,"stats":{"Line":4}},{"line":138,"address":[22270209],"length":1,"stats":{"Line":1}},{"line":139,"address":[22160446,22159756,22160595,22160845,22160499],"length":1,"stats":{"Line":3}},{"line":142,"address":[16408543,16408701,16408905,16410541,16408496,16408448,16408756,16408466],"length":1,"stats":{"Line":4}},{"line":143,"address":[22367446],"length":1,"stats":{"Line":1}},{"line":144,"address":[22267206],"length":1,"stats":{"Line":1}},{"line":146,"address":[22162470],"length":1,"stats":{"Line":0}},{"line":147,"address":[22168536,22169078,22168299,22169527,22169642,22168716],"length":1,"stats":{"Line":5}},{"line":148,"address":[15198326],"length":1,"stats":{"Line":1}},{"line":149,"address":[22271766],"length":1,"stats":{"Line":1}},{"line":150,"address":[22273454],"length":1,"stats":{"Line":1}},{"line":154,"address":[22267260],"length":1,"stats":{"Line":1}},{"line":155,"address":[22272861],"length":1,"stats":{"Line":1}},{"line":157,"address":[22155716],"length":1,"stats":{"Line":1}},{"line":158,"address":[22155724],"length":1,"stats":{"Line":1}},{"line":159,"address":[22162520],"length":1,"stats":{"Line":1}},{"line":161,"address":[22367496,22368984,22367912,22367705,22368927,22368342],"length":1,"stats":{"Line":4}},{"line":163,"address":[15198633,15198426],"length":1,"stats":{"Line":2}},{"line":165,"address":[22273719,22273747],"length":1,"stats":{"Line":1}},{"line":169,"address":[22272132],"length":1,"stats":{"Line":0}},{"line":172,"address":[22162766],"length":1,"stats":{"Line":1}},{"line":175,"address":[22269088,22271181,22269183,22269136,22269106,22269545,22269396,22269341],"length":1,"stats":{"Line":4}},{"line":176,"address":[22273254],"length":1,"stats":{"Line":1}},{"line":177,"address":[22369814],"length":1,"stats":{"Line":1}},{"line":179,"address":[22270630],"length":1,"stats":{"Line":0}},{"line":180,"address":[22371079,22371194,22370630,22369851,22370268,22370088],"length":1,"stats":{"Line":5}},{"line":181,"address":[22171086],"length":1,"stats":{"Line":1}},{"line":182,"address":[22270070],"length":1,"stats":{"Line":1}},{"line":183,"address":[15200582],"length":1,"stats":{"Line":1}},{"line":187,"address":[15199992],"length":1,"stats":{"Line":1}},{"line":188,"address":[22156813],"length":1,"stats":{"Line":1}},{"line":190,"address":[22371028],"length":1,"stats":{"Line":1}},{"line":191,"address":[22157964],"length":1,"stats":{"Line":1}},{"line":192,"address":[22371048],"length":1,"stats":{"Line":1}},{"line":194,"address":[22163448,22164936,22163657,22164879,22163864,22164294],"length":1,"stats":{"Line":4}},{"line":196,"address":[22232018,22232233],"length":1,"stats":{"Line":2}},{"line":198,"address":[22239219,22239191],"length":1,"stats":{"Line":1}},{"line":202,"address":[22164516],"length":1,"stats":{"Line":0}},{"line":205,"address":[16412526],"length":1,"stats":{"Line":1}},{"line":208,"address":[22233234,22233299,22233465,22233626,22233264,22233894,22233216,22233425],"length":1,"stats":{"Line":0}},{"line":209,"address":[22271564,22271641,22271770,22271516],"length":1,"stats":{"Line":0}},{"line":212,"address":[22240915,22240850,22241023,22240832,22241063,22241227,22241710,22240880],"length":1,"stats":{"Line":4}},{"line":213,"address":[22241399,22241189,22241708,22241461,22241130,22241627,22241002,22241563],"length":1,"stats":{"Line":6}},{"line":214,"address":[22173357],"length":1,"stats":{"Line":1}},{"line":215,"address":[22234122,22234654,22234274,22234331,22234473,22234230],"length":1,"stats":{"Line":3}},{"line":216,"address":[22166818,22167013,22166992],"length":1,"stats":{"Line":3}},{"line":219,"address":[22278672],"length":1,"stats":{"Line":1}},{"line":224,"address":[22277418,22277858,22277628,22278066,22277231,22277791,22277680,22277359,22278534],"length":1,"stats":{"Line":6}},{"line":226,"address":[22278994],"length":1,"stats":{"Line":1}},{"line":227,"address":[22174399,22174930,22174551,22174750,22174608,22174507],"length":1,"stats":{"Line":3}},{"line":228,"address":[11631943,11631907],"length":1,"stats":{"Line":1}},{"line":230,"address":[16415670],"length":1,"stats":{"Line":1}},{"line":231,"address":[16415872,16415767],"length":1,"stats":{"Line":2}},{"line":232,"address":[22274784,22274802],"length":1,"stats":{"Line":2}},{"line":234,"address":[22278244],"length":1,"stats":{"Line":1}},{"line":235,"address":[22175368],"length":1,"stats":{"Line":1}},{"line":239,"address":[22175256],"length":1,"stats":{"Line":1}}],"covered":100,"coverable":112},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","default_topics.rs"],"content":"use std::collections::HashSet;\nuse tokio::sync::RwLock;\n\n/// 既定トピック集合を管理し、非同期アクセスを直列化するレジストリ。\npub struct DefaultTopicsRegistry {\n    topics: RwLock<HashSet<String>>,\n}\n\nimpl DefaultTopicsRegistry {\n    pub fn with_topics<I>(topics: I) -> Self\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut set = HashSet::new();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                set.insert(topic);\n            }\n        }\n        Self {\n            topics: RwLock::new(set),\n        }\n    }\n\n    pub async fn replace_with_single(&self, topic: String) {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        if !topic.trim().is_empty() {\n            guard.insert(topic);\n        }\n    }\n\n    pub async fn replace_all<I>(&self, topics: I)\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                guard.insert(topic);\n            }\n        }\n    }\n\n    pub async fn add(&self, topic: String) {\n        let normalized = topic.trim();\n        if normalized.is_empty() {\n            return;\n        }\n        let mut guard = self.topics.write().await;\n        guard.insert(normalized.to_string());\n    }\n\n    pub async fn remove(&self, topic: &str) {\n        let mut guard = self.topics.write().await;\n        guard.remove(topic);\n    }\n\n    pub async fn list(&self) -> Vec<String> {\n        let guard = self.topics.read().await;\n        guard.iter().cloned().collect()\n    }\n\n    pub async fn snapshot(&self) -> HashSet<String> {\n        let guard = self.topics.read().await;\n        guard.clone()\n    }\n}\n","traces":[{"line":10,"address":[16576554,16576582,16575680],"length":1,"stats":{"Line":4}},{"line":14,"address":[16532006],"length":1,"stats":{"Line":4}},{"line":15,"address":[16532346,16532201,16532292,16532100],"length":1,"stats":{"Line":16}},{"line":16,"address":[25701313,25701118],"length":1,"stats":{"Line":8}},{"line":17,"address":[16539575,16539631],"length":1,"stats":{"Line":8}},{"line":18,"address":[16570897,16570821],"length":1,"stats":{"Line":9}},{"line":22,"address":[16570518],"length":1,"stats":{"Line":5}},{"line":26,"address":[16575182,16575024,16575049,16575939,16574976,16574984,16575337],"length":1,"stats":{"Line":0}},{"line":27,"address":[16472283,16472384,16472329,16472489],"length":1,"stats":{"Line":0}},{"line":28,"address":[16571648,16571715],"length":1,"stats":{"Line":0}},{"line":29,"address":[16575662,16575766,16575832],"length":1,"stats":{"Line":0}},{"line":30,"address":[24234108,24234082],"length":1,"stats":{"Line":0}},{"line":34,"address":[16466286,16466160],"length":1,"stats":{"Line":4}},{"line":38,"address":[24234648,24234593,24234753,24234547],"length":1,"stats":{"Line":4}},{"line":39,"address":[16578347,16578280],"length":1,"stats":{"Line":4}},{"line":40,"address":[16673142,16673399,16673345],"length":1,"stats":{"Line":6}},{"line":41,"address":[16573209,16573071],"length":1,"stats":{"Line":4}},{"line":42,"address":[16474327,16474383],"length":1,"stats":{"Line":4}},{"line":43,"address":[25703877,25703904],"length":1,"stats":{"Line":4}},{"line":48,"address":[16579200,16579346,16579735,16579160,16579225,16579657,16580142,16579152],"length":1,"stats":{"Line":4}},{"line":49,"address":[16577793,16577672],"length":1,"stats":{"Line":2}},{"line":50,"address":[16579494],"length":1,"stats":{"Line":1}},{"line":53,"address":[16579767,16579533,16579575,16579373],"length":1,"stats":{"Line":2}},{"line":54,"address":[25704975,25704926],"length":1,"stats":{"Line":2}},{"line":57,"address":[16580882,16580160,16580379,16580178,16580208,16580233,16580499,16580342],"length":1,"stats":{"Line":4}},{"line":58,"address":[25705293,25705259,25705450,25705363],"length":1,"stats":{"Line":2}},{"line":59,"address":[25705658,25705710],"length":1,"stats":{"Line":2}},{"line":62,"address":[16579256,16579248,16579538,16579264,16580022,16579384,16579299,16579421],"length":1,"stats":{"Line":4}},{"line":63,"address":[11507524],"length":1,"stats":{"Line":2}},{"line":64,"address":[16581519,16581454],"length":1,"stats":{"Line":2}},{"line":67,"address":[16581731,16581970,16581680,16581688,16581816,16581853,16582379,16581696],"length":1,"stats":{"Line":0}},{"line":68,"address":[16545029,16545075,16545129,16545234],"length":1,"stats":{"Line":0}},{"line":69,"address":[16576648,16576715],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","event_id_mapper.rs"],"content":"use crate::domain::value_objects::EventId;\nuse crate::shared::{AppError, ValidationFailureKind};\n\npub(crate) fn parse_event_id(hex: &str) -> Result<EventId, AppError> {\n    EventId::from_hex(hex).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid event ID: {err}\"),\n        )\n    })\n}\n\npub(crate) fn parse_optional_event_id(hex: Option<&str>) -> Result<Option<EventId>, AppError> {\n    match hex {\n        Some(value) => parse_event_id(value).map(Some),\n        None => Ok(None),\n    }\n}\n\npub(crate) fn parse_event_ids(hexes: &[String]) -> Result<Vec<EventId>, AppError> {\n    hexes.iter().map(|value| parse_event_id(value)).collect()\n}\n","traces":[{"line":4,"address":[20818528],"length":1,"stats":{"Line":0}},{"line":5,"address":[20774896,20774856,20775115],"length":1,"stats":{"Line":0}},{"line":6,"address":[20817119],"length":1,"stats":{"Line":0}},{"line":7,"address":[20781845],"length":1,"stats":{"Line":0}},{"line":8,"address":[20774922,20774981],"length":1,"stats":{"Line":0}},{"line":13,"address":[20775152],"length":1,"stats":{"Line":0}},{"line":14,"address":[20813288],"length":1,"stats":{"Line":0}},{"line":15,"address":[23056486],"length":1,"stats":{"Line":0}},{"line":16,"address":[20707399],"length":1,"stats":{"Line":0}},{"line":20,"address":[20913792],"length":1,"stats":{"Line":0}},{"line":21,"address":[20775443,20775408,20775362],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","metadata_mapper.rs"],"content":"use crate::domain::entities::event_gateway::{PrivacyPreferences, ProfileMetadata, RelayEndpoint};\nuse crate::presentation::dto::event::{Nip65RelayDto, NostrMetadataDto};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse nostr_sdk::JsonUtil;\nuse nostr_sdk::prelude::{Metadata, Url};\nuse serde_json::{Map, Value};\n\npub(crate) fn dto_to_profile_metadata(dto: NostrMetadataDto) -> Result<ProfileMetadata, AppError> {\n    let relays = dto.relays.map(convert_relays).transpose()?;\n    let privacy = dto.privacy.map(|prefs| PrivacyPreferences {\n        public_profile: prefs.public_profile.unwrap_or(true),\n        show_online_status: prefs.show_online_status.unwrap_or(false),\n    });\n\n    ProfileMetadata::new(\n        dto.name,\n        dto.display_name,\n        dto.about,\n        dto.picture,\n        dto.banner,\n        dto.nip05,\n        dto.lud16,\n        dto.website,\n        relays,\n        privacy,\n    )\n    .map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid profile metadata: {err}\"),\n        )\n    })\n}\n\npub(crate) fn profile_metadata_to_nostr(metadata: &ProfileMetadata) -> Result<Metadata, AppError> {\n    if let Some(website) = metadata.website.as_ref() {\n        Url::parse(website).map_err(|_| {\n            AppError::validation(ValidationFailureKind::Generic, \"Invalid website URL\")\n        })?;\n    }\n\n    let mut map = Map::new();\n    if let Some(name) = metadata.name.as_ref() {\n        map.insert(\"name\".to_string(), Value::String(name.clone()));\n    }\n    if let Some(display_name) = metadata.display_name.as_ref() {\n        map.insert(\n            \"display_name\".to_string(),\n            Value::String(display_name.clone()),\n        );\n    }\n    if let Some(about) = metadata.about.as_ref() {\n        map.insert(\"about\".to_string(), Value::String(about.clone()));\n    }\n    if let Some(picture) = metadata.picture.as_ref() {\n        map.insert(\"picture\".to_string(), Value::String(picture.clone()));\n    }\n    if let Some(banner) = metadata.banner.as_ref() {\n        map.insert(\"banner\".to_string(), Value::String(banner.clone()));\n    }\n    if let Some(nip05) = metadata.nip05.as_ref() {\n        map.insert(\"nip05\".to_string(), Value::String(nip05.clone()));\n    }\n    if let Some(lud16) = metadata.lud16.as_ref() {\n        map.insert(\"lud16\".to_string(), Value::String(lud16.clone()));\n    }\n    if let Some(website) = metadata.website.as_ref() {\n        map.insert(\"website\".to_string(), Value::String(website.clone()));\n    }\n    if let Some(relays) = metadata.relays.as_ref() {\n        let relay_values = relays\n            .iter()\n            .map(|relay| {\n                let mut item = Map::new();\n                item.insert(\"url\".to_string(), Value::String(relay.url.clone()));\n                item.insert(\"read\".to_string(), Value::Bool(relay.read));\n                item.insert(\"write\".to_string(), Value::Bool(relay.write));\n                Value::Object(item)\n            })\n            .collect();\n        map.insert(\"relays\".to_string(), Value::Array(relay_values));\n    }\n    if let Some(privacy) = metadata.privacy.as_ref() {\n        let mut prefs = Map::new();\n        prefs.insert(\n            \"public_profile\".to_string(),\n            Value::Bool(privacy.public_profile),\n        );\n        prefs.insert(\n            \"show_online_status\".to_string(),\n            Value::Bool(privacy.show_online_status),\n        );\n        map.insert(\"kukuri_privacy\".to_string(), Value::Object(prefs));\n    }\n\n    Metadata::from_json(Value::Object(map).to_string())\n        .map_err(|err| AppError::NostrError(err.to_string()))\n}\n\nfn convert_relays(relays: Vec<Nip65RelayDto>) -> Result<Vec<RelayEndpoint>, AppError> {\n    relays\n        .into_iter()\n        .map(|relay| {\n            RelayEndpoint::new(relay.url, relay.read, relay.write)\n                .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn dto_relays_are_converted_into_domain() {\n        let dto = NostrMetadataDto {\n            name: None,\n            display_name: None,\n            about: None,\n            picture: None,\n            banner: None,\n            nip05: None,\n            lud16: None,\n            website: None,\n            relays: Some(vec![Nip65RelayDto {\n                url: \"wss://relay.example\".to_string(),\n                read: true,\n                write: false,\n            }]),\n            privacy: None,\n        };\n\n        let metadata = dto_to_profile_metadata(dto).expect(\"metadata conversion\");\n        let relay = metadata\n            .relays\n            .and_then(|mut list| list.pop())\n            .expect(\"relay entry\");\n        assert_eq!(relay.url, \"wss://relay.example\");\n        assert!(relay.read);\n        assert!(!relay.write);\n    }\n\n    #[test]\n    fn profile_metadata_includes_relays_in_json() {\n        let relay = RelayEndpoint::new(\"wss://relay.example\".to_string(), true, false).unwrap();\n        let metadata = ProfileMetadata::new(\n            Some(\"name\".into()),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(vec![relay]),\n            None,\n        )\n        .expect(\"valid metadata\");\n\n        let nostr = profile_metadata_to_nostr(&metadata).expect(\"nostr metadata\");\n        let json_value: serde_json::Value =\n            serde_json::from_str(&nostr.as_json()).expect(\"valid json\");\n        let relays = json_value\n            .get(\"relays\")\n            .and_then(|value| value.as_array())\n            .expect(\"relays array\");\n        assert_eq!(relays.len(), 1);\n        let entry = relays[0].as_object().expect(\"relay object\");\n        assert_eq!(entry.get(\"url\").unwrap(), &json!(\"wss://relay.example\"));\n        assert_eq!(entry.get(\"read\").unwrap(), &json!(true));\n        assert_eq!(entry.get(\"write\").unwrap(), &json!(false));\n    }\n\n    #[test]\n    fn profile_metadata_includes_privacy_settings_in_json() {\n        let metadata = ProfileMetadata::new(\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(PrivacyPreferences {\n                public_profile: false,\n                show_online_status: true,\n            }),\n        )\n        .expect(\"valid metadata\");\n\n        let nostr = profile_metadata_to_nostr(&metadata).expect(\"nostr metadata\");\n        let json_value: serde_json::Value =\n            serde_json::from_str(&nostr.as_json()).expect(\"valid json\");\n        let privacy = json_value\n            .get(\"kukuri_privacy\")\n            .and_then(|value| value.as_object())\n            .expect(\"privacy object\");\n        assert_eq!(privacy.get(\"public_profile\").unwrap(), &json!(false));\n        assert_eq!(privacy.get(\"show_online_status\").unwrap(), &json!(true));\n    }\n}\n","traces":[{"line":8,"address":[13494902,13495381,13493840],"length":1,"stats":{"Line":1}},{"line":9,"address":[13600016,13600194,13599782],"length":1,"stats":{"Line":2}},{"line":10,"address":[23057089,23058480,23057243],"length":1,"stats":{"Line":2}},{"line":11,"address":[13605526],"length":1,"stats":{"Line":0}},{"line":12,"address":[13701995],"length":1,"stats":{"Line":0}},{"line":16,"address":[23057257],"length":1,"stats":{"Line":1}},{"line":17,"address":[23057288],"length":1,"stats":{"Line":1}},{"line":18,"address":[13600396],"length":1,"stats":{"Line":1}},{"line":19,"address":[13606012],"length":1,"stats":{"Line":1}},{"line":20,"address":[13494540],"length":1,"stats":{"Line":1}},{"line":21,"address":[13494572],"length":1,"stats":{"Line":1}},{"line":22,"address":[21262799],"length":1,"stats":{"Line":1}},{"line":23,"address":[13569381],"length":1,"stats":{"Line":1}},{"line":24,"address":[13604539],"length":1,"stats":{"Line":1}},{"line":27,"address":[13563755,13563536],"length":1,"stats":{"Line":0}},{"line":28,"address":[13495903],"length":1,"stats":{"Line":0}},{"line":29,"address":[13563557],"length":1,"stats":{"Line":0}},{"line":30,"address":[13607317,13607258],"length":1,"stats":{"Line":0}},{"line":35,"address":[23063332,23058800,23059687],"length":1,"stats":{"Line":1}},{"line":36,"address":[13496034],"length":1,"stats":{"Line":1}},{"line":37,"address":[13503164,13503423,13503317,13507568],"length":1,"stats":{"Line":0}},{"line":38,"address":[23063395],"length":1,"stats":{"Line":0}},{"line":42,"address":[13571026],"length":1,"stats":{"Line":1}},{"line":43,"address":[13606389,13606175],"length":1,"stats":{"Line":2}},{"line":44,"address":[13571330,13571403],"length":1,"stats":{"Line":2}},{"line":46,"address":[13490107,13489849],"length":1,"stats":{"Line":2}},{"line":47,"address":[13564941],"length":1,"stats":{"Line":0}},{"line":48,"address":[23059765,23059838],"length":1,"stats":{"Line":0}},{"line":49,"address":[13497093,13497033],"length":1,"stats":{"Line":0}},{"line":52,"address":[13703279,13703528],"length":1,"stats":{"Line":2}},{"line":53,"address":[13608805,13608878],"length":1,"stats":{"Line":0}},{"line":55,"address":[13497340,13497589],"length":1,"stats":{"Line":2}},{"line":56,"address":[21265842,21265915],"length":1,"stats":{"Line":0}},{"line":58,"address":[13572425,13572674],"length":1,"stats":{"Line":2}},{"line":59,"address":[13607855,13607925],"length":1,"stats":{"Line":0}},{"line":61,"address":[13603958,13604201],"length":1,"stats":{"Line":2}},{"line":62,"address":[13505385,13505315],"length":1,"stats":{"Line":0}},{"line":64,"address":[13609882,13610125],"length":1,"stats":{"Line":2}},{"line":65,"address":[13705037,13704967],"length":1,"stats":{"Line":0}},{"line":67,"address":[13610465,13610222],"length":1,"stats":{"Line":2}},{"line":68,"address":[13566897,13566827],"length":1,"stats":{"Line":0}},{"line":70,"address":[13605221,13604978,13605646],"length":1,"stats":{"Line":3}},{"line":71,"address":[13605274,13605339],"length":1,"stats":{"Line":2}},{"line":73,"address":[13508257,13507632],"length":1,"stats":{"Line":1}},{"line":74,"address":[13706982],"length":1,"stats":{"Line":1}},{"line":75,"address":[13493928,13494002,13494478],"length":1,"stats":{"Line":2}},{"line":76,"address":[13494160],"length":1,"stats":{"Line":1}},{"line":77,"address":[13568863],"length":1,"stats":{"Line":1}},{"line":78,"address":[13612680],"length":1,"stats":{"Line":1}},{"line":81,"address":[13499580,13499508],"length":1,"stats":{"Line":2}},{"line":83,"address":[21267575,21267950,21268586],"length":1,"stats":{"Line":3}},{"line":84,"address":[13506800],"length":1,"stats":{"Line":1}},{"line":85,"address":[23062730,23062866],"length":1,"stats":{"Line":2}},{"line":86,"address":[13605869],"length":1,"stats":{"Line":1}},{"line":87,"address":[13500026],"length":1,"stats":{"Line":1}},{"line":89,"address":[13706479],"length":1,"stats":{"Line":1}},{"line":90,"address":[13609959],"length":1,"stats":{"Line":1}},{"line":91,"address":[23062928],"length":1,"stats":{"Line":1}},{"line":93,"address":[13507193],"length":1,"stats":{"Line":1}},{"line":96,"address":[23063270,23062620],"length":1,"stats":{"Line":2}},{"line":97,"address":[23064096,23063300,23064114,23063210],"length":1,"stats":{"Line":1}},{"line":100,"address":[13611328],"length":1,"stats":{"Line":1}},{"line":101,"address":[13501486],"length":1,"stats":{"Line":1}},{"line":103,"address":[13494768],"length":1,"stats":{"Line":1}},{"line":104,"address":[23064339],"length":1,"stats":{"Line":1}},{"line":105,"address":[13707967,13707952],"length":1,"stats":{"Line":0}}],"covered":48,"coverable":66},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","mod.rs"],"content":"pub(crate) mod event_id_mapper;\npub(crate) mod metadata_mapper;\npub(crate) mod nostr_to_domain;\n\npub(crate) use event_id_mapper::{parse_event_id, parse_event_ids, parse_optional_event_id};\npub(crate) use metadata_mapper::{dto_to_profile_metadata, profile_metadata_to_nostr};\npub(crate) use nostr_to_domain::{\n    domain_event_from_event, domain_event_to_nostr_event, nostr_event_to_domain_event,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","nostr_to_domain.rs"],"content":"use crate::application::shared::nostr::to_nostr_event;\nuse crate::domain::entities::Event;\nuse crate::domain::entities::event_gateway::DomainEvent;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, Utc};\nuse nostr_sdk::prelude::Event as NostrEvent;\n\npub(crate) fn domain_event_from_event(event: &Event) -> Result<DomainEvent, AppError> {\n    DomainEvent::try_from(event).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid domain event: {err}\"),\n        )\n    })\n}\n\npub(crate) fn domain_event_to_nostr_event(\n    domain_event: &DomainEvent,\n) -> Result<nostr_sdk::Event, AppError> {\n    to_nostr_event(&domain_event.to_event())\n}\n\npub(crate) fn nostr_event_to_domain_event(event: &NostrEvent) -> Result<Event, AppError> {\n    let id = EventId::from_hex(&event.id.to_string()).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid event ID received from gateway: {err}\"),\n        )\n    })?;\n\n    let created_at = DateTime::<Utc>::from_timestamp(event.created_at.as_secs() as i64, 0)\n        .ok_or_else(|| {\n            AppError::validation(ValidationFailureKind::Generic, \"Invalid event timestamp\")\n        })?;\n\n    let tags = event.tags.iter().map(|tag| tag.clone().to_vec()).collect();\n\n    let event = Event::new_with_id(\n        id,\n        event.pubkey.to_string(),\n        event.content.clone(),\n        event.kind.as_u16() as u32,\n        tags,\n        created_at,\n        event.sig.to_string(),\n    );\n    event\n        .validate_for_gateway()\n        .map_err(|err| AppError::validation(err.kind, err.message))?;\n    Ok(event)\n}\n","traces":[{"line":9,"address":[19767040],"length":1,"stats":{"Line":0}},{"line":10,"address":[19655560,19655819,19655600],"length":1,"stats":{"Line":0}},{"line":11,"address":[25707455],"length":1,"stats":{"Line":0}},{"line":12,"address":[19765477],"length":1,"stats":{"Line":0}},{"line":13,"address":[19767130,19767189],"length":1,"stats":{"Line":0}},{"line":18,"address":[19730592,19730717],"length":1,"stats":{"Line":1}},{"line":21,"address":[19662856],"length":1,"stats":{"Line":1}},{"line":24,"address":[19864079,19862304,19864229],"length":1,"stats":{"Line":2}},{"line":25,"address":[19726027,19725808,19723854,19724004,19724243],"length":1,"stats":{"Line":4}},{"line":26,"address":[19769679],"length":1,"stats":{"Line":0}},{"line":27,"address":[25709589],"length":1,"stats":{"Line":0}},{"line":28,"address":[19732821,19732762],"length":1,"stats":{"Line":0}},{"line":32,"address":[19766366,19766591,19767766],"length":1,"stats":{"Line":2}},{"line":33,"address":[19768112],"length":1,"stats":{"Line":0}},{"line":34,"address":[19726076],"length":1,"stats":{"Line":0}},{"line":37,"address":[19651536,19649881,19649990,19651582],"length":1,"stats":{"Line":6}},{"line":40,"address":[13904357],"length":1,"stats":{"Line":2}},{"line":41,"address":[19863170,19863239],"length":1,"stats":{"Line":4}},{"line":42,"address":[19731695,19731761],"length":1,"stats":{"Line":4}},{"line":43,"address":[19768537,19768604],"length":1,"stats":{"Line":4}},{"line":44,"address":[25708715],"length":1,"stats":{"Line":2}},{"line":46,"address":[25708763],"length":1,"stats":{"Line":2}},{"line":48,"address":[19664374,19664644,19664445],"length":1,"stats":{"Line":4}},{"line":50,"address":[19768272,19768283,19767476],"length":1,"stats":{"Line":0}},{"line":51,"address":[13905068],"length":1,"stats":{"Line":2}}],"covered":14,"coverable":25},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","events.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_event_row(row: &SqliteRow) -> Result<Event, AppError> {\n    let event_id_hex: String = row.try_get(\"event_id\")?;\n    let event_id = EventId::from_hex(event_id_hex.as_str())?;\n    let kind = row.try_get::<i64, _>(\"kind\")? as u32;\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n    let tags = parse_event_tags(&tags_json);\n\n    Ok(Event::new_with_id(\n        event_id,\n        row.try_get(\"public_key\")?,\n        row.try_get(\"content\")?,\n        kind,\n        tags,\n        created_at,\n        row.try_get(\"sig\")?,\n    ))\n}\n\npub(crate) fn parse_event_tags(tags_json: &str) -> Vec<Vec<String>> {\n    serde_json::from_str(tags_json).unwrap_or_default()\n}\n","traces":[{"line":7,"address":[16548381,16545632,16548862],"length":1,"stats":{"Line":0}},{"line":8,"address":[16464142,16464344],"length":1,"stats":{"Line":0}},{"line":9,"address":[16677691,16677521,16677399,16680412],"length":1,"stats":{"Line":0}},{"line":10,"address":[16583913,16581491,16581223,16581361],"length":1,"stats":{"Line":0}},{"line":11,"address":[26506677,26504406,26504301],"length":1,"stats":{"Line":0}},{"line":13,"address":[16465142],"length":1,"stats":{"Line":0}},{"line":14,"address":[16546728,16546807],"length":1,"stats":{"Line":0}},{"line":16,"address":[16679568,16679249],"length":1,"stats":{"Line":0}},{"line":17,"address":[26504769],"length":1,"stats":{"Line":0}},{"line":18,"address":[16479115,16479190,16479365],"length":1,"stats":{"Line":0}},{"line":19,"address":[16547089,16547246,16547473],"length":1,"stats":{"Line":0}},{"line":21,"address":[16547389],"length":1,"stats":{"Line":0}},{"line":23,"address":[16466074,16466321,16465917],"length":1,"stats":{"Line":0}},{"line":27,"address":[16474144],"length":1,"stats":{"Line":0}},{"line":28,"address":[16580087],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","mod.rs"],"content":"pub(crate) mod event;\npub(crate) mod events;\npub(crate) mod posts;\npub(crate) mod topics;\npub(crate) mod users;\n\npub(crate) use event::{\n    domain_event_from_event, domain_event_to_nostr_event, dto_to_profile_metadata,\n    nostr_event_to_domain_event, parse_event_id, parse_event_ids, parse_optional_event_id,\n    profile_metadata_to_nostr,\n};\npub(crate) use events::map_event_row;\npub(crate) use posts::map_post_row;\npub(crate) use topics::{map_joined_topic_row, map_topic_row};\npub(crate) use users::map_user_row;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","posts.rs"],"content":"use crate::domain::entities::{Post, User};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_post_row(\n    row: &SqliteRow,\n    fallback_topic: Option<&str>,\n) -> Result<Post, AppError> {\n    let event_id: String = row.try_get(\"event_id\")?;\n    let public_key: String = row.try_get(\"public_key\")?;\n    let content: String = row.try_get(\"content\")?;\n    let created_at: i64 = row.try_get(\"created_at\")?;\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n\n    let topic_id = fallback_topic\n        .map(|id| id.to_string())\n        .or_else(|| extract_topic_from_tags(&tags_json))\n        .unwrap_or_default();\n\n    let user = User::from_pubkey(&public_key);\n    let created_at = DateTime::from_timestamp_millis(created_at).unwrap_or_else(Utc::now);\n\n    let scope = extract_scope_from_tags(&tags_json);\n    let epoch = extract_epoch_from_tags(&tags_json);\n\n    let mut post = Post::new_with_id(event_id, content, user, topic_id, created_at);\n    post.scope = scope;\n    post.epoch = epoch;\n    Ok(post)\n}\n\npub(crate) fn extract_topic_from_tags(tags_json: &str) -> Option<String> {\n    let tags = serde_json::from_str::<Vec<Vec<String>>>(tags_json).ok()?;\n    tags.into_iter().find_map(|tag| match tag.as_slice() {\n        [key, value, ..] if key == \"t\" => Some(value.clone()),\n        _ => None,\n    })\n}\n\nfn extract_tag_value(tags_json: &str, target: &str) -> Option<String> {\n    let tags = serde_json::from_str::<Vec<Vec<String>>>(tags_json).ok()?;\n    tags.into_iter().find_map(|tag| match tag.as_slice() {\n        [key, value, ..] if key == target => Some(value.clone()),\n        _ => None,\n    })\n}\n\nfn extract_scope_from_tags(tags_json: &str) -> Option<String> {\n    extract_tag_value(tags_json, \"scope\")\n}\n\nfn extract_epoch_from_tags(tags_json: &str) -> Option<i64> {\n    extract_tag_value(tags_json, \"epoch\").and_then(|value| value.parse::<i64>().ok())\n}\n","traces":[{"line":6,"address":[16467424,16469795,16469971],"length":1,"stats":{"Line":1}},{"line":10,"address":[25710100,25710329],"length":1,"stats":{"Line":1}},{"line":11,"address":[16582660,16580707,16580531,16580399],"length":1,"stats":{"Line":2}},{"line":12,"address":[16542553,16542716,16544530,16542897],"length":1,"stats":{"Line":2}},{"line":13,"address":[16468423,16468266,16468553],"length":1,"stats":{"Line":4}},{"line":14,"address":[16468514,16468630],"length":1,"stats":{"Line":3}},{"line":16,"address":[16586958,16587021],"length":1,"stats":{"Line":2}},{"line":17,"address":[16683088,16683110],"length":1,"stats":{"Line":2}},{"line":18,"address":[16683136,16683154],"length":1,"stats":{"Line":2}},{"line":21,"address":[16681883,16681951],"length":1,"stats":{"Line":2}},{"line":22,"address":[16475703,16475748],"length":1,"stats":{"Line":2}},{"line":24,"address":[16475790],"length":1,"stats":{"Line":2}},{"line":25,"address":[16482824,16482892],"length":1,"stats":{"Line":2}},{"line":27,"address":[16475975],"length":1,"stats":{"Line":1}},{"line":28,"address":[16586080,16586225],"length":1,"stats":{"Line":3}},{"line":29,"address":[16483377],"length":1,"stats":{"Line":1}},{"line":30,"address":[16582379],"length":1,"stats":{"Line":2}},{"line":33,"address":[16545118,16544720],"length":1,"stats":{"Line":1}},{"line":34,"address":[24245136,24245338],"length":1,"stats":{"Line":1}},{"line":35,"address":[25712838,25713139,25713104,25713378,25712975],"length":1,"stats":{"Line":8}},{"line":36,"address":[16545295,16545264,16545414],"length":1,"stats":{"Line":6}},{"line":37,"address":[16470683],"length":1,"stats":{"Line":0}},{"line":41,"address":[24246275,24245856],"length":1,"stats":{"Line":1}},{"line":42,"address":[25713450,25713655],"length":1,"stats":{"Line":2}},{"line":43,"address":[16684456,16684696,16684137,16684416,16684266],"length":1,"stats":{"Line":6}},{"line":44,"address":[24246421,24246572,24246457],"length":1,"stats":{"Line":4}},{"line":45,"address":[16546048],"length":1,"stats":{"Line":1}},{"line":49,"address":[16589936],"length":1,"stats":{"Line":1}},{"line":50,"address":[16471669],"length":1,"stats":{"Line":2}},{"line":53,"address":[16478480],"length":1,"stats":{"Line":2}},{"line":54,"address":[16546308,16546377,16546368],"length":1,"stats":{"Line":3}}],"covered":30,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","topics.rs"],"content":"use crate::domain::entities::{Topic, TopicVisibility};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    base_topic_from_row(row)\n}\n\npub(crate) fn map_joined_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let mut topic = base_topic_from_row(row)?;\n    topic.is_joined = true;\n    Ok(topic)\n}\n\nfn base_topic_from_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let description = row\n        .try_get::<Option<String>, _>(\"description\")?\n        .unwrap_or_default();\n    let mut topic = Topic::new_with_id(\n        row.try_get(\"topic_id\")?,\n        row.try_get(\"name\")?,\n        description,\n        created_at,\n    );\n    topic.updated_at =\n        DateTime::from_timestamp_millis(row.try_get(\"updated_at\")?).unwrap_or(created_at);\n    topic.member_count = row.try_get::<i64, _>(\"member_count\")? as u32;\n    topic.post_count = row.try_get::<i64, _>(\"post_count\")? as u32;\n    topic.visibility = match row.try_get::<String, _>(\"visibility\")?.as_str() {\n        \"private\" => TopicVisibility::Private,\n        _ => TopicVisibility::Public,\n    };\n    Ok(topic)\n}\n","traces":[{"line":6,"address":[14314368],"length":1,"stats":{"Line":0}},{"line":7,"address":[12962433],"length":1,"stats":{"Line":0}},{"line":10,"address":[14277632],"length":1,"stats":{"Line":0}},{"line":11,"address":[14312952,14312777],"length":1,"stats":{"Line":0}},{"line":12,"address":[21971232],"length":1,"stats":{"Line":0}},{"line":13,"address":[14308968],"length":1,"stats":{"Line":0}},{"line":16,"address":[14411984,14411846,14409456],"length":1,"stats":{"Line":0}},{"line":17,"address":[12962750],"length":1,"stats":{"Line":0}},{"line":19,"address":[14314986,14315118,14314844],"length":1,"stats":{"Line":0}},{"line":23,"address":[14271360,14271664,14271489],"length":1,"stats":{"Line":0}},{"line":24,"address":[12963362,12963733,12963511],"length":1,"stats":{"Line":0}},{"line":25,"address":[14278811],"length":1,"stats":{"Line":0}},{"line":28,"address":[14314504],"length":1,"stats":{"Line":0}},{"line":29,"address":[14315913,14317096,14315838],"length":1,"stats":{"Line":0}},{"line":30,"address":[14279571,14279414,14280326],"length":1,"stats":{"Line":0}},{"line":31,"address":[14411876,14411326,14411087,14411200],"length":1,"stats":{"Line":0}},{"line":32,"address":[14314971,14315423,14314858,14315309],"length":1,"stats":{"Line":0}},{"line":33,"address":[14273210,14273253],"length":1,"stats":{"Line":0}},{"line":34,"address":[14311355],"length":1,"stats":{"Line":0}},{"line":36,"address":[21973680],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","users.rs"],"content":"use crate::domain::entities::{User, UserProfile};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_user_row(row: &SqliteRow) -> Result<User, AppError> {\n    let profile = UserProfile {\n        display_name: row.try_get(\"display_name\").unwrap_or_default(),\n        bio: row.try_get(\"bio\").unwrap_or_default(),\n        avatar_url: row.try_get(\"avatar_url\").ok(),\n    };\n\n    let mut user = User::new_with_profile(row.try_get(\"npub\")?, profile);\n    user.pubkey = row.try_get(\"pubkey\")?;\n    user.public_profile = row.try_get::<i64, _>(\"is_profile_public\").unwrap_or(1) != 0;\n    user.show_online_status = row.try_get::<i64, _>(\"show_online_status\").unwrap_or(0) != 0;\n\n    if let Ok(created_at_ms) = row.try_get::<i64, _>(\"created_at\") {\n        if let Some(timestamp) = DateTime::<Utc>::from_timestamp_millis(created_at_ms) {\n            user.created_at = timestamp;\n        }\n    }\n    if let Ok(updated_at_ms) = row.try_get::<i64, _>(\"updated_at\") {\n        if let Some(timestamp) = DateTime::<Utc>::from_timestamp_millis(updated_at_ms) {\n            user.updated_at = timestamp;\n        }\n    }\n\n    Ok(user)\n}\n","traces":[{"line":6,"address":[16896022,16895651,16894032],"length":1,"stats":{"Line":2}},{"line":8,"address":[16812550],"length":1,"stats":{"Line":1}},{"line":9,"address":[17025761,17025693],"length":1,"stats":{"Line":3}},{"line":10,"address":[16929433,16929361],"length":1,"stats":{"Line":3}},{"line":13,"address":[23915976,23917390,23915908],"length":1,"stats":{"Line":3}},{"line":14,"address":[16813282,16813357],"length":1,"stats":{"Line":3}},{"line":15,"address":[16895187],"length":1,"stats":{"Line":1}},{"line":16,"address":[17026820],"length":1,"stats":{"Line":2}},{"line":18,"address":[23916777],"length":1,"stats":{"Line":1}},{"line":19,"address":[16827751,16827678],"length":1,"stats":{"Line":3}},{"line":20,"address":[16895566],"length":1,"stats":{"Line":2}},{"line":23,"address":[16895620,16895660],"length":1,"stats":{"Line":3}},{"line":24,"address":[16814272,16814199],"length":1,"stats":{"Line":3}},{"line":25,"address":[16821111],"length":1,"stats":{"Line":1}},{"line":29,"address":[16927080],"length":1,"stats":{"Line":2}}],"covered":15,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mod.rs"],"content":"pub mod default_topics;\npub mod mappers;\npub mod nostr;\n#[doc(hidden)]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","factory.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::shared::error::AppError;\nuse nostr_sdk::JsonUtil;\nuse serde_json::json;\n\npub fn build_deletion_event(id: &str, pubkey: String) -> Event {\n    let mut deletion_event = Event::new(EventKind::EventDeletion.as_u32(), String::new(), pubkey);\n    deletion_event.add_e_tag(id.to_string());\n    deletion_event\n}\n\npub fn to_nostr_event(event: &Event) -> Result<nostr_sdk::Event, AppError> {\n    let event_json = json!({\n        \"id\": event.id,\n        \"pubkey\": event.pubkey,\n        \"created_at\": event.created_at.timestamp(),\n        \"kind\": event.kind,\n        \"tags\": event.tags,\n        \"content\": event.content,\n        \"sig\": event.sig,\n    });\n\n    nostr_sdk::Event::from_json(event_json.to_string())\n        .map_err(|e| AppError::NostrError(format!(\"Failed to convert event: {e}\")))\n}\n","traces":[{"line":6,"address":[12694583,12694224],"length":1,"stats":{"Line":0}},{"line":7,"address":[12725456,12725561],"length":1,"stats":{"Line":0}},{"line":8,"address":[12731294,12731234],"length":1,"stats":{"Line":0}},{"line":9,"address":[12626795],"length":1,"stats":{"Line":0}},{"line":12,"address":[20388080,20389964],"length":1,"stats":{"Line":3}},{"line":13,"address":[12695311,12696530,12694654,12695258],"length":1,"stats":{"Line":6}},{"line":16,"address":[12695303,12695239],"length":1,"stats":{"Line":6}},{"line":23,"address":[12827923,12827985],"length":1,"stats":{"Line":6}},{"line":24,"address":[23919886,23919856],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","mod.rs"],"content":"pub mod factory;\npub mod publisher;\n\npub use factory::*;\npub use publisher::EventPublisher;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","publisher.rs"],"content":"use anyhow::Result;\r\nuse nostr_sdk::prelude::*;\r\nuse tracing::{debug, info};\r\n\r\n/// Nostr イベントの生成を担う共通パブリッシャー。\r\n#[derive(Default)]\r\npub struct EventPublisher {\r\n    keys: Option<Keys>,\r\n}\r\n\r\nimpl EventPublisher {\r\n    /// 新しい EventPublisher インスタンスを作成\r\n    pub fn new() -> Self {\r\n        Self::default()\r\n    }\r\n\r\n    /// 鍵を設定\r\n    pub fn set_keys(&mut self, keys: Keys) {\r\n        self.keys = Some(keys);\r\n    }\r\n\r\n    /// テキストノートイベントを作成\r\n    pub fn create_text_note(&self, content: &str, tags: Vec<Tag>) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::text_note(content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created text note event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// メタデータイベントを作成\r\n    pub fn create_metadata(&self, metadata: Metadata) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::metadata(&metadata).sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created metadata event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// リアクションイベントを作成\r\n    pub fn create_reaction(&self, event_id: &EventId, reaction: &str) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        // リアクションイベント用のタグを作成\r\n        let tags = vec![Tag::event(*event_id), Tag::public_key(keys.public_key())];\r\n\r\n        let event = EventBuilder::new(Kind::Reaction, reaction)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created reaction event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n    pub fn create_repost(&self, event_id: &EventId) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::new(Kind::Repost, \"\")\r\n            .tag(Tag::event(*event_id))\r\n            .sign_with_keys(keys)?;\r\n\r\n        info!(\"Created repost event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// 削除イベントを作成\r\n    pub fn create_deletion(&self, event_ids: Vec<EventId>, reason: Option<&str>) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        // 削除イベント用のタグを作成\r\n        let tags: Vec<Tag> = event_ids.iter().map(|id| Tag::event(*id)).collect();\r\n\r\n        let content = reason.unwrap_or(\"\");\r\n\r\n        let event = EventBuilder::new(Kind::EventDeletion, content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created deletion event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// トピック投稿イベントを作成（kukuri 独自実装）\r\n    pub fn create_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\r\n        let mut tags = vec![\r\n            Tag::hashtag(topic_id),\r\n            Tag::custom(TagKind::Custom(\"topic\".into()), vec![topic_id.to_string()]),\r\n        ];\r\n\r\n        if let Some(reply_id) = reply_to {\n            tags.push(Tag::event(reply_id));\n            tags.push(Tag::custom(\n                TagKind::Custom(\"reply\".into()),\n                vec![reply_id.to_string()],\n            ));\n        }\n\n        if let Some(scope) = scope {\n            tags.push(Tag::parse([\"scope\", scope])?);\n        }\n        if let Some(epoch) = epoch {\n            let epoch_value = epoch.to_string();\n            tags.push(Tag::parse([\"epoch\", epoch_value.as_str()])?);\n        }\n\r\n        let event = EventBuilder::text_note(content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        info!(\"Created topic post for topic: {}\", topic_id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// 公開鍵を取得\r\n    pub fn get_public_key(&self) -> Option<PublicKey> {\r\n        self.keys.as_ref().map(|k| k.public_key())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_event_publisher_creation() {\r\n        let publisher = EventPublisher::new();\r\n        assert!(publisher.keys.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_set_keys() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        let public_key = keys.public_key();\r\n\r\n        publisher.set_keys(keys);\r\n        assert_eq!(publisher.get_public_key(), Some(public_key));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_text_note() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event = publisher.create_text_note(\"Hello, Nostr!\", vec![]).unwrap();\r\n        assert_eq!(event.content, \"Hello, Nostr!\");\r\n        assert_eq!(event.kind, Kind::TextNote);\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_text_note_with_tags() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let tags = vec![Tag::hashtag(\"nostr\"), Tag::hashtag(\"test\")];\r\n\r\n        let event = publisher\r\n            .create_text_note(\"Hello with tags!\", tags.clone())\r\n            .unwrap();\r\n        assert_eq!(event.content, \"Hello with tags!\");\r\n\r\n        // タグが含まれていることを確認\r\n        let event_tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"nostr\")));\r\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"test\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_metadata() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let metadata = Metadata::new()\r\n            .name(\"Test User\")\r\n            .about(\"Test about\")\r\n            .picture(Url::parse(\"https://example.com/pic.jpg\").unwrap());\r\n\r\n        let event = publisher.create_metadata(metadata).unwrap();\r\n        assert_eq!(event.kind, Kind::Metadata);\r\n        assert!(event.content.contains(\"Test User\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_repost() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event_id = EventId::from_slice(&[4; 32]).unwrap();\r\n        let event = publisher.create_repost(&event_id).unwrap();\r\n        assert_eq!(event.kind, Kind::Repost);\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_reaction() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys.clone());\r\n\r\n        let event_id = EventId::from_slice(&[1; 32]).unwrap();\r\n        let event = publisher.create_reaction(&event_id, \"+\").unwrap();\r\n\r\n        assert_eq!(event.kind, Kind::Reaction);\r\n        assert_eq!(event.content, \"+\");\r\n\r\n        // タグにイベントIDが含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id: id, .. }) if id == &event_id)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_deletion() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event_ids = vec![\r\n            EventId::from_slice(&[1; 32]).unwrap(),\r\n            EventId::from_slice(&[2; 32]).unwrap(),\r\n        ];\r\n\r\n        let event = publisher\r\n            .create_deletion(event_ids.clone(), Some(\"Spam\"))\r\n            .unwrap();\r\n        assert_eq!(event.kind, Kind::EventDeletion);\r\n        assert_eq!(event.content, \"Spam\");\r\n\r\n        // 削除対象のイベントIDが含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        for id in &event_ids {\r\n            assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == id)));\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_topic_post() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event = publisher\n            .create_topic_post(\"bitcoin\", \"Let's discuss Bitcoin!\", None, None, None)\n            .unwrap();\n        assert!(event.content.contains(\"Let's discuss Bitcoin!\"));\r\n\r\n        // タグを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"bitcoin\")));\r\n        assert!(\r\n            tags.iter()\r\n                .any(|t| t.kind().to_string() == \"topic\" && t.content().is_some())\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_topic_post_with_reply() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let reply_to = EventId::from_slice(&[3; 32]).unwrap();\r\n        let event = publisher\n            .create_topic_post(\"nostr\", \"Reply to thread\", Some(reply_to), None, None)\n            .unwrap();\n\r\n        // タグにリプライ情報が含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == &reply_to)));\r\n        assert!(\r\n            tags.iter()\r\n                .any(|t| t.kind().to_string() == \"reply\" && t.content().is_some())\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_keys_error() {\r\n        let publisher = EventPublisher::new();\r\n\r\n        // 鍵が設定されていない状態で各メソッドを呼び出すとエラーになることを確認\r\n        assert!(publisher.create_text_note(\"test\", vec![]).is_err());\r\n        assert!(publisher.create_metadata(Metadata::new()).is_err());\r\n        assert!(\r\n            publisher\r\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\r\n                .is_err()\r\n        );\r\n        assert!(publisher.create_deletion(vec![], None).is_err());\n        assert!(\n            publisher\n                .create_topic_post(\"topic\", \"content\", None, None, None)\n                .is_err()\n        );\n    }\r\n\r\n    #[test]\r\n    fn test_event_signature_verification() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        // 各種イベントを作成して署名が正しいことを確認\r\n        let events = vec![\r\n            publisher.create_text_note(\"test\", vec![]).unwrap(),\r\n            publisher\r\n                .create_metadata(Metadata::new().name(\"test\"))\r\n                .unwrap(),\r\n            publisher\r\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\r\n                .unwrap(),\r\n            publisher\n                .create_topic_post(\"test\", \"content\", None, None, None)\n                .unwrap(),\n        ];\r\n\r\n        for event in events {\r\n            assert!(\r\n                event.verify().is_ok(),\r\n                \"Event signature verification failed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[21973920],"length":1,"stats":{"Line":2}},{"line":14,"address":[21973928],"length":1,"stats":{"Line":2}},{"line":18,"address":[14317264,14317348],"length":1,"stats":{"Line":3}},{"line":19,"address":[14212755,14212859],"length":1,"stats":{"Line":6}},{"line":23,"address":[14315776,14318119,14318160],"length":1,"stats":{"Line":1}},{"line":24,"address":[14199226,14201502,14199310,14199506],"length":1,"stats":{"Line":4}},{"line":27,"address":[14319840,14317778,14319844],"length":1,"stats":{"Line":3}},{"line":29,"address":[21974542,21974439,21974845,21976464],"length":1,"stats":{"Line":2}},{"line":30,"address":[14281055],"length":1,"stats":{"Line":1}},{"line":31,"address":[14412893],"length":1,"stats":{"Line":0}},{"line":33,"address":[25715925,25715250,25715410,25850943,25850809],"length":1,"stats":{"Line":3}},{"line":34,"address":[14281927],"length":1,"stats":{"Line":1}},{"line":38,"address":[14320474,14318256,14320503],"length":1,"stats":{"Line":1}},{"line":39,"address":[21976721,21976650,21978837,21976905],"length":1,"stats":{"Line":4}},{"line":42,"address":[14320201,14322176,14322180],"length":1,"stats":{"Line":3}},{"line":44,"address":[21976874,21977146,21978819,21976950],"length":1,"stats":{"Line":2}},{"line":46,"address":[14415203,14415899,14415370,14468057,14468191,14416082],"length":1,"stats":{"Line":3}},{"line":47,"address":[14315460],"length":1,"stats":{"Line":1}},{"line":51,"address":[21981652,21981671,21978928],"length":1,"stats":{"Line":1}},{"line":52,"address":[14217810,14218000],"length":1,"stats":{"Line":2}},{"line":55,"address":[14211008,14213524,14213520],"length":1,"stats":{"Line":3}},{"line":58,"address":[25719630,25722059,25720030,25719519],"length":1,"stats":{"Line":1}},{"line":60,"address":[14317459,14317762,14317317],"length":1,"stats":{"Line":2}},{"line":61,"address":[14317419],"length":1,"stats":{"Line":1}},{"line":62,"address":[14286530],"length":1,"stats":{"Line":0}},{"line":64,"address":[21980826,21980114,22030623,22030489,21980637,21979947],"length":1,"stats":{"Line":3}},{"line":65,"address":[14287116],"length":1,"stats":{"Line":1}},{"line":67,"address":[14325688,14323440],"length":1,"stats":{"Line":1}},{"line":68,"address":[14419938,14420167],"length":1,"stats":{"Line":1}},{"line":71,"address":[14207079,14209108,14209104],"length":1,"stats":{"Line":0}},{"line":73,"address":[14220716,14220914,14221201,14220969],"length":1,"stats":{"Line":3}},{"line":74,"address":[25722350,25722437,25722525,25724360],"length":1,"stats":{"Line":2}},{"line":75,"address":[21982379],"length":1,"stats":{"Line":0}},{"line":77,"address":[14221793,14269801,14269935,14221982,14221135,14221278],"length":1,"stats":{"Line":3}},{"line":78,"address":[14326264],"length":1,"stats":{"Line":1}},{"line":82,"address":[14283760,14286418,14286475],"length":1,"stats":{"Line":1}},{"line":83,"address":[14290778,14291053,14290857,14293401],"length":1,"stats":{"Line":4}},{"line":86,"address":[21986884,21984493,21986880],"length":1,"stats":{"Line":3}},{"line":89,"address":[14327770,14327858,14330277,14330256],"length":1,"stats":{"Line":4}},{"line":91,"address":[14216483,14216574],"length":1,"stats":{"Line":2}},{"line":93,"address":[25725054,25725139,25725439],"length":1,"stats":{"Line":2}},{"line":94,"address":[14209851],"length":1,"stats":{"Line":1}},{"line":95,"address":[14291666],"length":1,"stats":{"Line":0}},{"line":97,"address":[14263353,14263487,14217058,14217595,14216891,14217784],"length":1,"stats":{"Line":3}},{"line":98,"address":[14210732],"length":1,"stats":{"Line":1}},{"line":102,"address":[14288469,14286640,14291332],"length":1,"stats":{"Line":2}},{"line":110,"address":[14328888,14329072],"length":1,"stats":{"Line":3}},{"line":113,"address":[14329056,14333456,14333460],"length":1,"stats":{"Line":3}},{"line":115,"address":[14329821,14329000,14329172,14329090,14329621,14333439],"length":1,"stats":{"Line":4}},{"line":116,"address":[14226133],"length":1,"stats":{"Line":2}},{"line":117,"address":[14329476,14325198,14325277],"length":1,"stats":{"Line":5}},{"line":120,"address":[14329845,14329806],"length":1,"stats":{"Line":3}},{"line":121,"address":[14213229,14213363],"length":1,"stats":{"Line":2}},{"line":122,"address":[14220571,14220622],"length":1,"stats":{"Line":2}},{"line":123,"address":[14220181],"length":1,"stats":{"Line":1}},{"line":124,"address":[14330189,14330526,14330125],"length":1,"stats":{"Line":2}},{"line":128,"address":[14426356,14426985],"length":1,"stats":{"Line":2}},{"line":129,"address":[25729137,25729239],"length":1,"stats":{"Line":0}},{"line":131,"address":[14214015,14214261],"length":1,"stats":{"Line":2}},{"line":132,"address":[21989253],"length":1,"stats":{"Line":0}},{"line":133,"address":[14214350,14214433],"length":1,"stats":{"Line":0}},{"line":136,"address":[25729951,25729508,25730251,25731841],"length":1,"stats":{"Line":4}},{"line":137,"address":[14289339],"length":1,"stats":{"Line":2}},{"line":138,"address":[21990018],"length":1,"stats":{"Line":0}},{"line":140,"address":[14428765,14428075,14428954,14470303,14470169,14428242],"length":1,"stats":{"Line":8}},{"line":141,"address":[14215628],"length":1,"stats":{"Line":2}},{"line":145,"address":[14230640],"length":1,"stats":{"Line":1}},{"line":146,"address":[14333552,14333584,14333600],"length":1,"stats":{"Line":3}}],"covered":59,"coverable":68},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","fixtures.rs"],"content":"use nostr_sdk::prelude::*;\n\npub fn sample_signed_event() -> Event {\n    let keys = Keys::generate();\n    EventBuilder::text_note(\"Test content\")\n        .tags(vec![Tag::hashtag(\"test\")])\n        .sign_with_keys(&keys)\n        .expect(\"sign text note\")\n}\n","traces":[{"line":3,"address":[15123163,15123199,15122608],"length":1,"stats":{"Line":0}},{"line":4,"address":[20947073],"length":1,"stats":{"Line":0}},{"line":5,"address":[15123089,15122643,15123017],"length":1,"stats":{"Line":0}},{"line":6,"address":[15129691,15130036,15130148],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","manager_tests.rs"],"content":"#![cfg(test)]\r\n\r\nuse super::mocks::TestGossipService;\r\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::crypto::DefaultKeyManager;\nuse crate::infrastructure::event::EventManager;\nuse crate::infrastructure::p2p::GossipService;\nuse nostr_sdk::prelude::*;\r\nuse std::sync::Arc;\r\n\r\n#[tokio::test]\r\nasync fn event_manager_initializes_with_key_manager() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .expect(\"initialization succeeds\");\r\n    assert!(manager.get_public_key().await.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn event_manager_initializes_with_keypair_directly() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    let keypair = key_manager\r\n        .generate_keypair()\r\n        .await\r\n        .expect(\"keypair generation\");\r\n\r\n    manager\r\n        .initialize_with_keypair(&keypair)\r\n        .await\r\n        .expect(\"initialization with keypair\");\r\n    assert!(manager.get_public_key().await.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn operations_fail_before_initialization() {\r\n    let manager = EventManager::new();\r\n\r\n    assert!(manager.publish_text_note(\"test\").await.is_err());\n    assert!(\n        manager\n            .publish_topic_post(\"topic\", \"content\", None, None, None)\n            .await\n            .is_err()\n    );\n    assert!(manager.subscribe_to_topic(\"topic\", None).await.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn initialize_and_disconnect_cycle() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    assert!(manager.ensure_initialized().await.is_ok());\r\n    manager.disconnect().await.unwrap();\r\n    assert!(manager.ensure_initialized().await.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn get_public_key_matches_key_manager() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    assert!(manager.get_public_key().await.is_none());\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    let public_key = manager.get_public_key().await.unwrap();\r\n    let current_pubkey = key_manager.current_keypair().await.unwrap().public_key;\r\n    let expected = PublicKey::from_hex(&current_pubkey).expect(\"valid pubkey hex\");\r\n    assert_eq!(public_key, expected);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn default_topics_api_behaves_idempotently() {\r\n    let manager = EventManager::new();\n\n    let mut topics = manager.list_default_p2p_topics().await;\n    topics.sort();\n    assert_eq!(topics, vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()]);\n\r\n    manager\r\n        .set_default_p2p_topics(vec![\"a\".into(), \"b\".into()])\r\n        .await;\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    topics.sort();\r\n    assert_eq!(topics, vec![\"a\".to_string(), \"b\".to_string()]);\r\n\r\n    manager.add_default_p2p_topic(\"c\").await;\r\n    manager.remove_default_p2p_topic(\"b\").await;\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    topics.sort();\r\n    assert_eq!(topics, vec![\"a\".to_string(), \"c\".to_string()]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn routing_non_topic_broadcasts_to_user_topic() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    manager\r\n        .set_default_p2p_topics(vec![\"t1\".into(), \"t2\".into()])\r\n        .await;\r\n\r\n    let gossip = Arc::new(TestGossipService::new());\r\n    manager.set_gossip_service(gossip.clone()).await;\r\n\r\n    let publisher = manager.event_publisher.read().await;\r\n    let nostr_event = publisher.create_text_note(\"hello\", vec![]).unwrap();\r\n    drop(publisher);\r\n\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    if let Some(pk) = manager.get_public_key().await {\r\n        topics.push(user_topic_id(&pk.to_string()));\r\n    }\r\n    manager\r\n        .broadcast_to_topics(\r\n            &(gossip.clone() as Arc<dyn GossipService>),\r\n            &topics,\r\n            &nostr_event,\r\n        )\r\n        .await\r\n        .unwrap();\r\n\r\n    let joined = gossip.joined_topics().await;\r\n    let pubkey = manager.get_public_key().await.unwrap();\r\n    let user_topic = user_topic_id(&pubkey.to_string());\r\n    assert!(joined.contains(\"t1\"));\r\n    assert!(joined.contains(\"t2\"));\r\n    assert!(joined.contains(&user_topic));\r\n\r\n    let mut b = gossip.broadcasted_topics().await;\r\n    b.sort();\r\n    assert_eq!(b, {\r\n        let mut v = vec![\"t1\".to_string(), \"t2\".to_string(), user_topic];\r\n        v.sort();\r\n        v\r\n    });\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publisher_creates_expected_event_kinds() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    let publisher = manager.event_publisher.read().await;\r\n\r\n    let text_event = publisher.create_text_note(\"Test note\", vec![]).unwrap();\r\n    assert_eq!(text_event.kind, Kind::TextNote);\r\n\r\n    let metadata = Metadata::new().name(\"Test User\");\r\n    let metadata_event = publisher.create_metadata(metadata).unwrap();\r\n    assert_eq!(metadata_event.kind, Kind::Metadata);\r\n\r\n    let event_id = EventId::from_slice(&[1; 32]).unwrap();\r\n    let reaction_event = publisher.create_reaction(&event_id, \"+\").unwrap();\r\n    assert_eq!(reaction_event.kind, Kind::Reaction);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn ensure_initialized_requires_keypair() {\r\n    let manager = EventManager::new();\r\n    assert!(manager.ensure_initialized().await.is_err());\r\n\r\n    let key_manager = DefaultKeyManager::new();\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    assert!(manager.ensure_initialized().await.is_ok());\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mocks.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse tokio::sync::RwLock;\n\nuse crate::domain::entities as domain;\nuse crate::domain::p2p::TopicStats;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\n\npub struct TestGossipService {\n    joined: Arc<RwLock<HashSet<String>>>,\n    broadcasts: Arc<RwLock<Vec<(String, domain::Event)>>>,\n}\n\nimpl TestGossipService {\n    pub fn new() -> Self {\n        Self {\n            joined: Arc::new(RwLock::new(HashSet::new())),\n            broadcasts: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn joined_topics(&self) -> HashSet<String> {\n        self.joined.read().await.clone()\n    }\n\n    pub async fn broadcasted_topics(&self) -> Vec<String> {\n        self.broadcasts\n            .read()\n            .await\n            .iter()\n            .map(|(t, _)| t.clone())\n            .collect()\n    }\n}\n\nimpl Default for TestGossipService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl GossipService for TestGossipService {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        let mut j = self.joined.write().await;\n        j.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &domain::Event) -> Result<(), AppError> {\n        let mut b = self.broadcasts.write().await;\n        b.push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<domain::Event>, AppError> {\n        let (_tx, rx) = tokio::sync::mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_stats(&self, _topic: &str) -> Result<Option<TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[14298496,14298708],"length":1,"stats":{"Line":1}},{"line":20,"address":[14230743],"length":1,"stats":{"Line":1}},{"line":21,"address":[14329816,14329759],"length":1,"stats":{"Line":2}},{"line":25,"address":[21992200,21992325,21992208,21992243,21992362,21992503,21992910,21992192],"length":1,"stats":{"Line":4}},{"line":26,"address":[14217333,14217376,14217435,14217559],"length":1,"stats":{"Line":2}},{"line":29,"address":[14218006,14217960,14218294,14217952,14218138,14217968,14218098,14218846],"length":1,"stats":{"Line":4}},{"line":30,"address":[14232410,14231838,14231996,14232223,14232337,14231950],"length":1,"stats":{"Line":6}},{"line":32,"address":[14292918,14292858,14292717,14293103,14292801],"length":1,"stats":{"Line":3}},{"line":34,"address":[14331568,14331601],"length":1,"stats":{"Line":2}},{"line":40,"address":[14300448],"length":1,"stats":{"Line":0}},{"line":41,"address":[14331633],"length":1,"stats":{"Line":0}},{"line":47,"address":[14374208],"length":1,"stats":{"Line":0}},{"line":48,"address":[14375864],"length":1,"stats":{"Line":0}},{"line":51,"address":[14257712,14258214,14258359,14258813,14257631,14257977,14258012,14257856,14257747],"length":1,"stats":{"Line":4}},{"line":52,"address":[14374838,14375031,14374523,14374901],"length":1,"stats":{"Line":2}},{"line":53,"address":[14265398,14265466],"length":1,"stats":{"Line":2}},{"line":54,"address":[22033714],"length":1,"stats":{"Line":1}},{"line":57,"address":[14272643,14272718,14272869,14272997,14272688,14272781,14272846],"length":1,"stats":{"Line":0}},{"line":58,"address":[14375849],"length":1,"stats":{"Line":0}},{"line":61,"address":[14372280,14373098,14372080,14372115,14372197,14372303,14372023,14372532],"length":1,"stats":{"Line":5}},{"line":62,"address":[11993319],"length":1,"stats":{"Line":1}},{"line":63,"address":[14372787,14372855],"length":1,"stats":{"Line":2}},{"line":64,"address":[14376981],"length":1,"stats":{"Line":1}},{"line":67,"address":[14260881,14260573,14260435,14260638,14260510,14260661,14260480],"length":1,"stats":{"Line":0}},{"line":71,"address":[14342281],"length":1,"stats":{"Line":0}},{"line":72,"address":[19417228],"length":1,"stats":{"Line":0}},{"line":75,"address":[19417337,19417468,19417551,19417533,19417743,19417405,19417376],"length":1,"stats":{"Line":0}},{"line":76,"address":[14373959],"length":1,"stats":{"Line":0}},{"line":79,"address":[14342931,14343005,14342976,14343133,14343155,14343347,14343068],"length":1,"stats":{"Line":0}},{"line":80,"address":[14374439],"length":1,"stats":{"Line":0}},{"line":83,"address":[14378531,14378606,14378734,14378669,14378961,14378576,14378757],"length":1,"stats":{"Line":0}},{"line":84,"address":[14262217],"length":1,"stats":{"Line":0}},{"line":87,"address":[19418958,19418765,19418800,19418830,19418893,19418977,19419105],"length":1,"stats":{"Line":0}},{"line":88,"address":[14344233],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":34},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mod.rs"],"content":"pub mod fixtures;\npub mod mocks;\n\n#[cfg(test)]\npub mod manager_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","mod.rs"],"content":"//! Shared test utilities.\n\npub mod event;\npub mod p2p;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","bootstrap.rs"],"content":"use crate::domain::p2p::P2PEvent;\nuse crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\nuse crate::infrastructure::p2p::{DiscoveryOptions, gossip_service::GossipService};\nuse iroh::{Endpoint, EndpointAddr, discovery::static_provider::StaticProvider};\nuse std::net::{Ipv4Addr, SocketAddrV4};\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\nuse tokio::time::{Duration, sleep, timeout};\n\nuse super::logging::log_step;\n\npub const DEFAULT_JOIN_TIMEOUT: Duration = Duration::from_secs(15);\npub const DEFAULT_EVENT_TIMEOUT: Duration = Duration::from_secs(15);\n\n#[derive(Clone, Debug)]\npub struct BootstrapContext {\n    pub hints: Vec<String>,\n    pub node_addrs: Vec<EndpointAddr>,\n}\n\npub async fn create_service(ctx: &BootstrapContext) -> IrohGossipService {\n    let bind_addr = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 0);\n    log_step!(\n        \"binding endpoint on {} and enabling DHT discovery (bootstrap hints: {})\",\n        bind_addr,\n        ctx.hints.join(\", \")\n    );\n    let static_discovery = Arc::new(StaticProvider::new());\n    let builder = DiscoveryOptions::default()\n        .apply_to_builder(Endpoint::builder())\n        .discovery(static_discovery.clone())\n        .bind_addr_v4(bind_addr);\n    let endpoint = Arc::new(builder.bind().await.expect(\"failed to bind iroh endpoint\"));\n    endpoint.online().await;\n    for addr in &ctx.node_addrs {\n        log_step!(\"adding bootstrap node addr {}\", addr.id);\n        static_discovery.add_endpoint_info(addr.clone());\n        match endpoint.connect(addr.clone(), iroh_gossip::ALPN).await {\n            Ok(_) => log_step!(\"connected to bootstrap {}\", addr.id),\n            Err(err) => log_step!(\"failed to connect to bootstrap {}: {:?}\", addr.id, err),\n        }\n    }\n    log_step!(\"endpoint ready, building gossip service\");\n    sleep(Duration::from_millis(200)).await;\n    IrohGossipService::new(endpoint, static_discovery).expect(\"failed to create gossip service\")\n}\n\npub fn build_peer_hints(\n    base: &[String],\n    local_hints: &[Option<String>],\n    self_idx: usize,\n) -> Vec<String> {\n    let mut result = base.to_vec();\n    for (idx, hint) in local_hints.iter().enumerate() {\n        if idx == self_idx {\n            continue;\n        }\n        if let Some(h) = hint {\n            if !result.contains(h) {\n                result.push(h.clone());\n            }\n        }\n    }\n    result\n}\n\npub async fn wait_for_topic_membership(\n    service: &IrohGossipService,\n    topic: &str,\n    timeout_duration: Duration,\n) -> bool {\n    let target = topic.to_string();\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < timeout_duration {\n        log_step!(\n            \"checking joined topics for {} (elapsed {:?}/{:?})\",\n            topic,\n            start.elapsed(),\n            timeout_duration\n        );\n        if let Ok(joined) = service.get_joined_topics().await {\n            log_step!(\"currently joined topics: {:?}\", joined);\n            if joined.iter().any(|t| t == &target) {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(100)).await;\n    }\n    false\n}\n\npub async fn wait_for_peer_join_event(\n    receivers: &mut [&mut broadcast::Receiver<P2PEvent>],\n    max_wait: Duration,\n) -> bool {\n    log_step!(\n        \"waiting up to {:?} for peer join events across {} receivers\",\n        max_wait,\n        receivers.len()\n    );\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < max_wait {\n        for rx in receivers.iter_mut() {\n            if let Ok(recv_result) =\n                timeout(Duration::from_millis(150), async { rx.recv().await }).await\n            {\n                match recv_result {\n                    Ok(P2PEvent::PeerJoined { .. }) => {\n                        log_step!(\"received PeerJoined event after {:?}\", start.elapsed());\n                        return true;\n                    }\n                    Ok(_) => {}\n                    Err(err) => {\n                        log_step!(\"peer join receiver error: {:?}\", err);\n                    }\n                }\n            }\n        }\n    }\n    log_step!(\n        \"timed out waiting for peer join events after {:?}\",\n        max_wait\n    );\n    false\n}\n","traces":[{"line":21,"address":[22927616,22927584,22927592,22928010,22927904,22930873,22927723],"length":1,"stats":{"Line":0}},{"line":22,"address":[22995592,22995833],"length":1,"stats":{"Line":0}},{"line":23,"address":[18021961,18022423],"length":1,"stats":{"Line":0}},{"line":28,"address":[22914887,22916411],"length":1,"stats":{"Line":0}},{"line":29,"address":[18022936,18023086,18023177,18023246,18022992],"length":1,"stats":{"Line":0}},{"line":30,"address":[22923384,22923438],"length":1,"stats":{"Line":0}},{"line":31,"address":[22917091,22916777,22916662,22916507],"length":1,"stats":{"Line":0}},{"line":32,"address":[18023216],"length":1,"stats":{"Line":0}},{"line":33,"address":[22927934,22930905,22930700,22930763],"length":1,"stats":{"Line":0}},{"line":34,"address":[23032483,23035933,23035849],"length":1,"stats":{"Line":0}},{"line":35,"address":[23038772,23038707,23034574],"length":1,"stats":{"Line":0}},{"line":37,"address":[22938077,22939095],"length":1,"stats":{"Line":0}},{"line":38,"address":[23038093,23030755,23026920],"length":1,"stats":{"Line":0}},{"line":40,"address":[22995447,22993102,22994899],"length":1,"stats":{"Line":0}},{"line":44,"address":[23032525,23041984,23040980,23043861],"length":1,"stats":{"Line":0}},{"line":45,"address":[23042389],"length":1,"stats":{"Line":0}},{"line":48,"address":[23039314,23038688],"length":1,"stats":{"Line":0}},{"line":53,"address":[22926056],"length":1,"stats":{"Line":0}},{"line":54,"address":[22940142,22939840,22939912],"length":1,"stats":{"Line":0}},{"line":55,"address":[23043059],"length":1,"stats":{"Line":0}},{"line":58,"address":[17180737],"length":1,"stats":{"Line":0}},{"line":59,"address":[22933264],"length":1,"stats":{"Line":0}},{"line":60,"address":[23043195],"length":1,"stats":{"Line":0}},{"line":64,"address":[23044628],"length":1,"stats":{"Line":0}},{"line":67,"address":[18032848],"length":1,"stats":{"Line":0}},{"line":72,"address":[23043498],"length":1,"stats":{"Line":0}},{"line":73,"address":[23043640,23043754],"length":1,"stats":{"Line":0}},{"line":74,"address":[22940880,22941210],"length":1,"stats":{"Line":0}},{"line":75,"address":[22928761,22929182],"length":1,"stats":{"Line":0}},{"line":81,"address":[23140265,23142642,23141194,23139991],"length":1,"stats":{"Line":0}},{"line":83,"address":[17184861,17185921,17186384,17186397],"length":1,"stats":{"Line":0}},{"line":84,"address":[18037838],"length":1,"stats":{"Line":0}},{"line":87,"address":[22938770,22938625,22934011,22933724],"length":1,"stats":{"Line":0}},{"line":89,"address":[23045804],"length":1,"stats":{"Line":0}},{"line":92,"address":[23044832],"length":1,"stats":{"Line":0}},{"line":96,"address":[18039671,18039997],"length":1,"stats":{"Line":0}},{"line":101,"address":[23045658,23046930],"length":1,"stats":{"Line":0}},{"line":102,"address":[22941016,22945352],"length":1,"stats":{"Line":0}},{"line":103,"address":[18044423,18044346,18044627,18046157],"length":1,"stats":{"Line":0}},{"line":104,"address":[23147704],"length":1,"stats":{"Line":0}},{"line":107,"address":[23016184,23016243],"length":1,"stats":{"Line":0}},{"line":109,"address":[23053059,23052732],"length":1,"stats":{"Line":0}},{"line":110,"address":[23010066],"length":1,"stats":{"Line":0}},{"line":113,"address":[23051409],"length":1,"stats":{"Line":0}},{"line":124,"address":[23057500],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","config.rs"],"content":"use crate::infrastructure::p2p::utils::parse_peer_hint;\n\nuse super::bootstrap::BootstrapContext;\nuse super::logging::log_step;\n\npub fn load_bootstrap_context(test_name: &str) -> Option<BootstrapContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        log_step!(\"skipping {} (ENABLE_P2P_INTEGRATION != 1)\", test_name);\n        return None;\n    }\n\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    if raw.trim().is_empty() {\n        log_step!(\"skipping {} (KUKURI_BOOTSTRAP_PEERS not set)\", test_name);\n        return None;\n    }\n\n    let mut hints = Vec::new();\n    let mut addrs = Vec::new();\n\n    for entry in raw.split(',') {\n        let trimmed = entry.trim();\n        if trimmed.is_empty() {\n            continue;\n        }\n        hints.push(trimmed.to_string());\n        match parse_peer_hint(trimmed) {\n            Ok(parsed) => {\n                if let Some(addr) = parsed.node_addr {\n                    addrs.push(addr);\n                } else {\n                    log_step!(\"bootstrap peer '{}' missing address; skipping\", trimmed);\n                }\n            }\n            Err(err) => {\n                log_step!(\"failed to parse bootstrap peer '{}': {:?}\", trimmed, err);\n                return None;\n            }\n        }\n    }\n\n    if addrs.is_empty() {\n        log_step!(\n            \"skipping {} (no usable bootstrap node addresses)\",\n            test_name\n        );\n        return None;\n    }\n\n    log_step!(\n        \"test {} using bootstrap peers: {}\",\n        test_name,\n        hints.join(\", \")\n    );\n\n    Some(BootstrapContext {\n        hints,\n        node_addrs: addrs,\n    })\n}\n","traces":[{"line":6,"address":[19661225,19658480,19668693],"length":1,"stats":{"Line":4}},{"line":7,"address":[19651750,19652032],"length":1,"stats":{"Line":7}},{"line":9,"address":[19775209],"length":1,"stats":{"Line":4}},{"line":12,"address":[23064715],"length":1,"stats":{"Line":0}},{"line":13,"address":[19726730,19726601],"length":1,"stats":{"Line":0}},{"line":15,"address":[23073619],"length":1,"stats":{"Line":0}},{"line":18,"address":[13906508],"length":1,"stats":{"Line":0}},{"line":19,"address":[19865326],"length":1,"stats":{"Line":0}},{"line":21,"address":[23065384,23065189,23065109,23071360],"length":1,"stats":{"Line":0}},{"line":22,"address":[13906940,13910814],"length":1,"stats":{"Line":0}},{"line":23,"address":[19731118],"length":1,"stats":{"Line":0}},{"line":26,"address":[19773213],"length":1,"stats":{"Line":0}},{"line":27,"address":[19738162],"length":1,"stats":{"Line":0}},{"line":28,"address":[19731295],"length":1,"stats":{"Line":0}},{"line":29,"address":[19663521,19663616],"length":1,"stats":{"Line":0}},{"line":30,"address":[19773648,19773544],"length":1,"stats":{"Line":0}},{"line":35,"address":[19769457],"length":1,"stats":{"Line":0}},{"line":37,"address":[19771877],"length":1,"stats":{"Line":0}},{"line":42,"address":[23065370,23065449],"length":1,"stats":{"Line":0}},{"line":47,"address":[23068164],"length":1,"stats":{"Line":0}},{"line":50,"address":[19867572,19867117],"length":1,"stats":{"Line":0}},{"line":56,"address":[19766011],"length":1,"stats":{"Line":0}},{"line":57,"address":[23065991],"length":1,"stats":{"Line":0}},{"line":58,"address":[19866331],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","fixtures.rs"],"content":"use crate::domain::entities::Event;\n\npub fn nostr_to_domain(ev: &nostr_sdk::Event) -> Event {\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(ev.created_at.as_secs() as i64, 0)\n            .expect(\"invalid timestamp in nostr event\");\n    Event {\n        id: ev.id.to_string(),\n        pubkey: ev.pubkey.to_string(),\n        created_at,\n        kind: ev.kind.as_u16() as u32,\n        tags: ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: ev.content.clone(),\n        sig: ev.sig.to_string(),\n    }\n}\n","traces":[{"line":3,"address":[23818622,23817904],"length":1,"stats":{"Line":0}},{"line":4,"address":[23708086],"length":1,"stats":{"Line":0}},{"line":8,"address":[23819665],"length":1,"stats":{"Line":0}},{"line":9,"address":[23914472],"length":1,"stats":{"Line":0}},{"line":11,"address":[20518357,20518427],"length":1,"stats":{"Line":0}},{"line":12,"address":[23702062,23702016,23701546],"length":1,"stats":{"Line":0}},{"line":13,"address":[23914698],"length":1,"stats":{"Line":0}},{"line":14,"address":[23783218],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","logging.rs"],"content":"use std::sync::Once;\nuse tracing_subscriber::EnvFilter;\n\nstatic INIT_TRACING: Once = Once::new();\n\npub fn init_tracing() {\n    INIT_TRACING.call_once(|| {\n        let env_filter = EnvFilter::try_from_default_env()\n            .unwrap_or_else(|_| EnvFilter::new(\"info,iroh_tests=info\"));\n        let subscriber = tracing_subscriber::fmt()\n            .with_env_filter(env_filter)\n            .with_target(true)\n            .compact()\n            .finish();\n        let _ = tracing::subscriber::set_global_default(subscriber);\n    });\n}\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    }};\n}\n\npub(crate) use log_step;\n","traces":[{"line":6,"address":[20707664],"length":1,"stats":{"Line":4}},{"line":7,"address":[20714641,20714672,20715070,20715041],"length":1,"stats":{"Line":4}},{"line":8,"address":[20714724],"length":1,"stats":{"Line":1}},{"line":9,"address":[20708112,20708128,20707804],"length":1,"stats":{"Line":1}},{"line":10,"address":[20813732,20813837],"length":1,"stats":{"Line":2}},{"line":11,"address":[14955392],"length":1,"stats":{"Line":1}},{"line":15,"address":[20817886],"length":1,"stats":{"Line":1}},{"line":21,"address":[23200393,23035246,23200550,23198966,23200921,23045890,23201078,23031556,23202134,23050586,23199337,23201449,23053127,23055355,23051441,23198281,23203033,23200022,23049650,23048969,23197910,23035880,23046700,23032694,23053440,23032232,23038792,23201977,23055872,23197753,23051617,23055274,23202505,23037524,23035341,23046599,23045469,23038744,23198438,23199494,23199865,23201606,23039364,23047242,23053947,23035119,23203190,23052173,23044187,23040998,23202662,23030995,23040460,23050260,23198809,23052800,23036998,23044265,23049097,23044811],"length":1,"stats":{"Line":12}}],"covered":8,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","mod.rs"],"content":"pub mod bootstrap;\npub mod config;\npub mod fixtures;\npub mod logging;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","bin","p2p_metrics_export.rs"],"content":"use anyhow::{Context, Result, bail};\nuse chrono::Utc;\nuse kukuri_lib::{\n    AppConfig, ConnectionPool, SqliteRepository, TopicMetricsRecord, TopicMetricsRepository,\n    TopicMetricsSnapshot, ops::p2p::metrics,\n};\nuse std::{\n    env, fs,\n    path::{Path, PathBuf},\n};\nuse tokio::runtime::Runtime;\n\nconst DEFAULT_LIMIT: usize = 25;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum JobKind {\n    P2P,\n    Trending,\n}\n\n#[derive(Debug, Clone)]\nstruct CliOptions {\n    output: Option<PathBuf>,\n    pretty: bool,\n    job: JobKind,\n    limit: usize,\n    database_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, serde::Serialize)]\nstruct ScoreWeightsSummary {\n    posts: f64,\n    unique_authors: f64,\n    boosts: f64,\n}\n\n#[derive(Debug, serde::Serialize)]\nstruct TrendingJobReport {\n    job: &'static str,\n    generated_at_ms: i64,\n    collected_at_ms: i64,\n    limit: usize,\n    metrics_count: usize,\n    score_weights: ScoreWeightsSummary,\n    window_start_ms: Option<i64>,\n    window_end_ms: Option<i64>,\n    window_duration_ms: Option<i64>,\n    lag_ms: Option<i64>,\n    topics: Vec<TopicMetricsRecord>,\n}\n\nfn usage() -> &'static str {\n    \"Usage: p2p_metrics_export [--job <p2p|trending>] [--output <path>] [--pretty] [--limit <n>] [--database-url <url>]\"\n}\n\nfn write_output(path: &Path, data: &str) -> Result<()> {\n    if let Some(parent) = path.parent() {\n        if !parent.as_os_str().is_empty() {\n            fs::create_dir_all(parent)\n                .with_context(|| format!(\"Failed to create {}\", parent.display()))?;\n        }\n    }\n    fs::write(path, data).with_context(|| format!(\"Failed to write {}\", path.display()))\n}\n\nfn emit_payload(target: Option<&Path>, payload: &str) -> Result<()> {\n    if let Some(path) = target {\n        write_output(path, payload)?;\n        println!(\"Metrics written to {}\", path.display());\n    } else {\n        println!(\"{payload}\");\n    }\n    Ok(())\n}\n\nfn main() -> Result<()> {\n    let args: Vec<String> = env::args().skip(1).collect();\n    let options = parse_args(args.into_iter())?;\n\n    match options.job {\n        JobKind::P2P => export_p2p(&options),\n        JobKind::Trending => export_trending(&options),\n    }\n}\n\nfn export_p2p(options: &CliOptions) -> Result<()> {\n    let snapshot = metrics::snapshot_full();\n    let payload = to_json(&snapshot, options.pretty)?;\n    emit_payload(options.output.as_deref(), &payload)\n}\n\nfn export_trending(options: &CliOptions) -> Result<()> {\n    let database_url = resolve_database_url(options);\n    let weights = current_score_weights();\n    let rt = Runtime::new().context(\"Failed to create Tokio runtime\")?;\n    let report = rt.block_on(async {\n        collect_trending_report(&database_url, options.limit, weights)\n            .await\n            .with_context(|| format!(\"Failed to collect trending metrics from {database_url}\"))\n    })?;\n\n    let payload = to_json(&report, options.pretty)?;\n    emit_payload(options.output.as_deref(), &payload)\n}\n\nfn to_json<T: serde::Serialize>(value: &T, pretty: bool) -> Result<String> {\n    if pretty {\n        Ok(serde_json::to_string_pretty(value)?)\n    } else {\n        Ok(serde_json::to_string(value)?)\n    }\n}\n\nfn parse_args<I>(args: I) -> Result<CliOptions>\nwhere\n    I: IntoIterator<Item = String>,\n{\n    let mut output: Option<PathBuf> = None;\n    let mut pretty = false;\n    let mut job = JobKind::P2P;\n    let mut limit = DEFAULT_LIMIT;\n    let mut database_url: Option<String> = None;\n\n    let mut iter = args.into_iter();\n    while let Some(arg) = iter.next() {\n        match arg.as_str() {\n            \"-o\" | \"--output\" => {\n                let path = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--output requires a path\\n{}\", usage()))?;\n                output = Some(PathBuf::from(path));\n            }\n            \"--pretty\" => {\n                pretty = true;\n            }\n            \"--job\" => {\n                let value = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--job requires a value\\n{}\", usage()))?;\n                job = parse_job(&value)?;\n            }\n            \"--limit\" => {\n                let value = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--limit requires a value\\n{}\", usage()))?;\n                limit = parse_limit(&value)?;\n            }\n            \"--database-url\" => {\n                let value = iter.next().ok_or_else(|| {\n                    anyhow::anyhow!(\"--database-url requires a value\\n{}\", usage())\n                })?;\n                database_url = Some(value);\n            }\n            \"-h\" | \"--help\" => {\n                println!(\"{}\", usage());\n                std::process::exit(0);\n            }\n            other => {\n                bail!(\"Unknown argument: {other}\\n{}\", usage());\n            }\n        }\n    }\n\n    Ok(CliOptions {\n        output,\n        pretty,\n        job,\n        limit,\n        database_url,\n    })\n}\n\nfn parse_job(value: &str) -> Result<JobKind> {\n    match value.to_ascii_lowercase().as_str() {\n        \"p2p\" => Ok(JobKind::P2P),\n        \"trending\" => Ok(JobKind::Trending),\n        other => bail!(\"Unknown job: {other}. Expected 'p2p' or 'trending'.\"),\n    }\n}\n\nfn parse_limit(value: &str) -> Result<usize> {\n    let parsed: usize = value\n        .parse()\n        .with_context(|| format!(\"Invalid limit '{value}'. Expected a positive integer.\"))?;\n    if parsed == 0 {\n        bail!(\"--limit must be greater than 0\");\n    }\n    Ok(parsed)\n}\n\nfn resolve_database_url(options: &CliOptions) -> String {\n    if let Some(url) = &options.database_url {\n        return url.clone();\n    }\n    if let Ok(env_url) = env::var(\"DATABASE_URL\") {\n        if !env_url.trim().is_empty() {\n            return env_url;\n        }\n    }\n    AppConfig::from_env().database.url\n}\n\nfn current_score_weights() -> ScoreWeightsSummary {\n    let cfg = AppConfig::from_env();\n    ScoreWeightsSummary {\n        posts: cfg.metrics.score_weights.posts,\n        unique_authors: cfg.metrics.score_weights.unique_authors,\n        boosts: cfg.metrics.score_weights.boosts,\n    }\n}\n\nasync fn collect_trending_report(\n    database_url: &str,\n    limit: usize,\n    weights: ScoreWeightsSummary,\n) -> Result<TrendingJobReport> {\n    let pool = ConnectionPool::new(database_url)\n        .await\n        .with_context(|| format!(\"Failed to connect to database at {database_url}\"))?;\n    let repository = SqliteRepository::new(pool);\n    let snapshot = repository\n        .list_recent_metrics(limit)\n        .await\n        .context(\"Failed to query topic metrics snapshot\")?;\n\n    Ok(build_report(snapshot, limit, weights))\n}\n\nfn build_report(\n    snapshot: Option<TopicMetricsSnapshot>,\n    limit: usize,\n    weights: ScoreWeightsSummary,\n) -> TrendingJobReport {\n    let now_ms = current_unix_ms();\n\n    if let Some(snapshot) = snapshot {\n        let duration = snapshot\n            .window_end\n            .saturating_sub(snapshot.window_start)\n            .max(0);\n        let lag = now_ms.saturating_sub(snapshot.window_end).max(0);\n        let metrics = snapshot.metrics;\n        TrendingJobReport {\n            job: \"trending_metrics\",\n            generated_at_ms: snapshot.window_end,\n            collected_at_ms: now_ms,\n            limit,\n            metrics_count: metrics.len(),\n            score_weights: weights,\n            window_start_ms: Some(snapshot.window_start),\n            window_end_ms: Some(snapshot.window_end),\n            window_duration_ms: Some(duration),\n            lag_ms: Some(lag),\n            topics: metrics,\n        }\n    } else {\n        TrendingJobReport {\n            job: \"trending_metrics\",\n            generated_at_ms: now_ms,\n            collected_at_ms: now_ms,\n            limit,\n            metrics_count: 0,\n            score_weights: weights,\n            window_start_ms: None,\n            window_end_ms: None,\n            window_duration_ms: None,\n            lag_ms: None,\n            topics: Vec::new(),\n        }\n    }\n}\n\nfn current_unix_ms() -> i64 {\n    Utc::now().timestamp_millis()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parses_defaults() {\n        let opts = parse_args(Vec::<String>::new()).expect(\"options\");\n        assert_eq!(opts.job, JobKind::P2P);\n        assert_eq!(opts.limit, DEFAULT_LIMIT);\n        assert!(opts.output.is_none());\n    }\n\n    #[test]\n    fn parses_trending_job_with_options() {\n        let opts = parse_args(\n            vec![\n                \"--job\".into(),\n                \"trending\".into(),\n                \"--limit\".into(),\n                \"10\".into(),\n                \"--database-url\".into(),\n                \"sqlite::memory:\".into(),\n                \"--output\".into(),\n                \"out.json\".into(),\n                \"--pretty\".into(),\n            ]\n            .into_iter(),\n        )\n        .expect(\"options\");\n\n        assert_eq!(opts.job, JobKind::Trending);\n        assert_eq!(opts.limit, 10);\n        assert_eq!(opts.database_url.as_deref(), Some(\"sqlite::memory:\"));\n        assert!(opts.pretty);\n        assert_eq!(opts.output.as_deref(), Some(Path::new(\"out.json\")));\n    }\n\n    #[test]\n    fn rejects_invalid_job() {\n        let err = parse_args(vec![\"--job\".into(), \"unknown\".into()].into_iter()).unwrap_err();\n        assert!(format!(\"{err}\").contains(\"Unknown job\"));\n    }\n\n    #[test]\n    fn reject_zero_limit() {\n        let err = parse_args(vec![\"--limit\".into(), \"0\".into()].into_iter()).unwrap_err();\n        assert!(format!(\"{err}\").contains(\"greater than 0\"));\n    }\n\n    #[test]\n    fn trending_report_uses_snapshot_window_end() {\n        let snapshot = TopicMetricsSnapshot {\n            window_start: 1_000,\n            window_end: 2_000,\n            metrics: Vec::new(),\n        };\n        let weights = ScoreWeightsSummary {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        };\n\n        let report = build_report(Some(snapshot), 25, weights);\n\n        assert_eq!(report.generated_at_ms, 2_000);\n        assert_eq!(report.window_start_ms, Some(1_000));\n        assert_eq!(report.window_end_ms, Some(2_000));\n        assert!(report.collected_at_ms >= report.generated_at_ms);\n        assert_eq!(report.score_weights.posts, 0.6);\n    }\n}\n","traces":[{"line":56,"address":[10986320],"length":1,"stats":{"Line":0}},{"line":57,"address":[10986367],"length":1,"stats":{"Line":0}},{"line":58,"address":[10986445],"length":1,"stats":{"Line":0}},{"line":59,"address":[10986527,10986603],"length":1,"stats":{"Line":0}},{"line":60,"address":[10986640,10986666,10986590],"length":1,"stats":{"Line":0}},{"line":63,"address":[10986842,10986816,10986487],"length":1,"stats":{"Line":0}},{"line":66,"address":[10986992],"length":1,"stats":{"Line":0}},{"line":67,"address":[10987019],"length":1,"stats":{"Line":0}},{"line":68,"address":[10987081,10987358],"length":1,"stats":{"Line":0}},{"line":69,"address":[10987250],"length":1,"stats":{"Line":0}},{"line":71,"address":[10987141],"length":1,"stats":{"Line":0}},{"line":73,"address":[10987391],"length":1,"stats":{"Line":0}},{"line":76,"address":[10987808,10987424],"length":1,"stats":{"Line":0}},{"line":77,"address":[10987431],"length":1,"stats":{"Line":0}},{"line":78,"address":[10987645,10987477],"length":1,"stats":{"Line":0}},{"line":80,"address":[10987625],"length":1,"stats":{"Line":0}},{"line":81,"address":[10987689,10987763],"length":1,"stats":{"Line":0}},{"line":82,"address":[10987709,10987788],"length":1,"stats":{"Line":0}},{"line":86,"address":[10988350,10987840,10988318],"length":1,"stats":{"Line":0}},{"line":87,"address":[10987860],"length":1,"stats":{"Line":0}},{"line":88,"address":[10988332,10988104,10987889,10987952],"length":1,"stats":{"Line":0}},{"line":89,"address":[10988083,10988218],"length":1,"stats":{"Line":0}},{"line":92,"address":[10988368,10989548,10989641],"length":1,"stats":{"Line":0}},{"line":93,"address":[10988399],"length":1,"stats":{"Line":0}},{"line":94,"address":[10988412],"length":1,"stats":{"Line":0}},{"line":95,"address":[10988821,10989634,10988463],"length":1,"stats":{"Line":0}},{"line":96,"address":[10988923,10988743,10989079,10989664,10989714,10989792,10989606,10990016,10990304,10989832],"length":1,"stats":{"Line":0}},{"line":97,"address":[10989889,10989972,10990249,10989767,10990170],"length":1,"stats":{"Line":0}},{"line":98,"address":[10989965,10990172,10989996,10990048,10989819],"length":1,"stats":{"Line":0}},{"line":99,"address":[10990225,10990342,10990320],"length":1,"stats":{"Line":0}},{"line":102,"address":[10989562,10989145,10989041,10989297],"length":1,"stats":{"Line":0}},{"line":103,"address":[10989276,10989411],"length":1,"stats":{"Line":0}},{"line":106,"address":[10990864,10990448],"length":1,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[10998960,10993205,10991280,10997061,10995136,10995104],"length":1,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[10991361,10995217],"length":1,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[10991803,10995659,10997993,10998225,10994369,10994137],"length":1,"stats":{"Line":2}},{"line":130,"address":[10998209,10998992,10994353,10998999,10999136,10999143],"length":1,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[10991919,10995775],"length":1,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[10997240,10997352,10997487,10993496,10993631,10993384],"length":1,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[10992987,10992121,10995977,10996580,10996843,10992724,10999856,11000000],"length":1,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[10992869,10996953,10996725,10993004,10993097,10996860],"length":1,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[10992194,10996437,10996050,10992581],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[10996090,10992234],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[11000144,11000584],"length":1,"stats":{"Line":2}},{"line":174,"address":[11000187,11000265],"length":1,"stats":{"Line":4}},{"line":175,"address":[11000352,11000281],"length":1,"stats":{"Line":2}},{"line":176,"address":[11000324,11000379,11000434],"length":1,"stats":{"Line":5}},{"line":177,"address":[11000454,11000395],"length":1,"stats":{"Line":2}},{"line":181,"address":[11000608],"length":1,"stats":{"Line":1}},{"line":182,"address":[11000625,11000729],"length":1,"stats":{"Line":1}},{"line":184,"address":[11000870,11000848,11000716],"length":1,"stats":{"Line":0}},{"line":185,"address":[11000708],"length":1,"stats":{"Line":1}},{"line":186,"address":[11000753],"length":1,"stats":{"Line":1}},{"line":188,"address":[11000810],"length":1,"stats":{"Line":1}},{"line":191,"address":[11000976,11001470],"length":1,"stats":{"Line":0}},{"line":192,"address":[11001001],"length":1,"stats":{"Line":0}},{"line":193,"address":[11001062],"length":1,"stats":{"Line":0}},{"line":195,"address":[11001070,11001116],"length":1,"stats":{"Line":0}},{"line":196,"address":[11001225,11001141],"length":1,"stats":{"Line":0}},{"line":197,"address":[11001278],"length":1,"stats":{"Line":0}},{"line":200,"address":[11001508,11001393],"length":1,"stats":{"Line":0}},{"line":203,"address":[11001584],"length":1,"stats":{"Line":0}},{"line":204,"address":[11001600],"length":1,"stats":{"Line":0}},{"line":206,"address":[11001615],"length":1,"stats":{"Line":0}},{"line":207,"address":[11001624],"length":1,"stats":{"Line":0}},{"line":208,"address":[11001633],"length":1,"stats":{"Line":0}},{"line":212,"address":[11001680],"length":1,"stats":{"Line":0}},{"line":217,"address":[11001939,11002446,11002896,11002117,11002322,11002632],"length":1,"stats":{"Line":0}},{"line":218,"address":[11002147,11002370,11002000,11002090,11002207],"length":1,"stats":{"Line":0}},{"line":219,"address":[11002616,11002430,11003744,11003766],"length":1,"stats":{"Line":0}},{"line":220,"address":[11002563,11002712],"length":1,"stats":{"Line":0}},{"line":221,"address":[11002734,11003138,11003478,11003030,11002715,11002852],"length":1,"stats":{"Line":0}},{"line":222,"address":[11002730],"length":1,"stats":{"Line":0}},{"line":223,"address":[11002821,11002018,11002924,11003078,11002868],"length":1,"stats":{"Line":0}},{"line":226,"address":[11003572,11003339],"length":1,"stats":{"Line":0}},{"line":229,"address":[11003872,11004892,11005196],"length":1,"stats":{"Line":1}},{"line":234,"address":[11004024,11003912],"length":1,"stats":{"Line":2}},{"line":236,"address":[11004032,11005145],"length":1,"stats":{"Line":1}},{"line":237,"address":[11004117,11004253],"length":1,"stats":{"Line":2}},{"line":239,"address":[11004112],"length":1,"stats":{"Line":1}},{"line":241,"address":[11004291],"length":1,"stats":{"Line":1}},{"line":242,"address":[11004349],"length":1,"stats":{"Line":1}},{"line":245,"address":[11004383],"length":1,"stats":{"Line":1}},{"line":248,"address":[11004403],"length":1,"stats":{"Line":1}},{"line":250,"address":[11004498],"length":1,"stats":{"Line":1}},{"line":251,"address":[11004523],"length":1,"stats":{"Line":1}},{"line":252,"address":[11004551],"length":1,"stats":{"Line":1}},{"line":253,"address":[11004571],"length":1,"stats":{"Line":1}},{"line":268,"address":[11004185],"length":1,"stats":{"Line":0}},{"line":273,"address":[11005232],"length":1,"stats":{"Line":1}},{"line":274,"address":[11005236],"length":1,"stats":{"Line":1}}],"covered":54,"coverable":122},{"path":["/","app","kukuri-tauri","src-tauri","src","contract_testing.rs"],"content":"use crate::domain::entities::event::Event;\n\npub fn validate_nip10_tags(tags: Vec<Vec<String>>) -> Result<(), String> {\n    let mut event = Event::new(1, String::new(), \"a\".repeat(64));\n    event.id = \"f\".repeat(64);\n    event.sig = \"f\".repeat(128);\n    event.created_at = chrono::Utc::now();\n    event.tags = tags;\n    event.validate_nip10_19().map_err(|err| err.message)\n}\n","traces":[{"line":3,"address":[22226695,22225856,22226726],"length":1,"stats":{"Line":1}},{"line":4,"address":[22439030,22439776,22438950],"length":1,"stats":{"Line":2}},{"line":5,"address":[16480393,16480466],"length":1,"stats":{"Line":2}},{"line":6,"address":[22342907],"length":1,"stats":{"Line":1}},{"line":7,"address":[22226425],"length":1,"stats":{"Line":1}},{"line":8,"address":[22343119],"length":1,"stats":{"Line":1}},{"line":9,"address":[22343258,22343408,22343411],"length":1,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","constants.rs"],"content":"pub const TOPIC_NAMESPACE: &str = \"kukuri:tauri:\";\npub const DEFAULT_PUBLIC_TOPIC_ID: &str =\n    \"kukuri:tauri:731051a1c14a65ee3735ee4ab3b97198cae1633700f9b87fcde205e64c5a56b0\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","account","mod.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// SecureStorage に保存されるアカウント情報を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccountMetadata {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n    pub last_used: DateTime<Utc>,\n}\n\nimpl AccountMetadata {\n    pub fn mark_used(&mut self, timestamp: DateTime<Utc>) {\n        self.last_used = timestamp;\n    }\n}\n\n/// SecureStorage に保存されるアカウント一覧と現在アカウントのメタデータ。\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct AccountsMetadata {\n    pub accounts: HashMap<String, AccountMetadata>,\n    pub current_npub: Option<String>,\n}\n\n/// アカウント登録時に必要な情報。\n#[derive(Debug, Clone)]\npub struct AccountRegistration {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl AccountRegistration {\n    pub fn into_metadata(self) -> (AccountMetadata, String) {\n        let AccountRegistration {\n            npub,\n            nsec,\n            pubkey,\n            name,\n            display_name,\n            picture,\n        } = self;\n\n        let metadata = AccountMetadata {\n            npub: npub.clone(),\n            pubkey,\n            name,\n            display_name,\n            picture,\n            last_used: Utc::now(),\n        };\n\n        (metadata, nsec)\n    }\n}\n\n/// 現在のアカウントのメタデータと秘密鍵。\n#[derive(Debug, Clone)]\npub struct CurrentAccountSecret {\n    pub metadata: AccountMetadata,\n    pub nsec: String,\n}\n","traces":[{"line":17,"address":[21355056],"length":1,"stats":{"Line":0}},{"line":18,"address":[19288197],"length":1,"stats":{"Line":0}},{"line":41,"address":[21355088,21356251,21356022],"length":1,"stats":{"Line":0}},{"line":42,"address":[15609414],"length":1,"stats":{"Line":0}},{"line":43,"address":[21429734],"length":1,"stats":{"Line":0}},{"line":44,"address":[21568231],"length":1,"stats":{"Line":0}},{"line":45,"address":[21355177],"length":1,"stats":{"Line":0}},{"line":46,"address":[21471843],"length":1,"stats":{"Line":0}},{"line":47,"address":[19288371],"length":1,"stats":{"Line":0}},{"line":48,"address":[21467971],"length":1,"stats":{"Line":0}},{"line":52,"address":[21355302],"length":1,"stats":{"Line":0}},{"line":57,"address":[21369281],"length":1,"stats":{"Line":0}},{"line":60,"address":[21437379],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","bookmark.rs"],"content":"use crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// ユーザーが投稿をブックマークした履歴を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Bookmark {\n    id: BookmarkId,\n    user_pubkey: PublicKey,\n    post_id: EventId,\n    created_at: DateTime<Utc>,\n}\n\nimpl Bookmark {\n    /// 現在時刻で新しいブックマークを作成する。\n    pub fn new(user_pubkey: PublicKey, post_id: EventId) -> Self {\n        Self {\n            id: BookmarkId::random(),\n            user_pubkey,\n            post_id,\n            created_at: Utc::now(),\n        }\n    }\n\n    /// 既存レコードからブックマークを復元する。\n    pub fn from_parts(\n        id: BookmarkId,\n        user_pubkey: PublicKey,\n        post_id: EventId,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            user_pubkey,\n            post_id,\n            created_at,\n        }\n    }\n\n    pub fn id(&self) -> &BookmarkId {\n        &self.id\n    }\n\n    pub fn user_pubkey(&self) -> &PublicKey {\n        &self.user_pubkey\n    }\n\n    pub fn post_id(&self) -> &EventId {\n        &self.post_id\n    }\n\n    pub fn created_at(&self) -> DateTime<Utc> {\n        self.created_at\n    }\n}\n","traces":[{"line":16,"address":[13613566,13613638,13613216],"length":1,"stats":{"Line":1}},{"line":18,"address":[13569547],"length":1,"stats":{"Line":1}},{"line":21,"address":[13611744],"length":1,"stats":{"Line":1}},{"line":26,"address":[13576912],"length":1,"stats":{"Line":1}},{"line":40,"address":[13570080],"length":1,"stats":{"Line":1}},{"line":44,"address":[13570096],"length":1,"stats":{"Line":1}},{"line":45,"address":[13608216],"length":1,"stats":{"Line":1}},{"line":48,"address":[20519552],"length":1,"stats":{"Line":1}},{"line":49,"address":[13502312],"length":1,"stats":{"Line":1}},{"line":52,"address":[13708608],"length":1,"stats":{"Line":1}},{"line":53,"address":[13570136],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","direct_message.rs"],"content":"use chrono::{DateTime, TimeZone, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::str::FromStr;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum MessageDirection {\n    Outbound,\n    Inbound,\n}\n\nimpl MessageDirection {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            MessageDirection::Outbound => \"outbound\",\n            MessageDirection::Inbound => \"inbound\",\n        }\n    }\n}\n\nimpl FromStr for MessageDirection {\n    type Err = ();\n\n    fn from_str(value: &str) -> Result<Self, Self::Err> {\n        match value {\n            \"outbound\" => Ok(MessageDirection::Outbound),\n            \"inbound\" => Ok(MessageDirection::Inbound),\n            _ => Err(()),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct NewDirectMessage {\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub payload_cipher_base64: String,\n    pub created_at: DateTime<Utc>,\n    pub delivered: bool,\n    pub direction: MessageDirection,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessage {\n    pub id: i64,\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub payload_cipher_base64: String,\n    pub created_at: DateTime<Utc>,\n    pub delivered: bool,\n    pub direction: MessageDirection,\n    pub decrypted_content: Option<String>,\n}\n\nimpl DirectMessage {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: i64,\n        owner_npub: String,\n        conversation_npub: String,\n        sender_npub: String,\n        recipient_npub: String,\n        event_id: Option<String>,\n        client_message_id: Option<String>,\n        payload_cipher_base64: String,\n        created_at_millis: i64,\n        delivered: bool,\n        direction: MessageDirection,\n    ) -> Self {\n        let created_at = match Utc.timestamp_millis_opt(created_at_millis) {\n            chrono::LocalResult::Single(ts) => ts,\n            _ => Utc\n                .timestamp_millis_opt(0)\n                .single()\n                .unwrap_or_else(Utc::now),\n        };\n\n        Self {\n            id,\n            owner_npub,\n            conversation_npub,\n            sender_npub,\n            recipient_npub,\n            event_id,\n            client_message_id,\n            payload_cipher_base64,\n            created_at,\n            delivered,\n            direction,\n            decrypted_content: None,\n        }\n    }\n\n    pub fn with_decrypted_content(mut self, content: String) -> Self {\n        self.decrypted_content = Some(content);\n        self\n    }\n\n    pub fn mark_delivered(mut self, delivered: bool) -> Self {\n        self.delivered = delivered;\n        self\n    }\n\n    pub fn cursor(&self) -> String {\n        let event_part = self.event_id.clone().unwrap_or_default();\n        format!(\"{}:{}\", self.created_at.timestamp_millis(), event_part)\n    }\n\n    pub fn created_at_millis(&self) -> i64 {\n        self.created_at.timestamp_millis()\n    }\n\n    pub fn counterparty_npub(&self) -> &str {\n        &self.conversation_npub\n    }\n}\n","traces":[{"line":13,"address":[16590224],"length":1,"stats":{"Line":1}},{"line":14,"address":[16478725],"length":1,"stats":{"Line":1}},{"line":15,"address":[20519618],"length":1,"stats":{"Line":0}},{"line":16,"address":[16588617],"length":1,"stats":{"Line":1}},{"line":24,"address":[16590304],"length":1,"stats":{"Line":1}},{"line":26,"address":[16553559,16553612],"length":1,"stats":{"Line":1}},{"line":27,"address":[16485876,16485829],"length":1,"stats":{"Line":2}},{"line":28,"address":[16685181],"length":1,"stats":{"Line":0}},{"line":65,"address":[16547928,16547824,16546736],"length":1,"stats":{"Line":2}},{"line":78,"address":[16590576,16590638],"length":1,"stats":{"Line":4}},{"line":79,"address":[20520024],"length":1,"stats":{"Line":2}},{"line":80,"address":[16553930,16554689],"length":1,"stats":{"Line":0}},{"line":102,"address":[16590000,16590184],"length":1,"stats":{"Line":1}},{"line":103,"address":[16590027,16590128],"length":1,"stats":{"Line":2}},{"line":104,"address":[16548116],"length":1,"stats":{"Line":1}},{"line":107,"address":[16473568],"length":1,"stats":{"Line":0}},{"line":108,"address":[24248567],"length":1,"stats":{"Line":0}},{"line":109,"address":[16686671],"length":1,"stats":{"Line":0}},{"line":112,"address":[16555480,16555152],"length":1,"stats":{"Line":0}},{"line":113,"address":[16591949],"length":1,"stats":{"Line":0}},{"line":114,"address":[20521356,20521425],"length":1,"stats":{"Line":0}},{"line":117,"address":[20521632],"length":1,"stats":{"Line":1}},{"line":118,"address":[16487749],"length":1,"stats":{"Line":1}},{"line":121,"address":[16590656],"length":1,"stats":{"Line":1}},{"line":122,"address":[24248997],"length":1,"stats":{"Line":1}}],"covered":16,"coverable":25},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","kind.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]\n#[repr(u32)]\npub enum EventKind {\n    Metadata = 0,\n    TextNote = 1,\n    RecommendRelay = 2,\n    Contacts = 3,\n    EncryptedDirectMessage = 4,\n    EventDeletion = 5,\n    Repost = 6,\n    Reaction = 7,\n    BadgeAward = 8,\n    ChannelCreation = 40,\n    ChannelMetadata = 41,\n    ChannelMessage = 42,\n    ChannelHideMessage = 43,\n    ChannelMuteUser = 44,\n    Custom(u32),\n}\n\nimpl From<u32> for EventKind {\n    fn from(value: u32) -> Self {\n        match value {\n            0 => EventKind::Metadata,\n            1 => EventKind::TextNote,\n            2 => EventKind::RecommendRelay,\n            3 => EventKind::Contacts,\n            4 => EventKind::EncryptedDirectMessage,\n            5 => EventKind::EventDeletion,\n            6 => EventKind::Repost,\n            7 => EventKind::Reaction,\n            8 => EventKind::BadgeAward,\n            40 => EventKind::ChannelCreation,\n            41 => EventKind::ChannelMetadata,\n            42 => EventKind::ChannelMessage,\n            43 => EventKind::ChannelHideMessage,\n            44 => EventKind::ChannelMuteUser,\n            v => EventKind::Custom(v),\n        }\n    }\n}\n\nimpl From<EventKind> for u32 {\n    fn from(value: EventKind) -> Self {\n        match value {\n            EventKind::Metadata => 0,\n            EventKind::TextNote => 1,\n            EventKind::RecommendRelay => 2,\n            EventKind::Contacts => 3,\n            EventKind::EncryptedDirectMessage => 4,\n            EventKind::EventDeletion => 5,\n            EventKind::Repost => 6,\n            EventKind::Reaction => 7,\n            EventKind::BadgeAward => 8,\n            EventKind::ChannelCreation => 40,\n            EventKind::ChannelMetadata => 41,\n            EventKind::ChannelMessage => 42,\n            EventKind::ChannelHideMessage => 43,\n            EventKind::ChannelMuteUser => 44,\n            EventKind::Custom(v) => v,\n        }\n    }\n}\n\nimpl EventKind {\n    pub fn from_u32(value: u32) -> Option<Self> {\n        Some(value.into())\n    }\n\n    pub fn as_u32(self) -> u32 {\n        self.into()\n    }\n}\n","traces":[{"line":24,"address":[15229136],"length":1,"stats":{"Line":0}},{"line":25,"address":[15191032],"length":1,"stats":{"Line":0}},{"line":26,"address":[15229198],"length":1,"stats":{"Line":0}},{"line":27,"address":[15233147],"length":1,"stats":{"Line":0}},{"line":28,"address":[15123301],"length":1,"stats":{"Line":0}},{"line":29,"address":[15116527],"length":1,"stats":{"Line":0}},{"line":30,"address":[15233177],"length":1,"stats":{"Line":0}},{"line":31,"address":[15229251],"length":1,"stats":{"Line":0}},{"line":32,"address":[15123341],"length":1,"stats":{"Line":0}},{"line":33,"address":[22891543],"length":1,"stats":{"Line":0}},{"line":34,"address":[15198097],"length":1,"stats":{"Line":0}},{"line":35,"address":[16437099],"length":1,"stats":{"Line":0}},{"line":36,"address":[15198117],"length":1,"stats":{"Line":0}},{"line":37,"address":[22891583],"length":1,"stats":{"Line":0}},{"line":38,"address":[16437129],"length":1,"stats":{"Line":0}},{"line":39,"address":[15229331],"length":1,"stats":{"Line":0}},{"line":40,"address":[15234765],"length":1,"stats":{"Line":0}},{"line":46,"address":[15234944],"length":1,"stats":{"Line":1}},{"line":47,"address":[22891640],"length":1,"stats":{"Line":1}},{"line":48,"address":[15130456],"length":1,"stats":{"Line":0}},{"line":49,"address":[15116709],"length":1,"stats":{"Line":1}},{"line":50,"address":[15235010],"length":1,"stats":{"Line":0}},{"line":51,"address":[15191324],"length":1,"stats":{"Line":0}},{"line":52,"address":[15198262],"length":1,"stats":{"Line":0}},{"line":53,"address":[15229456],"length":1,"stats":{"Line":0}},{"line":54,"address":[15123546],"length":1,"stats":{"Line":0}},{"line":55,"address":[15233412],"length":1,"stats":{"Line":0}},{"line":56,"address":[15116782],"length":1,"stats":{"Line":0}},{"line":57,"address":[15235080],"length":1,"stats":{"Line":0}},{"line":58,"address":[15130562],"length":1,"stats":{"Line":0}},{"line":59,"address":[15191404],"length":1,"stats":{"Line":0}},{"line":60,"address":[15123606],"length":1,"stats":{"Line":0}},{"line":61,"address":[22891808],"length":1,"stats":{"Line":0}},{"line":62,"address":[15233482],"length":1,"stats":{"Line":0}},{"line":68,"address":[15229568],"length":1,"stats":{"Line":0}},{"line":69,"address":[15116872],"length":1,"stats":{"Line":0}},{"line":72,"address":[16437424],"length":1,"stats":{"Line":0}},{"line":73,"address":[15329992],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","mod.rs"],"content":"mod kind;\nmod model;\npub mod validation;\n\npub use kind::EventKind;\npub use model::Event;\npub use validation::{\n    EventValidationError, KIND30078_KIND, KIND30078_MAX_ATTACHMENTS, ValidationResult,\n};\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","model.rs"],"content":"use crate::domain::value_objects::EventId;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Event {\n    pub id: String,\n    pub pubkey: String,\n    pub created_at: DateTime<Utc>,\n    pub kind: u32,\n    pub tags: Vec<Vec<String>>,\n    pub content: String,\n    pub sig: String,\n}\n\nimpl Event {\n    pub fn new(kind: u32, content: String, pubkey: String) -> Self {\n        Self {\n            id: String::new(),\n            pubkey,\n            created_at: Utc::now(),\n            kind,\n            tags: Vec::new(),\n            content,\n            sig: String::new(),\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<Vec<String>>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn add_tag(&mut self, tag: Vec<String>) {\n        self.tags.push(tag);\n    }\n\n    pub fn add_p_tag(&mut self, pubkey: String) {\n        self.tags.push(vec![\"p\".to_string(), pubkey]);\n    }\n\n    pub fn add_e_tag(&mut self, event_id: String) {\n        self.tags.push(vec![\"e\".to_string(), event_id]);\n    }\n\n    pub fn add_t_tag(&mut self, hashtag: String) {\n        self.tags.push(vec![\"t\".to_string(), hashtag]);\n    }\n\n    pub fn get_referenced_event_ids(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"e\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_referenced_pubkeys(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"p\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_hashtags(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"t\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn new_with_id(\n        id: EventId,\n        pubkey: String,\n        content: String,\n        kind: u32,\n        tags: Vec<Vec<String>>,\n        created_at: DateTime<Utc>,\n        sig: String,\n    ) -> Self {\n        Self {\n            id: id.to_hex(),\n            pubkey,\n            created_at,\n            kind,\n            tags,\n            content,\n            sig,\n        }\n    }\n}\n","traces":[{"line":17,"address":[25732610,25732096,25732684],"length":1,"stats":{"Line":2}},{"line":19,"address":[18866213],"length":1,"stats":{"Line":2}},{"line":21,"address":[18934135],"length":1,"stats":{"Line":2}},{"line":23,"address":[18972304],"length":1,"stats":{"Line":2}},{"line":25,"address":[13113964],"length":1,"stats":{"Line":2}},{"line":29,"address":[19073088,19073245],"length":1,"stats":{"Line":1}},{"line":30,"address":[18976770,18976688],"length":1,"stats":{"Line":2}},{"line":31,"address":[18860153],"length":1,"stats":{"Line":1}},{"line":34,"address":[13114496],"length":1,"stats":{"Line":0}},{"line":35,"address":[18978485],"length":1,"stats":{"Line":0}},{"line":38,"address":[18973342,18973328,18972928],"length":1,"stats":{"Line":0}},{"line":39,"address":[18941764,18941848,18942153],"length":1,"stats":{"Line":0}},{"line":42,"address":[18942192,18942592,18942606],"length":1,"stats":{"Line":0}},{"line":43,"address":[18977416,18977721,18977332],"length":1,"stats":{"Line":0}},{"line":46,"address":[19074192,19074592,19074606],"length":1,"stats":{"Line":0}},{"line":47,"address":[18875289,18874984,18874900],"length":1,"stats":{"Line":0}},{"line":50,"address":[18978208],"length":1,"stats":{"Line":0}},{"line":51,"address":[18978240],"length":1,"stats":{"Line":0}},{"line":53,"address":[18943219,18943200],"length":1,"stats":{"Line":0}},{"line":54,"address":[25734531,25734496],"length":1,"stats":{"Line":0}},{"line":58,"address":[18868656],"length":1,"stats":{"Line":0}},{"line":59,"address":[18875664],"length":1,"stats":{"Line":0}},{"line":61,"address":[18978624,18978643],"length":1,"stats":{"Line":0}},{"line":62,"address":[18875891,18875856],"length":1,"stats":{"Line":0}},{"line":66,"address":[18974880],"length":1,"stats":{"Line":0}},{"line":67,"address":[18978848],"length":1,"stats":{"Line":0}},{"line":69,"address":[18980595,18980576],"length":1,"stats":{"Line":0}},{"line":70,"address":[18862400,18862435],"length":1,"stats":{"Line":0}},{"line":74,"address":[18944497,18944569,18944000],"length":1,"stats":{"Line":2}},{"line":84,"address":[18979195],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":30},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","kind30078.rs"],"content":"use crate::domain::entities::event::{Event, KIND30078_KIND, KIND30078_MAX_ATTACHMENTS};\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Utc;\nuse serde_json::json;\nuse sha2::{Digest, Sha256};\n\nfn build_kind30078_event(\n    pubkey: String,\n    tags: Vec<Vec<String>>,\n    content: serde_json::Value,\n) -> Event {\n    let created_at = Utc::now();\n    let kind = KIND30078_KIND;\n    let content_str = content.to_string();\n    let tags_for_event = tags.clone();\n    let id_payload = json!([0, pubkey, created_at.timestamp(), kind, tags, content_str]);\n    let serialized = serde_json::to_vec(&id_payload).expect(\"serialize kind30078 event\");\n    let id = format!(\"{:x}\", Sha256::digest(&serialized));\n    Event {\n        id,\n        pubkey,\n        created_at,\n        kind,\n        tags: tags_for_event,\n        content: content_str,\n        sig: \"f\".repeat(128),\n    }\n}\n\nfn base_kind30078_tags(pubkey: &str, slug: &str, revision: &str) -> Vec<Vec<String>> {\n    vec![\n        vec![\n            \"d\".into(),\n            format!(\"kukuri:topic:{}:post:{}\", slug, revision),\n        ],\n        vec![\"k\".into(), \"topic-post\".into()],\n        vec![\"t\".into(), format!(\"topic:{}\", slug)],\n        vec![\n            \"a\".into(),\n            format!(\"30078:{}:kukuri:topic:{}:post:{}\", pubkey, slug, revision),\n        ],\n    ]\n}\n\n#[test]\nfn test_validate_kind30078_ok() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [\"iroh://attachment\"],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    assert!(event.validate_kind30078().is_ok());\n}\n\n#[test]\nfn test_validate_kind30078_missing_d_tag() {\n    let mut tags = base_kind30078_tags(&\"f\".repeat(64), \"slug\", &\"A\".repeat(26));\n    tags.retain(|tag| tag.first().map(|s| s != \"d\").unwrap_or(true));\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(\"f\".repeat(64), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMissing);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_t_value() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let mut tags = base_kind30078_tags(&pubkey, slug, &revision);\n    if let Some(t_tag) = tags\n        .iter_mut()\n        .find(|tag| tag.first().map(|s| s == \"t\").unwrap_or(false))\n    {\n        t_tag[1] = \"topic:wrong\".into();\n    }\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMismatch);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_attachment() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [\"invalid://attachment\"],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSchema);\n}\n\n#[test]\nfn test_validate_kind30078_missing_a_tag() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let mut tags = base_kind30078_tags(&pubkey, slug, &revision);\n    tags.retain(|tag| tag.first().map(|s| s != \"a\").unwrap_or(true));\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMissing);\n}\n\n#[test]\nfn test_validate_kind30078_attachment_overflow() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let attachments: Vec<String> = (0..=KIND30078_MAX_ATTACHMENTS)\n        .map(|i| format!(\"iroh://attachment/{i}\"))\n        .collect();\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": attachments,\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSize);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_semver() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"not-a-version\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSchema);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","mod.rs"],"content":"mod kind30078;\nmod nip01;\nmod nip10_19;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","nip01.rs"],"content":"use crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Duration;\nuse nostr_sdk::prelude::*;\nuse serde_json::json;\nuse sha2::{Digest, Sha256};\n\n#[tokio::test]\nasync fn test_validate_nip01_ok() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"hello nip01\")\n        .sign_with_keys(&keys)\n        .unwrap();\n\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_secs() as i64, 0)\n            .unwrap();\n\n    let dom = Event {\n        id: nostr_ev.id.to_string(),\n        pubkey: nostr_ev.pubkey.to_string(),\n        created_at,\n        kind: nostr_ev.kind.as_u16() as u32,\n        tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: nostr_ev.content.clone(),\n        sig: nostr_ev.sig.to_string(),\n    };\n\n    assert!(dom.validate_nip01().is_ok());\n}\n\n#[tokio::test]\nasync fn test_validate_nip01_bad_id() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"oops\")\n        .sign_with_keys(&keys)\n        .unwrap();\n\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_secs() as i64, 0)\n            .unwrap();\n\n    let mut dom = Event {\n        id: nostr_ev.id.to_string(),\n        pubkey: nostr_ev.pubkey.to_string(),\n        created_at,\n        kind: nostr_ev.kind.as_u16() as u32,\n        tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: nostr_ev.content.clone(),\n        sig: nostr_ev.sig.to_string(),\n    };\n    dom.content = \"tampered\".into();\n    let err = dom.validate_nip01().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Nip01Integrity);\n}\n\nfn build_event_with_data(\n    pubkey: &str,\n    kind: u32,\n    tags: Vec<Vec<String>>,\n    content: &str,\n    created_at: chrono::DateTime<chrono::Utc>,\n) -> Event {\n    let id_payload = json!([0, pubkey, created_at.timestamp(), kind, tags, content]);\n    let serialized = serde_json::to_vec(&id_payload).expect(\"serialize event\");\n    let id = format!(\"{:x}\", Sha256::digest(&serialized));\n    Event {\n        id,\n        pubkey: pubkey.to_string(),\n        created_at,\n        kind,\n        tags,\n        content: content.to_string(),\n        sig: \"f\".repeat(128),\n    }\n}\n\n#[test]\nfn test_validate_nip01_rejects_timestamp_drift() {\n    let created_at = chrono::Utc::now() - Duration::hours(2);\n    let event = build_event_with_data(&\"f\".repeat(64), 1, Vec::new(), \"time drift\", created_at);\n    let err = event.validate_nip01().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::TimestampOutOfRange);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","nip10_19.rs"],"content":"use crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse bech32::{Bech32, Hrp};\nuse nostr_sdk::prelude::*;\n\nfn dummy_event_with_tags(tags: Vec<Vec<String>>) -> Event {\n    Event {\n        id: \"0\".repeat(64),\n        pubkey: \"f\".repeat(64),\n        created_at: chrono::Utc::now(),\n        kind: 1,\n        tags,\n        content: String::new(),\n        sig: \"f\".repeat(128),\n    }\n}\n\nfn encode_bech32(hrp: &str, bytes: &[u8]) -> String {\n    let hrp = Hrp::parse(hrp).expect(\"valid hrp\");\n    bech32::encode::<Bech32>(hrp, bytes).expect(\"encode\")\n}\n\n#[test]\nfn test_validate_nip10_19_ok_with_bech32_refs() {\n    let keys = Keys::generate();\n    let npub = keys.public_key().to_bech32().unwrap();\n\n    let nostr_ev = EventBuilder::text_note(\"x\").sign_with_keys(&keys).unwrap();\n    let note = nostr_ev.id.to_bech32().unwrap();\n\n    let e_root = vec![\"e\".into(), note.clone(), String::new(), \"root\".into()];\n    let e_reply = vec![\"e\".into(), note, String::new(), \"reply\".into()];\n    let p_tag = vec![\"p\".into(), npub];\n    let ev = dummy_event_with_tags(vec![e_root, e_reply, p_tag]);\n    assert!(ev.validate_nip10_19().is_ok());\n}\n\n#[test]\nfn test_validate_nip10_19_rejects_invalid_marker_and_pk() {\n    let e_tag = vec![\"e\".into(), \"0\".repeat(64), String::new(), \"bad\".into()];\n    let p_tag = vec![\"p\".into(), \"zzz\".into()];\n    let ev = dummy_event_with_tags(vec![e_tag, p_tag]);\n    let err = ev.validate_nip10_19().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Nip10TagStructure);\n}\n\n#[test]\nfn test_validate_nip10_reply_without_root_ok() {\n    let e_tag_reply = vec![\"e\".into(), \"0\".repeat(64), String::new(), \"reply\".into()];\n    let ev = dummy_event_with_tags(vec![e_tag_reply]);\n    assert!(ev.validate_nip10_19().is_ok());\n}\n\n#[test]\nfn test_nprofile_tlv_multiple_relays_ok() {\n    let keys = Keys::generate();\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&keys.public_key().to_bytes());\n    for relay in [\"wss://relay.one\", \"wss://relay.two\"] {\n        let relay_bytes = relay.as_bytes();\n        bytes.push(1);\n        bytes.push(relay_bytes.len() as u8);\n        bytes.extend_from_slice(relay_bytes);\n    }\n    let encoded = encode_bech32(\"nprofile\", &bytes);\n    assert!(Event::validate_nprofile_tlv(&encoded).is_ok());\n}\n\n#[test]\nfn test_nprofile_tlv_rejects_invalid_relay_scheme() {\n    let keys = Keys::generate();\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&keys.public_key().to_bytes());\n    let relay_bytes = b\"https://relay.invalid\";\n    bytes.push(1);\n    bytes.push(relay_bytes.len() as u8);\n    bytes.extend_from_slice(relay_bytes);\n    let encoded = encode_bech32(\"nprofile\", &bytes);\n    assert!(Event::validate_nprofile_tlv(&encoded).is_err());\n}\n\n#[test]\nfn test_nevent_tlv_with_optional_author_and_kind() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"tlv\")\n        .sign_with_keys(&keys)\n        .expect(\"sign\");\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&nostr_ev.id.to_bytes());\n    let relay_bytes = b\"wss://relay.example\";\n    bytes.push(1);\n    bytes.push(relay_bytes.len() as u8);\n    bytes.extend_from_slice(relay_bytes);\n    bytes.push(2);\n    bytes.push(32);\n    bytes.extend_from_slice(&nostr_ev.pubkey.to_bytes());\n    let kind_bytes = (nostr_ev.kind.as_u16() as u32).to_be_bytes();\n    bytes.push(3);\n    bytes.push(kind_bytes.len() as u8);\n    bytes.extend_from_slice(&kind_bytes);\n    let encoded = encode_bech32(\"nevent\", &bytes);\n    assert!(Event::validate_nevent_tlv(&encoded).is_ok());\n}\n\n#[test]\nfn test_nevent_tlv_rejects_invalid_author_length() {\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&[0u8; 32]);\n    bytes.push(2);\n    bytes.push(31);\n    bytes.extend_from_slice(&[0u8; 31]);\n    let encoded = encode_bech32(\"nevent\", &bytes);\n    assert!(Event::validate_nevent_tlv(&encoded).is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","errors.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse std::fmt;\n\npub type ValidationResult<T> = Result<T, EventValidationError>;\n\npub(super) const MAX_EVENT_TAGS: usize = 512;\npub(super) const MAX_EVENT_CONTENT_BYTES: usize = 1_048_576;\npub(super) const TIMESTAMP_DRIFT_SECS: i64 = 600;\n\n#[derive(Debug, Clone)]\npub struct EventValidationError {\n    pub kind: ValidationFailureKind,\n    pub message: String,\n}\n\nimpl EventValidationError {\n    pub fn new(kind: ValidationFailureKind, message: impl Into<String>) -> Self {\n        Self {\n            kind,\n            message: message.into(),\n        }\n    }\n}\n\nimpl fmt::Display for EventValidationError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}: {}\", self.kind, self.message)\n    }\n}\n\nimpl std::error::Error for EventValidationError {}\n","traces":[{"line":17,"address":[22947760,22947872],"length":1,"stats":{"Line":4}},{"line":20,"address":[24705399,24705506],"length":1,"stats":{"Line":4}},{"line":26,"address":[22948000],"length":1,"stats":{"Line":0}},{"line":27,"address":[22955015],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","kind30078.rs"],"content":"use super::errors::{EventValidationError, MAX_EVENT_CONTENT_BYTES, ValidationResult};\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse semver::Version;\nuse serde::Deserialize;\n\npub const KIND30078_KIND: u32 = 30_078;\npub const KIND30078_MAX_ATTACHMENTS: usize = 16;\n\n#[derive(Debug, Deserialize)]\nstruct Kind30078Content {\n    body: String,\n    #[serde(default)]\n    attachments: Vec<String>,\n    metadata: Kind30078Metadata,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Kind30078Metadata {\n    app_version: String,\n    edited: bool,\n}\n\nimpl Event {\n    /// kind:30078 (kukuri topic post PRE) のタグ・content検証\n    pub fn validate_kind30078(&self) -> ValidationResult<()> {\n        if self.kind != KIND30078_KIND {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::UnsupportedKind,\n                format!(\n                    \"kind mismatch for kind30078 (expected {}, got {})\",\n                    KIND30078_KIND, self.kind\n                ),\n            ));\n        }\n\n        let mut identifier: Option<(String, String)> = None;\n        let mut has_k = false;\n        let mut topic_tag: Option<String> = None;\n        let mut address_tag: Option<String> = None;\n\n        for tag in &self.tags {\n            if tag.is_empty() {\n                continue;\n            }\n            match tag[0].as_str() {\n                \"d\" => {\n                    if identifier.is_some() {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            \"multiple d tags detected for kind30078\",\n                        ));\n                    }\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"d tag must be [\\\"d\\\", <identifier>] (len={})\", tag.len()),\n                        ));\n                    }\n                    let (slug, revision) = parse_kind30078_identifier(&tag[1])?;\n                    ensure_slug_valid(&slug)?;\n                    ensure_revision_valid(&revision)?;\n                    identifier = Some((slug, revision));\n                }\n                \"k\" => {\n                    if has_k {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            \"multiple k tags detected for kind30078\",\n                        ));\n                    }\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"k tag must be [\\\"k\\\", \\\"topic-post\\\"] (len={})\", tag.len()),\n                        ));\n                    }\n                    if tag[1] != \"topic-post\" {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"k tag must equal \\\"topic-post\\\" (value={})\", tag[1]),\n                        ));\n                    }\n                    has_k = true;\n                }\n                \"t\" => {\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\n                                \"t tag must be [\\\"t\\\", \\\"topic:<slug>\\\"] (len={})\",\n                                tag.len()\n                            ),\n                        ));\n                    }\n                    topic_tag = Some(tag[1].clone());\n                }\n                \"a\" => {\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"a tag must be [\\\"a\\\", <address>] (len={})\", tag.len()),\n                        ));\n                    }\n                    address_tag = Some(tag[1].clone());\n                }\n                _ => {}\n            }\n        }\n\n        let (slug, revision) = identifier.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing d tag for kind30078 event\",\n            )\n        })?;\n\n        if !has_k {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing k tag for kind30078 event\",\n            ));\n        }\n\n        let topic_value = topic_tag.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing t tag for kind30078 event\",\n            )\n        })?;\n\n        let expected_topic = format!(\"topic:{slug}\");\n        if topic_value != expected_topic {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMismatch,\n                format!(\"t tag must equal \\\"{expected_topic}\\\" (value={topic_value})\"),\n            ));\n        }\n\n        let address_value = address_tag.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing a tag for kind30078 event\",\n            )\n        })?;\n\n        let expected_address = format!(\n            \"{}:{}:kukuri:topic:{}:post:{}\",\n            KIND30078_KIND, self.pubkey, slug, revision\n        );\n        if address_value != expected_address {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMismatch,\n                format!(\"a tag must equal \\\"{expected_address}\\\" (value={address_value})\"),\n            ));\n        }\n\n        self.validate_kind30078_content()?;\n\n        Ok(())\n    }\n\n    fn validate_kind30078_content(&self) -> ValidationResult<()> {\n        let parsed: Kind30078Content = serde_json::from_str(&self.content).map_err(|err| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                format!(\"content must be valid JSON object: {err}\"),\n            )\n        })?;\n\n        if parsed.body.len() > MAX_EVENT_CONTENT_BYTES {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSize,\n                format!(\"body exceeds {MAX_EVENT_CONTENT_BYTES} bytes\"),\n            ));\n        }\n\n        if parsed.attachments.len() > KIND30078_MAX_ATTACHMENTS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSize,\n                format!(\"attachments exceed max {KIND30078_MAX_ATTACHMENTS}\"),\n            ));\n        }\n\n        for (idx, attachment) in parsed.attachments.iter().enumerate() {\n            if attachment.is_empty() {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\"attachment[{idx}] must not be empty\"),\n                ));\n            }\n            if !attachment.is_ascii() {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\"attachment[{idx}] must be ASCII\"),\n                ));\n            }\n            let lower = attachment.to_ascii_lowercase();\n            if !(lower.starts_with(\"iroh://\") || lower.starts_with(\"https://\")) {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\n                        \"attachment[{idx}] must start with iroh:// or https:// (value={attachment})\"\n                    ),\n                ));\n            }\n        }\n\n        Version::parse(&parsed.metadata.app_version).map_err(|err| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                format!(\"metadata.app_version must be semantic version: {err}\"),\n            )\n        })?;\n\n        if parsed.metadata.edited {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                \"metadata.edited=true is not supported for kind30078\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n}\n\nfn parse_kind30078_identifier(value: &str) -> ValidationResult<(String, String)> {\n    let rest = value.strip_prefix(\"kukuri:topic:\").ok_or_else(|| {\n        EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"d tag must start with kukuri:topic: (value={value})\"),\n        )\n    })?;\n    let (slug, revision) = rest.split_once(\":post:\").ok_or_else(|| {\n        EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"d tag must contain :post: separator (value={value})\"),\n        )\n    })?;\n    Ok((slug.to_string(), revision.to_string()))\n}\n\nfn ensure_slug_valid(slug: &str) -> ValidationResult<()> {\n    if slug.is_empty() || slug.len() > 48 {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"slug must be 1..48 characters (slug={slug})\"),\n        ));\n    }\n    if !slug\n        .chars()\n        .all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-')\n    {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"slug contains invalid characters: {slug}\"),\n        ));\n    }\n    Ok(())\n}\n\nfn ensure_revision_valid(revision: &str) -> ValidationResult<()> {\n    if revision.len() == 26 && is_crockford_base32(revision) {\n        return Ok(());\n    }\n    if revision.len() == 32 && revision.chars().all(|c| c.is_ascii_hexdigit()) {\n        return Ok(());\n    }\n    Err(EventValidationError::new(\n        ValidationFailureKind::Kind30078TagMismatch,\n        format!(\"invalid revision identifier: {revision}\"),\n    ))\n}\n\nfn is_crockford_base32(value: &str) -> bool {\n    value.chars().all(|c| {\n        let up = c.to_ascii_uppercase();\n        matches!(\n            up,\n            '0'..='9'\n                | 'A'..='H'\n                | 'J'..='K'\n                | 'M'..='N'\n                | 'P'..='T'\n                | 'V'..='Z'\n        )\n    })\n}\n","traces":[{"line":26,"address":[18876832,18884436,18879957],"length":1,"stats":{"Line":1}},{"line":27,"address":[18937703],"length":1,"stats":{"Line":1}},{"line":28,"address":[18863465],"length":1,"stats":{"Line":0}},{"line":29,"address":[18979911],"length":1,"stats":{"Line":0}},{"line":30,"address":[18863279],"length":1,"stats":{"Line":0}},{"line":37,"address":[18937763],"length":1,"stats":{"Line":1}},{"line":38,"address":[18944717],"length":1,"stats":{"Line":1}},{"line":39,"address":[18876965],"length":1,"stats":{"Line":1}},{"line":40,"address":[18944741],"length":1,"stats":{"Line":1}},{"line":42,"address":[18870021,18870396,18870567],"length":1,"stats":{"Line":3}},{"line":43,"address":[13118111,13120824],"length":1,"stats":{"Line":2}},{"line":46,"address":[18979242],"length":1,"stats":{"Line":1}},{"line":47,"address":[18948157],"length":1,"stats":{"Line":1}},{"line":48,"address":[18985452,18983358],"length":1,"stats":{"Line":2}},{"line":49,"address":[18951924,18950370],"length":1,"stats":{"Line":0}},{"line":50,"address":[18875626],"length":1,"stats":{"Line":0}},{"line":54,"address":[25741500,25741433],"length":1,"stats":{"Line":2}},{"line":55,"address":[18986941],"length":1,"stats":{"Line":0}},{"line":56,"address":[18943539],"length":1,"stats":{"Line":0}},{"line":57,"address":[18987243,18988454],"length":1,"stats":{"Line":0}},{"line":60,"address":[18950499,18950768,18950431,18951676],"length":1,"stats":{"Line":2}},{"line":61,"address":[19083108,19082440,19082542,19082295],"length":1,"stats":{"Line":2}},{"line":62,"address":[18869445,18870015,18869549,18869841],"length":1,"stats":{"Line":3}},{"line":63,"address":[18876406,18876683],"length":1,"stats":{"Line":2}},{"line":65,"address":[13121058,13122546,13120996],"length":1,"stats":{"Line":4}},{"line":66,"address":[18866802],"length":1,"stats":{"Line":1}},{"line":67,"address":[18980781,18981457],"length":1,"stats":{"Line":0}},{"line":68,"address":[18881829],"length":1,"stats":{"Line":0}},{"line":72,"address":[18868053,18868124],"length":1,"stats":{"Line":3}},{"line":73,"address":[18986938],"length":1,"stats":{"Line":0}},{"line":74,"address":[13122478],"length":1,"stats":{"Line":0}},{"line":75,"address":[18868515,18868182],"length":1,"stats":{"Line":0}},{"line":78,"address":[18986426,18986494],"length":1,"stats":{"Line":3}},{"line":79,"address":[19081487],"length":1,"stats":{"Line":0}},{"line":80,"address":[18984895],"length":1,"stats":{"Line":0}},{"line":81,"address":[18980967],"length":1,"stats":{"Line":0}},{"line":84,"address":[18984874],"length":1,"stats":{"Line":2}},{"line":86,"address":[13121080,13121132,13122109],"length":1,"stats":{"Line":5}},{"line":87,"address":[18979588,18980212],"length":1,"stats":{"Line":3}},{"line":88,"address":[18874734],"length":1,"stats":{"Line":0}},{"line":89,"address":[18867561],"length":1,"stats":{"Line":0}},{"line":90,"address":[18980527],"length":1,"stats":{"Line":0}},{"line":92,"address":[18867569,18867815],"length":1,"stats":{"Line":0}},{"line":96,"address":[18980300,18980226],"length":1,"stats":{"Line":3}},{"line":98,"address":[18983490,18983553,18983897],"length":1,"stats":{"Line":5}},{"line":99,"address":[13121234],"length":1,"stats":{"Line":1}},{"line":100,"address":[18867405],"length":1,"stats":{"Line":0}},{"line":101,"address":[18880770],"length":1,"stats":{"Line":0}},{"line":102,"address":[18983658,18983910],"length":1,"stats":{"Line":0}},{"line":105,"address":[18880731,18880808],"length":1,"stats":{"Line":3}},{"line":111,"address":[25736387,25739142,25736747,25736527],"length":1,"stats":{"Line":6}},{"line":112,"address":[23820417],"length":1,"stats":{"Line":1}},{"line":113,"address":[23915196],"length":1,"stats":{"Line":1}},{"line":118,"address":[13118320],"length":1,"stats":{"Line":1}},{"line":119,"address":[25736930,25736780],"length":1,"stats":{"Line":0}},{"line":120,"address":[18982385],"length":1,"stats":{"Line":0}},{"line":125,"address":[13120772,13118829,13118448,13118636],"length":1,"stats":{"Line":3}},{"line":126,"address":[23708977],"length":1,"stats":{"Line":0}},{"line":127,"address":[23708972],"length":1,"stats":{"Line":0}},{"line":132,"address":[18939190,18939050],"length":1,"stats":{"Line":3}},{"line":133,"address":[18981338,18981423],"length":1,"stats":{"Line":3}},{"line":134,"address":[18866351],"length":1,"stats":{"Line":1}},{"line":135,"address":[18878616],"length":1,"stats":{"Line":1}},{"line":136,"address":[18984496,18983152],"length":1,"stats":{"Line":2}},{"line":140,"address":[18878654,18878846,18878549,18879966],"length":1,"stats":{"Line":6}},{"line":141,"address":[23783777],"length":1,"stats":{"Line":1}},{"line":142,"address":[23702252],"length":1,"stats":{"Line":1}},{"line":147,"address":[25737671,25737814],"length":1,"stats":{"Line":3}},{"line":151,"address":[18978096,18978181],"length":1,"stats":{"Line":3}},{"line":152,"address":[18982701],"length":1,"stats":{"Line":0}},{"line":153,"address":[18947026],"length":1,"stats":{"Line":0}},{"line":154,"address":[13120222,13119818],"length":1,"stats":{"Line":0}},{"line":158,"address":[19078571,19078966,19078616,19078726],"length":1,"stats":{"Line":5}},{"line":160,"address":[25738267],"length":1,"stats":{"Line":1}},{"line":163,"address":[25743296,25745606,25746188],"length":1,"stats":{"Line":1}},{"line":164,"address":[23776896,23777121],"length":1,"stats":{"Line":2}},{"line":165,"address":[23709268],"length":1,"stats":{"Line":0}},{"line":166,"address":[23702325],"length":1,"stats":{"Line":0}},{"line":167,"address":[23716090,23716155],"length":1,"stats":{"Line":0}},{"line":171,"address":[13125519,13125351],"length":1,"stats":{"Line":3}},{"line":172,"address":[18990203],"length":1,"stats":{"Line":0}},{"line":173,"address":[25743818],"length":1,"stats":{"Line":0}},{"line":174,"address":[18948055,18945850],"length":1,"stats":{"Line":0}},{"line":178,"address":[18871295,18871223],"length":1,"stats":{"Line":3}},{"line":179,"address":[18947960],"length":1,"stats":{"Line":1}},{"line":180,"address":[18878120],"length":1,"stats":{"Line":1}},{"line":181,"address":[18987984,18989908],"length":1,"stats":{"Line":2}},{"line":185,"address":[19084373,19084461,19084713],"length":1,"stats":{"Line":5}},{"line":186,"address":[18989961,18990493],"length":1,"stats":{"Line":2}},{"line":187,"address":[18947765],"length":1,"stats":{"Line":0}},{"line":188,"address":[18990524],"length":1,"stats":{"Line":0}},{"line":189,"address":[18886833,18886004],"length":1,"stats":{"Line":0}},{"line":192,"address":[19085283,19085356],"length":1,"stats":{"Line":2}},{"line":193,"address":[25745018],"length":1,"stats":{"Line":0}},{"line":194,"address":[18872305],"length":1,"stats":{"Line":0}},{"line":195,"address":[18990656,18990601],"length":1,"stats":{"Line":0}},{"line":198,"address":[18990869,18990628],"length":1,"stats":{"Line":2}},{"line":199,"address":[19085739,19085668,19085833],"length":1,"stats":{"Line":3}},{"line":200,"address":[18947568],"length":1,"stats":{"Line":1}},{"line":201,"address":[13127102],"length":1,"stats":{"Line":1}},{"line":202,"address":[19085878],"length":1,"stats":{"Line":1}},{"line":209,"address":[18988256,18988345,18988839,18988602],"length":1,"stats":{"Line":5}},{"line":210,"address":[23915782],"length":1,"stats":{"Line":1}},{"line":211,"address":[23819232],"length":1,"stats":{"Line":1}},{"line":212,"address":[23702597],"length":1,"stats":{"Line":1}},{"line":216,"address":[18878775],"length":1,"stats":{"Line":1}},{"line":217,"address":[18953613],"length":1,"stats":{"Line":0}},{"line":218,"address":[18872038],"length":1,"stats":{"Line":0}},{"line":219,"address":[25744601],"length":1,"stats":{"Line":0}},{"line":223,"address":[18953529],"length":1,"stats":{"Line":1}},{"line":227,"address":[20523066,20522320],"length":1,"stats":{"Line":1}},{"line":228,"address":[23709563,23709833,23710320],"length":1,"stats":{"Line":1}},{"line":229,"address":[23710460],"length":1,"stats":{"Line":0}},{"line":230,"address":[20523110],"length":1,"stats":{"Line":0}},{"line":231,"address":[20523115],"length":1,"stats":{"Line":0}},{"line":234,"address":[23821363,23821590,23822000,23821188],"length":1,"stats":{"Line":2}},{"line":235,"address":[23816556],"length":1,"stats":{"Line":0}},{"line":236,"address":[20523286],"length":1,"stats":{"Line":0}},{"line":237,"address":[20523291],"length":1,"stats":{"Line":0}},{"line":240,"address":[23784848,23784701],"length":1,"stats":{"Line":1}},{"line":243,"address":[23778480],"length":1,"stats":{"Line":1}},{"line":244,"address":[23785435],"length":1,"stats":{"Line":1}},{"line":245,"address":[23704078],"length":1,"stats":{"Line":0}},{"line":246,"address":[23785479],"length":1,"stats":{"Line":0}},{"line":247,"address":[23917036],"length":1,"stats":{"Line":0}},{"line":250,"address":[23778736],"length":1,"stats":{"Line":1}},{"line":252,"address":[20524013,20524000],"length":1,"stats":{"Line":2}},{"line":254,"address":[23817032],"length":1,"stats":{"Line":0}},{"line":255,"address":[23816901],"length":1,"stats":{"Line":0}},{"line":256,"address":[23785725],"length":1,"stats":{"Line":0}},{"line":259,"address":[17958721],"length":1,"stats":{"Line":1}},{"line":262,"address":[23711312],"length":1,"stats":{"Line":2}},{"line":263,"address":[23779146],"length":1,"stats":{"Line":1}},{"line":264,"address":[23917693],"length":1,"stats":{"Line":1}},{"line":266,"address":[23817298,23817351,23817616,23817629],"length":1,"stats":{"Line":0}},{"line":267,"address":[23821519],"length":1,"stats":{"Line":0}},{"line":269,"address":[23917882],"length":1,"stats":{"Line":0}},{"line":270,"address":[23779283],"length":1,"stats":{"Line":0}},{"line":271,"address":[23786216],"length":1,"stats":{"Line":0}},{"line":275,"address":[23711728],"length":1,"stats":{"Line":2}},{"line":276,"address":[23786478,23786512],"length":1,"stats":{"Line":3}},{"line":277,"address":[23817709],"length":1,"stats":{"Line":3}},{"line":278,"address":[23718818,23718929],"length":1,"stats":{"Line":2}},{"line":280,"address":[23821665,23821693],"length":1,"stats":{"Line":3}},{"line":281,"address":[23823326,23823372],"length":1,"stats":{"Line":3}},{"line":282,"address":[23817814,23817773],"length":1,"stats":{"Line":0}},{"line":283,"address":[23705136,23705095],"length":1,"stats":{"Line":0}},{"line":284,"address":[23718881,23718922],"length":1,"stats":{"Line":0}},{"line":285,"address":[23823468,23823435],"length":1,"stats":{"Line":0}}],"covered":83,"coverable":149},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","mod.rs"],"content":"mod errors;\nmod kind30078;\nmod nip01;\nmod nip10_19;\nmod nip19;\nmod utils;\n\npub use errors::{EventValidationError, ValidationResult};\npub use kind30078::{KIND30078_KIND, KIND30078_MAX_ATTACHMENTS};\n\nuse super::Event;\n\nimpl Event {\n    pub fn validate_for_gateway(&self) -> ValidationResult<()> {\n        self.validate_nip01()?;\n        self.validate_nip10_19()?;\n        if self.kind == KIND30078_KIND {\n            self.validate_kind30078()?;\n        }\n        Ok(())\n    }\n\n    pub fn validate_nprofile_tlv(s: &str) -> ValidationResult<()> {\n        nip19::validate_nprofile_tlv(s)\n    }\n\n    pub fn validate_nevent_tlv(s: &str) -> ValidationResult<()> {\n        nip19::validate_nevent_tlv(s)\n    }\n}\n","traces":[{"line":14,"address":[18996192],"length":1,"stats":{"Line":2}},{"line":15,"address":[18886500,18886365],"length":1,"stats":{"Line":2}},{"line":16,"address":[18992348,18992506],"length":1,"stats":{"Line":2}},{"line":17,"address":[18998071],"length":1,"stats":{"Line":2}},{"line":18,"address":[18961436],"length":1,"stats":{"Line":0}},{"line":20,"address":[18893654],"length":1,"stats":{"Line":2}},{"line":23,"address":[18961616],"length":1,"stats":{"Line":1}},{"line":24,"address":[18954709],"length":1,"stats":{"Line":1}},{"line":27,"address":[18992848],"length":1,"stats":{"Line":1}},{"line":28,"address":[18992869],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip01.rs"],"content":"use super::errors::{\n    EventValidationError, MAX_EVENT_CONTENT_BYTES, MAX_EVENT_TAGS, TIMESTAMP_DRIFT_SECS,\n    ValidationResult,\n};\nuse super::utils::is_hex_n;\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Utc;\nuse sha2::{Digest, Sha256};\n\nimpl Event {\n    /// NIP-01に基づく基本バリデーション\n    /// - idは[0,pubkey,created_at,kind,tags,content]のsha256\n    /// - pubkeyは32byte hex（64桁）\n    /// - sigは64byte hex（128桁）\n    pub fn validate_nip01(&self) -> ValidationResult<()> {\n        if !is_hex_n(&self.pubkey, 64) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid pubkey (expect 64 hex)\",\n            ));\n        }\n        if !is_hex_n(&self.sig, 128) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid sig (expect 128 hex)\",\n            ));\n        }\n        if !is_hex_n(&self.id, 64) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid id (expect 64 hex)\",\n            ));\n        }\n\n        let created_at_secs = self.created_at.timestamp();\n        let payload = serde_json::json!([\n            0,\n            self.pubkey,\n            created_at_secs,\n            self.kind,\n            self.tags,\n            self.content,\n        ]);\n        let serialized = serde_json::to_vec(&payload).map_err(|e| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                format!(\"serialization error: {e}\"),\n            )\n        })?;\n        let hash = Sha256::digest(&serialized);\n        let calc_id = format!(\"{hash:x}\");\n        if calc_id != self.id {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"id mismatch (not NIP-01 compliant)\",\n            ));\n        }\n\n        let drift_secs = self\n            .created_at\n            .signed_duration_since(Utc::now())\n            .num_seconds()\n            .abs();\n        if drift_secs > TIMESTAMP_DRIFT_SECS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::TimestampOutOfRange,\n                format!(\"created_at outside ±{TIMESTAMP_DRIFT_SECS}s window (drift={drift_secs}s)\"),\n            ));\n        }\n\n        if self.tags.len() > MAX_EVENT_TAGS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::TagLimitExceeded,\n                format!(\"too many tags: {} (max {MAX_EVENT_TAGS})\", self.tags.len()),\n            ));\n        }\n\n        if self.content.len() > MAX_EVENT_CONTENT_BYTES {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::ContentTooLarge,\n                format!(\n                    \"content exceeds {MAX_EVENT_CONTENT_BYTES} bytes (actual {})\",\n                    self.content.len()\n                ),\n            ));\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[18989775,18989786,18986384],"length":1,"stats":{"Line":2}},{"line":17,"address":[18948310],"length":1,"stats":{"Line":2}},{"line":18,"address":[18986459],"length":1,"stats":{"Line":0}},{"line":19,"address":[18990387],"length":1,"stats":{"Line":0}},{"line":23,"address":[18880623],"length":1,"stats":{"Line":2}},{"line":24,"address":[18873891],"length":1,"stats":{"Line":0}},{"line":25,"address":[18990523],"length":1,"stats":{"Line":0}},{"line":29,"address":[18986688],"length":1,"stats":{"Line":2}},{"line":30,"address":[18880801],"length":1,"stats":{"Line":0}},{"line":31,"address":[18990649],"length":1,"stats":{"Line":0}},{"line":36,"address":[18990753],"length":1,"stats":{"Line":2}},{"line":37,"address":[18990784,18991749,18993735],"length":1,"stats":{"Line":2}},{"line":45,"address":[21356497,21356272],"length":1,"stats":{"Line":4}},{"line":46,"address":[21473092],"length":1,"stats":{"Line":0}},{"line":47,"address":[21472933],"length":1,"stats":{"Line":0}},{"line":48,"address":[15610667,15610602],"length":1,"stats":{"Line":0}},{"line":51,"address":[18993610],"length":1,"stats":{"Line":2}},{"line":52,"address":[13129763],"length":1,"stats":{"Line":2}},{"line":53,"address":[18889351,18889422],"length":1,"stats":{"Line":4}},{"line":54,"address":[18876981,18875725],"length":1,"stats":{"Line":2}},{"line":55,"address":[18994005],"length":1,"stats":{"Line":1}},{"line":60,"address":[18950265,18950359],"length":1,"stats":{"Line":4}},{"line":62,"address":[18957218],"length":1,"stats":{"Line":2}},{"line":65,"address":[18988585],"length":1,"stats":{"Line":2}},{"line":66,"address":[18883668],"length":1,"stats":{"Line":1}},{"line":67,"address":[18992560],"length":1,"stats":{"Line":1}},{"line":68,"address":[18876741,18875928],"length":1,"stats":{"Line":2}},{"line":72,"address":[18994250,18994188],"length":1,"stats":{"Line":4}},{"line":73,"address":[18890409],"length":1,"stats":{"Line":0}},{"line":74,"address":[18950588],"length":1,"stats":{"Line":0}},{"line":75,"address":[18883256,18882788],"length":1,"stats":{"Line":0}},{"line":79,"address":[13130336,13130279],"length":1,"stats":{"Line":4}},{"line":80,"address":[18992998],"length":1,"stats":{"Line":0}},{"line":81,"address":[18988786],"length":1,"stats":{"Line":0}},{"line":82,"address":[18876165],"length":1,"stats":{"Line":0}},{"line":84,"address":[25748559,25748618],"length":1,"stats":{"Line":0}},{"line":89,"address":[19089127],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip10_19.rs"],"content":"use super::errors::{EventValidationError, ValidationResult};\nuse super::nip19::{validate_nevent_tlv, validate_nprofile_tlv};\nuse super::utils::{is_hex_n, is_ws_url};\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse nostr_sdk::prelude::{EventId as NostrEventId, FromBech32 as _, PublicKey as NostrPublicKey};\n\nimpl Event {\n    /// NIP-10/NIP-19 の返信タグ・bech32/TLVの検証\n    pub fn validate_nip10_19(&self) -> ValidationResult<()> {\n        let mut root_seen = 0usize;\n        let mut reply_seen = 0usize;\n\n        for tag in &self.tags {\n            if tag.is_empty() {\n                continue;\n            }\n            match tag[0].as_str() {\n                \"e\" => {\n                    if tag.len() < 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Nip10TagStructure,\n                            \"invalid e tag (len < 2)\",\n                        ));\n                    }\n                    let evref = &tag[1];\n                    if !is_hex_n(evref, 64) {\n                        ensure_event_ref(evref)?;\n                    }\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(EventValidationError::new(\n                                ValidationFailureKind::Nip10TagStructure,\n                                format!(\"invalid e tag relay_url: {relay_url}\"),\n                            ));\n                        }\n                    }\n                    if tag.len() >= 4 {\n                        let marker = tag[3].as_str();\n                        match marker {\n                            \"root\" => root_seen += 1,\n                            \"reply\" => reply_seen += 1,\n                            \"mention\" => {}\n                            _ => {\n                                return Err(EventValidationError::new(\n                                    ValidationFailureKind::Nip10TagStructure,\n                                    format!(\"invalid e tag marker: {marker}\"),\n                                ));\n                            }\n                        }\n                    }\n                }\n                \"p\" => {\n                    if tag.len() < 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Nip10TagStructure,\n                            \"invalid p tag (len < 2)\",\n                        ));\n                    }\n                    let pkref = &tag[1];\n                    if !is_hex_n(pkref, 64) {\n                        ensure_pubkey_ref(pkref)?;\n                    }\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(EventValidationError::new(\n                                ValidationFailureKind::Nip10TagStructure,\n                                format!(\"invalid p tag relay_url: {relay_url}\"),\n                            ));\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if root_seen > 1 {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip10TagStructure,\n                \"multiple root markers in e tags\",\n            ));\n        }\n        if reply_seen > 1 {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip10TagStructure,\n                \"multiple reply markers in e tags\",\n            ));\n        }\n        Ok(())\n    }\n}\n\nfn ensure_event_ref(s: &str) -> ValidationResult<()> {\n    if s.starts_with(\"note1\") {\n        NostrEventId::from_bech32(s).map_err(|_| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip19Encoding,\n                \"invalid note reference bech32\",\n            )\n        })?;\n        Ok(())\n    } else if s.starts_with(\"nevent1\") {\n        validate_nevent_tlv(s)\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip10TagStructure,\n            format!(\"unsupported e tag reference format: {s}\"),\n        ))\n    }\n}\n\nfn ensure_pubkey_ref(s: &str) -> ValidationResult<()> {\n    if s.starts_with(\"npub1\") {\n        NostrPublicKey::from_bech32(s).map_err(|_| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip19Encoding,\n                \"invalid npub reference bech32\",\n            )\n        })?;\n        Ok(())\n    } else if s.starts_with(\"nprofile1\") {\n        validate_nprofile_tlv(s)\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip10TagStructure,\n            format!(\"unsupported p tag reference format: {s}\"),\n        ))\n    }\n}\n","traces":[{"line":10,"address":[18890864],"length":1,"stats":{"Line":3}},{"line":11,"address":[18890902],"length":1,"stats":{"Line":3}},{"line":12,"address":[18989855],"length":1,"stats":{"Line":3}},{"line":14,"address":[18989864,18989936],"length":1,"stats":{"Line":6}},{"line":15,"address":[19090322],"length":1,"stats":{"Line":4}},{"line":18,"address":[13131807],"length":1,"stats":{"Line":4}},{"line":19,"address":[18891304],"length":1,"stats":{"Line":4}},{"line":20,"address":[18877606],"length":1,"stats":{"Line":4}},{"line":21,"address":[18953009],"length":1,"stats":{"Line":0}},{"line":22,"address":[18991113],"length":1,"stats":{"Line":0}},{"line":26,"address":[18994984],"length":1,"stats":{"Line":4}},{"line":27,"address":[18885162],"length":1,"stats":{"Line":4}},{"line":28,"address":[25751065,25750964],"length":1,"stats":{"Line":3}},{"line":30,"address":[13132894],"length":1,"stats":{"Line":3}},{"line":31,"address":[18892490],"length":1,"stats":{"Line":3}},{"line":32,"address":[18953364],"length":1,"stats":{"Line":3}},{"line":33,"address":[25751411],"length":1,"stats":{"Line":1}},{"line":34,"address":[18995462],"length":1,"stats":{"Line":1}},{"line":35,"address":[18995470],"length":1,"stats":{"Line":1}},{"line":39,"address":[25751159],"length":1,"stats":{"Line":3}},{"line":40,"address":[18995688],"length":1,"stats":{"Line":3}},{"line":42,"address":[18996160,18995730,18995806],"length":1,"stats":{"Line":7}},{"line":43,"address":[13133541,13133431,13133793],"length":1,"stats":{"Line":7}},{"line":44,"address":[18892954],"length":1,"stats":{"Line":2}},{"line":46,"address":[18960918],"length":1,"stats":{"Line":2}},{"line":47,"address":[18997552],"length":1,"stats":{"Line":2}},{"line":48,"address":[18886056],"length":1,"stats":{"Line":2}},{"line":54,"address":[18995863],"length":1,"stats":{"Line":3}},{"line":55,"address":[18994272],"length":1,"stats":{"Line":2}},{"line":56,"address":[18891482],"length":1,"stats":{"Line":0}},{"line":57,"address":[18952306],"length":1,"stats":{"Line":0}},{"line":61,"address":[18884433],"length":1,"stats":{"Line":2}},{"line":62,"address":[18891443],"length":1,"stats":{"Line":2}},{"line":63,"address":[19090995,19090890],"length":1,"stats":{"Line":3}},{"line":65,"address":[18996189],"length":1,"stats":{"Line":2}},{"line":66,"address":[18891778],"length":1,"stats":{"Line":1}},{"line":67,"address":[18959580],"length":1,"stats":{"Line":1}},{"line":68,"address":[19091324],"length":1,"stats":{"Line":1}},{"line":69,"address":[18994758],"length":1,"stats":{"Line":1}},{"line":70,"address":[18878126],"length":1,"stats":{"Line":1}},{"line":79,"address":[19090294],"length":1,"stats":{"Line":3}},{"line":80,"address":[13131587],"length":1,"stats":{"Line":0}},{"line":81,"address":[18951867],"length":1,"stats":{"Line":0}},{"line":85,"address":[25749729],"length":1,"stats":{"Line":3}},{"line":86,"address":[18958919],"length":1,"stats":{"Line":1}},{"line":87,"address":[25749854],"length":1,"stats":{"Line":1}},{"line":91,"address":[18891136],"length":1,"stats":{"Line":3}},{"line":95,"address":[13612208],"length":1,"stats":{"Line":2}},{"line":96,"address":[13509355,13509820],"length":1,"stats":{"Line":4}},{"line":97,"address":[13709191,13709232,13708737,13709067,13709332],"length":1,"stats":{"Line":6}},{"line":98,"address":[13608885],"length":1,"stats":{"Line":1}},{"line":99,"address":[13577696],"length":1,"stats":{"Line":1}},{"line":103,"address":[21271023],"length":1,"stats":{"Line":2}},{"line":104,"address":[13495955,13495627],"length":1,"stats":{"Line":1}},{"line":105,"address":[13502746],"length":1,"stats":{"Line":1}},{"line":107,"address":[21270849],"length":1,"stats":{"Line":0}},{"line":108,"address":[13708814],"length":1,"stats":{"Line":0}},{"line":109,"address":[13612390],"length":1,"stats":{"Line":0}},{"line":114,"address":[13614576],"length":1,"stats":{"Line":2}},{"line":115,"address":[13496780,13496315],"length":1,"stats":{"Line":4}},{"line":116,"address":[13614673,13615003,13615268,13615168,13615127],"length":1,"stats":{"Line":6}},{"line":117,"address":[13496901],"length":1,"stats":{"Line":1}},{"line":118,"address":[25753296],"length":1,"stats":{"Line":1}},{"line":122,"address":[13510527],"length":1,"stats":{"Line":2}},{"line":123,"address":[13503131,13503459],"length":1,"stats":{"Line":1}},{"line":124,"address":[13709754],"length":1,"stats":{"Line":1}},{"line":126,"address":[13496593],"length":1,"stats":{"Line":0}},{"line":127,"address":[13614750],"length":1,"stats":{"Line":0}},{"line":128,"address":[13503254],"length":1,"stats":{"Line":0}}],"covered":57,"coverable":69},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip19.rs"],"content":"use super::errors::{EventValidationError, ValidationResult};\nuse super::utils::is_ws_url;\nuse crate::shared::validation::ValidationFailureKind;\nuse bech32;\n\npub(super) const MAX_TLV_RELAY_URLS: usize = 16;\npub(super) const MAX_TLV_RELAY_URL_LEN: usize = 255;\n\npub(super) fn validate_nprofile_tlv(s: &str) -> ValidationResult<()> {\n    let (hrp, data) = bech32::decode(s).map_err(|_| {\n        EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            \"invalid nprofile bech32 encoding\",\n        )\n    })?;\n    if hrp.as_str() != \"nprofile\" {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            format!(\"unexpected nprofile hrp: {hrp}\"),\n        ));\n    }\n    let bytes = data;\n    let mut has_pubkey = false;\n    let mut relay_count = 0usize;\n    parse_tlv(&bytes, |tag, value| match tag {\n        0 => {\n            if has_pubkey || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nprofile tag 0 must appear exactly once with 32 bytes\",\n                ))\n            } else {\n                has_pubkey = true;\n                Ok(())\n            }\n        }\n        1 => {\n            relay_count += 1;\n            if relay_count > MAX_TLV_RELAY_URLS {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"nprofile relay entries exceed max {MAX_TLV_RELAY_URLS}\"),\n                ));\n            }\n            validate_tlv_relay(value)\n        }\n        _ => Ok(()),\n    })?;\n    if !has_pubkey {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"nprofile missing tag 0 (pubkey)\",\n        ));\n    }\n    Ok(())\n}\n\npub(super) fn validate_nevent_tlv(s: &str) -> ValidationResult<()> {\n    let (hrp, data) = bech32::decode(s).map_err(|_| {\n        EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            \"invalid nevent bech32 encoding\",\n        )\n    })?;\n    if hrp.as_str() != \"nevent\" {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            format!(\"unexpected nevent hrp: {hrp}\"),\n        ));\n    }\n    let bytes = data;\n    let mut has_event_id = false;\n    let mut has_author = false;\n    let mut has_kind = false;\n    let mut relay_count = 0usize;\n    parse_tlv(&bytes, |tag, value| match tag {\n        0 => {\n            if has_event_id || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 0 must appear exactly once with 32 bytes\",\n                ))\n            } else {\n                has_event_id = true;\n                Ok(())\n            }\n        }\n        1 => {\n            relay_count += 1;\n            if relay_count > MAX_TLV_RELAY_URLS {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"nevent relay entries exceed max {MAX_TLV_RELAY_URLS}\"),\n                ));\n            }\n            validate_tlv_relay(value)\n        }\n        2 => {\n            if has_author || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 2 (author) must be 32 bytes and appear at most once\",\n                ))\n            } else {\n                has_author = true;\n                Ok(())\n            }\n        }\n        3 => {\n            if has_kind || value.len() != 4 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 3 (kind) must be 4 bytes and appear at most once\",\n                ))\n            } else {\n                has_kind = true;\n                Ok(())\n            }\n        }\n        _ => Ok(()),\n    })?;\n    if !has_event_id {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"nevent missing tag 0 (event id)\",\n        ));\n    }\n    Ok(())\n}\n\nfn parse_tlv(\n    bytes: &[u8],\n    mut handler: impl FnMut(u8, &[u8]) -> ValidationResult<()>,\n) -> ValidationResult<()> {\n    let mut i = 0usize;\n    while i + 2 <= bytes.len() {\n        let tag = bytes[i];\n        let len = bytes[i + 1] as usize;\n        i += 2;\n        if i + len > bytes.len() {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip19Tlv,\n                \"TLV value length exceeds buffer\",\n            ));\n        }\n        let value = &bytes[i..i + len];\n        handler(tag, value)?;\n        i += len;\n    }\n    if i == bytes.len() {\n        Ok(())\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"TLV parse ended with trailing bytes\",\n        ))\n    }\n}\n\nfn validate_tlv_relay(value: &[u8]) -> ValidationResult<()> {\n    if value.len() > MAX_TLV_RELAY_URL_LEN {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            format!(\"relay url exceeds {MAX_TLV_RELAY_URL_LEN} bytes\"),\n        ));\n    }\n    if value.is_empty() {\n        return Ok(());\n    }\n    match std::str::from_utf8(value) {\n        Ok(url) => {\n            if url.is_ascii() && is_ws_url(url) {\n                Ok(())\n            } else {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"relay url must be ws[s]:// and ASCII: {url}\"),\n                ))\n            }\n        }\n        Err(_) => Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"relay url must be valid UTF-8\",\n        )),\n    }\n}\n","traces":[{"line":9,"address":[12828496,12829658,12829888],"length":1,"stats":{"Line":2}},{"line":10,"address":[12622241,12622691,12623632],"length":1,"stats":{"Line":2}},{"line":11,"address":[12733505],"length":1,"stats":{"Line":0}},{"line":12,"address":[20391836],"length":1,"stats":{"Line":0}},{"line":16,"address":[12690410,12690576],"length":1,"stats":{"Line":4}},{"line":17,"address":[12729399],"length":1,"stats":{"Line":0}},{"line":18,"address":[12734417],"length":1,"stats":{"Line":0}},{"line":19,"address":[12729299,12728841],"length":1,"stats":{"Line":0}},{"line":22,"address":[12616040],"length":1,"stats":{"Line":2}},{"line":23,"address":[12629840],"length":1,"stats":{"Line":2}},{"line":24,"address":[12697608],"length":1,"stats":{"Line":2}},{"line":25,"address":[12616912,12616565,12616100,12616242,12616981,12616360],"length":1,"stats":{"Line":12}},{"line":27,"address":[20392052,20392001,20392131],"length":1,"stats":{"Line":4}},{"line":28,"address":[12617087],"length":1,"stats":{"Line":0}},{"line":29,"address":[20392058],"length":1,"stats":{"Line":0}},{"line":33,"address":[20392143],"length":1,"stats":{"Line":2}},{"line":34,"address":[20949393],"length":1,"stats":{"Line":2}},{"line":38,"address":[12617208,12617227,12617040],"length":1,"stats":{"Line":4}},{"line":39,"address":[12630975],"length":1,"stats":{"Line":2}},{"line":40,"address":[12691990],"length":1,"stats":{"Line":0}},{"line":41,"address":[12698785],"length":1,"stats":{"Line":0}},{"line":42,"address":[12830345],"length":1,"stats":{"Line":0}},{"line":45,"address":[12631018],"length":1,"stats":{"Line":2}},{"line":47,"address":[12733642],"length":1,"stats":{"Line":0}},{"line":49,"address":[12829383],"length":1,"stats":{"Line":2}},{"line":50,"address":[12729101,12729182],"length":1,"stats":{"Line":2}},{"line":51,"address":[20391365],"length":1,"stats":{"Line":1}},{"line":55,"address":[12697971],"length":1,"stats":{"Line":2}},{"line":58,"address":[12731640,12730176,12731410],"length":1,"stats":{"Line":3}},{"line":59,"address":[12700496,12699025,12699475],"length":1,"stats":{"Line":5}},{"line":60,"address":[20393969],"length":1,"stats":{"Line":1}},{"line":61,"address":[12618988],"length":1,"stats":{"Line":1}},{"line":65,"address":[12730570,12730736],"length":1,"stats":{"Line":6}},{"line":66,"address":[12831887],"length":1,"stats":{"Line":0}},{"line":67,"address":[12631953],"length":1,"stats":{"Line":0}},{"line":68,"address":[12625499,12624985],"length":1,"stats":{"Line":0}},{"line":71,"address":[12624872],"length":1,"stats":{"Line":3}},{"line":72,"address":[12618128],"length":1,"stats":{"Line":3}},{"line":73,"address":[12699656],"length":1,"stats":{"Line":3}},{"line":74,"address":[12618144],"length":1,"stats":{"Line":3}},{"line":75,"address":[12624936],"length":1,"stats":{"Line":3}},{"line":76,"address":[12619040,12618164,12619105,12618290,12618685,12618480],"length":1,"stats":{"Line":14}},{"line":78,"address":[12832238,12832414,12832335],"length":1,"stats":{"Line":6}},{"line":79,"address":[20951482],"length":1,"stats":{"Line":0}},{"line":80,"address":[12693861],"length":1,"stats":{"Line":0}},{"line":84,"address":[12693946],"length":1,"stats":{"Line":3}},{"line":85,"address":[12700880],"length":1,"stats":{"Line":3}},{"line":89,"address":[20951621,20951389,20951602],"length":1,"stats":{"Line":4}},{"line":90,"address":[12626186],"length":1,"stats":{"Line":2}},{"line":91,"address":[12737873],"length":1,"stats":{"Line":0}},{"line":92,"address":[12619452],"length":1,"stats":{"Line":0}},{"line":93,"address":[20394436],"length":1,"stats":{"Line":0}},{"line":96,"address":[20951652],"length":1,"stats":{"Line":2}},{"line":99,"address":[12694254,12694389,12693809,12694354],"length":1,"stats":{"Line":7}},{"line":100,"address":[12732380],"length":1,"stats":{"Line":1}},{"line":101,"address":[12701188],"length":1,"stats":{"Line":1}},{"line":105,"address":[12626561],"length":1,"stats":{"Line":2}},{"line":106,"address":[20394760],"length":1,"stats":{"Line":2}},{"line":110,"address":[12700760,12701427,12701327,12701462],"length":1,"stats":{"Line":6}},{"line":111,"address":[12626605],"length":1,"stats":{"Line":0}},{"line":112,"address":[12832885],"length":1,"stats":{"Line":0}},{"line":116,"address":[12738210],"length":1,"stats":{"Line":2}},{"line":117,"address":[12694521],"length":1,"stats":{"Line":2}},{"line":120,"address":[12693735],"length":1,"stats":{"Line":0}},{"line":122,"address":[12736719],"length":1,"stats":{"Line":2}},{"line":123,"address":[12632358,12632277],"length":1,"stats":{"Line":2}},{"line":124,"address":[12693101],"length":1,"stats":{"Line":1}},{"line":128,"address":[12735211],"length":1,"stats":{"Line":2}},{"line":131,"address":[12702760,12701472,12702640,12701603],"length":1,"stats":{"Line":5}},{"line":135,"address":[12701534,12702691],"length":1,"stats":{"Line":5}},{"line":136,"address":[12696765,12695775,12694618,12695613],"length":1,"stats":{"Line":10}},{"line":137,"address":[20953491,20953661,20952350,20952568,20952520,20953709],"length":1,"stats":{"Line":10}},{"line":138,"address":[12739929,12738618,12739775,12739840,12738772,12738683],"length":1,"stats":{"Line":10}},{"line":139,"address":[20953888,20953795,20952654,20953860,20952719,20952747],"length":1,"stats":{"Line":10}},{"line":140,"address":[12703200,12702094,12702043,12703251],"length":1,"stats":{"Line":10}},{"line":141,"address":[20397187,20396035,20396781,20395624],"length":1,"stats":{"Line":0}},{"line":142,"address":[12733344,12734501],"length":1,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[20952811,20954051,20952910,20953952],"length":1,"stats":{"Line":10}},{"line":147,"address":[12834022,12835271,12835175,12833861,12834119,12835023],"length":1,"stats":{"Line":11}},{"line":148,"address":[20397154,20396002,20395989,20397055,20397141,20395901],"length":1,"stats":{"Line":10}},{"line":150,"address":[12736874,12737922,12736765,12738031],"length":1,"stats":{"Line":8}},{"line":151,"address":[20396354,20395197],"length":1,"stats":{"Line":4}},{"line":153,"address":[12695926,12694769,12694833,12695990],"length":1,"stats":{"Line":0}},{"line":154,"address":[12732873,12734030],"length":1,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[12738912],"length":1,"stats":{"Line":2}},{"line":161,"address":[12735019],"length":1,"stats":{"Line":3}},{"line":162,"address":[20397450],"length":1,"stats":{"Line":0}},{"line":163,"address":[12735057],"length":1,"stats":{"Line":0}},{"line":164,"address":[12696950],"length":1,"stats":{"Line":0}},{"line":167,"address":[12703854],"length":1,"stats":{"Line":3}},{"line":168,"address":[12835654],"length":1,"stats":{"Line":0}},{"line":170,"address":[20954725],"length":1,"stats":{"Line":3}},{"line":171,"address":[12735304],"length":1,"stats":{"Line":3}},{"line":172,"address":[20955151,20954807],"length":1,"stats":{"Line":4}},{"line":173,"address":[12636775],"length":1,"stats":{"Line":3}},{"line":175,"address":[12735600],"length":1,"stats":{"Line":1}},{"line":176,"address":[12629546],"length":1,"stats":{"Line":1}},{"line":177,"address":[20954944],"length":1,"stats":{"Line":1}},{"line":181,"address":[12740959],"length":1,"stats":{"Line":1}},{"line":182,"address":[12735367],"length":1,"stats":{"Line":1}}],"covered":70,"coverable":102},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","utils.rs"],"content":"pub(super) fn is_hex_n(s: &str, n: usize) -> bool {\n    s.len() == n && s.chars().all(|c| c.is_ascii_hexdigit())\n}\n\npub(super) fn is_ws_url(url: &str) -> bool {\n    let lower = url.to_ascii_lowercase();\n    (lower.starts_with(\"ws://\") || lower.starts_with(\"wss://\")) && lower.len() > 5\n}\n","traces":[{"line":1,"address":[16416432],"length":1,"stats":{"Line":3}},{"line":2,"address":[22175921,22176000,22176013],"length":1,"stats":{"Line":9}},{"line":5,"address":[22280560,22280841],"length":1,"stats":{"Line":4}},{"line":6,"address":[22278945],"length":1,"stats":{"Line":4}},{"line":7,"address":[22375452,22375610,22375387],"length":1,"stats":{"Line":11}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","domain_event.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Nostr イベントのタグを表現するドメイン型。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct EventTag {\n    name: String,\n    values: Vec<String>,\n}\n\nimpl EventTag {\n    /// 新しいタグを生成する。タグ名は1文字以上である必要がある。\n    pub fn new<N: Into<String>>(name: N, values: Vec<String>) -> Result<Self, String> {\n        let name = name.into();\n        if name.trim().is_empty() {\n            return Err(\"Tag name cannot be empty\".to_string());\n        }\n        Ok(Self { name, values })\n    }\n\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    pub fn values(&self) -> &[String] {\n        &self.values\n    }\n\n    pub fn to_raw(&self) -> Vec<String> {\n        std::iter::once(self.name.clone())\n            .chain(self.values.iter().cloned())\n            .collect()\n    }\n\n    pub fn into_raw(self) -> Vec<String> {\n        std::iter::once(self.name).chain(self.values).collect()\n    }\n}\n\nimpl TryFrom<Vec<String>> for EventTag {\n    type Error = String;\n\n    fn try_from(value: Vec<String>) -> Result<Self, Self::Error> {\n        let mut iter = value.into_iter();\n        let name = iter\n            .next()\n            .ok_or_else(|| \"Tag vector must contain at least one element\".to_string())?;\n        let values: Vec<String> = iter.collect();\n        Self::new(name, values)\n    }\n}\n\nimpl From<EventTag> for Vec<String> {\n    fn from(tag: EventTag) -> Self {\n        tag.into_raw()\n    }\n}\n\n/// Application 層が扱う Nostr ドメインイベント。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct DomainEvent {\n    pub id: EventId,\n    pub author: PublicKey,\n    pub kind: EventKind,\n    pub created_at: DateTime<Utc>,\n    pub content: String,\n    pub tags: Vec<EventTag>,\n    pub signature: String,\n}\n\nimpl DomainEvent {\n    const SIGNATURE_LENGTH: usize = 128;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: EventId,\n        author: PublicKey,\n        kind: EventKind,\n        created_at: DateTime<Utc>,\n        content: String,\n        tags: Vec<EventTag>,\n        signature: String,\n    ) -> Result<Self, String> {\n        Self::validate_signature(&signature)?;\n        Ok(Self {\n            id,\n            author,\n            kind,\n            created_at,\n            content,\n            tags,\n            signature,\n        })\n    }\n\n    pub fn with_tags(mut self, tags: Vec<EventTag>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn signature(&self) -> &str {\n        &self.signature\n    }\n\n    pub fn kind(&self) -> EventKind {\n        self.kind\n    }\n\n    pub fn to_event(&self) -> Event {\n        Event {\n            id: self.id.to_hex(),\n            pubkey: self.author.as_hex().to_string(),\n            created_at: self.created_at,\n            kind: u32::from(self.kind),\n            tags: self.tags.iter().map(EventTag::to_raw).collect(),\n            content: self.content.clone(),\n            sig: self.signature.clone(),\n        }\n    }\n\n    fn validate_signature(signature: &str) -> Result<(), String> {\n        if signature.len() != Self::SIGNATURE_LENGTH {\n            return Err(\"Signature must be 128 hex characters\".to_string());\n        }\n        if !signature.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Signature must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl TryFrom<Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .into_iter()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content,\n            tags,\n            value.sig,\n        )\n    }\n}\n\nimpl TryFrom<&Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: &Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .iter()\n            .cloned()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content.clone(),\n            tags,\n            value.sig.clone(),\n        )\n    }\n}\n\nimpl From<&DomainEvent> for Event {\n    fn from(value: &DomainEvent) -> Self {\n        value.to_event()\n    }\n}\n","traces":[{"line":15,"address":[25754048,25754592,25755116,25754556],"length":1,"stats":{"Line":1}},{"line":16,"address":[25754070,25754630],"length":1,"stats":{"Line":1}},{"line":17,"address":[13609803,13609868],"length":1,"stats":{"Line":2}},{"line":18,"address":[13572002,13572048],"length":1,"stats":{"Line":0}},{"line":20,"address":[13609930],"length":1,"stats":{"Line":1}},{"line":23,"address":[13572144],"length":1,"stats":{"Line":0}},{"line":24,"address":[25755157],"length":1,"stats":{"Line":0}},{"line":27,"address":[13710640],"length":1,"stats":{"Line":0}},{"line":28,"address":[13614213],"length":1,"stats":{"Line":0}},{"line":31,"address":[13616182,13615888,13616211],"length":1,"stats":{"Line":1}},{"line":32,"address":[13497630,13497828,13497870],"length":1,"stats":{"Line":3}},{"line":33,"address":[21272668,21272838,21272883],"length":1,"stats":{"Line":2}},{"line":37,"address":[13579673,13579706,13579456],"length":1,"stats":{"Line":0}},{"line":38,"address":[25755542,25755638],"length":1,"stats":{"Line":0}},{"line":45,"address":[13711828,13711280,13711790],"length":1,"stats":{"Line":0}},{"line":46,"address":[13616513],"length":1,"stats":{"Line":0}},{"line":47,"address":[13505057,13505117,13505322],"length":1,"stats":{"Line":0}},{"line":49,"address":[13512560,13512272,13512572],"length":1,"stats":{"Line":0}},{"line":50,"address":[13512206],"length":1,"stats":{"Line":0}},{"line":51,"address":[13498609],"length":1,"stats":{"Line":0}},{"line":56,"address":[16687104],"length":1,"stats":{"Line":0}},{"line":57,"address":[16487800],"length":1,"stats":{"Line":0}},{"line":77,"address":[13616537,13615488],"length":1,"stats":{"Line":1}},{"line":86,"address":[13616239,13615584,13615657],"length":1,"stats":{"Line":2}},{"line":87,"address":[13580819],"length":1,"stats":{"Line":1}},{"line":88,"address":[21274100],"length":1,"stats":{"Line":1}},{"line":89,"address":[13512919],"length":1,"stats":{"Line":1}},{"line":92,"address":[13580714],"length":1,"stats":{"Line":1}},{"line":93,"address":[13499229],"length":1,"stats":{"Line":1}},{"line":94,"address":[13573856],"length":1,"stats":{"Line":1}},{"line":98,"address":[21274896,21275053],"length":1,"stats":{"Line":0}},{"line":99,"address":[13616674,13616592],"length":1,"stats":{"Line":0}},{"line":100,"address":[13574649],"length":1,"stats":{"Line":0}},{"line":103,"address":[25757616],"length":1,"stats":{"Line":0}},{"line":104,"address":[13506885],"length":1,"stats":{"Line":0}},{"line":107,"address":[25757632],"length":1,"stats":{"Line":0}},{"line":108,"address":[13574709],"length":1,"stats":{"Line":0}},{"line":111,"address":[13612832,13613559],"length":1,"stats":{"Line":1}},{"line":113,"address":[13612862],"length":1,"stats":{"Line":1}},{"line":114,"address":[13581773,13581697],"length":1,"stats":{"Line":2}},{"line":115,"address":[13574869],"length":1,"stats":{"Line":1}},{"line":116,"address":[13500305],"length":1,"stats":{"Line":1}},{"line":117,"address":[13500375],"length":1,"stats":{"Line":1}},{"line":118,"address":[13500496],"length":1,"stats":{"Line":1}},{"line":119,"address":[13514328],"length":1,"stats":{"Line":1}},{"line":123,"address":[13713952],"length":1,"stats":{"Line":1}},{"line":124,"address":[13575522],"length":1,"stats":{"Line":1}},{"line":125,"address":[13500985],"length":1,"stats":{"Line":0}},{"line":127,"address":[13613657,13613853,13613840],"length":1,"stats":{"Line":3}},{"line":128,"address":[13714113],"length":1,"stats":{"Line":0}},{"line":130,"address":[13613806],"length":1,"stats":{"Line":1}},{"line":137,"address":[13619288,13617808],"length":1,"stats":{"Line":0}},{"line":138,"address":[21276468,21276174,21277786,21276314],"length":1,"stats":{"Line":0}},{"line":139,"address":[25758962,25759104,25759248,25760205],"length":1,"stats":{"Line":0}},{"line":140,"address":[13620026,13620171],"length":1,"stats":{"Line":0}},{"line":141,"address":[13614613,13615172],"length":1,"stats":{"Line":0}},{"line":147,"address":[13515915],"length":1,"stats":{"Line":0}},{"line":148,"address":[13515949],"length":1,"stats":{"Line":0}},{"line":150,"address":[13715301],"length":1,"stats":{"Line":0}},{"line":151,"address":[13509038],"length":1,"stats":{"Line":0}},{"line":152,"address":[13620574],"length":1,"stats":{"Line":0}},{"line":153,"address":[25759790],"length":1,"stats":{"Line":0}},{"line":161,"address":[13615920,13617693,13617487],"length":1,"stats":{"Line":0}},{"line":162,"address":[13584997,13584780],"length":1,"stats":{"Line":0}},{"line":163,"address":[13517529,13518734,13517208,13517362],"length":1,"stats":{"Line":0}},{"line":164,"address":[13503736,13503884],"length":1,"stats":{"Line":0}},{"line":165,"address":[25761331,25761757],"length":1,"stats":{"Line":0}},{"line":172,"address":[13616880],"length":1,"stats":{"Line":0}},{"line":173,"address":[13578816],"length":1,"stats":{"Line":0}},{"line":175,"address":[25761669],"length":1,"stats":{"Line":0}},{"line":176,"address":[13717369,13717507],"length":1,"stats":{"Line":0}},{"line":177,"address":[13518203],"length":1,"stats":{"Line":0}},{"line":178,"address":[13504491],"length":1,"stats":{"Line":0}},{"line":184,"address":[18992896],"length":1,"stats":{"Line":0}},{"line":185,"address":[18893969],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":75},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","mod.rs"],"content":"pub mod domain_event;\npub mod profile_metadata;\n\npub use domain_event::{DomainEvent, EventTag};\npub use profile_metadata::{PrivacyPreferences, ProfileMetadata, RelayEndpoint};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","profile_metadata.rs"],"content":"use nostr_sdk::prelude::Url;\nuse serde::{Deserialize, Serialize};\n\n/// NIP-65 Relay Listエントリ。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct RelayEndpoint {\n    pub url: String,\n    pub read: bool,\n    pub write: bool,\n}\n\nimpl RelayEndpoint {\n    pub fn new(url: String, read: bool, write: bool) -> Result<Self, String> {\n        Self::validate_url(&url)?;\n        Ok(Self { url, read, write })\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        Self::validate_url(&self.url)\n    }\n\n    fn validate_url(value: &str) -> Result<(), String> {\n        if value.is_empty() {\n            return Err(\"Relay URL must not be empty\".to_string());\n        }\n        let parsed =\n            Url::parse(value).map_err(|_| \"Relay URL must be a valid websocket URL\".to_string())?;\n        match parsed.scheme() {\n            \"ws\" | \"wss\" => Ok(()),\n            _ => Err(\"Relay URL must use ws:// or wss://\".to_string()),\n        }\n    }\n}\n\n/// プロフィール更新時に利用するメタデータ。\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]\npub struct ProfileMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub website: Option<String>,\n    pub relays: Option<Vec<RelayEndpoint>>,\n    pub privacy: Option<PrivacyPreferences>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct PrivacyPreferences {\n    pub public_profile: bool,\n    pub show_online_status: bool,\n}\n\nimpl ProfileMetadata {\n    const NAME_LIMIT: usize = 100;\n    const DISPLAY_NAME_LIMIT: usize = 100;\n    const ABOUT_LIMIT: usize = 1_000;\n    const URL_LIMIT: usize = 1_024;\n    const MAX_RELAYS: usize = 64;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n        picture: Option<String>,\n        banner: Option<String>,\n        nip05: Option<String>,\n        lud16: Option<String>,\n        website: Option<String>,\n        relays: Option<Vec<RelayEndpoint>>,\n        privacy: Option<PrivacyPreferences>,\n    ) -> Result<Self, String> {\n        let metadata = Self {\n            name,\n            display_name,\n            about,\n            picture,\n            banner,\n            nip05,\n            lud16,\n            website,\n            relays,\n            privacy,\n        };\n        metadata.validate()?;\n        Ok(metadata)\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if let Some(name) = self.name.as_ref() {\n            if name.chars().count() > Self::NAME_LIMIT {\n                return Err(format!(\n                    \"Name is too long (max {} characters)\",\n                    Self::NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(display_name) = self.display_name.as_ref() {\n            if display_name.chars().count() > Self::DISPLAY_NAME_LIMIT {\n                return Err(format!(\n                    \"Display name is too long (max {} characters)\",\n                    Self::DISPLAY_NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(about) = self.about.as_ref() {\n            if about.chars().count() > Self::ABOUT_LIMIT {\n                return Err(format!(\n                    \"About is too long (max {} characters)\",\n                    Self::ABOUT_LIMIT\n                ));\n            }\n        }\n\n        if let Some(picture) = self.picture.as_ref() {\n            Self::validate_url_length(picture, \"Picture\")?;\n        }\n\n        if let Some(banner) = self.banner.as_ref() {\n            Self::validate_url_length(banner, \"Banner\")?;\n        }\n\n        if let Some(website) = self.website.as_ref() {\n            Self::validate_url_length(website, \"Website\")?;\n        }\n\n        if let Some(relays) = self.relays.as_ref() {\n            if relays.len() > Self::MAX_RELAYS {\n                return Err(format!(\n                    \"Relay list is too long (max {} entries)\",\n                    Self::MAX_RELAYS\n                ));\n            }\n            for relay in relays {\n                relay.validate()?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn validate_url_length(value: &str, field: &str) -> Result<(), String> {\n        if value.chars().count() > Self::URL_LIMIT {\n            return Err(format!(\n                \"{} URL is too long (max {} characters)\",\n                field,\n                Self::URL_LIMIT\n            ));\n        }\n        Ok(())\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.name.is_none()\n            && self.display_name.is_none()\n            && self.about.is_none()\n            && self.picture.is_none()\n            && self.banner.is_none()\n            && self.nip05.is_none()\n            && self.lud16.is_none()\n            && self.website.is_none()\n            && self.relays.as_ref().is_none_or(|relays| relays.is_empty())\n            && self.privacy.is_none()\n    }\n}\n","traces":[{"line":13,"address":[19775808,19776239],"length":1,"stats":{"Line":1}},{"line":14,"address":[20955347,20955275,20955579],"length":1,"stats":{"Line":2}},{"line":15,"address":[19779956],"length":1,"stats":{"Line":2}},{"line":18,"address":[19677328],"length":1,"stats":{"Line":1}},{"line":19,"address":[19780240],"length":1,"stats":{"Line":1}},{"line":22,"address":[19781920,19782702],"length":1,"stats":{"Line":1}},{"line":23,"address":[19738283],"length":1,"stats":{"Line":1}},{"line":24,"address":[19738399],"length":1,"stats":{"Line":0}},{"line":26,"address":[19781107,19780350,19780722,19780506,19781088],"length":1,"stats":{"Line":4}},{"line":28,"address":[19738652,19738799],"length":1,"stats":{"Line":4}},{"line":29,"address":[19671007],"length":1,"stats":{"Line":2}},{"line":30,"address":[13918623],"length":1,"stats":{"Line":0}},{"line":64,"address":[19671280,19671839],"length":1,"stats":{"Line":1}},{"line":88,"address":[19746486,19746308,19746373],"length":1,"stats":{"Line":2}},{"line":89,"address":[19877987],"length":1,"stats":{"Line":1}},{"line":92,"address":[19783376],"length":1,"stats":{"Line":1}},{"line":93,"address":[13919430],"length":1,"stats":{"Line":1}},{"line":94,"address":[19678936],"length":1,"stats":{"Line":1}},{"line":95,"address":[20957366],"length":1,"stats":{"Line":0}},{"line":102,"address":[19678974,19679184],"length":1,"stats":{"Line":1}},{"line":103,"address":[13919744],"length":1,"stats":{"Line":0}},{"line":104,"address":[19740126],"length":1,"stats":{"Line":0}},{"line":111,"address":[19782118,19782344],"length":1,"stats":{"Line":1}},{"line":112,"address":[19665720],"length":1,"stats":{"Line":0}},{"line":113,"address":[20957912],"length":1,"stats":{"Line":0}},{"line":120,"address":[19782400,19782626],"length":1,"stats":{"Line":1}},{"line":121,"address":[20958098,20958251],"length":1,"stats":{"Line":0}},{"line":124,"address":[19879301,19879170],"length":1,"stats":{"Line":1}},{"line":125,"address":[19783041,19782885],"length":1,"stats":{"Line":0}},{"line":128,"address":[20958436,20958569],"length":1,"stats":{"Line":1}},{"line":129,"address":[19673428,19673275],"length":1,"stats":{"Line":0}},{"line":132,"address":[19673502,19673371],"length":1,"stats":{"Line":2}},{"line":133,"address":[19666739],"length":1,"stats":{"Line":1}},{"line":134,"address":[19666808],"length":1,"stats":{"Line":0}},{"line":139,"address":[13921282,13921085],"length":1,"stats":{"Line":2}},{"line":140,"address":[19783689],"length":1,"stats":{"Line":1}},{"line":144,"address":[19741350],"length":1,"stats":{"Line":1}},{"line":147,"address":[20959296],"length":1,"stats":{"Line":0}},{"line":148,"address":[19783925],"length":1,"stats":{"Line":0}},{"line":149,"address":[19681092],"length":1,"stats":{"Line":0}},{"line":155,"address":[19748834],"length":1,"stats":{"Line":0}},{"line":158,"address":[19780256],"length":1,"stats":{"Line":0}},{"line":159,"address":[19749085],"length":1,"stats":{"Line":0}},{"line":160,"address":[19749109],"length":1,"stats":{"Line":0}},{"line":161,"address":[19681369],"length":1,"stats":{"Line":0}},{"line":162,"address":[19780333],"length":1,"stats":{"Line":0}},{"line":163,"address":[19742241],"length":1,"stats":{"Line":0}},{"line":164,"address":[19785957],"length":1,"stats":{"Line":0}},{"line":165,"address":[19742281],"length":1,"stats":{"Line":0}},{"line":166,"address":[19749235],"length":1,"stats":{"Line":0}},{"line":167,"address":[20959821,20959888,20959897],"length":1,"stats":{"Line":0}},{"line":168,"address":[20959854],"length":1,"stats":{"Line":0}}],"covered":26,"coverable":52},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","mod.rs"],"content":"pub mod account;\npub mod bookmark;\npub mod direct_message;\npub mod event;\npub mod event_gateway;\npub mod offline;\npub mod pending_topic;\npub mod post;\npub mod profile_avatar;\npub mod topic;\npub mod topic_metrics;\npub mod user;\n\npub use account::{AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret};\npub use bookmark::Bookmark;\npub use direct_message::{DirectMessage, MessageDirection, NewDirectMessage};\npub use event::{Event, EventKind};\npub use event_gateway::{DomainEvent, EventTag, ProfileMetadata};\npub use offline::{\n    CacheMetadataRecord, CacheStatusSnapshot, CacheTypeStatus, OfflineActionDraft,\n    OfflineActionFilter, OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord,\n    SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusRecord,\n    SyncStatusUpdate,\n};\npub use pending_topic::{PendingTopic, PendingTopicStatus};\npub use post::Post;\npub use profile_avatar::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry};\npub use topic::{Topic, TopicVisibility};\npub use topic_metrics::{\n    MetricsWindow, ScoreWeights, TopicActivityRow, TopicMetricsRecord, TopicMetricsSnapshot,\n    TopicMetricsUpsert,\n};\npub use user::{User, UserMetadata, UserProfile};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_metadata.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataRecord {\n    pub record_id: i64,\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub last_accessed_at: Option<DateTime<Utc>>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<DateTime<Utc>>,\n    pub metadata: Option<Value>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_status.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheTypeStatus {\n    pub cache_type: CacheType,\n    pub item_count: u64,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub is_stale: bool,\n    pub metadata: Option<Value>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheStatusSnapshot {\n    pub total_items: u64,\n    pub stale_items: u64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\nimpl CacheStatusSnapshot {\n    pub fn new(total_items: u64, stale_items: u64, cache_types: Vec<CacheTypeStatus>) -> Self {\n        Self {\n            total_items,\n            stale_items,\n            cache_types,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataUpdate {\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub metadata: Option<Value>,\n    pub expiry: Option<DateTime<Utc>>,\n    pub is_stale: Option<bool>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n","traces":[{"line":26,"address":[12966064],"length":1,"stats":{"Line":2}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","commands.rs"],"content":"use crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// オフラインアクションを保存する際に使用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionDraft {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n}\n\nimpl OfflineActionDraft {\n    pub fn new(\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        }\n    }\n}\n\n/// オフラインアクション取得時のフィルタ。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct OfflineActionFilter {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\nimpl OfflineActionFilter {\n    pub fn new(\n        user_pubkey: Option<PublicKey>,\n        include_synced: Option<bool>,\n        limit: Option<u32>,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            include_synced,\n            limit,\n        }\n    }\n}\n\n/// 同期キューに追加する際のドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItemDraft {\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub priority: Option<u8>,\n}\n\nimpl SyncQueueItemDraft {\n    pub fn new(\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        priority: Option<u8>,\n    ) -> Self {\n        Self {\n            action_type,\n            payload,\n            priority,\n        }\n    }\n}\n\n/// 楽観的更新の保存に利用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateDraft {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n}\n\nimpl OptimisticUpdateDraft {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        original_data: Option<OfflinePayload>,\n        updated_data: OfflinePayload,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            original_data,\n            updated_data,\n        }\n    }\n}\n\n/// 同期状態の更新に使用するコマンド。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusUpdate {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl SyncStatusUpdate {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        sync_status: SyncStatus,\n        conflict_data: Option<OfflinePayload>,\n        updated_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            sync_status,\n            conflict_data,\n            updated_at,\n        }\n    }\n}\n","traces":[{"line":18,"address":[11068848],"length":1,"stats":{"Line":2}},{"line":42,"address":[16828416],"length":1,"stats":{"Line":2}},{"line":64,"address":[16933008],"length":1,"stats":{"Line":2}},{"line":87,"address":[16931472],"length":1,"stats":{"Line":1}},{"line":113,"address":[17028016],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","mod.rs"],"content":"pub mod cache_metadata;\npub mod cache_status;\npub mod commands;\npub mod offline_action;\npub mod optimistic_update;\npub mod saved_action;\npub mod sync_queue_item;\npub mod sync_result;\npub mod sync_status_record;\n\npub use cache_metadata::CacheMetadataRecord;\npub use cache_status::{CacheMetadataUpdate, CacheStatusSnapshot, CacheTypeStatus};\npub use commands::{\n    OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft, SyncQueueItemDraft,\n    SyncStatusUpdate,\n};\npub use offline_action::OfflineActionRecord;\npub use optimistic_update::OptimisticUpdateRecord;\npub use saved_action::SavedOfflineAction;\npub use sync_queue_item::SyncQueueItem;\npub use sync_result::SyncResult;\npub use sync_status_record::SyncStatusRecord;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","offline_action.rs"],"content":"use crate::domain::value_objects::{\n    EntityId, OfflineActionId, OfflineActionType, OfflinePayload, PublicKey, RemoteEventId,\n    SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionRecord {\n    pub record_id: Option<i64>,\n    pub action_id: OfflineActionId,\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n    pub remote_id: Option<RemoteEventId>,\n    pub sync_status: SyncStatus,\n    pub created_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl OfflineActionRecord {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        record_id: Option<i64>,\n        action_id: OfflineActionId,\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n        sync_status: SyncStatus,\n        created_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) -> Self {\n        Self {\n            record_id,\n            action_id,\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n            remote_id,\n            sync_status,\n            created_at,\n            synced_at,\n            error_message: None,\n        }\n    }\n\n    pub fn with_error_message(mut self, message: Option<String>) -> Self {\n        self.error_message = message;\n        self\n    }\n\n    pub fn mark_synced(\n        &mut self,\n        status: SyncStatus,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) {\n        self.sync_status = status;\n        self.synced_at = synced_at;\n        self.remote_id = remote_id;\n    }\n}\n","traces":[{"line":25,"address":[21473168],"length":1,"stats":{"Line":3}},{"line":52,"address":[21363680,21363855],"length":1,"stats":{"Line":0}},{"line":53,"address":[21475307,21475216],"length":1,"stats":{"Line":0}},{"line":54,"address":[21570123],"length":1,"stats":{"Line":0}},{"line":57,"address":[20525568,20525894,20525872],"length":1,"stats":{"Line":0}},{"line":63,"address":[21357132],"length":1,"stats":{"Line":0}},{"line":64,"address":[21570334],"length":1,"stats":{"Line":0}},{"line":65,"address":[21438801],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","optimistic_update.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, OptimisticUpdateId};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateRecord {\n    pub record_id: i64,\n    pub update_id: OptimisticUpdateId,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n    pub is_confirmed: bool,\n    pub created_at: DateTime<Utc>,\n    pub confirmed_at: Option<DateTime<Utc>>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","saved_action.rs"],"content":"use super::OfflineActionRecord;\nuse crate::domain::value_objects::OfflineActionId;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SavedOfflineAction {\n    pub local_id: OfflineActionId,\n    pub action: OfflineActionRecord,\n}\n\nimpl SavedOfflineAction {\n    pub fn new(local_id: OfflineActionId, action: OfflineActionRecord) -> Self {\n        Self { local_id, action }\n    }\n}\n","traces":[{"line":12,"address":[19289408],"length":1,"stats":{"Line":3}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_queue_item.rs"],"content":"use crate::domain::value_objects::{\n    OfflineActionType, OfflinePayload, SyncQueueId, SyncQueueStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItem {\n    pub id: SyncQueueId,\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub status: SyncQueueStatus,\n    pub retry_count: u32,\n    pub max_retries: u32,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl SyncQueueItem {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: SyncQueueId,\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        status: SyncQueueStatus,\n        retry_count: u32,\n        max_retries: u32,\n        created_at: DateTime<Utc>,\n        updated_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        error_message: Option<String>,\n    ) -> Self {\n        Self {\n            id,\n            action_type,\n            payload,\n            status,\n            retry_count,\n            max_retries,\n            created_at,\n            updated_at,\n            synced_at,\n            error_message,\n        }\n    }\n}\n","traces":[{"line":23,"address":[23077808],"length":1,"stats":{"Line":3}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_result.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct SyncResult {\n    pub synced_count: u32,\n    pub failed_count: u32,\n    pub pending_count: u32,\n}\n\nimpl SyncResult {\n    pub fn new(synced_count: u32, failed_count: u32, pending_count: u32) -> Self {\n        Self {\n            synced_count,\n            failed_count,\n            pending_count,\n        }\n    }\n}\n","traces":[{"line":11,"address":[14393600],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_status_record.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, SyncStatus};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusRecord {\n    pub record_id: i64,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: DateTime<Utc>,\n    pub last_remote_sync: Option<DateTime<Utc>>,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","pending_topic.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum PendingTopicStatus {\n    #[serde(rename = \"queued\")]\n    Queued,\n    #[serde(rename = \"synced\")]\n    Synced,\n    #[serde(rename = \"failed\")]\n    Failed,\n}\n\nimpl PendingTopicStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            PendingTopicStatus::Queued => \"queued\",\n            PendingTopicStatus::Synced => \"synced\",\n            PendingTopicStatus::Failed => \"failed\",\n        }\n    }\n\n    pub fn from_value(value: &str) -> Self {\n        match value {\n            \"synced\" => PendingTopicStatus::Synced,\n            \"failed\" => PendingTopicStatus::Failed,\n            _ => PendingTopicStatus::Queued,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PendingTopic {\n    pub pending_id: String,\n    pub user_pubkey: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub status: PendingTopicStatus,\n    pub offline_action_id: String,\n    pub synced_topic_id: Option<String>,\n    pub error_message: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl PendingTopic {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        pending_id: String,\n        user_pubkey: String,\n        name: String,\n        description: Option<String>,\n        status: PendingTopicStatus,\n        offline_action_id: String,\n        synced_topic_id: Option<String>,\n        error_message: Option<String>,\n        created_at: DateTime<Utc>,\n        updated_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            pending_id,\n            user_pubkey,\n            name,\n            description,\n            status,\n            offline_action_id,\n            synced_topic_id,\n            error_message,\n            created_at,\n            updated_at,\n        }\n    }\n\n    pub fn with_status(mut self, status: PendingTopicStatus) -> Self {\n        self.status = status;\n        self.updated_at = Utc::now();\n        self\n    }\n}\n","traces":[{"line":15,"address":[22275520],"length":1,"stats":{"Line":0}},{"line":16,"address":[22244341],"length":1,"stats":{"Line":0}},{"line":17,"address":[22275557],"length":1,"stats":{"Line":0}},{"line":18,"address":[22237468],"length":1,"stats":{"Line":0}},{"line":19,"address":[22275603],"length":1,"stats":{"Line":0}},{"line":23,"address":[22376016],"length":1,"stats":{"Line":0}},{"line":25,"address":[22275671,22275724],"length":1,"stats":{"Line":0}},{"line":26,"address":[16417338,16417301],"length":1,"stats":{"Line":0}},{"line":27,"address":[22275731],"length":1,"stats":{"Line":0}},{"line":48,"address":[22169840],"length":1,"stats":{"Line":0}},{"line":74,"address":[22244992,22244864],"length":1,"stats":{"Line":0}},{"line":75,"address":[22163368],"length":1,"stats":{"Line":0}},{"line":76,"address":[22276078,22276134],"length":1,"stats":{"Line":0}},{"line":77,"address":[17045352],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","post.rs"],"content":"use super::user::User;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Post {\n    pub id: String,\n    pub content: String,\n    pub author: User,\n    pub topic_id: String,\n    pub created_at: DateTime<Utc>,\n    pub tags: Vec<String>,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: Vec<Post>,\n    pub is_synced: bool,\n    pub is_boosted: bool,\n    pub is_bookmarked: bool,\n    pub scope: Option<String>,\n    pub epoch: Option<i64>,\n    pub is_encrypted: bool,\n    pub local_id: Option<String>,\n    pub event_id: Option<String>,\n}\n\nimpl Post {\n    pub fn new(content: String, author: User, topic_id: String) -> Self {\n        let id = uuid::Uuid::new_v4().to_string();\n        let local_id = id.clone();\n\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at: chrono::Utc::now(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: Some(local_id),\n            event_id: None,\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn mark_as_synced(&mut self, event_id: String) {\n        self.is_synced = true;\n        self.event_id = Some(event_id);\n    }\n\n    pub fn add_reply(&mut self, reply: Post) {\n        self.replies.push(reply);\n    }\n\n    pub fn increment_likes(&mut self) {\n        self.likes += 1;\n    }\n\n    pub fn decrement_likes(&mut self) {\n        if self.likes > 0 {\n            self.likes -= 1;\n        }\n    }\n\n    pub fn increment_boosts(&mut self) {\n        self.boosts += 1;\n        self.is_boosted = true;\n    }\n\n    pub fn toggle_bookmark(&mut self) {\n        self.is_bookmarked = !self.is_bookmarked;\n    }\n\n    pub fn new_with_id(\n        id: String,\n        content: String,\n        author: User,\n        topic_id: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at,\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    pub fn mark_as_unsynced(&mut self) {\n        self.is_synced = false;\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostDraft {\n    pub id: String,\n    pub content: String,\n    pub topic_id: String,\n    pub tags: Vec<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl PostDraft {\n    pub fn new(content: String, topic_id: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            content,\n            topic_id,\n            tags: Vec::new(),\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn update_content(&mut self, content: String) {\n        self.content = content;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn into_post(self, author: User) -> Post {\n        Post::new(self.content, author, self.topic_id).with_tags(self.tags)\n    }\n}\n","traces":[{"line":27,"address":[18047408,18048689,18048540],"length":1,"stats":{"Line":2}},{"line":28,"address":[14232849,14232736],"length":1,"stats":{"Line":4}},{"line":29,"address":[14300638],"length":1,"stats":{"Line":2}},{"line":36,"address":[14432387],"length":1,"stats":{"Line":2}},{"line":37,"address":[14300898],"length":1,"stats":{"Line":2}},{"line":40,"address":[21994373],"length":1,"stats":{"Line":1}},{"line":47,"address":[21994468],"length":1,"stats":{"Line":2}},{"line":52,"address":[14301967,14301792],"length":1,"stats":{"Line":0}},{"line":53,"address":[14336944,14337035],"length":1,"stats":{"Line":0}},{"line":54,"address":[14295019],"length":1,"stats":{"Line":0}},{"line":57,"address":[14220480,14220565],"length":1,"stats":{"Line":1}},{"line":58,"address":[18048926],"length":1,"stats":{"Line":1}},{"line":59,"address":[14337236,14337141],"length":1,"stats":{"Line":2}},{"line":62,"address":[14337280],"length":1,"stats":{"Line":0}},{"line":63,"address":[14338933],"length":1,"stats":{"Line":0}},{"line":66,"address":[21995648],"length":1,"stats":{"Line":0}},{"line":67,"address":[14227506,14227469],"length":1,"stats":{"Line":0}},{"line":70,"address":[21995728],"length":1,"stats":{"Line":0}},{"line":71,"address":[14234526,14234580],"length":1,"stats":{"Line":0}},{"line":72,"address":[14295377,14295414],"length":1,"stats":{"Line":0}},{"line":76,"address":[14339136],"length":1,"stats":{"Line":0}},{"line":77,"address":[14302381,14302425],"length":1,"stats":{"Line":0}},{"line":78,"address":[14433965],"length":1,"stats":{"Line":0}},{"line":81,"address":[14234688],"length":1,"stats":{"Line":0}},{"line":82,"address":[14434005],"length":1,"stats":{"Line":0}},{"line":85,"address":[14338429,14338372,14337600],"length":1,"stats":{"Line":1}},{"line":98,"address":[21996058],"length":1,"stats":{"Line":2}},{"line":101,"address":[14234905],"length":1,"stats":{"Line":2}},{"line":113,"address":[14303328],"length":1,"stats":{"Line":1}},{"line":114,"address":[14338453],"length":1,"stats":{"Line":1}},{"line":129,"address":[14229137,14228608,14229065],"length":1,"stats":{"Line":0}},{"line":130,"address":[14340139],"length":1,"stats":{"Line":0}},{"line":132,"address":[14228724],"length":1,"stats":{"Line":0}},{"line":135,"address":[14435115],"length":1,"stats":{"Line":0}},{"line":141,"address":[14303904,14303961],"length":1,"stats":{"Line":0}},{"line":142,"address":[14340690,14340764],"length":1,"stats":{"Line":0}},{"line":143,"address":[14339139],"length":1,"stats":{"Line":0}},{"line":146,"address":[14335509,14335490,14335248],"length":1,"stats":{"Line":0}},{"line":147,"address":[21997683,21997541],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","profile_avatar.rs"],"content":"use std::str::FromStr;\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// プロフィールアバターの共有範囲\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ProfileAvatarAccessLevel {\n    #[default]\n    Public,\n    ContactsOnly,\n    Private,\n}\n\nimpl ProfileAvatarAccessLevel {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            ProfileAvatarAccessLevel::Public => \"public\",\n            ProfileAvatarAccessLevel::ContactsOnly => \"contacts_only\",\n            ProfileAvatarAccessLevel::Private => \"private\",\n        }\n    }\n}\n\nimpl FromStr for ProfileAvatarAccessLevel {\n    type Err = &'static str;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"public\" => Ok(ProfileAvatarAccessLevel::Public),\n            \"contacts_only\" => Ok(ProfileAvatarAccessLevel::ContactsOnly),\n            \"private\" => Ok(ProfileAvatarAccessLevel::Private),\n            _ => Err(\"invalid access level\"),\n        }\n    }\n}\n\n/// Doc に保存するプロフィールアバターのメタデータ\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileAvatarDocEntry {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub encrypted_key: String,\n    pub key_nonce: String,\n    pub encryption_nonce: String,\n    pub content_sha256: String,\n    pub updated_at: DateTime<Utc>,\n    pub version: u64,\n}\n","traces":[{"line":17,"address":[23821856],"length":1,"stats":{"Line":2}},{"line":18,"address":[23712005],"length":1,"stats":{"Line":2}},{"line":19,"address":[23817957],"length":1,"stats":{"Line":1}},{"line":20,"address":[23823564],"length":1,"stats":{"Line":1}},{"line":21,"address":[23786819],"length":1,"stats":{"Line":0}},{"line":29,"address":[23719104],"length":1,"stats":{"Line":2}},{"line":31,"address":[23786912,23786970],"length":1,"stats":{"Line":3}},{"line":32,"address":[23780100,23780014],"length":1,"stats":{"Line":2}},{"line":33,"address":[23818184,23818263],"length":1,"stats":{"Line":0}},{"line":34,"address":[23818238],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","topic.rs"],"content":"use crate::domain::constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\npub enum TopicVisibility {\n    #[default]\n    Public,\n    Private,\n}\n\nimpl TopicVisibility {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            TopicVisibility::Public => \"public\",\n            TopicVisibility::Private => \"private\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Topic {\n    pub id: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub is_joined: bool,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub visibility: TopicVisibility,\n    pub owner: Option<String>,\n    pub image_url: Option<String>,\n}\n\nimpl Topic {\n    pub fn new(name: String, description: Option<String>) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            name,\n            description,\n            created_at: now,\n            updated_at: now,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn public_topic() -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            name: \"#public\".to_string(),\n            description: Some(\"公開タイムライン\".to_string()),\n            created_at: now,\n            updated_at: now,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn join(&mut self) {\n        self.is_joined = true;\n        self.member_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn leave(&mut self) {\n        self.is_joined = false;\n        if self.member_count > 0 {\n            self.member_count -= 1;\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn increment_post_count(&mut self) {\n        self.post_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn decrement_post_count(&mut self) {\n        if self.post_count > 0 {\n            self.post_count -= 1;\n            self.updated_at = chrono::Utc::now();\n        }\n    }\n\n    pub fn update_description(&mut self, description: String) {\n        self.description = Some(description);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn set_owner(&mut self, owner: String) {\n        self.owner = Some(owner);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn new_with_id(\n        id: String,\n        name: String,\n        description: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            name,\n            description: Some(description),\n            created_at,\n            updated_at: created_at,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStats {\n    pub topic_id: String,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub active_members: u32,\n    pub posts_today: u32,\n    pub last_activity: Option<i64>,\n}\n\nimpl TopicStats {\n    pub fn new(topic_id: String) -> Self {\n        Self {\n            topic_id,\n            member_count: 0,\n            post_count: 0,\n            active_members: 0,\n            posts_today: 0,\n            last_activity: None,\n        }\n    }\n}\n","traces":[{"line":13,"address":[13505024],"length":1,"stats":{"Line":0}},{"line":14,"address":[13617733],"length":1,"stats":{"Line":0}},{"line":15,"address":[13586562],"length":1,"stats":{"Line":0}},{"line":16,"address":[21280041],"length":1,"stats":{"Line":0}},{"line":37,"address":[13519357,13519382,13518864],"length":1,"stats":{"Line":1}},{"line":38,"address":[13579723],"length":1,"stats":{"Line":1}},{"line":40,"address":[13621828],"length":1,"stats":{"Line":1}},{"line":54,"address":[13623936,13624465],"length":1,"stats":{"Line":0}},{"line":55,"address":[13580257],"length":1,"stats":{"Line":0}},{"line":57,"address":[13505679],"length":1,"stats":{"Line":0}},{"line":58,"address":[13622355],"length":1,"stats":{"Line":0}},{"line":59,"address":[13587297,13587373],"length":1,"stats":{"Line":0}},{"line":71,"address":[13519968],"length":1,"stats":{"Line":0}},{"line":72,"address":[13519982],"length":1,"stats":{"Line":0}},{"line":73,"address":[13580821,13580897],"length":1,"stats":{"Line":0}},{"line":74,"address":[13587782],"length":1,"stats":{"Line":0}},{"line":77,"address":[26508144],"length":1,"stats":{"Line":0}},{"line":78,"address":[13619054],"length":1,"stats":{"Line":0}},{"line":79,"address":[13624737,13624645],"length":1,"stats":{"Line":0}},{"line":80,"address":[26508259,26508222],"length":1,"stats":{"Line":0}},{"line":82,"address":[13520126],"length":1,"stats":{"Line":0}},{"line":85,"address":[21281456],"length":1,"stats":{"Line":0}},{"line":86,"address":[13588090,13588014],"length":1,"stats":{"Line":0}},{"line":87,"address":[13588047],"length":1,"stats":{"Line":0}},{"line":90,"address":[13520352],"length":1,"stats":{"Line":0}},{"line":91,"address":[21281674,21281582],"length":1,"stats":{"Line":0}},{"line":92,"address":[13506625,13506700],"length":1,"stats":{"Line":0}},{"line":93,"address":[21281636],"length":1,"stats":{"Line":0}},{"line":97,"address":[13581312,13581381],"length":1,"stats":{"Line":0}},{"line":98,"address":[13623374,13623460],"length":1,"stats":{"Line":0}},{"line":99,"address":[13619551],"length":1,"stats":{"Line":0}},{"line":102,"address":[26508704,26508773],"length":1,"stats":{"Line":0}},{"line":103,"address":[13588430,13588516],"length":1,"stats":{"Line":0}},{"line":104,"address":[13588543],"length":1,"stats":{"Line":0}},{"line":107,"address":[13507072],"length":1,"stats":{"Line":0}},{"line":116,"address":[13625363],"length":1,"stats":{"Line":0}},{"line":140,"address":[13588864],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","topic_metrics.rs"],"content":"use serde::Serialize;\n\n#[derive(Debug, Clone, Copy, Serialize)]\npub struct MetricsWindow {\n    pub start: i64,\n    pub end: i64,\n}\n\nimpl MetricsWindow {\n    pub fn new(start: i64, end: i64) -> Self {\n        Self { start, end }\n    }\n\n    pub fn duration_millis(&self) -> i64 {\n        self.end.saturating_sub(self.start)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize)]\npub struct ScoreWeights {\n    pub posts: f64,\n    pub unique_authors: f64,\n    pub boosts: f64,\n}\n\nimpl Default for ScoreWeights {\n    fn default() -> Self {\n        Self {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        }\n    }\n}\n\nimpl ScoreWeights {\n    pub fn score(&self, posts: i64, unique_authors: i64, boosts: i64) -> f64 {\n        (posts as f64 * self.posts)\n            + (unique_authors as f64 * self.unique_authors)\n            + (boosts as f64 * self.boosts)\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicActivityRow {\n    pub topic_id: String,\n    pub posts_count: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n}\n\nimpl TopicActivityRow {\n    pub fn empty(topic_id: impl Into<String>) -> Self {\n        Self {\n            topic_id: topic_id.into(),\n            posts_count: 0,\n            unique_authors: 0,\n            boosts: 0,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsUpsert {\n    pub topic_id: String,\n    pub window_start: i64,\n    pub window_end: i64,\n    pub posts_24h: i64,\n    pub posts_6h: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n    pub score_24h: f64,\n    pub score_6h: f64,\n    pub updated_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsRecord {\n    pub topic_id: String,\n    pub window_start: i64,\n    pub window_end: i64,\n    pub posts_24h: i64,\n    pub posts_6h: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n    pub score_24h: f64,\n    pub score_6h: f64,\n    pub updated_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsSnapshot {\n    pub window_start: i64,\n    pub window_end: i64,\n    pub metrics: Vec<TopicMetricsRecord>,\n}\n","traces":[{"line":10,"address":[12704576],"length":1,"stats":{"Line":0}},{"line":14,"address":[12735792],"length":1,"stats":{"Line":0}},{"line":15,"address":[12636853],"length":1,"stats":{"Line":0}},{"line":27,"address":[12741456],"length":1,"stats":{"Line":1}},{"line":37,"address":[12836288],"length":1,"stats":{"Line":0}},{"line":38,"address":[12836308,12836327,12836341],"length":1,"stats":{"Line":0}},{"line":39,"address":[12697837],"length":1,"stats":{"Line":0}},{"line":40,"address":[12630043],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":1,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","user.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n// UserProfile for compatibility with SqliteRepository\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct UserProfile {\n    pub display_name: String,\n    pub bio: String,\n    pub avatar_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct User {\n    pub npub: String,\n    pub pubkey: String,\n    pub profile: UserProfile,\n    pub name: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub public_profile: bool,\n    pub show_online_status: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl User {\n    pub fn new(npub: String, pubkey: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            npub,\n            pubkey,\n            profile: UserProfile {\n                display_name: String::new(),\n                bio: String::new(),\n                avatar_url: None,\n            },\n            name: None,\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn with_profile(\n        mut self,\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n    ) -> Self {\n        self.name = name;\n        self.profile.display_name = display_name.unwrap_or_default();\n        self.profile.bio = about.unwrap_or_default();\n        self.updated_at = chrono::Utc::now();\n        self\n    }\n\n    pub fn update_metadata(&mut self, metadata: UserMetadata) {\n        if let Some(name) = metadata.name {\n            self.name = Some(name);\n        }\n        if let Some(display_name) = metadata.display_name {\n            self.profile.display_name = display_name;\n        }\n        if let Some(about) = metadata.about {\n            self.profile.bio = about;\n        }\n        if let Some(picture) = metadata.picture {\n            self.profile.avatar_url = Some(picture);\n        }\n        if let Some(nip05) = metadata.nip05 {\n            self.nip05 = Some(nip05);\n        }\n        if let Some(lud16) = metadata.lud16 {\n            self.lud16 = Some(lud16);\n        }\n        if let Some(public_profile) = metadata.public_profile {\n            self.public_profile = public_profile;\n        }\n        if let Some(show_online_status) = metadata.show_online_status {\n            self.show_online_status = show_online_status;\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn pubkey(&self) -> &str {\n        &self.pubkey\n    }\n\n    pub fn npub(&self) -> &str {\n        &self.npub\n    }\n\n    pub fn from_pubkey(pubkey: &str) -> Self {\n        use nostr_sdk::prelude::*;\n\n        let npub = PublicKey::from_hex(pubkey)\n            .ok()\n            .and_then(|pk| pk.to_bech32().ok())\n            .unwrap_or_else(|| pubkey.to_string());\n\n        Self::new(npub, pubkey.to_string())\n    }\n\n    pub fn new_with_profile(npub: String, profile: UserProfile) -> Self {\n        let mut user = Self::new(npub.clone(), String::new());\n        user.profile = profile;\n        user\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub public_profile: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n","traces":[{"line":27,"address":[19785313,19785258,19784480],"length":1,"stats":{"Line":2}},{"line":28,"address":[19667866],"length":1,"stats":{"Line":2}},{"line":32,"address":[19742741],"length":1,"stats":{"Line":2}},{"line":47,"address":[13923693,13923008,13923652],"length":1,"stats":{"Line":0}},{"line":53,"address":[19675533],"length":1,"stats":{"Line":0}},{"line":54,"address":[13923288,13923196],"length":1,"stats":{"Line":0}},{"line":55,"address":[19669083],"length":1,"stats":{"Line":0}},{"line":56,"address":[19743832],"length":1,"stats":{"Line":0}},{"line":57,"address":[19787585],"length":1,"stats":{"Line":0}},{"line":60,"address":[19784797,19782112,19784094],"length":1,"stats":{"Line":1}},{"line":61,"address":[19782474,19782136],"length":1,"stats":{"Line":2}},{"line":62,"address":[19751112,19751196],"length":1,"stats":{"Line":1}},{"line":64,"address":[19676416,19676783,19676612],"length":1,"stats":{"Line":3}},{"line":65,"address":[19788202,19788142],"length":1,"stats":{"Line":1}},{"line":67,"address":[19683634,19683773,19683953],"length":1,"stats":{"Line":3}},{"line":68,"address":[19676886,19676826],"length":1,"stats":{"Line":1}},{"line":70,"address":[19788495,19788350,19788722],"length":1,"stats":{"Line":1}},{"line":71,"address":[19670331,19670239],"length":1,"stats":{"Line":0}},{"line":73,"address":[19883778,19883363,19883520],"length":1,"stats":{"Line":1}},{"line":74,"address":[19745177,19745075],"length":1,"stats":{"Line":0}},{"line":76,"address":[19752058,19752491,19752240],"length":1,"stats":{"Line":1}},{"line":77,"address":[19752278,19752370],"length":1,"stats":{"Line":0}},{"line":79,"address":[26512393,26512221],"length":1,"stats":{"Line":1}},{"line":80,"address":[19677787],"length":1,"stats":{"Line":0}},{"line":82,"address":[26512425],"length":1,"stats":{"Line":1}},{"line":83,"address":[19752588],"length":1,"stats":{"Line":0}},{"line":85,"address":[19783781],"length":1,"stats":{"Line":1}},{"line":88,"address":[19686304],"length":1,"stats":{"Line":2}},{"line":89,"address":[19785253],"length":1,"stats":{"Line":2}},{"line":92,"address":[19785264],"length":1,"stats":{"Line":2}},{"line":93,"address":[19785269],"length":1,"stats":{"Line":2}},{"line":96,"address":[19885648,19885963,19885995],"length":1,"stats":{"Line":1}},{"line":99,"address":[19679403],"length":1,"stats":{"Line":1}},{"line":101,"address":[19686718,19686704],"length":1,"stats":{"Line":0}},{"line":102,"address":[19747600,19747621],"length":1,"stats":{"Line":2}},{"line":104,"address":[19789544,19789383],"length":1,"stats":{"Line":1}},{"line":107,"address":[13927911,13927360,13927849],"length":1,"stats":{"Line":2}},{"line":108,"address":[19786258,19785870,19785786],"length":1,"stats":{"Line":2}},{"line":109,"address":[19791762,19791567],"length":1,"stats":{"Line":3}},{"line":110,"address":[19791794],"length":1,"stats":{"Line":2}}],"covered":28,"coverable":40},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","mod.rs"],"content":"#![allow(unused_imports)]\n\npub mod constants;\npub mod entities;\npub mod p2p;\npub mod value_objects;\n\npub use constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\npub use entities::{Event, Post, Topic, User};\npub use p2p::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, P2PEvent, TopicMesh, TopicStats,\n    generate_topic_id, user_topic_id,\n};\npub use value_objects::{EventId, Npub, TopicId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","distribution.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// イベント配信時の戦略を表すドメイン値。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum DistributionStrategy {\n    Broadcast,\n    Gossip,\n    Direct(String),\n    Hybrid,\n    Nostr,\n    P2P,\n}\n\n/// 配信時のメトリクス記録を抽象化するトレイト。\npub trait DistributionMetrics: Send + Sync {\n    fn record_attempt(&self, _strategy: &DistributionStrategy) {}\n    fn record_success(&self, _strategy: &DistributionStrategy) {}\n    fn record_failure(&self, _strategy: &DistributionStrategy) {}\n}\n","traces":[{"line":16,"address":[15205152,15205162],"length":1,"stats":{"Line":4}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","events.rs"],"content":"use crate::domain::p2p::message::GossipMessage;\n\n#[derive(Clone, Debug)]\npub enum P2PEvent {\n    MessageReceived {\n        topic_id: String,\n        message: GossipMessage,\n        _from_peer: Vec<u8>,\n    },\n    PeerJoined {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n    PeerLeft {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n    NetworkConnected {\n        node_id: String,\n        addresses: Vec<String>,\n    },\n    NetworkDisconnected {\n        node_id: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","message.rs"],"content":"use crate::domain::constants::TOPIC_NAMESPACE;\nuse crate::domain::entities::TopicVisibility;\nuse bincode::{Decode, Encode};\nuse chrono::Utc;\nuse secp256k1::ecdsa::Signature;\nuse secp256k1::{Message as Secp256k1Message, PublicKey, SECP256K1, SecretKey};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse uuid::Uuid;\n\npub type MessageId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GossipMessage {\n    /// メッセージID（重複チェック用）\n    pub id: MessageId,\n\n    /// メッセージタイプ\n    pub msg_type: MessageType,\n\n    /// ペイロード\n    pub payload: Vec<u8>,\n\n    /// タイムスタンプ\n    pub timestamp: i64,\n\n    /// 送信者の公開鍵（33バイト - 圧縮形式）\n    pub sender: Vec<u8>,\n\n    /// 署名\n    pub signature: Vec<u8>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Encode, Decode)]\npub enum MessageType {\n    /// Nostrイベント\n    NostrEvent,\n\n    /// トピック情報の同期\n    TopicSync,\n\n    /// ピア情報の交換\n    PeerExchange,\n\n    /// ハートビート\n    Heartbeat,\n}\n\nimpl GossipMessage {\n    /// 新しいメッセージを作成\n    pub fn new(msg_type: MessageType, payload: Vec<u8>, sender: Vec<u8>) -> Self {\n        let id = generate_message_id();\n        let timestamp = Utc::now().timestamp();\n\n        Self {\n            id,\n            msg_type,\n            payload,\n            timestamp,\n            sender,\n            signature: Vec::new(), // 署名は後で追加\n        }\n    }\n\n    /// メッセージを署名用のバイト列に変換\n    pub fn to_signing_bytes(&self) -> Vec<u8> {\n        let mut bytes = Vec::new();\n        bytes.extend_from_slice(&self.id);\n        bytes.extend_from_slice(&(self.msg_type as u8).to_le_bytes());\n        bytes.extend_from_slice(&self.payload);\n        bytes.extend_from_slice(&self.timestamp.to_le_bytes());\n        // 注意: senderは署名に含めない（署名作成時にはまだ設定されていないため）\n        bytes\n    }\n\n    /// バイト列からメッセージを復元\n    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {\n        bincode::decode_from_slice(bytes, bincode::config::standard())\n            .map(|(msg, _)| msg)\n            .map_err(|e| format!(\"Failed to deserialize message: {e}\"))\n    }\n\n    /// メッセージをバイト列に変換\n    pub fn to_bytes(&self) -> Result<Vec<u8>, String> {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| format!(\"Failed to serialize message: {e}\"))\n    }\n\n    /// メッセージに署名を付ける\n    pub fn sign(&mut self, secret_key: &SecretKey) -> Result<(), String> {\n        let signing_bytes = self.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest(hash.into());\n\n        // 署名\n        let signature = SECP256K1.sign_ecdsa(message, secret_key);\n        self.signature = signature.serialize_compact().to_vec();\n\n        // 公開鍵を設定（圧縮形式）\n        let public_key = PublicKey::from_secret_key(SECP256K1, secret_key);\n        self.sender = public_key.serialize().to_vec();\n\n        Ok(())\n    }\n\n    /// 署名を検証\n    pub fn verify_signature(&self) -> Result<bool, String> {\n        if self.signature.is_empty() || self.sender.is_empty() {\n            return Ok(false);\n        }\n\n        // 公開鍵を復元\n        let public_key =\n            PublicKey::from_slice(&self.sender).map_err(|e| format!(\"Invalid public key: {e}\"))?;\n\n        // 署名を復元\n        let signature = Signature::from_compact(&self.signature)\n            .map_err(|e| format!(\"Invalid signature: {e}\"))?;\n\n        // 署名対象のバイト列を作成\n        let mut message_for_verification = self.clone();\n        message_for_verification.signature = Vec::new(); // 署名フィールドを空にする\n        let signing_bytes = message_for_verification.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest(hash.into());\n\n        // 署名を検証\n        Ok(SECP256K1\n            .verify_ecdsa(message, &signature, &public_key)\n            .is_ok())\n    }\n}\n\n/// トピックIDの生成（既に `kukuri:` で始まる場合は再利用する）\npub fn generate_topic_id(topic_name: &str) -> String {\n    generate_topic_id_with_visibility(topic_name, TopicVisibility::Public)\n}\n\npub fn generate_topic_id_with_visibility(topic_name: &str, _visibility: TopicVisibility) -> String {\n    let trimmed = topic_name.trim();\n    let base = if trimmed.is_empty() {\n        format!(\"{TOPIC_NAMESPACE}default\")\n    } else {\n        let normalized = trimmed.to_lowercase();\n        if normalized.starts_with(TOPIC_NAMESPACE) {\n            normalized\n        } else {\n            format!(\"{TOPIC_NAMESPACE}{normalized}\")\n        }\n    };\n\n    if is_hashed_topic_id(&base) {\n        return base;\n    }\n\n    hash_topic_id(&base)\n}\n\npub fn topic_id_bytes(canonical_id: &str) -> [u8; 32] {\n    if let Some(tail) = canonical_id.strip_prefix(TOPIC_NAMESPACE) {\n        if tail.len() == 64 && tail.chars().all(|c| c.is_ascii_hexdigit()) {\n            if let Ok(decoded) = hex::decode(tail) {\n                if decoded.len() >= 32 {\n                    let mut out = [0u8; 32];\n                    out.copy_from_slice(&decoded[..32]);\n                    return out;\n                }\n            }\n        }\n    }\n\n    *blake3::hash(canonical_id.as_bytes()).as_bytes()\n}\n\nfn is_hashed_topic_id(topic_id: &str) -> bool {\n    topic_id\n        .strip_prefix(TOPIC_NAMESPACE)\n        .is_some_and(|tail| tail.len() == 64 && tail.chars().all(|c| c.is_ascii_hexdigit()))\n}\n\nfn hash_topic_id(base: &str) -> String {\n    let mut hasher = blake3::Hasher::new();\n    hasher.update(base.as_bytes());\n    format!(\n        \"{TOPIC_NAMESPACE}{}\",\n        hex::encode(hasher.finalize().as_bytes())\n    )\n}\n\n/// グローバルトピック（全体のタイムライン）\npub const GLOBAL_TOPIC: &str = \"kukuri:global\";\n\n/// ユーザー固有トピック\npub fn user_topic_id(pubkey: &str) -> String {\n    format!(\"kukuri:user:{pubkey}\")\n}\n\nfn generate_message_id() -> MessageId {\n    let uuid = Uuid::new_v4();\n    let mut id = [0u8; 32];\n    let uuid_bytes = uuid.as_bytes();\n    id[..16].copy_from_slice(uuid_bytes);\n    let timestamp = Utc::now().timestamp_nanos_opt().unwrap_or(0);\n    id[16..24].copy_from_slice(&timestamp.to_le_bytes());\n    id[24..].copy_from_slice(&uuid_bytes[8..]);\n    id\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_message_signing_and_verification() {\n        // 秘密鍵を生成\n        let mut rng = rand::rng();\n        let secret_key = SecretKey::new(&mut rng);\n\n        // メッセージを作成\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3, 4, 5], vec![]);\n\n        // 署名\n        assert!(message.sign(&secret_key).is_ok());\n        assert!(!message.signature.is_empty());\n        assert!(!message.sender.is_empty());\n\n        // 検証 - 正しい署名\n        assert!(message.verify_signature().unwrap());\n\n        // ペイロードを改ざん\n        message.payload.push(6);\n        assert!(!message.verify_signature().unwrap());\n\n        // 署名を改ざん\n        message.payload.pop(); // 元に戻す\n        if !message.signature.is_empty() {\n            message.signature[0] ^= 0xFF;\n        }\n        assert!(!message.verify_signature().unwrap());\n    }\n\n    #[test]\n    fn test_message_serialization() {\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![10, 20, 30],\n            vec![1; 33], // 公開鍵は33バイト\n        );\n\n        // シリアライズ\n        let bytes = message.to_bytes().unwrap();\n\n        // デシリアライズ\n        let deserialized = GossipMessage::from_bytes(&bytes).unwrap();\n\n        assert_eq!(message.id, deserialized.id);\n        assert_eq!(message.msg_type as u8, deserialized.msg_type as u8);\n        assert_eq!(message.payload, deserialized.payload);\n        assert_eq!(message.timestamp, deserialized.timestamp);\n        assert_eq!(message.sender, deserialized.sender);\n    }\n}\n","traces":[{"line":51,"address":[17960376,17959904,17960432],"length":1,"stats":{"Line":1}},{"line":52,"address":[23780233],"length":1,"stats":{"Line":1}},{"line":53,"address":[17960030],"length":1,"stats":{"Line":1}},{"line":61,"address":[23787360],"length":1,"stats":{"Line":1}},{"line":66,"address":[25762976,25763363],"length":1,"stats":{"Line":1}},{"line":67,"address":[17960491],"length":1,"stats":{"Line":1}},{"line":68,"address":[23824504],"length":1,"stats":{"Line":1}},{"line":69,"address":[23822926],"length":1,"stats":{"Line":1}},{"line":70,"address":[25763185],"length":1,"stats":{"Line":1}},{"line":71,"address":[23781020],"length":1,"stats":{"Line":1}},{"line":73,"address":[23706513],"length":1,"stats":{"Line":1}},{"line":77,"address":[23819280],"length":1,"stats":{"Line":1}},{"line":78,"address":[25763434],"length":1,"stats":{"Line":1}},{"line":79,"address":[23819420,23819408],"length":1,"stats":{"Line":2}},{"line":80,"address":[25763552,25763578],"length":1,"stats":{"Line":0}},{"line":84,"address":[23706944],"length":1,"stats":{"Line":1}},{"line":85,"address":[23823608],"length":1,"stats":{"Line":1}},{"line":86,"address":[23707024,23707045],"length":1,"stats":{"Line":0}},{"line":90,"address":[23823872,23824774],"length":1,"stats":{"Line":1}},{"line":91,"address":[23823915],"length":1,"stats":{"Line":1}},{"line":94,"address":[23825577],"length":1,"stats":{"Line":1}},{"line":95,"address":[23823986],"length":1,"stats":{"Line":1}},{"line":96,"address":[17961671],"length":1,"stats":{"Line":1}},{"line":99,"address":[17961801],"length":1,"stats":{"Line":1}},{"line":102,"address":[25764382],"length":1,"stats":{"Line":1}},{"line":103,"address":[17962001],"length":1,"stats":{"Line":1}},{"line":106,"address":[23824493],"length":1,"stats":{"Line":1}},{"line":107,"address":[23920996],"length":1,"stats":{"Line":1}},{"line":109,"address":[23789617],"length":1,"stats":{"Line":1}},{"line":113,"address":[23826448,23827842],"length":1,"stats":{"Line":1}},{"line":114,"address":[25764998],"length":1,"stats":{"Line":1}},{"line":115,"address":[23708238],"length":1,"stats":{"Line":0}},{"line":119,"address":[17962569,17962809,17963912,17963888],"length":1,"stats":{"Line":1}},{"line":123,"address":[23825046,23825221,23825434],"length":1,"stats":{"Line":2}},{"line":124,"address":[23716496,23716520,23715530],"length":1,"stats":{"Line":0}},{"line":127,"address":[23827005],"length":1,"stats":{"Line":1}},{"line":128,"address":[17963168,17963026],"length":1,"stats":{"Line":2}},{"line":129,"address":[23790507],"length":1,"stats":{"Line":1}},{"line":132,"address":[23783606],"length":1,"stats":{"Line":1}},{"line":133,"address":[17963381],"length":1,"stats":{"Line":1}},{"line":134,"address":[23722864],"length":1,"stats":{"Line":1}},{"line":137,"address":[23790763],"length":1,"stats":{"Line":1}},{"line":140,"address":[23922404],"length":1,"stats":{"Line":1}},{"line":147,"address":[23716624],"length":1,"stats":{"Line":1}},{"line":148,"address":[23716646],"length":1,"stats":{"Line":1}},{"line":151,"address":[25767375,25766672],"length":1,"stats":{"Line":1}},{"line":152,"address":[23784566],"length":1,"stats":{"Line":1}},{"line":153,"address":[17964323,17964868],"length":1,"stats":{"Line":2}},{"line":154,"address":[23784685],"length":1,"stats":{"Line":1}},{"line":156,"address":[23828326],"length":1,"stats":{"Line":1}},{"line":157,"address":[23724156,23724037,23723833],"length":1,"stats":{"Line":3}},{"line":158,"address":[23826980],"length":1,"stats":{"Line":1}},{"line":160,"address":[23828602,23828689],"length":1,"stats":{"Line":2}},{"line":164,"address":[23710590,23710680],"length":1,"stats":{"Line":2}},{"line":165,"address":[23785323],"length":1,"stats":{"Line":0}},{"line":168,"address":[23792229,23792303],"length":1,"stats":{"Line":2}},{"line":171,"address":[23924568,23923904],"length":1,"stats":{"Line":1}},{"line":172,"address":[23923963],"length":1,"stats":{"Line":1}},{"line":173,"address":[23827621,23828160,23828173,23827730],"length":1,"stats":{"Line":4}},{"line":174,"address":[23827775],"length":1,"stats":{"Line":1}},{"line":175,"address":[23711204,23711293],"length":1,"stats":{"Line":2}},{"line":176,"address":[23827958],"length":1,"stats":{"Line":1}},{"line":177,"address":[23829625],"length":1,"stats":{"Line":1}},{"line":178,"address":[23786014],"length":1,"stats":{"Line":1}},{"line":184,"address":[23792522],"length":1,"stats":{"Line":0}},{"line":187,"address":[23829840],"length":1,"stats":{"Line":1}},{"line":188,"address":[23924638],"length":1,"stats":{"Line":1}},{"line":190,"address":[23824416,23824344,23824429,23824320],"length":1,"stats":{"Line":2}},{"line":193,"address":[23825028,23824448],"length":1,"stats":{"Line":1}},{"line":194,"address":[23924859],"length":1,"stats":{"Line":1}},{"line":195,"address":[23786403,23786471],"length":1,"stats":{"Line":2}},{"line":196,"address":[25768739],"length":1,"stats":{"Line":1}},{"line":198,"address":[23924967],"length":1,"stats":{"Line":1}},{"line":206,"address":[23712352],"length":1,"stats":{"Line":1}},{"line":207,"address":[23786970],"length":1,"stats":{"Line":1}},{"line":210,"address":[23719280],"length":1,"stats":{"Line":1}},{"line":211,"address":[23794033],"length":1,"stats":{"Line":1}},{"line":212,"address":[23825228],"length":1,"stats":{"Line":1}},{"line":213,"address":[23794061],"length":1,"stats":{"Line":1}},{"line":214,"address":[23787156],"length":1,"stats":{"Line":1}},{"line":215,"address":[23829256],"length":1,"stats":{"Line":1}},{"line":216,"address":[23712666],"length":1,"stats":{"Line":1}},{"line":217,"address":[25769541],"length":1,"stats":{"Line":1}},{"line":218,"address":[23794395],"length":1,"stats":{"Line":1}}],"covered":78,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","mod.rs"],"content":"pub mod distribution;\npub mod events;\npub mod message;\npub mod topic_mesh;\n\n#[cfg(test)]\nmod tests;\n\npub use distribution::{DistributionMetrics, DistributionStrategy};\npub use events::P2PEvent;\npub use message::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, generate_topic_id,\n    generate_topic_id_with_visibility, topic_id_bytes, user_topic_id,\n};\npub use topic_mesh::{TopicMesh, TopicStats};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","gossip_tests.rs"],"content":"#[cfg(test)]\r\nmod tests {\r\n    use crate::domain::entities::Event;\r\n    use crate::domain::p2p::generate_topic_id;\r\n    use crate::infrastructure::p2p::gossip_service::GossipService;\r\n    use crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\r\n    use iroh::{Endpoint, discovery::static_provider::StaticProvider};\r\n    use std::sync::Arc;\r\n\r\n    macro_rules! skip_unless_p2p_enabled {\r\n        ($name:literal) => {\r\n            if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\r\n                eprintln!(\"skipping {} (ENABLE_P2P_INTEGRATION!=1)\", $name);\r\n                return;\r\n            }\r\n        };\r\n    }\r\n\r\n    async fn create_test_service() -> IrohGossipService {\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Endpoint::builder()\r\n            .discovery(static_discovery.clone())\r\n            .bind()\r\n            .await\r\n            .unwrap();\r\n        IrohGossipService::new(Arc::new(endpoint), static_discovery).unwrap()\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_topic_join_leave() {\r\n        skip_unless_p2p_enabled!(\"test_topic_join_leave\");\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"test-topic\");\r\n\r\n        // Join topic\r\n        let result = service.join_topic(&topic_id, vec![]).await;\r\n        assert!(result.is_ok());\r\n\r\n        // Verify topic is active\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert!(active_topics.contains(&topic_id));\r\n\r\n        // Leave topic\r\n        let result = service.leave_topic(&topic_id).await;\r\n        assert!(result.is_ok());\r\n\r\n        // Verify topic is removed\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert!(!active_topics.contains(&topic_id));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_multiple_topics() {\r\n        skip_unless_p2p_enabled!(\"test_multiple_topics\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"topic1\", \"topic2\", \"topic3\"];\r\n\r\n        // Join multiple topics\r\n        for topic in &topics {\r\n            let id = generate_topic_id(topic);\r\n            service.join_topic(&id, vec![]).await.unwrap();\r\n        }\r\n\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 3);\r\n\r\n        // Leave one topic\r\n        let id = generate_topic_id(\"topic2\");\r\n        service.leave_topic(&id).await.unwrap();\r\n\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 2);\r\n        assert!(!active_topics.contains(&generate_topic_id(\"topic2\")));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_leave_nonexistent_topic() {\r\n        skip_unless_p2p_enabled!(\"test_leave_nonexistent_topic\");\r\n        let service = create_test_service().await;\r\n        let topic = generate_topic_id(\"nonexistent\");\r\n        let result = service.leave_topic(&topic).await;\r\n        // 未参加トピックのleaveは冪等（エラーにしない）\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_broadcast_to_topic() {\r\n        skip_unless_p2p_enabled!(\"test_broadcast_to_topic\");\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"broadcast-test\");\r\n\r\n        // まずトピックに参加\r\n        service.join_topic(&topic_id, vec![]).await.unwrap();\r\n\r\n        // ダミーEventを作成してブロードキャスト\r\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(&topic_id, &event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_broadcast_to_nonexistent_topic() {\r\n        skip_unless_p2p_enabled!(\"test_broadcast_to_nonexistent_topic\");\r\n        let service = create_test_service().await;\r\n\r\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(\"nonexistent-topic\", &event).await;\r\n        // 未参加トピックのbroadcastはエラー\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_get_topic_status() {\r\n        skip_unless_p2p_enabled!(\"test_get_topic_status\");\r\n        // IrohGossipServiceではステータスAPIは最小提供のためスキップ\r\n        // 代わりにjoin後にget_joined_topicsで存在確認\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"status-test\");\r\n        service.join_topic(&topic_id, vec![]).await.unwrap();\r\n        let topics = service.get_joined_topics().await.unwrap();\r\n        assert!(topics.contains(&topic_id));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_get_all_topic_stats() {\r\n        skip_unless_p2p_enabled!(\"test_get_all_topic_stats\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"stats-topic1\", \"stats-topic2\", \"stats-topic3\"];\r\n        for topic in &topics {\r\n            service\r\n                .join_topic(&generate_topic_id(topic), vec![])\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let joined = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(joined.len(), 3);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_shutdown() {\r\n        skip_unless_p2p_enabled!(\"test_shutdown\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"shutdown-topic1\", \"shutdown-topic2\"];\r\n        for topic in &topics {\r\n            service\r\n                .join_topic(&generate_topic_id(topic), vec![])\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 2);\r\n        // leave all\r\n        for topic in &topics {\r\n            service\r\n                .leave_topic(&generate_topic_id(topic))\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 0);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_node_id() {\r\n        skip_unless_p2p_enabled!(\"test_node_id\");\r\n        // IrohGossipServiceでは直接のNodeID APIは提供しないため簡易確認のみ\r\n        let _service = create_test_service().await;\r\n        assert!(true);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_node_addr() {\r\n        skip_unless_p2p_enabled!(\"test_node_addr\");\r\n        // IrohGossipServiceでは直接のアドレスAPIは提供しないためスキップ\r\n        let _service = create_test_service().await;\r\n        assert!(true);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_concurrent_topic_operations() {\r\n        skip_unless_p2p_enabled!(\"test_concurrent_topic_operations\");\r\n        use std::sync::Arc;\r\n        use tokio::task;\r\n\r\n        let service = Arc::new(create_test_service().await);\r\n        let mut handles = vec![];\r\n\r\n        // 並行して複数のトピック操作を実行\r\n        for i in 0..5 {\r\n            let service_clone = service.clone();\r\n            let handle = task::spawn(async move {\r\n                let topic_id = generate_topic_id(&format!(\"concurrent-topic-{i}\"));\r\n                service_clone.join_topic(&topic_id, vec![]).await.unwrap();\r\n                let joined = service_clone.get_joined_topics().await.unwrap();\r\n                assert!(joined.contains(&topic_id));\r\n                service_clone.leave_topic(&topic_id).await.unwrap();\r\n            });\r\n            handles.push(handle);\r\n        }\r\n\r\n        // すべてのタスクが完了するのを待つ\r\n        for handle in handles {\r\n            handle.await.unwrap();\r\n        }\r\n\r\n        // 最終的にすべてのトピックから離脱していることを確認\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 0);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","message_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\n    use crate::domain::entities::TopicVisibility;\n    use crate::domain::p2p::message::*;\n\n    #[test]\n    fn test_message_type_copy() {\n        let msg_type = MessageType::NostrEvent;\n        let copied = msg_type;\n        assert!(matches!(copied, MessageType::NostrEvent));\n    }\n\n    #[test]\n    fn test_gossip_message_creation() {\n        let msg_type = MessageType::NostrEvent;\n        let payload = vec![1, 2, 3, 4, 5];\n        let sender = vec![0; 32];\n\n        let message = GossipMessage::new(msg_type, payload.clone(), sender.clone());\n\n        assert!(matches!(message.msg_type, MessageType::NostrEvent));\n        assert_eq!(message.payload, payload);\n        assert_eq!(message.sender, sender);\n        assert!(message.timestamp > 0);\n        assert_eq!(message.signature.len(), 0); // 初期状態では署名なし\n    }\n\n    #[test]\n    fn test_message_id_uniqueness() {\n        let messages: Vec<GossipMessage> = (0..100)\n            .map(|i| GossipMessage::new(MessageType::Heartbeat, vec![i as u8], vec![0; 32]))\n            .collect();\n\n        // すべてのメッセージIDがユニークであることを確認\n        let mut ids = messages.iter().map(|m| m.id).collect::<Vec<_>>();\n        ids.sort();\n        ids.dedup();\n        assert_eq!(ids.len(), 100);\n    }\n\n    #[test]\n    fn test_generate_topic_id() {\n        let bitcoin_base = format!(\"{TOPIC_NAMESPACE}bitcoin\");\n        let nostr_base = format!(\"{TOPIC_NAMESPACE}nostr\");\n        let test_topic_base = format!(\"{TOPIC_NAMESPACE}test topic\");\n        assert_eq!(\n            generate_topic_id(\"Bitcoin\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(bitcoin_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(\n            generate_topic_id(\"NOSTR\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(nostr_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(\n            generate_topic_id(\"Test Topic\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(test_topic_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(generate_topic_id(\"public\"), DEFAULT_PUBLIC_TOPIC_ID);\n        assert_eq!(\n            generate_topic_id(\"   kukuri:tauri:public   \"),\n            DEFAULT_PUBLIC_TOPIC_ID\n        );\n        let default_base = format!(\"{TOPIC_NAMESPACE}default\");\n        assert_eq!(\n            generate_topic_id(\"   \"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(default_base.as_bytes()).as_bytes())\n            )\n        );\n\n        let private = generate_topic_id_with_visibility(\"secret-room\", TopicVisibility::Private);\n        assert!(private.starts_with(TOPIC_NAMESPACE));\n        let tail = private.trim_start_matches(TOPIC_NAMESPACE);\n        assert_eq!(tail.len(), 64);\n        assert!(tail.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    #[test]\n    fn test_topic_id_bytes_respects_visibility() {\n        let private = generate_topic_id_with_visibility(\"hidden\", TopicVisibility::Private);\n        let private_tail = private.trim_start_matches(TOPIC_NAMESPACE);\n        let bytes = topic_id_bytes(&private);\n        assert_eq!(hex::encode(bytes), private_tail[..64]);\n\n        let public_bytes = topic_id_bytes(DEFAULT_PUBLIC_TOPIC_ID);\n        let public_tail = DEFAULT_PUBLIC_TOPIC_ID.trim_start_matches(TOPIC_NAMESPACE);\n        assert_eq!(public_bytes.len(), 32);\n        assert_eq!(hex::encode(public_bytes), public_tail);\n    }\n\n    #[test]\n    fn test_global_topic_constant() {\n        assert_eq!(GLOBAL_TOPIC, \"kukuri:global\");\n    }\n\n    #[test]\n    fn test_user_topic_id() {\n        let pubkey = \"npub1234567890abcdef\";\n        assert_eq!(user_topic_id(pubkey), \"kukuri:user:npub1234567890abcdef\");\n    }\n\n    #[test]\n    fn test_message_to_signing_bytes() {\n        let message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3], vec![4, 5, 6]);\n\n        let signing_bytes = message.to_signing_bytes();\n\n        // 署名用バイト列が正しく生成されることを確認\n        assert!(!signing_bytes.is_empty());\n        assert!(signing_bytes.len() > message.id.len() + message.payload.len());\n    }\n\n    #[test]\n    fn test_all_message_types() {\n        let types = vec![\n            MessageType::NostrEvent,\n            MessageType::TopicSync,\n            MessageType::PeerExchange,\n            MessageType::Heartbeat,\n        ];\n\n        for msg_type in types {\n            let message = GossipMessage::new(msg_type, vec![], vec![0; 32]);\n            assert!(matches!(message.msg_type, _));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","mod.rs"],"content":"mod gossip_tests;\nmod message_tests;\nmod topic_mesh_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","topic_mesh_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::p2p::message::{GossipMessage, MessageType};\n    use crate::domain::p2p::topic_mesh::*;\n\n    fn create_test_mesh() -> TopicMesh {\n        TopicMesh::new(\"test-topic\".to_string())\n    }\n\n    fn create_test_message(id: u8) -> GossipMessage {\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![id], vec![id; 32]);\n        // 一意のIDを設定\n        message.id[0] = id;\n        message\n    }\n\n    #[tokio::test]\n    async fn test_topic_mesh_creation() {\n        let mesh = create_test_mesh();\n        let stats = mesh.get_stats().await;\n\n        assert_eq!(stats.peer_count, 0);\n        assert_eq!(stats.message_count, 0);\n        assert_eq!(stats.last_activity, 0);\n    }\n\n    #[tokio::test]\n    async fn test_message_handling() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(1);\n\n        // メッセージ処理\n        let result = mesh.handle_message(message.clone()).await;\n        assert!(result.is_ok());\n\n        // 統計情報の確認\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.message_count, 1);\n        assert_eq!(stats.peer_count, 1);\n        assert!(stats.last_activity > 0);\n    }\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(2);\n\n        // 最初のメッセージは重複ではない\n        assert!(!mesh.is_duplicate(&message.id).await);\n\n        // メッセージを処理\n        mesh.handle_message(message.clone()).await.unwrap();\n\n        // 同じメッセージは重複として検出される\n        assert!(mesh.is_duplicate(&message.id).await);\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = create_test_mesh();\n        let peer1 = vec![1; 32];\n        let peer2 = vec![2; 32];\n\n        // ピアの追加\n        mesh.update_peer_status(peer1.clone(), true).await;\n        mesh.update_peer_status(peer2.clone(), true).await;\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 2);\n\n        // ピアの削除\n        mesh.update_peer_status(peer1, false).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n    }\n\n    #[tokio::test]\n    async fn test_cache_limit() {\n        let mesh = create_test_mesh();\n\n        // キャッシュ制限（1000）を超えるメッセージを追加しようとする\n        // 実際にはLRUキャッシュが古いメッセージを削除する\n        for i in 0..1100 {\n            let mut message = create_test_message((i % 256) as u8);\n            // より一意なIDを設定\n            message.id[0] = (i % 256) as u8;\n            message.id[1] = ((i >> 8) % 256) as u8;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        // キャッシュサイズは1000以下\n        assert!(stats.message_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_message_handling() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 10個の並行タスクでメッセージを送信\n        for i in 0..10 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..100 {\n                    let mut message = create_test_message((i * 100 + j) as u8);\n                    // より一意なメッセージIDを設定\n                    message.id[0] = ((i * 100 + j) % 256) as u8;\n                    message.id[1] = ((i * 100 + j) / 256) as u8;\n                    mesh_clone.handle_message(message).await.unwrap();\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 統計情報を確認\n        let stats = mesh.get_stats().await;\n        // 1000メッセージ送信したが、重複があるため実際のメッセージ数は少ない\n        assert!(stats.message_count > 0);\n        assert!(stats.message_count <= 1000); // キャッシュ制限を超えない\n        assert!(stats.peer_count > 0);\n        assert!(stats.peer_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_peer_updates() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 並行してピアの追加/削除を行う\n        for i in 0..5 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..20 {\n                    let peer = vec![(i * 20 + j) as u8; 32];\n                    mesh_clone.update_peer_status(peer.clone(), true).await;\n                    if j % 2 == 0 {\n                        mesh_clone.update_peer_status(peer, false).await;\n                    }\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 最終的なピア数を確認\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 50); // 奇数番号のピアのみ残る\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_cache_operations() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n\n        // メッセージ追加タスク\n        let mesh_add = mesh.clone();\n        let add_task = task::spawn(async move {\n            for i in 0..500 {\n                let message = create_test_message(i as u8);\n                mesh_add.handle_message(message).await.unwrap();\n                tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\n            }\n        });\n\n        // 統計情報取得タスク\n        let mesh_stats = mesh.clone();\n        let stats_task = task::spawn(async move {\n            let mut last_count = 0;\n            for _ in 0..50 {\n                let stats = mesh_stats.get_stats().await;\n                assert!(stats.message_count >= last_count); // 単調増加\n                last_count = stats.message_count;\n                tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n            }\n        });\n\n        // すべてのタスクが完了するのを待つ\n        add_task.await.unwrap();\n        stats_task.await.unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","topic_mesh.rs"],"content":"use crate::domain::p2p::message::{GossipMessage, MessageId};\nuse anyhow::Result;\nuse lru::LruCache;\nuse std::collections::{HashMap, HashSet};\nuse std::num::NonZeroUsize;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse tokio::sync::{RwLock, mpsc};\n\nconst DEFAULT_SUBSCRIBER_BUFFER: usize = 128;\nconst DEFAULT_REPLAY_LIMIT: usize = 64;\n\n#[derive(Clone)]\npub struct TopicMesh {\n    peers: Arc<RwLock<HashSet<Vec<u8>>>>, // PublicKeyのバイト表現\n    message_cache: Arc<RwLock<LruCache<MessageId, GossipMessage>>>,\n    subscribers: Arc<RwLock<HashMap<u64, mpsc::Sender<GossipMessage>>>>,\n    next_subscription_id: Arc<AtomicU64>,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct TopicStats {\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\nimpl TopicMesh {\n    /// 新しいTopicMeshを作成\n    pub fn new(_topic_id: String) -> Self {\n        let cache_size = NonZeroUsize::new(1000).unwrap(); // 最大1000メッセージをキャッシュ\n\n        Self {\n            peers: Arc::new(RwLock::new(HashSet::new())),\n            message_cache: Arc::new(RwLock::new(LruCache::new(cache_size))),\n            subscribers: Arc::new(RwLock::new(HashMap::new())),\n            next_subscription_id: Arc::new(AtomicU64::new(1)),\n        }\n    }\n\n    /// メッセージの受信処理\n    pub async fn handle_message(&self, message: GossipMessage) -> Result<()> {\n        // 重複チェック\n        if self.is_duplicate(&message.id).await {\n            return Ok(()); // 重複メッセージは無視\n        }\n\n        // メッセージをキャッシュに追加\n        let mut cache = self.message_cache.write().await;\n        cache.put(message.id, message.clone());\n\n        // ピアリストに送信者を追加\n        let mut peers = self.peers.write().await;\n        peers.insert(message.sender.clone());\n        drop(peers);\n\n        self.notify_subscribers(&message).await;\n\n        Ok(())\n    }\n\n    /// ピアの接続状態管理\n    pub async fn update_peer_status(&self, peer: Vec<u8>, connected: bool) {\n        let mut peers = self.peers.write().await;\n        if connected {\n            peers.insert(peer);\n        } else {\n            peers.remove(&peer);\n        }\n    }\n\n    /// メッセージの重複チェック\n    pub async fn is_duplicate(&self, message_id: &MessageId) -> bool {\n        let cache = self.message_cache.read().await;\n        cache.contains(message_id)\n    }\n\n    /// トピックの統計情報を取得\n    pub async fn get_stats(&self) -> TopicStats {\n        let peers = self.peers.read().await;\n        let cache = self.message_cache.read().await;\n\n        let last_activity = cache\n            .iter()\n            .map(|(_, msg)| msg.timestamp)\n            .max()\n            .unwrap_or(0);\n\n        TopicStats {\n            peer_count: peers.len(),\n            message_count: cache.len(),\n            last_activity,\n        }\n    }\n\n    /// Gossipメッセージ購読用のチャネルを生成\n    pub async fn subscribe(&self) -> TopicMeshSubscription {\n        let (tx, rx) = mpsc::channel(DEFAULT_SUBSCRIBER_BUFFER);\n        let subscription_id = self.next_subscription_id.fetch_add(1, Ordering::Relaxed);\n\n        {\n            let mut subscribers = self.subscribers.write().await;\n            subscribers.insert(subscription_id, tx.clone());\n        }\n\n        // Receiver がクローズされたら自動的に購読登録を解除する\n        {\n            let drop_tx = tx.clone();\n            let mesh = self.clone();\n            tokio::spawn(async move {\n                drop_tx.closed().await;\n                mesh.unsubscribe(subscription_id).await;\n            });\n        }\n\n        // 直近メッセージを購読開始直後に配信（最新→古い順で保持し、古→新順で送信）\n        if let Err(_e) = self\n            .replay_recent_messages(tx.clone(), DEFAULT_REPLAY_LIMIT)\n            .await\n        {\n            // リプレイ開始前に購読者が離脱した場合は登録を解除\n            self.unsubscribe(subscription_id).await;\n        }\n\n        TopicMeshSubscription {\n            id: subscription_id,\n            receiver: rx,\n        }\n    }\n\n    /// 指定された購読IDを解除\n    pub async fn unsubscribe(&self, subscription_id: u64) {\n        let mut subscribers = self.subscribers.write().await;\n        subscribers.remove(&subscription_id);\n    }\n\n    async fn notify_subscribers(&self, message: &GossipMessage) {\n        let subscribers = self.subscribers.read().await;\n        if subscribers.is_empty() {\n            return;\n        }\n\n        let senders: Vec<(u64, mpsc::Sender<GossipMessage>)> = subscribers\n            .iter()\n            .map(|(&id, sender)| (id, sender.clone()))\n            .collect();\n        drop(subscribers);\n\n        let mut closed_ids = Vec::new();\n        for (id, sender) in senders {\n            match sender.try_send(message.clone()) {\n                Ok(_) => {}\n                Err(mpsc::error::TrySendError::Full(pending)) => {\n                    if sender.send(pending).await.is_err() {\n                        closed_ids.push(id);\n                    }\n                }\n                Err(mpsc::error::TrySendError::Closed(_)) => closed_ids.push(id),\n            }\n        }\n\n        if !closed_ids.is_empty() {\n            let mut subscribers = self.subscribers.write().await;\n            for id in closed_ids {\n                subscribers.remove(&id);\n            }\n        }\n    }\n\n    async fn replay_recent_messages(\n        &self,\n        sender: mpsc::Sender<GossipMessage>,\n        limit: usize,\n    ) -> Result<(), ()> {\n        if limit == 0 {\n            return Ok(());\n        }\n\n        let messages = {\n            let cache = self.message_cache.read().await;\n            let mut cached: Vec<_> = cache.iter().map(|(_, msg)| msg.clone()).collect();\n            if cached.is_empty() {\n                return Ok(());\n            }\n            // LruCacheは最新アクセス順なので一度降順に並べ替えて上位limit件を確保\n            cached.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));\n            cached.truncate(limit.min(DEFAULT_SUBSCRIBER_BUFFER));\n            cached.reverse();\n            cached\n        };\n\n        for message in messages {\n            if sender.send(message).await.is_err() {\n                // 送信に失敗した場合は購読終了とみなし、呼び出し元で解除する\n                return Err(());\n            }\n        }\n\n        // 送信完了\n        let _ = sender;\n        Ok(())\n    }\n\n    #[cfg(test)]\n    pub async fn subscriber_count(&self) -> usize {\n        let subscribers = self.subscribers.read().await;\n        subscribers.len()\n    }\n}\n\npub struct TopicMeshSubscription {\n    pub id: u64,\n    pub receiver: mpsc::Receiver<GossipMessage>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::p2p::message::MessageType;\n    use tokio::time::{Duration, sleep};\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![1, 2, 3],\n            vec![0x02; 33], // 33バイトの公開鍵\n        );\n        let id = message.id;\n\n        mesh.handle_message(message.clone()).await.unwrap();\n        assert!(mesh.is_duplicate(&id).await);\n\n        // もう一度同じメッセージを処理\n        let result = mesh.handle_message(message).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let peer = vec![0x02; 33];\n\n        mesh.update_peer_status(peer.clone(), true).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n\n        mesh.update_peer_status(peer, false).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_stats() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n\n        for i in 0..5 {\n            let mut message =\n                GossipMessage::new(MessageType::TopicSync, vec![i as u8], vec![0x02; 33]);\n            message.timestamp = i;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n        assert_eq!(stats.message_count, 5);\n        assert_eq!(stats.last_activity, 4);\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_and_receive_messages() {\n        let mesh = TopicMesh::new(\"topic_subscribe\".into());\n        let mut subscription = mesh.subscribe().await;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        let message = GossipMessage::new(MessageType::NostrEvent, vec![42, 24], vec![0x02; 33]);\n        mesh.handle_message(message.clone()).await.unwrap();\n\n        let received = subscription\n            .receiver\n            .recv()\n            .await\n            .expect(\"subscriber should receive message\");\n        assert_eq!(received.payload, message.payload);\n        assert_eq!(received.msg_type as u8, MessageType::NostrEvent as u8);\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_replays_recent_messages() {\n        let mesh = TopicMesh::new(\"topic_replay\".into());\n\n        for ts in 0..5 {\n            let mut message =\n                GossipMessage::new(MessageType::TopicSync, vec![ts as u8], vec![0x02; 33]);\n            message.timestamp = ts;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let mut subscription = mesh.subscribe().await;\n        let mut received = Vec::new();\n        for _ in 0..5 {\n            let message = subscription\n                .receiver\n                .recv()\n                .await\n                .expect(\"replay should deliver cached message\");\n            received.push(message.timestamp);\n        }\n\n        assert_eq!(received, vec![0, 1, 2, 3, 4]);\n    }\n\n    #[tokio::test]\n    async fn test_unsubscribe_removes_channel() {\n        let mesh = TopicMesh::new(\"topic_unsubscribe\".into());\n        let subscription = mesh.subscribe().await;\n        let subscription_id = subscription.id;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        mesh.unsubscribe(subscription_id).await;\n        assert_eq!(mesh.subscriber_count().await, 0);\n\n        // Drop receiver without explicit unsubscribe: should be cleaned up on notify\n        let subscription = mesh.subscribe().await;\n        let dropped_id = subscription.id;\n        drop(subscription);\n\n        let message = GossipMessage::new(MessageType::TopicSync, vec![1, 2, 3], vec![0x02; 33]);\n        mesh.handle_message(message).await.unwrap();\n\n        // 送信エラー処理が走る時間を確保\n        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n\n        let subscribers = mesh.subscribers.read().await;\n        assert!(\n            !subscribers.contains_key(&dropped_id),\n            \"closed channel should be removed automatically\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_subscription_auto_unsubscribes_on_drop() {\n        let mesh = TopicMesh::new(\"topic_auto_unsubscribe\".into());\n        let subscription = mesh.subscribe().await;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        drop(subscription);\n\n        // Allow the drop guard to execute unsubscribe inside spawned task\n        sleep(Duration::from_millis(10)).await;\n\n        assert_eq!(\n            mesh.subscriber_count().await,\n            0,\n            \"subscription drop should trigger unsubscribe\"\n        );\n    }\n}\n","traces":[{"line":30,"address":[18887024,18887698],"length":1,"stats":{"Line":1}},{"line":31,"address":[18894022,18894089],"length":1,"stats":{"Line":2}},{"line":34,"address":[13134669],"length":1,"stats":{"Line":1}},{"line":35,"address":[18993155,18993215],"length":1,"stats":{"Line":4}},{"line":36,"address":[13134886,13134949],"length":1,"stats":{"Line":4}},{"line":37,"address":[18997361,18997422],"length":1,"stats":{"Line":4}},{"line":42,"address":[18962544,18963433,18962788,18963532,18962499,18962569,18963015,18962464],"length":1,"stats":{"Line":8}},{"line":44,"address":[18994114,18993931,18994231,18993999],"length":1,"stats":{"Line":5}},{"line":45,"address":[13136067],"length":1,"stats":{"Line":1}},{"line":49,"address":[11426422],"length":1,"stats":{"Line":6}},{"line":50,"address":[13136639,13136563],"length":1,"stats":{"Line":6}},{"line":53,"address":[11632736],"length":1,"stats":{"Line":6}},{"line":54,"address":[13137259,13137186],"length":1,"stats":{"Line":6}},{"line":55,"address":[18889801],"length":1,"stats":{"Line":3}},{"line":57,"address":[11537978],"length":1,"stats":{"Line":3}},{"line":59,"address":[18897135],"length":1,"stats":{"Line":1}},{"line":63,"address":[18996192,18996281,18996212,18997151,18996256,18996610,18996431],"length":1,"stats":{"Line":4}},{"line":64,"address":[18958406,18958346,18958530,18958303],"length":1,"stats":{"Line":2}},{"line":65,"address":[18884153,18884356,18884274],"length":1,"stats":{"Line":3}},{"line":66,"address":[18965708,18965816],"length":1,"stats":{"Line":2}},{"line":68,"address":[13138471,13138558],"length":1,"stats":{"Line":2}},{"line":73,"address":[18884585,18884541,18884684,18884528,18884862,18884721,18884560,18885254],"length":1,"stats":{"Line":6}},{"line":74,"address":[11530212],"length":1,"stats":{"Line":5}},{"line":75,"address":[18891967,18891900],"length":1,"stats":{"Line":3}},{"line":79,"address":[18885272,18885327,18885652,18885280,18885432,18885496,18885264,18886124],"length":1,"stats":{"Line":4}},{"line":80,"address":[11406767],"length":1,"stats":{"Line":2}},{"line":81,"address":[11481378],"length":1,"stats":{"Line":2}},{"line":83,"address":[19003024,19003097],"length":1,"stats":{"Line":2}},{"line":85,"address":[20966143,20966128],"length":1,"stats":{"Line":2}},{"line":90,"address":[20965887],"length":1,"stats":{"Line":1}},{"line":91,"address":[18968144],"length":1,"stats":{"Line":1}},{"line":97,"address":[13141184,13141168,13142772,13141827,13141215,13141176,13141427,13141342],"length":1,"stats":{"Line":4}},{"line":98,"address":[18893780,18893970],"length":1,"stats":{"Line":2}},{"line":99,"address":[18968730,18968821],"length":1,"stats":{"Line":2}},{"line":102,"address":[19181969],"length":1,"stats":{"Line":1}},{"line":103,"address":[18969319,18969387],"length":1,"stats":{"Line":3}},{"line":108,"address":[20967286,20967222],"length":1,"stats":{"Line":3}},{"line":109,"address":[20967302],"length":1,"stats":{"Line":2}},{"line":110,"address":[19000839,19001939,19002108,19002645,19001840,19001865,19002406],"length":1,"stats":{"Line":3}},{"line":111,"address":[19001966,19002035,19002140,19001915],"length":1,"stats":{"Line":2}},{"line":112,"address":[18964303,18963869,18964180],"length":1,"stats":{"Line":1}},{"line":117,"address":[18902097,18902050,18902436,18902148,18902349],"length":1,"stats":{"Line":7}},{"line":118,"address":[19006595],"length":1,"stats":{"Line":1}},{"line":119,"address":[19005245,19005117,19003729,19005001,19005058],"length":1,"stats":{"Line":5}},{"line":122,"address":[10761649],"length":1,"stats":{"Line":0}},{"line":132,"address":[18890048,18890105,18890382,18890080,18890204,18890792,18890061,18890241],"length":1,"stats":{"Line":4}},{"line":133,"address":[11493252],"length":1,"stats":{"Line":2}},{"line":134,"address":[18897477,18897410],"length":1,"stats":{"Line":2}},{"line":137,"address":[19004022,19003552,19003583,19003533,19003763,19005034,19003520,19003860],"length":1,"stats":{"Line":12}},{"line":138,"address":[11645857],"length":1,"stats":{"Line":4}},{"line":139,"address":[18905461,18905381],"length":1,"stats":{"Line":4}},{"line":143,"address":[19104798,19104888],"length":1,"stats":{"Line":2}},{"line":145,"address":[20973747,20973728],"length":1,"stats":{"Line":2}},{"line":147,"address":[19004605],"length":1,"stats":{"Line":1}},{"line":149,"address":[18973504],"length":1,"stats":{"Line":1}},{"line":150,"address":[19105243,19106367,19106430,19105115],"length":1,"stats":{"Line":4}},{"line":151,"address":[19012015,19011678,19011931],"length":1,"stats":{"Line":4}},{"line":152,"address":[18907482],"length":1,"stats":{"Line":1}},{"line":153,"address":[18907509],"length":1,"stats":{"Line":0}},{"line":154,"address":[20972867,20970146,20971998,20971308,20971836,20972779],"length":1,"stats":{"Line":0}},{"line":155,"address":[18899808],"length":1,"stats":{"Line":0}},{"line":158,"address":[13148225,13148327],"length":1,"stats":{"Line":2}},{"line":162,"address":[18893432,18893501],"length":1,"stats":{"Line":2}},{"line":163,"address":[19011757,19012367,19011796,19009419],"length":1,"stats":{"Line":2}},{"line":164,"address":[19107384,19107499,19107646,19107692],"length":1,"stats":{"Line":4}},{"line":165,"address":[18901535,18901420],"length":1,"stats":{"Line":2}},{"line":170,"address":[13149264],"length":1,"stats":{"Line":1}},{"line":175,"address":[18969765],"length":1,"stats":{"Line":1}},{"line":176,"address":[18895254],"length":1,"stats":{"Line":0}},{"line":180,"address":[13149672,13149524,13149573,13149808],"length":1,"stats":{"Line":3}},{"line":181,"address":[19108819,19108892,19110584,19110544],"length":1,"stats":{"Line":5}},{"line":182,"address":[18895893,18895964],"length":1,"stats":{"Line":2}},{"line":183,"address":[18977519],"length":1,"stats":{"Line":1}},{"line":186,"address":[19010240,19010272,19008674,19008743],"length":1,"stats":{"Line":4}},{"line":187,"address":[18909810],"length":1,"stats":{"Line":1}},{"line":188,"address":[18977627],"length":1,"stats":{"Line":1}},{"line":189,"address":[19109229],"length":1,"stats":{"Line":1}},{"line":192,"address":[20975781,20974980,20975717],"length":1,"stats":{"Line":3}},{"line":193,"address":[19007945,19009074,19009899,19009595,19010059],"length":1,"stats":{"Line":4}},{"line":195,"address":[18911180],"length":1,"stats":{"Line":0}},{"line":201,"address":[19009938],"length":1,"stats":{"Line":1}},{"line":205,"address":[20976296,20976411,20976958,20976577,20976448,20976329,20976288,20976304],"length":1,"stats":{"Line":4}},{"line":206,"address":[10781156],"length":1,"stats":{"Line":2}},{"line":207,"address":[20976834,20976888],"length":1,"stats":{"Line":2}}],"covered":78,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","bookmark_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Bookmark エンティティの識別子。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct BookmarkId(String);\n\nimpl BookmarkId {\n    /// 既存の識別子文字列から `BookmarkId` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"BookmarkId cannot be empty\".to_string());\n        }\n        uuid::Uuid::parse_str(&value).map_err(|err| format!(\"Invalid BookmarkId format: {err}\"))?;\n        Ok(Self(value))\n    }\n\n    /// 新規 BookmarkId を生成する。\n    pub fn random() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    /// 内部の文字列を参照する。\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for BookmarkId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<BookmarkId> for String {\n    fn from(value: BookmarkId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":10,"address":[13507440,13507985],"length":1,"stats":{"Line":1}},{"line":11,"address":[20525934,20525990],"length":1,"stats":{"Line":2}},{"line":12,"address":[13507554,13507949],"length":1,"stats":{"Line":0}},{"line":14,"address":[21282571,21282905,21283009,21282992,21282840,21282513],"length":1,"stats":{"Line":2}},{"line":15,"address":[13582323],"length":1,"stats":{"Line":1}},{"line":19,"address":[13721216],"length":1,"stats":{"Line":1}},{"line":20,"address":[13508157],"length":1,"stats":{"Line":1}},{"line":24,"address":[13624864],"length":1,"stats":{"Line":1}},{"line":25,"address":[20526677],"length":1,"stats":{"Line":1}},{"line":30,"address":[13620944],"length":1,"stats":{"Line":0}},{"line":31,"address":[13508264],"length":1,"stats":{"Line":0}},{"line":36,"address":[24646096],"length":1,"stats":{"Line":0}},{"line":37,"address":[24713859],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","mod.rs"],"content":"pub mod bookmark_id;\n\npub use bookmark_id::BookmarkId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","encrypted_post.rs"],"content":"use serde::{Deserialize, Serialize};\n\nconst ENCRYPTED_POST_SCHEMA: &str = \"kukuri-post-cipher-v1\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct EncryptedPostPayload {\n    pub schema: String,\n    pub topic: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub payload_b64: String,\n}\n\nimpl EncryptedPostPayload {\n    pub fn new(topic: String, scope: String, epoch: i64, payload_b64: String) -> Self {\n        Self {\n            schema: ENCRYPTED_POST_SCHEMA.to_string(),\n            topic,\n            scope,\n            epoch,\n            payload_b64,\n        }\n    }\n\n    pub fn schema() -> &'static str {\n        ENCRYPTED_POST_SCHEMA\n    }\n\n    pub fn try_parse(content: &str) -> Option<Self> {\n        let value: Self = serde_json::from_str(content).ok()?;\n        if value.schema == ENCRYPTED_POST_SCHEMA {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":15,"address":[13508743,13508352,13508702],"length":1,"stats":{"Line":1}},{"line":17,"address":[13721468],"length":1,"stats":{"Line":1}},{"line":29,"address":[21283760,21284330],"length":1,"stats":{"Line":1}},{"line":30,"address":[13625457,13625804],"length":1,"stats":{"Line":2}},{"line":31,"address":[13509228,13509252,13509136],"length":1,"stats":{"Line":2}},{"line":32,"address":[13625894],"length":1,"stats":{"Line":1}},{"line":34,"address":[13625879],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","mod.rs"],"content":"pub mod public_key;\npub mod reaction_value;\npub mod topic_content;\n\npub use public_key::PublicKey;\npub use reaction_value::ReactionValue;\npub use topic_content::TopicContent;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","public_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Nostr の公開鍵（hex 64文字）を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PublicKey(String);\n\nimpl PublicKey {\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn from_hex_str(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    /// 内部の16進文字列を参照で取得する。\n    pub fn as_hex(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.len() != 64 {\n            return Err(\"Public key must be 64 hex characters\".to_string());\n        }\n        if !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Public key must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for PublicKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<PublicKey> for String {\n    fn from(value: PublicKey) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for PublicKey {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::from_hex_str(value)\n    }\n}\n","traces":[{"line":10,"address":[16592811,16592432],"length":1,"stats":{"Line":0}},{"line":11,"address":[17046446,17046726,17046519],"length":1,"stats":{"Line":0}},{"line":12,"address":[16555841],"length":1,"stats":{"Line":0}},{"line":16,"address":[16591200],"length":1,"stats":{"Line":2}},{"line":17,"address":[24249579,24249752],"length":1,"stats":{"Line":2}},{"line":18,"address":[16587375],"length":1,"stats":{"Line":2}},{"line":22,"address":[16687920],"length":1,"stats":{"Line":2}},{"line":23,"address":[17047109],"length":1,"stats":{"Line":2}},{"line":26,"address":[16593152],"length":1,"stats":{"Line":2}},{"line":27,"address":[16549506],"length":1,"stats":{"Line":2}},{"line":28,"address":[17047222],"length":1,"stats":{"Line":0}},{"line":30,"address":[16556653,16556640,16556455],"length":1,"stats":{"Line":6}},{"line":31,"address":[16591663],"length":1,"stats":{"Line":0}},{"line":33,"address":[16593372],"length":1,"stats":{"Line":2}},{"line":38,"address":[16556672],"length":1,"stats":{"Line":0}},{"line":39,"address":[16688248],"length":1,"stats":{"Line":0}},{"line":44,"address":[24749008],"length":1,"stats":{"Line":0}},{"line":45,"address":[24706963],"length":1,"stats":{"Line":0}},{"line":52,"address":[16587968],"length":1,"stats":{"Line":0}},{"line":53,"address":[24250261],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","reaction_value.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// リアクション（例: 👍, ❤️）の値を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ReactionValue(String);\n\nimpl ReactionValue {\n    const MAX_LENGTH: usize = 20;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Reaction cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Reaction is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for ReactionValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<ReactionValue> for String {\n    fn from(value: ReactionValue) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for ReactionValue {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for ReactionValue {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[16550283,16549904],"length":1,"stats":{"Line":0}},{"line":12,"address":[16475622,16475342,16475415],"length":1,"stats":{"Line":0}},{"line":13,"address":[16489249],"length":1,"stats":{"Line":0}},{"line":16,"address":[20527200],"length":1,"stats":{"Line":0}},{"line":17,"address":[16689016,16688843],"length":1,"stats":{"Line":0}},{"line":18,"address":[16489599],"length":1,"stats":{"Line":0}},{"line":21,"address":[24250992],"length":1,"stats":{"Line":0}},{"line":22,"address":[16557541],"length":1,"stats":{"Line":0}},{"line":25,"address":[16550624],"length":1,"stats":{"Line":0}},{"line":26,"address":[16557609],"length":1,"stats":{"Line":0}},{"line":27,"address":[16689214],"length":1,"stats":{"Line":0}},{"line":29,"address":[16588822],"length":1,"stats":{"Line":0}},{"line":30,"address":[16689296],"length":1,"stats":{"Line":0}},{"line":35,"address":[16588910],"length":1,"stats":{"Line":0}},{"line":40,"address":[16550976],"length":1,"stats":{"Line":0}},{"line":41,"address":[16483192],"length":1,"stats":{"Line":0}},{"line":46,"address":[24713920],"length":1,"stats":{"Line":0}},{"line":47,"address":[24646163],"length":1,"stats":{"Line":0}},{"line":54,"address":[16490256],"length":1,"stats":{"Line":0}},{"line":55,"address":[20527989],"length":1,"stats":{"Line":0}},{"line":62,"address":[16490304],"length":1,"stats":{"Line":0}},{"line":63,"address":[16483349],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","topic_content.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// トピック投稿など、長文コンテンツを扱う値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TopicContent(String);\n\nimpl TopicContent {\n    const MAX_LENGTH: usize = 10_000;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn into_string(self) -> String {\n        self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Content is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for TopicContent {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicContent> for String {\n    fn from(value: TopicContent) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for TopicContent {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for TopicContent {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[14229632,14230011],"length":1,"stats":{"Line":0}},{"line":12,"address":[14222878,14222951,14223158],"length":1,"stats":{"Line":0}},{"line":13,"address":[14335729],"length":1,"stats":{"Line":0}},{"line":16,"address":[25770096],"length":1,"stats":{"Line":0}},{"line":17,"address":[14297899,14298072],"length":1,"stats":{"Line":0}},{"line":18,"address":[25770207],"length":1,"stats":{"Line":0}},{"line":21,"address":[21998528],"length":1,"stats":{"Line":0}},{"line":22,"address":[14436629],"length":1,"stats":{"Line":0}},{"line":25,"address":[25770400],"length":1,"stats":{"Line":0}},{"line":26,"address":[21998547],"length":1,"stats":{"Line":0}},{"line":29,"address":[14298192],"length":1,"stats":{"Line":0}},{"line":30,"address":[14340297],"length":1,"stats":{"Line":0}},{"line":31,"address":[14305232],"length":1,"stats":{"Line":0}},{"line":33,"address":[14298278],"length":1,"stats":{"Line":0}},{"line":34,"address":[14230578],"length":1,"stats":{"Line":0}},{"line":39,"address":[14340416],"length":1,"stats":{"Line":0}},{"line":44,"address":[14336656],"length":1,"stats":{"Line":0}},{"line":45,"address":[14336680],"length":1,"stats":{"Line":0}},{"line":50,"address":[12212544],"length":1,"stats":{"Line":0}},{"line":51,"address":[12212547],"length":1,"stats":{"Line":0}},{"line":58,"address":[14437136],"length":1,"stats":{"Line":0}},{"line":59,"address":[14336789],"length":1,"stats":{"Line":0}},{"line":66,"address":[25770944],"length":1,"stats":{"Line":0}},{"line":67,"address":[14437205],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EventId(String);\n\nimpl EventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Event ID cannot be empty\".to_string());\n        }\n        // Validate hex format (64 characters)\n        if value.len() != 64 || !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Invalid event ID format: must be 64 hex characters\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        use sha2::{Digest, Sha256};\n        let random_bytes = uuid::Uuid::new_v4().as_bytes().to_vec();\n        let hash = Sha256::digest(&random_bytes);\n        Self(format!(\"{hash:x}\"))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn from_hex(hex: &str) -> Result<Self, String> {\n        Self::new(hex.to_string())\n    }\n\n    pub fn to_hex(&self) -> String {\n        self.0.clone()\n    }\n}\n\nimpl fmt::Display for EventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EventId> for String {\n    fn from(id: EventId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[20819792,20820327],"length":1,"stats":{"Line":2}},{"line":9,"address":[20528094,20528150],"length":1,"stats":{"Line":4}},{"line":10,"address":[20783523,20783133],"length":1,"stats":{"Line":0}},{"line":13,"address":[20818289,20818704,20818717,20818241,20818361],"length":1,"stats":{"Line":10}},{"line":14,"address":[14955981,14956246],"length":1,"stats":{"Line":0}},{"line":16,"address":[20814502],"length":1,"stats":{"Line":2}},{"line":19,"address":[20915482,20915168],"length":1,"stats":{"Line":1}},{"line":21,"address":[20528673],"length":1,"stats":{"Line":1}},{"line":22,"address":[20820462],"length":1,"stats":{"Line":1}},{"line":23,"address":[20776823],"length":1,"stats":{"Line":1}},{"line":26,"address":[20528992],"length":1,"stats":{"Line":1}},{"line":27,"address":[20783957],"length":1,"stats":{"Line":1}},{"line":30,"address":[20819088],"length":1,"stats":{"Line":2}},{"line":31,"address":[20820759],"length":1,"stats":{"Line":2}},{"line":34,"address":[20784032],"length":1,"stats":{"Line":2}},{"line":35,"address":[20915601],"length":1,"stats":{"Line":2}},{"line":40,"address":[20819200],"length":1,"stats":{"Line":1}},{"line":41,"address":[20777176],"length":1,"stats":{"Line":1}},{"line":46,"address":[24745168],"length":1,"stats":{"Line":0}},{"line":47,"address":[18886771],"length":1,"stats":{"Line":0}}],"covered":16,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","keychain.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nconst LEDGER_VERSION: u32 = 1;\n\n/// 個々の鍵素材を表すレコード。公開情報のみを保持する。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMaterialRecord {\n    pub npub: String,\n    pub public_key: String,\n    pub created_at: DateTime<Utc>,\n    pub last_used: DateTime<Utc>,\n}\n\nimpl KeyMaterialRecord {\n    pub fn new(npub: String, public_key: String) -> Self {\n        let now = Utc::now();\n        Self {\n            npub,\n            public_key,\n            created_at: now,\n            last_used: now,\n        }\n    }\n\n    pub fn touch(&mut self) {\n        self.last_used = Utc::now();\n    }\n}\n\n/// KeyManager が参照する鍵素材の台帳。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMaterialLedger {\n    pub version: u32,\n    pub records: HashMap<String, KeyMaterialRecord>,\n    pub current_npub: Option<String>,\n}\n\nimpl Default for KeyMaterialLedger {\n    fn default() -> Self {\n        Self {\n            version: LEDGER_VERSION,\n            records: HashMap::new(),\n            current_npub: None,\n        }\n    }\n}\n\nimpl KeyMaterialLedger {\n    pub fn upsert(&mut self, record: KeyMaterialRecord) {\n        let npub = record.npub.clone();\n        self.records.insert(npub, record);\n    }\n\n    pub fn remove(&mut self, npub: &str) -> bool {\n        let removed = self.records.remove(npub).is_some();\n        if removed && self.current_npub.as_deref() == Some(npub) {\n            self.current_npub = None;\n        }\n        removed\n    }\n\n    pub fn touch_current(&mut self, npub: &str) {\n        if let Some(record) = self.records.get_mut(npub) {\n            record.touch();\n            self.current_npub = Some(npub.to_string());\n        }\n    }\n}\n","traces":[{"line":17,"address":[15940272,15940509,15940534],"length":1,"stats":{"Line":0}},{"line":18,"address":[15947224],"length":1,"stats":{"Line":0}},{"line":27,"address":[15982592],"length":1,"stats":{"Line":0}},{"line":28,"address":[15872750],"length":1,"stats":{"Line":0}},{"line":41,"address":[15982656],"length":1,"stats":{"Line":0}},{"line":44,"address":[15947549],"length":1,"stats":{"Line":0}},{"line":51,"address":[15866128,15866381,15866352],"length":1,"stats":{"Line":0}},{"line":52,"address":[15947672],"length":1,"stats":{"Line":0}},{"line":53,"address":[15978938],"length":1,"stats":{"Line":0}},{"line":56,"address":[15947920,15948318],"length":1,"stats":{"Line":0}},{"line":57,"address":[16079526],"length":1,"stats":{"Line":0}},{"line":58,"address":[12213465,12213487,12213692],"length":1,"stats":{"Line":0}},{"line":59,"address":[15873456],"length":1,"stats":{"Line":0}},{"line":64,"address":[23641992,23641808],"length":1,"stats":{"Line":0}},{"line":65,"address":[15867075,15866868],"length":1,"stats":{"Line":0}},{"line":66,"address":[15983559],"length":1,"stats":{"Line":0}},{"line":67,"address":[15985287,15985226,15985337],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","mod.rs"],"content":"pub mod bookmark;\npub mod encrypted_post;\npub mod event_gateway;\npub mod event_id;\npub mod keychain;\npub mod npub;\npub mod offline;\npub mod subscription;\npub mod topic_id;\n\npub use bookmark::BookmarkId;\npub use encrypted_post::EncryptedPostPayload;\npub use event_gateway::{PublicKey, ReactionValue, TopicContent};\npub use event_id::EventId;\npub use keychain::{KeyMaterialLedger, KeyMaterialRecord};\npub use npub::Npub;\npub use offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\npub use subscription::{\n    RESYNC_BACKOFF_SECS, SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use topic_id::TopicId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","npub.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Npub(String);\n\nimpl Npub {\n    pub fn new(value: String) -> Result<Self, String> {\n        if !value.starts_with(\"npub1\") {\n            return Err(\"Invalid npub format: must start with 'npub1'\".to_string());\n        }\n        if value.len() != 63 {\n            return Err(\"Invalid npub format: incorrect length\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn to_pubkey(&self) -> Result<String, String> {\n        // This would normally use bech32 decoding\n        // For now, return a placeholder\n        Ok(format!(\"pubkey_from_{}\", self.0))\n    }\n}\n\nimpl fmt::Display for Npub {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<Npub> for String {\n    fn from(npub: Npub) -> Self {\n        npub.0\n    }\n}\n","traces":[{"line":8,"address":[15980241,15979792],"length":1,"stats":{"Line":0}},{"line":9,"address":[15948706,15948638],"length":1,"stats":{"Line":0}},{"line":10,"address":[15979976,15979927],"length":1,"stats":{"Line":0}},{"line":12,"address":[15941918,15941848],"length":1,"stats":{"Line":0}},{"line":13,"address":[15980156,15980202],"length":1,"stats":{"Line":0}},{"line":15,"address":[16080414],"length":1,"stats":{"Line":0}},{"line":18,"address":[15980272],"length":1,"stats":{"Line":0}},{"line":19,"address":[23642549],"length":1,"stats":{"Line":0}},{"line":22,"address":[15980288],"length":1,"stats":{"Line":0}},{"line":25,"address":[15874392],"length":1,"stats":{"Line":0}},{"line":30,"address":[15949280],"length":1,"stats":{"Line":0}},{"line":31,"address":[15867784],"length":1,"stats":{"Line":0}},{"line":36,"address":[24745200],"length":1,"stats":{"Line":0}},{"line":37,"address":[12213971],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// アプリケーションが参照するオフラインアクションの識別子（`local_id` 相当）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionId(String);\n\nimpl OfflineActionId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionId> for String {\n    fn from(id: OfflineActionId) -> Self {\n        id.0\n    }\n}\n\nimpl FromStr for OfflineActionId {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":9,"address":[16829211,16828832],"length":1,"stats":{"Line":0}},{"line":10,"address":[16927879,16928086,16927806],"length":1,"stats":{"Line":0}},{"line":11,"address":[17047745],"length":1,"stats":{"Line":0}},{"line":14,"address":[17047968],"length":1,"stats":{"Line":3}},{"line":15,"address":[16928408,16928235],"length":1,"stats":{"Line":3}},{"line":16,"address":[16932239],"length":1,"stats":{"Line":3}},{"line":19,"address":[11070080],"length":1,"stats":{"Line":1}},{"line":20,"address":[16934069],"length":1,"stats":{"Line":1}},{"line":23,"address":[16829552],"length":1,"stats":{"Line":3}},{"line":24,"address":[17028912],"length":1,"stats":{"Line":3}},{"line":25,"address":[17028952],"length":1,"stats":{"Line":0}},{"line":27,"address":[17028937],"length":1,"stats":{"Line":3}},{"line":32,"address":[16822736],"length":1,"stats":{"Line":4}},{"line":33,"address":[16822760],"length":1,"stats":{"Line":4}},{"line":38,"address":[24749168],"length":1,"stats":{"Line":0}},{"line":39,"address":[24845603],"length":1,"stats":{"Line":0}},{"line":46,"address":[17048544],"length":1,"stats":{"Line":0}},{"line":47,"address":[16829845],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// オフラインアクションの種類（例: `publish_text_note`、`send_reaction`）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionType(String);\n\nimpl OfflineActionType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionType> for String {\n    fn from(kind: OfflineActionType) -> Self {\n        kind.0\n    }\n}\n","traces":[{"line":9,"address":[15116944,15117323],"length":1,"stats":{"Line":2}},{"line":10,"address":[24706375,24706582,24706302],"length":1,"stats":{"Line":4}},{"line":11,"address":[15117121],"length":1,"stats":{"Line":2}},{"line":14,"address":[22892336],"length":1,"stats":{"Line":2}},{"line":15,"address":[15191957],"length":1,"stats":{"Line":2}},{"line":18,"address":[15330448],"length":1,"stats":{"Line":2}},{"line":19,"address":[15117424],"length":1,"stats":{"Line":2}},{"line":20,"address":[15234104],"length":1,"stats":{"Line":0}},{"line":22,"address":[24706761],"length":1,"stats":{"Line":2}},{"line":27,"address":[15230240],"length":1,"stats":{"Line":0}},{"line":28,"address":[15117560],"length":1,"stats":{"Line":0}},{"line":33,"address":[24646320],"length":1,"stats":{"Line":0}},{"line":34,"address":[24714083],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheKey(String);\n\nimpl CacheKey {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache key cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheKey> for String {\n    fn from(key: CacheKey) -> Self {\n        key.0\n    }\n}\n","traces":[{"line":8,"address":[16816112,16816491],"length":1,"stats":{"Line":4}},{"line":9,"address":[23920318,23920598,23920391],"length":1,"stats":{"Line":8}},{"line":10,"address":[16816289],"length":1,"stats":{"Line":4}},{"line":13,"address":[11070832],"length":1,"stats":{"Line":2}},{"line":14,"address":[16891125],"length":1,"stats":{"Line":2}},{"line":17,"address":[17029616],"length":1,"stats":{"Line":4}},{"line":18,"address":[16816592],"length":1,"stats":{"Line":4}},{"line":19,"address":[16933272],"length":1,"stats":{"Line":0}},{"line":21,"address":[23920777],"length":1,"stats":{"Line":4}},{"line":26,"address":[16929408],"length":1,"stats":{"Line":0}},{"line":27,"address":[16816728],"length":1,"stats":{"Line":0}},{"line":32,"address":[24646352],"length":1,"stats":{"Line":0}},{"line":33,"address":[24714115],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheType(String);\n\nimpl CacheType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheType> for String {\n    fn from(value: CacheType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[23713307,23712928],"length":1,"stats":{"Line":4}},{"line":9,"address":[18051783,18051990,18051710],"length":1,"stats":{"Line":8}},{"line":10,"address":[23713105],"length":1,"stats":{"Line":4}},{"line":13,"address":[17967648],"length":1,"stats":{"Line":2}},{"line":14,"address":[23787941],"length":1,"stats":{"Line":2}},{"line":17,"address":[23926432],"length":1,"stats":{"Line":4}},{"line":18,"address":[23713408],"length":1,"stats":{"Line":4}},{"line":19,"address":[23830088],"length":1,"stats":{"Line":0}},{"line":21,"address":[18052169],"length":1,"stats":{"Line":4}},{"line":26,"address":[23826224],"length":1,"stats":{"Line":3}},{"line":27,"address":[23713544],"length":1,"stats":{"Line":3}},{"line":32,"address":[24646384],"length":1,"stats":{"Line":0}},{"line":33,"address":[24714147],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityId(String);\n\nimpl EntityId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityId> for String {\n    fn from(value: EntityId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[23713632,23714011],"length":1,"stats":{"Line":2}},{"line":9,"address":[24707270,24706990,24707063],"length":1,"stats":{"Line":4}},{"line":10,"address":[23713809],"length":1,"stats":{"Line":2}},{"line":13,"address":[17968352],"length":1,"stats":{"Line":2}},{"line":14,"address":[23788645],"length":1,"stats":{"Line":2}},{"line":17,"address":[23927136],"length":1,"stats":{"Line":2}},{"line":18,"address":[23714112],"length":1,"stats":{"Line":2}},{"line":19,"address":[23830792],"length":1,"stats":{"Line":0}},{"line":21,"address":[24707449],"length":1,"stats":{"Line":2}},{"line":26,"address":[23826928],"length":1,"stats":{"Line":2}},{"line":27,"address":[23714248],"length":1,"stats":{"Line":2}},{"line":32,"address":[24646416],"length":1,"stats":{"Line":0}},{"line":33,"address":[24714179],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityType(String);\n\nimpl EntityType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityType> for String {\n    fn from(value: EntityType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[24632688,24633067],"length":1,"stats":{"Line":2}},{"line":9,"address":[19289798,19289518,19289591],"length":1,"stats":{"Line":4}},{"line":10,"address":[24632865],"length":1,"stats":{"Line":2}},{"line":13,"address":[18887408],"length":1,"stats":{"Line":2}},{"line":14,"address":[24707701],"length":1,"stats":{"Line":2}},{"line":17,"address":[24846192],"length":1,"stats":{"Line":2}},{"line":18,"address":[24633168],"length":1,"stats":{"Line":2}},{"line":19,"address":[24749848],"length":1,"stats":{"Line":0}},{"line":21,"address":[19289977],"length":1,"stats":{"Line":2}},{"line":26,"address":[24745984],"length":1,"stats":{"Line":1}},{"line":27,"address":[24633304],"length":1,"stats":{"Line":1}},{"line":32,"address":[24647152],"length":1,"stats":{"Line":0}},{"line":33,"address":[24714915],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","mod.rs"],"content":"pub mod action_id;\npub mod action_type;\npub mod cache_key;\npub mod cache_type;\npub mod entity_id;\npub mod entity_type;\npub mod optimistic_update_id;\npub mod payload;\npub mod remote_event_id;\npub mod sync_queue_id;\npub mod sync_queue_status;\npub mod sync_status;\n\npub use action_id::OfflineActionId;\npub use action_type::OfflineActionType;\npub use cache_key::CacheKey;\npub use cache_type::CacheType;\npub use entity_id::EntityId;\npub use entity_type::EntityType;\npub use optimistic_update_id::OptimisticUpdateId;\npub use payload::OfflinePayload;\npub use remote_event_id::RemoteEventId;\npub use sync_queue_id::SyncQueueId;\npub use sync_queue_status::SyncQueueStatus;\npub use sync_status::SyncStatus;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","optimistic_update_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OptimisticUpdateId(String);\n\nimpl OptimisticUpdateId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Optimistic update ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OptimisticUpdateId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OptimisticUpdateId> for String {\n    fn from(value: OptimisticUpdateId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[22941771,22941392],"length":1,"stats":{"Line":1}},{"line":9,"address":[12966142,12966422,12966215],"length":1,"stats":{"Line":2}},{"line":10,"address":[22941569],"length":1,"stats":{"Line":1}},{"line":13,"address":[17196112],"length":1,"stats":{"Line":1}},{"line":14,"address":[23016405],"length":1,"stats":{"Line":1}},{"line":17,"address":[23154896],"length":1,"stats":{"Line":1}},{"line":18,"address":[22941872],"length":1,"stats":{"Line":1}},{"line":19,"address":[23058552],"length":1,"stats":{"Line":0}},{"line":21,"address":[12966601],"length":1,"stats":{"Line":1}},{"line":26,"address":[23054688],"length":1,"stats":{"Line":0}},{"line":27,"address":[22942008],"length":1,"stats":{"Line":0}},{"line":32,"address":[24647184],"length":1,"stats":{"Line":0}},{"line":33,"address":[24714947],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","payload.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflinePayload(Value);\n\nimpl OfflinePayload {\n    pub fn new(value: Value) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn from_json_str(json: &str) -> Result<Self, String> {\n        let value: Value =\n            serde_json::from_str(json).map_err(|e| format!(\"Invalid JSON payload: {e}\"))?;\n        Self::new(value)\n    }\n\n    pub fn as_json(&self) -> &Value {\n        &self.0\n    }\n\n    pub fn into_inner(self) -> Value {\n        self.0\n    }\n\n    fn validate(value: &Value) -> Result<(), String> {\n        if value.is_null() {\n            return Err(\"Offline payload cannot be null\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl From<OfflinePayload> for Value {\n    fn from(payload: OfflinePayload) -> Self {\n        payload.0\n    }\n}\n","traces":[{"line":8,"address":[23023980,23023616],"length":1,"stats":{"Line":2}},{"line":9,"address":[22942391,22942123,22942171],"length":1,"stats":{"Line":4}},{"line":10,"address":[23155310],"length":1,"stats":{"Line":2}},{"line":13,"address":[23059136,23059487,23059516],"length":1,"stats":{"Line":2}},{"line":14,"address":[26515424],"length":1,"stats":{"Line":2}},{"line":16,"address":[22942665],"length":1,"stats":{"Line":2}},{"line":19,"address":[23024624],"length":1,"stats":{"Line":2}},{"line":23,"address":[23156192],"length":1,"stats":{"Line":1}},{"line":24,"address":[26516003],"length":1,"stats":{"Line":1}},{"line":27,"address":[22956928],"length":1,"stats":{"Line":2}},{"line":28,"address":[23024718],"length":1,"stats":{"Line":2}},{"line":29,"address":[23024748],"length":1,"stats":{"Line":0}},{"line":31,"address":[22943213],"length":1,"stats":{"Line":2}},{"line":36,"address":[16483376],"length":1,"stats":{"Line":0}},{"line":37,"address":[16589299],"length":1,"stats":{"Line":0}}],"covered":12,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","remote_event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RemoteEventId(String);\n\nimpl RemoteEventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.trim().is_empty() {\n            return Err(\"Remote event ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for RemoteEventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<RemoteEventId> for String {\n    fn from(value: RemoteEventId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[21474096,21474443],"length":1,"stats":{"Line":0}},{"line":9,"address":[21364338,21364270],"length":1,"stats":{"Line":0}},{"line":10,"address":[21470414,21470465],"length":1,"stats":{"Line":0}},{"line":12,"address":[21475900],"length":1,"stats":{"Line":0}},{"line":15,"address":[21439360],"length":1,"stats":{"Line":0}},{"line":16,"address":[21371605],"length":1,"stats":{"Line":0}},{"line":21,"address":[21439376],"length":1,"stats":{"Line":0}},{"line":22,"address":[21432472],"length":1,"stats":{"Line":0}},{"line":27,"address":[24746160],"length":1,"stats":{"Line":0}},{"line":28,"address":[24746163],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct SyncQueueId(i64);\n\nimpl SyncQueueId {\n    pub fn new(value: i64) -> Result<Self, String> {\n        if value <= 0 {\n            return Err(\"Sync queue id must be positive\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn value(&self) -> i64 {\n        self.0\n    }\n}\n\nimpl fmt::Display for SyncQueueId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<SyncQueueId> for i64 {\n    fn from(id: SyncQueueId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[14305680],"length":1,"stats":{"Line":2}},{"line":9,"address":[14336887],"length":1,"stats":{"Line":3}},{"line":10,"address":[14342505],"length":1,"stats":{"Line":0}},{"line":12,"address":[14237958],"length":1,"stats":{"Line":2}},{"line":15,"address":[21999264],"length":1,"stats":{"Line":1}},{"line":16,"address":[14305813],"length":1,"stats":{"Line":1}},{"line":21,"address":[14305824],"length":1,"stats":{"Line":0}},{"line":22,"address":[14437400],"length":1,"stats":{"Line":0}},{"line":27,"address":[14395440],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_status.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncQueueStatus {\n    Pending,\n    Processing,\n    Failed,\n    Completed,\n    Unknown(String),\n}\n\nimpl SyncQueueStatus {\n    pub fn as_str(&self) -> &str {\n        match self {\n            SyncQueueStatus::Pending => \"pending\",\n            SyncQueueStatus::Processing => \"processing\",\n            SyncQueueStatus::Failed => \"failed\",\n            SyncQueueStatus::Completed => \"completed\",\n            SyncQueueStatus::Unknown(value) => value.as_str(),\n        }\n    }\n}\n\nimpl From<&str> for SyncQueueStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncQueueStatus::Pending,\n            \"processing\" => SyncQueueStatus::Processing,\n            \"failed\" => SyncQueueStatus::Failed,\n            \"completed\" => SyncQueueStatus::Completed,\n            other => SyncQueueStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":13,"address":[15117648],"length":1,"stats":{"Line":2}},{"line":14,"address":[15205359,15205182],"length":1,"stats":{"Line":4}},{"line":15,"address":[15117722],"length":1,"stats":{"Line":2}},{"line":16,"address":[22892721],"length":1,"stats":{"Line":0}},{"line":17,"address":[15192360],"length":1,"stats":{"Line":1}},{"line":18,"address":[15330863],"length":1,"stats":{"Line":0}},{"line":19,"address":[15117819],"length":1,"stats":{"Line":0}},{"line":25,"address":[15234496],"length":1,"stats":{"Line":3}},{"line":27,"address":[15205424,15205482],"length":1,"stats":{"Line":7}},{"line":28,"address":[15230721,15230638],"length":1,"stats":{"Line":1}},{"line":29,"address":[15117989,15118069],"length":1,"stats":{"Line":2}},{"line":30,"address":[15131902,15131801],"length":1,"stats":{"Line":0}},{"line":31,"address":[15199613],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_status.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse serde::{Deserialize, Serialize};\nuse std::borrow::Cow;\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncStatus {\n    Pending,\n    SentToNostr,\n    SentToP2P,\n    FullySynced,\n    Failed,\n    Conflict,\n    Invalid(ValidationFailureKind),\n    Unknown(String),\n}\n\nimpl SyncStatus {\n    pub fn as_str(&self) -> Cow<'static, str> {\n        match self {\n            SyncStatus::Pending => Cow::Borrowed(\"pending\"),\n            SyncStatus::SentToNostr => Cow::Borrowed(\"sent_to_nostr\"),\n            SyncStatus::SentToP2P => Cow::Borrowed(\"sent_to_p2p\"),\n            SyncStatus::FullySynced => Cow::Borrowed(\"fully_synced\"),\n            SyncStatus::Failed => Cow::Borrowed(\"failed\"),\n            SyncStatus::Conflict => Cow::Borrowed(\"conflict\"),\n            SyncStatus::Invalid(kind) => Cow::Owned(format!(\"invalid:{}\", kind.as_str())),\n            SyncStatus::Unknown(value) => Cow::Owned(value.clone()),\n        }\n    }\n\n    pub fn is_terminal(&self) -> bool {\n        matches!(\n            self,\n            SyncStatus::FullySynced\n                | SyncStatus::Failed\n                | SyncStatus::Conflict\n                | SyncStatus::Invalid(_)\n        )\n    }\n}\n\nimpl fmt::Display for SyncStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl From<&str> for SyncStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncStatus::Pending,\n            \"sent_to_nostr\" => SyncStatus::SentToNostr,\n            \"sent_to_p2p\" => SyncStatus::SentToP2P,\n            \"fully_synced\" => SyncStatus::FullySynced,\n            \"failed\" => SyncStatus::Failed,\n            \"conflict\" => SyncStatus::Conflict,\n            value if value.starts_with(\"invalid:\") => {\n                let reason = &value[8..];\n                let kind = reason.parse().unwrap_or(ValidationFailureKind::Generic);\n                SyncStatus::Invalid(kind)\n            }\n            other => SyncStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":19,"address":[14337136],"length":1,"stats":{"Line":2}},{"line":20,"address":[14342750],"length":1,"stats":{"Line":2}},{"line":21,"address":[14231311],"length":1,"stats":{"Line":2}},{"line":22,"address":[14341209],"length":1,"stats":{"Line":0}},{"line":23,"address":[14341251],"length":1,"stats":{"Line":0}},{"line":24,"address":[14306173],"length":1,"stats":{"Line":0}},{"line":25,"address":[14437767],"length":1,"stats":{"Line":0}},{"line":26,"address":[21999713],"length":1,"stats":{"Line":0}},{"line":27,"address":[14437851],"length":1,"stats":{"Line":0}},{"line":28,"address":[14337666],"length":1,"stats":{"Line":1}},{"line":32,"address":[14231824],"length":1,"stats":{"Line":0}},{"line":33,"address":[14438149],"length":1,"stats":{"Line":0}},{"line":34,"address":[14438117],"length":1,"stats":{"Line":0}},{"line":44,"address":[16438192,16438384],"length":1,"stats":{"Line":0}},{"line":45,"address":[14343442],"length":1,"stats":{"Line":0}},{"line":50,"address":[14343632],"length":1,"stats":{"Line":2}},{"line":52,"address":[14225437,14225368],"length":1,"stats":{"Line":4}},{"line":53,"address":[14342039,14342133],"length":1,"stats":{"Line":1}},{"line":54,"address":[14239215,14239309],"length":1,"stats":{"Line":1}},{"line":55,"address":[14232389,14232295],"length":1,"stats":{"Line":1}},{"line":56,"address":[14232351,14232445],"length":1,"stats":{"Line":1}},{"line":57,"address":[16438800,16438695],"length":1,"stats":{"Line":1}},{"line":58,"address":[14343967],"length":1,"stats":{"Line":1}},{"line":59,"address":[16438872],"length":1,"stats":{"Line":0}},{"line":60,"address":[14438916],"length":1,"stats":{"Line":0}},{"line":61,"address":[14232664],"length":1,"stats":{"Line":0}},{"line":63,"address":[14232530],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":27},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","subscription.rs"],"content":"use crate::shared::{AppError, ValidationFailureKind};\nuse nostr_sdk::prelude::Timestamp;\nuse std::str::FromStr;\n\npub const RESYNC_BACKOFF_SECS: i64 = 300;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum SubscriptionTarget {\n    Topic(String),\n    User(String),\n}\n\nimpl SubscriptionTarget {\n    pub fn as_parts(&self) -> (&str, &str) {\n        match self {\n            SubscriptionTarget::Topic(id) => (\"topic\", id.as_str()),\n            SubscriptionTarget::User(id) => (\"user\", id.as_str()),\n        }\n    }\n\n    pub fn from_parts(target_type: &str, target: String) -> Result<Self, AppError> {\n        match target_type {\n            \"topic\" => Ok(SubscriptionTarget::Topic(target)),\n            \"user\" => Ok(SubscriptionTarget::User(target)),\n            other => Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unknown subscription target type: {other}\"),\n            )),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SubscriptionStatus {\n    Pending,\n    Subscribed,\n    NeedsResync,\n}\n\nimpl SubscriptionStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            SubscriptionStatus::Pending => \"pending\",\n            SubscriptionStatus::Subscribed => \"subscribed\",\n            SubscriptionStatus::NeedsResync => \"needs_resync\",\n        }\n    }\n\n    pub fn parse(value: &str) -> Result<Self, AppError> {\n        match value {\n            \"pending\" => Ok(SubscriptionStatus::Pending),\n            \"subscribed\" => Ok(SubscriptionStatus::Subscribed),\n            \"needs_resync\" => Ok(SubscriptionStatus::NeedsResync),\n            other => Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unknown subscription status: {other}\"),\n            )),\n        }\n    }\n}\n\nimpl FromStr for SubscriptionStatus {\n    type Err = AppError;\n\n    fn from_str(value: &str) -> Result<Self, Self::Err> {\n        Self::parse(value)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SubscriptionRecord {\n    pub target: SubscriptionTarget,\n    pub status: SubscriptionStatus,\n    pub last_synced_at: Option<i64>,\n    pub last_attempt_at: Option<i64>,\n    pub failure_count: i64,\n    pub error_message: Option<String>,\n}\n\nimpl SubscriptionRecord {\n    pub fn new(target: SubscriptionTarget) -> Self {\n        Self {\n            target,\n            status: SubscriptionStatus::Pending,\n            last_synced_at: None,\n            last_attempt_at: None,\n            failure_count: 0,\n            error_message: None,\n        }\n    }\n\n    pub fn mark_requested(&mut self, attempt_ts: i64) {\n        self.status = SubscriptionStatus::Pending;\n        self.last_attempt_at = Some(attempt_ts);\n        self.error_message = None;\n    }\n\n    pub fn mark_subscribed(&mut self, synced_at: i64) {\n        self.status = SubscriptionStatus::Subscribed;\n        self.last_synced_at = Some(synced_at);\n        self.failure_count = 0;\n        self.error_message = None;\n    }\n\n    pub fn mark_failure(&mut self, attempt_ts: i64, error_message: impl Into<String>) {\n        self.status = SubscriptionStatus::NeedsResync;\n        self.last_attempt_at = Some(attempt_ts);\n        self.failure_count += 1;\n        self.error_message = Some(error_message.into());\n    }\n\n    pub fn since_timestamp(&self) -> Option<Timestamp> {\n        let last_synced = self.last_synced_at?;\n        let adjusted = last_synced.saturating_sub(RESYNC_BACKOFF_SECS);\n        Some(Timestamp::from(adjusted as u64))\n    }\n}\n","traces":[{"line":14,"address":[16476640],"length":1,"stats":{"Line":1}},{"line":15,"address":[16551256],"length":1,"stats":{"Line":1}},{"line":16,"address":[16551267],"length":1,"stats":{"Line":1}},{"line":17,"address":[16483514],"length":1,"stats":{"Line":1}},{"line":21,"address":[16558320,16559065],"length":1,"stats":{"Line":2}},{"line":22,"address":[16595152],"length":1,"stats":{"Line":2}},{"line":23,"address":[16476880,16476948,16476997],"length":1,"stats":{"Line":5}},{"line":24,"address":[16490724,16490878,16490958],"length":1,"stats":{"Line":3}},{"line":25,"address":[16589838,16590155],"length":1,"stats":{"Line":0}},{"line":26,"address":[16558670],"length":1,"stats":{"Line":0}},{"line":27,"address":[16690230,16690423],"length":1,"stats":{"Line":0}},{"line":41,"address":[16477568],"length":1,"stats":{"Line":1}},{"line":42,"address":[16484357],"length":1,"stats":{"Line":1}},{"line":43,"address":[16594245],"length":1,"stats":{"Line":1}},{"line":44,"address":[16594268],"length":1,"stats":{"Line":2}},{"line":45,"address":[16595939],"length":1,"stats":{"Line":1}},{"line":49,"address":[24252672],"length":1,"stats":{"Line":1}},{"line":51,"address":[12215427,12215369],"length":1,"stats":{"Line":2}},{"line":52,"address":[16484567,16484656],"length":1,"stats":{"Line":4}},{"line":53,"address":[16552676,16552432],"length":1,"stats":{"Line":2}},{"line":54,"address":[16596324,16596189],"length":1,"stats":{"Line":0}},{"line":55,"address":[16552503],"length":1,"stats":{"Line":0}},{"line":56,"address":[24252892],"length":1,"stats":{"Line":0}},{"line":65,"address":[16552704],"length":1,"stats":{"Line":0}},{"line":66,"address":[16691205],"length":1,"stats":{"Line":0}},{"line":81,"address":[24253136],"length":1,"stats":{"Line":1}},{"line":92,"address":[16559840,16559954],"length":1,"stats":{"Line":1}},{"line":93,"address":[16596626],"length":1,"stats":{"Line":1}},{"line":94,"address":[16594990],"length":1,"stats":{"Line":1}},{"line":95,"address":[16591096,16591168],"length":1,"stats":{"Line":2}},{"line":98,"address":[16595258,16595136],"length":1,"stats":{"Line":2}},{"line":99,"address":[16691586],"length":1,"stats":{"Line":2}},{"line":100,"address":[16553118],"length":1,"stats":{"Line":2}},{"line":101,"address":[24253534],"length":1,"stats":{"Line":2}},{"line":102,"address":[16596864,16596936],"length":1,"stats":{"Line":4}},{"line":105,"address":[16553648,16553280],"length":1,"stats":{"Line":1}},{"line":106,"address":[12216355],"length":1,"stats":{"Line":1}},{"line":107,"address":[16485545],"length":1,"stats":{"Line":1}},{"line":108,"address":[16560313,16560382],"length":1,"stats":{"Line":1}},{"line":109,"address":[16560445,16560354],"length":1,"stats":{"Line":2}},{"line":112,"address":[16595712],"length":1,"stats":{"Line":0}},{"line":113,"address":[16597372,16597454],"length":1,"stats":{"Line":0}},{"line":114,"address":[16560646],"length":1,"stats":{"Line":0}},{"line":115,"address":[24254120],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":44},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","topic_id.rs"],"content":"use crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct TopicId(String);\n\nimpl TopicId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Topic ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn public() -> Self {\n        Self(DEFAULT_PUBLIC_TOPIC_ID.to_string())\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn is_public(&self) -> bool {\n        self.0 == DEFAULT_PUBLIC_TOPIC_ID\n    }\n}\n\nimpl fmt::Display for TopicId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicId> for String {\n    fn from(id: TopicId) -> Self {\n        id.0\n    }\n}\n\nimpl Default for TopicId {\n    fn default() -> Self {\n        Self::public()\n    }\n}\n","traces":[{"line":9,"address":[21371998,21371728],"length":1,"stats":{"Line":0}},{"line":10,"address":[21470746,21470697],"length":1,"stats":{"Line":0}},{"line":11,"address":[19290357,19290404],"length":1,"stats":{"Line":0}},{"line":13,"address":[19290265],"length":1,"stats":{"Line":0}},{"line":16,"address":[21470976],"length":1,"stats":{"Line":0}},{"line":17,"address":[21474925],"length":1,"stats":{"Line":0}},{"line":20,"address":[15612656],"length":1,"stats":{"Line":0}},{"line":21,"address":[21476653],"length":1,"stats":{"Line":0}},{"line":24,"address":[21372192],"length":1,"stats":{"Line":0}},{"line":25,"address":[21571509],"length":1,"stats":{"Line":0}},{"line":28,"address":[21571520],"length":1,"stats":{"Line":0}},{"line":29,"address":[21571525],"length":1,"stats":{"Line":0}},{"line":34,"address":[21365264],"length":1,"stats":{"Line":0}},{"line":35,"address":[21365288],"length":1,"stats":{"Line":0}},{"line":40,"address":[24750128],"length":1,"stats":{"Line":0}},{"line":41,"address":[24846563],"length":1,"stats":{"Line":0}},{"line":46,"address":[19290800],"length":1,"stats":{"Line":0}},{"line":47,"address":[21372360],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","mod.rs"],"content":"pub mod post_cache;\n\npub use post_cache::PostCacheService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","post_cache.rs"],"content":"use crate::application::ports::cache::PostCache;\nuse crate::domain::entities::Post;\nuse async_trait::async_trait;\nuse std::collections::{HashMap, VecDeque};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nconst MAX_TOPIC_CACHE: usize = 200;\n\n#[derive(Clone)]\npub struct PostCacheService {\n    inner: Arc<RwLock<PostCacheInner>>,\n}\n\nstruct PostCacheInner {\n    posts_by_id: HashMap<String, Post>,\n    topic_index: HashMap<String, VecDeque<(String, i64)>>,\n}\n\nimpl Default for PostCacheService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl PostCacheService {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(PostCacheInner {\n                posts_by_id: HashMap::new(),\n                topic_index: HashMap::new(),\n            })),\n        }\n    }\n\n    pub async fn add(&self, post: Post) {\n        Self::add_internal(&self.inner, post).await;\n    }\n\n    pub async fn get(&self, id: &str) -> Option<Post> {\n        let inner = self.inner.read().await;\n        inner.posts_by_id.get(id).cloned()\n    }\n\n    pub async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        let inner = self.inner.read().await;\n        inner\n            .topic_index\n            .get(topic_id)\n            .into_iter()\n            .flat_map(|entries| {\n                entries\n                    .iter()\n                    .filter_map(|(post_id, _)| inner.posts_by_id.get(post_id))\n                    .take(limit)\n                    .cloned()\n            })\n            .collect()\n    }\n\n    pub async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        let mut inner = self.inner.write().await;\n\n        if let Some(entries) = inner.topic_index.remove(topic_id) {\n            for (post_id, _) in entries {\n                if let Some(existing) = inner.posts_by_id.get(&post_id) {\n                    if existing.topic_id == topic_id {\n                        inner.posts_by_id.remove(&post_id);\n                    }\n                } else {\n                    inner.posts_by_id.remove(&post_id);\n                }\n            }\n        }\n\n        let mut sorted_posts = posts;\n        sorted_posts.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n\n        let mut entries = VecDeque::new();\n        for post in sorted_posts.into_iter().take(MAX_TOPIC_CACHE) {\n            let timestamp = post.created_at.timestamp();\n            let post_id = post.id.clone();\n            inner.posts_by_id.insert(post_id.clone(), post);\n            entries.push_back((post_id, timestamp));\n        }\n\n        inner.topic_index.insert(topic_id.to_string(), entries);\n    }\n\n    pub async fn invalidate_topic(&self, topic_id: &str) {\n        let mut inner = self.inner.write().await;\n        if let Some(entries) = inner.topic_index.remove(topic_id) {\n            for (post_id, _) in entries {\n                if let Some(existing) = inner.posts_by_id.get(&post_id) {\n                    if existing.topic_id == topic_id {\n                        inner.posts_by_id.remove(&post_id);\n                    }\n                } else {\n                    inner.posts_by_id.remove(&post_id);\n                }\n            }\n        }\n    }\n\n    pub async fn remove(&self, id: &str) -> Option<Post> {\n        let mut inner = self.inner.write().await;\n        let removed = inner.posts_by_id.remove(id);\n        if removed.is_some() {\n            for entries in inner.topic_index.values_mut() {\n                entries.retain(|(post_id, _)| post_id != id);\n            }\n        }\n        removed\n    }\n\n    async fn add_internal(inner: &Arc<RwLock<PostCacheInner>>, post: Post) {\n        let mut guard = inner.write().await;\n        let topic_id = post.topic_id.clone();\n        let post_id = post.id.clone();\n        let timestamp = post.created_at.timestamp();\n\n        guard.posts_by_id.insert(post_id.clone(), post);\n\n        let entries = guard.topic_index.entry(topic_id).or_default();\n        entries.retain(|(id, _)| id != &post_id);\n        let position = entries.iter().position(|(_, ts)| *ts < timestamp);\n        match position {\n            Some(idx) => entries.insert(idx, (post_id, timestamp)),\n            None => entries.push_back((post_id, timestamp)),\n        }\n        if entries.len() > MAX_TOPIC_CACHE {\n            entries.truncate(MAX_TOPIC_CACHE);\n        }\n    }\n}\n\n#[cfg(test)]\nimpl PostCacheService {\n    pub async fn add_many(&self, posts: Vec<Post>) {\n        for post in posts {\n            Self::add_internal(&self.inner, post).await;\n        }\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_many(&self, ids: &[String]) -> Vec<Post> {\n        let inner = self.inner.read().await;\n        ids.iter()\n            .filter_map(|id| inner.posts_by_id.get(id).cloned())\n            .collect()\n    }\n\n    pub async fn clear(&self) {\n        let mut inner = self.inner.write().await;\n        inner.posts_by_id.clear();\n        inner.topic_index.clear();\n    }\n\n    pub async fn size(&self) -> usize {\n        let inner = self.inner.read().await;\n        inner.posts_by_id.len()\n    }\n}\n\n#[async_trait]\nimpl PostCache for PostCacheService {\n    async fn add(&self, post: Post) {\n        PostCacheService::add(self, post).await;\n    }\n\n    async fn get(&self, id: &str) -> Option<Post> {\n        PostCacheService::get(self, id).await\n    }\n\n    async fn remove(&self, id: &str) -> Option<Post> {\n        PostCacheService::remove(self, id).await\n    }\n\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        PostCacheService::get_by_topic(self, topic_id, limit).await\n    }\n\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        PostCacheService::set_topic_posts(self, topic_id, posts).await;\n    }\n\n    async fn invalidate_topic(&self, topic_id: &str) {\n        PostCacheService::invalidate_topic(self, topic_id).await;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::{TimeZone, Utc};\n\n    fn create_test_post(id: &str, topic_id: &str, ts: i64) -> Post {\n        use crate::domain::entities::user::User;\n\n        let author = User {\n            npub: \"npub1test\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: \"Test User\".to_string(),\n                bio: \"Test bio\".to_string(),\n                avatar_url: None,\n            },\n            name: Some(\"Test User\".to_string()),\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        };\n\n        Post {\n            id: id.to_string(),\n            content: \"Test content\".to_string(),\n            author,\n            topic_id: topic_id.to_string(),\n            created_at: Utc.timestamp_opt(ts, 0).unwrap(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: true,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_add_and_get() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\", 1);\n\n        cache.add(post.clone()).await;\n        let retrieved = cache.get(\"1\").await;\n\n        assert!(retrieved.is_some());\n        assert_eq!(retrieved.unwrap().id, \"1\");\n    }\n\n    #[tokio::test]\n    async fn test_topic_ordering_and_limit() {\n        let cache = PostCacheService::new();\n        for i in 0..5 {\n            let post = create_test_post(&format!(\"p{i}\"), \"topic\", i);\n            cache.add(post).await;\n        }\n\n        let posts = cache.get_by_topic(\"topic\", 3).await;\n        assert_eq!(posts.len(), 3);\n        assert_eq!(posts[0].id, \"p4\");\n        assert_eq!(posts[1].id, \"p3\");\n        assert_eq!(posts[2].id, \"p2\");\n    }\n\n    #[tokio::test]\n    async fn test_set_topic_posts_replaces_existing() {\n        let cache = PostCacheService::new();\n\n        let initial = vec![\n            create_test_post(\"old1\", \"topic\", 1),\n            create_test_post(\"old2\", \"topic\", 2),\n        ];\n        cache.set_topic_posts(\"topic\", initial).await;\n\n        let replacement = vec![\n            create_test_post(\"new1\", \"topic\", 10),\n            create_test_post(\"new2\", \"topic\", 11),\n        ];\n        cache.set_topic_posts(\"topic\", replacement.clone()).await;\n\n        let posts = cache.get_by_topic(\"topic\", 10).await;\n        assert_eq!(posts.len(), 2);\n        assert_eq!(posts[0].id, \"new2\");\n        assert_eq!(posts[1].id, \"new1\");\n\n        assert!(cache.get(\"old1\").await.is_none());\n        assert!(cache.get(\"old2\").await.is_none());\n        assert!(cache.get(\"new1\").await.is_some());\n        assert!(cache.get(\"new2\").await.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_invalidate_topic() {\n        let cache = PostCacheService::new();\n        let posts = vec![\n            create_test_post(\"1\", \"topic1\", 1),\n            create_test_post(\"2\", \"topic1\", 2),\n        ];\n\n        cache.set_topic_posts(\"topic1\", posts).await;\n        cache.invalidate_topic(\"topic1\").await;\n\n        assert!(cache.get_by_topic(\"topic1\", 10).await.is_empty());\n        assert!(cache.get(\"1\").await.is_none());\n        assert!(cache.get(\"2\").await.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_remove_post() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\", 1);\n\n        cache.add(post.clone()).await;\n        let removed = cache.remove(\"1\").await;\n\n        assert!(removed.is_some());\n        assert_eq!(removed.unwrap().id, \"1\");\n        assert!(cache.get_by_topic(\"topic1\", 10).await.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_clear_resets_cache() {\n        let cache = PostCacheService::new();\n        cache\n            .add_many(vec![\n                create_test_post(\"1\", \"topic1\", 1),\n                create_test_post(\"2\", \"topic2\", 2),\n            ])\n            .await;\n\n        assert_eq!(cache.size().await, 2);\n        cache.clear().await;\n        assert_eq!(cache.size().await, 0);\n    }\n}\n","traces":[{"line":21,"address":[13622080],"length":1,"stats":{"Line":0}},{"line":22,"address":[21284353],"length":1,"stats":{"Line":0}},{"line":27,"address":[13590912,13591100],"length":1,"stats":{"Line":4}},{"line":29,"address":[13627767],"length":1,"stats":{"Line":4}},{"line":36,"address":[13591768,13591241,13591377,13591171,13591544,13591414,13591216,13591136],"length":1,"stats":{"Line":4}},{"line":37,"address":[13516725,13516668,13516840,13516622],"length":1,"stats":{"Line":2}},{"line":40,"address":[13517074,13517104,13517245,13517056,13517139,13517425,13517282,13517874],"length":1,"stats":{"Line":4}},{"line":41,"address":[11513175],"length":1,"stats":{"Line":2}},{"line":42,"address":[13510973,13510906],"length":1,"stats":{"Line":2}},{"line":45,"address":[13628664,13627983,13628126,13627827,13627767,13627744,13627792,13627946],"length":1,"stats":{"Line":4}},{"line":46,"address":[13585987,13585925,13586110,13585882],"length":1,"stats":{"Line":2}},{"line":47,"address":[13525584,13525601,13525517,13525652],"length":1,"stats":{"Line":4}},{"line":49,"address":[13511828],"length":1,"stats":{"Line":1}},{"line":51,"address":[13630171,13630336],"length":1,"stats":{"Line":2}},{"line":52,"address":[13630432,13630385,13630404],"length":1,"stats":{"Line":3}},{"line":54,"address":[23080704,23080723,23080624],"length":1,"stats":{"Line":3}},{"line":55,"address":[13624841],"length":1,"stats":{"Line":1}},{"line":61,"address":[13589864,13586866,13586943,13587352,13588529,13586848,13586912,13587153],"length":1,"stats":{"Line":4}},{"line":62,"address":[11531761],"length":1,"stats":{"Line":2}},{"line":64,"address":[13629668,13629741],"length":1,"stats":{"Line":2}},{"line":65,"address":[13631733,13631679,13631544,13631495],"length":1,"stats":{"Line":4}},{"line":66,"address":[13631765,13631928],"length":1,"stats":{"Line":2}},{"line":67,"address":[13726852,13726794],"length":1,"stats":{"Line":2}},{"line":68,"address":[13513808],"length":1,"stats":{"Line":1}},{"line":71,"address":[13632176,13632040],"length":1,"stats":{"Line":0}},{"line":76,"address":[13626208],"length":1,"stats":{"Line":1}},{"line":77,"address":[13628064,13626263,13626701,13628032],"length":1,"stats":{"Line":4}},{"line":79,"address":[13727080],"length":1,"stats":{"Line":1}},{"line":80,"address":[13514172,13514373,13514328,13515144,13514059],"length":1,"stats":{"Line":5}},{"line":81,"address":[13631051,13631386],"length":1,"stats":{"Line":2}},{"line":82,"address":[13521597,13521538],"length":1,"stats":{"Line":2}},{"line":83,"address":[13727893,13727955],"length":1,"stats":{"Line":2}},{"line":84,"address":[13627718],"length":1,"stats":{"Line":1}},{"line":87,"address":[23082822],"length":1,"stats":{"Line":1}},{"line":90,"address":[13628312,13629517,13628275,13628144,13628169,13628096,13628455,13628114],"length":1,"stats":{"Line":4}},{"line":91,"address":[11531847],"length":1,"stats":{"Line":2}},{"line":92,"address":[13516065,13516822,13515998],"length":1,"stats":{"Line":2}},{"line":93,"address":[23084481,23084633,23084506,23084683],"length":1,"stats":{"Line":4}},{"line":94,"address":[13516527,13516438],"length":1,"stats":{"Line":2}},{"line":95,"address":[13591201,13591253],"length":1,"stats":{"Line":2}},{"line":96,"address":[13634977],"length":1,"stats":{"Line":1}},{"line":99,"address":[13634924,13635052],"length":1,"stats":{"Line":0}},{"line":105,"address":[13591504,13591682,13591456,13591474,13592561,13591645,13591539,13591825],"length":1,"stats":{"Line":4}},{"line":106,"address":[13730337,13730214,13730109,13730152],"length":1,"stats":{"Line":2}},{"line":107,"address":[13531313,13531246],"length":1,"stats":{"Line":2}},{"line":108,"address":[23085794,23085846],"length":1,"stats":{"Line":2}},{"line":109,"address":[13634348],"length":1,"stats":{"Line":1}},{"line":110,"address":[13531744,13531656,13531724,13531758],"length":1,"stats":{"Line":4}},{"line":113,"address":[23085880],"length":1,"stats":{"Line":1}},{"line":116,"address":[13599552,13599657,13601403,13599587,13601360,13599632,13599825,13600014],"length":1,"stats":{"Line":4}},{"line":117,"address":[13532049,13532152,13532286,13532092],"length":1,"stats":{"Line":2}},{"line":118,"address":[13518753,13518836],"length":1,"stats":{"Line":2}},{"line":119,"address":[21293897,21293820],"length":1,"stats":{"Line":2}},{"line":120,"address":[13635640,13635569],"length":1,"stats":{"Line":2}},{"line":122,"address":[13593600],"length":1,"stats":{"Line":1}},{"line":124,"address":[13525950],"length":1,"stats":{"Line":1}},{"line":125,"address":[13601470,13601456,13600823],"length":1,"stats":{"Line":3}},{"line":126,"address":[21294976,21294986,21294303],"length":1,"stats":{"Line":3}},{"line":127,"address":[21294385],"length":1,"stats":{"Line":1}},{"line":128,"address":[13632251,13632404],"length":1,"stats":{"Line":2}},{"line":129,"address":[13594269,13594017],"length":1,"stats":{"Line":2}},{"line":131,"address":[23087863,23087805,23087786],"length":1,"stats":{"Line":2}},{"line":132,"address":[23087825],"length":1,"stats":{"Line":0}},{"line":167,"address":[13702601,13703097,13702774,13702576,13702737,13702904,13702495],"length":1,"stats":{"Line":4}},{"line":168,"address":[13737884,13738056,13737838,13737941],"length":1,"stats":{"Line":2}},{"line":171,"address":[13628531,13628707,13628496,13628618,13628730,13628945,13629192,13628447],"length":1,"stats":{"Line":0}},{"line":172,"address":[13622193,13622052,13621861],"length":1,"stats":{"Line":0}},{"line":175,"address":[13740751,13741249,13740922,13741011,13741496,13740835,13740800,13741034],"length":1,"stats":{"Line":5}},{"line":176,"address":[23223843,23223712,23223525],"length":1,"stats":{"Line":1}},{"line":179,"address":[13741616,13741651,13741862,13741559,13742416,13741753,13741890,13742129],"length":1,"stats":{"Line":5}},{"line":180,"address":[11717767],"length":1,"stats":{"Line":1}},{"line":183,"address":[13736985,13737114,13736960,13736879,13737270,13737151,13737457],"length":1,"stats":{"Line":4}},{"line":184,"address":[11233504],"length":1,"stats":{"Line":2}},{"line":187,"address":[13631946,13631664,13631615,13631689,13631827,13631790,13632133],"length":1,"stats":{"Line":0}},{"line":188,"address":[11869609],"length":1,"stats":{"Line":0}}],"covered":66,"coverable":75},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_encryption_service.rs"],"content":"use super::encryption_service::EncryptionService;\nuse crate::shared::error::AppError;\nuse aes_gcm::{\n    Aes256Gcm, Key, Nonce,\n    aead::{Aead, AeadCore, KeyInit, OsRng},\n};\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose};\nuse sha2::{Digest, Sha256};\nuse std::str;\n\nconst NONCE_SIZE: usize = 12;\n\npub struct DefaultEncryptionService;\n\nimpl DefaultEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn derive_key(password: &str) -> Key<Aes256Gcm> {\n        let mut hasher = Sha256::new();\n        hasher.update(password.as_bytes());\n        let result = hasher.finalize();\n        let mut key = Key::<Aes256Gcm>::default();\n        key.copy_from_slice(&result);\n        key\n    }\n\n    fn encrypt_internal(plaintext: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Encryption failed: {err}\")))?;\n\n        let mut combined = nonce.to_vec();\n        combined.extend_from_slice(&ciphertext);\n\n        Ok(general_purpose::STANDARD.encode(combined).into_bytes())\n    }\n\n    fn decrypt_internal(encrypted_data: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let encoded = str::from_utf8(encrypted_data)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid encrypted payload: {err}\")))?;\n        let combined = general_purpose::STANDARD\n            .decode(encoded)\n            .map_err(|err| AppError::Crypto(format!(\"Base64 decode failed: {err}\")))?;\n\n        if combined.len() < NONCE_SIZE {\n            return Err(AppError::Crypto(\n                \"Encrypted data is shorter than nonce size\".to_string(),\n            ));\n        }\n\n        let (nonce_bytes, ciphertext) = combined.split_at(NONCE_SIZE);\n        let mut nonce = Nonce::default();\n        nonce.copy_from_slice(nonce_bytes);\n\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n\n        cipher\n            .decrypt(&nonce, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Decryption failed: {err}\")))\n    }\n}\n\nimpl Default for DefaultEncryptionService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EncryptionService for DefaultEncryptionService {\n    async fn encrypt(\n        &self,\n        _data: &[u8],\n        _recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric encryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn decrypt(\n        &self,\n        _encrypted_data: &[u8],\n        _sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric decryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::encrypt_internal(data, password).map_err(|err| Box::new(err) as _)\n    }\n\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::decrypt_internal(encrypted_data, password).map_err(|err| Box::new(err) as _)\n    }\n}\n","traces":[{"line":21,"address":[24254192],"length":1,"stats":{"Line":0}},{"line":22,"address":[16692330],"length":1,"stats":{"Line":0}},{"line":23,"address":[16560798],"length":1,"stats":{"Line":0}},{"line":24,"address":[16493057],"length":1,"stats":{"Line":0}},{"line":25,"address":[16595982],"length":1,"stats":{"Line":0}},{"line":26,"address":[16553948],"length":1,"stats":{"Line":0}},{"line":27,"address":[16692512],"length":1,"stats":{"Line":0}},{"line":30,"address":[16592208,16593122,16593097],"length":1,"stats":{"Line":0}},{"line":31,"address":[16592293],"length":1,"stats":{"Line":0}},{"line":32,"address":[16486401],"length":1,"stats":{"Line":0}},{"line":33,"address":[16592338],"length":1,"stats":{"Line":0}},{"line":34,"address":[24254691,24254951],"length":1,"stats":{"Line":0}},{"line":36,"address":[16493687,16494192,16494209],"length":1,"stats":{"Line":0}},{"line":38,"address":[16692965,16693130],"length":1,"stats":{"Line":0}},{"line":39,"address":[19291766,19291689],"length":1,"stats":{"Line":0}},{"line":41,"address":[16486972],"length":1,"stats":{"Line":0}},{"line":44,"address":[24255584,24256583,24256687],"length":1,"stats":{"Line":0}},{"line":45,"address":[16480896,16480667],"length":1,"stats":{"Line":0}},{"line":46,"address":[16480868,16481728,16481744],"length":1,"stats":{"Line":0}},{"line":47,"address":[16487825,16487706,16487557],"length":1,"stats":{"Line":0}},{"line":49,"address":[16555602,16556480,16556496],"length":1,"stats":{"Line":0}},{"line":51,"address":[16480986,16481116],"length":1,"stats":{"Line":0}},{"line":52,"address":[19293211],"length":1,"stats":{"Line":0}},{"line":53,"address":[16694223],"length":1,"stats":{"Line":0}},{"line":57,"address":[16599410,16599483],"length":1,"stats":{"Line":0}},{"line":58,"address":[16594014],"length":1,"stats":{"Line":0}},{"line":59,"address":[16594033],"length":1,"stats":{"Line":0}},{"line":61,"address":[16694486],"length":1,"stats":{"Line":0}},{"line":62,"address":[16598061],"length":1,"stats":{"Line":0}},{"line":64,"address":[16495302,16495218],"length":1,"stats":{"Line":0}},{"line":66,"address":[24257024,24257041],"length":1,"stats":{"Line":0}},{"line":71,"address":[24257200],"length":1,"stats":{"Line":0}},{"line":72,"address":[16489009],"length":1,"stats":{"Line":0}},{"line":78,"address":[16629276,16629304,16629576,16629037,16629102,16629185,16629072],"length":1,"stats":{"Line":0}},{"line":83,"address":[16732327],"length":1,"stats":{"Line":0}},{"line":84,"address":[16690248],"length":1,"stats":{"Line":0}},{"line":88,"address":[16690625,16690542,16690477,16690512,16690716,16690744,16691016],"length":1,"stats":{"Line":0}},{"line":93,"address":[16690887],"length":1,"stats":{"Line":0}},{"line":94,"address":[16630024],"length":1,"stats":{"Line":0}},{"line":98,"address":[16623277,16623574,16623373,16623547,16623456,16623779,16623344],"length":1,"stats":{"Line":0}},{"line":103,"address":[24391878,24392016,24392017],"length":1,"stats":{"Line":0}},{"line":106,"address":[16730075,16729805,16730307,16729872,16729901,16729984,16730102],"length":1,"stats":{"Line":0}},{"line":111,"address":[16830721,16830582,16830720],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::infrastructure::crypto::signature_service::SignatureService;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::*;\n\n/// デフォルトの署名サービス実装\npub struct DefaultSignatureService;\n\nimpl DefaultSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Default for DefaultSignatureService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SignatureService for DefaultSignatureService {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // Nostr SDKを使用してイベントに署名\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // イベントIDを計算\n        let tags: Vec<nostr_sdk::Tag> = event\n            .tags\n            .clone()\n            .into_iter()\n            .map(|t| {\n                // Convert Vec<String> to Tag\n                if !t.is_empty() {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(t[0].as_str()), t[1..].to_vec())\n                } else {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(\"\"), Vec::<String>::new())\n                }\n            })\n            .collect();\n\n        let mut event_builder =\n            nostr_sdk::EventBuilder::new(Kind::from(event.kind as u16), event.content.clone());\n        for tag in tags {\n            event_builder = event_builder.tag(tag);\n        }\n\n        // 署名を生成\n        let signed_event = event_builder.sign_with_keys(&keys)?;\n        event.sig = signed_event.sig.to_string();\n        event.id = signed_event.id.to_hex();\n\n        Ok(())\n    }\n\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // イベントの署名を検証\n        let _public_key = PublicKey::from_hex(&event.pubkey)?;\n\n        // Nostrイベントを再構築\n        let nostr_event = nostr_sdk::Event::from_json(serde_json::to_string(event)?)?;\n\n        // 署名を検証\n        Ok(nostr_event.verify().is_ok())\n    }\n\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // Create a simple text note event and sign it\n        let event = EventBuilder::text_note(message).sign_with_keys(&keys)?;\n\n        // Return the signature\n        Ok(event.sig.to_string())\n    }\n\n    async fn verify_message(\n        &self,\n        _message: &str,\n        _signature: &str,\n        _public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // For now, we'll use the Nostr event verification approach\n        // In a real implementation, you'd need to reconstruct the event with the signature\n        // and verify it properly\n\n        // This is a simplified version - you may need to store more context\n        // to properly verify standalone signatures\n        Ok(true) // Placeholder implementation\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_sign_and_verify_message() {\n        let service = DefaultSignatureService::new();\n        let keys = Keys::generate();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let public_key = keys.public_key().to_string();\n\n        let message = \"Test message\";\n        let signature = service.sign_message(message, &private_key).await.unwrap();\n\n        let is_valid = service\n            .verify_message(message, &signature, &public_key)\n            .await\n            .unwrap();\n        assert!(is_valid);\n    }\n}\n","traces":[{"line":16,"address":[21372400],"length":1,"stats":{"Line":0}},{"line":17,"address":[21358641],"length":1,"stats":{"Line":0}},{"line":23,"address":[21562955,21563047,21562878,21565167,21562848,21565390,21562792],"length":1,"stats":{"Line":5}},{"line":29,"address":[21567335,21569305,21567151,21567091],"length":1,"stats":{"Line":2}},{"line":30,"address":[21532152],"length":1,"stats":{"Line":1}},{"line":33,"address":[21532399,21532311],"length":1,"stats":{"Line":2}},{"line":37,"address":[21665792,21666212,21666354],"length":1,"stats":{"Line":1}},{"line":39,"address":[21571046,21571122,21571546],"length":1,"stats":{"Line":2}},{"line":40,"address":[21565549,21565609,21565825],"length":1,"stats":{"Line":2}},{"line":42,"address":[21569903,21569512,21569789],"length":1,"stats":{"Line":0}},{"line":47,"address":[21569256,21569361],"length":1,"stats":{"Line":2}},{"line":49,"address":[21567796,21568039,21568129,21569224,21567904],"length":1,"stats":{"Line":5}},{"line":50,"address":[21458280,21459334],"length":1,"stats":{"Line":2}},{"line":54,"address":[21568282,21569126,21568595],"length":1,"stats":{"Line":1}},{"line":55,"address":[21458869,21458709],"length":1,"stats":{"Line":2}},{"line":56,"address":[21568851],"length":1,"stats":{"Line":1}},{"line":58,"address":[21570645],"length":1,"stats":{"Line":1}},{"line":61,"address":[21527982,21529080,21527952,21528035,21527902,21529051,21528131],"length":1,"stats":{"Line":0}},{"line":66,"address":[15708115,15708787,15707951],"length":1,"stats":{"Line":0}},{"line":69,"address":[21461257,21460971,21460567,21460648],"length":1,"stats":{"Line":0}},{"line":72,"address":[21570820,21570940],"length":1,"stats":{"Line":0}},{"line":75,"address":[24056157,24056329,24057461,24057391,24056208,24056444,24056238],"length":1,"stats":{"Line":5}},{"line":80,"address":[21529568,21529812,21530486,21529628],"length":1,"stats":{"Line":2}},{"line":81,"address":[21668229],"length":1,"stats":{"Line":1}},{"line":84,"address":[15709715,15709884,15709618],"length":1,"stats":{"Line":2}},{"line":87,"address":[21568413,21568254],"length":1,"stats":{"Line":2}},{"line":90,"address":[21462968,21462879,21462800,21462826,21462764,21463095,21462941],"length":1,"stats":{"Line":5}},{"line":102,"address":[24057841],"length":1,"stats":{"Line":1}}],"covered":21,"coverable":28},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","encryption_service.rs"],"content":"use async_trait::async_trait;\n\n#[async_trait]\npub trait EncryptionService: Send + Sync {\n    async fn encrypt(\n        &self,\n        data: &[u8],\n        recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt(\n        &self,\n        encrypted_data: &[u8],\n        sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","key_manager.rs"],"content":"use crate::application::ports::key_manager::{KeyManager, KeyMaterialStore, KeyPair};\nuse crate::shared::error::AppError;\nuse anyhow::{Result, anyhow};\nuse async_trait::async_trait;\nuse nostr_sdk::{FromBech32, prelude::*};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::warn;\n\n/// デフォルトのKeyManager実装\n#[derive(Clone)]\npub struct DefaultKeyManager {\n    inner: Arc<RwLock<KeyManagerInner>>,\n    key_store: Arc<dyn KeyMaterialStore>,\n}\n\nstruct KeyManagerInner {\n    keys: Option<Keys>,\n}\n\nimpl DefaultKeyManager {\n    pub fn new() -> Self {\n        Self::with_store(Arc::new(InMemoryKeyMaterialStore::default()))\n    }\n\n    pub fn with_store(key_store: Arc<dyn KeyMaterialStore>) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(KeyManagerInner { keys: None })),\n            key_store,\n        }\n    }\n\n    /// 旧インターフェース用: 新しいキーペアを生成（タプル形式）\n    pub async fn generate(&self) -> Result<(String, String, String)> {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_hex();\n        let secret_key = keys.secret_key().to_bech32()?;\n        let npub = keys.public_key().to_bech32()?;\n\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, secret_key, npub))\n    }\n\n    /// 旧インターフェース用: nsecでログイン\n    pub async fn login(&self, nsec: &str) -> Result<(String, String)> {\n        let secret_key = SecretKey::from_bech32(nsec)?;\n        let keys = Keys::new(secret_key);\n\n        let public_key = keys.public_key().to_hex();\n        let npub = keys.public_key().to_bech32()?;\n\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, npub))\n    }\n\n    /// 旧インターフェース用: ログアウト\n    pub async fn logout(&self) -> Result<()> {\n        let mut inner = self.inner.write().await;\n        inner.keys = None;\n        Ok(())\n    }\n\n    /// 旧インターフェース用: 現在の鍵を取得\n    pub async fn get_keys(&self) -> Result<Keys> {\n        let inner = self.inner.read().await;\n        inner.keys.clone().ok_or_else(|| anyhow!(\"No keys loaded\"))\n    }\n\n    async fn save_generated_keys(&self, keys: &Keys, keypair: &KeyPair) -> Result<(), AppError> {\n        {\n            let mut inner = self.inner.write().await;\n            inner.keys = Some(keys.clone());\n        }\n        self.key_store.save_keypair(keypair).await?;\n\n        if let Err(err) = self.key_store.set_current(&keypair.npub).await {\n            warn!(\n                npub = %keypair.npub,\n                \"set_current failed after save_keypair, retrying once: {err}\"\n            );\n            self.key_store.save_keypair(keypair).await?;\n            self.key_store.set_current(&keypair.npub).await?;\n        }\n        Ok(())\n    }\n\n    async fn install_current_from_pair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        let keys = keys_from_keypair(keypair)?;\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n        Ok(())\n    }\n}\n\nimpl Default for DefaultKeyManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl KeyManager for DefaultKeyManager {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n        let keys = Keys::generate();\n        let keypair = keypair_from_keys(&keys)?;\n        self.save_generated_keys(&keys, &keypair).await?;\n        Ok(keypair)\n    }\n\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError> {\n        let secret_key = SecretKey::from_bech32(nsec)\n            .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e:?}\")))?;\n        let keys = Keys::new(secret_key);\n        let keypair = keypair_from_keys(&keys)?;\n        self.save_generated_keys(&keys, &keypair).await?;\n        Ok(keypair)\n    }\n\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_store\n            .get_keypair(npub)\n            .await?\n            .map(|kp| kp.nsec)\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_store\n            .get_keypair(npub)\n            .await?\n            .map(|kp| kp.public_key)\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        self.key_store.save_keypair(keypair).await?;\n        self.key_store.set_current(&keypair.npub).await?;\n        self.install_current_from_pair(keypair).await\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        self.key_store.delete_keypair(npub).await?;\n        let mut inner = self.inner.write().await;\n        if let Some(keys) = &inner.keys {\n            let current_npub = keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert npub: {e:?}\")))?;\n            if current_npub == npub {\n                inner.keys = None;\n            }\n        }\n        Ok(())\n    }\n\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n        let pairs = self.key_store.list_keypairs().await?;\n        Ok(pairs.into_iter().map(|kp| kp.npub).collect())\n    }\n\n    async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        if let Some(keys) = self.inner.read().await.keys.clone() {\n            let npub = keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert npub: {e:?}\")))?;\n            if let Some(pair) = self.key_store.get_keypair(&npub).await? {\n                return Ok(pair);\n            }\n        }\n\n        if let Some(pair) = self.key_store.current_keypair().await? {\n            self.install_current_from_pair(&pair).await?;\n            Ok(pair)\n        } else {\n            // Fallback: if no \"current\" is set, try the first stored keypair to avoid empty auth state\n            let mut fallback = self.key_store.list_keypairs().await?;\n            if let Some(pair) = fallback.pop() {\n                self.key_store.set_current(&pair.npub).await.ok();\n                self.install_current_from_pair(&pair).await?;\n                Ok(pair)\n            } else {\n                Err(AppError::NotFound(\"No keys loaded\".into()))\n            }\n        }\n    }\n}\n\nfn keypair_from_keys(keys: &Keys) -> Result<KeyPair, AppError> {\n    let public_key = keys.public_key().to_hex();\n    let private_key = keys.secret_key().display_secret().to_string();\n    let npub = keys\n        .public_key()\n        .to_bech32()\n        .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n    let nsec = keys\n        .secret_key()\n        .to_bech32()\n        .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n\n    Ok(KeyPair {\n        public_key,\n        private_key,\n        npub,\n        nsec,\n    })\n}\n\nfn keys_from_keypair(keypair: &KeyPair) -> Result<Keys, AppError> {\n    let secret_key = SecretKey::from_bech32(&keypair.nsec)\n        .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e:?}\")))?;\n    Ok(Keys::new(secret_key))\n}\n\n#[derive(Default)]\nstruct InMemoryKeyMaterialStore {\n    keys: RwLock<HashMap<String, KeyPair>>,\n    current: RwLock<Option<String>>,\n}\n\n#[async_trait]\nimpl KeyMaterialStore for InMemoryKeyMaterialStore {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        let mut guard = self.keys.write().await;\n        guard.insert(keypair.npub.clone(), keypair.clone());\n        Ok(())\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        let mut guard = self.keys.write().await;\n        guard.remove(npub);\n        let mut current = self.current.write().await;\n        if current.as_deref() == Some(npub) {\n            *current = None;\n        }\n        Ok(())\n    }\n\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        Ok(guard.get(npub).cloned())\n    }\n\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        Ok(guard.values().cloned().collect())\n    }\n\n    async fn set_current(&self, npub: &str) -> Result<(), AppError> {\n        let guard = self.keys.read().await;\n        if guard.contains_key(npub) {\n            let mut current = self.current.write().await;\n            *current = Some(npub.to_string());\n            Ok(())\n        } else {\n            Err(AppError::NotFound(format!(\n                \"Keypair not found for npub {npub}\"\n            )))\n        }\n    }\n\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        let current = self.current.read().await;\n        Ok(match current.as_deref() {\n            Some(npub) => guard.get(npub).cloned(),\n            None => None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_key_manager_new() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.get_keys().await;\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), \"No keys loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_generate_keypair() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.generate_keypair().await;\n        assert!(result.is_ok());\n        let pair = result.unwrap();\n        assert!(!pair.public_key.is_empty());\n        assert!(!pair.npub.is_empty());\n        assert!(!pair.nsec.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_import_private_key_roundtrip() {\n        let key_manager = DefaultKeyManager::new();\n        let (_, nsec, _) = key_manager.generate().await.expect(\"generate\");\n        let pair = key_manager\n            .import_private_key(&nsec)\n            .await\n            .expect(\"import should work\");\n        assert_eq!(pair.nsec, nsec);\n    }\n\n    #[tokio::test]\n    async fn test_store_and_export_keypair() {\n        let key_manager = DefaultKeyManager::new();\n        let generated = key_manager.generate_keypair().await.expect(\"generate\");\n        key_manager.store_keypair(&generated).await.expect(\"store\");\n        let exported = key_manager\n            .export_private_key(&generated.npub)\n            .await\n            .expect(\"export\");\n        assert_eq!(exported, generated.nsec);\n    }\n\n    #[tokio::test]\n    async fn test_delete_keypair_clears_current() {\n        let key_manager = DefaultKeyManager::new();\n        let pair = key_manager.generate_keypair().await.expect(\"generate\");\n        key_manager\n            .store_keypair(&pair)\n            .await\n            .expect(\"store default\");\n        key_manager\n            .delete_keypair(&pair.npub)\n            .await\n            .expect(\"delete\");\n        let result = key_manager.current_keypair().await;\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":23,"address":[14225920],"length":1,"stats":{"Line":4}},{"line":24,"address":[14307456],"length":1,"stats":{"Line":4}},{"line":27,"address":[14439072,14439274],"length":1,"stats":{"Line":4}},{"line":29,"address":[14232923,14232811],"length":1,"stats":{"Line":8}},{"line":35,"address":[22001232,22001208,22001200,22001267,22001472,22003245,22001420,22002232],"length":1,"stats":{"Line":4}},{"line":36,"address":[14343065],"length":1,"stats":{"Line":1}},{"line":37,"address":[14439615,14439705],"length":1,"stats":{"Line":2}},{"line":38,"address":[22001642,22001728],"length":1,"stats":{"Line":2}},{"line":39,"address":[14343516,14343600],"length":1,"stats":{"Line":2}},{"line":41,"address":[10872537],"length":1,"stats":{"Line":2}},{"line":42,"address":[14302105,14302812,14302842],"length":1,"stats":{"Line":1}},{"line":44,"address":[14346085],"length":1,"stats":{"Line":1}},{"line":48,"address":[14230493,14228384,14229630,14228432,14228467,14228649,14228701,14228402],"length":1,"stats":{"Line":0}},{"line":49,"address":[22003724,22003606,22003908],"length":1,"stats":{"Line":0}},{"line":50,"address":[14347346,14347155],"length":1,"stats":{"Line":0}},{"line":52,"address":[14442223,14442142],"length":1,"stats":{"Line":0}},{"line":53,"address":[14229271,14229187],"length":1,"stats":{"Line":0}},{"line":55,"address":[14345316,14346302,14346051,14346117],"length":1,"stats":{"Line":0}},{"line":56,"address":[14243647,14244204,14244234],"length":1,"stats":{"Line":0}},{"line":58,"address":[14304761],"length":1,"stats":{"Line":0}},{"line":62,"address":[14244384,14244368,14244677,14244536,14245243,14244499,14244376,14244409],"length":1,"stats":{"Line":0}},{"line":63,"address":[14230723,14230766,14230825,14230949],"length":1,"stats":{"Line":0}},{"line":64,"address":[14444241,14444536,14444509],"length":1,"stats":{"Line":0}},{"line":65,"address":[14245120],"length":1,"stats":{"Line":0}},{"line":69,"address":[22006650,22006488,22006791,22006613,22006496,22006480,22007224,22006531],"length":1,"stats":{"Line":4}},{"line":70,"address":[20534879,20534812,20534983,20534773],"length":1,"stats":{"Line":2}},{"line":71,"address":[14348716,14348912,14348781,14348916],"length":1,"stats":{"Line":4}},{"line":74,"address":[14239120,14239215,14239168,14239138,14240506,14239496,14239369,14239667],"length":1,"stats":{"Line":14}},{"line":76,"address":[14314290,14314135,14314071,14314435],"length":1,"stats":{"Line":7}},{"line":77,"address":[14349802,14350333],"length":1,"stats":{"Line":4}},{"line":79,"address":[11670171],"length":1,"stats":{"Line":3}},{"line":81,"address":[14247792,14246417,14248221,14247952],"length":1,"stats":{"Line":12}},{"line":82,"address":[14241577,14274665,14242387,14242211,14274799,14241686],"length":1,"stats":{"Line":0}},{"line":86,"address":[11675801],"length":1,"stats":{"Line":0}},{"line":87,"address":[11557536],"length":1,"stats":{"Line":0}},{"line":89,"address":[14449959],"length":1,"stats":{"Line":6}},{"line":92,"address":[14312746,14312563,14312528,14313849,14312496,14312509,14313228,14312694],"length":1,"stats":{"Line":8}},{"line":93,"address":[14238083,14238201,14238348],"length":1,"stats":{"Line":4}},{"line":94,"address":[14355123,14355308,14354969,14354769],"length":1,"stats":{"Line":6}},{"line":95,"address":[14246022,14245992,14245667],"length":1,"stats":{"Line":3}},{"line":96,"address":[22014140],"length":1,"stats":{"Line":3}},{"line":101,"address":[22014272],"length":1,"stats":{"Line":0}},{"line":102,"address":[20542120],"length":1,"stats":{"Line":0}},{"line":108,"address":[14483059,14483087,14481439,14481488,14481625,14481523,14481737,14482454],"length":1,"stats":{"Line":24}},{"line":109,"address":[14350296],"length":1,"stats":{"Line":4}},{"line":110,"address":[14343462,14343740,14343387,14343946],"length":1,"stats":{"Line":8}},{"line":111,"address":[20627819,20627650,20627124,20628383,20627934],"length":1,"stats":{"Line":7}},{"line":112,"address":[14482755],"length":1,"stats":{"Line":6}},{"line":115,"address":[14353046,14351909,14351648,14353662,14351583,14353686,14351797,14351683],"length":1,"stats":{"Line":10}},{"line":116,"address":[14389141,14388792,14388860,14389795],"length":1,"stats":{"Line":4}},{"line":117,"address":[14485302,14485280,14483877],"length":1,"stats":{"Line":0}},{"line":118,"address":[20629215],"length":1,"stats":{"Line":2}},{"line":119,"address":[14277791,14278064,14277719,14278266],"length":1,"stats":{"Line":4}},{"line":120,"address":[14484630,14484475,14485094,14484322,14483376],"length":1,"stats":{"Line":4}},{"line":121,"address":[14278611],"length":1,"stats":{"Line":2}},{"line":124,"address":[14486070,14485635,14485555,14486688,14485600,14486698,14485826,14485714],"length":1,"stats":{"Line":10}},{"line":125,"address":[14385606,14386267,14385845,14385665,14385558,14385991,14386325,14386224],"length":1,"stats":{"Line":12}},{"line":126,"address":[20631313],"length":1,"stats":{"Line":2}},{"line":127,"address":[14347261,14347522,14347829,14348064,14347566,14347622],"length":1,"stats":{"Line":6}},{"line":128,"address":[14287408,14287431],"length":1,"stats":{"Line":4}},{"line":129,"address":[14273840,14273554,14273861],"length":1,"stats":{"Line":2}},{"line":132,"address":[14275168,14274080,14275178,14274035,14274115,14274306,14274550,14274194],"length":1,"stats":{"Line":0}},{"line":133,"address":[14393403,14392801,14392694,14393127,14392742,14392981,14393461,14393360],"length":1,"stats":{"Line":0}},{"line":134,"address":[14281225],"length":1,"stats":{"Line":0}},{"line":135,"address":[11983428],"length":1,"stats":{"Line":0}},{"line":136,"address":[14281984,14282007],"length":1,"stats":{"Line":0}},{"line":137,"address":[11844999,11844963],"length":1,"stats":{"Line":0}},{"line":140,"address":[14357111,14357199,14358355,14357753,14357465,14357152,14359073,14357299],"length":1,"stats":{"Line":12}},{"line":141,"address":[11850801],"length":1,"stats":{"Line":2}},{"line":142,"address":[14290292,14290604,14290434,14290902,14291068,14289590],"length":1,"stats":{"Line":4}},{"line":143,"address":[19544297],"length":1,"stats":{"Line":4}},{"line":146,"address":[20636413,20636894,20635888,20636022,20635926,20636154,20637860,20635839],"length":1,"stats":{"Line":5}},{"line":147,"address":[14491582,14491293,14490881,14491773,14491095],"length":1,"stats":{"Line":1}},{"line":148,"address":[11983301],"length":1,"stats":{"Line":2}},{"line":149,"address":[20637128,20637185],"length":1,"stats":{"Line":2}},{"line":150,"address":[14492159,14492411,14492122],"length":1,"stats":{"Line":2}},{"line":153,"address":[14392465,14391995,14392448],"length":1,"stats":{"Line":0}},{"line":154,"address":[22054400,22054233,22054618],"length":1,"stats":{"Line":3}},{"line":155,"address":[14286236,14286431],"length":1,"stats":{"Line":1}},{"line":158,"address":[14397345],"length":1,"stats":{"Line":1}},{"line":161,"address":[14398378,14398256,14398490,14399495,14398217,14398291,14398754,14399451,14399478],"length":1,"stats":{"Line":0}},{"line":162,"address":[11844468],"length":1,"stats":{"Line":0}},{"line":163,"address":[20639123,20638922,20639296,20639324],"length":1,"stats":{"Line":0}},{"line":166,"address":[14494983,14494733,14494495,14494544,14494606,14495249,14496546,14498995],"length":1,"stats":{"Line":16}},{"line":167,"address":[14295785,14295451,14296337,14295969],"length":1,"stats":{"Line":6}},{"line":168,"address":[14357634,14357364,14357254,14357966],"length":1,"stats":{"Line":6}},{"line":171,"address":[14404576,14399634,14404593],"length":1,"stats":{"Line":0}},{"line":172,"address":[11845947],"length":1,"stats":{"Line":6}},{"line":173,"address":[14290827],"length":1,"stats":{"Line":3}},{"line":177,"address":[11852900],"length":1,"stats":{"Line":2}},{"line":178,"address":[20643711,20643119,20639834,20642997,20643377],"length":1,"stats":{"Line":0}},{"line":179,"address":[14299514],"length":1,"stats":{"Line":0}},{"line":182,"address":[11852950],"length":1,"stats":{"Line":1}},{"line":183,"address":[14404761,14404595],"length":1,"stats":{"Line":2}},{"line":184,"address":[11771455],"length":1,"stats":{"Line":0}},{"line":185,"address":[14406084,14400105,14405609],"length":1,"stats":{"Line":0}},{"line":186,"address":[22062708],"length":1,"stats":{"Line":0}},{"line":188,"address":[20644732],"length":1,"stats":{"Line":1}},{"line":194,"address":[14353244,14352032,14353220],"length":1,"stats":{"Line":4}},{"line":195,"address":[20542184],"length":1,"stats":{"Line":4}},{"line":196,"address":[14246235,14246177],"length":1,"stats":{"Line":8}},{"line":197,"address":[14356212,14357165,14356452,14356164],"length":1,"stats":{"Line":8}},{"line":200,"address":[14246548,14247344,14247361],"length":1,"stats":{"Line":0}},{"line":201,"address":[14246531,14247226,14246674],"length":1,"stats":{"Line":9}},{"line":204,"address":[20543186,20543537,20543520],"length":1,"stats":{"Line":0}},{"line":206,"address":[14240177],"length":1,"stats":{"Line":5}},{"line":207,"address":[14246829],"length":1,"stats":{"Line":4}},{"line":208,"address":[14321604],"length":1,"stats":{"Line":5}},{"line":209,"address":[14356769],"length":1,"stats":{"Line":4}},{"line":214,"address":[14248094,14248123,14247696],"length":1,"stats":{"Line":2}},{"line":215,"address":[14454258,14454022],"length":1,"stats":{"Line":2}},{"line":216,"address":[14358000,14357798,14358022],"length":1,"stats":{"Line":0}},{"line":217,"address":[14357741,14357896],"length":1,"stats":{"Line":4}},{"line":228,"address":[14303145,14302147,14302317,14302538,14302068,14302234,14302340,14302112,14303118],"length":1,"stats":{"Line":26}},{"line":229,"address":[22063656,22063786,22063477],"length":1,"stats":{"Line":5}},{"line":230,"address":[20647075,20646770,20646821],"length":1,"stats":{"Line":10}},{"line":231,"address":[14502377],"length":1,"stats":{"Line":6}},{"line":234,"address":[22064716,22064586,22066140,22064464,22064919,22065405,22064415,22064693,22064499],"length":1,"stats":{"Line":5}},{"line":235,"address":[11875055],"length":1,"stats":{"Line":1}},{"line":236,"address":[14408480,14408555],"length":1,"stats":{"Line":2}},{"line":237,"address":[11875074],"length":1,"stats":{"Line":1}},{"line":238,"address":[14365323,14365705,14365250],"length":1,"stats":{"Line":3}},{"line":239,"address":[14503950,14504241],"length":1,"stats":{"Line":1}},{"line":241,"address":[14403552],"length":1,"stats":{"Line":1}},{"line":244,"address":[14298115,14298326,14299063,14298524,14298303,14298080,14298214,14298031],"length":1,"stats":{"Line":20}},{"line":245,"address":[14291457,14291772,14291642],"length":1,"stats":{"Line":4}},{"line":246,"address":[20649610,20649667],"length":1,"stats":{"Line":8}},{"line":249,"address":[14374290,14373872,14373833,14374092,14373907,14374783,14374069,14373986],"length":1,"stats":{"Line":5}},{"line":250,"address":[11904836],"length":1,"stats":{"Line":1}},{"line":251,"address":[14306794,14306865],"length":1,"stats":{"Line":2}},{"line":254,"address":[14410122,14411765,14410035,14410000,14410229,14409951,14410252,14410455,14411176],"length":1,"stats":{"Line":30}},{"line":255,"address":[11862847],"length":1,"stats":{"Line":6}},{"line":256,"address":[14410716,14410791],"length":1,"stats":{"Line":12}},{"line":257,"address":[14301241,14301001,14300311,14301329],"length":1,"stats":{"Line":12}},{"line":258,"address":[14411405,14411770],"length":1,"stats":{"Line":6}},{"line":259,"address":[14508141],"length":1,"stats":{"Line":6}},{"line":261,"address":[14368781,14368844],"length":1,"stats":{"Line":0}},{"line":267,"address":[14413688,14413798,14414045,14415217,14413487,14413536,14413574,14413824,14414496],"length":1,"stats":{"Line":5}},{"line":268,"address":[14376947,14377309,14377161],"length":1,"stats":{"Line":1}},{"line":269,"address":[11809778],"length":1,"stats":{"Line":2}},{"line":270,"address":[14409172,14409245,14409411],"length":1,"stats":{"Line":3}},{"line":271,"address":[14303421,14303621],"length":1,"stats":{"Line":0}},{"line":272,"address":[22071593],"length":1,"stats":{"Line":1}}],"covered":104,"coverable":143},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","mod.rs"],"content":"pub mod default_encryption_service;\npub mod default_signature_service;\npub mod encryption_service;\npub mod key_manager;\npub mod signature_service;\npub mod stream_encryptor;\n\npub use default_encryption_service::DefaultEncryptionService;\npub use default_signature_service::DefaultSignatureService;\npub use encryption_service::EncryptionService;\npub use key_manager::DefaultKeyManager;\npub use signature_service::SignatureService;\npub use stream_encryptor::{\n    CapabilityEncryptor, EncryptedSessionKey, StreamEncryptionResult, StreamEncryptor,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SignatureService: Send + Sync {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_message(\n        &self,\n        message: &str,\n        signature: &str,\n        public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","stream_encryptor.rs"],"content":"use aes_gcm::{\n    Aes256Gcm, Key,\n    aead::{Aead, AeadCore, KeyInit, OsRng, rand_core::RngCore},\n};\n\nuse crate::shared::AppError;\n\nconst AES_KEY_SIZE: usize = 32;\nconst AES_NONCE_SIZE: usize = 12;\n\ntype AesGcmNonce = aes_gcm::Nonce<<Aes256Gcm as AeadCore>::NonceSize>;\n\n/// ストリーム暗号化結果\n#[derive(Debug, Clone)]\npub struct StreamEncryptionResult {\n    pub ciphertext: Vec<u8>,\n    pub session_key: [u8; AES_KEY_SIZE],\n    pub nonce: [u8; AES_NONCE_SIZE],\n}\n\n/// セッションキーを Capability で暗号化した結果\n#[derive(Debug, Clone)]\npub struct EncryptedSessionKey {\n    pub ciphertext: Vec<u8>,\n    pub nonce: [u8; AES_NONCE_SIZE],\n}\n\n/// Blob 本体を暗号化するユーティリティ\npub struct StreamEncryptor;\n\nimpl StreamEncryptor {\n    pub fn encrypt(plaintext: &[u8]) -> Result<StreamEncryptionResult, AppError> {\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut session_key);\n\n        let key = Key::<Aes256Gcm>::from(session_key);\n        let cipher = Aes256Gcm::new(&key);\n\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt stream: {err}\")))?;\n\n        let mut nonce_bytes = [0u8; AES_NONCE_SIZE];\n        nonce_bytes.copy_from_slice(&nonce);\n\n        Ok(StreamEncryptionResult {\n            ciphertext,\n            session_key,\n            nonce: nonce_bytes,\n        })\n    }\n\n    pub fn decrypt(\n        ciphertext: &[u8],\n        session_key: &[u8; AES_KEY_SIZE],\n        nonce: &[u8; AES_NONCE_SIZE],\n    ) -> Result<Vec<u8>, AppError> {\n        let key = Key::<Aes256Gcm>::from(*session_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = AesGcmNonce::from(*nonce);\n        cipher\n            .decrypt(&nonce, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt stream: {err}\")))\n    }\n}\n\n/// Capability 秘密を用いたセッションキー暗号化ユーティリティ\npub struct CapabilityEncryptor;\n\nimpl CapabilityEncryptor {\n    pub fn encrypt_session_key(\n        session_key: &[u8; AES_KEY_SIZE],\n        capability_key: &[u8; AES_KEY_SIZE],\n    ) -> Result<EncryptedSessionKey, AppError> {\n        let key = Key::<Aes256Gcm>::from(*capability_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, session_key.as_slice())\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt session key: {err}\")))?;\n\n        let mut nonce_bytes = [0u8; AES_NONCE_SIZE];\n        nonce_bytes.copy_from_slice(&nonce);\n\n        Ok(EncryptedSessionKey {\n            ciphertext,\n            nonce: nonce_bytes,\n        })\n    }\n\n    pub fn decrypt_session_key(\n        encrypted: &EncryptedSessionKey,\n        capability_key: &[u8; AES_KEY_SIZE],\n    ) -> Result<[u8; AES_KEY_SIZE], AppError> {\n        let key = Key::<Aes256Gcm>::from(*capability_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = AesGcmNonce::from(encrypted.nonce);\n        let decrypted = cipher\n            .decrypt(&nonce, encrypted.ciphertext.as_slice())\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt session key: {err}\")))?;\n\n        if decrypted.len() != AES_KEY_SIZE {\n            return Err(AppError::Crypto(\n                \"Decrypted session key has unexpected length\".to_string(),\n            ));\n        }\n\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        session_key.copy_from_slice(&decrypted);\n        Ok(session_key)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn encrypt_and_decrypt_roundtrip() {\n        let data = b\"hello profile avatar\";\n        let encrypted = StreamEncryptor::encrypt(data).expect(\"encrypt\");\n        let decrypted = StreamEncryptor::decrypt(\n            &encrypted.ciphertext,\n            &encrypted.session_key,\n            &encrypted.nonce,\n        )\n        .expect(\"decrypt\");\n        assert_eq!(decrypted, data);\n    }\n\n    #[test]\n    fn capability_encryption_roundtrip() {\n        let mut capability_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut capability_key);\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut session_key);\n\n        let encrypted = CapabilityEncryptor::encrypt_session_key(&session_key, &capability_key)\n            .expect(\"encrypt\");\n        let decrypted =\n            CapabilityEncryptor::decrypt_session_key(&encrypted, &capability_key).expect(\"decrypt\");\n        assert_eq!(session_key, decrypted);\n    }\n}\n","traces":[{"line":32,"address":[18973172,18972192,18973147],"length":1,"stats":{"Line":2}},{"line":33,"address":[18972235],"length":1,"stats":{"Line":2}},{"line":34,"address":[18911416],"length":1,"stats":{"Line":2}},{"line":36,"address":[19110752],"length":1,"stats":{"Line":2}},{"line":37,"address":[19110810],"length":1,"stats":{"Line":2}},{"line":39,"address":[13152059],"length":1,"stats":{"Line":2}},{"line":40,"address":[19014476,19014759],"length":1,"stats":{"Line":2}},{"line":42,"address":[19111143,19111680,19111697],"length":1,"stats":{"Line":0}},{"line":44,"address":[18898014],"length":1,"stats":{"Line":2}},{"line":45,"address":[19014842,19014677],"length":1,"stats":{"Line":4}},{"line":47,"address":[20979012],"length":1,"stats":{"Line":2}},{"line":48,"address":[19010942],"length":1,"stats":{"Line":2}},{"line":49,"address":[19010990],"length":1,"stats":{"Line":2}},{"line":50,"address":[19111410],"length":1,"stats":{"Line":2}},{"line":54,"address":[19017376,19017072],"length":1,"stats":{"Line":2}},{"line":59,"address":[18905631],"length":1,"stats":{"Line":2}},{"line":60,"address":[18898893],"length":1,"stats":{"Line":2}},{"line":61,"address":[19015552],"length":1,"stats":{"Line":2}},{"line":62,"address":[18905792],"length":1,"stats":{"Line":2}},{"line":64,"address":[18980657,18980640],"length":1,"stats":{"Line":0}},{"line":72,"address":[18973888,18974713,18974738],"length":1,"stats":{"Line":2}},{"line":76,"address":[19015974],"length":1,"stats":{"Line":2}},{"line":77,"address":[18906164],"length":1,"stats":{"Line":2}},{"line":78,"address":[20980033],"length":1,"stats":{"Line":2}},{"line":79,"address":[19016144,19016426],"length":1,"stats":{"Line":2}},{"line":80,"address":[19016113],"length":1,"stats":{"Line":2}},{"line":81,"address":[18974752,18974330,18974769],"length":1,"stats":{"Line":0}},{"line":83,"address":[18899682],"length":1,"stats":{"Line":2}},{"line":84,"address":[19112777,19112940],"length":1,"stats":{"Line":4}},{"line":86,"address":[19018270],"length":1,"stats":{"Line":2}},{"line":87,"address":[18913664],"length":1,"stats":{"Line":2}},{"line":88,"address":[19018240],"length":1,"stats":{"Line":2}},{"line":92,"address":[18908056,18908045,18907120],"length":1,"stats":{"Line":2}},{"line":96,"address":[19017014],"length":1,"stats":{"Line":2}},{"line":97,"address":[19017063],"length":1,"stats":{"Line":2}},{"line":98,"address":[18900445],"length":1,"stats":{"Line":2}},{"line":99,"address":[18907613,18907358,18908054],"length":1,"stats":{"Line":2}},{"line":100,"address":[19013247],"length":1,"stats":{"Line":2}},{"line":101,"address":[18907565,18908097,18908080],"length":1,"stats":{"Line":0}},{"line":103,"address":[18975344,18975499],"length":1,"stats":{"Line":4}},{"line":104,"address":[20981730],"length":1,"stats":{"Line":0}},{"line":105,"address":[20981541],"length":1,"stats":{"Line":0}},{"line":109,"address":[19113985],"length":1,"stats":{"Line":2}},{"line":110,"address":[19114077,19114004],"length":1,"stats":{"Line":4}},{"line":111,"address":[19019329],"length":1,"stats":{"Line":2}}],"covered":39,"coverable":45},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","connection_pool.rs"],"content":"use sqlx::{SqlitePool, sqlite::SqlitePoolOptions};\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct ConnectionPool {\n    pool: Arc<SqlitePool>,\n}\n\nimpl ConnectionPool {\n    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(5)\n            .connect(database_url)\n            .await?;\n\n        Ok(Self {\n            pool: Arc::new(pool),\n        })\n    }\n\n    pub async fn from_memory() -> Result<Self, sqlx::Error> {\n        Self::new(\":memory:\").await\n    }\n\n    pub fn get_pool(&self) -> &SqlitePool {\n        &self.pool\n    }\n\n    pub async fn migrate(&self) -> Result<(), sqlx::migrate::MigrateError> {\n        sqlx::migrate!(\"./migrations\").run(self.pool.as_ref()).await\n    }\n\n    pub async fn close(&self) {\n        self.pool.close().await;\n    }\n}\n","traces":[{"line":10,"address":[12704832,12705820,12705048,12705000,12704813,12704882,12704800,12705237],"length":1,"stats":{"Line":19}},{"line":11,"address":[12705641,12704981,12705095,12705188,12705492,12705381],"length":1,"stats":{"Line":29}},{"line":14,"address":[10857927],"length":1,"stats":{"Line":21}},{"line":16,"address":[12740839],"length":1,"stats":{"Line":7}},{"line":17,"address":[12837126],"length":1,"stats":{"Line":7}},{"line":21,"address":[20399890,20399362,20399483,20399595,20399312,20399296,20399299,20399446],"length":1,"stats":{"Line":4}},{"line":22,"address":[12837569,12837626,12837723,12837511],"length":1,"stats":{"Line":4}},{"line":25,"address":[12838000],"length":1,"stats":{"Line":6}},{"line":26,"address":[12638693],"length":1,"stats":{"Line":6}},{"line":29,"address":[12707199,12706531,12706464,12706829,12706643,12707104,12706496,12706472],"length":1,"stats":{"Line":28}},{"line":30,"address":[12632125,12631864,12631934],"length":1,"stats":{"Line":10}},{"line":33,"address":[12743984,12744163,12744016,12744126,12744307,12743992,12744525,12744041],"length":1,"stats":{"Line":4}},{"line":34,"address":[12838937,12839123,12838894,12838999],"length":1,"stats":{"Line":3}}],"covered":13,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","mod.rs"],"content":"pub mod connection_pool;\npub mod repository;\npub mod sqlite_repository;\npub mod subscription_state_repository;\n\npub use connection_pool::ConnectionPool;\npub use repository::Repository;\npub use subscription_state_repository::SqliteSubscriptionStateRepository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","repository.rs"],"content":"use crate::application::ports::repositories::{\n    BookmarkRepository, DirectMessageRepository, EventRepository, PostRepository, TopicRepository,\n    UserRepository,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait Repository:\n    PostRepository\n    + TopicRepository\n    + UserRepository\n    + EventRepository\n    + BookmarkRepository\n    + DirectMessageRepository\n{\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn health_check(&self) -> Result<bool, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","bookmarks.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    DELETE_BOOKMARK, INSERT_BOOKMARK, SELECT_BOOKMARK_BY_USER_AND_POST, SELECT_BOOKMARKS_BY_USER,\n};\nuse crate::application::ports::repositories::BookmarkRepository;\nuse crate::domain::entities::Bookmark;\nuse crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse chrono::{TimeZone, Utc};\nuse sqlx::FromRow;\n\n#[derive(Debug, FromRow)]\nstruct BookmarkRow {\n    id: String,\n    user_pubkey: String,\n    post_id: String,\n    created_at: i64,\n}\n\nimpl BookmarkRow {\n    fn into_domain(self) -> Result<Bookmark, AppError> {\n        let id = BookmarkId::new(self.id).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid BookmarkId: {err}\"),\n            )\n        })?;\n        let user_pubkey = PublicKey::from_hex_str(&self.user_pubkey).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid public key: {err}\"),\n            )\n        })?;\n        let post_id = EventId::from_hex(&self.post_id).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid post id: {err}\"),\n            )\n        })?;\n        let created_at = Utc\n            .timestamp_millis_opt(self.created_at)\n            .single()\n            .ok_or_else(|| AppError::DeserializationError(\"Invalid timestamp\".to_string()))?;\n\n        Ok(Bookmark::from_parts(id, user_pubkey, post_id, created_at))\n    }\n}\n\nimpl SqliteRepository {\n    async fn fetch_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let row = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARK_BY_USER_AND_POST)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => row.into_domain(),\n            None => Err(AppError::NotFound(\"Bookmark not found\".to_string())),\n        }\n    }\n}\n\n#[async_trait]\nimpl BookmarkRepository for SqliteRepository {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let bookmark = Bookmark::new(user_pubkey.clone(), post_id.clone());\n\n        let result = sqlx::query(INSERT_BOOKMARK)\n            .bind(bookmark.id().as_str())\n            .bind(bookmark.user_pubkey().as_hex())\n            .bind(bookmark.post_id().as_str())\n            .bind(bookmark.created_at().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        if result.rows_affected() == 0 {\n            return self.fetch_bookmark(user_pubkey, post_id).await;\n        }\n\n        Ok(bookmark)\n    }\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError> {\n        sqlx::query(DELETE_BOOKMARK)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError> {\n        let rows = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARKS_BY_USER)\n            .bind(user_pubkey.as_hex())\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        rows.into_iter().map(BookmarkRow::into_domain).collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::database::connection_pool::ConnectionPool;\n\n    async fn setup_repository() -> SqliteRepository {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            );\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create table\");\n\n        SqliteRepository::new(pool)\n    }\n\n    fn sample_pubkey() -> PublicKey {\n        let hex = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n        PublicKey::from_hex_str(hex).expect(\"valid pubkey\")\n    }\n\n    fn sample_event_id() -> EventId {\n        EventId::generate()\n    }\n\n    #[tokio::test]\n    async fn create_and_list_bookmarks() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert_eq!(bookmarks.len(), 1);\n        assert_eq!(bookmarks[0].post_id().as_str(), event_id.as_str());\n        assert_eq!(bookmarks[0].user_pubkey().as_hex(), pubkey.as_hex());\n    }\n\n    #[tokio::test]\n    async fn create_is_idempotent() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        let first = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n        let second = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark idempotent\");\n\n        assert_eq!(first.id().as_str(), second.id().as_str());\n    }\n\n    #[tokio::test]\n    async fn delete_bookmark_succeeds() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        repo.delete_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"deleted\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert!(bookmarks.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[24848281,24846592],"length":1,"stats":{"Line":1}},{"line":23,"address":[12216870,12218632,12217183,12218736,12218951,12217001],"length":1,"stats":{"Line":2}},{"line":24,"address":[24635663],"length":1,"stats":{"Line":0}},{"line":25,"address":[24642293],"length":1,"stats":{"Line":0}},{"line":26,"address":[24710165,24710106],"length":1,"stats":{"Line":0}},{"line":29,"address":[24752235,24752087,24752484,24754251,24753635,24754032],"length":1,"stats":{"Line":2}},{"line":30,"address":[24642703],"length":1,"stats":{"Line":0}},{"line":31,"address":[24642549],"length":1,"stats":{"Line":0}},{"line":32,"address":[24848842,24848901],"length":1,"stats":{"Line":0}},{"line":35,"address":[24752640,24752859,24751939,24751172,24750762,24750916],"length":1,"stats":{"Line":2}},{"line":36,"address":[18890479],"length":1,"stats":{"Line":0}},{"line":37,"address":[24636021],"length":1,"stats":{"Line":0}},{"line":38,"address":[24717546,24717605],"length":1,"stats":{"Line":0}},{"line":41,"address":[24848062,24847527,24847674],"length":1,"stats":{"Line":2}},{"line":42,"address":[24641235],"length":1,"stats":{"Line":1}},{"line":44,"address":[24752896,24752910,24751582],"length":1,"stats":{"Line":0}},{"line":46,"address":[24635029,24634742],"length":1,"stats":{"Line":2}},{"line":51,"address":[17048592],"length":1,"stats":{"Line":1}},{"line":56,"address":[24849717,24850588,24850162,24849606,24849922,24850789,24849794,24850448,24850040],"length":1,"stats":{"Line":8}},{"line":57,"address":[24849725,24850283,24849677,24849834],"length":1,"stats":{"Line":2}},{"line":58,"address":[12220070,12220342,12219966],"length":1,"stats":{"Line":2}},{"line":59,"address":[24850075,24850216,24849978],"length":1,"stats":{"Line":2}},{"line":60,"address":[11885556],"length":1,"stats":{"Line":4}},{"line":62,"address":[24755923],"length":1,"stats":{"Line":1}},{"line":63,"address":[24637788,24638080],"length":1,"stats":{"Line":2}},{"line":64,"address":[18892270,18892058],"length":1,"stats":{"Line":0}},{"line":71,"address":[17218575],"length":1,"stats":{"Line":5}},{"line":76,"address":[24808056,24809466],"length":1,"stats":{"Line":1}},{"line":78,"address":[24810258,24810569,24811286,24809989,24810102,24810694,24810414,24811604,24811864,24809891,24811409,24810812],"length":1,"stats":{"Line":10}},{"line":79,"address":[24692762,24691849,24692807,24691709,24691634],"length":1,"stats":{"Line":2}},{"line":80,"address":[24767335,24766234,24766457,24767298,24766597,24767362],"length":1,"stats":{"Line":2}},{"line":81,"address":[24905730,24905786,24905093,24905233,24905759,24905850,24904722],"length":1,"stats":{"Line":2}},{"line":82,"address":[24766250,24767258,24767314,24767378,24766908,24767221,24766769],"length":1,"stats":{"Line":2}},{"line":83,"address":[18947098,18947034,18946895,18945970,18946636,18946745,18946978],"length":1,"stats":{"Line":2}},{"line":84,"address":[11979378],"length":1,"stats":{"Line":4}},{"line":86,"address":[24767950,24767829],"length":1,"stats":{"Line":2}},{"line":87,"address":[24775124,24772731,24775006,24774884],"length":1,"stats":{"Line":3}},{"line":90,"address":[24693399],"length":1,"stats":{"Line":1}},{"line":93,"address":[18948339,18948554,18948304,18949218,18948442,18949648,18949278],"length":1,"stats":{"Line":5}},{"line":98,"address":[24907427,24908190,24907493,24908469,24907829,24907899,24907579,24908288,24907711],"length":1,"stats":{"Line":8}},{"line":99,"address":[24807246,24807133,24807656,24807090],"length":1,"stats":{"Line":2}},{"line":100,"address":[12317103,12316758,12316875],"length":1,"stats":{"Line":2}},{"line":101,"address":[24776215,24776312,24776402],"length":1,"stats":{"Line":2}},{"line":102,"address":[11904996],"length":1,"stats":{"Line":4}},{"line":103,"address":[24702094],"length":1,"stats":{"Line":1}},{"line":106,"address":[12940487],"length":1,"stats":{"Line":5}},{"line":107,"address":[24778047,24777315,24777585,24777381,24778300,24777949,24777467,24777690],"length":1,"stats":{"Line":7}},{"line":108,"address":[24709747,24710023,24709629,24709586],"length":1,"stats":{"Line":2}},{"line":109,"address":[24812740,24812643,24812865],"length":1,"stats":{"Line":2}},{"line":110,"address":[11433348],"length":1,"stats":{"Line":4}},{"line":112,"address":[24703638,24703449],"length":1,"stats":{"Line":2}}],"covered":40,"coverable":51},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","direct_messages.rs"],"content":"use super::SqliteRepository;\nuse crate::application::ports::repositories::{\n    DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n    DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n    DirectMessagePageRaw, DirectMessageRepository,\n};\nuse crate::domain::entities::{DirectMessage, MessageDirection, NewDirectMessage};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse sqlx::sqlite::SqliteRow;\nuse sqlx::{Acquire, FromRow, Row};\nuse sqlx::{QueryBuilder, Sqlite};\nuse std::str::FromStr;\n\nuse super::queries::{\n    INSERT_DIRECT_MESSAGE, INSERT_DM_CONVERSATION, MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID,\n    MARK_DM_CONVERSATION_READ, SELECT_DIRECT_MESSAGE_BY_ID, UPDATE_DM_CONVERSATION_LAST_MESSAGE,\n};\n\n#[derive(Debug, Clone)]\nstruct DirectMessageRow {\n    id: i64,\n    owner_npub: String,\n    conversation_npub: String,\n    sender_npub: String,\n    recipient_npub: String,\n    event_id: Option<String>,\n    client_message_id: Option<String>,\n    payload_cipher_base64: String,\n    created_at: i64,\n    delivered: i64,\n    direction: String,\n}\n\nimpl<'r> FromRow<'r, SqliteRow> for DirectMessageRow {\n    fn from_row(row: &'r SqliteRow) -> Result<Self, sqlx::Error> {\n        Ok(Self {\n            id: row.try_get(\"id\")?,\n            owner_npub: row.try_get(\"owner_npub\")?,\n            conversation_npub: row.try_get(\"conversation_npub\")?,\n            sender_npub: row.try_get(\"sender_npub\")?,\n            recipient_npub: row.try_get(\"recipient_npub\")?,\n            event_id: row.try_get(\"event_id\")?,\n            client_message_id: row.try_get(\"client_message_id\")?,\n            payload_cipher_base64: row.try_get(\"payload_cipher_base64\")?,\n            created_at: row.try_get(\"created_at\")?,\n            delivered: row.try_get(\"delivered\")?,\n            direction: row.try_get(\"direction\")?,\n        })\n    }\n}\n\nimpl From<DirectMessageRow> for DirectMessage {\n    fn from(row: DirectMessageRow) -> Self {\n        let direction = row.direction.parse().unwrap_or(MessageDirection::Outbound);\n        let delivered = row.delivered != 0;\n        DirectMessage::new(\n            row.id,\n            row.owner_npub,\n            row.conversation_npub,\n            row.sender_npub,\n            row.recipient_npub,\n            row.event_id,\n            row.client_message_id,\n            row.payload_cipher_base64,\n            row.created_at,\n            delivered,\n            direction,\n        )\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct DirectMessageConversationJoinedRow {\n    owner_npub: String,\n    conversation_npub: String,\n    last_message_created_at: Option<i64>,\n    last_read_at: i64,\n    unread_count: i64,\n    msg_id: Option<i64>,\n    msg_owner_npub: Option<String>,\n    msg_conversation_npub: Option<String>,\n    msg_sender_npub: Option<String>,\n    msg_recipient_npub: Option<String>,\n    msg_event_id: Option<String>,\n    msg_client_message_id: Option<String>,\n    msg_payload_cipher_base64: Option<String>,\n    msg_created_at: Option<i64>,\n    msg_delivered: Option<i64>,\n    msg_direction: Option<String>,\n}\n\nimpl<'r> FromRow<'r, SqliteRow> for DirectMessageConversationJoinedRow {\n    fn from_row(row: &'r SqliteRow) -> Result<Self, sqlx::Error> {\n        Ok(Self {\n            owner_npub: row.try_get(\"owner_npub\")?,\n            conversation_npub: row.try_get(\"conversation_npub\")?,\n            last_message_created_at: row.try_get(\"last_message_created_at\")?,\n            last_read_at: row.try_get(\"last_read_at\")?,\n            unread_count: row.try_get(\"unread_count\")?,\n            msg_id: row.try_get(\"msg_id\")?,\n            msg_owner_npub: row.try_get(\"msg_owner_npub\")?,\n            msg_conversation_npub: row.try_get(\"msg_conversation_npub\")?,\n            msg_sender_npub: row.try_get(\"msg_sender_npub\")?,\n            msg_recipient_npub: row.try_get(\"msg_recipient_npub\")?,\n            msg_event_id: row.try_get(\"msg_event_id\")?,\n            msg_client_message_id: row.try_get(\"msg_client_message_id\")?,\n            msg_payload_cipher_base64: row.try_get(\"msg_payload_cipher_base64\")?,\n            msg_created_at: row.try_get(\"msg_created_at\")?,\n            msg_delivered: row.try_get(\"msg_delivered\")?,\n            msg_direction: row.try_get(\"msg_direction\")?,\n        })\n    }\n}\n\nimpl DirectMessageConversationJoinedRow {\n    fn into_record(self) -> DirectMessageConversationRecord {\n        let last_message = self.build_message();\n        DirectMessageConversationRecord {\n            owner_npub: self.owner_npub,\n            conversation_npub: self.conversation_npub,\n            last_message,\n            last_message_created_at: self.last_message_created_at,\n            last_read_at: self.last_read_at,\n            unread_count: self.unread_count,\n        }\n    }\n\n    fn build_message(&self) -> Option<DirectMessage> {\n        let (\n            Some(id),\n            Some(owner_npub),\n            Some(conversation_npub),\n            Some(sender_npub),\n            Some(recipient_npub),\n            Some(payload),\n            Some(created_at),\n            Some(direction_str),\n        ) = (\n            self.msg_id,\n            self.msg_owner_npub.clone(),\n            self.msg_conversation_npub.clone(),\n            self.msg_sender_npub.clone(),\n            self.msg_recipient_npub.clone(),\n            self.msg_payload_cipher_base64.clone(),\n            self.msg_created_at,\n            self.msg_direction.clone(),\n        )\n        else {\n            return None;\n        };\n\n        let delivered = self.msg_delivered.unwrap_or(1) != 0;\n        let direction =\n            MessageDirection::from_str(&direction_str).unwrap_or(MessageDirection::Outbound);\n\n        Some(DirectMessage::new(\n            id,\n            owner_npub,\n            conversation_npub,\n            sender_npub,\n            recipient_npub,\n            self.msg_event_id.clone(),\n            self.msg_client_message_id.clone(),\n            payload,\n            created_at,\n            delivered,\n            direction,\n        ))\n    }\n}\n\n#[async_trait]\nimpl DirectMessageRepository for SqliteRepository {\n    async fn insert_direct_message(\n        &self,\n        message: &NewDirectMessage,\n    ) -> Result<DirectMessage, AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let mut tx = conn.begin().await?;\n\n        sqlx::query(INSERT_DIRECT_MESSAGE)\n            .bind(&message.owner_npub)\n            .bind(&message.conversation_npub)\n            .bind(&message.sender_npub)\n            .bind(&message.recipient_npub)\n            .bind(&message.event_id)\n            .bind(&message.client_message_id)\n            .bind(&message.payload_cipher_base64)\n            .bind(message.created_at.timestamp_millis())\n            .bind(if message.delivered { 1 } else { 0 })\n            .bind(message.direction.as_str())\n            .execute(&mut *tx)\n            .await?;\n\n        let inserted_id: i64 = sqlx::query_scalar(\"SELECT last_insert_rowid()\")\n            .fetch_one(&mut *tx)\n            .await?;\n\n        let row = sqlx::query_as::<_, DirectMessageRow>(SELECT_DIRECT_MESSAGE_BY_ID)\n            .bind(inserted_id)\n            .fetch_one(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n\n        Ok(row.into())\n    }\n\n    async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<DirectMessageCursor>,\n        limit: usize,\n        direction: DirectMessageListDirection,\n    ) -> Result<DirectMessagePageRaw, AppError> {\n        let fetch_limit = limit.saturating_add(1);\n\n        let mut builder = QueryBuilder::<Sqlite>::new(\n            \"SELECT id,\n                    owner_npub,\n                    conversation_npub,\n                    sender_npub,\n                    recipient_npub,\n                    event_id,\n                    client_message_id,\n                    payload_cipher_base64,\n                    created_at,\n                    delivered,\n                    direction\n             FROM direct_messages\n             WHERE owner_npub = \",\n        );\n\n        builder.push_bind(owner_npub);\n        builder.push(\" AND conversation_npub = \");\n        builder.push_bind(conversation_npub);\n\n        if let Some(cur) = cursor.as_ref() {\n            match direction {\n                DirectMessageListDirection::Backward => {\n                    builder.push(\" AND (created_at < \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" OR (created_at = \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" AND IFNULL(event_id, '') < \");\n                    builder.push_bind(cur.event_id.clone().unwrap_or_default());\n                    builder.push(\"))\");\n                }\n                DirectMessageListDirection::Forward => {\n                    builder.push(\" AND (created_at > \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" OR (created_at = \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" AND IFNULL(event_id, '') > \");\n                    builder.push_bind(cur.event_id.clone().unwrap_or_default());\n                    builder.push(\"))\");\n                }\n            }\n        }\n\n        builder.push(\" ORDER BY created_at \");\n        match direction {\n            DirectMessageListDirection::Backward => {\n                builder.push(\"DESC, IFNULL(event_id, '') DESC\");\n            }\n            DirectMessageListDirection::Forward => {\n                builder.push(\"ASC, IFNULL(event_id, '') ASC\");\n            }\n        }\n\n        builder.push(\" LIMIT \");\n        builder.push_bind(fetch_limit as i64);\n\n        let query = builder.build_query_as::<DirectMessageRow>();\n        let mut rows = query.fetch_all(self.pool.get_pool()).await?;\n\n        let has_more = rows.len() > limit;\n        if has_more {\n            rows.truncate(limit);\n        }\n\n        let next_cursor = rows.last().map(|row| {\n            let dm: DirectMessage = row.clone().into();\n            dm.cursor()\n        });\n\n        let items = rows.into_iter().map(Into::into).collect();\n\n        Ok(DirectMessagePageRaw {\n            items,\n            next_cursor,\n            has_more,\n        })\n    }\n\n    async fn mark_delivered_by_client_id(\n        &self,\n        owner_npub: &str,\n        client_message_id: &str,\n        event_id: Option<String>,\n        delivered: bool,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        sqlx::query(MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID)\n            .bind(owner_npub)\n            .bind(client_message_id)\n            .bind(event_id.as_deref())\n            .bind(if delivered { 1 } else { 0 })\n            .execute(&mut *conn)\n            .await?;\n        Ok(())\n    }\n\n    async fn upsert_conversation_metadata(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        last_message_id: i64,\n        last_message_created_at: i64,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let updated = sqlx::query(UPDATE_DM_CONVERSATION_LAST_MESSAGE)\n            .bind(owner_npub)\n            .bind(conversation_npub)\n            .bind(last_message_id)\n            .bind(last_message_created_at)\n            .execute(&mut *conn)\n            .await?;\n\n        if updated.rows_affected() == 0 {\n            sqlx::query(INSERT_DM_CONVERSATION)\n                .bind(owner_npub)\n                .bind(conversation_npub)\n                .bind(last_message_id)\n                .bind(last_message_created_at)\n                .bind(0_i64)\n                .execute(&mut *conn)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at: i64,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let updated = sqlx::query(MARK_DM_CONVERSATION_READ)\n            .bind(owner_npub)\n            .bind(conversation_npub)\n            .bind(read_at)\n            .execute(&mut *conn)\n            .await?;\n\n        if updated.rows_affected() == 0 {\n            sqlx::query(INSERT_DM_CONVERSATION)\n                .bind(owner_npub)\n                .bind(conversation_npub)\n                .bind(None::<i64>)\n                .bind(None::<i64>)\n                .bind(read_at)\n                .execute(&mut *conn)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<DirectMessageConversationCursor>,\n        limit: usize,\n    ) -> Result<DirectMessageConversationPageRaw, AppError> {\n        let fetch_limit = limit.saturating_add(1).max(1);\n        let mut builder = QueryBuilder::<Sqlite>::new(\n            r#\"\nSELECT\n    c.owner_npub AS owner_npub,\n    c.conversation_npub AS conversation_npub,\n    c.last_message_id AS last_message_id,\n    c.last_message_created_at AS last_message_created_at,\n    c.last_read_at AS last_read_at,\n    (\n        SELECT COUNT(*)\n        FROM direct_messages dm_unread\n        WHERE dm_unread.owner_npub = c.owner_npub\n          AND dm_unread.conversation_npub = c.conversation_npub\n          AND dm_unread.direction = 'inbound'\n          AND dm_unread.created_at > c.last_read_at\n    ) AS unread_count,\n    dm.id AS msg_id,\n    dm.owner_npub AS msg_owner_npub,\n    dm.conversation_npub AS msg_conversation_npub,\n    dm.sender_npub AS msg_sender_npub,\n    dm.recipient_npub AS msg_recipient_npub,\n    dm.event_id AS msg_event_id,\n    dm.client_message_id AS msg_client_message_id,\n    dm.payload_cipher_base64 AS msg_payload_cipher_base64,\n    dm.created_at AS msg_created_at,\n    dm.delivered AS msg_delivered,\n    dm.direction AS msg_direction\nFROM direct_message_conversations c\nLEFT JOIN direct_messages dm ON dm.id = c.last_message_id\nWHERE c.owner_npub = \"#,\n        );\n        builder.push_bind(owner_npub);\n\n        if let Some(cursor) = &cursor {\n            let bucket = cursor.bucket();\n            builder.push(\" AND (\");\n            builder.push(\"CASE WHEN c.last_message_created_at IS NULL THEN 1 ELSE 0 END > \");\n            builder.push_bind(bucket);\n            builder.push(\" OR (\");\n            builder.push(\"CASE WHEN c.last_message_created_at IS NULL THEN 1 ELSE 0 END = \");\n            builder.push_bind(bucket);\n            builder.push(\" AND \");\n            if bucket == 0 {\n                let created_at = cursor.last_message_created_at.unwrap_or(0);\n                builder.push(\"(\");\n                builder.push(\"c.last_message_created_at < \");\n                builder.push_bind(created_at);\n                builder.push(\" OR (c.last_message_created_at = \");\n                builder.push_bind(created_at);\n                builder.push(\" AND c.conversation_npub > \");\n                builder.push_bind(&cursor.conversation_npub);\n                builder.push(\"))\");\n            } else {\n                builder.push(\"(\");\n                builder.push(\"c.last_message_created_at IS NULL AND c.conversation_npub > \");\n                builder.push_bind(&cursor.conversation_npub);\n                builder.push(\")\");\n            }\n            builder.push(\"))\");\n        }\n\n        builder.push(\n            \" ORDER BY\n    c.last_message_created_at IS NULL,\n    c.last_message_created_at DESC,\n    c.conversation_npub ASC\nLIMIT \",\n        );\n        builder.push_bind(fetch_limit as i64);\n\n        let mut rows = builder\n            .build_query_as::<DirectMessageConversationJoinedRow>()\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let has_more = rows.len() > limit;\n        if has_more {\n            rows.truncate(limit);\n        }\n\n        let records: Vec<DirectMessageConversationRecord> =\n            rows.into_iter().map(|row| row.into_record()).collect();\n\n        let next_cursor = if has_more {\n            records.last().map(|record| {\n                DirectMessageConversationCursor::new(\n                    record.last_message_created_at,\n                    record.conversation_npub.clone(),\n                )\n                .to_string()\n            })\n        } else {\n            None\n        };\n\n        Ok(DirectMessageConversationPageRaw {\n            items: records,\n            next_cursor,\n            has_more,\n        })\n    }\n}\n","traces":[{"line":36,"address":[15236464,15240206],"length":1,"stats":{"Line":1}},{"line":37,"address":[15334083],"length":1,"stats":{"Line":1}},{"line":38,"address":[15192995,15192798],"length":1,"stats":{"Line":1}},{"line":39,"address":[15132225,15132320,15132075],"length":1,"stats":{"Line":2}},{"line":40,"address":[15118661,15118828,15118529],"length":1,"stats":{"Line":2}},{"line":41,"address":[15235432,15235756,15235589],"length":1,"stats":{"Line":2}},{"line":42,"address":[15125864,15126188,15126021],"length":1,"stats":{"Line":2}},{"line":43,"address":[15119525,15119368,15119692],"length":1,"stats":{"Line":2}},{"line":44,"address":[15126440,15126597,15126764],"length":1,"stats":{"Line":2}},{"line":45,"address":[15126885,15126728,15127052],"length":1,"stats":{"Line":2}},{"line":46,"address":[18054517,18054368,18054637],"length":1,"stats":{"Line":2}},{"line":47,"address":[15202277,15201997,15202154],"length":1,"stats":{"Line":2}},{"line":48,"address":[18055523,18054990,18054841],"length":1,"stats":{"Line":2}},{"line":54,"address":[16696240,16695312,16696025],"length":1,"stats":{"Line":1}},{"line":55,"address":[24257246,24257430],"length":1,"stats":{"Line":2}},{"line":56,"address":[16564050],"length":1,"stats":{"Line":1}},{"line":58,"address":[16600839],"length":1,"stats":{"Line":1}},{"line":59,"address":[24257534],"length":1,"stats":{"Line":1}},{"line":60,"address":[16600874],"length":1,"stats":{"Line":1}},{"line":61,"address":[16489402],"length":1,"stats":{"Line":1}},{"line":62,"address":[16557242],"length":1,"stats":{"Line":1}},{"line":63,"address":[20547698],"length":1,"stats":{"Line":1}},{"line":64,"address":[16595424],"length":1,"stats":{"Line":1}},{"line":65,"address":[20547774],"length":1,"stats":{"Line":1}},{"line":66,"address":[16489574],"length":1,"stats":{"Line":1}},{"line":94,"address":[18063480,18058096],"length":1,"stats":{"Line":1}},{"line":95,"address":[15202922],"length":1,"stats":{"Line":1}},{"line":96,"address":[15198794,15198611],"length":1,"stats":{"Line":1}},{"line":97,"address":[18058409,18058572,18058282],"length":1,"stats":{"Line":2}},{"line":98,"address":[15241376,15241074,15241231],"length":1,"stats":{"Line":2}},{"line":99,"address":[15138460,15138741,15138617],"length":1,"stats":{"Line":2}},{"line":100,"address":[15241866,15241742,15241585],"length":1,"stats":{"Line":2}},{"line":101,"address":[18059268,18059554,18059433],"length":1,"stats":{"Line":2}},{"line":102,"address":[18059830,18059522,18059687],"length":1,"stats":{"Line":2}},{"line":103,"address":[15132528,15132685,15132852],"length":1,"stats":{"Line":2}},{"line":104,"address":[15139949,15140116,15139792],"length":1,"stats":{"Line":2}},{"line":105,"address":[15126644,15126320,15126477],"length":1,"stats":{"Line":2}},{"line":106,"address":[15201357,15201524,15201200],"length":1,"stats":{"Line":2}},{"line":107,"address":[18061067,18060902,18061210],"length":1,"stats":{"Line":2}},{"line":108,"address":[15243824,15244148,15243981],"length":1,"stats":{"Line":2}},{"line":109,"address":[15240478,15240333,15240176],"length":1,"stats":{"Line":2}},{"line":110,"address":[15134824,15134522,15134679],"length":1,"stats":{"Line":2}},{"line":111,"address":[15135690,15134788,15134945],"length":1,"stats":{"Line":2}},{"line":117,"address":[15246585,15245792],"length":1,"stats":{"Line":1}},{"line":118,"address":[15133115],"length":1,"stats":{"Line":1}},{"line":120,"address":[15146933],"length":1,"stats":{"Line":1}},{"line":121,"address":[15207789],"length":1,"stats":{"Line":1}},{"line":123,"address":[15140005],"length":1,"stats":{"Line":1}},{"line":124,"address":[15346309],"length":1,"stats":{"Line":1}},{"line":125,"address":[15133249],"length":1,"stats":{"Line":1}},{"line":129,"address":[15346976,15349454,15349705],"length":1,"stats":{"Line":1}},{"line":130,"address":[15209670,15209557,15209724,15209445,15209631,15209592,15209405],"length":1,"stats":{"Line":7}},{"line":131,"address":[15246641,15247854],"length":1,"stats":{"Line":2}},{"line":132,"address":[15247875],"length":1,"stats":{"Line":1}},{"line":133,"address":[22910187],"length":1,"stats":{"Line":1}},{"line":134,"address":[15247955],"length":1,"stats":{"Line":1}},{"line":135,"address":[22910267],"length":1,"stats":{"Line":1}},{"line":136,"address":[18069266],"length":1,"stats":{"Line":1}},{"line":137,"address":[15209963],"length":1,"stats":{"Line":1}},{"line":138,"address":[15135392],"length":1,"stats":{"Line":1}},{"line":140,"address":[15215537],"length":1,"stats":{"Line":1}},{"line":141,"address":[18067977],"length":1,"stats":{"Line":1}},{"line":142,"address":[15208678],"length":1,"stats":{"Line":1}},{"line":143,"address":[15147917],"length":1,"stats":{"Line":1}},{"line":144,"address":[15134232],"length":1,"stats":{"Line":1}},{"line":145,"address":[15347379],"length":1,"stats":{"Line":1}},{"line":146,"address":[15141166],"length":1,"stats":{"Line":1}},{"line":147,"address":[15215920],"length":1,"stats":{"Line":1}},{"line":150,"address":[15251558],"length":1,"stats":{"Line":0}},{"line":153,"address":[15142286,15142208],"length":1,"stats":{"Line":2}},{"line":154,"address":[15135528],"length":1,"stats":{"Line":1}},{"line":157,"address":[15150005,15149789],"length":1,"stats":{"Line":2}},{"line":159,"address":[22910608],"length":1,"stats":{"Line":1}},{"line":160,"address":[15348752],"length":1,"stats":{"Line":1}},{"line":161,"address":[15348800],"length":1,"stats":{"Line":1}},{"line":162,"address":[15254064],"length":1,"stats":{"Line":1}},{"line":163,"address":[15252464,15252539],"length":1,"stats":{"Line":2}},{"line":164,"address":[15348979],"length":1,"stats":{"Line":1}},{"line":165,"address":[15248693],"length":1,"stats":{"Line":1}},{"line":175,"address":[12903799],"length":1,"stats":{"Line":5}},{"line":179,"address":[12001012],"length":1,"stats":{"Line":2}},{"line":180,"address":[12036158],"length":1,"stats":{"Line":3}},{"line":182,"address":[18295161,18295693,18296077,18297087,18295784,18295594,18296195,18295507,18296492,18295552,18296787,18296618,18295952,18295423,18295465,18295339,18295381],"length":1,"stats":{"Line":15}},{"line":183,"address":[15361004],"length":1,"stats":{"Line":1}},{"line":184,"address":[15242758],"length":1,"stats":{"Line":1}},{"line":185,"address":[15361092],"length":1,"stats":{"Line":1}},{"line":186,"address":[15355554],"length":1,"stats":{"Line":1}},{"line":187,"address":[15249680],"length":1,"stats":{"Line":1}},{"line":188,"address":[18295514],"length":1,"stats":{"Line":1}},{"line":189,"address":[15361325,15361279],"length":1,"stats":{"Line":2}},{"line":190,"address":[15456236,15456829,15455753,15456117],"length":1,"stats":{"Line":2}},{"line":191,"address":[15456244,15456369],"length":1,"stats":{"Line":2}},{"line":192,"address":[15456377,15456326,15456807,15456503],"length":1,"stats":{"Line":2}},{"line":193,"address":[15250046,15250340,15250231,15250490],"length":1,"stats":{"Line":2}},{"line":194,"address":[12032248],"length":1,"stats":{"Line":4}},{"line":196,"address":[15457379,15458061,15458452,15457531,15457461,15457773,15457228,15457899],"length":1,"stats":{"Line":6}},{"line":197,"address":[15318864,15318907,15319115,15319016],"length":1,"stats":{"Line":2}},{"line":198,"address":[18296992,18297032,18297273,18297457,18293551,18297115],"length":1,"stats":{"Line":4}},{"line":200,"address":[23020587,23019886,23020507,23020909,23021085,23020263,23020151,23020042],"length":1,"stats":{"Line":6}},{"line":201,"address":[15319685],"length":1,"stats":{"Line":1}},{"line":202,"address":[15326730,15326621,15326546,15326871],"length":1,"stats":{"Line":2}},{"line":203,"address":[12036236],"length":1,"stats":{"Line":4}},{"line":205,"address":[11933382],"length":1,"stats":{"Line":3}},{"line":207,"address":[15246633,15246437],"length":1,"stats":{"Line":2}},{"line":210,"address":[12836170],"length":1,"stats":{"Line":0}},{"line":218,"address":[15328845,15328927],"length":1,"stats":{"Line":0}},{"line":236,"address":[15247450],"length":1,"stats":{"Line":0}},{"line":237,"address":[23022508],"length":1,"stats":{"Line":0}},{"line":238,"address":[18300007],"length":1,"stats":{"Line":0}},{"line":240,"address":[15261361],"length":1,"stats":{"Line":0}},{"line":241,"address":[15460764],"length":1,"stats":{"Line":0}},{"line":243,"address":[15329270],"length":1,"stats":{"Line":0}},{"line":244,"address":[23022804],"length":1,"stats":{"Line":0}},{"line":245,"address":[18300271],"length":1,"stats":{"Line":0}},{"line":246,"address":[15329415],"length":1,"stats":{"Line":0}},{"line":247,"address":[15364562],"length":1,"stats":{"Line":0}},{"line":248,"address":[15247962],"length":1,"stats":{"Line":0}},{"line":249,"address":[15261809],"length":1,"stats":{"Line":0}},{"line":252,"address":[15261545],"length":1,"stats":{"Line":0}},{"line":253,"address":[15360798],"length":1,"stats":{"Line":0}},{"line":254,"address":[15329641],"length":1,"stats":{"Line":0}},{"line":255,"address":[15248161],"length":1,"stats":{"Line":0}},{"line":256,"address":[15254972],"length":1,"stats":{"Line":0}},{"line":257,"address":[15261988],"length":1,"stats":{"Line":0}},{"line":258,"address":[15364955],"length":1,"stats":{"Line":0}},{"line":263,"address":[15322304],"length":1,"stats":{"Line":0}},{"line":264,"address":[15364995],"length":1,"stats":{"Line":0}},{"line":266,"address":[15323035,15322965],"length":1,"stats":{"Line":0}},{"line":269,"address":[15255264,15255192],"length":1,"stats":{"Line":0}},{"line":273,"address":[23023421],"length":1,"stats":{"Line":0}},{"line":274,"address":[15365127],"length":1,"stats":{"Line":0}},{"line":276,"address":[15330030],"length":1,"stats":{"Line":0}},{"line":277,"address":[11452077],"length":1,"stats":{"Line":0}},{"line":279,"address":[15249278,15249433],"length":1,"stats":{"Line":0}},{"line":280,"address":[15366104],"length":1,"stats":{"Line":0}},{"line":281,"address":[15324089],"length":1,"stats":{"Line":0}},{"line":284,"address":[15249540,15250429,15249468,15250272],"length":1,"stats":{"Line":0}},{"line":285,"address":[15363014],"length":1,"stats":{"Line":0}},{"line":286,"address":[15368644],"length":1,"stats":{"Line":0}},{"line":289,"address":[15324172,15324283],"length":1,"stats":{"Line":0}},{"line":291,"address":[15249781],"length":1,"stats":{"Line":0}},{"line":293,"address":[15366389],"length":1,"stats":{"Line":0}},{"line":298,"address":[15369311,15369163,15368787,15371014,15371105,15369025,15368752,15368900,15370527,15370494],"length":1,"stats":{"Line":0}},{"line":305,"address":[11932057],"length":1,"stats":{"Line":0}},{"line":306,"address":[15327236,15326048,15326597,15326965,15326252,15327063,15326212,15326715,15326446,15326368],"length":1,"stats":{"Line":0}},{"line":307,"address":[15258391],"length":1,"stats":{"Line":0}},{"line":308,"address":[15265407,15265447],"length":1,"stats":{"Line":0}},{"line":309,"address":[15333331,15333092,15333735,15333215],"length":1,"stats":{"Line":0}},{"line":310,"address":[15326411,15326515],"length":1,"stats":{"Line":0}},{"line":311,"address":[15326769,15326480,15326632,15326523],"length":1,"stats":{"Line":0}},{"line":312,"address":[15332177,15333782,15333941,15333670,15334116,15333568],"length":1,"stats":{"Line":0}},{"line":313,"address":[15334085],"length":1,"stats":{"Line":0}},{"line":316,"address":[15372751,15374191,15371234,15371737,15371184,15371480,15371332],"length":1,"stats":{"Line":5}},{"line":323,"address":[15371769,15371359,15372198,15372760,15371612],"length":1,"stats":{"Line":2}},{"line":324,"address":[15335563,15336216,15336112,15335603,15335639,15336972,15335399,15335675,15335896,15336405,15335781],"length":1,"stats":{"Line":9}},{"line":325,"address":[15335550],"length":1,"stats":{"Line":1}},{"line":326,"address":[23029046],"length":1,"stats":{"Line":1}},{"line":327,"address":[15267870],"length":1,"stats":{"Line":1}},{"line":328,"address":[15372434,15372470],"length":1,"stats":{"Line":2}},{"line":329,"address":[15367000,15366894,15367138,15366699],"length":1,"stats":{"Line":2}},{"line":330,"address":[15253089,15254477,15254406,15254640,15254837,15254304],"length":1,"stats":{"Line":4}},{"line":332,"address":[15374078,15373097,15373215],"length":1,"stats":{"Line":3}},{"line":333,"address":[15367787,15367859,15367637,15367996,15368296,15367823,15368400,15368612,15368547,15368066,15367747],"length":1,"stats":{"Line":9}},{"line":334,"address":[15468102],"length":1,"stats":{"Line":1}},{"line":335,"address":[15268830],"length":1,"stats":{"Line":1}},{"line":336,"address":[15255110],"length":1,"stats":{"Line":1}},{"line":337,"address":[15367850],"length":1,"stats":{"Line":1}},{"line":339,"address":[15468293,15468492,15468399,15468067],"length":1,"stats":{"Line":2}},{"line":340,"address":[12000942],"length":1,"stats":{"Line":4}},{"line":343,"address":[15254964],"length":1,"stats":{"Line":1}},{"line":346,"address":[12935559],"length":1,"stats":{"Line":5}},{"line":352,"address":[18309511,18308450,18308588,18308220,18308992],"length":1,"stats":{"Line":2}},{"line":353,"address":[15338629,15338553,15339060,15338593,15339344,15338735,15338389,15338850,15339158,15339954],"length":1,"stats":{"Line":8}},{"line":354,"address":[15257020],"length":1,"stats":{"Line":1}},{"line":355,"address":[15263844],"length":1,"stats":{"Line":1}},{"line":356,"address":[18309188,18309224],"length":1,"stats":{"Line":2}},{"line":357,"address":[23031961,23032361,23032226,23032120],"length":1,"stats":{"Line":2}},{"line":358,"address":[12041698],"length":1,"stats":{"Line":4}},{"line":360,"address":[15340289,15339386,15339271],"length":1,"stats":{"Line":2}},{"line":361,"address":[15258822,15258675,15258887,15258116,15257872,15258022,15258061,15258574,15258168,15258274,15258344,15257982],"length":1,"stats":{"Line":0}},{"line":362,"address":[15257969],"length":1,"stats":{"Line":0}},{"line":363,"address":[18310093],"length":1,"stats":{"Line":0}},{"line":364,"address":[15271809],"length":1,"stats":{"Line":0}},{"line":365,"address":[15374744],"length":1,"stats":{"Line":0}},{"line":366,"address":[15271919,15271955],"length":1,"stats":{"Line":0}},{"line":367,"address":[23033285,23032910,23033179,23033378],"length":1,"stats":{"Line":0}},{"line":368,"address":[12004949],"length":1,"stats":{"Line":0}},{"line":371,"address":[15470975],"length":1,"stats":{"Line":1}},{"line":374,"address":[12011926],"length":1,"stats":{"Line":4}},{"line":380,"address":[15333963,15334045],"length":1,"stats":{"Line":2}},{"line":412,"address":[15273282],"length":1,"stats":{"Line":1}},{"line":414,"address":[15341124],"length":1,"stats":{"Line":1}},{"line":415,"address":[15266443,15266502],"length":1,"stats":{"Line":0}},{"line":416,"address":[15334318],"length":1,"stats":{"Line":0}},{"line":417,"address":[15273521],"length":1,"stats":{"Line":0}},{"line":418,"address":[18311845],"length":1,"stats":{"Line":0}},{"line":419,"address":[15376464],"length":1,"stats":{"Line":0}},{"line":420,"address":[15378147],"length":1,"stats":{"Line":0}},{"line":421,"address":[15273659],"length":1,"stats":{"Line":0}},{"line":422,"address":[15341442],"length":1,"stats":{"Line":0}},{"line":423,"address":[23034938],"length":1,"stats":{"Line":0}},{"line":424,"address":[15378261,15378331],"length":1,"stats":{"Line":0}},{"line":425,"address":[15372755],"length":1,"stats":{"Line":0}},{"line":426,"address":[18312102],"length":1,"stats":{"Line":0}},{"line":427,"address":[15341646],"length":1,"stats":{"Line":0}},{"line":428,"address":[15378437],"length":1,"stats":{"Line":0}},{"line":429,"address":[15260189],"length":1,"stats":{"Line":0}},{"line":430,"address":[23035188],"length":1,"stats":{"Line":0}},{"line":431,"address":[15378540],"length":1,"stats":{"Line":0}},{"line":432,"address":[15267063],"length":1,"stats":{"Line":0}},{"line":434,"address":[23034976],"length":1,"stats":{"Line":0}},{"line":435,"address":[15341871],"length":1,"stats":{"Line":0}},{"line":436,"address":[15334983],"length":1,"stats":{"Line":0}},{"line":437,"address":[15274178],"length":1,"stats":{"Line":0}},{"line":439,"address":[15341978,15341836],"length":1,"stats":{"Line":0}},{"line":442,"address":[15334267],"length":1,"stats":{"Line":1}},{"line":449,"address":[15378756],"length":1,"stats":{"Line":1}},{"line":451,"address":[15335897,15335691,15335326,15335221,15335083,15335571],"length":1,"stats":{"Line":5}},{"line":453,"address":[15274424,15274558,15274282,15274330],"length":1,"stats":{"Line":2}},{"line":454,"address":[15260672,15260767,15261027,15260861,15261257,15259124],"length":1,"stats":{"Line":4}},{"line":456,"address":[15274993,15275148],"length":1,"stats":{"Line":2}},{"line":457,"address":[15342939],"length":1,"stats":{"Line":1}},{"line":458,"address":[18313403],"length":1,"stats":{"Line":0}},{"line":461,"address":[23036499,23037292,23036399,23037264],"length":1,"stats":{"Line":4}},{"line":464,"address":[15343101,15343125],"length":1,"stats":{"Line":2}},{"line":465,"address":[15275367,15276096,15275689,15276278],"length":1,"stats":{"Line":0}},{"line":466,"address":[23037392],"length":1,"stats":{"Line":0}},{"line":467,"address":[15276121],"length":1,"stats":{"Line":0}},{"line":468,"address":[18314234],"length":1,"stats":{"Line":0}},{"line":470,"address":[18314309],"length":1,"stats":{"Line":0}},{"line":473,"address":[15268371],"length":1,"stats":{"Line":1}},{"line":476,"address":[15336299],"length":1,"stats":{"Line":1}},{"line":477,"address":[18313540],"length":1,"stats":{"Line":1}},{"line":478,"address":[15379963],"length":1,"stats":{"Line":1}}],"covered":148,"coverable":234},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","events.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_event_row;\nuse super::queries::{\n    INSERT_EVENT, INSERT_EVENT_TOPIC, MARK_EVENT_DELETED, MARK_EVENT_SYNCED, SELECT_EVENT_BY_ID,\n    SELECT_EVENT_TOPICS, SELECT_EVENTS_BY_AUTHOR, SELECT_EVENTS_BY_KIND, SELECT_UNSYNC_EVENTS,\n};\nuse crate::application::ports::repositories::EventRepository;\nuse crate::domain::entities::Event;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl EventRepository for SqliteRepository {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError> {\n        let tags_json = serde_json::to_string(&event.tags).unwrap_or_else(|_| \"[]\".to_string());\n\n        sqlx::query(INSERT_EVENT)\n            .bind(event.id.to_string())\n            .bind(&event.pubkey)\n            .bind(&event.content)\n            .bind(event.kind as i64)\n            .bind(&tags_json)\n            .bind(event.created_at.timestamp_millis())\n            .bind(&event.sig)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        for tag in &event.tags {\n            if tag.len() >= 2 {\n                let key = tag[0].to_lowercase();\n                if (key == \"topic\" || key == \"t\") && !tag[1].is_empty() {\n                    let _ = self.add_event_topic(&event.id, &tag[1]).await;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        let row = sqlx::query(SELECT_EVENT_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_event_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_KIND)\n            .bind(kind as i64)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_AUTHOR)\n            .bind(pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_EVENTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_SYNCED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError> {\n        sqlx::query(INSERT_EVENT_TOPIC)\n            .bind(event_id)\n            .bind(topic_id)\n            .bind(Utc::now().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_EVENT_TOPICS)\n            .bind(event_id)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            topics.push(row.try_get::<String, _>(\"topic_id\")?);\n        }\n\n        Ok(topics)\n    }\n}\n","traces":[{"line":16,"address":[13036151],"length":1,"stats":{"Line":0}},{"line":17,"address":[15713728,15713744,15711077],"length":1,"stats":{"Line":0}},{"line":19,"address":[21669918,21670411,21670206,21670470,21670128,21670617,21670061,21671024,21671134,21669984,21670735,21671319,21670253,21670292],"length":1,"stats":{"Line":0}},{"line":20,"address":[21539300,21538397,21538552,21538440],"length":1,"stats":{"Line":0}},{"line":21,"address":[21569744],"length":1,"stats":{"Line":0}},{"line":22,"address":[21573758],"length":1,"stats":{"Line":0}},{"line":23,"address":[21531753],"length":1,"stats":{"Line":0}},{"line":24,"address":[21538728,21538767],"length":1,"stats":{"Line":0}},{"line":25,"address":[21575662,21575371,21576046,21575543],"length":1,"stats":{"Line":0}},{"line":26,"address":[21471142,21471220],"length":1,"stats":{"Line":0}},{"line":27,"address":[15712031,15711729,15711772,15711884],"length":1,"stats":{"Line":0}},{"line":28,"address":[21574839,21574333,21573190,21574228,21574474,21574640],"length":1,"stats":{"Line":0}},{"line":30,"address":[21539676,21540359,21539817,21540291],"length":1,"stats":{"Line":0}},{"line":31,"address":[21533455,21533513],"length":1,"stats":{"Line":0}},{"line":32,"address":[21533531],"length":1,"stats":{"Line":0}},{"line":33,"address":[21575679],"length":1,"stats":{"Line":0}},{"line":34,"address":[12003666],"length":1,"stats":{"Line":0}},{"line":39,"address":[21458808],"length":1,"stats":{"Line":0}},{"line":42,"address":[21572390,21572502,21572964,21572240,21572275,21573689],"length":1,"stats":{"Line":0}},{"line":43,"address":[21459903,21459982,21460081,21460186,21460413,21460521,21461424,21460805],"length":1,"stats":{"Line":0}},{"line":44,"address":[21572673,21572718],"length":1,"stats":{"Line":0}},{"line":45,"address":[21578526,21578310,21578404,21578222],"length":1,"stats":{"Line":0}},{"line":46,"address":[21460461,21459713,21460124,21460301,21460757,21460213],"length":1,"stats":{"Line":0}},{"line":48,"address":[21673795],"length":1,"stats":{"Line":0}},{"line":49,"address":[21579176,21579278,21579644],"length":1,"stats":{"Line":0}},{"line":50,"address":[21535434],"length":1,"stats":{"Line":0}},{"line":54,"address":[12830008],"length":1,"stats":{"Line":0}},{"line":55,"address":[21543938,21543702,21544248,21543389,21543463,21544042,21543597,21545393],"length":1,"stats":{"Line":0}},{"line":56,"address":[21675011],"length":1,"stats":{"Line":0}},{"line":57,"address":[21574711],"length":1,"stats":{"Line":0}},{"line":58,"address":[21536704,21536607,21536492,21536832],"length":1,"stats":{"Line":0}},{"line":59,"address":[11974900],"length":1,"stats":{"Line":0}},{"line":61,"address":[21476571,21476416],"length":1,"stats":{"Line":0}},{"line":62,"address":[15717435,15717141,15717252,15717387],"length":1,"stats":{"Line":0}},{"line":63,"address":[21581467,21581672,21581890],"length":1,"stats":{"Line":0}},{"line":64,"address":[21538140],"length":1,"stats":{"Line":0}},{"line":67,"address":[21676261],"length":1,"stats":{"Line":0}},{"line":70,"address":[21677729,21678785,21676960,21676995,21677098,21677210],"length":1,"stats":{"Line":0}},{"line":75,"address":[21546634,21547777,21546428,21545785,21546103,21546330,21545864,21545998],"length":1,"stats":{"Line":0}},{"line":76,"address":[21577035],"length":1,"stats":{"Line":0}},{"line":77,"address":[21581048],"length":1,"stats":{"Line":0}},{"line":78,"address":[21582584,21582801,21582704,21582923],"length":1,"stats":{"Line":0}},{"line":79,"address":[21678138,21677125,21677682,21677593,21677770,21677930],"length":1,"stats":{"Line":0}},{"line":81,"address":[21546717,21546562],"length":1,"stats":{"Line":0}},{"line":82,"address":[21583805,21583511,21583622,21583757],"length":1,"stats":{"Line":0}},{"line":83,"address":[21578690,21578269,21578474],"length":1,"stats":{"Line":0}},{"line":84,"address":[21584220],"length":1,"stats":{"Line":0}},{"line":87,"address":[21583863],"length":1,"stats":{"Line":0}},{"line":90,"address":[12897999],"length":1,"stats":{"Line":0}},{"line":91,"address":[21548563,21548823,21548921,21548133,21548303,21549102,21548493,21548204,21548359],"length":1,"stats":{"Line":0}},{"line":92,"address":[21548338,21548164,21548648,21548212],"length":1,"stats":{"Line":0}},{"line":93,"address":[21585114,21585194],"length":1,"stats":{"Line":0}},{"line":94,"address":[21541506,21541458,21541689,21541244,21541600],"length":1,"stats":{"Line":0}},{"line":95,"address":[12007844],"length":1,"stats":{"Line":0}},{"line":97,"address":[21467495],"length":1,"stats":{"Line":0}},{"line":100,"address":[21580371,21581008,21580336,21582064,21580474,21580586],"length":1,"stats":{"Line":0}},{"line":101,"address":[21468230,21468761,21468125,21467987,21468058,21469906,21468457,21468555],"length":1,"stats":{"Line":0}},{"line":102,"address":[21481778,21481920,21482042,21481826],"length":1,"stats":{"Line":0}},{"line":103,"address":[12011172],"length":1,"stats":{"Line":0}},{"line":105,"address":[21543436,21543281],"length":1,"stats":{"Line":0}},{"line":106,"address":[21682188,21682236,21682053,21681942],"length":1,"stats":{"Line":0}},{"line":107,"address":[21682707,21682489,21682284],"length":1,"stats":{"Line":0}},{"line":108,"address":[21469581],"length":1,"stats":{"Line":0}},{"line":111,"address":[21543814],"length":1,"stats":{"Line":0}},{"line":114,"address":[12941823],"length":1,"stats":{"Line":0}},{"line":115,"address":[21552569,21551951,21552141,21552471,21552750,21552007,21551781,21551852,21552211],"length":1,"stats":{"Line":0}},{"line":116,"address":[21160992,21161118,21161412,21160944],"length":1,"stats":{"Line":0}},{"line":117,"address":[15724858,15724778],"length":1,"stats":{"Line":0}},{"line":118,"address":[21470514,21470300,21470745,21470562,21470656],"length":1,"stats":{"Line":0}},{"line":119,"address":[21583368,21583544,21583422,21583703,21583886,21582781],"length":1,"stats":{"Line":0}},{"line":121,"address":[21471143],"length":1,"stats":{"Line":0}},{"line":124,"address":[21685264,21685636,21684485,21684352,21684591,21685226,21684387],"length":1,"stats":{"Line":4}},{"line":125,"address":[21590168,21590724,21590905,21590356,21590623,21590286,21589918,21590002,21590042],"length":1,"stats":{"Line":9}},{"line":126,"address":[21553221],"length":1,"stats":{"Line":1}},{"line":127,"address":[21546333,21546373],"length":1,"stats":{"Line":2}},{"line":128,"address":[21478573,21478704,21478445,21478947],"length":1,"stats":{"Line":2}},{"line":129,"address":[21553189,21553553,21553456,21553642],"length":1,"stats":{"Line":2}},{"line":130,"address":[11969847],"length":1,"stats":{"Line":5}},{"line":131,"address":[21472530],"length":1,"stats":{"Line":0}},{"line":134,"address":[21589296,21589532,21589426,21589994,21589331,21591064],"length":1,"stats":{"Line":0}},{"line":135,"address":[15729101,15727479,15728114,15727584,15727909,15727380,15727301,15727811],"length":1,"stats":{"Line":0}},{"line":136,"address":[21547700,21547655],"length":1,"stats":{"Line":0}},{"line":137,"address":[15727332,15727514,15727420,15727636],"length":1,"stats":{"Line":0}},{"line":138,"address":[11977876],"length":1,"stats":{"Line":0}},{"line":140,"address":[21590379,21590532],"length":1,"stats":{"Line":0}},{"line":141,"address":[21555438,21555684,21555549,21555732],"length":1,"stats":{"Line":0}},{"line":142,"address":[21165001,21164776],"length":1,"stats":{"Line":0}},{"line":145,"address":[21592574],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":88},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mapper.rs"],"content":"pub(super) use crate::application::shared::mappers::{\n    map_event_row, map_joined_topic_row, map_post_row, map_topic_row, map_user_row,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mod.rs"],"content":"use super::ConnectionPool;\nuse super::Repository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\nmod bookmarks;\nmod direct_messages;\nmod events;\nmod mapper;\nmod pending_topics;\nmod posts;\nmod queries;\nmod topic_metrics;\nmod topics;\nmod users;\n\npub struct SqliteRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl Repository for SqliteRepository {\n    async fn initialize(&self) -> Result<(), AppError> {\n        self.pool.migrate().await?;\n        Ok(())\n    }\n\n    async fn health_check(&self) -> Result<bool, AppError> {\n        let result = sqlx::query(\"SELECT 1\")\n            .fetch_one(self.pool.get_pool())\n            .await;\n        Ok(result.is_ok())\n    }\n}\n","traces":[{"line":22,"address":[12743120],"length":1,"stats":{"Line":7}},{"line":29,"address":[12902179,12902261,12902367,12902144,12902095,12903004,12902571,12902912],"length":1,"stats":{"Line":33}},{"line":30,"address":[12940715,12940400,12940585,12941029],"length":1,"stats":{"Line":10}},{"line":31,"address":[12902878],"length":1,"stats":{"Line":6}},{"line":34,"address":[12904116,12903072,12903033,12903300,12903194,12903684,12903107,12903277],"length":1,"stats":{"Line":0}},{"line":35,"address":[12941722,12941517,12941949,12941652,12941585],"length":1,"stats":{"Line":0}},{"line":36,"address":[12903575,12903481,12903662,12903436],"length":1,"stats":{"Line":0}},{"line":37,"address":[12945981,12945773,12945685,12945269,12945631],"length":1,"stats":{"Line":0}},{"line":38,"address":[12843222,12843151],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","pending_topics.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    DELETE_PENDING_TOPIC, INSERT_PENDING_TOPIC, SELECT_PENDING_TOPIC_BY_ID,\n    SELECT_PENDING_TOPICS_BY_USER, UPDATE_PENDING_TOPIC_STATUS,\n};\nuse crate::application::ports::repositories::PendingTopicRepository;\nuse crate::domain::entities::{PendingTopic, PendingTopicStatus};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse sqlx::Row;\n\nfn map_pending_topic(row: &sqlx::sqlite::SqliteRow) -> Result<PendingTopic, AppError> {\n    let created_at = DateTime::<Utc>::from_timestamp_millis(row.try_get::<i64, _>(\"created_at\")?)\n        .ok_or_else(|| AppError::Internal(\"Invalid created_at timestamp\".into()))?;\n    let updated_at = DateTime::<Utc>::from_timestamp_millis(row.try_get::<i64, _>(\"updated_at\")?)\n        .ok_or_else(|| AppError::Internal(\"Invalid updated_at timestamp\".into()))?;\n    let status_value: String = row.try_get(\"status\")?;\n\n    Ok(PendingTopic::new(\n        row.try_get(\"pending_id\")?,\n        row.try_get(\"user_pubkey\")?,\n        row.try_get(\"name\")?,\n        row.try_get::<Option<String>, _>(\"description\")?,\n        PendingTopicStatus::from_value(status_value.as_str()),\n        row.try_get(\"offline_action_id\")?,\n        row.try_get::<Option<String>, _>(\"synced_topic_id\")?,\n        row.try_get::<Option<String>, _>(\"error_message\")?,\n        created_at,\n        updated_at,\n    ))\n}\n\n#[async_trait]\nimpl PendingTopicRepository for SqliteRepository {\n    async fn insert_pending_topic(&self, topic: &PendingTopic) -> Result<(), AppError> {\n        sqlx::query(INSERT_PENDING_TOPIC)\n            .bind(&topic.pending_id)\n            .bind(&topic.user_pubkey)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.status.as_str())\n            .bind(&topic.offline_action_id)\n            .bind(&topic.synced_topic_id)\n            .bind(&topic.error_message)\n            .bind(topic.created_at.timestamp_millis())\n            .bind(topic.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn list_pending_topics(&self, user_pubkey: &str) -> Result<Vec<PendingTopic>, AppError> {\n        let rows = sqlx::query(SELECT_PENDING_TOPICS_BY_USER)\n            .bind(user_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        rows.iter().map(map_pending_topic).collect()\n    }\n\n    async fn get_pending_topic(&self, pending_id: &str) -> Result<Option<PendingTopic>, AppError> {\n        let row = sqlx::query(SELECT_PENDING_TOPIC_BY_ID)\n            .bind(pending_id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => map_pending_topic(&row).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    async fn update_pending_topic_status(\n        &self,\n        pending_id: &str,\n        status: PendingTopicStatus,\n        synced_topic_id: Option<&str>,\n        error_message: Option<&str>,\n    ) -> Result<(), AppError> {\n        let now = Utc::now().timestamp_millis();\n        sqlx::query(UPDATE_PENDING_TOPIC_STATUS)\n            .bind(pending_id)\n            .bind(status.as_str())\n            .bind(synced_topic_id)\n            .bind(error_message)\n            .bind(now)\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn delete_pending_topic(&self, pending_id: &str) -> Result<(), AppError> {\n        sqlx::query(DELETE_PENDING_TOPIC)\n            .bind(pending_id)\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[20787989,20784192,20789221],"length":1,"stats":{"Line":0}},{"line":14,"address":[20815406,20815836],"length":1,"stats":{"Line":0}},{"line":15,"address":[20789262,20784624,20789248],"length":1,"stats":{"Line":0}},{"line":16,"address":[20821446,20821760,20821304],"length":1,"stats":{"Line":0}},{"line":17,"address":[20987118,20982807,20987104],"length":1,"stats":{"Line":0}},{"line":18,"address":[20821791,20821886,20821641],"length":1,"stats":{"Line":0}},{"line":20,"address":[20919100,20918699],"length":1,"stats":{"Line":0}},{"line":21,"address":[20710658,20710351,20710483],"length":1,"stats":{"Line":0}},{"line":22,"address":[20983347,20983198,20983518],"length":1,"stats":{"Line":0}},{"line":23,"address":[14958595,14958770,14958438],"length":1,"stats":{"Line":0}},{"line":24,"address":[20711535,20711214,20711371],"length":1,"stats":{"Line":0}},{"line":25,"address":[20786402,20786249],"length":1,"stats":{"Line":0}},{"line":26,"address":[20817812,20817606],"length":1,"stats":{"Line":0}},{"line":27,"address":[20718989,20718832,20719164],"length":1,"stats":{"Line":0}},{"line":28,"address":[20823813,20824145,20823656],"length":1,"stats":{"Line":0}},{"line":36,"address":[20866416,20866451,20867788,20868240,20866562,20866674,20867870],"length":1,"stats":{"Line":0}},{"line":37,"address":[20863292,20863577,20864176,20863161,20862958,20863038,20863335,20863217,20863448,20863765,20862918,20862843,20862998,20864078,20863695,20864357],"length":1,"stats":{"Line":0}},{"line":38,"address":[20750205],"length":1,"stats":{"Line":0}},{"line":39,"address":[20824833],"length":1,"stats":{"Line":0}},{"line":40,"address":[20824873],"length":1,"stats":{"Line":0}},{"line":41,"address":[20750361,20750321],"length":1,"stats":{"Line":0}},{"line":42,"address":[15004796,15004474,15004673,15005512],"length":1,"stats":{"Line":0}},{"line":43,"address":[20757284],"length":1,"stats":{"Line":0}},{"line":44,"address":[20863279],"length":1,"stats":{"Line":0}},{"line":45,"address":[20750615,20750658],"length":1,"stats":{"Line":0}},{"line":46,"address":[20764946,20764539,20764300,20764426],"length":1,"stats":{"Line":0}},{"line":47,"address":[20757579,20757941,20757697],"length":1,"stats":{"Line":0}},{"line":48,"address":[15005420,15005233,15005330],"length":1,"stats":{"Line":0}},{"line":49,"address":[15005726,15005338,15005392,15004253,15005566,15005909],"length":1,"stats":{"Line":0}},{"line":50,"address":[20864270],"length":1,"stats":{"Line":0}},{"line":53,"address":[12940505],"length":1,"stats":{"Line":0}},{"line":54,"address":[20758994,20759817,20759389,20759291,20759595,20758819,20758895,20759064],"length":1,"stats":{"Line":0}},{"line":55,"address":[20864802,20864847],"length":1,"stats":{"Line":0}},{"line":56,"address":[20759116,20758850,20758935,20759029],"length":1,"stats":{"Line":0}},{"line":57,"address":[20759179,20759037,20759091,20758629,20759339,20759547],"length":1,"stats":{"Line":0}},{"line":59,"address":[20766662,20766491],"length":1,"stats":{"Line":0}},{"line":62,"address":[20753040,20753075,20753764,20753302,20754489,20753190,20754681],"length":1,"stats":{"Line":0}},{"line":63,"address":[20866394,20866621,20867013,20866289,20866729,20866190,20866111],"length":1,"stats":{"Line":0}},{"line":64,"address":[20866177,20866222],"length":1,"stats":{"Line":0}},{"line":65,"address":[20767198,20767286,20767380,20767502],"length":1,"stats":{"Line":0}},{"line":66,"address":[20866965,20865921,20866509,20866669,20866332,20866421],"length":1,"stats":{"Line":0}},{"line":68,"address":[21169619],"length":1,"stats":{"Line":0}},{"line":69,"address":[20867198,20867096],"length":1,"stats":{"Line":0}},{"line":70,"address":[20867050],"length":1,"stats":{"Line":0}},{"line":74,"address":[12905613],"length":1,"stats":{"Line":0}},{"line":81,"address":[20761926],"length":1,"stats":{"Line":0}},{"line":82,"address":[20969047,20968727,20968593,20968468,20968270,20968521,20969148,20969329,20968349,20968797],"length":1,"stats":{"Line":0}},{"line":83,"address":[20755304,20755264],"length":1,"stats":{"Line":0}},{"line":84,"address":[20868514,20867933,20868016,20868145],"length":1,"stats":{"Line":0}},{"line":87,"address":[20769345],"length":1,"stats":{"Line":0}},{"line":88,"address":[20769236,20769450,20769353,20769539],"length":1,"stats":{"Line":0}},{"line":89,"address":[20768608,20769783,20769458,20769512,20769969,20769624],"length":1,"stats":{"Line":0}},{"line":90,"address":[20969242],"length":1,"stats":{"Line":0}},{"line":93,"address":[12905737],"length":1,"stats":{"Line":0}},{"line":94,"address":[20873452,20873277,20873353,20873522,20873749,20873847,20874028],"length":1,"stats":{"Line":0}},{"line":95,"address":[15011049,15011004],"length":1,"stats":{"Line":0}},{"line":96,"address":[20831260,20831439,20831345,20831526],"length":1,"stats":{"Line":0}},{"line":97,"address":[11931012],"length":1,"stats":{"Line":0}},{"line":98,"address":[15011605],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","posts.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_post_row;\nuse super::queries::{\n    INSERT_POST_EVENT, MARK_POST_DELETED, MARK_POST_SYNCED, SELECT_POST_BY_ID,\n    SELECT_POSTS_BY_AUTHOR, SELECT_POSTS_BY_TOPIC, SELECT_RECENT_POSTS, SELECT_UNSYNC_POSTS,\n    UPDATE_POST_CONTENT,\n};\nuse crate::application::ports::repositories::{PostFeedCursor, PostFeedPage, PostRepository};\nuse crate::domain::entities::Post;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{QueryBuilder, Sqlite};\n\nfn serialize_topic_tags(post: &Post) -> String {\n    let mut tags = vec![vec![\"t\".to_string(), post.topic_id.clone()]];\n    if let Some(scope) = post.scope.as_ref() {\n        tags.push(vec![\"scope\".to_string(), scope.clone()]);\n    }\n    if let Some(epoch) = post.epoch {\n        tags.push(vec![\"epoch\".to_string(), epoch.to_string()]);\n    }\n    serde_json::to_string(&tags).unwrap_or_else(|_| \"[]\".to_string())\n}\n\nfn topic_tag_like(topic_id: &str) -> String {\n    format!(r#\"[\"t\",\"{topic_id}\"]\"#)\n}\n\n#[async_trait]\nimpl PostRepository for SqliteRepository {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError> {\n        let tags_json = serialize_topic_tags(post);\n\n        sqlx::query(INSERT_POST_EVENT)\n            .bind(&post.id)\n            .bind(post.author.pubkey())\n            .bind(&post.content)\n            .bind(1)\n            .bind(&tags_json)\n            .bind(post.created_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        let row = sqlx::query(SELECT_POST_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_post_row(&row, None)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_TOPIC)\n            .bind(topic_tag_like(topic_id))\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, Some(topic_id))?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn update_post(&self, post: &Post) -> Result<(), AppError> {\n        sqlx::query(UPDATE_POST_CONTENT)\n            .bind(&post.content)\n            .bind(Utc::now().timestamp_millis())\n            .bind(&post.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_POSTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let mut post = map_post_row(&row, None)?;\n            post.mark_as_unsynced();\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_SYNCED)\n            .bind(event_id)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_AUTHOR)\n            .bind(author_pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_RECENT_POSTS)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<PostFeedCursor>,\n        limit: usize,\n    ) -> Result<PostFeedPage, AppError> {\n        let limit = limit.clamp(1, 100);\n        let fetch_limit = limit + 1;\n\n        let mut builder: QueryBuilder<Sqlite> = QueryBuilder::new(\n            \"SELECT e.event_id, e.public_key, e.content, e.tags, e.created_at \\\n             FROM events e \\\n             INNER JOIN follows f ON f.followed_pubkey = e.public_key \\\n             WHERE f.follower_pubkey = \",\n        );\n        builder.push_bind(follower_pubkey);\n        builder.push(\" AND e.kind = 1 AND e.deleted = 0\");\n\n        if let Some(cursor) = cursor {\n            builder.push(\" AND (e.created_at < \");\n            builder.push_bind(cursor.created_at);\n            builder.push(\" OR (e.created_at = \");\n            builder.push_bind(cursor.created_at);\n            builder.push(\" AND e.event_id < \");\n            builder.push_bind(cursor.event_id);\n            builder.push(\"))\");\n        }\n\n        builder.push(\" ORDER BY e.created_at DESC, e.event_id DESC LIMIT \");\n        builder.push_bind(fetch_limit as i64);\n\n        let rows = builder.build().fetch_all(self.pool.get_pool()).await?;\n\n        let mut rows_iter = rows.into_iter();\n        let mut posts = Vec::with_capacity(limit.min(fetch_limit));\n\n        for _ in 0..limit {\n            if let Some(row) = rows_iter.next() {\n                let post = map_post_row(&row, None)?;\n                posts.push(post);\n            } else {\n                break;\n            }\n        }\n\n        let has_more = rows_iter.next().is_some();\n        let next_cursor = if has_more {\n            posts.last().map(|post| {\n                PostFeedCursor {\n                    created_at: post.created_at.timestamp_millis(),\n                    event_id: post.id.clone(),\n                }\n                .to_string()\n            })\n        } else {\n            None\n        };\n\n        Ok(PostFeedPage {\n            items: posts,\n            next_cursor,\n            has_more,\n        })\n    }\n}\n","traces":[{"line":15,"address":[16600955,16601458,16599824],"length":1,"stats":{"Line":2}},{"line":16,"address":[12967401,12968423,12966845],"length":1,"stats":{"Line":2}},{"line":17,"address":[16596474,16596559],"length":1,"stats":{"Line":4}},{"line":18,"address":[16490744,16491108,16490707],"length":1,"stats":{"Line":2}},{"line":20,"address":[16565460,16565854],"length":1,"stats":{"Line":3}},{"line":21,"address":[16491140,16491184],"length":1,"stats":{"Line":2}},{"line":23,"address":[12967985,12968432,12968364,12968448],"length":1,"stats":{"Line":4}},{"line":26,"address":[16498720],"length":1,"stats":{"Line":1}},{"line":27,"address":[16484986],"length":1,"stats":{"Line":1}},{"line":32,"address":[12905815],"length":1,"stats":{"Line":8}},{"line":33,"address":[16736323],"length":1,"stats":{"Line":2}},{"line":35,"address":[16734950,16735166,16734695,16735678,16735053,16735399,16734894,16735284,16735946,16734774,16735012,16735776],"length":1,"stats":{"Line":18}},{"line":36,"address":[16730825,16730865],"length":1,"stats":{"Line":4}},{"line":37,"address":[24393849,24393062,24393265,24393145],"length":1,"stats":{"Line":4}},{"line":38,"address":[16692889],"length":1,"stats":{"Line":2}},{"line":40,"address":[16736692,16736728],"length":1,"stats":{"Line":4}},{"line":41,"address":[16736736,16736854,16737139,16736625],"length":1,"stats":{"Line":4}},{"line":42,"address":[16735453,16735319,16735222],"length":1,"stats":{"Line":2}},{"line":43,"address":[12098932],"length":1,"stats":{"Line":4}},{"line":45,"address":[16619230],"length":1,"stats":{"Line":1}},{"line":48,"address":[12831161],"length":1,"stats":{"Line":5}},{"line":49,"address":[16633535,16635060,16633818,16634428,16633614,16634147,16633713,16634045],"length":1,"stats":{"Line":6}},{"line":50,"address":[16619841,16619886],"length":1,"stats":{"Line":2}},{"line":51,"address":[16633566,16633654,16633748,16633870],"length":1,"stats":{"Line":2}},{"line":52,"address":[11888436],"length":1,"stats":{"Line":4}},{"line":54,"address":[16695181],"length":1,"stats":{"Line":1}},{"line":55,"address":[13302116,13301637,13301767],"length":1,"stats":{"Line":1}},{"line":56,"address":[24395681],"length":1,"stats":{"Line":0}},{"line":60,"address":[16734016,16736036,16734051,16734162,16734913,16734944,16734274],"length":1,"stats":{"Line":5}},{"line":65,"address":[16836939,16834909,16834769,16835760,16835099,16835456,16834835,16834965,16835204,16835554],"length":1,"stats":{"Line":8}},{"line":66,"address":[16629002,16628669,16628512,16628555],"length":1,"stats":{"Line":2}},{"line":67,"address":[16734664],"length":1,"stats":{"Line":1}},{"line":68,"address":[16621920,16622062,16621968,16622187],"length":1,"stats":{"Line":2}},{"line":69,"address":[16635245,16635830,16635919,16636032,16636400,16636192],"length":1,"stats":{"Line":4}},{"line":71,"address":[16697208,16697363],"length":1,"stats":{"Line":2}},{"line":72,"address":[13303725,13303852,13303896,13303622],"length":1,"stats":{"Line":4}},{"line":73,"address":[16736093,16735827,16736300],"length":1,"stats":{"Line":2}},{"line":74,"address":[16705062],"length":1,"stats":{"Line":1}},{"line":77,"address":[16697786],"length":1,"stats":{"Line":1}},{"line":80,"address":[24400145,24398978,24398848,24399735,24398883,24399776,24399084],"length":1,"stats":{"Line":0}},{"line":81,"address":[16705999,16706463,16705817,16706203,16705733,16706133,16705943,16706561,16706742],"length":1,"stats":{"Line":0}},{"line":82,"address":[16837356,16837396],"length":1,"stats":{"Line":0}},{"line":83,"address":[16743056,16742746,16742620,16742532],"length":1,"stats":{"Line":0}},{"line":84,"address":[16638226,16638306],"length":1,"stats":{"Line":0}},{"line":85,"address":[24399530,24399624,24399482,24399713,24399228],"length":1,"stats":{"Line":0}},{"line":86,"address":[16837728,16838246,16837904,16837101,16838063,16837782],"length":1,"stats":{"Line":0}},{"line":88,"address":[16625135],"length":1,"stats":{"Line":0}},{"line":91,"address":[16741939,16742751,16741904,16742034,16742792,16743161,16742140],"length":1,"stats":{"Line":5}},{"line":92,"address":[16701166,16700197,16700423,16700557,16700367,16700268,16700887,16700627,16700985],"length":1,"stats":{"Line":8}},{"line":93,"address":[24400612,24400660,24401096,24400786],"length":1,"stats":{"Line":2}},{"line":94,"address":[16625818,16625898],"length":1,"stats":{"Line":2}},{"line":95,"address":[16738348,16738562,16738610,16738793,16738704],"length":1,"stats":{"Line":2}},{"line":96,"address":[16700776,16700935,16700600,16700654,16701118,16700013],"length":1,"stats":{"Line":4}},{"line":98,"address":[16626487],"length":1,"stats":{"Line":1}},{"line":101,"address":[12838441],"length":1,"stats":{"Line":5}},{"line":102,"address":[16840521,16840051,16840294,16840619,16840189,16840825,16842013,16840122],"length":1,"stats":{"Line":6}},{"line":103,"address":[16641034,16640770,16640912,16640818],"length":1,"stats":{"Line":2}},{"line":104,"address":[16641465,16641097,16640549,16640920,16641009,16641257],"length":1,"stats":{"Line":4}},{"line":106,"address":[16746124,16745969],"length":1,"stats":{"Line":2}},{"line":107,"address":[16840934,16841180,16841228,16841045],"length":1,"stats":{"Line":4}},{"line":108,"address":[16709708,16710109,16709957],"length":1,"stats":{"Line":2}},{"line":109,"address":[24403554],"length":1,"stats":{"Line":1}},{"line":110,"address":[24403691],"length":1,"stats":{"Line":1}},{"line":113,"address":[16709762],"length":1,"stats":{"Line":1}},{"line":116,"address":[16748169,16748541,16747232,16747267,16747365,16747471,16748128],"length":1,"stats":{"Line":7}},{"line":117,"address":[16745934,16746946,16746200,16746144,16746765,16746664,16746018,16746334,16746404],"length":1,"stats":{"Line":10}},{"line":118,"address":[16703997,16703957],"length":1,"stats":{"Line":2}},{"line":119,"address":[16643299,16643609,16643173,16643085],"length":1,"stats":{"Line":2}},{"line":120,"address":[16742331,16742251],"length":1,"stats":{"Line":2}},{"line":121,"address":[16842659,16842801,16842707,16842405,16842890],"length":1,"stats":{"Line":2}},{"line":122,"address":[16635888,16636575,16636521,16636856,16637042,16636697],"length":1,"stats":{"Line":5}},{"line":124,"address":[24405195],"length":1,"stats":{"Line":2}},{"line":127,"address":[16712010,16711872,16711907,16712122,16712641,16713725],"length":1,"stats":{"Line":0}},{"line":132,"address":[16637513,16637592,16638156,16639524,16637831,16638362,16638058,16637726],"length":1,"stats":{"Line":0}},{"line":133,"address":[13311383],"length":1,"stats":{"Line":0}},{"line":134,"address":[16743576],"length":1,"stats":{"Line":0}},{"line":135,"address":[16743803,16743464,16743584,16743681],"length":1,"stats":{"Line":0}},{"line":136,"address":[11973284],"length":1,"stats":{"Line":0}},{"line":138,"address":[16749949,16749794],"length":1,"stats":{"Line":0}},{"line":139,"address":[16631798,16631933,16631981,16631687],"length":1,"stats":{"Line":0}},{"line":140,"address":[16744717,16744966,16745173],"length":1,"stats":{"Line":0}},{"line":141,"address":[16707007],"length":1,"stats":{"Line":0}},{"line":144,"address":[16744771],"length":1,"stats":{"Line":0}},{"line":147,"address":[16714998,16716082,16714272,16714410,16714307,16714522],"length":1,"stats":{"Line":0}},{"line":148,"address":[13314391,13313884,13314099,13313621,13313692,13314209,13315497,13313787],"length":1,"stats":{"Line":0}},{"line":149,"address":[16633232],"length":1,"stats":{"Line":0}},{"line":150,"address":[16640024,16639944,16640118,16640240],"length":1,"stats":{"Line":0}},{"line":151,"address":[19668932],"length":1,"stats":{"Line":0}},{"line":153,"address":[24408839,24408994],"length":1,"stats":{"Line":0}},{"line":154,"address":[16708930,16708636,16708747,16708882],"length":1,"stats":{"Line":0}},{"line":155,"address":[13314798,13315246,13315063],"length":1,"stats":{"Line":0}},{"line":156,"address":[24409748],"length":1,"stats":{"Line":0}},{"line":159,"address":[16847496],"length":1,"stats":{"Line":0}},{"line":162,"address":[16635348,16635464,16638966,16635104,16636489,16635151,16636866,16639188,16635688],"length":1,"stats":{"Line":4}},{"line":168,"address":[16710231,16710366],"length":1,"stats":{"Line":2}},{"line":169,"address":[16642645,16642561],"length":1,"stats":{"Line":1}},{"line":177,"address":[16754169],"length":1,"stats":{"Line":1}},{"line":178,"address":[16748667],"length":1,"stats":{"Line":1}},{"line":180,"address":[16636452,16635998],"length":1,"stats":{"Line":2}},{"line":181,"address":[16710684],"length":1,"stats":{"Line":1}},{"line":182,"address":[16849278],"length":1,"stats":{"Line":1}},{"line":183,"address":[16748941],"length":1,"stats":{"Line":1}},{"line":184,"address":[24411248],"length":1,"stats":{"Line":1}},{"line":185,"address":[16849375],"length":1,"stats":{"Line":1}},{"line":186,"address":[16849410],"length":1,"stats":{"Line":1}},{"line":187,"address":[16849481],"length":1,"stats":{"Line":1}},{"line":190,"address":[16754415],"length":1,"stats":{"Line":1}},{"line":191,"address":[13316846],"length":1,"stats":{"Line":1}},{"line":193,"address":[16636780,16637347,16639183,16636528,16635378,16636898],"length":1,"stats":{"Line":3}},{"line":195,"address":[16651040],"length":1,"stats":{"Line":1}},{"line":196,"address":[16719071,16718993],"length":1,"stats":{"Line":2}},{"line":198,"address":[16755953,16755865],"length":1,"stats":{"Line":2}},{"line":199,"address":[24412753],"length":1,"stats":{"Line":1}},{"line":200,"address":[16712457,16712582,16712791],"length":1,"stats":{"Line":2}},{"line":201,"address":[16851217],"length":1,"stats":{"Line":1}},{"line":207,"address":[16719989,16719267],"length":1,"stats":{"Line":2}},{"line":208,"address":[16713164,16713188],"length":1,"stats":{"Line":2}},{"line":209,"address":[16714210,16713190,16714032,16713456],"length":1,"stats":{"Line":3}},{"line":210,"address":[16653285],"length":1,"stats":{"Line":1}},{"line":211,"address":[16752175],"length":1,"stats":{"Line":1}},{"line":212,"address":[16721017],"length":1,"stats":{"Line":1}},{"line":214,"address":[16757854],"length":1,"stats":{"Line":0}},{"line":217,"address":[16713170],"length":1,"stats":{"Line":1}},{"line":220,"address":[16638698],"length":1,"stats":{"Line":1}},{"line":221,"address":[13318878],"length":1,"stats":{"Line":1}},{"line":222,"address":[13318910],"length":1,"stats":{"Line":1}}],"covered":95,"coverable":126},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","queries.rs"],"content":"﻿pub(super) const INSERT_BOOKMARK: &str = r#\"\n    INSERT INTO bookmarks (id, user_pubkey, post_id, created_at)\n    VALUES (?1, ?2, ?3, ?4)\n    ON CONFLICT(user_pubkey, post_id) DO NOTHING\n\"#;\n\npub(super) const DELETE_BOOKMARK: &str = r#\"\n    DELETE FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARK_BY_USER_AND_POST: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARKS_BY_USER: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const INSERT_DIRECT_MESSAGE: &str = r#\"\n    INSERT INTO direct_messages (\n        owner_npub,\n        conversation_npub,\n        sender_npub,\n        recipient_npub,\n        event_id,\n        client_message_id,\n        payload_cipher_base64,\n        created_at,\n        delivered,\n        direction\n    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\n\"#;\n\npub(super) const MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID: &str = r#\"\n    UPDATE direct_messages\n    SET delivered = ?4,\n        event_id = COALESCE(?3, event_id)\n    WHERE owner_npub = ?1\n      AND client_message_id = ?2\n\"#;\n\npub(super) const SELECT_DIRECT_MESSAGE_BY_ID: &str = r#\"\n    SELECT id,\n           owner_npub,\n           conversation_npub,\n           sender_npub,\n           recipient_npub,\n           event_id,\n           client_message_id,\n           payload_cipher_base64,\n           created_at,\n           delivered,\n           direction\n    FROM direct_messages\n    WHERE id = ?1\n\"#;\n\npub(super) const UPDATE_DM_CONVERSATION_LAST_MESSAGE: &str = r#\"\n    UPDATE direct_message_conversations\n    SET last_message_id = ?3,\n        last_message_created_at = ?4\n    WHERE owner_npub = ?1 AND conversation_npub = ?2\n\"#;\n\npub(super) const INSERT_DM_CONVERSATION: &str = r#\"\n    INSERT INTO direct_message_conversations (\n        owner_npub,\n        conversation_npub,\n        last_message_id,\n        last_message_created_at,\n        last_read_at\n    ) VALUES (?1, ?2, ?3, ?4, ?5)\n\"#;\n\npub(super) const MARK_DM_CONVERSATION_READ: &str = r#\"\n    UPDATE direct_message_conversations\n    SET last_read_at = MAX(last_read_at, ?3)\n    WHERE owner_npub = ?1 AND conversation_npub = ?2\n\"#;\n\npub(super) const INSERT_POST_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at)\n    VALUES (?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_POST_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE event_id = ? AND kind = 1\n\"#;\n\npub(super) const SELECT_POSTS_BY_TOPIC: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND tags LIKE '%' || ? || '%'\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const UPDATE_POST_CONTENT: &str = r#\"\n    UPDATE events\n    SET content = ?, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const MARK_POST_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND (sync_status IS NULL OR sync_status = 0)\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_POST_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, sync_event_id = ?, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_POSTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1 AND public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_RECENT_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const INSERT_TOPIC: &str = r#\"\n    INSERT INTO topics (topic_id, name, description, created_at, updated_at, visibility)\n    VALUES (?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const INSERT_PENDING_TOPIC: &str = r#\"\n    INSERT INTO topics_pending (\n        pending_id,\n        user_pubkey,\n        name,\n        description,\n        status,\n        offline_action_id,\n        synced_topic_id,\n        error_message,\n        created_at,\n        updated_at\n    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\n\"#;\n\npub(super) const SELECT_TOPIC_BY_ID: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count, visibility\n    FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const SELECT_ALL_TOPICS: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count, visibility\n    FROM topics\n    ORDER BY created_at ASC\n\"#;\n\npub(super) const SELECT_PENDING_TOPIC_BY_ID: &str = r#\"\n    SELECT pending_id,\n           user_pubkey,\n           name,\n           description,\n           status,\n           offline_action_id,\n           synced_topic_id,\n           error_message,\n           created_at,\n           updated_at\n    FROM topics_pending\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const SELECT_PENDING_TOPICS_BY_USER: &str = r#\"\n    SELECT pending_id,\n           user_pubkey,\n           name,\n           description,\n           status,\n           offline_action_id,\n           synced_topic_id,\n           error_message,\n           created_at,\n           updated_at\n    FROM topics_pending\n    WHERE user_pubkey = ?1\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const UPDATE_PENDING_TOPIC_STATUS: &str = r#\"\n    UPDATE topics_pending\n    SET status = ?2,\n        synced_topic_id = ?3,\n        error_message = ?4,\n        updated_at = ?5\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const DELETE_PENDING_TOPIC: &str = r#\"\n    DELETE FROM topics_pending\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const SELECT_JOINED_TOPICS: &str = r#\"\n    SELECT t.topic_id, t.name, t.description, t.created_at, t.updated_at, t.member_count, t.post_count, t.visibility\n    FROM topics t\n    INNER JOIN user_topics ut ON t.topic_id = ut.topic_id\n    WHERE ut.is_joined = 1 AND ut.user_pubkey = ?\n    ORDER BY t.created_at ASC\n\"#;\n\npub(super) const UPDATE_TOPIC: &str = r#\"\n    UPDATE topics\n    SET name = ?, description = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_USER_TOPICS_BY_TOPIC: &str = r#\"\n    DELETE FROM user_topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_TOPIC: &str = r#\"\n    DELETE FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const UPSERT_USER_TOPIC: &str = r#\"\n    INSERT INTO user_topics (topic_id, user_pubkey, is_joined, joined_at, left_at)\n    VALUES (?1, ?2, 1, ?3, NULL)\n    ON CONFLICT(topic_id, user_pubkey) DO UPDATE SET\n        is_joined = 1,\n        joined_at = excluded.joined_at,\n        left_at = NULL\n\"#;\n\npub(super) const SELECT_TOPIC_MEMBER_COUNT: &str = r#\"\n    SELECT COUNT(*) as count\n    FROM user_topics\n    WHERE topic_id = ?1 AND is_joined = 1\n\"#;\n\npub(super) const UPDATE_TOPIC_MEMBER_COUNT: &str = r#\"\n    UPDATE topics\n    SET member_count = ?1, updated_at = ?2\n    WHERE topic_id = ?3\n\"#;\n\npub(super) const MARK_TOPIC_LEFT: &str = r#\"\n    UPDATE user_topics\n    SET is_joined = 0, left_at = ?1\n    WHERE topic_id = ?2 AND user_pubkey = ?3\n\"#;\n\npub(super) const UPDATE_TOPIC_STATS: &str = r#\"\n    UPDATE topics\n    SET member_count = ?, post_count = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const UPSERT_TOPIC_METRICS: &str = r#\"\n    INSERT INTO topic_metrics (\n        topic_id,\n        window_start,\n        window_end,\n        posts_24h,\n        posts_6h,\n        unique_authors,\n        boosts,\n        replies,\n        bookmarks,\n        participant_delta,\n        score_24h,\n        score_6h,\n        updated_at\n    ) VALUES (\n        ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13\n    )\n    ON CONFLICT(topic_id, window_start) DO UPDATE SET\n        window_end = excluded.window_end,\n        posts_24h = excluded.posts_24h,\n        posts_6h = excluded.posts_6h,\n        unique_authors = excluded.unique_authors,\n        boosts = excluded.boosts,\n        replies = excluded.replies,\n        bookmarks = excluded.bookmarks,\n        participant_delta = excluded.participant_delta,\n        score_24h = excluded.score_24h,\n        score_6h = excluded.score_6h,\n        updated_at = excluded.updated_at\n\"#;\n\npub(super) const CLEANUP_TOPIC_METRICS: &str = r#\"\n    DELETE FROM topic_metrics\n    WHERE window_end < ?1\n\"#;\n\npub(super) const COLLECT_TOPIC_ACTIVITY: &str = r#\"\n    SELECT\n        et.topic_id AS topic_id,\n        COUNT(DISTINCT e.event_id) AS posts_count,\n        COUNT(DISTINCT e.public_key) AS unique_authors,\n        0 AS boosts,\n        0 AS replies,\n        0 AS bookmarks,\n        0 AS participant_delta\n    FROM event_topics et\n    INNER JOIN events e ON e.event_id = et.event_id\n    WHERE e.kind = 1\n      AND e.deleted = 0\n      AND e.created_at >= ?1\n      AND e.created_at < ?2\n    GROUP BY et.topic_id\n\"#;\n\npub(super) const SELECT_LATEST_METRICS_WINDOW_END: &str = r#\"\n    SELECT MAX(window_end) as window_end\n    FROM topic_metrics\n\"#;\n\npub(super) const SELECT_METRICS_BY_WINDOW: &str = r#\"\n    SELECT\n        topic_id,\n        window_start,\n        window_end,\n        posts_24h,\n        posts_6h,\n        unique_authors,\n        boosts,\n        replies,\n        bookmarks,\n        participant_delta,\n        score_24h,\n        score_6h,\n        updated_at\n    FROM topic_metrics\n    WHERE window_end = ?1\n    ORDER BY score_24h DESC, score_6h DESC, posts_24h DESC, topic_id ASC\n    LIMIT ?2\n\"#;\n\npub(super) const INSERT_USER: &str = r#\"\n    INSERT INTO users (\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    )\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_USER_BY_NPUB: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_USER_BY_PUBKEY: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE pubkey = ?\n\"#;\n\npub(super) const SEARCH_USERS: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE display_name LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR npub LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR pubkey LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR bio LIKE '%' || ?1 || '%' COLLATE NOCASE\n    ORDER BY updated_at DESC\n    LIMIT ?2\n\"#;\n\npub(super) const UPDATE_USER: &str = r#\"\n    UPDATE users\n    SET\n        display_name = ?,\n        bio = ?,\n        avatar_url = ?,\n        is_profile_public = ?,\n        show_online_status = ?,\n        updated_at = ?\n    WHERE npub = ?\n\"#;\n\npub(super) const DELETE_USER: &str = r#\"\n    DELETE FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_FOLLOWING_PUBKEYS: &str = r#\"\n    SELECT followed_pubkey\n    FROM follows\n    WHERE follower_pubkey = ?1\n\"#;\n\npub(super) const SELECT_FOLLOWER_PUBKEYS: &str = r#\"\n    SELECT follower_pubkey\n    FROM follows\n    WHERE followed_pubkey = ?1\n\"#;\n\npub(super) const UPSERT_FOLLOW_RELATION: &str = r#\"\n    INSERT INTO follows (follower_pubkey, followed_pubkey)\n    VALUES (?1, ?2)\n    ON CONFLICT(follower_pubkey, followed_pubkey) DO NOTHING\n\"#;\n\npub(super) const DELETE_FOLLOW_RELATION: &str = r#\"\n    DELETE FROM follows\n    WHERE follower_pubkey = ?1 AND followed_pubkey = ?2\n\"#;\n\npub(super) const INSERT_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at, sig)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_EVENT_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_KIND: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE kind = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const MARK_EVENT_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_EVENTS: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE sync_status IS NULL OR sync_status = 0\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_EVENT_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const INSERT_EVENT_TOPIC: &str = r#\"\n    INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at)\n    VALUES (?1, ?2, ?3)\n\"#;\n\npub(super) const SELECT_EVENT_TOPICS: &str = r#\"\n    SELECT topic_id FROM event_topics WHERE event_id = ?1\n\"#;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","topic_metrics.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    CLEANUP_TOPIC_METRICS, COLLECT_TOPIC_ACTIVITY, SELECT_LATEST_METRICS_WINDOW_END,\n    SELECT_METRICS_BY_WINDOW, UPSERT_TOPIC_METRICS,\n};\nuse crate::application::ports::repositories::TopicMetricsRepository;\nuse crate::domain::entities::{\n    MetricsWindow, TopicActivityRow, TopicMetricsRecord, TopicMetricsSnapshot, TopicMetricsUpsert,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse sqlx::FromRow;\n\n#[derive(Debug, FromRow)]\nstruct DbTopicActivityRow {\n    topic_id: String,\n    posts_count: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n}\n\n#[derive(Debug, FromRow)]\nstruct DbTopicMetricsRow {\n    topic_id: String,\n    window_start: i64,\n    window_end: i64,\n    posts_24h: i64,\n    posts_6h: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n    score_24h: f64,\n    score_6h: f64,\n    updated_at: i64,\n}\n\nimpl From<DbTopicMetricsRow> for TopicMetricsRecord {\n    fn from(value: DbTopicMetricsRow) -> Self {\n        Self {\n            topic_id: value.topic_id,\n            window_start: value.window_start,\n            window_end: value.window_end,\n            posts_24h: value.posts_24h,\n            posts_6h: value.posts_6h,\n            unique_authors: value.unique_authors,\n            boosts: value.boosts,\n            replies: value.replies,\n            bookmarks: value.bookmarks,\n            participant_delta: value.participant_delta,\n            score_24h: value.score_24h,\n            score_6h: value.score_6h,\n            updated_at: value.updated_at,\n        }\n    }\n}\n\n#[async_trait]\nimpl TopicMetricsRepository for SqliteRepository {\n    async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError> {\n        sqlx::query(UPSERT_TOPIC_METRICS)\n            .bind(&metrics.topic_id)\n            .bind(metrics.window_start)\n            .bind(metrics.window_end)\n            .bind(metrics.posts_24h)\n            .bind(metrics.posts_6h)\n            .bind(metrics.unique_authors)\n            .bind(metrics.boosts)\n            .bind(metrics.replies)\n            .bind(metrics.bookmarks)\n            .bind(metrics.participant_delta)\n            .bind(metrics.score_24h)\n            .bind(metrics.score_6h)\n            .bind(metrics.updated_at)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError> {\n        let result = sqlx::query(CLEANUP_TOPIC_METRICS)\n            .bind(cutoff_millis)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected())\n    }\n\n    async fn collect_activity(\n        &self,\n        window: MetricsWindow,\n    ) -> Result<Vec<TopicActivityRow>, AppError> {\n        let rows: Vec<DbTopicActivityRow> = sqlx::query_as(COLLECT_TOPIC_ACTIVITY)\n            .bind(window.start)\n            .bind(window.end)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut activities = Vec::with_capacity(rows.len());\n        for row in rows {\n            activities.push(TopicActivityRow {\n                topic_id: row.topic_id,\n                posts_count: row.posts_count,\n                unique_authors: row.unique_authors,\n                boosts: row.boosts,\n                replies: row.replies,\n                bookmarks: row.bookmarks,\n                participant_delta: row.participant_delta,\n            });\n        }\n\n        Ok(activities)\n    }\n\n    async fn latest_window_end(&self) -> Result<Option<i64>, AppError> {\n        let result: Option<(i64,)> = sqlx::query_as(SELECT_LATEST_METRICS_WINDOW_END)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n        Ok(result.map(|row| row.0))\n    }\n\n    async fn list_recent_metrics(\n        &self,\n        limit: usize,\n    ) -> Result<Option<TopicMetricsSnapshot>, AppError> {\n        let Some(window_end) = self.latest_window_end().await? else {\n            return Ok(None);\n        };\n\n        let fetch_limit = if limit == 0 { 1 } else { limit }.min(i64::MAX as usize);\n        let rows: Vec<DbTopicMetricsRow> = sqlx::query_as(SELECT_METRICS_BY_WINDOW)\n            .bind(window_end)\n            .bind(fetch_limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        if rows.is_empty() {\n            return Ok(Some(TopicMetricsSnapshot {\n                window_start: window_end,\n                window_end,\n                metrics: Vec::new(),\n            }));\n        }\n\n        let window_start = rows\n            .first()\n            .map(|row| row.window_start)\n            .unwrap_or(window_end);\n\n        let metrics = if limit == 0 {\n            Vec::new()\n        } else {\n            rows.into_iter()\n                .take(limit)\n                .map(TopicMetricsRecord::from)\n                .collect()\n        };\n\n        Ok(Some(TopicMetricsSnapshot {\n            window_start,\n            window_end,\n            metrics,\n        }))\n    }\n}\n","traces":[{"line":43,"address":[12640064],"length":1,"stats":{"Line":0}},{"line":45,"address":[20401293],"length":1,"stats":{"Line":0}},{"line":46,"address":[20401319],"length":1,"stats":{"Line":0}},{"line":47,"address":[12742987],"length":1,"stats":{"Line":0}},{"line":48,"address":[12839423],"length":1,"stats":{"Line":0}},{"line":49,"address":[12839427],"length":1,"stats":{"Line":0}},{"line":50,"address":[12707879],"length":1,"stats":{"Line":0}},{"line":51,"address":[12707883],"length":1,"stats":{"Line":0}},{"line":52,"address":[12743007],"length":1,"stats":{"Line":0}},{"line":53,"address":[23921075],"length":1,"stats":{"Line":0}},{"line":54,"address":[12640135],"length":1,"stats":{"Line":0}},{"line":55,"address":[12839451],"length":1,"stats":{"Line":0}},{"line":56,"address":[12743024],"length":1,"stats":{"Line":0}},{"line":57,"address":[20401365],"length":1,"stats":{"Line":0}},{"line":64,"address":[12838879],"length":1,"stats":{"Line":0}},{"line":65,"address":[24785307,24784620,24784815,24785541,24784776,24785090,24785863,24784659,24784893,24784932,24785051,24785192,24785011,24784698,24784737,24784545,24784854,24784971,24785645],"length":1,"stats":{"Line":0}},{"line":66,"address":[19450127],"length":1,"stats":{"Line":0}},{"line":67,"address":[24716887],"length":1,"stats":{"Line":0}},{"line":68,"address":[24821454],"length":1,"stats":{"Line":0}},{"line":69,"address":[24821493],"length":1,"stats":{"Line":0}},{"line":70,"address":[24784764],"length":1,"stats":{"Line":0}},{"line":71,"address":[18957587],"length":1,"stats":{"Line":0}},{"line":72,"address":[24703322],"length":1,"stats":{"Line":0}},{"line":73,"address":[24703361],"length":1,"stats":{"Line":0}},{"line":74,"address":[24777992],"length":1,"stats":{"Line":0}},{"line":75,"address":[24916511],"length":1,"stats":{"Line":0}},{"line":76,"address":[24820118],"length":1,"stats":{"Line":0}},{"line":77,"address":[24710302],"length":1,"stats":{"Line":0}},{"line":78,"address":[24916630,24916674],"length":1,"stats":{"Line":0}},{"line":79,"address":[24717467,24717604,24716816,24717370],"length":1,"stats":{"Line":0}},{"line":80,"address":[11987201],"length":1,"stats":{"Line":0}},{"line":82,"address":[24917291],"length":1,"stats":{"Line":0}},{"line":85,"address":[24711984,24711546,24711434,24711347,24711312,24712498],"length":1,"stats":{"Line":0}},{"line":86,"address":[24821993,24821766,24821529,24822091,24822273,24821696,24821597,24822359],"length":1,"stats":{"Line":0}},{"line":87,"address":[24817693],"length":1,"stats":{"Line":0}},{"line":88,"address":[24711781,24711704,24711962,24711875],"length":1,"stats":{"Line":0}},{"line":89,"address":[24823689,24823529,24823873,24823387,24822965,24823441],"length":1,"stats":{"Line":0}},{"line":91,"address":[24780153,24780264],"length":1,"stats":{"Line":0}},{"line":94,"address":[24789352,24789312,24787381,24787248,24787283,24787493,24788027],"length":1,"stats":{"Line":0}},{"line":98,"address":[24824482,24824948,24825049,24825254,24824721,24824411,24824616],"length":1,"stats":{"Line":0}},{"line":100,"address":[24720018],"length":1,"stats":{"Line":0}},{"line":101,"address":[24706363,24706154,24706485,24706266],"length":1,"stats":{"Line":0}},{"line":102,"address":[24706918,24705888,24706460,24706371,24706708,24706548],"length":1,"stats":{"Line":0}},{"line":104,"address":[24819599,24819752],"length":1,"stats":{"Line":0}},{"line":105,"address":[19454057,19454184,19454237,19453954],"length":1,"stats":{"Line":0}},{"line":106,"address":[24714581,24714321],"length":1,"stats":{"Line":0}},{"line":107,"address":[24820161],"length":1,"stats":{"Line":0}},{"line":108,"address":[24714273],"length":1,"stats":{"Line":0}},{"line":109,"address":[24789017],"length":1,"stats":{"Line":0}},{"line":110,"address":[24782097],"length":1,"stats":{"Line":0}},{"line":111,"address":[18961817],"length":1,"stats":{"Line":0}},{"line":112,"address":[24789041],"length":1,"stats":{"Line":0}},{"line":113,"address":[19454389],"length":1,"stats":{"Line":0}},{"line":117,"address":[24707654],"length":1,"stats":{"Line":0}},{"line":120,"address":[24824480,24824714,24825606,24825098,24824602,24824515],"length":1,"stats":{"Line":0}},{"line":121,"address":[24783563,24782771,24782906,24783464,24783301,24782976,24783203,24782839],"length":1,"stats":{"Line":0}},{"line":122,"address":[24820914,24821053,24820959,24821140],"length":1,"stats":{"Line":0}},{"line":123,"address":[24826277,24826645,24826787,24826699,24826947,24827112],"length":1,"stats":{"Line":0}},{"line":124,"address":[24821688,24821620,24821507,24821680],"length":1,"stats":{"Line":0}},{"line":127,"address":[18964880,18966043,18963461,18963606,18963296,18963860,18963343],"length":1,"stats":{"Line":0}},{"line":131,"address":[11990815],"length":1,"stats":{"Line":0}},{"line":132,"address":[24723786],"length":1,"stats":{"Line":0}},{"line":135,"address":[19456887,19456805],"length":1,"stats":{"Line":0}},{"line":136,"address":[24823200,24823728,24823095,24824687,24823409,24822876,24823523,24822954],"length":1,"stats":{"Line":0}},{"line":137,"address":[24723998],"length":1,"stats":{"Line":0}},{"line":138,"address":[18964613],"length":1,"stats":{"Line":0}},{"line":139,"address":[24791837,24791723,24792074,24791946],"length":1,"stats":{"Line":0}},{"line":140,"address":[12028946],"length":1,"stats":{"Line":0}},{"line":142,"address":[24827746,24827593],"length":1,"stats":{"Line":0}},{"line":143,"address":[24828413],"length":1,"stats":{"Line":0}},{"line":144,"address":[24829429],"length":1,"stats":{"Line":0}},{"line":146,"address":[19457907],"length":1,"stats":{"Line":0}},{"line":150,"address":[24724955,24725019,24724872],"length":1,"stats":{"Line":0}},{"line":152,"address":[24830288,24830293],"length":1,"stats":{"Line":0}},{"line":153,"address":[24792767],"length":1,"stats":{"Line":0}},{"line":155,"address":[24725048],"length":1,"stats":{"Line":0}},{"line":156,"address":[24824096,24824007],"length":1,"stats":{"Line":0}},{"line":158,"address":[18965626,18965923],"length":1,"stats":{"Line":0}},{"line":159,"address":[24924679],"length":1,"stats":{"Line":0}},{"line":164,"address":[24718243],"length":1,"stats":{"Line":0}},{"line":166,"address":[24828039],"length":1,"stats":{"Line":0}},{"line":167,"address":[24718195],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":82},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","topics.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::{map_joined_topic_row, map_topic_row};\nuse super::queries::{\n    DELETE_TOPIC, DELETE_USER_TOPICS_BY_TOPIC, INSERT_TOPIC, MARK_TOPIC_LEFT, SELECT_ALL_TOPICS,\n    SELECT_JOINED_TOPICS, SELECT_TOPIC_BY_ID, SELECT_TOPIC_MEMBER_COUNT, UPDATE_TOPIC,\n    UPDATE_TOPIC_MEMBER_COUNT, UPDATE_TOPIC_STATS, UPSERT_USER_TOPIC,\n};\nuse crate::application::ports::repositories::TopicRepository;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::Topic;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl TopicRepository for SqliteRepository {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(INSERT_TOPIC)\n            .bind(&topic.id)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.created_at.timestamp_millis())\n            .bind(topic.updated_at.timestamp_millis())\n            .bind(topic.visibility.as_str())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        let row = sqlx::query(SELECT_TOPIC_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_topic_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_ALL_TOPICS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_JOINED_TOPICS)\n            .bind(user_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_joined_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.updated_at.timestamp_millis())\n            .bind(&topic.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        if id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"デフォルトトピックは削除できません\".into());\n        }\n\n        sqlx::query(DELETE_USER_TOPICS_BY_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        sqlx::query(DELETE_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(UPSERT_USER_TOPIC)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .bind(now)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        if topic_id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"デフォルトトピックから離脱することはできません\".into());\n        }\n\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(MARK_TOPIC_LEFT)\n            .bind(now)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn update_topic_stats(\n        &self,\n        id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC_STATS)\n            .bind(member_count as i64)\n            .bind(post_count as i64)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[19988046,19986451,19986416,19986562,19986674,19987676,19987587],"length":1,"stats":{"Line":0}},{"line":19,"address":[19982843,19982998,19983564,19983982,19983884,19983237,19982918,19982958,19983494,19984163,19983108,19983376],"length":1,"stats":{"Line":0}},{"line":20,"address":[19982909],"length":1,"stats":{"Line":0}},{"line":21,"address":[19870241],"length":1,"stats":{"Line":0}},{"line":22,"address":[18314913,18314877],"length":1,"stats":{"Line":0}},{"line":23,"address":[19870329,19870439,19870170,19871014],"length":1,"stats":{"Line":0}},{"line":24,"address":[19877239,19877352,19877769],"length":1,"stats":{"Line":0}},{"line":25,"address":[19877496,19877740,19877368],"length":1,"stats":{"Line":0}},{"line":26,"address":[19987368,19987465,19987555],"length":1,"stats":{"Line":0}},{"line":27,"address":[19987708,19987868,19986589,19987473,19987527,19988051],"length":1,"stats":{"Line":0}},{"line":29,"address":[19989660],"length":1,"stats":{"Line":0}},{"line":32,"address":[20084576,20084726,20084838,20084611,20086025,20085300],"length":1,"stats":{"Line":0}},{"line":33,"address":[19946746,19947081,19946463,19947365,19947982,19946542,19946641,19946973],"length":1,"stats":{"Line":0}},{"line":34,"address":[19878721,19878766],"length":1,"stats":{"Line":0}},{"line":35,"address":[19988724,19988846,19988542,19988630],"length":1,"stats":{"Line":0}},{"line":36,"address":[11960852],"length":1,"stats":{"Line":0}},{"line":38,"address":[14126995],"length":1,"stats":{"Line":0}},{"line":39,"address":[19989962,19989496,19989598],"length":1,"stats":{"Line":0}},{"line":40,"address":[19886570],"length":1,"stats":{"Line":0}},{"line":44,"address":[12938361],"length":1,"stats":{"Line":0}},{"line":45,"address":[19875666,19874521,19874315,19874217,19873747,19873990,19873818,19873885],"length":1,"stats":{"Line":0}},{"line":46,"address":[14128130,14128082,14128346,14128224],"length":1,"stats":{"Line":0}},{"line":47,"address":[19887688,19887865,19888233,19887777,19888025,19887317],"length":1,"stats":{"Line":0}},{"line":49,"address":[19987153,19987308],"length":1,"stats":{"Line":0}},{"line":50,"address":[19888636,19888684,19888390,19888501],"length":1,"stats":{"Line":0}},{"line":51,"address":[19888732,19888937,19889155],"length":1,"stats":{"Line":0}},{"line":52,"address":[14129645],"length":1,"stats":{"Line":0}},{"line":55,"address":[19949574],"length":1,"stats":{"Line":0}},{"line":58,"address":[13038793],"length":1,"stats":{"Line":0}},{"line":59,"address":[19957555,19957634,19958163,19959514,19958369,19957733,19957838,19958065],"length":1,"stats":{"Line":0}},{"line":60,"address":[19988850,19988805],"length":1,"stats":{"Line":0}},{"line":61,"address":[19957768,19957586,19957674,19957890],"length":1,"stats":{"Line":0}},{"line":62,"address":[11912980],"length":1,"stats":{"Line":0}},{"line":64,"address":[20089849,20090004],"length":1,"stats":{"Line":0}},{"line":65,"address":[19993598,19993709,19993844,19993892],"length":1,"stats":{"Line":0}},{"line":66,"address":[19877300,19877723,19877505],"length":1,"stats":{"Line":0}},{"line":67,"address":[19891429],"length":1,"stats":{"Line":0}},{"line":70,"address":[19951902],"length":1,"stats":{"Line":0}},{"line":73,"address":[19952722,19952828,19953497,19953897,19952592,19952627,19953528],"length":1,"stats":{"Line":0}},{"line":74,"address":[19997047,19997367,19996629,19997465,19997646,19996748,19996913,19997117,19996708,19996861],"length":1,"stats":{"Line":0}},{"line":75,"address":[19959927],"length":1,"stats":{"Line":0}},{"line":76,"address":[19885231,19885271],"length":1,"stats":{"Line":0}},{"line":77,"address":[19885156,19885392,19885698,19885279],"length":1,"stats":{"Line":0}},{"line":78,"address":[18322940,18323012],"length":1,"stats":{"Line":0}},{"line":79,"address":[19885436,19885667,19885578,19885484],"length":1,"stats":{"Line":0}},{"line":80,"address":[19997090,19996445,19997415,19997598,19997256,19997144],"length":1,"stats":{"Line":0}},{"line":82,"address":[19995911],"length":1,"stats":{"Line":0}},{"line":85,"address":[17230511],"length":1,"stats":{"Line":0}},{"line":86,"address":[19961278],"length":1,"stats":{"Line":0}},{"line":87,"address":[19992534,19992882],"length":1,"stats":{"Line":0}},{"line":90,"address":[19893559,19894211,19894384,19893852,19893679,19894113,19893782,19894715],"length":1,"stats":{"Line":0}},{"line":91,"address":[19893666,19893706],"length":1,"stats":{"Line":0}},{"line":92,"address":[18324234,18324329,18324411,18324151],"length":1,"stats":{"Line":0}},{"line":93,"address":[19998864,19998353,19998529,19997853,19998689,19998407],"length":1,"stats":{"Line":0}},{"line":95,"address":[19955137,19955663,19955942,19955474,19955761,19955301,19955404],"length":1,"stats":{"Line":0}},{"line":96,"address":[19955328,19955288],"length":1,"stats":{"Line":0}},{"line":97,"address":[19993637,19993551,19993365,19993448],"length":1,"stats":{"Line":0}},{"line":98,"address":[20094191,20093927,20093981,20094032,20092655,20094374],"length":1,"stats":{"Line":0}},{"line":100,"address":[19997903],"length":1,"stats":{"Line":0}},{"line":103,"address":[12942607],"length":1,"stats":{"Line":0}},{"line":104,"address":[19881889],"length":1,"stats":{"Line":0}},{"line":105,"address":[12005119],"length":1,"stats":{"Line":0}},{"line":107,"address":[19965131,19964146,19964355,19964851,19964312,19964618,19964394,19964503,19964958,19965490],"length":1,"stats":{"Line":0}},{"line":108,"address":[14137081],"length":1,"stats":{"Line":0}},{"line":109,"address":[19999459],"length":1,"stats":{"Line":0}},{"line":110,"address":[20001150,20001189],"length":1,"stats":{"Line":0}},{"line":111,"address":[19896502,19896669,19896778,19896919],"length":1,"stats":{"Line":0}},{"line":112,"address":[11902258],"length":1,"stats":{"Line":0}},{"line":114,"address":[19958809,19959106,19959025,19958290,19958469,19959256,19959739,19958124,19958702,19958399],"length":1,"stats":{"Line":0}},{"line":115,"address":[19883725,19883683],"length":1,"stats":{"Line":0}},{"line":116,"address":[20096805,20097010,20096720,20096914],"length":1,"stats":{"Line":0}},{"line":117,"address":[11888520],"length":1,"stats":{"Line":0}},{"line":120,"address":[18329519,18328998,18329412,18328917,18328956,18329107,18329177,18328846,18329772,18329890],"length":1,"stats":{"Line":0}},{"line":122,"address":[19959391],"length":1,"stats":{"Line":0}},{"line":123,"address":[19959430,19959472],"length":1,"stats":{"Line":0}},{"line":124,"address":[19959480,19959685,19959589,19959324],"length":1,"stats":{"Line":0}},{"line":125,"address":[20003603,20003867,20003293,19999950,20003353,20003440],"length":1,"stats":{"Line":0}},{"line":127,"address":[19967274,19966992,19963200,19967181,19967609],"length":1,"stats":{"Line":0}},{"line":128,"address":[20002678],"length":1,"stats":{"Line":0}},{"line":131,"address":[12839839],"length":1,"stats":{"Line":0}},{"line":132,"address":[19968263],"length":1,"stats":{"Line":0}},{"line":133,"address":[20005357,20005090],"length":1,"stats":{"Line":0}},{"line":136,"address":[14141147,14141087],"length":1,"stats":{"Line":0}},{"line":137,"address":[20100204,20100698,20101238,20099974,20100034,20099531],"length":1,"stats":{"Line":0}},{"line":139,"address":[19969363,19969930,19969320,19969587,19970462,19969278,19969115,19969472,19970103,19969820],"length":1,"stats":{"Line":0}},{"line":140,"address":[19887746],"length":1,"stats":{"Line":0}},{"line":141,"address":[14142089],"length":1,"stats":{"Line":0}},{"line":142,"address":[18331915,18331958],"length":1,"stats":{"Line":0}},{"line":143,"address":[20004768,20004627,20004351,20004518],"length":1,"stats":{"Line":0}},{"line":144,"address":[11889938],"length":1,"stats":{"Line":0}},{"line":146,"address":[19970024,19970369,19970928,19970712,19970602,19970190,19971642,19971159,19971009,19970299],"length":1,"stats":{"Line":0}},{"line":147,"address":[19963247,19963289],"length":1,"stats":{"Line":0}},{"line":148,"address":[19902574,19902465,19902380,19902670],"length":1,"stats":{"Line":0}},{"line":149,"address":[19886495,19888882,19889360,19888822,19888967,19889130],"length":1,"stats":{"Line":0}},{"line":152,"address":[20102900,20103314,20102748,20102858,20103079,20103424,20103677,20102819,20103009,20103799],"length":1,"stats":{"Line":0}},{"line":154,"address":[14144078],"length":1,"stats":{"Line":0}},{"line":155,"address":[20002559,20002517],"length":1,"stats":{"Line":0}},{"line":156,"address":[18333908,18334113,18333752,18334017],"length":1,"stats":{"Line":0}},{"line":157,"address":[11964574],"length":1,"stats":{"Line":0}},{"line":159,"address":[12002708],"length":1,"stats":{"Line":0}},{"line":160,"address":[20007659],"length":1,"stats":{"Line":0}},{"line":163,"address":[12839950],"length":1,"stats":{"Line":0}},{"line":169,"address":[19973238,19973121,19973624,19973886,19973984,19973203,19973420,19974165,19973554,19973364],"length":1,"stats":{"Line":0}},{"line":170,"address":[19973199],"length":1,"stats":{"Line":0}},{"line":171,"address":[20010033,20010002],"length":1,"stats":{"Line":0}},{"line":172,"address":[20104825,20105262,20104704,20104951],"length":1,"stats":{"Line":0}},{"line":173,"address":[20008607,20008527],"length":1,"stats":{"Line":0}},{"line":174,"address":[19973447,19973495,19973160,19973589,19973679],"length":1,"stats":{"Line":0}},{"line":175,"address":[14146901,14146435,14146718,14145677,14146558,14146381],"length":1,"stats":{"Line":0}},{"line":177,"address":[20105630],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":110},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","users.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_user_row;\nuse super::queries::{\n    DELETE_FOLLOW_RELATION, DELETE_USER, INSERT_USER, SEARCH_USERS, SELECT_FOLLOWER_PUBKEYS,\n    SELECT_FOLLOWING_PUBKEYS, SELECT_USER_BY_NPUB, SELECT_USER_BY_PUBKEY, UPDATE_USER,\n    UPSERT_FOLLOW_RELATION,\n};\nuse crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};\nuse sqlx::{QueryBuilder, Row, Sqlite};\n\nconst SORT_KEY_LOWER_EXPR: &str = \"LOWER(COALESCE(NULLIF(TRIM(u.display_name), ''), u.npub))\";\n\nfn encode_follow_cursor(sort: FollowListSort, primary: &str, pubkey: &str) -> String {\n    let encoded_primary = URL_SAFE_NO_PAD.encode(primary.as_bytes());\n    format!(\"{}|{}|{}\", sort.as_str(), encoded_primary, pubkey)\n}\n\nfn decode_follow_cursor(\n    cursor: &str,\n    expected_sort: FollowListSort,\n) -> Result<(String, String), AppError> {\n    let mut parts = cursor.splitn(3, '|');\n    let sort_part = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    if sort_part != expected_sort.as_str() {\n        return Err(AppError::InvalidInput(\"Cursor sort mismatch\".into()));\n    }\n    let primary_encoded = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    let pubkey = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    let primary_bytes = URL_SAFE_NO_PAD\n        .decode(primary_encoded.as_bytes())\n        .map_err(|_| AppError::InvalidInput(\"Invalid cursor payload\".into()))?;\n    let primary = String::from_utf8(primary_bytes)\n        .map_err(|_| AppError::InvalidInput(\"Invalid cursor payload\".into()))?;\n    if pubkey.is_empty() {\n        return Err(AppError::InvalidInput(\"Invalid cursor pubkey\".into()));\n    }\n    Ok((primary, pubkey.to_string()))\n}\n\nstruct FollowQueryDescriptor {\n    join_expr: &'static str,\n    filter_column: &'static str,\n    relation_column: &'static str,\n}\n\nasync fn query_follow_relation(\n    repo: &SqliteRepository,\n    npub: &str,\n    cursor: Option<&str>,\n    limit: usize,\n    sort: FollowListSort,\n    search: Option<&str>,\n    descriptor: FollowQueryDescriptor,\n) -> Result<UserCursorPage, AppError> {\n    let limit = limit.clamp(1, 100);\n    let fetch_limit = limit + 1;\n    let normalized_search = search.map(|s| s.to_lowercase());\n\n    let mut builder: QueryBuilder<Sqlite> = QueryBuilder::new(&format!(\n        \"SELECT u.npub, u.pubkey, u.display_name, u.bio, u.avatar_url, u.is_profile_public, u.show_online_status, u.created_at, u.updated_at, \\\n                f.created_at AS relation_created_at, {relation_column} AS relation_pubkey, \\\n                {SORT_KEY_LOWER_EXPR} AS sort_key_normalized \\\n             FROM users u \\\n             INNER JOIN follows f ON u.pubkey = {join_expr} \\\n             WHERE {filter_column} = (SELECT pubkey FROM users WHERE npub = ?)\",\n        relation_column = descriptor.relation_column,\n        join_expr = descriptor.join_expr,\n        filter_column = descriptor.filter_column,\n    ));\n    builder.push_bind(npub);\n\n    let mut count_builder: QueryBuilder<Sqlite> = QueryBuilder::new(&format!(\n        \"SELECT COUNT(*) as total_count \\\n         FROM users u \\\n         INNER JOIN follows f ON u.pubkey = {join_expr} \\\n         WHERE {filter_column} = (SELECT pubkey FROM users WHERE npub = ?)\",\n        join_expr = descriptor.join_expr,\n        filter_column = descriptor.filter_column,\n    ));\n    count_builder.push_bind(npub);\n\n    if let Some(search_value) = normalized_search.as_ref() {\n        let pattern = format!(\"%{search_value}%\");\n        for builder_ref in [&mut builder, &mut count_builder] {\n            builder_ref.push(\" AND (\");\n            builder_ref.push(SORT_KEY_LOWER_EXPR);\n            builder_ref.push(\" LIKE ? OR LOWER(u.npub) LIKE ? OR LOWER(u.pubkey) LIKE ?)\");\n            builder_ref.push_bind(pattern.clone());\n            builder_ref.push_bind(pattern.clone());\n            builder_ref.push_bind(pattern.clone());\n        }\n    }\n\n    if let Some(cursor_str) = cursor {\n        let (primary_str, cursor_pubkey) = decode_follow_cursor(cursor_str, sort)?;\n        match sort {\n            FollowListSort::Recent => {\n                let timestamp = primary_str\n                    .parse::<i64>()\n                    .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\n                builder.push(format!(\n                    \" AND (f.created_at < ? OR (f.created_at = ? AND {relation_column} < ?))\",\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(timestamp);\n                builder.push_bind(timestamp);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::Oldest => {\n                let timestamp = primary_str\n                    .parse::<i64>()\n                    .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\n                builder.push(format!(\n                    \" AND (f.created_at > ? OR (f.created_at = ? AND {relation_column} > ?))\",\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(timestamp);\n                builder.push_bind(timestamp);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::NameAsc => {\n                builder.push(\" AND (\");\n                builder.push(SORT_KEY_LOWER_EXPR);\n                builder.push(format!(\n                    \" > ? OR ({expr} = ? AND {relation_column} > ?))\",\n                    expr = SORT_KEY_LOWER_EXPR,\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::NameDesc => {\n                builder.push(\" AND (\");\n                builder.push(SORT_KEY_LOWER_EXPR);\n                builder.push(format!(\n                    \" < ? OR ({expr} = ? AND {relation_column} < ?))\",\n                    expr = SORT_KEY_LOWER_EXPR,\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(primary_str);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n        }\n    }\n\n    match sort {\n        FollowListSort::Recent => {\n            builder.push(format!(\n                \" ORDER BY f.created_at DESC, {relation_column} DESC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::Oldest => {\n            builder.push(format!(\n                \" ORDER BY f.created_at ASC, {relation_column} ASC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::NameAsc => {\n            builder.push(format!(\n                \" ORDER BY sort_key_normalized ASC, {relation_column} ASC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::NameDesc => {\n            builder.push(format!(\n                \" ORDER BY sort_key_normalized DESC, {relation_column} DESC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n    }\n    builder.push(\" LIMIT ?\");\n    builder.push_bind(fetch_limit as i64);\n\n    let rows = builder.build().fetch_all(repo.pool.get_pool()).await?;\n    let count_row = count_builder\n        .build()\n        .fetch_one(repo.pool.get_pool())\n        .await?;\n    let total_count: i64 = count_row.try_get(\"total_count\")?;\n    let total_count = total_count.max(0) as u64;\n\n    let mut users = Vec::with_capacity(rows.len().min(limit));\n    let mut next_cursor = None;\n\n    for (index, row) in rows.into_iter().enumerate() {\n        if index >= limit {\n            let relation_pubkey: String = row.try_get(\"relation_pubkey\")?;\n            let primary_value = match sort {\n                FollowListSort::Recent | FollowListSort::Oldest => {\n                    let timestamp: i64 = row.try_get(\"relation_created_at\")?;\n                    timestamp.to_string()\n                }\n                FollowListSort::NameAsc | FollowListSort::NameDesc => {\n                    row.try_get::<String, _>(\"sort_key_normalized\")?\n                }\n            };\n            next_cursor = Some(encode_follow_cursor(sort, &primary_value, &relation_pubkey));\n            break;\n        }\n        users.push(map_user_row(&row)?);\n    }\n\n    let has_more = next_cursor.is_some();\n\n    Ok(UserCursorPage {\n        users,\n        next_cursor,\n        has_more,\n        total_count,\n    })\n}\n\n#[async_trait]\nimpl UserRepository for SqliteRepository {\n    async fn create_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(INSERT_USER)\n            .bind(user.npub())\n            .bind(user.pubkey())\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(if user.public_profile { 1 } else { 0 })\n            .bind(if user.show_online_status { 1 } else { 0 })\n            .bind(user.created_at.timestamp_millis())\n            .bind(user.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_NPUB)\n            .bind(npub)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_PUBKEY)\n            .bind(pubkey)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\n        if query.trim().is_empty() {\n            return Ok(vec![]);\n        }\n\n        let rows = sqlx::query(SEARCH_USERS)\n            .bind(query)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut users = Vec::with_capacity(rows.len());\n        for row in rows {\n            users.push(map_user_row(&row)?);\n        }\n\n        Ok(users)\n    }\n\n    async fn update_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(UPDATE_USER)\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(if user.public_profile { 1 } else { 0 })\n            .bind(if user.show_online_status { 1 } else { 0 })\n            .bind(user.updated_at.timestamp_millis())\n            .bind(user.npub())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\n        sqlx::query(DELETE_USER)\n            .bind(npub)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_followers_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        query_follow_relation(\n            self,\n            npub,\n            cursor,\n            limit,\n            sort,\n            search,\n            FollowQueryDescriptor {\n                join_expr: \"f.follower_pubkey\",\n                filter_column: \"f.followed_pubkey\",\n                relation_column: \"f.follower_pubkey\",\n            },\n        )\n        .await\n    }\n\n    async fn get_following_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        query_follow_relation(\n            self,\n            npub,\n            cursor,\n            limit,\n            sort,\n            search,\n            FollowQueryDescriptor {\n                join_expr: \"f.followed_pubkey\",\n                filter_column: \"f.follower_pubkey\",\n                relation_column: \"f.followed_pubkey\",\n            },\n        )\n        .await\n    }\n\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let result = sqlx::query(UPSERT_FOLLOW_RELATION)\n            .bind(follower_pubkey)\n            .bind(followed_pubkey)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected() > 0)\n    }\n\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let result = sqlx::query(DELETE_FOLLOW_RELATION)\n            .bind(follower_pubkey)\n            .bind(followed_pubkey)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected() > 0)\n    }\n\n    async fn list_following_pubkeys(&self, follower_pubkey: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWING_PUBKEYS)\n            .bind(follower_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut result = Vec::with_capacity(rows.len());\n        for row in rows {\n            result.push(row.try_get::<String, _>(\"followed_pubkey\")?);\n        }\n        Ok(result)\n    }\n\n    async fn list_follower_pubkeys(&self, followed_pubkey: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWER_PUBKEYS)\n            .bind(followed_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut result = Vec::with_capacity(rows.len());\n        for row in rows {\n            result.push(row.try_get::<String, _>(\"follower_pubkey\")?);\n        }\n        Ok(result)\n    }\n}\n","traces":[{"line":17,"address":[13733544,13733120],"length":1,"stats":{"Line":0}},{"line":18,"address":[13638406],"length":1,"stats":{"Line":0}},{"line":19,"address":[13533917,13533994],"length":1,"stats":{"Line":0}},{"line":22,"address":[13639085,13637136,13638916],"length":1,"stats":{"Line":0}},{"line":26,"address":[13733607],"length":1,"stats":{"Line":0}},{"line":27,"address":[13602093,13602306],"length":1,"stats":{"Line":0}},{"line":29,"address":[13604014,13602275,13604000],"length":1,"stats":{"Line":0}},{"line":30,"address":[13638984],"length":1,"stats":{"Line":0}},{"line":31,"address":[13733968],"length":1,"stats":{"Line":0}},{"line":33,"address":[13534795,13534948,13534572],"length":1,"stats":{"Line":0}},{"line":35,"address":[21297566,21297552,21296133],"length":1,"stats":{"Line":0}},{"line":36,"address":[13633781,13633928,13634114],"length":1,"stats":{"Line":0}},{"line":38,"address":[13597278,13595971,13597264],"length":1,"stats":{"Line":0}},{"line":39,"address":[13639572,13639724,13639890],"length":1,"stats":{"Line":0}},{"line":40,"address":[23922393],"length":1,"stats":{"Line":0}},{"line":41,"address":[13597360,13596163,13597374],"length":1,"stats":{"Line":0}},{"line":42,"address":[13638148,13639070,13638534,13638309],"length":1,"stats":{"Line":0}},{"line":43,"address":[13536624,13536642,13535606],"length":1,"stats":{"Line":0}},{"line":44,"address":[13634534,13634672],"length":1,"stats":{"Line":0}},{"line":45,"address":[13735115,13735362],"length":1,"stats":{"Line":0}},{"line":47,"address":[13735156,13735056],"length":1,"stats":{"Line":0}},{"line":56,"address":[13604544],"length":1,"stats":{"Line":0}},{"line":65,"address":[13640252,13640433],"length":1,"stats":{"Line":0}},{"line":66,"address":[13636590,13636500],"length":1,"stats":{"Line":0}},{"line":67,"address":[13736932,13747440,13747462],"length":1,"stats":{"Line":0}},{"line":69,"address":[13537809,13537666],"length":1,"stats":{"Line":0}},{"line":80,"address":[13531226],"length":1,"stats":{"Line":0}},{"line":82,"address":[13531252],"length":1,"stats":{"Line":0}},{"line":90,"address":[13538570],"length":1,"stats":{"Line":0}},{"line":92,"address":[21299812],"length":1,"stats":{"Line":0}},{"line":93,"address":[13531780,13531715],"length":1,"stats":{"Line":0}},{"line":94,"address":[13531880,13531991,13532134,13532190],"length":1,"stats":{"Line":0}},{"line":95,"address":[13532214],"length":1,"stats":{"Line":0}},{"line":96,"address":[13643771],"length":1,"stats":{"Line":0}},{"line":97,"address":[13638218],"length":1,"stats":{"Line":0}},{"line":98,"address":[21300513],"length":1,"stats":{"Line":0}},{"line":99,"address":[13600183],"length":1,"stats":{"Line":0}},{"line":100,"address":[13607165],"length":1,"stats":{"Line":0}},{"line":104,"address":[13638417,13637662,13641314],"length":1,"stats":{"Line":0}},{"line":105,"address":[13644033,13644113,13644346,13646944],"length":1,"stats":{"Line":0}},{"line":106,"address":[13638715],"length":1,"stats":{"Line":0}},{"line":108,"address":[13601495,13600743,13600945,13601163],"length":1,"stats":{"Line":0}},{"line":110,"address":[13526523,13534437,13534416],"length":1,"stats":{"Line":0}},{"line":111,"address":[13601200,13601067],"length":1,"stats":{"Line":0}},{"line":115,"address":[13608263],"length":1,"stats":{"Line":0}},{"line":116,"address":[13739849],"length":1,"stats":{"Line":0}},{"line":117,"address":[13526803],"length":1,"stats":{"Line":0}},{"line":120,"address":[13644473,13645449,13645231,13645762],"length":1,"stats":{"Line":0}},{"line":122,"address":[21302089,21309509,21309488],"length":1,"stats":{"Line":0}},{"line":123,"address":[13540958,13540825],"length":1,"stats":{"Line":0}},{"line":127,"address":[13740405],"length":1,"stats":{"Line":0}},{"line":128,"address":[13541127],"length":1,"stats":{"Line":0}},{"line":129,"address":[13534177],"length":1,"stats":{"Line":0}},{"line":132,"address":[13526211],"length":1,"stats":{"Line":0}},{"line":133,"address":[13541368],"length":1,"stats":{"Line":0}},{"line":134,"address":[13534430],"length":1,"stats":{"Line":0}},{"line":139,"address":[13640572],"length":1,"stats":{"Line":0}},{"line":140,"address":[21302920],"length":1,"stats":{"Line":0}},{"line":141,"address":[13541780],"length":1,"stats":{"Line":0}},{"line":144,"address":[13540012],"length":1,"stats":{"Line":0}},{"line":145,"address":[13644741],"length":1,"stats":{"Line":0}},{"line":146,"address":[13640843],"length":1,"stats":{"Line":0}},{"line":151,"address":[13609881],"length":1,"stats":{"Line":0}},{"line":152,"address":[13535221],"length":1,"stats":{"Line":0}},{"line":153,"address":[13528511],"length":1,"stats":{"Line":0}},{"line":158,"address":[13638482],"length":1,"stats":{"Line":0}},{"line":160,"address":[13542625,13542421],"length":1,"stats":{"Line":0}},{"line":166,"address":[13647000,13647323],"length":1,"stats":{"Line":0}},{"line":172,"address":[13641871,13641467],"length":1,"stats":{"Line":0}},{"line":178,"address":[13603891,13603406],"length":1,"stats":{"Line":0}},{"line":184,"address":[13542754],"length":1,"stats":{"Line":0}},{"line":185,"address":[13646079],"length":1,"stats":{"Line":0}},{"line":187,"address":[11549410],"length":1,"stats":{"Line":0}},{"line":188,"address":[13643293,13643517,13643643,13643175,13643859,13642939,13646944],"length":1,"stats":{"Line":0}},{"line":190,"address":[13643210,13643058,13643101,13643355],"length":1,"stats":{"Line":0}},{"line":191,"address":[11667720],"length":1,"stats":{"Line":0}},{"line":192,"address":[23932065,23932163,23931905,23934945],"length":1,"stats":{"Line":0}},{"line":193,"address":[13649712,13649602],"length":1,"stats":{"Line":0}},{"line":195,"address":[13649720],"length":1,"stats":{"Line":0}},{"line":196,"address":[13644244],"length":1,"stats":{"Line":0}},{"line":198,"address":[21306648,21306524,21306866,21306799],"length":1,"stats":{"Line":0}},{"line":199,"address":[13538754],"length":1,"stats":{"Line":0}},{"line":200,"address":[21307367,21309038,21306990,21307518],"length":1,"stats":{"Line":0}},{"line":201,"address":[13546277],"length":1,"stats":{"Line":0}},{"line":203,"address":[13645699,13645569,13645331,13645456],"length":1,"stats":{"Line":0}},{"line":204,"address":[13532838,13532947],"length":1,"stats":{"Line":0}},{"line":207,"address":[13645370,13645723,13646761],"length":1,"stats":{"Line":0}},{"line":210,"address":[13649979,13649589],"length":1,"stats":{"Line":0}},{"line":213,"address":[13745059,13745172,13745439],"length":1,"stats":{"Line":0}},{"line":216,"address":[21308615],"length":1,"stats":{"Line":0}},{"line":218,"address":[13746817],"length":1,"stats":{"Line":0}},{"line":219,"address":[13650321],"length":1,"stats":{"Line":0}},{"line":220,"address":[13615233],"length":1,"stats":{"Line":0}},{"line":228,"address":[13632330,13632176,13633669,13632211,13633783,13634152,13632442],"length":1,"stats":{"Line":9}},{"line":229,"address":[13640490,13640123,13640560,13639938,13639978,13640902,13639863,13639807,13641000,13639675,13639589,13641181,13639523,13640047,13640243,13640372],"length":1,"stats":{"Line":24}},{"line":230,"address":[13625837,13625794,13626977,13625950],"length":1,"stats":{"Line":4}},{"line":231,"address":[13707602,13708465,13707486],"length":1,"stats":{"Line":4}},{"line":232,"address":[13839162],"length":1,"stats":{"Line":2}},{"line":233,"address":[13742805],"length":1,"stats":{"Line":2}},{"line":234,"address":[13707725],"length":1,"stats":{"Line":1}},{"line":235,"address":[13742885],"length":1,"stats":{"Line":1}},{"line":236,"address":[13633105,13633181],"length":1,"stats":{"Line":4}},{"line":237,"address":[13744418,13744806,13744693,13745211],"length":1,"stats":{"Line":2}},{"line":238,"address":[21401628,21401510,21401870],"length":1,"stats":{"Line":4}},{"line":239,"address":[13743308,13743405,13743493],"length":1,"stats":{"Line":2}},{"line":240,"address":[13701623,13700165,13701419,13701965,13701365,13701782],"length":1,"stats":{"Line":9}},{"line":242,"address":[13743974],"length":1,"stats":{"Line":3}},{"line":245,"address":[13641232,13641494,13642684,13641267,13641955,13641382],"length":1,"stats":{"Line":0}},{"line":246,"address":[13841528,13841812,13841420,13842433,13841089,13840990,13840911,13841194],"length":1,"stats":{"Line":0}},{"line":247,"address":[13740654,13740609],"length":1,"stats":{"Line":0}},{"line":248,"address":[21402934,21403149,21403028,21402846],"length":1,"stats":{"Line":0}},{"line":249,"address":[11994484],"length":1,"stats":{"Line":0}},{"line":251,"address":[13642418],"length":1,"stats":{"Line":0}},{"line":252,"address":[13703885,13703415,13703521],"length":1,"stats":{"Line":0}},{"line":253,"address":[13635561],"length":1,"stats":{"Line":0}},{"line":257,"address":[13636195,13636160,13636310,13636422,13636883,13637612],"length":1,"stats":{"Line":0}},{"line":258,"address":[13748209,13748110,13749553,13748648,13748031,13748314,13748540,13748932],"length":1,"stats":{"Line":0}},{"line":259,"address":[13746449,13746494],"length":1,"stats":{"Line":0}},{"line":260,"address":[13748365,13748062,13748150,13748244],"length":1,"stats":{"Line":0}},{"line":261,"address":[11978100],"length":1,"stats":{"Line":0}},{"line":263,"address":[13843634],"length":1,"stats":{"Line":0}},{"line":264,"address":[21405703,21405809,21406173],"length":1,"stats":{"Line":0}},{"line":265,"address":[13630681],"length":1,"stats":{"Line":0}},{"line":269,"address":[13638064,13638306,13638910,13638980,13638099,13640031,13638194],"length":1,"stats":{"Line":12}},{"line":270,"address":[13631649],"length":1,"stats":{"Line":3}},{"line":271,"address":[24064480,24064113],"length":1,"stats":{"Line":0}},{"line":274,"address":[13645810,13645705,13645571,13645470,13646100,13647378,13646198,13646404],"length":1,"stats":{"Line":14}},{"line":275,"address":[13744502],"length":1,"stats":{"Line":3}},{"line":276,"address":[13706467],"length":1,"stats":{"Line":3}},{"line":277,"address":[13706475,13706355,13706696,13706572],"length":1,"stats":{"Line":6}},{"line":278,"address":[11415844],"length":1,"stats":{"Line":10}},{"line":280,"address":[13714092,13714247],"length":1,"stats":{"Line":3}},{"line":281,"address":[13749393,13749639,13749504,13749687],"length":1,"stats":{"Line":6}},{"line":282,"address":[13633296,13633079],"length":1,"stats":{"Line":2}},{"line":285,"address":[13633109],"length":1,"stats":{"Line":2}},{"line":288,"address":[13634877,13633667,13634817,13635247,13633632,13633770,13633882],"length":1,"stats":{"Line":0}},{"line":289,"address":[21409082,21409042,21409519,21409997,21410095,21410276,21409122,21409387,21409707,21409637,21409267,21408963,21409191],"length":1,"stats":{"Line":0}},{"line":290,"address":[13746757],"length":1,"stats":{"Line":0}},{"line":291,"address":[13708685],"length":1,"stats":{"Line":0}},{"line":292,"address":[21409109],"length":1,"stats":{"Line":0}},{"line":293,"address":[13847245],"length":1,"stats":{"Line":0}},{"line":294,"address":[21409225,21409301],"length":1,"stats":{"Line":0}},{"line":295,"address":[13752621,13752734,13752306,13753143],"length":1,"stats":{"Line":0}},{"line":296,"address":[13709418,13709054,13709175],"length":1,"stats":{"Line":0}},{"line":297,"address":[13634599,13634696,13634785],"length":1,"stats":{"Line":0}},{"line":298,"address":[11886612],"length":1,"stats":{"Line":0}},{"line":300,"address":[13648973],"length":1,"stats":{"Line":0}},{"line":303,"address":[13642128,13642163,13642779,13642356,13642250,13643158],"length":1,"stats":{"Line":0}},{"line":304,"address":[13748950,13749131,13748556,13748457,13748381,13748626,13748852],"length":1,"stats":{"Line":0}},{"line":305,"address":[13848857,13848812],"length":1,"stats":{"Line":0}},{"line":306,"address":[13635973,13635708,13635793,13635887],"length":1,"stats":{"Line":0}},{"line":307,"address":[19661476],"length":1,"stats":{"Line":0}},{"line":309,"address":[13710932],"length":1,"stats":{"Line":0}},{"line":312,"address":[13755439,13754997,13754768,13755020,13754806,13754908,13755739],"length":1,"stats":{"Line":0}},{"line":322,"address":[13749645],"length":1,"stats":{"Line":0}},{"line":327,"address":[13636954],"length":1,"stats":{"Line":0}},{"line":333,"address":[13637127,13636647,13637359,13637073,13637183],"length":1,"stats":{"Line":0}},{"line":336,"address":[13754112,13754364,13754341,13754252,13754150,13755083,13754783],"length":1,"stats":{"Line":0}},{"line":346,"address":[13750637],"length":1,"stats":{"Line":0}},{"line":351,"address":[13756234],"length":1,"stats":{"Line":0}},{"line":357,"address":[13750823,13750343,13750879,13750769,13751055],"length":1,"stats":{"Line":0}},{"line":360,"address":[12945439],"length":1,"stats":{"Line":5}},{"line":365,"address":[13639085,13639683,13638797,13638873,13639590,13639015,13639311,13639409,13638913],"length":1,"stats":{"Line":7}},{"line":366,"address":[13638860],"length":1,"stats":{"Line":1}},{"line":367,"address":[13720420,13720465],"length":1,"stats":{"Line":2}},{"line":368,"address":[21414112,21413929,21413804,21414026],"length":1,"stats":{"Line":2}},{"line":369,"address":[12015972],"length":1,"stats":{"Line":4}},{"line":371,"address":[13714111,13714220],"length":1,"stats":{"Line":2}},{"line":374,"address":[13646602,13646708,13647174,13646515,13647694,13646480],"length":1,"stats":{"Line":0}},{"line":379,"address":[13646889,13647101,13647327,13646813,13647699,13647606,13647031,13647425,13646929],"length":1,"stats":{"Line":0}},{"line":380,"address":[13853164],"length":1,"stats":{"Line":0}},{"line":381,"address":[13853249,13853204],"length":1,"stats":{"Line":0}},{"line":382,"address":[13758348,13758570,13758473,13758656],"length":1,"stats":{"Line":0}},{"line":383,"address":[11917524],"length":1,"stats":{"Line":0}},{"line":385,"address":[24072816,24072921],"length":1,"stats":{"Line":0}},{"line":388,"address":[12945641],"length":1,"stats":{"Line":5}},{"line":389,"address":[13641269,13641876,13641447,13642081,13641348,13643068,13641552,13641778],"length":1,"stats":{"Line":6}},{"line":390,"address":[13754039,13754084],"length":1,"stats":{"Line":2}},{"line":391,"address":[13716074,13715980,13715892,13716195],"length":1,"stats":{"Line":2}},{"line":392,"address":[13716171,13716082,13715677,13716625,13716418,13716258],"length":1,"stats":{"Line":4}},{"line":394,"address":[13723683,13723530],"length":1,"stats":{"Line":2}},{"line":395,"address":[13760588,13760723,13760477,13760771],"length":1,"stats":{"Line":4}},{"line":396,"address":[13761032,13760803],"length":1,"stats":{"Line":2}},{"line":398,"address":[13642557],"length":1,"stats":{"Line":1}},{"line":401,"address":[13644839,13643107,13643072,13643769,13643202,13643308],"length":1,"stats":{"Line":5}},{"line":402,"address":[13756400,13756295,13757916,13756117,13756929,13756626,13756196,13756724],"length":1,"stats":{"Line":6}},{"line":403,"address":[13760164,13760119],"length":1,"stats":{"Line":2}},{"line":404,"address":[13756330,13756148,13756451,13756236],"length":1,"stats":{"Line":2}},{"line":405,"address":[13643634,13643810,13643970,13644177,13643229,13643723],"length":1,"stats":{"Line":4}},{"line":407,"address":[13725674,13725827],"length":1,"stats":{"Line":2}},{"line":408,"address":[13761084,13760973,13761267,13761219],"length":1,"stats":{"Line":4}},{"line":409,"address":[13763176,13762947],"length":1,"stats":{"Line":2}},{"line":411,"address":[21419677],"length":1,"stats":{"Line":1}}],"covered":50,"coverable":193},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","subscription_state_repository.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{Row, SqlitePool, sqlite::SqliteRow};\n\n#[derive(Clone)]\npub struct SqliteSubscriptionStateRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteSubscriptionStateRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &SqlitePool {\n        self.pool.get_pool()\n    }\n\n    fn row_to_record(row: SqliteRow) -> Result<SubscriptionRecord, AppError> {\n        let target_value: String = row.get(\"target\");\n        let target_type: String = row.get(\"target_type\");\n        let status: String = row.get(\"status\");\n        let last_synced_at: Option<i64> = row.get(\"last_synced_at\");\n        let last_attempt_at: Option<i64> = row.get(\"last_attempt_at\");\n        let failure_count: i64 = row.get(\"failure_count\");\n        let error_message: Option<String> = row.get(\"error_message\");\n\n        let target = SubscriptionTarget::from_parts(&target_type, target_value)?;\n        let status = SubscriptionStatus::parse(&status)?;\n\n        Ok(SubscriptionRecord {\n            target,\n            status,\n            last_synced_at,\n            last_attempt_at,\n            failure_count,\n            error_message,\n        })\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateRepository for SqliteSubscriptionStateRepository {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError> {\n        let (target_type, target_value) = record.target.as_parts();\n        let now_ms = Utc::now().timestamp_millis();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO nostr_subscriptions (\n                target,\n                target_type,\n                status,\n                last_synced_at,\n                last_attempt_at,\n                failure_count,\n                error_message,\n                created_at,\n                updated_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?8)\n            ON CONFLICT(target, target_type) DO UPDATE SET\n                status = excluded.status,\n                last_synced_at = excluded.last_synced_at,\n                last_attempt_at = excluded.last_attempt_at,\n                failure_count = excluded.failure_count,\n                error_message = excluded.error_message,\n                updated_at = excluded.updated_at\n            \"#,\n        )\n        .bind(target_value)\n        .bind(target_type)\n        .bind(record.status.as_str())\n        .bind(record.last_synced_at)\n        .bind(record.last_attempt_at)\n        .bind(record.failure_count)\n        .bind(record.error_message.clone())\n        .bind(now_ms)\n        .execute(self.pool())\n        .await?;\n\n        self.find(&record.target)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Subscription record missing after upsert\".into()))\n    }\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError> {\n        let (target_type, target_value) = target.as_parts();\n\n        let row = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE target_type = ?1 AND target = ?2\n            \"#,\n        )\n        .bind(target_type)\n        .bind(target_value)\n        .fetch_optional(self.pool())\n        .await?;\n\n        match row {\n            Some(row) => Ok(Some(Self::row_to_record(row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError> {\n        sqlx::query(\n            r#\"\n            UPDATE nostr_subscriptions\n            SET status = 'needs_resync',\n                updated_at = ?1,\n                error_message = NULL\n            WHERE status = 'subscribed'\n            \"#,\n        )\n        .bind(updated_at_ms)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE status IN ('pending', 'needs_resync')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            ORDER BY target_type ASC, target ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n}\n","traces":[{"line":17,"address":[16080944],"length":1,"stats":{"Line":1}},{"line":21,"address":[15986176],"length":1,"stats":{"Line":1}},{"line":22,"address":[15980597],"length":1,"stats":{"Line":1}},{"line":25,"address":[15876361,15874688,15876269],"length":1,"stats":{"Line":2}},{"line":26,"address":[15868018,15867926],"length":1,"stats":{"Line":4}},{"line":27,"address":[15984666],"length":1,"stats":{"Line":2}},{"line":28,"address":[15942699],"length":1,"stats":{"Line":2}},{"line":29,"address":[15986479,15986575],"length":1,"stats":{"Line":4}},{"line":30,"address":[15949839],"length":1,"stats":{"Line":2}},{"line":31,"address":[15875190],"length":1,"stats":{"Line":2}},{"line":32,"address":[17050643],"length":1,"stats":{"Line":2}},{"line":34,"address":[15985145,15985216,15986134,15985428],"length":1,"stats":{"Line":4}},{"line":35,"address":[15985558,15985962,15985407],"length":1,"stats":{"Line":2}},{"line":37,"address":[23644079],"length":1,"stats":{"Line":1}},{"line":38,"address":[15943631],"length":1,"stats":{"Line":1}},{"line":43,"address":[23644047],"length":1,"stats":{"Line":1}},{"line":50,"address":[16047876,16047964,16049439,16047920,16048087,16049386,16048226,16050595],"length":1,"stats":{"Line":7}},{"line":51,"address":[16004638],"length":1,"stats":{"Line":1}},{"line":52,"address":[16046801],"length":1,"stats":{"Line":1}},{"line":77,"address":[17234861],"length":1,"stats":{"Line":1}},{"line":78,"address":[16143560,16143320,16143437,16144201],"length":1,"stats":{"Line":2}},{"line":79,"address":[16005088],"length":1,"stats":{"Line":1}},{"line":80,"address":[15930578],"length":1,"stats":{"Line":1}},{"line":81,"address":[15937409,15937452],"length":1,"stats":{"Line":2}},{"line":82,"address":[16143748,16143872,16143615,16144179],"length":1,"stats":{"Line":2}},{"line":83,"address":[16047510],"length":1,"stats":{"Line":1}},{"line":84,"address":[16144148,16144052,16143950,16143907],"length":1,"stats":{"Line":2}},{"line":85,"address":[17235525,17235488,17236003,17235659,17234338,17235814],"length":1,"stats":{"Line":6}},{"line":87,"address":[23706482,23706801,23706642,23706979,23707223,23707288],"length":1,"stats":{"Line":7}},{"line":88,"address":[11870210],"length":1,"stats":{"Line":7}},{"line":89,"address":[15932320,15932334],"length":1,"stats":{"Line":0}},{"line":92,"address":[16046038,16045319,16045219,16045184,16045431,16045134,16046748],"length":1,"stats":{"Line":7}},{"line":96,"address":[23707808],"length":1,"stats":{"Line":1}},{"line":106,"address":[15939873],"length":1,"stats":{"Line":1}},{"line":107,"address":[23708073,23707951,23708166,23708288],"length":1,"stats":{"Line":2}},{"line":108,"address":[16050930,16051575,16052110,16051663,16051486,16051823],"length":1,"stats":{"Line":6}},{"line":110,"address":[15947551],"length":1,"stats":{"Line":2}},{"line":111,"address":[16046813,16046651],"length":1,"stats":{"Line":3}},{"line":112,"address":[16046611],"length":1,"stats":{"Line":2}},{"line":116,"address":[16147642,16147470,16147748,16147555,16147520,16148181,16148559],"length":1,"stats":{"Line":10}},{"line":126,"address":[15948663],"length":1,"stats":{"Line":2}},{"line":127,"address":[16047615,16047791,16047705,16047538],"length":1,"stats":{"Line":4}},{"line":128,"address":[11996340],"length":1,"stats":{"Line":8}},{"line":130,"address":[16016973],"length":1,"stats":{"Line":2}},{"line":133,"address":[16150024,16148940,16149358,16148834,16148665,16150059,16148704,16148739],"length":1,"stats":{"Line":5}},{"line":142,"address":[16052644,16052904,16052692,16052782],"length":1,"stats":{"Line":2}},{"line":143,"address":[11989108],"length":1,"stats":{"Line":4}},{"line":145,"address":[16053504,16053315],"length":1,"stats":{"Line":2}},{"line":148,"address":[16012286,16011632,16012952,16011762,16011868,16011667,16012987,16011593],"length":1,"stats":{"Line":5}},{"line":156,"address":[15944244,15944334,15944456,15944196],"length":1,"stats":{"Line":2}},{"line":157,"address":[11982788],"length":1,"stats":{"Line":4}},{"line":159,"address":[15944867,15945056],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":52},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","event_manager_gateway.rs"],"content":"use crate::application::ports::event_gateway::EventGateway;\r\n#[cfg(test)]\r\nuse crate::application::ports::key_manager::KeyPair;\r\nuse crate::application::shared::mappers::{domain_event_to_nostr_event, profile_metadata_to_nostr};\r\nuse crate::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\r\nuse crate::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\r\nuse crate::domain::value_objects::{EventId, TopicId};\r\nuse crate::infrastructure::event::manager_handle::EventManagerHandle;\r\nuse crate::infrastructure::event::metrics::{self, GatewayMetricKind};\r\nuse crate::infrastructure::p2p::metrics as p2p_metrics;\r\nuse crate::shared::{AppError, ValidationFailureKind};\r\nuse async_trait::async_trait;\r\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId};\r\nuse once_cell::sync::Lazy;\r\nuse serde::Serialize;\r\nuse std::collections::HashMap;\r\nuse std::sync::{Arc, Mutex};\r\nuse std::time::{Duration, Instant};\r\nuse tauri::{AppHandle, Emitter};\r\nuse tokio::sync::RwLock;\r\nuse tracing::error;\r\n\r\npub struct LegacyEventManagerGateway {\r\n    manager: Arc<dyn EventManagerHandle>,\r\n    app_handle: Arc<RwLock<Option<AppHandle>>>,\r\n}\r\n\r\nconst VALIDATION_LOG_WINDOW: Duration = Duration::from_secs(60);\r\nconst VALIDATION_WARN_THRESHOLD: u32 = 3;\r\n\r\nstruct ValidationLogWindow {\r\n    window_start: Instant,\r\n    count: u32,\r\n}\r\n\r\nstatic VALIDATION_LOG_WINDOWS: Lazy<Mutex<HashMap<ValidationFailureKind, ValidationLogWindow>>> =\r\n    Lazy::new(|| Mutex::new(HashMap::new()));\r\n\r\n#[derive(Debug, Clone, Serialize)]\r\nstruct FrontendEventPayload {\r\n    id: String,\r\n    author: String,\r\n    content: String,\r\n    created_at: u64,\r\n    kind: u32,\r\n    tags: Vec<Vec<String>>,\r\n}\r\n\r\nimpl From<&NostrEvent> for FrontendEventPayload {\r\n    fn from(event: &NostrEvent) -> Self {\r\n        Self {\r\n            id: event.id.to_string(),\r\n            author: event.pubkey.to_string(),\r\n            content: event.content.clone(),\r\n            created_at: event.created_at.as_secs(),\n            kind: event.kind.as_u16() as u32,\r\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::event_topic_store::EventTopicStore;\r\n    use crate::domain::entities::EventKind;\r\n    use crate::domain::entities::event_gateway::EventTag;\r\n    use crate::domain::value_objects::EventId;\r\n    use crate::infrastructure::event::manager_handle::LegacyEventManagerHandle;\r\n    use crate::infrastructure::event::metrics;\r\n    use crate::infrastructure::p2p::GossipService;\r\n    use anyhow::{Result as AnyResult, anyhow};\r\n    use chrono::Utc;\r\n    use nostr_sdk::Timestamp;\r\n    use nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata};\r\n\r\n    #[derive(Default)]\r\n    struct TestEventManagerHandle {\r\n        fail_handle_event: bool,\r\n        fail_publish_text: bool,\r\n    }\r\n\r\n    impl TestEventManagerHandle {\r\n        fn with_handle_failure() -> Self {\r\n            Self {\r\n                fail_handle_event: true,\r\n                fail_publish_text: false,\r\n            }\r\n        }\r\n\r\n        fn with_publish_failure() -> Self {\r\n            Self {\r\n                fail_handle_event: false,\r\n                fail_publish_text: true,\r\n            }\r\n        }\r\n    }\r\n\r\n    #[async_trait]\r\n    impl EventManagerHandle for TestEventManagerHandle {\r\n        async fn set_gossip_service(&self, _: Arc<dyn GossipService>) {}\r\n\r\n        async fn set_event_topic_store(&self, _: Arc<dyn EventTopicStore>) {}\r\n\r\n        async fn set_default_p2p_topic_id(&self, _: &str) {}\r\n\r\n        async fn set_default_p2p_topics(&self, _: Vec<String>) {}\r\n\r\n        async fn list_default_p2p_topics(&self) -> Vec<String> {\r\n            vec![]\r\n        }\r\n\r\n        async fn handle_p2p_event(&self, _: NostrEvent) -> AnyResult<()> {\r\n            if self.fail_handle_event {\r\n                Err(anyhow!(\"forced incoming failure\"))\r\n            } else {\r\n                Ok(())\r\n            }\r\n        }\r\n\r\n        async fn publish_text_note(&self, _: &str) -> AnyResult<NostrEventId> {\r\n            if self.fail_publish_text {\r\n                Err(anyhow!(\"forced publish failure\"))\r\n            } else {\r\n                Ok(sample_nostr_event_id('1'))\r\n            }\r\n        }\r\n\r\n        async fn publish_topic_post(\n            &self,\n            _: &str,\n            _: &str,\n            _: Option<NostrEventId>,\n            _: Option<&str>,\n            _: Option<i64>,\n        ) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('2'))\n        }\n\r\n        async fn publish_repost(&self, _: &NostrEventId) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('4'))\r\n        }\r\n\r\n        async fn publish_event(&self, _: NostrEvent) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('6'))\r\n        }\r\n\r\n        async fn send_reaction(&self, _: &NostrEventId, _: &str) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('3'))\r\n        }\r\n\r\n        async fn update_metadata(&self, _: Metadata) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('4'))\r\n        }\r\n\r\n        async fn delete_events(\r\n            &self,\r\n            _: Vec<NostrEventId>,\r\n            _: Option<String>,\r\n        ) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('5'))\r\n        }\r\n\r\n        async fn disconnect(&self) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_public_key(&self) -> Option<nostr_sdk::prelude::PublicKey> {\r\n            None\r\n        }\r\n\r\n        async fn subscribe_to_topic(&self, _: &str, _: Option<Timestamp>) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn subscribe_to_user(\r\n            &self,\r\n            _: nostr_sdk::prelude::PublicKey,\r\n            _: Option<Timestamp>,\r\n        ) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn register_event_callback(&self, _: Arc<dyn Fn(NostrEvent) + Send + Sync>) {}\r\n\r\n        async fn initialize_with_keypair(&self, _: KeyPair) -> anyhow::Result<()> {\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    fn sample_nostr_event_id(ch: char) -> NostrEventId {\r\n        let hex: String = std::iter::repeat(ch).take(64).collect();\r\n        NostrEventId::from_hex(&hex).expect(\"valid nostr id\")\r\n    }\r\n\r\n    fn repeating_hex(ch: char, len: usize) -> String {\r\n        std::iter::repeat(ch).take(len).collect()\r\n    }\r\n\r\n    fn sample_domain_event() -> DomainEvent {\r\n        let event_id = EventId::from_hex(&repeating_hex('a', 64)).expect(\"valid event id\");\r\n        let public_key = PublicKey::from_hex_str(&repeating_hex('b', 64)).expect(\"valid pubkey\");\r\n        let tags = vec![\r\n            EventTag::new(\"p\", vec![repeating_hex('c', 64)]).expect(\"valid p tag\"),\r\n            EventTag::new(\"t\", vec![\"sample\".to_string()]).expect(\"valid t tag\"),\r\n        ];\r\n        DomainEvent::new(\r\n            event_id,\r\n            public_key,\r\n            EventKind::TextNote,\r\n            Utc::now(),\r\n            \"sample content\".to_string(),\r\n            tags,\r\n            repeating_hex('d', 128),\r\n        )\r\n        .expect(\"valid domain event\")\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn handle_incoming_event_without_app_handle_succeeds() {\r\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(LegacyEventManagerHandle::new());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        let event = sample_domain_event();\r\n\r\n        let result = gateway.handle_incoming_event(event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn frontend_payload_matches_nostr_event() {\r\n        let event = sample_domain_event();\r\n        let nostr_event = domain_event_to_nostr_event(&event).expect(\"domain to nostr\");\r\n        let payload = FrontendEventPayload::from(&nostr_event);\r\n\r\n        assert_eq!(payload.id, nostr_event.id.to_string());\r\n        assert_eq!(payload.author, nostr_event.pubkey.to_string());\r\n        assert_eq!(payload.content, nostr_event.content);\r\n        assert_eq!(payload.kind, nostr_event.kind.as_u16() as u32);\r\n        assert_eq!(payload.tags.len(), nostr_event.tags.len());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_incoming_success() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(TestEventManagerHandle::default());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        gateway\r\n            .handle_incoming_event(sample_domain_event())\r\n            .await\r\n            .expect(\"incoming event succeeds\");\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(snapshot.incoming.total, before.incoming.total + 1);\r\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_incoming_failure() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> =\r\n            Arc::new(TestEventManagerHandle::with_handle_failure());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        let result = gateway.handle_incoming_event(sample_domain_event()).await;\r\n        assert!(result.is_err());\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures + 1);\r\n        assert_eq!(snapshot.incoming.total, before.incoming.total);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_publish_failure() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> =\r\n            Arc::new(TestEventManagerHandle::with_publish_failure());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n\r\n        let result = gateway.publish_text_note(\"metrics-check\").await;\r\n        assert!(result.is_err());\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(\r\n            snapshot.publish_text_note.failures,\r\n            before.publish_text_note.failures + 1\r\n        );\r\n        assert_eq!(\r\n            snapshot.publish_text_note.total,\r\n            before.publish_text_note.total\r\n        );\r\n    }\r\n}\r\n\r\nimpl LegacyEventManagerGateway {\r\n    pub fn new(manager: Arc<dyn EventManagerHandle>) -> Self {\r\n        Self {\r\n            manager,\r\n            app_handle: Arc::new(RwLock::new(None)),\r\n        }\r\n    }\r\n\r\n    fn to_nostr_event_id(event_id: &EventId) -> Result<NostrEventId, AppError> {\r\n        NostrEventId::from_hex(event_id.as_str())\r\n            .map_err(|err| AppError::NostrError(err.to_string()))\r\n    }\r\n\r\n    fn to_domain_event_id(event_id: NostrEventId) -> Result<EventId, AppError> {\r\n        EventId::from_hex(&event_id.to_hex()).map_err(|err| {\r\n            AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Invalid event ID returned: {err}\"),\r\n            )\r\n        })\r\n    }\r\n\r\n    fn to_domain_public_key(pk: nostr_sdk::prelude::PublicKey) -> Result<PublicKey, AppError> {\r\n        PublicKey::from_hex_str(&pk.to_hex()).map_err(|err| {\r\n            AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Invalid public key: {err}\"),\r\n            )\r\n        })\r\n    }\r\n\r\n    pub async fn set_app_handle(&self, handle: AppHandle) {\r\n        let mut guard = self.app_handle.write().await;\r\n        *guard = Some(handle);\r\n    }\r\n\r\n    async fn emit_frontend_event(&self, event: &NostrEvent) {\r\n        let handle = self.app_handle.read().await.clone();\r\n        if let Some(handle) = handle {\r\n            let payload = FrontendEventPayload::from(event);\r\n\r\n            if let Err(err) = handle.emit(\"nostr://event/p2p\", payload) {\r\n                error!(\"Failed to emit nostr event to frontend: {}\", err);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn record_p2p_broadcast_metrics<T>(result: Result<T, AppError>) -> Result<T, AppError> {\r\n    match result {\r\n        Ok(value) => {\r\n            p2p_metrics::record_broadcast_success();\r\n            Ok(value)\r\n        }\r\n        Err(err) => {\r\n            p2p_metrics::record_broadcast_failure();\r\n            Err(err)\r\n        }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl EventGateway for LegacyEventManagerGateway {\r\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError> {\r\n        let result = metrics::record_outcome(\r\n            async {\r\n                let nostr_event = domain_event_to_nostr_event(&event)?;\r\n                self.manager\r\n                    .handle_p2p_event(nostr_event.clone())\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                self.emit_frontend_event(&nostr_event).await;\r\n                Ok(())\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Incoming,\r\n        );\r\n\r\n        match &result {\r\n            Ok(_) => {\r\n                p2p_metrics::record_receive_success();\r\n            }\r\n            Err(err) => {\r\n                if let Some(kind) = err.validation_kind() {\r\n                    p2p_metrics::record_receive_failure_with_reason(kind);\r\n                    log_validation_failure(&event, kind, err.validation_message());\r\n                } else {\r\n                    p2p_metrics::record_receive_failure();\r\n                }\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let event_id = self\r\n                    .manager\r\n                    .publish_text_note(content)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::PublishTextNote,\r\n        ))\r\n    }\r\n\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let reply_to_converted = if let Some(reply) = reply_to {\r\n                    Some(Self::to_nostr_event_id(reply)?)\r\n                } else {\r\n                    None\r\n                };\r\n\r\n                let event_id = self\n                    .manager\n                    .publish_topic_post(\n                        topic_id.as_str(),\n                        content.as_str(),\n                        reply_to_converted,\n                        scope,\n                        epoch,\n                    )\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::PublishTopicPost,\r\n        ))\r\n    }\r\n\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &EventId,\r\n        reaction: &ReactionValue,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_event_id = Self::to_nostr_event_id(target)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .send_reaction(&nostr_event_id, reaction.as_str())\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Reaction,\r\n        ))\r\n    }\r\n\r\n    async fn update_profile_metadata(\r\n        &self,\r\n        metadata: &ProfileMetadata,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_metadata = profile_metadata_to_nostr(metadata)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .update_metadata(nostr_metadata)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::MetadataUpdate,\r\n        ))\r\n    }\r\n\r\n    async fn delete_events(\r\n        &self,\r\n        targets: &[EventId],\r\n        reason: Option<&str>,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_ids = targets\r\n                    .iter()\r\n                    .map(Self::to_nostr_event_id)\r\n                    .collect::<Result<Vec<_>, _>>()?;\r\n                let event_id = self\r\n                    .manager\r\n                    .delete_events(nostr_ids, reason.map(|value| value.to_string()))\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::DeleteEvents,\r\n        ))\r\n    }\r\n\r\n    async fn publish_repost(&self, target: &EventId) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_id = Self::to_nostr_event_id(target)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .publish_repost(&nostr_id)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Repost,\r\n        ))\r\n    }\r\n\r\n    async fn disconnect(&self) -> Result<(), AppError> {\r\n        metrics::record_outcome(\r\n            self.manager\r\n                .disconnect()\r\n                .await\r\n                .map_err(|err| AppError::NostrError(err.to_string())),\r\n            GatewayMetricKind::Disconnect,\r\n        )\r\n    }\r\n\r\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError> {\r\n        let maybe_pk = self.manager.get_public_key().await;\r\n        maybe_pk.map(Self::to_domain_public_key).transpose()\r\n    }\r\n\r\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError> {\r\n        let topic_strings: Vec<String> = topics\r\n            .iter()\r\n            .map(|topic| topic.as_str().to_string())\r\n            .collect();\r\n        self.manager.set_default_p2p_topics(topic_strings).await;\r\n        Ok(())\r\n    }\r\n\r\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError> {\r\n        let topics = self.manager.list_default_p2p_topics().await;\r\n        topics\r\n            .into_iter()\r\n            .map(|t| {\r\n                TopicId::new(t).map_err(|err| {\r\n                    AppError::validation(\r\n                        ValidationFailureKind::Generic,\r\n                        format!(\"Invalid topic identifier returned: {err}\"),\r\n                    )\r\n                })\r\n            })\r\n            .collect()\r\n    }\r\n}\r\n\r\nfn log_validation_failure(event: &DomainEvent, kind: ValidationFailureKind, message: Option<&str>) {\r\n    if let Ok(mut map) = VALIDATION_LOG_WINDOWS.lock() {\r\n        let entry = map.entry(kind).or_insert(ValidationLogWindow {\r\n            window_start: Instant::now(),\r\n            count: 0,\r\n        });\r\n        if entry.window_start.elapsed() > VALIDATION_LOG_WINDOW {\r\n            entry.window_start = Instant::now();\r\n            entry.count = 0;\r\n        }\r\n        entry.count += 1;\r\n        let log_message = message.unwrap_or(\"\");\r\n        let event_kind = u32::from(event.kind);\r\n        let event_id = event.id.to_hex();\r\n        if entry.count <= VALIDATION_WARN_THRESHOLD {\r\n            tracing::warn!(\r\n                reason = %kind,\r\n                event_id = %event_id,\r\n                event_kind,\r\n                message = log_message,\r\n                \"dropped invalid nostr event\",\r\n            );\r\n        } else {\r\n            tracing::debug!(\r\n                reason = %kind,\r\n                event_id = %event_id,\r\n                event_kind,\r\n                message = log_message,\r\n                \"dropped invalid nostr event\",\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":37,"address":[22238114,22238096],"length":1,"stats":{"Line":0}},{"line":50,"address":[22238160,22238680],"length":1,"stats":{"Line":1}},{"line":52,"address":[20548302],"length":1,"stats":{"Line":1}},{"line":53,"address":[22281909],"length":1,"stats":{"Line":1}},{"line":54,"address":[20548387],"length":1,"stats":{"Line":1}},{"line":55,"address":[22163753],"length":1,"stats":{"Line":1}},{"line":56,"address":[22376890],"length":1,"stats":{"Line":1}},{"line":57,"address":[16418416,16418158,16418462],"length":1,"stats":{"Line":3}},{"line":300,"address":[22171179,22170992],"length":1,"stats":{"Line":1}},{"line":303,"address":[16418555,16418636],"length":1,"stats":{"Line":2}},{"line":307,"address":[22282720],"length":1,"stats":{"Line":0}},{"line":308,"address":[22171246],"length":1,"stats":{"Line":0}},{"line":309,"address":[22246032,22246050],"length":1,"stats":{"Line":0}},{"line":312,"address":[22281447,22281296],"length":1,"stats":{"Line":0}},{"line":313,"address":[16419355,16418984,16419053,16419136],"length":1,"stats":{"Line":0}},{"line":314,"address":[22281647],"length":1,"stats":{"Line":0}},{"line":315,"address":[22171637],"length":1,"stats":{"Line":0}},{"line":316,"address":[16419221,16419162],"length":1,"stats":{"Line":0}},{"line":321,"address":[22283527,22283376],"length":1,"stats":{"Line":0}},{"line":322,"address":[16419485,16419787,16419568,16419416],"length":1,"stats":{"Line":0}},{"line":323,"address":[22246959],"length":1,"stats":{"Line":0}},{"line":324,"address":[22246805],"length":1,"stats":{"Line":0}},{"line":325,"address":[22378421,22378362],"length":1,"stats":{"Line":0}},{"line":330,"address":[22284890,22284911,22283913,22283888,22284077,22284262,22283808,22283843],"length":1,"stats":{"Line":0}},{"line":331,"address":[20550536,20550425,20550468,20550646],"length":1,"stats":{"Line":0}},{"line":332,"address":[16420860,16420887,16420531],"length":1,"stats":{"Line":0}},{"line":335,"address":[20551518,20551668,20551467,20553952,20551280,20551343,20551312,20551293],"length":1,"stats":{"Line":4}},{"line":336,"address":[19412004],"length":1,"stats":{"Line":2}},{"line":337,"address":[22167550,22167645],"length":1,"stats":{"Line":2}},{"line":338,"address":[20552178],"length":1,"stats":{"Line":0}},{"line":340,"address":[22380766,22382489],"length":1,"stats":{"Line":0}},{"line":341,"address":[22284297,22284431,22181584,22181685,22182186],"length":1,"stats":{"Line":0}},{"line":347,"address":[22169568,22169805],"length":1,"stats":{"Line":1}},{"line":348,"address":[22382662],"length":1,"stats":{"Line":1}},{"line":349,"address":[22287903],"length":1,"stats":{"Line":0}},{"line":350,"address":[16423937],"length":1,"stats":{"Line":0}},{"line":351,"address":[22288020],"length":1,"stats":{"Line":0}},{"line":353,"address":[20554189],"length":1,"stats":{"Line":1}},{"line":354,"address":[16423979],"length":1,"stats":{"Line":1}},{"line":355,"address":[22244457],"length":1,"stats":{"Line":1}},{"line":362,"address":[22285505,22286103,22284963,22286290,22284751,22285199,22285072,22285234,22284928,22285611],"length":1,"stats":{"Line":4}},{"line":364,"address":[20658826,20658890,20659470,20657866,20658152,20658688,20657969,20658735,20659987],"length":1,"stats":{"Line":5}},{"line":365,"address":[22391275,22391591,22390960,22391100],"length":1,"stats":{"Line":2}},{"line":366,"address":[22486252,22486682,22486020,22486832,22486319,22486588],"length":1,"stats":{"Line":6}},{"line":367,"address":[22486215],"length":1,"stats":{"Line":1}},{"line":368,"address":[11933108],"length":1,"stats":{"Line":3}},{"line":369,"address":[22355232,22355682,22355664],"length":1,"stats":{"Line":3}},{"line":370,"address":[22392208,22391037,22392082,22391969],"length":1,"stats":{"Line":2}},{"line":371,"address":[16528402],"length":1,"stats":{"Line":1}},{"line":373,"address":[11829617],"length":1,"stats":{"Line":3}},{"line":374,"address":[22353608],"length":1,"stats":{"Line":1}},{"line":377,"address":[22353651],"length":1,"stats":{"Line":1}},{"line":379,"address":[22346748,22346837],"length":1,"stats":{"Line":2}},{"line":381,"address":[22485247],"length":1,"stats":{"Line":1}},{"line":382,"address":[22346965,22346775],"length":1,"stats":{"Line":2}},{"line":383,"address":[22385127],"length":1,"stats":{"Line":0}},{"line":384,"address":[22485520],"length":1,"stats":{"Line":0}},{"line":386,"address":[22272437,22272525],"length":1,"stats":{"Line":2}},{"line":391,"address":[22286007],"length":1,"stats":{"Line":1}},{"line":394,"address":[22387397,22387030,22387314,22387644,22387235,22387964,22387200,22387420],"length":1,"stats":{"Line":5}},{"line":395,"address":[22275176],"length":1,"stats":{"Line":1}},{"line":396,"address":[22282218,22282382,22281854,22282178,22281672,22282064,22281600,22282099,22282893],"length":1,"stats":{"Line":5}},{"line":397,"address":[22357080,22357350,22357546,22357627,22356885,22357021,22357252],"length":1,"stats":{"Line":7}},{"line":399,"address":[22350080],"length":1,"stats":{"Line":1}},{"line":400,"address":[22488493,22488601,22488702,22488645,22488852],"length":1,"stats":{"Line":3}},{"line":401,"address":[22388850,22388688,22388832],"length":1,"stats":{"Line":3}},{"line":402,"address":[22276060,22275929],"length":1,"stats":{"Line":0}},{"line":404,"address":[22349507,22349564,22349229,22349710,22349453],"length":1,"stats":{"Line":3}},{"line":405,"address":[22356688],"length":1,"stats":{"Line":1}},{"line":409,"address":[22290886,22290336,22291209,22290559,22290148,22290453,22290536,22290371],"length":1,"stats":{"Line":0}},{"line":417,"address":[22490437],"length":1,"stats":{"Line":0}},{"line":418,"address":[22358594,22359141,22358776,22358480,22360524,22360016,22359234,22358992,22359042],"length":1,"stats":{"Line":0}},{"line":419,"address":[22291344,22291469,22291424,22291713],"length":1,"stats":{"Line":0}},{"line":420,"address":[22277955,22278076,22277694,22277761],"length":1,"stats":{"Line":0}},{"line":422,"address":[22284485],"length":1,"stats":{"Line":0}},{"line":425,"address":[22394677,22395639,22395386,22395092,22395273,22395600,22395007],"length":1,"stats":{"Line":0}},{"line":428,"address":[22396449],"length":1,"stats":{"Line":0}},{"line":429,"address":[22285010],"length":1,"stats":{"Line":0}},{"line":430,"address":[22396577],"length":1,"stats":{"Line":0}},{"line":431,"address":[22491425,22491409],"length":1,"stats":{"Line":0}},{"line":432,"address":[22491421,22491432],"length":1,"stats":{"Line":0}},{"line":434,"address":[11370292],"length":1,"stats":{"Line":0}},{"line":435,"address":[16533328,16533346,16533216],"length":1,"stats":{"Line":0}},{"line":436,"address":[22278994,22278857],"length":1,"stats":{"Line":0}},{"line":438,"address":[22490173,22490119,22490376,22490230,22489792],"length":1,"stats":{"Line":0}},{"line":439,"address":[20663081],"length":1,"stats":{"Line":0}},{"line":443,"address":[22395852,22396492,22396083,22396048,22396162,22396245,22396812,22396268],"length":1,"stats":{"Line":0}},{"line":448,"address":[22354680],"length":1,"stats":{"Line":0}},{"line":449,"address":[22287014,22286512,22286584,22288165,22286766,22287099,22287139,22286976,22287666],"length":1,"stats":{"Line":0}},{"line":450,"address":[16535136,16534855,16534706,16534593],"length":1,"stats":{"Line":0}},{"line":451,"address":[16534822,16535089,16535030,16535323,16535641,16535680,16535427],"length":1,"stats":{"Line":0}},{"line":453,"address":[22493728],"length":1,"stats":{"Line":0}},{"line":454,"address":[11858596],"length":1,"stats":{"Line":0}},{"line":455,"address":[22281289,22281392,22281410],"length":1,"stats":{"Line":0}},{"line":456,"address":[22281371,22281234],"length":1,"stats":{"Line":0}},{"line":458,"address":[22354476,22354419,22354365,22354141,22354622],"length":1,"stats":{"Line":0}},{"line":459,"address":[16534384],"length":1,"stats":{"Line":0}},{"line":463,"address":[22281747,22281826,22281712,22281932,22282464,22282144,22281909,22281566],"length":1,"stats":{"Line":0}},{"line":467,"address":[22289164],"length":1,"stats":{"Line":0}},{"line":468,"address":[16536578,16536336,16537989,16536819,16536784,16536902,16536396,16536951,16537459],"length":1,"stats":{"Line":0}},{"line":469,"address":[20668019,20668166,20667877,20668431],"length":1,"stats":{"Line":0}},{"line":470,"address":[22396082,22396296,22396384,22395536,22395811,22395752,22395988],"length":1,"stats":{"Line":0}},{"line":472,"address":[20668289],"length":1,"stats":{"Line":0}},{"line":473,"address":[11934916],"length":1,"stats":{"Line":0}},{"line":474,"address":[22283728,22283544,22283746],"length":1,"stats":{"Line":0}},{"line":475,"address":[22365009],"length":1,"stats":{"Line":0}},{"line":477,"address":[20667181,20667405,20667492,20667634,20667439],"length":1,"stats":{"Line":0}},{"line":478,"address":[22356964],"length":1,"stats":{"Line":0}},{"line":482,"address":[22497232,22497007,22497267,22497429,22497709,22498029,22497452,22497346],"length":1,"stats":{"Line":0}},{"line":487,"address":[20669941],"length":1,"stats":{"Line":0}},{"line":488,"address":[16538889,16539071,16539280,16539318,16539434,16538805,16540212,16540240,16539486],"length":1,"stats":{"Line":0}},{"line":489,"address":[22402141,22402557,22401713,22401879],"length":1,"stats":{"Line":0}},{"line":492,"address":[22299213],"length":1,"stats":{"Line":0}},{"line":493,"address":[22292619,22292852,22292201,22293260,22292952,22292528,22293166],"length":1,"stats":{"Line":0}},{"line":495,"address":[16540180,16540838,16540100,16539907,16540816],"length":1,"stats":{"Line":0}},{"line":496,"address":[16540420,16540154,16540108,16539461,16540272],"length":1,"stats":{"Line":0}},{"line":497,"address":[22367854,22368080,22368098],"length":1,"stats":{"Line":0}},{"line":498,"address":[22398983],"length":1,"stats":{"Line":0}},{"line":500,"address":[11815844],"length":1,"stats":{"Line":0}},{"line":501,"address":[22284865],"length":1,"stats":{"Line":0}},{"line":505,"address":[22499809,22500035,22500197,22500114,22500000,22500432,22500220,22500752],"length":1,"stats":{"Line":0}},{"line":506,"address":[22294380],"length":1,"stats":{"Line":0}},{"line":507,"address":[22399952,22400435,22400194,22400508,22401450,22400400,22400548,22400012,22400961],"length":1,"stats":{"Line":0}},{"line":508,"address":[22500853,22501091,22500960,22501282],"length":1,"stats":{"Line":0}},{"line":509,"address":[22295174,22294773,22295486,22295525,22294898,22295272,22294957],"length":1,"stats":{"Line":0}},{"line":511,"address":[22288105],"length":1,"stats":{"Line":0}},{"line":512,"address":[11853268],"length":1,"stats":{"Line":0}},{"line":513,"address":[22407074,22406942,22407056],"length":1,"stats":{"Line":0}},{"line":514,"address":[22405376,22405239],"length":1,"stats":{"Line":0}},{"line":516,"address":[11825828],"length":1,"stats":{"Line":0}},{"line":517,"address":[22287588],"length":1,"stats":{"Line":0}},{"line":521,"address":[22371033,22370611,22370576,22370457,22370802,22370779,22370690,22371343],"length":1,"stats":{"Line":0}},{"line":523,"address":[22303142,22303235,22303421,22303495],"length":1,"stats":{"Line":0}},{"line":525,"address":[22289197,22289444,22289488,22289545,22289681],"length":1,"stats":{"Line":0}},{"line":526,"address":[22296624,22296642],"length":1,"stats":{"Line":0}},{"line":527,"address":[22371274],"length":1,"stats":{"Line":0}},{"line":531,"address":[22406971,22407224,22406803,22406768,22406994,22407579,22406882,22406649],"length":1,"stats":{"Line":0}},{"line":532,"address":[11825716],"length":1,"stats":{"Line":0}},{"line":533,"address":[22407453],"length":1,"stats":{"Line":0}},{"line":536,"address":[22403683,22404060,22404577,22403968,22403824,22403862,22404810,22404086],"length":1,"stats":{"Line":0}},{"line":537,"address":[16545884,16545801],"length":1,"stats":{"Line":0}},{"line":539,"address":[16546448,16546483],"length":1,"stats":{"Line":0}},{"line":541,"address":[11938374],"length":1,"stats":{"Line":0}},{"line":542,"address":[22410348],"length":1,"stats":{"Line":0}},{"line":545,"address":[22306315,22306226,22305993,22306338,22306112,22306147,22306897,22306565],"length":1,"stats":{"Line":0}},{"line":546,"address":[12036516],"length":1,"stats":{"Line":0}},{"line":547,"address":[16547334],"length":1,"stats":{"Line":0}},{"line":549,"address":[22506224],"length":1,"stats":{"Line":0}},{"line":550,"address":[22409824,22409872,22410091],"length":1,"stats":{"Line":0}},{"line":551,"address":[22300191],"length":1,"stats":{"Line":0}},{"line":552,"address":[22411541],"length":1,"stats":{"Line":0}},{"line":553,"address":[22307077,22307018],"length":1,"stats":{"Line":0}},{"line":561,"address":[16429349,16425462,16424224],"length":1,"stats":{"Line":0}},{"line":562,"address":[22288273],"length":1,"stats":{"Line":0}},{"line":563,"address":[22183818,22183916,22183984],"length":1,"stats":{"Line":0}},{"line":564,"address":[22170183],"length":1,"stats":{"Line":0}},{"line":567,"address":[22286941,22287137],"length":1,"stats":{"Line":0}},{"line":568,"address":[22287075],"length":1,"stats":{"Line":0}},{"line":569,"address":[22283194],"length":1,"stats":{"Line":0}},{"line":571,"address":[22184171,22184290,22184327],"length":1,"stats":{"Line":0}},{"line":572,"address":[22252131,22252053],"length":1,"stats":{"Line":0}},{"line":573,"address":[22283331],"length":1,"stats":{"Line":0}},{"line":574,"address":[22283377],"length":1,"stats":{"Line":0}},{"line":575,"address":[22170700],"length":1,"stats":{"Line":0}},{"line":576,"address":[22410185,22287374,22410319,22289587],"length":1,"stats":{"Line":0}},{"line":584,"address":[22410815,22287456,22287800,22287346,22287936,22410681],"length":1,"stats":{"Line":0}}],"covered":43,"coverable":166},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","handler.rs"],"content":"use crate::infrastructure::database::connection_pool::ConnectionPool;\nuse anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, info};\n\n/// イベントコールバックの型エイリアス\ntype EventCallback = Arc<dyn Fn(Event) + Send + Sync>;\n\n/// Nostrイベントハンドラー\npub struct EventHandler {\n    event_callbacks: Arc<RwLock<Vec<EventCallback>>>,\n    connection_pool: Option<ConnectionPool>,\n}\n\nimpl EventHandler {\n    /// 新しいEventHandlerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            event_callbacks: Arc::new(RwLock::new(Vec::new())),\n            connection_pool: None,\n        }\n    }\n\n    /// データベースプールを設定\n    pub fn set_connection_pool(&mut self, pool: ConnectionPool) {\n        self.connection_pool = Some(pool);\n    }\n\n    pub async fn register_callback(&self, callback: EventCallback) {\n        let mut callbacks = self.event_callbacks.write().await;\n        callbacks.push(callback);\n    }\n\n    /// イベントを処理\n    pub async fn handle_event(&self, event: Event) -> Result<()> {\n        debug!(\"Handling event: {}\", event.id);\n\n        let callbacks = self.event_callbacks.read().await;\n        for callback in callbacks.iter() {\n            callback(event.clone());\n        }\n\n        // イベントの種類に応じた処理\n        match event.kind {\n            Kind::TextNote => {\n                self.handle_text_note(&event).await?;\n            }\n            Kind::Metadata => {\n                self.handle_metadata(&event).await?;\n            }\n            Kind::ContactList => {\n                self.handle_contact_list(&event).await?;\n            }\n            Kind::Reaction => {\n                self.handle_reaction(&event).await?;\n            }\n            _ => {\n                debug!(\"Unhandled event kind: {:?}\", event.kind);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// テキストノートイベントを処理\n    async fn handle_text_note(&self, event: &Event) -> Result<()> {\n        info!(\n            \"Received text note from {}: {}\",\n            event.pubkey, event.content\n        );\n\n        // データベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let event_id = event.id.to_string();\n            let public_key = event.pubkey.to_string();\n            let created_at = event.created_at.as_secs() as i64;\n            let kind = event.kind.as_u16() as i64;\n            let content = event.content.clone();\n            let tags = serde_json::to_string(&event.tags)?;\n            let signature = event.sig.to_string();\n            let saved_at = chrono::Utc::now().timestamp();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO events (event_id, public_key, created_at, kind, content, tags, sig, saved_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(event_id) DO NOTHING\n                \"#,\n                event_id,\n                public_key,\n                created_at,\n                kind,\n                content,\n                tags,\n                signature,\n                saved_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Text note saved to database: {}\", event.id);\n\n            // イベントのタグからトピックIDを抽出し、マッピングを保存（冪等）\n            // 対象: Hashtag(\"t\") と Custom(\"topic\")\n            for tag in event.tags.iter() {\n                if let Some(nostr_sdk::TagStandard::Hashtag(topic)) = tag.as_standardized() {\n                    let _ = sqlx::query(\n                        r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                    )\n                    .bind(event.id.to_string())\n                    .bind(topic)\n                    .bind(chrono::Utc::now().timestamp_millis())\n                    .execute(pool.get_pool())\n                    .await;\n                }\n                // カスタムタグ 'topic'\n                if tag.kind().to_string() == \"topic\" {\n                    if let Some(content) = tag.content() {\n                        let _ = sqlx::query(\n                            r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                        )\n                        .bind(event.id.to_string())\n                        .bind(content)\n                        .bind(chrono::Utc::now().timestamp_millis())\n                        .execute(pool.get_pool())\n                        .await;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// メタデータイベントを処理\n    async fn handle_metadata(&self, event: &Event) -> Result<()> {\n        info!(\"Received metadata update from {}\", event.pubkey);\n\n        // メタデータをパースしてデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let metadata: serde_json::Value = serde_json::from_str(&event.content)?;\n            let display_name = metadata\n                .get(\"name\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let about = metadata\n                .get(\"about\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let picture_url = metadata\n                .get(\"picture\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let banner_url = metadata\n                .get(\"banner\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let nip05 = metadata\n                .get(\"nip05\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let created_at = event.created_at.as_secs() as i64;\n            let updated_at = chrono::Utc::now().timestamp();\n            let public_key = event.pubkey.to_string();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO profiles (public_key, display_name, about, picture_url, banner_url, nip05, created_at, updated_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(public_key) DO UPDATE SET\n                    display_name = excluded.display_name,\n                    about = excluded.about,\n                    picture_url = excluded.picture_url,\n                    banner_url = excluded.banner_url,\n                    nip05 = excluded.nip05,\n                    updated_at = excluded.updated_at\n                \"#,\n                public_key,\n                display_name,\n                about,\n                picture_url,\n                banner_url,\n                nip05,\n                created_at,\n                updated_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Profile metadata saved to database for: {}\", event.pubkey);\n        }\n\n        Ok(())\n    }\n\n    /// コンタクトリストイベントを処理\n    async fn handle_contact_list(&self, event: &Event) -> Result<()> {\n        info!(\"Received contact list from {}\", event.pubkey);\n\n        // フォロー関係をデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            // 既存のフォロー関係を削除\n            let follower_pubkey = event.pubkey.to_string();\n            sqlx::query!(\n                r#\"DELETE FROM follows WHERE follower_pubkey = ?\"#,\n                follower_pubkey\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            // 新しいフォロー関係を追加\n            for tag in event.tags.iter() {\n                if let Some(TagStandard::PublicKey { public_key, .. }) = tag.as_standardized() {\n                    let followed_pubkey = public_key.to_string();\n                    let created_at = chrono::Utc::now().timestamp();\n                    sqlx::query!(\n                        r#\"\n                        INSERT INTO follows (follower_pubkey, followed_pubkey, created_at)\n                        VALUES (?1, ?2, ?3)\n                        ON CONFLICT(follower_pubkey, followed_pubkey) DO NOTHING\n                        \"#,\n                        follower_pubkey,\n                        followed_pubkey,\n                        created_at\n                    )\n                    .execute(pool.get_pool())\n                    .await?;\n                }\n            }\n\n            debug!(\n                \"Contact list processed and saved for: {}\",\n                event.pubkey.to_string()\n            );\n        }\n\n        Ok(())\n    }\n\n    /// リアクションイベントを処理\n    async fn handle_reaction(&self, event: &Event) -> Result<()> {\n        info!(\"Received reaction from {}: {}\", event.pubkey, event.content);\n\n        // リアクションをデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            if event.tags.is_empty() || event.content.is_empty() {\n                return Ok(());\n            }\n\n            let Some(first_tag) = event.tags.get(0) else {\n                return Ok(());\n            };\n            let Some(target_event_id) = first_tag.content() else {\n                return Ok(());\n            };\n\n            let reactor_pubkey = event.pubkey.to_string();\n            let reaction_content = event.content.clone();\n            let created_at = event.created_at.as_secs() as i64;\n            let updated_at = chrono::Utc::now().timestamp();\n            sqlx::query!(\n                r#\"\n                INSERT INTO reactions (target_event_id, reactor_pubkey, reaction_content, created_at, updated_at)\n                VALUES (?1, ?2, ?3, ?4, ?5)\n                ON CONFLICT(reactor_pubkey, target_event_id) DO UPDATE SET\n                    reaction_content = excluded.reaction_content,\n                    updated_at = excluded.updated_at\n                \"#,\n                target_event_id,\n                reactor_pubkey,\n                reaction_content,\n                created_at,\n                updated_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Reaction saved to database: {}\", event.id);\n        }\n\n        Ok(())\n    }\n}\n\nimpl Default for EventHandler {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[24260080],"length":1,"stats":{"Line":4}},{"line":21,"address":[16559700],"length":1,"stats":{"Line":4}},{"line":27,"address":[16597957,16597904],"length":1,"stats":{"Line":1}},{"line":28,"address":[24260195,24260260],"length":1,"stats":{"Line":2}},{"line":31,"address":[16567210,16567618,16567039,16567639,16566880,16566850,16566832,16566905],"length":1,"stats":{"Line":0}},{"line":32,"address":[16567126,16567242,16567066,16567023],"length":1,"stats":{"Line":0}},{"line":33,"address":[16492713,16492780],"length":1,"stats":{"Line":0}},{"line":37,"address":[16599156,16598960,16598915,16598880,16604110,16601051,16605569,16599006],"length":1,"stats":{"Line":8}},{"line":38,"address":[16493421,16646489,16493205,16646623,16493937],"length":1,"stats":{"Line":7}},{"line":40,"address":[24261458,24262085,24263355,24263210],"length":1,"stats":{"Line":4}},{"line":41,"address":[16607046,16606953,16607316],"length":1,"stats":{"Line":4}},{"line":42,"address":[16502804,16505061],"length":1,"stats":{"Line":0}},{"line":46,"address":[16488975],"length":1,"stats":{"Line":2}},{"line":47,"address":[16604429],"length":1,"stats":{"Line":2}},{"line":48,"address":[11519836],"length":1,"stats":{"Line":5}},{"line":50,"address":[16604801],"length":1,"stats":{"Line":0}},{"line":51,"address":[16570801,16573331,16568044,16573622,16570625],"length":1,"stats":{"Line":0}},{"line":53,"address":[16573965],"length":1,"stats":{"Line":0}},{"line":54,"address":[10803924],"length":1,"stats":{"Line":0}},{"line":56,"address":[24267769],"length":1,"stats":{"Line":0}},{"line":57,"address":[16605211,16605502,16599270,16602276,16605690,16601941],"length":1,"stats":{"Line":0}},{"line":60,"address":[16756841,16606316,16605714,16756975,16606836],"length":1,"stats":{"Line":0}},{"line":64,"address":[24265124],"length":1,"stats":{"Line":2}},{"line":68,"address":[16609712,16609693,16614295,16609680,16610031,16609946,16614368,16609743],"length":1,"stats":{"Line":8}},{"line":69,"address":[16647481,16500232,16647615,16500059,16500768],"length":1,"stats":{"Line":7}},{"line":75,"address":[24270145,24268904],"length":1,"stats":{"Line":3}},{"line":76,"address":[16708253],"length":1,"stats":{"Line":1}},{"line":77,"address":[16569821],"length":1,"stats":{"Line":1}},{"line":78,"address":[16495308,16495395],"length":1,"stats":{"Line":2}},{"line":79,"address":[24270383],"length":1,"stats":{"Line":1}},{"line":80,"address":[16495464],"length":1,"stats":{"Line":1}},{"line":81,"address":[16509334,16509255,16511454,16509500],"length":1,"stats":{"Line":2}},{"line":82,"address":[16612343],"length":1,"stats":{"Line":1}},{"line":83,"address":[16614121,16614188],"length":1,"stats":{"Line":2}},{"line":85,"address":[24270944,24273152,24272529,24272459,24272640,24272982,24274899,24271238,24272857],"length":1,"stats":{"Line":6}},{"line":100,"address":[16511383,16509979,16511163,16511278],"length":1,"stats":{"Line":2}},{"line":101,"address":[16511888,16511286,16507096,16511520,16511689,16511346],"length":1,"stats":{"Line":4}},{"line":103,"address":[16711292,16711172,16856057,16711809,16856191],"length":1,"stats":{"Line":3}},{"line":107,"address":[16615332,16617119,16616468,16617182],"length":1,"stats":{"Line":4}},{"line":108,"address":[16514452,16514565,16514325],"length":1,"stats":{"Line":3}},{"line":112,"address":[16507809,16507645,16507688,16508605],"length":1,"stats":{"Line":2}},{"line":113,"address":[16613807],"length":1,"stats":{"Line":1}},{"line":114,"address":[24276225,24276036,24276087,24276768],"length":1,"stats":{"Line":2}},{"line":115,"address":[16714446,16714337,16714140,16714832],"length":1,"stats":{"Line":2}},{"line":116,"address":[11577992],"length":1,"stats":{"Line":5}},{"line":119,"address":[16613476,16614547],"length":1,"stats":{"Line":2}},{"line":120,"address":[16502070],"length":1,"stats":{"Line":0}},{"line":124,"address":[16614938,16614981,16615107,16615588],"length":1,"stats":{"Line":0}},{"line":125,"address":[24277457],"length":1,"stats":{"Line":0}},{"line":126,"address":[17069106,17068755,17068704,17068893],"length":1,"stats":{"Line":0}},{"line":127,"address":[16502643,16502750,16502446,16502823],"length":1,"stats":{"Line":0}},{"line":128,"address":[17069029,17069069,17066697,17059762,17066464],"length":1,"stats":{"Line":0}},{"line":134,"address":[16611852],"length":1,"stats":{"Line":2}},{"line":138,"address":[16615831,16615648,16620719,16615679,16615616,16615629,16620605,16615874],"length":1,"stats":{"Line":0}},{"line":139,"address":[16643481,16643615,16503763,16503099,16503227],"length":1,"stats":{"Line":0}},{"line":142,"address":[16617550,16616411],"length":1,"stats":{"Line":0}},{"line":143,"address":[16617630,16620644,16617558,16617808],"length":1,"stats":{"Line":0}},{"line":144,"address":[16579653,16579797],"length":1,"stats":{"Line":0}},{"line":146,"address":[24285296,24285305],"length":1,"stats":{"Line":0}},{"line":148,"address":[16512154,16512055],"length":1,"stats":{"Line":0}},{"line":150,"address":[16510352,16510361],"length":1,"stats":{"Line":0}},{"line":152,"address":[16618140,16618239],"length":1,"stats":{"Line":0}},{"line":154,"address":[16584985,16584976],"length":1,"stats":{"Line":0}},{"line":156,"address":[16623889,16623988],"length":1,"stats":{"Line":0}},{"line":158,"address":[16524176,16524185],"length":1,"stats":{"Line":0}},{"line":160,"address":[16505865,16505766],"length":1,"stats":{"Line":0}},{"line":162,"address":[16524208,16524217],"length":1,"stats":{"Line":0}},{"line":164,"address":[16519787,16519694],"length":1,"stats":{"Line":0}},{"line":165,"address":[16519802],"length":1,"stats":{"Line":0}},{"line":166,"address":[16618833],"length":1,"stats":{"Line":0}},{"line":168,"address":[16720982,16723210,16720871,16721240,16720750,16719533,16721365,16721535,16719235],"length":1,"stats":{"Line":0}},{"line":189,"address":[16514394,16513202,16514497,16514653],"length":1,"stats":{"Line":0}},{"line":190,"address":[11575047],"length":1,"stats":{"Line":0}},{"line":192,"address":[16522775,16522267,16522147,16659663,16659529],"length":1,"stats":{"Line":0}},{"line":195,"address":[16623181],"length":1,"stats":{"Line":0}},{"line":199,"address":[16524240,16524303,16527020,16524468,16524532,16526989,16524272,16524253],"length":1,"stats":{"Line":0}},{"line":200,"address":[16524586,16524440,16660025,16660159,16525122],"length":1,"stats":{"Line":0}},{"line":203,"address":[17078658,17077498],"length":1,"stats":{"Line":0}},{"line":205,"address":[16519241],"length":1,"stats":{"Line":0}},{"line":206,"address":[16629239,16629878,16630346,16629145,16629658,16630497,16630050,16629776,16630169],"length":1,"stats":{"Line":0}},{"line":210,"address":[16594720,16594458,16594573,16594076],"length":1,"stats":{"Line":0}},{"line":211,"address":[11512511],"length":1,"stats":{"Line":0}},{"line":214,"address":[16631911,16632044,16632773,16632708],"length":1,"stats":{"Line":0}},{"line":215,"address":[16589093,16590922],"length":1,"stats":{"Line":0}},{"line":216,"address":[16629142],"length":1,"stats":{"Line":0}},{"line":217,"address":[16516461],"length":1,"stats":{"Line":0}},{"line":218,"address":[16531160,16527967,16528135,16531093,16531023,16527800,16530294,16530432],"length":1,"stats":{"Line":0}},{"line":228,"address":[16530951,16531058,16531128,16530392],"length":1,"stats":{"Line":0}},{"line":229,"address":[10879758],"length":1,"stats":{"Line":0}},{"line":233,"address":[16728685,16860729,16729031,16860863,16728103,16727598,16727529],"length":1,"stats":{"Line":0}},{"line":239,"address":[17078701],"length":1,"stats":{"Line":0}},{"line":243,"address":[24292511,24292480,24296486,24296388,24292663,24292448,24292706,24292461],"length":1,"stats":{"Line":0}},{"line":244,"address":[16760857,16630491,16631027,16630363,16760991],"length":1,"stats":{"Line":0}},{"line":247,"address":[16601028,16599787],"length":1,"stats":{"Line":0}},{"line":248,"address":[24294602,24294492,24294542],"length":1,"stats":{"Line":0}},{"line":249,"address":[16533362],"length":1,"stats":{"Line":0}},{"line":252,"address":[24294608],"length":1,"stats":{"Line":0}},{"line":253,"address":[16526531],"length":1,"stats":{"Line":0}},{"line":255,"address":[16632484,16632428],"length":1,"stats":{"Line":0}},{"line":256,"address":[17086053],"length":1,"stats":{"Line":0}},{"line":259,"address":[17086022],"length":1,"stats":{"Line":0}},{"line":260,"address":[17086070],"length":1,"stats":{"Line":0}},{"line":261,"address":[16520071,16519984],"length":1,"stats":{"Line":0}},{"line":262,"address":[16636723],"length":1,"stats":{"Line":0}},{"line":263,"address":[16639604,16638662,16639948,16640070,16640240,16639534,16639709,16641802,16638456],"length":1,"stats":{"Line":0}},{"line":277,"address":[16633985,16634084,16633035,16633882],"length":1,"stats":{"Line":0}},{"line":278,"address":[16535664,16535106,16531477,16535049,16535468,16535302],"length":1,"stats":{"Line":0}},{"line":280,"address":[16640284,16768191,16640164,16640789,16768057],"length":1,"stats":{"Line":0}},{"line":283,"address":[16601062],"length":1,"stats":{"Line":0}},{"line":288,"address":[16605104],"length":1,"stats":{"Line":0}},{"line":289,"address":[16636289],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":111},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","core.rs"],"content":"use crate::application::ports::{\n    event_topic_store::EventTopicStore,\n    key_manager::{KeyManager, KeyPair},\n};\nuse crate::application::shared::default_topics::DefaultTopicsRegistry;\nuse crate::application::shared::nostr::EventPublisher;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::infrastructure::event::{\n    handler::EventHandler, nostr_client_manager::NostrClientManager,\n};\nuse crate::infrastructure::p2p::GossipService;\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrイベントマネージャー - イベント処理の中心的な管理者\npub struct EventManager {\n    pub(crate) client_manager: Arc<RwLock<NostrClientManager>>,\n    pub(crate) event_handler: Arc<EventHandler>,\n    pub(crate) event_publisher: Arc<RwLock<EventPublisher>>,\n    pub(crate) default_topics: Arc<DefaultTopicsRegistry>,\n    is_initialized: Arc<RwLock<bool>>,\n    /// P2P配信用のGossipService（任意）\n    pub(crate) gossip_service: Arc<RwLock<Option<Arc<dyn GossipService>>>>,\n    /// 参照トピック解決用のEventTopicStore（任意）\n    pub(crate) event_topic_store: Arc<RwLock<Option<Arc<dyn EventTopicStore>>>>,\n}\n\nimpl EventManager {\n    /// 新しいEventManagerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(EventHandler::new()),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\n                DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            ])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_topic_store: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 新しいEventManagerインスタンスをConnectionPoolと共に作成\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        let mut event_handler = EventHandler::new();\n        event_handler.set_connection_pool(pool);\n\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(event_handler),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\n                DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            ])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_topic_store: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 既定の配信先トピックIDを設定\n    pub async fn set_default_p2p_topic_id(&self, topic_id: impl Into<String>) {\n        self.default_topics\n            .replace_with_single(topic_id.into())\n            .await;\n    }\n\n    /// 既定配信先トピックを一括設定（複数）\n    pub async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.default_topics.replace_all(topics).await;\n    }\n\n    /// 既定配信先トピックを追加\n    pub async fn add_default_p2p_topic(&self, topic_id: impl Into<String>) {\n        self.default_topics.add(topic_id.into()).await;\n    }\n\n    /// 既定配信先トピックを削除\n    pub async fn remove_default_p2p_topic(&self, topic_id: &str) {\n        self.default_topics.remove(topic_id).await;\n    }\n\n    /// 既定配信先トピック一覧を取得\n    pub async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.default_topics.list().await\n    }\n\n    pub async fn register_event_callback(&self, callback: Arc<dyn Fn(Event) + Send + Sync>) {\n        self.event_handler.register_callback(callback).await;\n    }\n\n    /// KeyManagerからの秘密鍵でマネージャーを初期化\n    pub async fn initialize_with_key_manager(\n        &self,\n        key_manager: &(dyn KeyManager + Send + Sync),\n    ) -> Result<()> {\n        let keypair = key_manager\n            .current_keypair()\n            .await\n            .map_err(|e| anyhow!(\"Failed to load current keypair: {e}\"))?;\n        self.initialize_with_keypair(&keypair).await\n    }\n\n    /// KeyPair を直接用いて EventManager を初期化\n    pub async fn initialize_with_keypair(&self, keypair: &KeyPair) -> Result<()> {\n        let secret_key = SecretKey::from_bech32(&keypair.nsec)\n            .map_err(|e| anyhow!(\"Invalid secret key: {e}\"))?;\n        let keys = Keys::new(secret_key);\n\n        // クライアントマネージャーを初期化\n        let mut client_manager = self.client_manager.write().await;\n        client_manager.init_with_keys(keys.secret_key()).await?;\n\n        // パブリッシャーに鍵を設定\n        let mut publisher = self.event_publisher.write().await;\n        publisher.set_keys(keys);\n\n        *self.is_initialized.write().await = true;\n\n        info!(\"EventManager initialized successfully\");\n        Ok(())\n    }\n\n    /// 特定のトピックをサブスクライブ\n    pub async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().hashtag(topic_id).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to topic: {}\", topic_id);\n        Ok(())\n    }\n\n    /// ユーザーの投稿をサブスクライブ\n    pub async fn subscribe_to_user(\n        &self,\n        pubkey: PublicKey,\n        since: Option<Timestamp>,\n    ) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().author(pubkey).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to user: {}\", pubkey);\n        Ok(())\n    }\n\n    /// 初期化状態を確認\n    pub(crate) async fn ensure_initialized(&self) -> Result<()> {\n        if !*self.is_initialized.read().await {\n            Err(anyhow!(\"EventManager not initialized\"))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// 公開鍵を取得\n    pub async fn get_public_key(&self) -> Option<PublicKey> {\n        let publisher = self.event_publisher.read().await;\n        if let Some(pk) = publisher.get_public_key() {\n            return Some(pk);\n        }\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.get_public_key()\n    }\n\n    /// 切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_manager = self.client_manager.read().await;\n        client_manager.disconnect().await?;\n        *self.is_initialized.write().await = false;\n        Ok(())\n    }\n}\n\nimpl Default for EventManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":34,"address":[15877335,15876384],"length":1,"stats":{"Line":1}},{"line":36,"address":[15987905],"length":1,"stats":{"Line":1}},{"line":37,"address":[15982393,15982465],"length":1,"stats":{"Line":5}},{"line":38,"address":[23644766,23644826],"length":1,"stats":{"Line":6}},{"line":39,"address":[15988284],"length":1,"stats":{"Line":3}},{"line":42,"address":[24708160,24708088],"length":1,"stats":{"Line":6}},{"line":43,"address":[24708185,24708283],"length":1,"stats":{"Line":4}},{"line":44,"address":[15951954,15951856],"length":1,"stats":{"Line":4}},{"line":49,"address":[15877360,15878501,15878529],"length":1,"stats":{"Line":1}},{"line":50,"address":[15987334,15987238],"length":1,"stats":{"Line":2}},{"line":51,"address":[24708668],"length":1,"stats":{"Line":1}},{"line":54,"address":[15987419],"length":1,"stats":{"Line":1}},{"line":55,"address":[15870940,15870860],"length":1,"stats":{"Line":2}},{"line":56,"address":[16084020,16084080],"length":1,"stats":{"Line":2}},{"line":57,"address":[15871154],"length":1,"stats":{"Line":1}},{"line":60,"address":[15987890,15987962],"length":1,"stats":{"Line":4}},{"line":61,"address":[24709357,24709259],"length":1,"stats":{"Line":4}},{"line":62,"address":[16084566,16084664],"length":1,"stats":{"Line":4}},{"line":67,"address":[15879025,15878578,15878795,15878560,15878633,15879247,15879268,15878608],"length":1,"stats":{"Line":0}},{"line":68,"address":[15885751,15885909,15885960],"length":1,"stats":{"Line":0}},{"line":69,"address":[15990394],"length":1,"stats":{"Line":0}},{"line":70,"address":[11847254],"length":1,"stats":{"Line":0}},{"line":74,"address":[16085793,16086272,16086021,16085632,16086251,16085657,16085584,16085592],"length":1,"stats":{"Line":8}},{"line":75,"address":[11567636],"length":1,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[15954768,15954786,15955009,15955381,15955163,15954816,15954969,15954841],"length":1,"stats":{"Line":4}},{"line":85,"address":[24712016,24712096,24711973,24712200],"length":1,"stats":{"Line":2}},{"line":89,"address":[23649022,23649162,23648899,23648848,23648864,23648856,23649459,23648985],"length":1,"stats":{"Line":4}},{"line":90,"address":[15986693,15986799,15986740,15986922],"length":1,"stats":{"Line":2}},{"line":93,"address":[15949307,15949161,15949503,15949746,15949088,15949725,15949106,15949136],"length":1,"stats":{"Line":0}},{"line":94,"address":[10944919],"length":1,"stats":{"Line":0}},{"line":98,"address":[16088272],"length":1,"stats":{"Line":4}},{"line":102,"address":[23650340,23651134,23650498,23650680,23650832,23651295],"length":1,"stats":{"Line":14}},{"line":104,"address":[15988239,15988113,15988296,15988195,15988504],"length":1,"stats":{"Line":11}},{"line":105,"address":[15883407,15882929,15883392],"length":1,"stats":{"Line":0}},{"line":106,"address":[15988817,15988128,15989089,15988933],"length":1,"stats":{"Line":6}},{"line":110,"address":[23652015,23653331,23651792,23651824,23651805,23651855,23652808,23652136],"length":1,"stats":{"Line":8}},{"line":111,"address":[16090298,16090876,16090562,16090081],"length":1,"stats":{"Line":4}},{"line":112,"address":[15877474,15881488,15881503],"length":1,"stats":{"Line":0}},{"line":113,"address":[15952174,15951992],"length":1,"stats":{"Line":6}},{"line":116,"address":[15994323,15994504,15993709,15994237],"length":1,"stats":{"Line":6}},{"line":117,"address":[11676203],"length":1,"stats":{"Line":6}},{"line":120,"address":[11564725],"length":1,"stats":{"Line":8}},{"line":121,"address":[15997567,15997646],"length":1,"stats":{"Line":8}},{"line":123,"address":[11564751],"length":1,"stats":{"Line":4}},{"line":125,"address":[16013183,15954546,15955098,16013049],"length":1,"stats":{"Line":8}},{"line":126,"address":[15894221],"length":1,"stats":{"Line":4}},{"line":130,"address":[15956413,15956288,15956669,15956316,15956584,15956804,15957799,15956352],"length":1,"stats":{"Line":4}},{"line":131,"address":[11653521],"length":1,"stats":{"Line":4}},{"line":133,"address":[23657620,23657529],"length":1,"stats":{"Line":0}},{"line":134,"address":[16095827,16096079],"length":1,"stats":{"Line":0}},{"line":135,"address":[15999602,15999438],"length":1,"stats":{"Line":0}},{"line":138,"address":[11649605],"length":1,"stats":{"Line":0}},{"line":139,"address":[15890271,15892579,15891022,15888848,15890360],"length":1,"stats":{"Line":0}},{"line":141,"address":[16152025,16097879,16097282,16097362,16152159],"length":1,"stats":{"Line":0}},{"line":142,"address":[24722834],"length":1,"stats":{"Line":0}},{"line":146,"address":[16004160],"length":1,"stats":{"Line":0}},{"line":151,"address":[15961368,15961987,15960748,15961043,15960812,15960917],"length":1,"stats":{"Line":0}},{"line":153,"address":[23661745,23661839],"length":1,"stats":{"Line":0}},{"line":154,"address":[23662234,23661973],"length":1,"stats":{"Line":0}},{"line":155,"address":[15999914,15999744],"length":1,"stats":{"Line":0}},{"line":158,"address":[11531995],"length":1,"stats":{"Line":0}},{"line":159,"address":[16005168,16004488,16006728,16002902,16004399],"length":1,"stats":{"Line":0}},{"line":161,"address":[16152655,16102169,16101652,16101572,16152521],"length":1,"stats":{"Line":0}},{"line":162,"address":[15889052],"length":1,"stats":{"Line":0}},{"line":166,"address":[23665973,23665193,23665457,23665168,23665316,23665160,23665152,23665279],"length":1,"stats":{"Line":8}},{"line":167,"address":[16008677,16008571,16008801,16009283,16008618],"length":1,"stats":{"Line":7}},{"line":168,"address":[15897636],"length":1,"stats":{"Line":1}},{"line":170,"address":[16003687],"length":1,"stats":{"Line":2}},{"line":175,"address":[16104112,16104088,16104315,16105132,16104147,16104080,16104456,16104248],"length":1,"stats":{"Line":4}},{"line":176,"address":[15972812,15972723,15972936,15972667],"length":1,"stats":{"Line":2}},{"line":177,"address":[16008293,16008361],"length":1,"stats":{"Line":2}},{"line":178,"address":[23666766],"length":1,"stats":{"Line":1}},{"line":180,"address":[16010134],"length":1,"stats":{"Line":1}},{"line":182,"address":[10886382],"length":1,"stats":{"Line":1}},{"line":183,"address":[15899156,15899085],"length":1,"stats":{"Line":2}},{"line":187,"address":[24730288,24730280,24730316,24730484,24731069,24730272,24730628,24730408],"length":1,"stats":{"Line":4}},{"line":188,"address":[11710017],"length":1,"stats":{"Line":2}},{"line":189,"address":[23668165,23668740,23668278,23668084,23668584,23667609],"length":1,"stats":{"Line":2}},{"line":190,"address":[23668628,23668552,23667627,23668835],"length":1,"stats":{"Line":2}},{"line":191,"address":[15900980],"length":1,"stats":{"Line":1}},{"line":196,"address":[16010880],"length":1,"stats":{"Line":0}},{"line":197,"address":[16012536],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","mod.rs"],"content":"mod core;\nmod p2p;\nmod publishing;\n\npub use core::EventManager;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","p2p.rs"],"content":"use std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse anyhow::{Result, anyhow};\r\nuse nostr_sdk::prelude::*;\r\nuse tracing::error;\r\n\r\nuse super::EventManager;\r\nuse crate::application::ports::event_topic_store::EventTopicStore;\r\nuse crate::application::shared::mappers::nostr_event_to_domain_event;\r\nuse crate::domain::p2p::user_topic_id;\r\nuse crate::infrastructure::p2p::GossipService;\r\n\r\nimpl EventManager {\r\n    /// GossipServiceを接続（P2P配信用）。未設定でも動作は継続。\r\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\r\n        let mut gs = self.gossip_service.write().await;\r\n        *gs = Some(gossip);\r\n    }\r\n\r\n    /// EventTopicStoreを接続（参照トピック解決用）。未設定でも動作は継続。\r\n    pub async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>) {\r\n        let mut r = self.event_topic_store.write().await;\r\n        *r = Some(store);\r\n    }\r\n\r\n    /// P2Pネットワークから受信したNostrイベントを処理\r\n    pub async fn handle_p2p_event(&self, event: Event) -> Result<()> {\r\n        if let Err(e) = self.event_handler.handle_event(event.clone()).await {\r\n            error!(\"Error handling P2P event: {}\", e);\r\n            return Err(e);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 複数トピックへ冪等Join + 重複排除つきでブロードキャスト\r\n    pub(crate) async fn broadcast_to_topics(\r\n        &self,\r\n        gossip: &Arc<dyn GossipService>,\r\n        topics: &[String],\r\n        nostr_event: &Event,\r\n    ) -> Result<()> {\r\n        let mut uniq: HashSet<String> = HashSet::new();\r\n        for t in topics {\r\n            if !t.is_empty() {\r\n                uniq.insert(t.clone());\r\n            }\r\n        }\r\n        if uniq.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        let domain_event =\r\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\r\n        for topic in uniq.into_iter() {\r\n            let _ = gossip.join_topic(&topic, vec![]).await;\r\n            if let Err(e) = gossip.broadcast(&topic, &domain_event).await {\r\n                error!(\"Failed to broadcast to topic {}: {}\", topic, e);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) async fn broadcast_to_topic(\r\n        &self,\r\n        gossip: &Arc<dyn GossipService>,\r\n        topic_id: &str,\r\n        nostr_event: &Event,\r\n    ) -> Result<()> {\r\n        let domain_event =\r\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\r\n        let _ = gossip.join_topic(topic_id, vec![]).await;\r\n        gossip\r\n            .broadcast(topic_id, &domain_event)\r\n            .await\r\n            .map_err(|e| anyhow::anyhow!(\"{}\", e))?;\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) async fn resolve_topics_for_referenced_event(\r\n        &self,\r\n        event_id: &str,\r\n    ) -> Option<Vec<String>> {\r\n        if let Some(store) = self.event_topic_store.read().await.as_ref().cloned() {\r\n            match store.get_event_topics(event_id).await {\r\n                Ok(v) if !v.is_empty() => return Some(v),\r\n                _ => {}\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    pub(crate) async fn default_topics_with_user_topic(&self) -> Vec<String> {\r\n        let mut topics = self.default_topics.snapshot().await;\r\n        if let Some(pk) = self.get_public_key().await {\r\n            topics.insert(user_topic_id(&pk.to_string()));\r\n        }\r\n        topics.into_iter().collect()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[16107344,16107362],"length":1,"stats":{"Line":12}},{"line":17,"address":[23935574,23935463,23935506,23935670],"length":1,"stats":{"Line":6}},{"line":18,"address":[15137543,15137253,15137570],"length":1,"stats":{"Line":3}},{"line":22,"address":[16007024,16007042],"length":1,"stats":{"Line":8}},{"line":23,"address":[15219335,15219558,15219382,15219442],"length":1,"stats":{"Line":4}},{"line":24,"address":[15250949,15251239,15251266],"length":1,"stats":{"Line":2}},{"line":28,"address":[15894368,15894403],"length":1,"stats":{"Line":8}},{"line":29,"address":[11831793],"length":1,"stats":{"Line":5}},{"line":30,"address":[15262601,15140614,15139971,15140170,15139638,15262735],"length":1,"stats":{"Line":0}},{"line":31,"address":[23938499],"length":1,"stats":{"Line":0}},{"line":34,"address":[15155463],"length":1,"stats":{"Line":2}},{"line":38,"address":[15901232],"length":1,"stats":{"Line":1}},{"line":44,"address":[15155739],"length":1,"stats":{"Line":1}},{"line":45,"address":[15216742,15216848,15216966],"length":1,"stats":{"Line":3}},{"line":46,"address":[15142398,15143055],"length":1,"stats":{"Line":2}},{"line":47,"address":[15224593],"length":1,"stats":{"Line":1}},{"line":50,"address":[23940358,23940280],"length":1,"stats":{"Line":2}},{"line":51,"address":[23940387],"length":1,"stats":{"Line":0}},{"line":54,"address":[22922015,22922000,22917412,22917911,22917448,22917722],"length":1,"stats":{"Line":2}},{"line":56,"address":[15255364,15255546,15258755,15258816],"length":1,"stats":{"Line":4}},{"line":57,"address":[15264568,15261464,15264436,15260323],"length":1,"stats":{"Line":3}},{"line":58,"address":[11767288],"length":1,"stats":{"Line":3}},{"line":59,"address":[15344617,15225710,15225377,15344751,15225909,15226330],"length":1,"stats":{"Line":0}},{"line":62,"address":[15152974],"length":1,"stats":{"Line":1}},{"line":65,"address":[24732240],"length":1,"stats":{"Line":1}},{"line":71,"address":[15261920,15260548,15261935,15260324,15260881,15260191],"length":1,"stats":{"Line":2}},{"line":73,"address":[11758628],"length":1,"stats":{"Line":2}},{"line":74,"address":[15223176,15223468,15223593,15223298,15223239,15223734],"length":1,"stats":{"Line":5}},{"line":75,"address":[22923603],"length":1,"stats":{"Line":1}},{"line":76,"address":[11751867],"length":1,"stats":{"Line":3}},{"line":77,"address":[22924102,22924495,22924480],"length":1,"stats":{"Line":0}},{"line":78,"address":[15155872],"length":1,"stats":{"Line":1}},{"line":81,"address":[23669568],"length":1,"stats":{"Line":0}},{"line":85,"address":[19560223],"length":1,"stats":{"Line":0}},{"line":86,"address":[15231474,15232154,15232271,15232445],"length":1,"stats":{"Line":0}},{"line":87,"address":[15225916,15225815],"length":1,"stats":{"Line":0}},{"line":91,"address":[15232413],"length":1,"stats":{"Line":0}},{"line":94,"address":[15151648,15151683,15151992,15151784,15151851,15152436],"length":1,"stats":{"Line":0}},{"line":95,"address":[11774959],"length":1,"stats":{"Line":0}},{"line":96,"address":[19549954],"length":1,"stats":{"Line":0}},{"line":97,"address":[22927679,22927803],"length":1,"stats":{"Line":0}},{"line":99,"address":[22927716,22927939],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":42},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","publishing.rs"],"content":"use std::collections::HashSet;\n\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse tracing::error;\n\nuse super::EventManager;\n\nimpl EventManager {\n    /// テキストノートを投稿\n    pub async fn publish_text_note(&self, content: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_text_note(content, vec![])?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = match client_manager.publish_event(event.clone()).await {\n            Ok(id) => id,\n            Err(e) => {\n                if std::env::var(\"KUKURI_ALLOW_NO_RELAY\")\n                    .map(|value| value == \"1\")\n                    .unwrap_or(false)\n                    && e.to_string().contains(\"no relays specified\")\n                {\n                    event.id\n                } else {\n                    return Err(e);\n                }\n            }\n        };\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast to P2P (text_note): {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// トピック投稿を作成・送信\n    pub async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_topic_post(topic_id, content, reply_to, scope, epoch)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = match client_manager.publish_event(event.clone()).await {\n            Ok(id) => id,\n            Err(e) => {\n                let msg = e.to_string();\n                let allow_no_relay = std::env::var(\"KUKURI_ALLOW_NO_RELAY\")\n                    .map(|value| value == \"1\")\n                    .unwrap_or(false)\n                    || msg.contains(\"no relays specified\")\n                    || msg.contains(\"not connected to any relays\");\n\n                if allow_no_relay {\n                    tracing::warn!(\n                        target: \"event_manager\",\n                        \"publish_event skipped (no relay connected): {msg}\"\n                    );\n                    event.id\n                } else {\n                    return Err(e);\n                }\n            }\n        };\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            if let Err(e) = self.broadcast_to_topic(&gossip, topic_id, &event).await {\n                error!(\"Failed to broadcast to P2P (topic {}): {}\", topic_id, e);\n            }\n        }\n\n        if let Some(store) = self.event_topic_store.read().await.as_ref().cloned() {\n            tracing::debug!(\n                target: \"event_manager\",\n                \"adding event_topic mapping for {}\",\n                event.id.to_hex()\n            );\n            let _ = store.add_event_topic(&event.id.to_string(), topic_id).await;\n        }\n\n        Ok(event_id)\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(&self, event_id: &EventId, reaction: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_reaction(event_id, reaction)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topic_list = if let Some(resolved_topics) = self\n                .resolve_topics_for_referenced_event(&event_id.to_hex())\n                .await\n            {\n                if resolved_topics.is_empty() {\n                    self.default_topics_with_user_topic().await\n                } else {\n                    let unique: HashSet<_> = resolved_topics.into_iter().collect();\n                    unique.into_iter().collect()\n                }\n            } else {\n                self.default_topics_with_user_topic().await\n            };\n\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topic_list, &event).await {\n                error!(\"Failed to broadcast reaction to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n\n    /// 投稿を再配信 (Repost) する\n    pub async fn publish_repost(&self, target: &EventId) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_repost(target)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topic_list = if let Some(resolved_topics) = self\n                .resolve_topics_for_referenced_event(&target.to_hex())\n                .await\n            {\n                if resolved_topics.is_empty() {\n                    self.default_topics_with_user_topic().await\n                } else {\n                    let unique: HashSet<_> = resolved_topics.into_iter().collect();\n                    unique.into_iter().collect()\n                }\n            } else {\n                self.default_topics_with_user_topic().await\n            };\n\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topic_list, &event).await {\n                error!(\"Failed to broadcast repost to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n\n    /// 指定したイベントを削除するための削除イベントを発行\n    pub async fn delete_events(\n        &self,\n        target_ids: Vec<EventId>,\n        reason: Option<String>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n        if target_ids.is_empty() {\n            return Err(anyhow!(\"No event IDs provided\"));\n        }\n\n        let publisher = self.event_publisher.read().await;\n        let deletion_event = publisher.create_deletion(target_ids.clone(), reason.as_deref())?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let deletion_event_id = client_manager.publish_event(deletion_event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let mut topics: HashSet<String> = HashSet::new();\n            for event_id in &target_ids {\n                if let Some(resolved_topics) = self\n                    .resolve_topics_for_referenced_event(&event_id.to_hex())\n                    .await\n                {\n                    topics.extend(resolved_topics);\n                }\n            }\n\n            if topics.is_empty() {\n                topics.extend(self.default_topics_with_user_topic().await);\n            }\n\n            let topic_list: Vec<String> = topics.into_iter().collect();\n            if let Err(e) = self\n                .broadcast_to_topics(&gossip, &topic_list, &deletion_event)\n                .await\n            {\n                error!(\"Failed to broadcast deletion to P2P: {}\", e);\n            }\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    /// リポスト（ブースト）を送信\n    /// 任意のイベントを発行\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast generic event to P2P: {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(&self, metadata: Metadata) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_metadata(metadata)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast metadata to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n}\n","traces":[{"line":11,"address":[15901456,15901474],"length":1,"stats":{"Line":4}},{"line":12,"address":[19673862,19674118,19674583,19674791,19673929,19674244],"length":1,"stats":{"Line":4}},{"line":14,"address":[19680734,19681329,19681643,19681462],"length":1,"stats":{"Line":0}},{"line":15,"address":[19688993,19688911,19689303,19689586],"length":1,"stats":{"Line":0}},{"line":16,"address":[19682279],"length":1,"stats":{"Line":0}},{"line":18,"address":[11882628],"length":1,"stats":{"Line":0}},{"line":19,"address":[11248497],"length":1,"stats":{"Line":0}},{"line":20,"address":[19676629],"length":1,"stats":{"Line":0}},{"line":21,"address":[19789467],"length":1,"stats":{"Line":0}},{"line":22,"address":[19793545,19793419],"length":1,"stats":{"Line":0}},{"line":23,"address":[19755561,19755552],"length":1,"stats":{"Line":0}},{"line":25,"address":[19758546],"length":1,"stats":{"Line":0}},{"line":27,"address":[19751903],"length":1,"stats":{"Line":0}},{"line":29,"address":[19795261],"length":1,"stats":{"Line":0}},{"line":33,"address":[20990242],"length":1,"stats":{"Line":0}},{"line":35,"address":[13928317,13931667,13932196],"length":1,"stats":{"Line":0}},{"line":36,"address":[11877119],"length":1,"stats":{"Line":0}},{"line":37,"address":[11977512],"length":1,"stats":{"Line":0}},{"line":38,"address":[21172927,21172793,20993136,20992538,20992635],"length":1,"stats":{"Line":0}},{"line":42,"address":[19759828],"length":1,"stats":{"Line":0}},{"line":46,"address":[16011360],"length":1,"stats":{"Line":2}},{"line":54,"address":[11252578],"length":1,"stats":{"Line":6}},{"line":56,"address":[19688919,19689231,19688302,19689049],"length":1,"stats":{"Line":2}},{"line":57,"address":[19764350,19764260,19764994,19764707],"length":1,"stats":{"Line":2}},{"line":58,"address":[19757731],"length":1,"stats":{"Line":1}},{"line":60,"address":[11884628],"length":1,"stats":{"Line":2}},{"line":61,"address":[19796581,19794264,19796499],"length":1,"stats":{"Line":2}},{"line":62,"address":[19684286],"length":1,"stats":{"Line":0}},{"line":63,"address":[19691204],"length":1,"stats":{"Line":1}},{"line":64,"address":[19698204],"length":1,"stats":{"Line":1}},{"line":65,"address":[19698395,19698494,19698323],"length":1,"stats":{"Line":3}},{"line":66,"address":[21006249,21006240],"length":1,"stats":{"Line":2}},{"line":68,"address":[19691547,19691495],"length":1,"stats":{"Line":0}},{"line":69,"address":[13939118],"length":1,"stats":{"Line":0}},{"line":71,"address":[19797603],"length":1,"stats":{"Line":1}},{"line":72,"address":[19691903,19691744,19900159,19692440,19900025],"length":1,"stats":{"Line":3}},{"line":76,"address":[19760183],"length":1,"stats":{"Line":1}},{"line":78,"address":[13939213],"length":1,"stats":{"Line":0}},{"line":82,"address":[19691255],"length":1,"stats":{"Line":1}},{"line":84,"address":[11886326],"length":1,"stats":{"Line":2}},{"line":85,"address":[11768063],"length":1,"stats":{"Line":2}},{"line":86,"address":[19800884,20006575,19800783,19801385,20006441],"length":1,"stats":{"Line":0}},{"line":90,"address":[11252704],"length":1,"stats":{"Line":3}},{"line":91,"address":[19766347,19766691],"length":1,"stats":{"Line":0}},{"line":96,"address":[19773974,19763164,19772667,19774392],"length":1,"stats":{"Line":3}},{"line":99,"address":[19767342],"length":1,"stats":{"Line":1}},{"line":103,"address":[19812047,19812402,19811820,19811728,19812258,19813040],"length":1,"stats":{"Line":0}},{"line":104,"address":[11757460],"length":1,"stats":{"Line":0}},{"line":106,"address":[11839006],"length":1,"stats":{"Line":0}},{"line":107,"address":[19769645,19770268,19769735,19769985],"length":1,"stats":{"Line":0}},{"line":108,"address":[19769937],"length":1,"stats":{"Line":0}},{"line":110,"address":[11240480],"length":1,"stats":{"Line":0}},{"line":111,"address":[19696078,19695996,19693852,19696620],"length":1,"stats":{"Line":0}},{"line":112,"address":[19703356],"length":1,"stats":{"Line":0}},{"line":114,"address":[19813946,19810513,19813576,19813305],"length":1,"stats":{"Line":0}},{"line":115,"address":[19779005,19779239,19779617,19779285,19779755],"length":1,"stats":{"Line":0}},{"line":116,"address":[19704393,19704292],"length":1,"stats":{"Line":0}},{"line":117,"address":[11240546],"length":1,"stats":{"Line":0}},{"line":119,"address":[19779848,19779965],"length":1,"stats":{"Line":0}},{"line":120,"address":[11839136],"length":1,"stats":{"Line":0}},{"line":122,"address":[19698565,19698451],"length":1,"stats":{"Line":0}},{"line":123,"address":[19911664],"length":1,"stats":{"Line":0}},{"line":126,"address":[21012040,21006844,21011456],"length":1,"stats":{"Line":0}},{"line":129,"address":[19532644],"length":1,"stats":{"Line":0}},{"line":130,"address":[19901647,19901513,19707037,19707538,19706936],"length":1,"stats":{"Line":0}},{"line":134,"address":[21010549],"length":1,"stats":{"Line":0}},{"line":138,"address":[15908781,15908768],"length":1,"stats":{"Line":0}},{"line":139,"address":[11834308],"length":1,"stats":{"Line":0}},{"line":141,"address":[19777568,19777435,19777749,19776798],"length":1,"stats":{"Line":0}},{"line":142,"address":[19717818,19717535,19717299,19717209],"length":1,"stats":{"Line":0}},{"line":143,"address":[19785247],"length":1,"stats":{"Line":0}},{"line":145,"address":[19776819,19778537,19778678,19778456],"length":1,"stats":{"Line":0}},{"line":146,"address":[19704378,19702248,19704460,19705002],"length":1,"stats":{"Line":0}},{"line":147,"address":[19817658],"length":1,"stats":{"Line":0}},{"line":149,"address":[11878108],"length":1,"stats":{"Line":0}},{"line":150,"address":[19818571,19818851,19819183,19819321,19818805],"length":1,"stats":{"Line":0}},{"line":151,"address":[13960295,13960194],"length":1,"stats":{"Line":0}},{"line":152,"address":[11878134],"length":1,"stats":{"Line":0}},{"line":154,"address":[19781302,19781419],"length":1,"stats":{"Line":0}},{"line":155,"address":[11834464],"length":1,"stats":{"Line":0}},{"line":157,"address":[19706833,19706947],"length":1,"stats":{"Line":0}},{"line":158,"address":[19788494],"length":1,"stats":{"Line":0}},{"line":161,"address":[11834490],"length":1,"stats":{"Line":0}},{"line":164,"address":[19721448,19721899,19716113],"length":1,"stats":{"Line":0}},{"line":165,"address":[19715318,19902009,19715920,19902143,19715419],"length":1,"stats":{"Line":0}},{"line":169,"address":[19824531],"length":1,"stats":{"Line":0}},{"line":173,"address":[15969648],"length":1,"stats":{"Line":0}},{"line":178,"address":[11867906],"length":1,"stats":{"Line":0}},{"line":179,"address":[13965614,13965532],"length":1,"stats":{"Line":0}},{"line":180,"address":[19827991,19828194],"length":1,"stats":{"Line":0}},{"line":183,"address":[19824020,19824365,19823318,19824134],"length":1,"stats":{"Line":0}},{"line":184,"address":[19829400,19828666,19829372,19828587,19829088],"length":1,"stats":{"Line":0}},{"line":185,"address":[19829046],"length":1,"stats":{"Line":0}},{"line":187,"address":[19530230],"length":1,"stats":{"Line":0}},{"line":188,"address":[11968352],"length":1,"stats":{"Line":0}},{"line":189,"address":[19720438],"length":1,"stats":{"Line":0}},{"line":191,"address":[11836826],"length":1,"stats":{"Line":0}},{"line":192,"address":[21026780],"length":1,"stats":{"Line":0}},{"line":193,"address":[19728739,19729537,19728621,19729467],"length":1,"stats":{"Line":0}},{"line":194,"address":[21027797,21027529,21027350,21028152,21028182],"length":1,"stats":{"Line":0}},{"line":195,"address":[19729573,19729854],"length":1,"stats":{"Line":0}},{"line":196,"address":[11829924],"length":1,"stats":{"Line":0}},{"line":198,"address":[19832228],"length":1,"stats":{"Line":0}},{"line":202,"address":[19928909,19928816],"length":1,"stats":{"Line":0}},{"line":203,"address":[19823423,19828645,19828944],"length":1,"stats":{"Line":0}},{"line":206,"address":[19928915,19929572],"length":1,"stats":{"Line":0}},{"line":207,"address":[19835034,19834988,19835238,19835330,19834822],"length":1,"stats":{"Line":0}},{"line":208,"address":[19833194,19833328],"length":1,"stats":{"Line":0}},{"line":209,"address":[11868088],"length":1,"stats":{"Line":0}},{"line":211,"address":[20008559,19829892,20008425,19830393,19829791],"length":1,"stats":{"Line":0}},{"line":215,"address":[19789656],"length":1,"stats":{"Line":0}},{"line":220,"address":[16108208,16108243],"length":1,"stats":{"Line":0}},{"line":221,"address":[19836109,19835747,19835814,19835983,19836444,19836652],"length":1,"stats":{"Line":0}},{"line":223,"address":[11969676],"length":1,"stats":{"Line":0}},{"line":224,"address":[11763414],"length":1,"stats":{"Line":0}},{"line":225,"address":[13975231],"length":1,"stats":{"Line":0}},{"line":227,"address":[11763440],"length":1,"stats":{"Line":0}},{"line":228,"address":[11838202],"length":1,"stats":{"Line":0}},{"line":229,"address":[19719279,19722502,19722659],"length":1,"stats":{"Line":0}},{"line":230,"address":[19723061,19896217,19723162,19896351,19723663],"length":1,"stats":{"Line":0}},{"line":234,"address":[21033853],"length":1,"stats":{"Line":0}},{"line":238,"address":[15908976,15909011],"length":1,"stats":{"Line":0}},{"line":239,"address":[11244866],"length":1,"stats":{"Line":0}},{"line":241,"address":[11878412],"length":1,"stats":{"Line":0}},{"line":242,"address":[19740406,19740102,19740020,19740696],"length":1,"stats":{"Line":0}},{"line":243,"address":[19939670],"length":1,"stats":{"Line":0}},{"line":245,"address":[19939895,19938185,19940036,19939814],"length":1,"stats":{"Line":0}},{"line":246,"address":[19843896,19844527,19841774,19843978],"length":1,"stats":{"Line":0}},{"line":247,"address":[13982143],"length":1,"stats":{"Line":0}},{"line":249,"address":[11244954],"length":1,"stats":{"Line":0}},{"line":250,"address":[11244976],"length":1,"stats":{"Line":0}},{"line":251,"address":[21040986,21036873,21041143],"length":1,"stats":{"Line":0}},{"line":252,"address":[19737487,19736885,19736986,19903631,19903497],"length":1,"stats":{"Line":0}},{"line":256,"address":[21040617],"length":1,"stats":{"Line":0}}],"covered":22,"coverable":134},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager_handle.rs"],"content":"use crate::application::ports::{event_topic_store::EventTopicStore, key_manager::KeyPair};\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::infrastructure::event::EventManager;\nuse crate::infrastructure::p2p::GossipService;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata, PublicKey};\nuse std::sync::Arc;\n\n#[async_trait]\npub trait EventManagerHandle: Send + Sync {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>);\n    async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>);\n    async fn set_default_p2p_topic_id(&self, topic_id: &str);\n    async fn set_default_p2p_topics(&self, topics: Vec<String>);\n    async fn list_default_p2p_topics(&self) -> Vec<String>;\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()>;\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<NostrEventId>;\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId>;\n    async fn publish_repost(&self, target: &NostrEventId) -> Result<NostrEventId>;\n    async fn publish_event(&self, event: NostrEvent) -> Result<NostrEventId>;\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId>;\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId>;\n    async fn disconnect(&self) -> Result<()>;\n    async fn get_public_key(&self) -> Option<PublicKey>;\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()>;\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()>;\n    async fn register_event_callback(&self, callback: Arc<dyn Fn(NostrEvent) + Send + Sync>);\n    async fn initialize_with_keypair(&self, keypair: KeyPair) -> Result<()>;\n}\n\n#[derive(Clone)]\npub struct LegacyEventManagerHandle {\n    inner: Arc<EventManager>,\n}\n\nimpl LegacyEventManagerHandle {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(EventManager::new()),\n        }\n    }\n\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        Self {\n            inner: Arc::new(EventManager::new_with_connection_pool(pool)),\n        }\n    }\n\n    pub fn as_event_manager(&self) -> Arc<EventManager> {\n        Arc::clone(&self.inner)\n    }\n}\n\nimpl Default for LegacyEventManagerHandle {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventManagerHandle for LegacyEventManagerHandle {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        self.inner.set_gossip_service(gossip).await;\n    }\n\n    async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>) {\n        self.inner.set_event_topic_store(store).await;\n    }\n\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\n        self.inner.set_default_p2p_topic_id(topic_id).await;\n    }\n\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.inner.set_default_p2p_topics(topics).await;\n    }\n\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.inner.list_default_p2p_topics().await\n    }\n\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()> {\n        self.inner.handle_p2p_event(event).await\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId> {\n        self.inner.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<NostrEventId> {\n        self.inner\n            .publish_topic_post(topic_id, content, reply_to, scope, epoch)\n            .await\n    }\n\n    async fn publish_repost(&self, target: &NostrEventId) -> Result<NostrEventId> {\n        self.inner.publish_repost(target).await\n    }\n\n    async fn publish_event(&self, event: NostrEvent) -> Result<NostrEventId> {\n        self.inner.publish_event(event).await\n    }\n\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId> {\n        self.inner.send_reaction(target, reaction).await\n    }\n\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId> {\n        self.inner.update_metadata(metadata).await\n    }\n\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId> {\n        self.inner.delete_events(target_ids, reason).await\n    }\n\n    async fn disconnect(&self) -> Result<()> {\n        self.inner.disconnect().await\n    }\n\n    async fn get_public_key(&self) -> Option<PublicKey> {\n        self.inner.get_public_key().await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_topic(topic_id, since).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_user(pubkey, since).await\n    }\n\n    async fn register_event_callback(&self, callback: Arc<dyn Fn(NostrEvent) + Send + Sync>) {\n        self.inner.register_event_callback(callback).await;\n    }\n\n    async fn initialize_with_keypair(&self, keypair: KeyPair) -> Result<()> {\n        self.inner.initialize_with_keypair(&keypair).await\n    }\n}\n","traces":[{"line":51,"address":[22181872],"length":1,"stats":{"Line":1}},{"line":53,"address":[22256612],"length":1,"stats":{"Line":1}},{"line":57,"address":[22181904],"length":1,"stats":{"Line":1}},{"line":59,"address":[22256652],"length":1,"stats":{"Line":1}},{"line":63,"address":[22291808],"length":1,"stats":{"Line":2}},{"line":64,"address":[22291813],"length":1,"stats":{"Line":2}},{"line":69,"address":[22256704],"length":1,"stats":{"Line":0}},{"line":70,"address":[22181969],"length":1,"stats":{"Line":0}},{"line":76,"address":[22369119,22369305,22369822,22369447,22369280,22369643,22369487],"length":1,"stats":{"Line":8}},{"line":77,"address":[11940491],"length":1,"stats":{"Line":4}},{"line":80,"address":[22309135,22309296,22309463,22309503,22309659,22309838,22309321],"length":1,"stats":{"Line":8}},{"line":81,"address":[22414018,22414219,22414081,22413975],"length":1,"stats":{"Line":4}},{"line":84,"address":[20680576,20680313,20680239,20680751,20680288,20680394,20680431],"length":1,"stats":{"Line":0}},{"line":85,"address":[22413226,22413161,22413118,22413363],"length":1,"stats":{"Line":0}},{"line":88,"address":[22410396,22409647,22410021,22410209,22409849,22409824,22409981],"length":1,"stats":{"Line":4}},{"line":89,"address":[11946068],"length":1,"stats":{"Line":2}},{"line":92,"address":[22372560,22372697,22373064,22372806,22372415,22372834,22373350,22372595],"length":1,"stats":{"Line":0}},{"line":93,"address":[11841783],"length":1,"stats":{"Line":0}},{"line":96,"address":[22512048,22512073,22512181,22512715,22512277,22512962,22512512,22512242,22511871],"length":1,"stats":{"Line":8}},{"line":97,"address":[22512747,22512496,22512208,22512557],"length":1,"stats":{"Line":5}},{"line":100,"address":[22418611,22418694,22418954,22418464,22418529,22419214,22418717,22418302],"length":1,"stats":{"Line":0}},{"line":101,"address":[12036631],"length":1,"stats":{"Line":0}},{"line":104,"address":[22308162,22308837,22308368,22307861,22308250,22308342,22308096,22309099],"length":1,"stats":{"Line":5}},{"line":112,"address":[22308971,22308785,22308663,22308601],"length":1,"stats":{"Line":4}},{"line":113,"address":[22414562],"length":1,"stats":{"Line":1}},{"line":114,"address":[16556389,16556539,16556278,16555797,16556332],"length":1,"stats":{"Line":4}},{"line":117,"address":[22415485,22415718,22415379,22415297,22415232,22415462,22415978,22415078],"length":1,"stats":{"Line":0}},{"line":118,"address":[16557350,16557006,16557191],"length":1,"stats":{"Line":0}},{"line":121,"address":[22317264,22318045,22317450,22317571,22318311,22317606,22317086,22317840,22317329],"length":1,"stats":{"Line":0}},{"line":122,"address":[22422005,22422352,22422605,22422413],"length":1,"stats":{"Line":0}},{"line":125,"address":[22421998,22421651,22422258,22421757,22421734,22421334,22421569,22421504],"length":1,"stats":{"Line":0}},{"line":126,"address":[22312007,22311822,22312174],"length":1,"stats":{"Line":0}},{"line":129,"address":[20688545,20688666,20688787,20689241,20689048,20688480,20688818,20688414,20689495],"length":1,"stats":{"Line":0}},{"line":130,"address":[11826929],"length":1,"stats":{"Line":0}},{"line":133,"address":[22521244,22520494,22521504,22520078,22520272,22520644,22520609,22520337,22520993],"length":1,"stats":{"Line":0}},{"line":138,"address":[22424844,22424545,22424089,22424611],"length":1,"stats":{"Line":0}},{"line":141,"address":[22390143,22390446,22390464,22390288,22390313,22390385,22390692,22390933],"length":1,"stats":{"Line":0}},{"line":142,"address":[11924199],"length":1,"stats":{"Line":0}},{"line":145,"address":[16564595,16563939,16563759,16564143,16564336,16563904,16564104,16564021],"length":1,"stats":{"Line":0}},{"line":146,"address":[22316848,22316528,22316718,22316602],"length":1,"stats":{"Line":0}},{"line":149,"address":[22324510,22325041,22324142,22324304,22324492,22324800,22324431,22324359],"length":1,"stats":{"Line":0}},{"line":150,"address":[11827943],"length":1,"stats":{"Line":0}},{"line":153,"address":[22386664,22386318,22386903,22386167,22385934,22386112,22386239,22386300],"length":1,"stats":{"Line":0}},{"line":154,"address":[22386696,22386266,22386498],"length":1,"stats":{"Line":0}},{"line":157,"address":[22387120,22387287,22387145,22387327,22386959,22387662,22387483],"length":1,"stats":{"Line":0}},{"line":158,"address":[22425426,22425383,22425627,22425489],"length":1,"stats":{"Line":0}},{"line":161,"address":[22395802,22395400,22395110,22395145,22395557,22394928,22394719,22395049,22394953],"length":1,"stats":{"Line":0}},{"line":162,"address":[22432218,22432152,22431844,22432357],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":48},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","metrics.rs"],"content":"use crate::shared::error::AppError;\nuse crate::shared::metrics::AtomicMetric;\nuse serde::Serialize;\n#[cfg(test)]\nuse std::cell::Cell;\n#[cfg(test)]\nuse std::sync::{Mutex, OnceLock};\n\r\nstatic INCOMING_EVENTS: AtomicMetric = AtomicMetric::new();\r\nstatic PUBLISH_TEXT: AtomicMetric = AtomicMetric::new();\r\nstatic PUBLISH_TOPIC: AtomicMetric = AtomicMetric::new();\r\nstatic SEND_REACTION: AtomicMetric = AtomicMetric::new();\r\nstatic UPDATE_METADATA: AtomicMetric = AtomicMetric::new();\r\nstatic DELETE_EVENTS: AtomicMetric = AtomicMetric::new();\r\nstatic DISCONNECT: AtomicMetric = AtomicMetric::new();\r\nstatic REPOST_EVENTS: AtomicMetric = AtomicMetric::new();\r\n\r\n#[cfg(test)]\r\nstatic TEST_LOCK: OnceLock<Mutex<()>> = OnceLock::new();\r\n#[cfg(test)]\r\nthread_local! {\r\n    static LOCK_DEPTH: Cell<u32> = Cell::new(0);\r\n}\r\n\r\n#[cfg(test)]\r\npub(crate) struct MetricsGuard {\n    _guard: Option<std::sync::MutexGuard<'static, ()>>,\n}\n\r\n#[cfg(test)]\r\nimpl Drop for MetricsGuard {\r\n    fn drop(&mut self) {\r\n        LOCK_DEPTH.with(|depth| {\r\n            let current = depth.get();\r\n            depth.set(current.saturating_sub(1));\r\n        });\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nfn lock_guard() -> MetricsGuard {\r\n    LOCK_DEPTH.with(|depth| {\r\n        let current = depth.get();\r\n        depth.set(current + 1);\r\n        if current == 0 {\r\n            MetricsGuard {\n                _guard: Some(\n                    TEST_LOCK\n                        .get_or_init(|| Mutex::new(()))\n                        .lock()\n                        .expect(\"event metrics lock\"),\n                ),\n            }\n        } else {\n            MetricsGuard { _guard: None }\n        }\n    })\n}\n\r\n#[cfg(not(test))]\r\nstruct MetricsGuard;\r\n\r\n#[cfg(not(test))]\r\nfn lock_guard() -> MetricsGuard {\r\n    MetricsGuard\r\n}\r\n\r\n#[cfg(test)]\npub(crate) fn test_guard() -> MetricsGuard {\n    lock_guard()\r\n}\r\n\r\n#[derive(Debug, Clone, Copy)]\r\npub enum GatewayMetricKind {\r\n    Incoming,\r\n    PublishTextNote,\r\n    PublishTopicPost,\r\n    Reaction,\r\n    MetadataUpdate,\r\n    DeleteEvents,\r\n    Disconnect,\r\n    Repost,\r\n}\r\n\r\nfn metric(kind: GatewayMetricKind) -> &'static AtomicMetric {\r\n    match kind {\r\n        GatewayMetricKind::Incoming => &INCOMING_EVENTS,\r\n        GatewayMetricKind::PublishTextNote => &PUBLISH_TEXT,\r\n        GatewayMetricKind::PublishTopicPost => &PUBLISH_TOPIC,\r\n        GatewayMetricKind::Reaction => &SEND_REACTION,\r\n        GatewayMetricKind::MetadataUpdate => &UPDATE_METADATA,\r\n        GatewayMetricKind::DeleteEvents => &DELETE_EVENTS,\r\n        GatewayMetricKind::Disconnect => &DISCONNECT,\r\n        GatewayMetricKind::Repost => &REPOST_EVENTS,\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct GatewayMetricSnapshot {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\r\n#[derive(Debug, Clone, Serialize, PartialEq)]\r\npub struct EventGatewayMetrics {\n    pub incoming: GatewayMetricSnapshot,\n    pub publish_text_note: GatewayMetricSnapshot,\r\n    pub publish_topic_post: GatewayMetricSnapshot,\r\n    pub reactions: GatewayMetricSnapshot,\r\n    pub metadata_updates: GatewayMetricSnapshot,\r\n    pub deletions: GatewayMetricSnapshot,\r\n    pub disconnects: GatewayMetricSnapshot,\r\n    pub reposts: GatewayMetricSnapshot,\n}\n\nfn snapshot_from_atomic(metric: &AtomicMetric) -> GatewayMetricSnapshot {\n    let snapshot = metric.snapshot();\n    GatewayMetricSnapshot {\n        total: snapshot.successes,\n        failures: snapshot.failures,\n        last_success_ms: snapshot.last_success_ms,\n        last_failure_ms: snapshot.last_failure_ms,\n    }\n}\n\r\npub fn record_success(kind: GatewayMetricKind) {\n    let _guard = lock_guard();\r\n    metric(kind).record_success();\r\n}\r\n\r\npub fn record_failure(kind: GatewayMetricKind) {\r\n    let _guard = lock_guard();\r\n    metric(kind).record_failure();\r\n}\r\n\r\npub fn record_outcome<T>(\r\n    result: Result<T, AppError>,\r\n    kind: GatewayMetricKind,\r\n) -> Result<T, AppError> {\r\n    match result {\r\n        Ok(value) => {\r\n            record_success(kind);\r\n            Ok(value)\r\n        }\r\n        Err(err) => {\r\n            record_failure(kind);\r\n            Err(err)\r\n        }\r\n    }\r\n}\r\n\r\npub fn snapshot() -> EventGatewayMetrics {\n    let _guard = lock_guard();\n    EventGatewayMetrics {\n        incoming: snapshot_from_atomic(&INCOMING_EVENTS),\n        publish_text_note: snapshot_from_atomic(&PUBLISH_TEXT),\n        publish_topic_post: snapshot_from_atomic(&PUBLISH_TOPIC),\n        reactions: snapshot_from_atomic(&SEND_REACTION),\n        metadata_updates: snapshot_from_atomic(&UPDATE_METADATA),\n        deletions: snapshot_from_atomic(&DELETE_EVENTS),\n        disconnects: snapshot_from_atomic(&DISCONNECT),\n        reposts: snapshot_from_atomic(&REPOST_EVENTS),\n    }\n}\n\r\n#[cfg(test)]\npub fn reset() {\n    let _guard = lock_guard();\r\n    INCOMING_EVENTS.reset();\r\n    PUBLISH_TEXT.reset();\r\n    PUBLISH_TOPIC.reset();\r\n    SEND_REACTION.reset();\r\n    UPDATE_METADATA.reset();\r\n    DELETE_EVENTS.reset();\r\n    DISCONNECT.reset();\r\n    REPOST_EVENTS.reset();\r\n}\r\n","traces":[{"line":22,"address":[18336689],"length":1,"stats":{"Line":1}},{"line":41,"address":[18070688],"length":1,"stats":{"Line":1}},{"line":42,"address":[18070704,18070689],"length":1,"stats":{"Line":2}},{"line":43,"address":[18070718],"length":1,"stats":{"Line":1}},{"line":44,"address":[18070770,18070732],"length":1,"stats":{"Line":1}},{"line":45,"address":[18070763,18070872],"length":1,"stats":{"Line":2}},{"line":46,"address":[18070854],"length":1,"stats":{"Line":1}},{"line":47,"address":[18070842],"length":1,"stats":{"Line":1}},{"line":48,"address":[18070786],"length":1,"stats":{"Line":1}},{"line":49,"address":[18070912,18070916],"length":1,"stats":{"Line":2}},{"line":55,"address":[18070874],"length":1,"stats":{"Line":1}},{"line":69,"address":[18070960],"length":1,"stats":{"Line":1}},{"line":70,"address":[18070961],"length":1,"stats":{"Line":1}},{"line":85,"address":[21433264],"length":1,"stats":{"Line":1}},{"line":86,"address":[21433414,21433271],"length":1,"stats":{"Line":2}},{"line":87,"address":[21477000],"length":1,"stats":{"Line":1}},{"line":88,"address":[21475366],"length":1,"stats":{"Line":1}},{"line":89,"address":[21372500],"length":1,"stats":{"Line":0}},{"line":90,"address":[15613058],"length":1,"stats":{"Line":0}},{"line":91,"address":[21475408],"length":1,"stats":{"Line":0}},{"line":92,"address":[21477070],"length":1,"stats":{"Line":0}},{"line":93,"address":[21475436],"length":1,"stats":{"Line":0}},{"line":94,"address":[21440330],"length":1,"stats":{"Line":0}},{"line":118,"address":[21372592],"length":1,"stats":{"Line":1}},{"line":119,"address":[15613154],"length":1,"stats":{"Line":1}},{"line":121,"address":[21475509],"length":1,"stats":{"Line":1}},{"line":122,"address":[21358874],"length":1,"stats":{"Line":1}},{"line":123,"address":[21475519],"length":1,"stats":{"Line":1}},{"line":124,"address":[21440409],"length":1,"stats":{"Line":1}},{"line":128,"address":[21365712],"length":1,"stats":{"Line":1}},{"line":129,"address":[21477228],"length":1,"stats":{"Line":1}},{"line":130,"address":[21471653],"length":1,"stats":{"Line":2}},{"line":133,"address":[21433568],"length":1,"stats":{"Line":1}},{"line":134,"address":[21440508],"length":1,"stats":{"Line":1}},{"line":135,"address":[18071444,18071396],"length":1,"stats":{"Line":2}},{"line":138,"address":[15613589,15613942,15613328,15613855,15613696],"length":1,"stats":{"Line":2}},{"line":142,"address":[21440943,21440578],"length":1,"stats":{"Line":2}},{"line":143,"address":[21477374],"length":1,"stats":{"Line":0}},{"line":144,"address":[21359104,21359447],"length":1,"stats":{"Line":1}},{"line":145,"address":[18071664,18071975],"length":1,"stats":{"Line":1}},{"line":147,"address":[21476109,21475766],"length":1,"stats":{"Line":2}},{"line":148,"address":[21433744,21434087],"length":1,"stats":{"Line":2}},{"line":149,"address":[21366129,21366380],"length":1,"stats":{"Line":2}},{"line":154,"address":[21359648],"length":1,"stats":{"Line":1}},{"line":155,"address":[21373424],"length":1,"stats":{"Line":1}},{"line":157,"address":[18072127],"length":1,"stats":{"Line":1}},{"line":158,"address":[18072183],"length":1,"stats":{"Line":1}},{"line":159,"address":[21477991],"length":1,"stats":{"Line":1}},{"line":160,"address":[21476360],"length":1,"stats":{"Line":1}},{"line":161,"address":[18072246],"length":1,"stats":{"Line":1}},{"line":162,"address":[21476400],"length":1,"stats":{"Line":1}},{"line":163,"address":[21472484],"length":1,"stats":{"Line":1}},{"line":164,"address":[21478088],"length":1,"stats":{"Line":1}},{"line":169,"address":[18072608,18072784],"length":1,"stats":{"Line":1}},{"line":170,"address":[18072612],"length":1,"stats":{"Line":1}},{"line":171,"address":[18072626],"length":1,"stats":{"Line":1}},{"line":172,"address":[18072671],"length":1,"stats":{"Line":1}},{"line":173,"address":[18072685],"length":1,"stats":{"Line":1}},{"line":174,"address":[18072699],"length":1,"stats":{"Line":1}},{"line":175,"address":[18072713],"length":1,"stats":{"Line":1}},{"line":176,"address":[18072727],"length":1,"stats":{"Line":1}},{"line":177,"address":[18072741],"length":1,"stats":{"Line":1}},{"line":178,"address":[18072755],"length":1,"stats":{"Line":1}}],"covered":56,"coverable":63},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","mod.rs"],"content":"pub mod event_manager_gateway;\npub mod handler;\npub mod manager;\npub mod manager_handle;\npub mod metrics;\npub mod nostr_client_manager;\npub mod subscription_invoker;\npub mod topic_store;\n\npub use event_manager_gateway::LegacyEventManagerGateway;\npub use manager::EventManager;\npub use manager_handle::{EventManagerHandle, LegacyEventManagerHandle};\npub use subscription_invoker::EventManagerSubscriptionInvoker;\npub use topic_store::RepositoryEventTopicStore;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","nostr_client_manager.rs"],"content":"use anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrクライアントの管理構造体\npub struct NostrClientManager {\n    client: Arc<RwLock<Option<Client>>>,\n    keys: Option<Keys>,\n}\n\nimpl NostrClientManager {\n    /// 新しいNostrClientManagerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            client: Arc::new(RwLock::new(None)),\n            keys: None,\n        }\n    }\n\n    /// 秘密鍵からクライアントを初期化\n    pub async fn init_with_keys(&mut self, secret_key: &SecretKey) -> Result<()> {\n        let keys = Keys::new(secret_key.clone());\n        self.keys = Some(keys.clone());\n\n        let client = Client::new(keys.clone());\n\n        *self.client.write().await = Some(client);\n\n        info!(\"Nostr client initialized with keys\");\n        Ok(())\n    }\n\n    /// 全てのリレーから切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            client.disconnect().await;\n            info!(\"Disconnected from all relays\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// カスタムイベントを投稿\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            let output = client.send_event(&event).await?;\n            let event_id = output.id();\n            info!(\"Published event: {}\", event_id);\n            Ok(*event_id)\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// イベントをサブスクライブ\n    pub async fn subscribe(&self, filters: Vec<Filter>) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            for filter in filters {\n                client.subscribe(filter, None).await?;\n            }\n            info!(\"Subscribed to filters\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// 公開鍵を取得\n    pub fn get_public_key(&self) -> Option<PublicKey> {\n        self.keys.as_ref().map(|k| k.public_key())\n    }\n}\n\nimpl Default for NostrClientManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_client_initialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        assert!(manager.init_with_keys(&secret_key).await.is_ok());\n        assert!(manager.get_public_key().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_client_not_initialized_error() {\n        let manager = NostrClientManager::new();\n\n        // クライアントが初期化されていない状態でのテスト\n        assert!(manager.disconnect().await.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_public_key_generation() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        // 初期化前は公開鍵がない\n        assert!(manager.get_public_key().is_none());\n\n        // 初期化後は公開鍵が取得できる\n        manager.init_with_keys(&secret_key).await.unwrap();\n        let public_key = manager.get_public_key().unwrap();\n        assert_eq!(public_key, Keys::new(secret_key).public_key());\n    }\n\n    #[tokio::test]\n    async fn test_client_reinitialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key1 = SecretKey::generate();\n        let secret_key2 = SecretKey::generate();\n\n        // 最初の初期化\n        manager.init_with_keys(&secret_key1).await.unwrap();\n        let public_key1 = manager.get_public_key().unwrap();\n\n        // 再初期化\n        manager.init_with_keys(&secret_key2).await.unwrap();\n        let public_key2 = manager.get_public_key().unwrap();\n\n        // 公開鍵が更新されていることを確認\n        assert_ne!(public_key1, public_key2);\n        assert_eq!(public_key2, Keys::new(secret_key2).public_key());\n    }\n}\n","traces":[{"line":15,"address":[21360048],"length":1,"stats":{"Line":2}},{"line":17,"address":[15614368],"length":1,"stats":{"Line":3}},{"line":23,"address":[25771199,25771168,25771391,25771120,25771133,25771965,25771994,25771348],"length":1,"stats":{"Line":12}},{"line":24,"address":[25771341,25771441],"length":1,"stats":{"Line":6}},{"line":25,"address":[21477248,21477167],"length":1,"stats":{"Line":6}},{"line":27,"address":[21477391],"length":1,"stats":{"Line":3}},{"line":29,"address":[21442328,21442575,21441954,21442627,21444646],"length":1,"stats":{"Line":5}},{"line":31,"address":[21436790,21551503,21551369,21436235],"length":1,"stats":{"Line":7}},{"line":32,"address":[21474854],"length":1,"stats":{"Line":4}},{"line":36,"address":[25775128,25774104,25774246,25774463,25774096,25774143,25774112,25774310],"length":1,"stats":{"Line":4}},{"line":37,"address":[11640225],"length":1,"stats":{"Line":2}},{"line":38,"address":[21438491,21438578,21439601],"length":1,"stats":{"Line":3}},{"line":39,"address":[11675365],"length":1,"stats":{"Line":2}},{"line":40,"address":[21589977,21477194,21477725,21590111],"length":1,"stats":{"Line":2}},{"line":41,"address":[21481637],"length":1,"stats":{"Line":1}},{"line":43,"address":[21445601,21445726],"length":1,"stats":{"Line":2}},{"line":48,"address":[15621553,15620256,15620811,15620336,15620291,15623945,15620413,15620575],"length":1,"stats":{"Line":4}},{"line":49,"address":[21440893,21441131,21440986,21440837],"length":1,"stats":{"Line":2}},{"line":50,"address":[21479613,21479520],"length":1,"stats":{"Line":2}},{"line":51,"address":[11653330],"length":1,"stats":{"Line":3}},{"line":52,"address":[15622183,15622338],"length":1,"stats":{"Line":0}},{"line":53,"address":[21690975,21581114,21690841,21581721],"length":1,"stats":{"Line":0}},{"line":54,"address":[21581621],"length":1,"stats":{"Line":0}},{"line":56,"address":[21380910,21380779],"length":1,"stats":{"Line":0}},{"line":61,"address":[21487710,21486496,21486448,21486456,21490171,21486557,21486936,21486712],"length":1,"stats":{"Line":0}},{"line":62,"address":[11767129],"length":1,"stats":{"Line":0}},{"line":63,"address":[21377383,21379379,21377470],"length":1,"stats":{"Line":0}},{"line":64,"address":[25782656,25782597,25781485,25781582],"length":1,"stats":{"Line":0}},{"line":65,"address":[10938280,10938451,10938387],"length":1,"stats":{"Line":0}},{"line":67,"address":[25895983,25782762,25783293,25895849],"length":1,"stats":{"Line":0}},{"line":68,"address":[21490871],"length":1,"stats":{"Line":0}},{"line":70,"address":[21384742,21384601],"length":1,"stats":{"Line":0}},{"line":75,"address":[21387584],"length":1,"stats":{"Line":1}},{"line":76,"address":[21486608,21486560,21486592],"length":1,"stats":{"Line":3}},{"line":81,"address":[21486624],"length":1,"stats":{"Line":0}},{"line":82,"address":[21587000],"length":1,"stats":{"Line":0}}],"covered":22,"coverable":36},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","subscription_invoker.rs"],"content":"use crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::infrastructure::event::EventManagerHandle;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{PublicKey, Timestamp};\nuse std::sync::Arc;\n\npub struct EventManagerSubscriptionInvoker {\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl EventManagerSubscriptionInvoker {\n    pub fn new(event_manager: Arc<dyn EventManagerHandle>) -> Self {\n        Self { event_manager }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionInvoker for EventManagerSubscriptionInvoker {\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError> {\n        self.event_manager\n            .subscribe_to_topic(topic_id, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError> {\n        let public_key = PublicKey::from_hex(pubkey)?;\n        self.event_manager\n            .subscribe_to_user(public_key, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n}\n","traces":[{"line":13,"address":[16523600],"length":1,"stats":{"Line":0}},{"line":20,"address":[19458733,19458910,19459024,19459326,19458784,19458822,19459002,19459586],"length":1,"stats":{"Line":0}},{"line":25,"address":[16650699,16650756,16650818,16651013,16651093],"length":1,"stats":{"Line":0}},{"line":26,"address":[16763444],"length":1,"stats":{"Line":0}},{"line":27,"address":[16657618,16657571,16657678,16657241,16657817],"length":1,"stats":{"Line":0}},{"line":28,"address":[16651152,16651170],"length":1,"stats":{"Line":0}},{"line":31,"address":[24426637,24426384,24427158,24427439,24426425,24426317,24426519],"length":1,"stats":{"Line":0}},{"line":32,"address":[19460232,19460573,19460366],"length":1,"stats":{"Line":0}},{"line":33,"address":[16726529,16726925,16726623,16727010,16726725],"length":1,"stats":{"Line":0}},{"line":35,"address":[11926708],"length":1,"stats":{"Line":0}},{"line":36,"address":[16666240,16666258],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","topic_store.rs"],"content":"use crate::application::ports::event_topic_store::EventTopicStore;\nuse crate::application::ports::repositories::EventRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\npub struct RepositoryEventTopicStore {\n    repository: Arc<dyn EventRepository>,\n}\n\nimpl RepositoryEventTopicStore {\n    pub fn new(repository: Arc<dyn EventRepository>) -> Self {\n        Self { repository }\n    }\n}\n\n#[async_trait]\nimpl EventTopicStore for RepositoryEventTopicStore {\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError> {\n        self.repository.add_event_topic(event_id, topic_id).await\n    }\n\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError> {\n        self.repository.get_event_topics(event_id).await\n    }\n}\n","traces":[{"line":12,"address":[18072816],"length":1,"stats":{"Line":2}},{"line":19,"address":[16769579,16769602,16769411,16769490,16769851,16769309,16769376,16770109],"length":1,"stats":{"Line":5}},{"line":20,"address":[16865949,16866315,16866134],"length":1,"stats":{"Line":2}},{"line":23,"address":[16771795,16772307,16771954,16772565,16772066,16771840,16771875,16772043],"length":1,"stats":{"Line":0}},{"line":24,"address":[11890804],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","mod.rs"],"content":"pub mod trending_metrics_job;\npub mod trending_metrics_metrics;\npub mod trending_metrics_server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_job.rs"],"content":"use super::trending_metrics_metrics::TrendingMetricsRecorder;\nuse crate::application::ports::repositories::TopicMetricsRepository;\nuse crate::domain::entities::{MetricsWindow, ScoreWeights, TopicActivityRow, TopicMetricsUpsert};\nuse crate::shared::error::AppError;\nuse chrono::Duration;\nuse chrono::Utc;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Instant;\n\n#[derive(Debug, Default, Clone)]\nstruct AggregatedTopicMetrics {\n    posts_24h: i64,\n    posts_6h: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n}\n\npub struct TrendingMetricsJob {\n    metrics_repository: Arc<dyn TopicMetricsRepository>,\n    score_weights: ScoreWeights,\n    ttl_hours: u64,\n    metrics_recorder: Option<Arc<TrendingMetricsRecorder>>,\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct TrendingMetricsRunStats {\n    pub topics_upserted: u64,\n    pub expired_records: u64,\n    pub cutoff_millis: i64,\n    pub window_start_millis: i64,\n    pub window_end_millis: i64,\n    pub lag_millis: i64,\n    pub score_weights: ScoreWeights,\n}\n\nimpl TrendingMetricsJob {\n    pub fn new(\n        metrics_repository: Arc<dyn TopicMetricsRepository>,\n        score_weights: Option<ScoreWeights>,\n        ttl_hours: u64,\n        metrics_recorder: Option<Arc<TrendingMetricsRecorder>>,\n    ) -> Self {\n        Self {\n            metrics_repository,\n            score_weights: score_weights.unwrap_or_default(),\n            ttl_hours,\n            metrics_recorder,\n        }\n    }\n\n    pub async fn run_once(&self) -> Result<(), AppError> {\n        let started = Instant::now();\n        let result = self.execute_once().await;\n        let duration = started.elapsed();\n        let duration_ms = duration.as_millis().min(u128::from(u64::MAX)) as u64;\n\n        if let Some(recorder) = &self.metrics_recorder {\n            match &result {\n                Ok(stats) => recorder.record_success(duration, stats),\n                Err(_) => recorder.record_failure(duration),\n            }\n        }\n\n        if let Ok(stats) = &result {\n            tracing::info!(\n                target: \"metrics::trending\",\n                topics_upserted = stats.topics_upserted,\n                cutoff_millis = stats.cutoff_millis,\n                removed_records = stats.expired_records,\n                window_start_millis = stats.window_start_millis,\n                window_end_millis = stats.window_end_millis,\n                lag_millis = stats.lag_millis,\n                score_weight_posts = stats.score_weights.posts,\n                score_weight_unique_authors = stats.score_weights.unique_authors,\n                score_weight_boosts = stats.score_weights.boosts,\n                duration_ms,\n                \"trending metrics job completed\"\n            );\n        }\n\n        result.map(|_| ())\n    }\n\n    async fn execute_once(&self) -> Result<TrendingMetricsRunStats, AppError> {\n        let now = Utc::now().timestamp_millis();\n        let window_24h = MetricsWindow::new(now - Duration::hours(24).num_milliseconds(), now);\n        let window_6h = MetricsWindow::new(now - Duration::hours(6).num_milliseconds(), now);\n\n        let activity_24h = self.metrics_repository.collect_activity(window_24h).await?;\n        let activity_6h = self.metrics_repository.collect_activity(window_6h).await?;\n\n        let aggregated = merge_activity(activity_24h, activity_6h);\n\n        let mut upserted = 0usize;\n        for (topic_id, metrics) in aggregated {\n            let score_24h =\n                self.score_weights\n                    .score(metrics.posts_24h, metrics.unique_authors, metrics.boosts);\n            let score_6h =\n                self.score_weights\n                    .score(metrics.posts_6h, metrics.unique_authors, metrics.boosts);\n\n            let upsert = TopicMetricsUpsert {\n                topic_id,\n                window_start: window_24h.start,\n                window_end: window_24h.end,\n                posts_24h: metrics.posts_24h,\n                posts_6h: metrics.posts_6h,\n                unique_authors: metrics.unique_authors,\n                boosts: metrics.boosts,\n                replies: metrics.replies,\n                bookmarks: metrics.bookmarks,\n                participant_delta: metrics.participant_delta,\n                score_24h,\n                score_6h,\n                updated_at: now,\n            };\n\n            self.metrics_repository.upsert_metrics(upsert).await?;\n            upserted += 1;\n        }\n\n        let cutoff = now - (self.ttl_hours as i64 * Duration::hours(1).num_milliseconds());\n        let removed = self.metrics_repository.cleanup_expired(cutoff).await?;\n        let lag_millis = now.saturating_sub(window_24h.end).max(0);\n\n        Ok(TrendingMetricsRunStats {\n            topics_upserted: upserted as u64,\n            expired_records: removed,\n            cutoff_millis: cutoff,\n            window_start_millis: window_24h.start,\n            window_end_millis: window_24h.end,\n            lag_millis,\n            score_weights: self.score_weights,\n        })\n    }\n}\n\nfn merge_activity(\n    activity_24h: Vec<TopicActivityRow>,\n    activity_6h: Vec<TopicActivityRow>,\n) -> HashMap<String, AggregatedTopicMetrics> {\n    let mut aggregated: HashMap<String, AggregatedTopicMetrics> = HashMap::new();\n\n    for row in activity_24h {\n        let entry = aggregated.entry(row.topic_id.clone()).or_default();\n        entry.posts_24h = row.posts_count;\n        entry.unique_authors = row.unique_authors;\n        entry.boosts = row.boosts;\n        entry.replies = row.replies;\n        entry.bookmarks = row.bookmarks;\n        entry.participant_delta = row.participant_delta;\n    }\n\n    for row in activity_6h {\n        let entry = aggregated.entry(row.topic_id.clone()).or_default();\n        entry.posts_6h = row.posts_count;\n\n        if entry.unique_authors == 0 {\n            entry.unique_authors = row.unique_authors;\n        }\n        if entry.boosts == 0 {\n            entry.boosts = row.boosts;\n        }\n        if entry.replies == 0 {\n            entry.replies = row.replies;\n        }\n        if entry.bookmarks == 0 {\n            entry.bookmarks = row.bookmarks;\n        }\n        if entry.participant_delta == 0 {\n            entry.participant_delta = row.participant_delta;\n        }\n    }\n\n    aggregated\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn merge_activity_prefers_24h_metrics() {\n        let topic = \"topic-1\";\n        let activity_24h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 12,\n            unique_authors: 5,\n            boosts: 3,\n            replies: 1,\n            bookmarks: 2,\n            participant_delta: 1,\n        }];\n\n        let activity_6h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 4,\n            unique_authors: 2,\n            boosts: 1,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }];\n\n        let merged = merge_activity(activity_24h, activity_6h);\n        let metrics = merged.get(topic).expect(\"metrics\");\n        assert_eq!(metrics.posts_24h, 12);\n        assert_eq!(metrics.posts_6h, 4);\n        assert_eq!(metrics.unique_authors, 5);\n        assert_eq!(metrics.boosts, 3);\n        assert_eq!(metrics.replies, 1);\n        assert_eq!(metrics.bookmarks, 2);\n    }\n\n    #[test]\n    fn merge_activity_falls_back_to_6h_when_24h_missing() {\n        let topic = \"topic-2\";\n        let activity_6h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 2,\n            unique_authors: 1,\n            boosts: 0,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }];\n\n        let merged = merge_activity(vec![], activity_6h);\n        let metrics = merged.get(topic).expect(\"metrics\");\n        assert_eq!(metrics.posts_24h, 0);\n        assert_eq!(metrics.posts_6h, 2);\n        assert_eq!(metrics.unique_authors, 1);\n    }\n}\n","traces":[{"line":41,"address":[12744784,12745015,12744990],"length":1,"stats":{"Line":0}},{"line":49,"address":[12739251],"length":1,"stats":{"Line":0}},{"line":55,"address":[12839856,12839824,12840310,12840080,12840037,12839903,12839832,12843977],"length":1,"stats":{"Line":0}},{"line":56,"address":[12840153,12839991],"length":1,"stats":{"Line":0}},{"line":57,"address":[12840342,12840067,12840159,12840222],"length":1,"stats":{"Line":0}},{"line":58,"address":[12740320,12740414],"length":1,"stats":{"Line":0}},{"line":59,"address":[12641493],"length":1,"stats":{"Line":0}},{"line":61,"address":[20402829,20402910],"length":1,"stats":{"Line":0}},{"line":62,"address":[12627921],"length":1,"stats":{"Line":0}},{"line":63,"address":[12709464,12709550],"length":1,"stats":{"Line":0}},{"line":64,"address":[12634779,12634863],"length":1,"stats":{"Line":0}},{"line":68,"address":[12841130,12841179],"length":1,"stats":{"Line":0}},{"line":69,"address":[12745669,12745292,12947293,12744771,12745137,12947159,12744924,12745926],"length":1,"stats":{"Line":0}},{"line":85,"address":[12744799,12747568],"length":1,"stats":{"Line":0}},{"line":88,"address":[12743730,12743878,12743656,12743984,12745575,12744825,12743648,12743680],"length":1,"stats":{"Line":0}},{"line":89,"address":[12644912,12645087],"length":1,"stats":{"Line":0}},{"line":90,"address":[12631393],"length":1,"stats":{"Line":0}},{"line":91,"address":[12748275],"length":1,"stats":{"Line":0}},{"line":93,"address":[11680865],"length":1,"stats":{"Line":0}},{"line":94,"address":[12646640,12646466,12647123,12647365,12646266,12644985],"length":1,"stats":{"Line":0}},{"line":96,"address":[12646997],"length":1,"stats":{"Line":0}},{"line":98,"address":[20408469],"length":1,"stats":{"Line":0}},{"line":99,"address":[12847319,12847387,12847242,12846581],"length":1,"stats":{"Line":0}},{"line":100,"address":[12976366,12976406,12976883],"length":1,"stats":{"Line":0}},{"line":102,"address":[12641221],"length":1,"stats":{"Line":0}},{"line":103,"address":[20409979,20409939],"length":1,"stats":{"Line":0}},{"line":105,"address":[12753267],"length":1,"stats":{"Line":0}},{"line":109,"address":[12977013],"length":1,"stats":{"Line":0}},{"line":110,"address":[12635099],"length":1,"stats":{"Line":0}},{"line":111,"address":[12751743],"length":1,"stats":{"Line":0}},{"line":112,"address":[12751751],"length":1,"stats":{"Line":0}},{"line":113,"address":[12716639],"length":1,"stats":{"Line":0}},{"line":114,"address":[20410103],"length":1,"stats":{"Line":0}},{"line":115,"address":[12716655],"length":1,"stats":{"Line":0}},{"line":116,"address":[20410119],"length":1,"stats":{"Line":0}},{"line":117,"address":[12648911],"length":1,"stats":{"Line":0}},{"line":123,"address":[12645006,12649058,12647801,12647402,12647712],"length":1,"stats":{"Line":0}},{"line":124,"address":[12708596,12708767,12708726],"length":1,"stats":{"Line":0}},{"line":127,"address":[12751124,12751388],"length":1,"stats":{"Line":0}},{"line":128,"address":[11775715],"length":1,"stats":{"Line":0}},{"line":129,"address":[12748699,12748884],"length":1,"stats":{"Line":0}},{"line":131,"address":[12650071],"length":1,"stats":{"Line":0}},{"line":132,"address":[12748920],"length":1,"stats":{"Line":0}},{"line":134,"address":[12849300],"length":1,"stats":{"Line":0}},{"line":135,"address":[12978062],"length":1,"stats":{"Line":0}},{"line":136,"address":[20411227],"length":1,"stats":{"Line":0}},{"line":138,"address":[12636263],"length":1,"stats":{"Line":0}},{"line":143,"address":[12643408,12644829,12644588],"length":1,"stats":{"Line":1}},{"line":147,"address":[12978459],"length":1,"stats":{"Line":1}},{"line":149,"address":[12643622,12643799,12643745,12643529],"length":1,"stats":{"Line":4}},{"line":150,"address":[12750561,12749799],"length":1,"stats":{"Line":2}},{"line":151,"address":[12756212],"length":1,"stats":{"Line":1}},{"line":152,"address":[20412911],"length":1,"stats":{"Line":1}},{"line":153,"address":[12979684],"length":1,"stats":{"Line":1}},{"line":154,"address":[12719479],"length":1,"stats":{"Line":1}},{"line":155,"address":[12712563],"length":1,"stats":{"Line":1}},{"line":156,"address":[12637983],"length":1,"stats":{"Line":1}},{"line":159,"address":[12718897,12718650,12718843],"length":1,"stats":{"Line":3}},{"line":160,"address":[20412433,20412537],"length":1,"stats":{"Line":2}},{"line":161,"address":[12755918],"length":1,"stats":{"Line":1}},{"line":163,"address":[12637642],"length":1,"stats":{"Line":1}},{"line":164,"address":[12719174],"length":1,"stats":{"Line":1}},{"line":166,"address":[12644455],"length":1,"stats":{"Line":1}},{"line":167,"address":[12979436],"length":1,"stats":{"Line":1}},{"line":169,"address":[12719220],"length":1,"stats":{"Line":1}},{"line":170,"address":[12651472],"length":1,"stats":{"Line":1}},{"line":172,"address":[20412705],"length":1,"stats":{"Line":1}},{"line":173,"address":[12979494],"length":1,"stats":{"Line":1}},{"line":175,"address":[12637758],"length":1,"stats":{"Line":1}},{"line":176,"address":[12651530],"length":1,"stats":{"Line":1}},{"line":180,"address":[12750193],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":71},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_metrics.rs"],"content":"use super::trending_metrics_job::TrendingMetricsRunStats;\nuse crate::shared::error::AppError;\nuse prometheus::{\n    Encoder, Gauge, Histogram, HistogramOpts, IntCounter, IntGauge, Opts, Registry, TextEncoder,\n};\nuse std::sync::Arc;\nuse std::time::Duration;\n\nfn now_millis() -> i64 {\n    chrono::Utc::now().timestamp_millis()\n}\n\nfn prometheus_err(err: prometheus::Error) -> AppError {\n    AppError::Internal(err.to_string())\n}\n\npub struct TrendingMetricsRecorder {\n    registry: Arc<Registry>,\n    encoder: TextEncoder,\n    runs_total: IntCounter,\n    failures_total: IntCounter,\n    topics_upserted: IntGauge,\n    expired_records: IntGauge,\n    last_success_ms: IntGauge,\n    last_failure_ms: IntGauge,\n    window_start_ms: IntGauge,\n    window_end_ms: IntGauge,\n    lag_ms: IntGauge,\n    weight_posts: Gauge,\n    weight_unique_authors: Gauge,\n    weight_boosts: Gauge,\n    duration_seconds: Option<Histogram>,\n}\n\nimpl TrendingMetricsRecorder {\n    pub fn new(emit_histogram: bool) -> Result<Self, AppError> {\n        let registry = Registry::new_custom(Some(\"kukuri\".into()), None).map_err(prometheus_err)?;\n\n        let runs_total = IntCounter::with_opts(Opts::new(\n            \"trending_metrics_job_runs_total\",\n            \"Total number of successful trending metrics job executions\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(runs_total.clone()))\n            .map_err(prometheus_err)?;\n\n        let failures_total = IntCounter::with_opts(Opts::new(\n            \"trending_metrics_job_failures_total\",\n            \"Total number of failed trending metrics job executions\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(failures_total.clone()))\n            .map_err(prometheus_err)?;\n\n        let topics_upserted = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_topics_upserted\",\n            \"Latest topics_upserted count emitted by the job\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(topics_upserted.clone()))\n            .map_err(prometheus_err)?;\n\n        let expired_records = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_expired_records\",\n            \"Latest expired records count removed by the job\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(expired_records.clone()))\n            .map_err(prometheus_err)?;\n\n        let last_success_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_last_success_timestamp\",\n            \"Unix timestamp in milliseconds of the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(last_success_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let last_failure_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_last_failure_timestamp\",\n            \"Unix timestamp in milliseconds of the last failed execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(last_failure_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let window_start_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_window_start_ms\",\n            \"Window start timestamp (milliseconds) for the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(window_start_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let window_end_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_window_end_ms\",\n            \"Window end timestamp (milliseconds) for the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(window_end_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let lag_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_lag_ms\",\n            \"Lag in milliseconds between now and the emitted window end\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(lag_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_posts = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_posts\",\n            \"Configured score weight applied to posts\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_posts.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_unique_authors = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_unique_authors\",\n            \"Configured score weight applied to unique authors\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_unique_authors.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_boosts = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_boosts\",\n            \"Configured score weight applied to boosts\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_boosts.clone()))\n            .map_err(prometheus_err)?;\n\n        let duration_seconds = if emit_histogram {\n            let histogram = Histogram::with_opts(\n                HistogramOpts::new(\n                    \"trending_metrics_job_duration_seconds\",\n                    \"Observed duration of trending metrics job executions\",\n                )\n                .buckets(vec![0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]),\n            )\n            .map_err(prometheus_err)?;\n            registry\n                .register(Box::new(histogram.clone()))\n                .map_err(prometheus_err)?;\n            Some(histogram)\n        } else {\n            None\n        };\n\n        Ok(Self {\n            registry: Arc::new(registry),\n            encoder: TextEncoder::new(),\n            runs_total,\n            failures_total,\n            topics_upserted,\n            expired_records,\n            last_success_ms,\n            last_failure_ms,\n            window_start_ms,\n            window_end_ms,\n            lag_ms,\n            weight_posts,\n            weight_unique_authors,\n            weight_boosts,\n            duration_seconds,\n        })\n    }\n\n    pub fn record_success(&self, duration: Duration, stats: &TrendingMetricsRunStats) {\n        self.runs_total.inc();\n        self.topics_upserted.set(stats.topics_upserted as i64);\n        self.expired_records.set(stats.expired_records as i64);\n        self.last_success_ms.set(now_millis());\n        self.window_start_ms.set(stats.window_start_millis);\n        self.window_end_ms.set(stats.window_end_millis);\n        self.lag_ms.set(stats.lag_millis);\n        self.weight_posts.set(stats.score_weights.posts);\n        self.weight_unique_authors\n            .set(stats.score_weights.unique_authors);\n        self.weight_boosts.set(stats.score_weights.boosts);\n        if let Some(histogram) = &self.duration_seconds {\n            histogram.observe(duration.as_secs_f64());\n        }\n    }\n\n    pub fn record_failure(&self, duration: Duration) {\n        self.failures_total.inc();\n        self.last_failure_ms.set(now_millis());\n        if let Some(histogram) = &self.duration_seconds {\n            histogram.observe(duration.as_secs_f64());\n        }\n    }\n\n    pub fn encode(&self) -> Result<Vec<u8>, AppError> {\n        let metric_families = self.registry.gather();\n        let mut buffer = Vec::new();\n        self.encoder\n            .encode(&metric_families, &mut buffer)\n            .map_err(prometheus_err)?;\n        Ok(buffer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::ScoreWeights;\n    use std::str;\n\n    fn contains_metric(haystack: &str, key: &str, value: &str) -> bool {\n        haystack\n            .lines()\n            .any(|line| line.trim().starts_with(key) && line.trim().ends_with(value))\n    }\n\n    #[test]\n    fn record_success_and_failure_update_metrics() {\n        let recorder = TrendingMetricsRecorder::new(true).expect(\"recorder\");\n        let stats = TrendingMetricsRunStats {\n            topics_upserted: 3,\n            expired_records: 1,\n            cutoff_millis: 0,\n            window_start_millis: 0,\n            window_end_millis: 0,\n            lag_millis: 0,\n            score_weights: ScoreWeights::default(),\n        };\n\n        recorder.record_success(Duration::from_millis(1200), &stats);\n        let snapshot = String::from_utf8(recorder.encode().expect(\"encode\")).expect(\"utf8\");\n        assert!(\n            contains_metric(&snapshot, \"kukuri_trending_metrics_job_runs_total\", \"1\"),\n            \"runs_total metric missing: {snapshot}\"\n        );\n        assert!(snapshot.contains(\"trending_metrics_job_topics_upserted 3\"));\n\n        recorder.record_failure(Duration::from_millis(800));\n        let snapshot = String::from_utf8(recorder.encode().expect(\"encode\")).expect(\"utf8\");\n        assert!(\n            contains_metric(&snapshot, \"kukuri_trending_metrics_job_failures_total\", \"1\"),\n            \"failures_total metric missing: {snapshot}\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[14354320],"length":1,"stats":{"Line":1}},{"line":10,"address":[14248404],"length":1,"stats":{"Line":1}},{"line":13,"address":[14354475,14354352],"length":1,"stats":{"Line":0}},{"line":14,"address":[14354371,14354429],"length":1,"stats":{"Line":0}},{"line":36,"address":[14264056,14255552,14264413],"length":1,"stats":{"Line":1}},{"line":37,"address":[14242143,14241859],"length":1,"stats":{"Line":1}},{"line":39,"address":[14256004,14256220,14264398,14255859],"length":1,"stats":{"Line":2}},{"line":43,"address":[14359052],"length":1,"stats":{"Line":0}},{"line":44,"address":[14361069,14368908,14360856],"length":1,"stats":{"Line":1}},{"line":45,"address":[14359014,14359181],"length":1,"stats":{"Line":1}},{"line":46,"address":[14317325],"length":1,"stats":{"Line":0}},{"line":48,"address":[22018002,22025594,22017786,22017657],"length":1,"stats":{"Line":2}},{"line":52,"address":[14317570],"length":1,"stats":{"Line":0}},{"line":53,"address":[14257107,14256894,14264357],"length":1,"stats":{"Line":1}},{"line":54,"address":[14242940,14243107],"length":1,"stats":{"Line":1}},{"line":55,"address":[22018275],"length":1,"stats":{"Line":0}},{"line":57,"address":[14356296,14363299,14356080,14355951],"length":1,"stats":{"Line":2}},{"line":61,"address":[14243544],"length":1,"stats":{"Line":0}},{"line":62,"address":[14368862,14362201,14361988],"length":1,"stats":{"Line":1}},{"line":63,"address":[14250290,14250457],"length":1,"stats":{"Line":1}},{"line":64,"address":[16441528],"length":1,"stats":{"Line":0}},{"line":66,"address":[14250597,14250726,14250942,14257356],"length":1,"stats":{"Line":2}},{"line":70,"address":[16441753],"length":1,"stats":{"Line":0}},{"line":71,"address":[16442244,16449176,16442043],"length":1,"stats":{"Line":1}},{"line":72,"address":[14244239,14244072],"length":1,"stats":{"Line":1}},{"line":73,"address":[14251215],"length":1,"stats":{"Line":0}},{"line":75,"address":[14457796,14457451,14463621,14457580],"length":1,"stats":{"Line":2}},{"line":79,"address":[14361316],"length":1,"stats":{"Line":0}},{"line":80,"address":[14325120,14319637,14319424],"length":1,"stats":{"Line":1}},{"line":81,"address":[14258565,14258398],"length":1,"stats":{"Line":1}},{"line":82,"address":[14244997],"length":1,"stats":{"Line":0}},{"line":84,"address":[14245074,14244945,14245290,14250526],"length":1,"stats":{"Line":2}},{"line":88,"address":[22020218],"length":1,"stats":{"Line":0}},{"line":89,"address":[14259158,14259371,14264265],"length":1,"stats":{"Line":1}},{"line":90,"address":[22020180,22020347],"length":1,"stats":{"Line":1}},{"line":91,"address":[14259323],"length":1,"stats":{"Line":0}},{"line":93,"address":[16443621,16443484,16449136,16443805],"length":1,"stats":{"Line":2}},{"line":97,"address":[14252592],"length":1,"stats":{"Line":0}},{"line":98,"address":[22021147,22025458,22020934],"length":1,"stats":{"Line":1}},{"line":99,"address":[14252721,14252554],"length":1,"stats":{"Line":1}},{"line":100,"address":[14252907],"length":1,"stats":{"Line":0}},{"line":102,"address":[14363184,14358904,14358775,14359117],"length":1,"stats":{"Line":2}},{"line":106,"address":[14246365],"length":1,"stats":{"Line":0}},{"line":107,"address":[14463531,14459797,14459584],"length":1,"stats":{"Line":1}},{"line":108,"address":[14320922,14321083],"length":1,"stats":{"Line":1}},{"line":109,"address":[14260437],"length":1,"stats":{"Line":0}},{"line":111,"address":[16444820,16449098,16445141,16444957],"length":1,"stats":{"Line":2}},{"line":115,"address":[14321511],"length":1,"stats":{"Line":0}},{"line":116,"address":[14257220,14253850,14254063],"length":1,"stats":{"Line":1}},{"line":117,"address":[14359749,14359588],"length":1,"stats":{"Line":1}},{"line":118,"address":[14321823],"length":1,"stats":{"Line":0}},{"line":120,"address":[14254092,14254305,14253963,14257218],"length":1,"stats":{"Line":2}},{"line":124,"address":[14365761],"length":1,"stats":{"Line":0}},{"line":125,"address":[14250413,14247833,14247620],"length":1,"stats":{"Line":1}},{"line":126,"address":[14254383,14254222],"length":1,"stats":{"Line":1}},{"line":127,"address":[22022761],"length":1,"stats":{"Line":0}},{"line":129,"address":[14368699,14366021,14366150,14366363],"length":1,"stats":{"Line":2}},{"line":133,"address":[14364667],"length":1,"stats":{"Line":0}},{"line":134,"address":[22023363,22023150,22025366],"length":1,"stats":{"Line":1}},{"line":135,"address":[22022968,22023129],"length":1,"stats":{"Line":1}},{"line":136,"address":[14255123],"length":1,"stats":{"Line":0}},{"line":138,"address":[14248287,14250388,14248416,14248629],"length":1,"stats":{"Line":2}},{"line":142,"address":[14366869],"length":1,"stats":{"Line":0}},{"line":143,"address":[14461982,14463439,14461800],"length":1,"stats":{"Line":1}},{"line":144,"address":[14366995,14366834],"length":1,"stats":{"Line":1}},{"line":145,"address":[14248862],"length":1,"stats":{"Line":0}},{"line":147,"address":[14249813,14248951,14248848],"length":1,"stats":{"Line":2}},{"line":149,"address":[14365965,14365593],"length":1,"stats":{"Line":2}},{"line":153,"address":[14249368,14249032,14250345],"length":1,"stats":{"Line":2}},{"line":155,"address":[16448093],"length":1,"stats":{"Line":0}},{"line":156,"address":[14256658,14256468],"length":1,"stats":{"Line":1}},{"line":157,"address":[16448070],"length":1,"stats":{"Line":1}},{"line":158,"address":[14263586],"length":1,"stats":{"Line":0}},{"line":159,"address":[14366437],"length":1,"stats":{"Line":1}},{"line":161,"address":[14255723],"length":1,"stats":{"Line":0}},{"line":164,"address":[14250124],"length":1,"stats":{"Line":1}},{"line":165,"address":[14365637,14366592],"length":1,"stats":{"Line":2}},{"line":166,"address":[14249960],"length":1,"stats":{"Line":1}},{"line":167,"address":[14263780],"length":1,"stats":{"Line":1}},{"line":168,"address":[14463100],"length":1,"stats":{"Line":1}},{"line":169,"address":[14366676],"length":1,"stats":{"Line":1}},{"line":170,"address":[14362748],"length":1,"stats":{"Line":1}},{"line":171,"address":[14331572],"length":1,"stats":{"Line":1}},{"line":172,"address":[14263820],"length":1,"stats":{"Line":1}},{"line":173,"address":[14362772],"length":1,"stats":{"Line":1}},{"line":174,"address":[14362780],"length":1,"stats":{"Line":1}},{"line":175,"address":[22025060],"length":1,"stats":{"Line":1}},{"line":176,"address":[16448753],"length":1,"stats":{"Line":1}},{"line":177,"address":[14324692],"length":1,"stats":{"Line":1}},{"line":178,"address":[14324700],"length":1,"stats":{"Line":1}},{"line":179,"address":[14256900],"length":1,"stats":{"Line":1}},{"line":183,"address":[14332208],"length":1,"stats":{"Line":1}},{"line":184,"address":[22025697],"length":1,"stats":{"Line":1}},{"line":185,"address":[14332261],"length":1,"stats":{"Line":1}},{"line":186,"address":[16449386],"length":1,"stats":{"Line":1}},{"line":187,"address":[14325375],"length":1,"stats":{"Line":1}},{"line":188,"address":[14369107],"length":1,"stats":{"Line":1}},{"line":189,"address":[14264603],"length":1,"stats":{"Line":1}},{"line":190,"address":[14369155],"length":1,"stats":{"Line":1}},{"line":191,"address":[14363595],"length":1,"stats":{"Line":1}},{"line":192,"address":[14363620,14363629],"length":1,"stats":{"Line":2}},{"line":193,"address":[14363624],"length":1,"stats":{"Line":1}},{"line":194,"address":[14332461],"length":1,"stats":{"Line":1}},{"line":195,"address":[14332481],"length":1,"stats":{"Line":1}},{"line":196,"address":[16449622],"length":1,"stats":{"Line":1}},{"line":200,"address":[14367680],"length":1,"stats":{"Line":1}},{"line":201,"address":[14369351],"length":1,"stats":{"Line":1}},{"line":202,"address":[14264838],"length":1,"stats":{"Line":1}},{"line":203,"address":[14325701],"length":1,"stats":{"Line":1}},{"line":204,"address":[14325748],"length":1,"stats":{"Line":1}},{"line":208,"address":[14265466,14264944],"length":1,"stats":{"Line":1}},{"line":209,"address":[14464294],"length":1,"stats":{"Line":1}},{"line":210,"address":[14258032],"length":1,"stats":{"Line":1}},{"line":211,"address":[16449914,16450011,16450226],"length":1,"stats":{"Line":2}},{"line":212,"address":[22026295],"length":1,"stats":{"Line":1}},{"line":213,"address":[16450184],"length":1,"stats":{"Line":0}},{"line":214,"address":[14258284],"length":1,"stats":{"Line":1}}],"covered":87,"coverable":117},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_server.rs"],"content":"use super::trending_metrics_metrics::TrendingMetricsRecorder;\nuse std::sync::Arc;\nuse tiny_http::{Header, Method, Response, Server, StatusCode};\n\nconst CONTENT_TYPE: &str = \"text/plain; version=0.0.4\";\n\npub fn spawn_prometheus_exporter(port: u16, recorder: Arc<TrendingMetricsRecorder>) {\n    let address = format!(\"127.0.0.1:{port}\");\n    tauri::async_runtime::spawn_blocking(move || match Server::http(&address) {\n        Ok(server) => {\n            tracing::info!(\n                target: \"metrics::trending\",\n                port,\n                \"prometheus exporter listening\"\n            );\n            for request in server.incoming_requests() {\n                let response = if request.method() == &Method::Get && request.url() == \"/metrics\" {\n                    match recorder.encode() {\n                        Ok(body) => Response::from_data(body)\n                            .with_status_code(StatusCode(200))\n                            .with_header(Header::from_bytes(\"Content-Type\", CONTENT_TYPE).unwrap()),\n                        Err(err) => {\n                            tracing::error!(\n                                target: \"metrics::trending\",\n                                error = %err,\n                                \"failed to encode metrics payload\"\n                            );\n                            Response::from_string(\"failed to encode metrics\")\n                                .with_status_code(StatusCode(500))\n                        }\n                    }\n                } else {\n                    Response::from_string(\"not found\").with_status_code(StatusCode(404))\n                };\n\n                if let Err(err) = request.respond(response) {\n                    tracing::warn!(\n                        target: \"metrics::trending\",\n                        error = %err,\n                        \"failed to respond to metrics request\"\n                    );\n                }\n            }\n        }\n        Err(err) => {\n            tracing::error!(\n                target: \"metrics::trending\",\n                port,\n                error = %err,\n                \"failed to bind prometheus exporter\"\n            );\n        }\n    });\n}\n","traces":[{"line":7,"address":[16817126,16817155,16816816],"length":1,"stats":{"Line":0}},{"line":8,"address":[16891509,16891428],"length":1,"stats":{"Line":0}},{"line":9,"address":[17030074,17030352,17030273,17030240,17038647,17033261],"length":1,"stats":{"Line":0}},{"line":10,"address":[16933973],"length":1,"stats":{"Line":0}},{"line":11,"address":[17030407,17103727,17031033,17030549,17103593],"length":1,"stats":{"Line":0}},{"line":16,"address":[16837561,16832938,16832831,16831703],"length":1,"stats":{"Line":0}},{"line":17,"address":[16900752,16900934,16900838],"length":1,"stats":{"Line":0}},{"line":18,"address":[16826310,16826558],"length":1,"stats":{"Line":0}},{"line":19,"address":[16932522,16932660,16932815],"length":1,"stats":{"Line":0}},{"line":20,"address":[26520104],"length":1,"stats":{"Line":0}},{"line":21,"address":[16833756,16833914],"length":1,"stats":{"Line":0}},{"line":22,"address":[16932581],"length":1,"stats":{"Line":0}},{"line":23,"address":[17104089,17033321,17104223,17033811,17032997],"length":1,"stats":{"Line":0}},{"line":28,"address":[16938993,16940207],"length":1,"stats":{"Line":0}},{"line":33,"address":[16901072,16900892],"length":1,"stats":{"Line":0}},{"line":36,"address":[16833346,16835741],"length":1,"stats":{"Line":0}},{"line":37,"address":[16903655,16904133,16973033,16903554,16973167],"length":1,"stats":{"Line":0}},{"line":45,"address":[16824147],"length":1,"stats":{"Line":0}},{"line":46,"address":[17105215,17030467,17036951,17037429,17105081],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","messaging","mod.rs"],"content":"pub mod nostr_gateway;\n\npub use nostr_gateway::NostrMessagingGateway;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","messaging","nostr_gateway.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::application::ports::messaging_gateway::{MessagingGateway, MessagingSendResult};\nuse crate::infrastructure::event::manager_handle::EventManagerHandle;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{EventBuilder, FromBech32, Keys, Kind, PublicKey, SecretKey, Tag, nip04};\nuse std::sync::Arc;\nuse tracing::warn;\n\npub struct NostrMessagingGateway {\n    key_manager: Arc<dyn KeyManager>,\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl NostrMessagingGateway {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        event_manager: Arc<dyn EventManagerHandle>,\n    ) -> Self {\n        Self {\n            key_manager,\n            event_manager,\n        }\n    }\n\n    async fn load_keys(&self, owner_npub: &str) -> Result<Keys, AppError> {\n        let nsec = self.key_manager.export_private_key(owner_npub).await?;\n        let secret_key = SecretKey::from_bech32(&nsec)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid nsec for {owner_npub}: {err}\")))?;\n        Ok(Keys::new(secret_key))\n    }\n\n    fn parse_npub(npub: &str) -> Result<PublicKey, AppError> {\n        PublicKey::from_bech32(npub).map_err(|err| AppError::ValidationError {\n            kind: ValidationFailureKind::Generic,\n            message: format!(\"Invalid npub {npub}: {err}\"),\n        })\n    }\n\n    fn encrypt_payload(\n        sender_secret: &SecretKey,\n        recipient: &PublicKey,\n        plaintext: &str,\n    ) -> Result<String, AppError> {\n        nip04::encrypt(sender_secret, recipient, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt direct message: {err}\")))\n    }\n\n    fn decrypt_payload(\n        owner_secret: &SecretKey,\n        counterparty: &PublicKey,\n        ciphertext: &str,\n    ) -> Result<String, AppError> {\n        nip04::decrypt(owner_secret, counterparty, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt direct message: {err}\")))\n    }\n}\n\n#[async_trait]\nimpl MessagingGateway for NostrMessagingGateway {\n    async fn encrypt_and_send(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<MessagingSendResult, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let recipient_pk = Self::parse_npub(recipient_npub)?;\n\n        let ciphertext = Self::encrypt_payload(keys.secret_key(), &recipient_pk, plaintext)?;\n\n        let event = EventBuilder::new(Kind::EncryptedDirectMessage, ciphertext.clone())\n            .tags([Tag::public_key(recipient_pk)])\n            .sign_with_keys(&keys)?;\n\n        if let Err(err) = self.event_manager.publish_event(event.clone()).await {\n            warn!(\"Failed to publish direct message event: {err}\");\n            return Err(AppError::NostrError(format!(\n                \"Failed to publish direct message: {err}\"\n            )));\n        }\n\n        let created_at_millis = (event.created_at.as_secs() as i64) * 1000;\n        let event_id = event.id.to_hex();\n\n        Ok(MessagingSendResult {\n            event_id: Some(event_id),\n            ciphertext,\n            created_at_millis,\n            delivered: true,\n        })\n    }\n\n    async fn encrypt_only(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<String, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let recipient_pk = Self::parse_npub(recipient_npub)?;\n        Self::encrypt_payload(keys.secret_key(), &recipient_pk, plaintext)\n    }\n\n    async fn decrypt_with_counterparty(\n        &self,\n        owner_npub: &str,\n        counterparty_npub: &str,\n        ciphertext: &str,\n    ) -> Result<String, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let counterparty_pk = Self::parse_npub(counterparty_npub)?;\n        Self::decrypt_payload(keys.secret_key(), &counterparty_pk, ciphertext)\n    }\n}\n","traces":[{"line":16,"address":[18901472],"length":1,"stats":{"Line":0}},{"line":26,"address":[19018208,19018243,19018359,19018563,19018160,19018178,19018399,19019582],"length":1,"stats":{"Line":0}},{"line":27,"address":[11671204],"length":1,"stats":{"Line":0}},{"line":28,"address":[18909222,18909250,18909516,18909060],"length":1,"stats":{"Line":0}},{"line":29,"address":[18903018,18902457,18902684,18902992],"length":1,"stats":{"Line":0}},{"line":30,"address":[18902621,18902810],"length":1,"stats":{"Line":0}},{"line":33,"address":[18917056],"length":1,"stats":{"Line":0}},{"line":34,"address":[19016368,19016023,19016080,19016312],"length":1,"stats":{"Line":0}},{"line":35,"address":[18984923],"length":1,"stats":{"Line":0}},{"line":36,"address":[19116550,19116480],"length":1,"stats":{"Line":0}},{"line":40,"address":[18903696],"length":1,"stats":{"Line":0}},{"line":45,"address":[18910513],"length":1,"stats":{"Line":0}},{"line":46,"address":[19022080,19022064],"length":1,"stats":{"Line":0}},{"line":49,"address":[12223712],"length":1,"stats":{"Line":0}},{"line":54,"address":[18978561],"length":1,"stats":{"Line":0}},{"line":55,"address":[12223808,12223792],"length":1,"stats":{"Line":0}},{"line":61,"address":[13214391,13216871,13214767,13219512,13214536,13214254,13214192,13214119],"length":1,"stats":{"Line":0}},{"line":67,"address":[19076757,19077511,19079260,19076981,19077135],"length":1,"stats":{"Line":0}},{"line":68,"address":[19174076,19174225,19173909,19175664],"length":1,"stats":{"Line":0}},{"line":70,"address":[19073989,19073830,19075280,19074208],"length":1,"stats":{"Line":0}},{"line":72,"address":[19078841,19078586,19078100,19078463,19078264,19078534,19079157],"length":1,"stats":{"Line":0}},{"line":73,"address":[13216849,13215893,13215979,13216162],"length":1,"stats":{"Line":0}},{"line":74,"address":[19043386,19043673],"length":1,"stats":{"Line":0}},{"line":76,"address":[11933378],"length":1,"stats":{"Line":0}},{"line":77,"address":[18974905,18975039,18969826,18969725,18970335],"length":1,"stats":{"Line":0}},{"line":78,"address":[18970298,18971306],"length":1,"stats":{"Line":0}},{"line":83,"address":[19077480,19077574],"length":1,"stats":{"Line":0}},{"line":84,"address":[12324124],"length":1,"stats":{"Line":0}},{"line":86,"address":[19178049],"length":1,"stats":{"Line":0}},{"line":87,"address":[19039487],"length":1,"stats":{"Line":0}},{"line":88,"address":[19083215],"length":1,"stats":{"Line":0}},{"line":94,"address":[19047138,19046912,19046947,19047345,19048133,19047026,19048160,19046839],"length":1,"stats":{"Line":0}},{"line":100,"address":[11814564],"length":1,"stats":{"Line":0}},{"line":101,"address":[19078853,19079013,19079149],"length":1,"stats":{"Line":0}},{"line":102,"address":[18980292,18980193],"length":1,"stats":{"Line":0}},{"line":105,"address":[19041506,19042640,19041392,19042613,19041618,19041427,19041319,19041825],"length":1,"stats":{"Line":0}},{"line":111,"address":[19048785,19048461,19049577,19048646,19049108],"length":1,"stats":{"Line":0}},{"line":112,"address":[19042445,19042309,19042149],"length":1,"stats":{"Line":0}},{"line":113,"address":[19086129,19086228],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","mod.rs"],"content":"pub mod cache;\npub mod crypto;\npub mod database;\npub mod event;\npub mod jobs;\npub mod messaging;\npub mod offline;\npub mod p2p;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mappers.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataRecord, OfflineActionRecord, OptimisticUpdateRecord, SyncQueueItem,\n    SyncStatusRecord,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, Utc};\n\nuse super::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\n\npub fn offline_action_from_row(row: OfflineActionRow) -> Result<OfflineActionRecord, AppError> {\n    let action_id = OfflineActionId::parse(&row.local_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let public_key = PublicKey::from_hex_str(&row.user_pubkey)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let action_type = OfflineActionType::new(row.action_type.clone())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let target_id = row\n        .target_id\n        .map(|id| {\n            EntityId::new(id).map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        })\n        .transpose()?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.action_data)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let sync_status = if row.is_synced {\n        SyncStatus::FullySynced\n    } else {\n        SyncStatus::Pending\n    };\n    let created_at = timestamp_to_datetime(row.created_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n    let remote_id = row\n        .remote_id\n        .map(|id| {\n            RemoteEventId::new(id)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        })\n        .transpose()?;\n\n    Ok(OfflineActionRecord::new(\n        Some(row.id),\n        action_id,\n        public_key,\n        action_type,\n        target_id,\n        payload,\n        sync_status,\n        created_at,\n        synced_at,\n        remote_id,\n    ))\n}\n\npub fn sync_queue_item_from_row(row: SyncQueueItemRow) -> Result<SyncQueueItem, AppError> {\n    let id = SyncQueueId::new(row.id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let action_type = OfflineActionType::new(row.action_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.payload)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let status = SyncQueueStatus::from(row.status.as_str());\n    let created_at = timestamp_to_datetime(row.created_at);\n    let updated_at = timestamp_to_datetime(row.updated_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n\n    Ok(SyncQueueItem::new(\n        id,\n        action_type,\n        payload,\n        status,\n        try_i32_to_u32(row.retry_count, \"retry_count\")?,\n        try_i32_to_u32(row.max_retries, \"max_retries\")?,\n        created_at,\n        updated_at,\n        synced_at,\n        row.error_message,\n    ))\n}\n\npub fn cache_metadata_from_row(row: CacheMetadataRow) -> Result<CacheMetadataRecord, AppError> {\n    let cache_key = CacheKey::new(row.cache_key)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let cache_type = CacheType::new(row.cache_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let last_synced_at = row.last_synced_at.map(timestamp_to_datetime);\n    let last_accessed_at = row.last_accessed_at.map(timestamp_to_datetime);\n    let expiry_time = row.expiry_time.map(timestamp_to_datetime);\n    let metadata = row\n        .metadata\n        .map(|value| serde_json::from_str(&value))\n        .transpose()\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n    Ok(CacheMetadataRecord {\n        record_id: row.id,\n        cache_key,\n        cache_type,\n        last_synced_at,\n        last_accessed_at,\n        data_version: row.data_version,\n        is_stale: row.is_stale,\n        expiry_time,\n        metadata,\n        doc_version: row.doc_version,\n        blob_hash: row.blob_hash,\n        payload_bytes: row.payload_bytes,\n    })\n}\n\npub fn optimistic_update_from_row(\n    row: OptimisticUpdateRow,\n) -> Result<OptimisticUpdateRecord, AppError> {\n    let update_id = OptimisticUpdateId::new(row.update_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_type = EntityType::new(row.entity_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_id = EntityId::new(row.entity_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let original_data = row\n        .original_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n    let updated_data = payload_from_json_str(&row.updated_data)?;\n    let created_at = timestamp_to_datetime(row.created_at);\n    let confirmed_at = row.confirmed_at.map(timestamp_to_datetime);\n\n    Ok(OptimisticUpdateRecord {\n        record_id: row.id,\n        update_id,\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n        is_confirmed: row.is_confirmed,\n        created_at,\n        confirmed_at,\n    })\n}\n\npub fn sync_status_from_row(row: SyncStatusRow) -> Result<SyncStatusRecord, AppError> {\n    let entity_type = EntityType::new(row.entity_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_id = EntityId::new(row.entity_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let sync_status = SyncStatus::from(row.sync_status.as_str());\n    let last_local_update = timestamp_to_datetime(row.last_local_update);\n    let last_remote_sync = row.last_remote_sync.map(timestamp_to_datetime);\n    let conflict_data = row\n        .conflict_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n\n    Ok(SyncStatusRecord {\n        record_id: row.id,\n        entity_type,\n        entity_id,\n        local_version: row.local_version,\n        remote_version: row.remote_version,\n        last_local_update,\n        last_remote_sync,\n        sync_status,\n        conflict_data,\n    })\n}\n\npub fn sync_queue_id_from_i64(value: i64) -> Result<SyncQueueId, AppError> {\n    SyncQueueId::new(value).map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn optimistic_update_id_from_string(value: String) -> Result<OptimisticUpdateId, AppError> {\n    OptimisticUpdateId::new(value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn payload_from_optional_json_str(\n    value: Option<String>,\n) -> Result<Option<OfflinePayload>, AppError> {\n    value.map(|json| payload_from_json_str(&json)).transpose()\n}\n\npub fn payload_from_json_str(json: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(json)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn payload_to_string(payload: &OfflinePayload) -> Result<String, AppError> {\n    serde_json::to_string(payload.as_json())\n        .map_err(|err| AppError::SerializationError(err.to_string()))\n}\n\npub fn timestamp_to_datetime(ts: i64) -> DateTime<Utc> {\n    DateTime::<Utc>::from_timestamp(ts, 0)\n        .or_else(|| DateTime::<Utc>::from_timestamp_millis(ts))\n        .unwrap_or_else(Utc::now)\n}\n\npub fn try_i32_to_u32(value: i32, label: &str) -> Result<u32, AppError> {\n    value.try_into().map_err(|_| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"{label} cannot be negative\"),\n        )\n    })\n}\n","traces":[{"line":17,"address":[23059973,23056000],"length":1,"stats":{"Line":3}},{"line":18,"address":[23156966,23160849,23156717,23156398,23156614,23156763],"length":1,"stats":{"Line":12}},{"line":19,"address":[22957329,22961916,22957443,22957606],"length":1,"stats":{"Line":6}},{"line":20,"address":[23156892,23157192,23157146,23160775,23157397,23157046],"length":1,"stats":{"Line":12}},{"line":21,"address":[26527933,26531406,26528094,26527830],"length":1,"stats":{"Line":6}},{"line":22,"address":[23157621,23157869,23157467,23160702,23157321,23157575],"length":1,"stats":{"Line":12}},{"line":23,"address":[22947659,22944430,22944541,22944749],"length":1,"stats":{"Line":6}},{"line":24,"address":[22944867,22947579,22944682,22945097],"length":1,"stats":{"Line":6}},{"line":26,"address":[23064960,23065096,23065122],"length":1,"stats":{"Line":3}},{"line":27,"address":[22962094,22962226],"length":1,"stats":{"Line":3}},{"line":30,"address":[23020063,23019615,23019769,23022120],"length":1,"stats":{"Line":6}},{"line":31,"address":[23023106,23020015,23023088],"length":1,"stats":{"Line":0}},{"line":32,"address":[26531156,26529437,26529678,26529120,26529302,26529379],"length":1,"stats":{"Line":12}},{"line":33,"address":[23020141,23020252,23020473,23022076],"length":1,"stats":{"Line":6}},{"line":34,"address":[23158937,23159056],"length":1,"stats":{"Line":6}},{"line":35,"address":[23058690],"length":1,"stats":{"Line":1}},{"line":37,"address":[23027478],"length":1,"stats":{"Line":3}},{"line":39,"address":[23020609],"length":1,"stats":{"Line":3}},{"line":40,"address":[22952869],"length":1,"stats":{"Line":3}},{"line":41,"address":[17201198,17200420],"length":1,"stats":{"Line":3}},{"line":43,"address":[23161864,23161890,23161728],"length":1,"stats":{"Line":0}},{"line":44,"address":[23067041,23066958],"length":1,"stats":{"Line":0}},{"line":45,"address":[22962454,22962542,22962562],"length":1,"stats":{"Line":0}},{"line":49,"address":[23064936,23065277],"length":1,"stats":{"Line":6}},{"line":50,"address":[22953125],"length":1,"stats":{"Line":3}},{"line":51,"address":[23159440],"length":1,"stats":{"Line":3}},{"line":52,"address":[22953192],"length":1,"stats":{"Line":3}},{"line":53,"address":[23059152],"length":1,"stats":{"Line":3}},{"line":54,"address":[23028008],"length":1,"stats":{"Line":3}},{"line":55,"address":[22953312],"length":1,"stats":{"Line":3}},{"line":56,"address":[23028088],"length":1,"stats":{"Line":3}},{"line":59,"address":[23159680],"length":1,"stats":{"Line":3}},{"line":63,"address":[22948832,22951826],"length":1,"stats":{"Line":3}},{"line":64,"address":[23065500,23065803,23065996,23069141,23065757,23065676],"length":1,"stats":{"Line":14}},{"line":65,"address":[17203348,17203612,17203459,17207016],"length":1,"stats":{"Line":5}},{"line":66,"address":[17203545,17203819,17203689,17204025,17206769,17203773],"length":1,"stats":{"Line":11}},{"line":67,"address":[23023985,23024265,23027071,23024099],"length":1,"stats":{"Line":4}},{"line":68,"address":[22963858,22963404,22963561,22966172],"length":1,"stats":{"Line":5}},{"line":69,"address":[22959616,22959634,22956834],"length":1,"stats":{"Line":0}},{"line":70,"address":[26534049,26533728,26533863,26533805,26533543,26535791],"length":1,"stats":{"Line":13}},{"line":71,"address":[23165440,23163525,23163248,23163359],"length":1,"stats":{"Line":5}},{"line":72,"address":[23031944,23032101],"length":1,"stats":{"Line":7}},{"line":73,"address":[23163685],"length":1,"stats":{"Line":4}},{"line":74,"address":[17204979],"length":1,"stats":{"Line":3}},{"line":75,"address":[23068990],"length":1,"stats":{"Line":4}},{"line":77,"address":[23033219,23032831],"length":1,"stats":{"Line":4}},{"line":79,"address":[23032253],"length":1,"stats":{"Line":3}},{"line":80,"address":[17205085],"length":1,"stats":{"Line":4}},{"line":81,"address":[23067469],"length":1,"stats":{"Line":3}},{"line":82,"address":[22957738,22957857,22957661],"length":1,"stats":{"Line":5}},{"line":83,"address":[17205333,17205833,17205498],"length":1,"stats":{"Line":5}},{"line":87,"address":[23067919],"length":1,"stats":{"Line":3}},{"line":91,"address":[23029762,23027584,23029541],"length":1,"stats":{"Line":3}},{"line":92,"address":[23069875,23069654,23069794,23070121,23069918,23071634],"length":1,"stats":{"Line":12}},{"line":93,"address":[23166342,23166234,23168255,23166514],"length":1,"stats":{"Line":6}},{"line":94,"address":[22967392,22967638,22967138,22967311,22967438,22968718],"length":1,"stats":{"Line":12}},{"line":95,"address":[26537210,26536955,26537058,26538316],"length":1,"stats":{"Line":6}},{"line":96,"address":[26537183],"length":1,"stats":{"Line":3}},{"line":97,"address":[23167028],"length":1,"stats":{"Line":3}},{"line":98,"address":[22967748],"length":1,"stats":{"Line":3}},{"line":99,"address":[23167947,23167092],"length":1,"stats":{"Line":3}},{"line":101,"address":[23036800,23036827],"length":1,"stats":{"Line":6}},{"line":103,"address":[23068146,23067531,23068128],"length":1,"stats":{"Line":0}},{"line":105,"address":[23035958],"length":1,"stats":{"Line":2}},{"line":106,"address":[23028861],"length":1,"stats":{"Line":3}},{"line":107,"address":[23167348],"length":1,"stats":{"Line":2}},{"line":108,"address":[23072603],"length":1,"stats":{"Line":2}},{"line":111,"address":[22968123],"length":1,"stats":{"Line":2}},{"line":112,"address":[26537718],"length":1,"stats":{"Line":2}},{"line":115,"address":[23035897],"length":1,"stats":{"Line":2}},{"line":116,"address":[22968145],"length":1,"stats":{"Line":2}},{"line":117,"address":[22954430],"length":1,"stats":{"Line":2}},{"line":121,"address":[17212647,17213058,17209888],"length":1,"stats":{"Line":0}},{"line":124,"address":[22956097,22958487,22955894,22955851,22955770,22955606],"length":1,"stats":{"Line":0}},{"line":125,"address":[23171839,23169130,23168958,23168850],"length":1,"stats":{"Line":0}},{"line":126,"address":[22958451,22956248,22955994,22956167,22956531,22956294],"length":1,"stats":{"Line":0}},{"line":127,"address":[22969935,22970243,22970046,22972225],"length":1,"stats":{"Line":0}},{"line":128,"address":[22963515,22963755,22963203,22963388,22965195,22963469],"length":1,"stats":{"Line":0}},{"line":129,"address":[23075011,23074900,23076717,23075211],"length":1,"stats":{"Line":0}},{"line":130,"address":[23031448,23031857,23031636,23032982],"length":1,"stats":{"Line":0}},{"line":132,"address":[23171968,23171995],"length":1,"stats":{"Line":0}},{"line":134,"address":[23170264,23170427,23170582],"length":1,"stats":{"Line":0}},{"line":135,"address":[23032075],"length":1,"stats":{"Line":0}},{"line":136,"address":[17211940],"length":1,"stats":{"Line":0}},{"line":138,"address":[23076236],"length":1,"stats":{"Line":0}},{"line":139,"address":[26540884],"length":1,"stats":{"Line":0}},{"line":140,"address":[22964463],"length":1,"stats":{"Line":0}},{"line":141,"address":[23170790],"length":1,"stats":{"Line":0}},{"line":142,"address":[23170838],"length":1,"stats":{"Line":0}},{"line":143,"address":[22971574],"length":1,"stats":{"Line":0}},{"line":144,"address":[22964662],"length":1,"stats":{"Line":0}},{"line":145,"address":[23039462],"length":1,"stats":{"Line":0}},{"line":151,"address":[23042490,23040560,23042687],"length":1,"stats":{"Line":1}},{"line":152,"address":[23071906,23071766,23072233,23073719,23072030,23071987],"length":1,"stats":{"Line":4}},{"line":153,"address":[23040730,23042720,23041010,23040838],"length":1,"stats":{"Line":2}},{"line":154,"address":[22973186,22973486,22973359,22973680,22973440,22974739],"length":1,"stats":{"Line":4}},{"line":155,"address":[17214176,17213911,17214022,17215297],"length":1,"stats":{"Line":2}},{"line":156,"address":[22966631,22966786],"length":1,"stats":{"Line":2}},{"line":157,"address":[23173098],"length":1,"stats":{"Line":1}},{"line":158,"address":[26543222],"length":1,"stats":{"Line":1}},{"line":159,"address":[26543989,26543249],"length":1,"stats":{"Line":1}},{"line":161,"address":[23077963,23077936],"length":1,"stats":{"Line":0}},{"line":164,"address":[26543604],"length":1,"stats":{"Line":1}},{"line":165,"address":[26543453],"length":1,"stats":{"Line":1}},{"line":166,"address":[23041865],"length":1,"stats":{"Line":1}},{"line":167,"address":[23041904],"length":1,"stats":{"Line":1}},{"line":168,"address":[23073136],"length":1,"stats":{"Line":1}},{"line":169,"address":[22974198],"length":1,"stats":{"Line":1}},{"line":172,"address":[22967228],"length":1,"stats":{"Line":1}},{"line":177,"address":[22961581,22961607,22961440],"length":1,"stats":{"Line":2}},{"line":178,"address":[23079879,23079747],"length":1,"stats":{"Line":4}},{"line":181,"address":[23078418,23078256,23078392],"length":1,"stats":{"Line":1}},{"line":182,"address":[22975390,22975473],"length":1,"stats":{"Line":2}},{"line":183,"address":[22961742,22961762,22961654],"length":1,"stats":{"Line":2}},{"line":186,"address":[26544848],"length":1,"stats":{"Line":1}},{"line":189,"address":[22975565,22975643,22975616],"length":1,"stats":{"Line":3}},{"line":192,"address":[26545174,26545040,26545196],"length":1,"stats":{"Line":1}},{"line":193,"address":[23074811,23074728],"length":1,"stats":{"Line":2}},{"line":194,"address":[17216440,17216460,17216352],"length":1,"stats":{"Line":2}},{"line":197,"address":[23036784],"length":1,"stats":{"Line":2}},{"line":198,"address":[22962222],"length":1,"stats":{"Line":2}},{"line":199,"address":[17216576,17216594],"length":1,"stats":{"Line":0}},{"line":202,"address":[22969216],"length":1,"stats":{"Line":3}},{"line":203,"address":[22969235],"length":1,"stats":{"Line":3}},{"line":204,"address":[23037120,23037137],"length":1,"stats":{"Line":0}},{"line":208,"address":[22969360],"length":1,"stats":{"Line":2}},{"line":209,"address":[17216919,17216960],"length":1,"stats":{"Line":3}},{"line":210,"address":[26545818],"length":1,"stats":{"Line":0}},{"line":211,"address":[17216981],"length":1,"stats":{"Line":0}},{"line":212,"address":[23080970],"length":1,"stats":{"Line":0}}],"covered":98,"coverable":130},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","metrics.rs"],"content":"use serde::Serialize;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{LazyLock, Mutex};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n#[derive(Debug, Clone, Copy, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum RetryOutcomeStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"camelCase\")]\npub struct OfflineRetryMetricsSnapshot {\n    pub total_success: u64,\n    pub total_failure: u64,\n    pub consecutive_failure: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n    pub last_outcome: Option<RetryOutcomeStatus>,\n    pub last_job_id: Option<String>,\n    pub last_job_reason: Option<String>,\n    pub last_trigger: Option<String>,\n    pub last_user_pubkey: Option<String>,\n    pub last_retry_count: Option<u32>,\n    pub last_max_retries: Option<u32>,\n    pub last_backoff_ms: Option<u64>,\n    pub last_duration_ms: Option<u64>,\n    pub last_success_count: Option<u32>,\n    pub last_failure_count: Option<u32>,\n    pub last_timestamp_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"camelCase\")]\npub struct RetryOutcomeMetadata {\n    pub job_id: Option<String>,\n    pub job_reason: Option<String>,\n    pub trigger: Option<String>,\n    pub user_pubkey: Option<String>,\n    pub retry_count: Option<u32>,\n    pub max_retries: Option<u32>,\n    pub backoff_ms: Option<u64>,\n    pub duration_ms: Option<u64>,\n    pub success_count: Option<u32>,\n    pub failure_count: Option<u32>,\n    pub timestamp_ms: Option<u64>,\n}\n\nimpl RetryOutcomeMetadata {\n    pub fn new() -> Self {\n        Self {\n            job_id: None,\n            job_reason: None,\n            trigger: None,\n            user_pubkey: None,\n            retry_count: None,\n            max_retries: None,\n            backoff_ms: None,\n            duration_ms: None,\n            success_count: None,\n            failure_count: None,\n            timestamp_ms: None,\n        }\n    }\n}\n\nimpl Default for RetryOutcomeMetadata {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[derive(Default, Clone)]\nstruct LastRetryMetadata {\n    last_outcome: Option<RetryOutcomeStatus>,\n    job_id: Option<String>,\n    job_reason: Option<String>,\n    trigger: Option<String>,\n    user_pubkey: Option<String>,\n    retry_count: Option<u32>,\n    max_retries: Option<u32>,\n    backoff_ms: Option<u64>,\n    duration_ms: Option<u64>,\n    success_count: Option<u32>,\n    failure_count: Option<u32>,\n    timestamp_ms: Option<u64>,\n}\n\nstruct OfflineRetryMetrics {\n    success: AtomicU64,\n    failure: AtomicU64,\n    consecutive_failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n    metadata: Mutex<LastRetryMetadata>,\n}\n\nimpl OfflineRetryMetrics {\n    fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            consecutive_failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(0),\n            last_failure_ms: AtomicU64::new(0),\n            metadata: Mutex::new(LastRetryMetadata::default()),\n        }\n    }\n\n    fn record(&self, status: RetryOutcomeStatus, meta: &RetryOutcomeMetadata) {\n        match status {\n            RetryOutcomeStatus::Success => {\n                self.success.fetch_add(1, Ordering::Relaxed);\n                self.last_success_ms\n                    .store(current_unix_ms(), Ordering::Relaxed);\n                self.consecutive_failure.store(0, Ordering::Relaxed);\n            }\n            RetryOutcomeStatus::Failure => {\n                self.failure.fetch_add(1, Ordering::Relaxed);\n                self.last_failure_ms\n                    .store(current_unix_ms(), Ordering::Relaxed);\n                self.consecutive_failure.fetch_add(1, Ordering::Relaxed);\n            }\n        }\n\n        if let Ok(mut guard) = self.metadata.lock() {\n            guard.last_outcome = Some(status);\n            guard.job_id = meta.job_id.clone();\n            guard.job_reason = meta.job_reason.clone();\n            guard.trigger = meta.trigger.clone();\n            guard.user_pubkey = meta.user_pubkey.clone();\n            guard.retry_count = meta.retry_count;\n            guard.max_retries = meta.max_retries;\n            guard.backoff_ms = meta.backoff_ms;\n            guard.duration_ms = meta.duration_ms;\n            guard.success_count = meta.success_count;\n            guard.failure_count = meta.failure_count;\n            guard.timestamp_ms = meta.timestamp_ms.or_else(|| Some(current_unix_ms()));\n        }\n    }\n\n    fn snapshot(&self) -> OfflineRetryMetricsSnapshot {\n        let metadata = self\n            .metadata\n            .lock()\n            .map(|guard| guard.clone())\n            .unwrap_or_else(|_| LastRetryMetadata::default());\n\n        OfflineRetryMetricsSnapshot {\n            total_success: self.success.load(Ordering::Relaxed),\n            total_failure: self.failure.load(Ordering::Relaxed),\n            consecutive_failure: self.consecutive_failure.load(Ordering::Relaxed),\n            last_success_ms: to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n            last_outcome: metadata.last_outcome,\n            last_job_id: metadata.job_id,\n            last_job_reason: metadata.job_reason,\n            last_trigger: metadata.trigger,\n            last_user_pubkey: metadata.user_pubkey,\n            last_retry_count: metadata.retry_count,\n            last_max_retries: metadata.max_retries,\n            last_backoff_ms: metadata.backoff_ms,\n            last_duration_ms: metadata.duration_ms,\n            last_success_count: metadata.success_count,\n            last_failure_count: metadata.failure_count,\n            last_timestamp_ms: metadata.timestamp_ms,\n        }\n    }\n}\n\nfn to_option(value: u64) -> Option<u64> {\n    if value == 0 { None } else { Some(value) }\n}\n\nfn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|duration| duration.as_millis() as u64)\n        .unwrap_or(0)\n}\n\nstatic OFFLINE_RETRY_METRICS: LazyLock<OfflineRetryMetrics> =\n    LazyLock::new(OfflineRetryMetrics::new);\n\npub fn record_outcome(\n    status: RetryOutcomeStatus,\n    metadata: &RetryOutcomeMetadata,\n) -> OfflineRetryMetricsSnapshot {\n    OFFLINE_RETRY_METRICS.record(status, metadata);\n    OFFLINE_RETRY_METRICS.snapshot()\n}\n\npub fn snapshot() -> OfflineRetryMetricsSnapshot {\n    OFFLINE_RETRY_METRICS.snapshot()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{RetryOutcomeMetadata, RetryOutcomeStatus};\n\n    #[test]\n    fn record_success_and_failure() {\n        let meta = RetryOutcomeMetadata {\n            job_id: Some(\"job-1\".into()),\n            job_reason: Some(\"pending-actions\".into()),\n            trigger: Some(\"worker\".into()),\n            retry_count: Some(1),\n            max_retries: Some(3),\n            backoff_ms: Some(5_000),\n            duration_ms: Some(800),\n            success_count: Some(2),\n            failure_count: Some(0),\n            timestamp_ms: Some(1_000),\n            user_pubkey: Some(\"npub\".into()),\n        };\n\n        super::record_outcome(RetryOutcomeStatus::Success, &meta);\n\n        let snapshot = super::snapshot();\n        assert_eq!(snapshot.total_success, 1);\n        assert_eq!(snapshot.total_failure, 0);\n        assert_eq!(snapshot.last_outcome, Some(RetryOutcomeStatus::Success));\n        assert_eq!(snapshot.last_job_id.as_deref(), Some(\"job-1\"));\n        assert_eq!(snapshot.last_backoff_ms, Some(5_000));\n\n        let failure_meta = RetryOutcomeMetadata {\n            job_id: Some(\"job-2\".into()),\n            failure_count: Some(1),\n            ..RetryOutcomeMetadata::default()\n        };\n\n        super::record_outcome(RetryOutcomeStatus::Failure, &failure_meta);\n        let snapshot = super::snapshot();\n        assert_eq!(snapshot.total_success, 1);\n        assert_eq!(snapshot.total_failure, 1);\n        assert_eq!(snapshot.last_outcome, Some(RetryOutcomeStatus::Failure));\n        assert_eq!(snapshot.last_job_id.as_deref(), Some(\"job-2\"));\n    }\n}\n","traces":[{"line":52,"address":[23795856],"length":1,"stats":{"Line":1}},{"line":70,"address":[23827424],"length":1,"stats":{"Line":1}},{"line":71,"address":[23831368],"length":1,"stats":{"Line":1}},{"line":101,"address":[23728512],"length":1,"stats":{"Line":1}},{"line":103,"address":[23827472],"length":1,"stats":{"Line":1}},{"line":104,"address":[23721582],"length":1,"stats":{"Line":1}},{"line":105,"address":[23796348],"length":1,"stats":{"Line":1}},{"line":106,"address":[17969162],"length":1,"stats":{"Line":1}},{"line":107,"address":[23721672],"length":1,"stats":{"Line":1}},{"line":108,"address":[23927990],"length":1,"stats":{"Line":1}},{"line":112,"address":[23715056,23717374,23717449],"length":1,"stats":{"Line":1}},{"line":113,"address":[23728867],"length":1,"stats":{"Line":1}},{"line":115,"address":[23928241],"length":1,"stats":{"Line":1}},{"line":116,"address":[17969514,17969552],"length":1,"stats":{"Line":2}},{"line":117,"address":[12224840],"length":1,"stats":{"Line":1}},{"line":118,"address":[23789861],"length":1,"stats":{"Line":1}},{"line":121,"address":[23828018],"length":1,"stats":{"Line":1}},{"line":122,"address":[23928465,23928427],"length":1,"stats":{"Line":2}},{"line":123,"address":[23828073],"length":1,"stats":{"Line":1}},{"line":124,"address":[23833702],"length":1,"stats":{"Line":1}},{"line":128,"address":[23832095],"length":1,"stats":{"Line":1}},{"line":129,"address":[23790226,23790104],"length":1,"stats":{"Line":2}},{"line":130,"address":[17971731,17969951],"length":1,"stats":{"Line":1}},{"line":131,"address":[23731165,23729661],"length":1,"stats":{"Line":1}},{"line":132,"address":[23791975,23790747],"length":1,"stats":{"Line":1}},{"line":133,"address":[23830056,23829113],"length":1,"stats":{"Line":1}},{"line":134,"address":[23730432],"length":1,"stats":{"Line":1}},{"line":135,"address":[23929839],"length":1,"stats":{"Line":1}},{"line":136,"address":[23791454],"length":1,"stats":{"Line":1}},{"line":137,"address":[23716933],"length":1,"stats":{"Line":1}},{"line":138,"address":[23723790],"length":1,"stats":{"Line":1}},{"line":139,"address":[23930155],"length":1,"stats":{"Line":1}},{"line":140,"address":[23717160,23717488,23717492],"length":1,"stats":{"Line":3}},{"line":144,"address":[23835294,23834176],"length":1,"stats":{"Line":1}},{"line":145,"address":[17971883],"length":1,"stats":{"Line":1}},{"line":148,"address":[23732448,23732475],"length":1,"stats":{"Line":2}},{"line":149,"address":[17973161,17973136],"length":1,"stats":{"Line":0}},{"line":152,"address":[23731425],"length":1,"stats":{"Line":1}},{"line":153,"address":[23836043],"length":1,"stats":{"Line":1}},{"line":154,"address":[23792390],"length":1,"stats":{"Line":1}},{"line":155,"address":[23799361],"length":1,"stats":{"Line":1}},{"line":156,"address":[23717926],"length":1,"stats":{"Line":1}},{"line":157,"address":[23731756],"length":1,"stats":{"Line":1}},{"line":158,"address":[23792599],"length":1,"stats":{"Line":1}},{"line":159,"address":[23792647],"length":1,"stats":{"Line":1}},{"line":160,"address":[23792695],"length":1,"stats":{"Line":1}},{"line":161,"address":[23836439],"length":1,"stats":{"Line":1}},{"line":162,"address":[23718199],"length":1,"stats":{"Line":1}},{"line":163,"address":[23834858],"length":1,"stats":{"Line":1}},{"line":164,"address":[23931305],"length":1,"stats":{"Line":1}},{"line":165,"address":[23725033],"length":1,"stats":{"Line":1}},{"line":166,"address":[23725049],"length":1,"stats":{"Line":1}},{"line":167,"address":[23931353],"length":1,"stats":{"Line":1}},{"line":168,"address":[23836584],"length":1,"stats":{"Line":1}},{"line":173,"address":[23793536],"length":1,"stats":{"Line":1}},{"line":174,"address":[23835594],"length":1,"stats":{"Line":1}},{"line":177,"address":[23837296],"length":1,"stats":{"Line":1}},{"line":178,"address":[12228532],"length":1,"stats":{"Line":1}},{"line":180,"address":[12228623,12228608],"length":1,"stats":{"Line":2}},{"line":187,"address":[23837408],"length":1,"stats":{"Line":1}},{"line":191,"address":[23932229],"length":1,"stats":{"Line":1}},{"line":192,"address":[23719193],"length":1,"stats":{"Line":1}},{"line":195,"address":[23732992],"length":1,"stats":{"Line":1}},{"line":196,"address":[23837534],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":64},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mod.rs"],"content":"mod mappers;\npub mod metrics;\npub mod reindex_job;\nmod rows;\npub mod sqlite_store;\n\npub use reindex_job::OfflineReindexJob;\npub use sqlite_store::SqliteOfflinePersistence;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","reindex_job.rs"],"content":"﻿use crate::application::ports::offline_store::OfflinePersistence;\r\nuse crate::domain::entities::offline::{OfflineActionFilter, OfflineActionRecord};\r\nuse crate::shared::error::AppError;\r\nuse chrono::Utc;\r\nuse serde::{Deserialize, Serialize};\r\nuse std::sync::Arc;\r\nuse tauri::Emitter;\r\nuse tokio::sync::Mutex;\r\n\r\npub trait ReindexEventEmitter: Send + Sync {\r\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String>;\r\n    fn emit_failure(&self, message: &str) -> Result<(), String>;\r\n}\r\n\r\nstruct TauriEventEmitter {\r\n    handle: tauri::AppHandle,\r\n}\r\n\r\nimpl ReindexEventEmitter for TauriEventEmitter {\r\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String> {\r\n        self.handle\r\n            .emit(\"offline://reindex_complete\", report)\r\n            .map_err(|err| err.to_string())\r\n    }\r\n\r\n    fn emit_failure(&self, message: &str) -> Result<(), String> {\r\n        self.handle\r\n            .emit(\"offline://reindex_failed\", message.to_string())\r\n            .map_err(|err| err.to_string())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SyncConflictDigest {\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub sync_status: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct OfflineReindexReport {\r\n    pub offline_action_count: usize,\r\n    pub queued_action_count: usize,\r\n    pub pending_queue_count: usize,\r\n    pub stale_cache_keys: Vec<String>,\r\n    pub optimistic_update_ids: Vec<String>,\r\n    pub sync_conflicts: Vec<SyncConflictDigest>,\r\n    pub queued_offline_action_ids: Vec<String>,\r\n    pub emitted_at: i64,\r\n}\r\n\r\npub struct OfflineReindexJob {\r\n    event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\r\n    persistence: Arc<dyn OfflinePersistence>,\r\n    gate: Mutex<()>,\r\n}\r\n\r\nimpl OfflineReindexJob {\r\n    pub fn create(\r\n        app_handle: Option<tauri::AppHandle>,\r\n        persistence: Arc<dyn OfflinePersistence>,\r\n    ) -> Arc<Self> {\r\n        let emitter = app_handle\r\n            .map(|handle| Arc::new(TauriEventEmitter { handle }) as Arc<dyn ReindexEventEmitter>);\r\n        Self::with_emitter(emitter, persistence)\r\n    }\r\n\r\n    pub fn with_emitter(\r\n        event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\r\n        persistence: Arc<dyn OfflinePersistence>,\r\n    ) -> Arc<Self> {\r\n        Arc::new(Self {\r\n            event_emitter,\r\n            persistence,\r\n            gate: Mutex::new(()),\r\n        })\r\n    }\r\n\r\n    pub fn trigger(self: &Arc<Self>) {\r\n        let job = Arc::clone(self);\r\n        tauri::async_runtime::spawn(async move {\r\n            job.run_guarded().await;\r\n        });\r\n    }\r\n\r\n    pub async fn reindex_once(&self) -> Result<OfflineReindexReport, AppError> {\r\n        let unsynced = self\r\n            .persistence\r\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\r\n            .await?;\r\n\r\n        let mut queued_action_count = 0usize;\r\n        let mut queued_local_ids = Vec::new();\r\n\r\n        for action in &unsynced {\r\n            if self.ensure_action_in_queue(action).await? {\r\n                queued_action_count += 1;\r\n                queued_local_ids.push(action.action_id.to_string());\r\n            }\r\n        }\r\n\r\n        let pending_queue = self.persistence.pending_sync_items().await?;\r\n        let stale_cache = self.persistence.stale_cache_entries().await?;\r\n        let optimistic_updates = self.persistence.unconfirmed_updates().await?;\r\n        let conflicts = self.persistence.sync_conflicts().await?;\r\n\r\n        let report = OfflineReindexReport {\r\n            offline_action_count: unsynced.len(),\r\n            queued_action_count,\r\n            pending_queue_count: pending_queue.len(),\r\n            stale_cache_keys: stale_cache\r\n                .into_iter()\r\n                .map(|entry| entry.cache_key.to_string())\r\n                .collect(),\r\n            optimistic_update_ids: optimistic_updates\r\n                .into_iter()\r\n                .map(|item| item.update_id.to_string())\r\n                .collect(),\r\n            sync_conflicts: conflicts\r\n                .into_iter()\r\n                .map(|record| SyncConflictDigest {\r\n                    entity_type: record.entity_type.to_string(),\r\n                    entity_id: record.entity_id.to_string(),\r\n                    sync_status: record.sync_status.as_str().into_owned(),\r\n                })\r\n                .collect(),\r\n            queued_offline_action_ids: queued_local_ids,\r\n            emitted_at: Utc::now().timestamp_millis(),\r\n        };\r\n\r\n        Ok(report)\r\n    }\r\n\r\n    async fn ensure_action_in_queue(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\r\n        self.persistence.enqueue_if_missing(action).await\r\n    }\r\n\r\n    async fn run_guarded(self: Arc<Self>) {\r\n        let _guard = self.gate.lock().await;\r\n        match self.reindex_once().await {\r\n            Ok(report) => self.emit_success(&report),\r\n            Err(err) => self.emit_failure(&err.to_string()),\r\n        }\r\n    }\r\n\r\n    fn emit_success(&self, report: &OfflineReindexReport) {\r\n        if let Some(emitter) = &self.event_emitter {\r\n            if let Err(err) = emitter.emit_report(report) {\r\n                tracing::warn!(\r\n                    target: \"offline::reindex\",\r\n                    error = %err,\r\n                    \"failed to emit offline reindex completion event\"\r\n                );\r\n            }\r\n        }\r\n        tracing::info!(\r\n            target: \"offline::reindex\",\r\n            queued = report.queued_action_count,\r\n            pending = report.pending_queue_count,\r\n            \"offline reindex completed\"\r\n        );\r\n    }\r\n\r\n    fn emit_failure(&self, message: &str) {\r\n        if let Some(emitter) = &self.event_emitter {\r\n            if let Err(err) = emitter.emit_failure(message) {\r\n                tracing::warn!(\r\n                    target: \"offline::reindex\",\r\n                    error = %err,\r\n                    \"failed to emit offline reindex failure event\"\r\n                );\r\n            }\r\n        }\r\n        tracing::error!(\r\n            target: \"offline::reindex\",\r\n            error = message,\r\n            \"offline reindex job failed\"\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::domain::entities::offline::{OfflineActionDraft, OfflineActionFilter};\r\n    use crate::domain::value_objects::event_gateway::PublicKey;\r\n    use crate::domain::value_objects::offline::{EntityId, OfflineActionType, OfflinePayload};\r\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\r\n    use sqlx::sqlite::SqlitePoolOptions;\r\n\r\n    const PUBKEY: &str = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\r\n\r\n    async fn setup_persistence() -> Arc<dyn OfflinePersistence> {\r\n        let pool = SqlitePoolOptions::new()\r\n            .max_connections(1)\r\n            .connect(\"sqlite::memory:\")\r\n            .await\r\n            .unwrap();\r\n\r\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\r\n\r\n        Arc::new(SqliteOfflinePersistence::new(pool))\r\n    }\r\n\r\n    fn sample_draft(index: u32) -> OfflineActionDraft {\r\n        OfflineActionDraft::new(\r\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\r\n            OfflineActionType::new(\"queue_test\".to_string()).unwrap(),\r\n            Some(EntityId::new(format!(\"post_{index}\")).unwrap()),\r\n            OfflinePayload::from_json_str(&format!(\"{{\\\"idx\\\": {index}}}\")).unwrap(),\r\n        )\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_reindex_queues_unsynced_actions() {\r\n        let persistence = setup_persistence().await;\r\n        persistence.save_action(sample_draft(1)).await.unwrap();\r\n        persistence.save_action(sample_draft(2)).await.unwrap();\r\n\r\n        let job = OfflineReindexJob::with_emitter(None, persistence.clone());\r\n\r\n        let report = job.reindex_once().await.unwrap();\r\n        assert_eq!(report.offline_action_count, 2);\r\n        assert_eq!(report.queued_action_count, 2);\r\n        assert_eq!(report.pending_queue_count, 2);\r\n        assert_eq!(report.queued_offline_action_ids.len(), 2);\r\n\r\n        // 再実行すると新規キュー追加は発生しない\r\n        let report_second = job.reindex_once().await.unwrap();\r\n        assert_eq!(report_second.queued_action_count, 0);\r\n        assert_eq!(report_second.pending_queue_count, 2);\r\n\r\n        let unsynced_after = persistence\r\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\r\n            .await\r\n            .unwrap();\r\n        assert_eq!(unsynced_after.len(), 2);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[17973600],"length":1,"stats":{"Line":0}},{"line":21,"address":[19293899],"length":1,"stats":{"Line":0}},{"line":23,"address":[23836016,23836032],"length":1,"stats":{"Line":0}},{"line":26,"address":[23794080],"length":1,"stats":{"Line":0}},{"line":27,"address":[23932640],"length":1,"stats":{"Line":0}},{"line":28,"address":[23733312],"length":1,"stats":{"Line":0}},{"line":29,"address":[23726416,23726432],"length":1,"stats":{"Line":0}},{"line":59,"address":[17974179,17974205,17974048],"length":1,"stats":{"Line":0}},{"line":63,"address":[23719758,23719824],"length":1,"stats":{"Line":0}},{"line":64,"address":[23733680,23733712],"length":1,"stats":{"Line":0}},{"line":65,"address":[23794426],"length":1,"stats":{"Line":0}},{"line":68,"address":[23933259,23933056,23933284],"length":1,"stats":{"Line":2}},{"line":72,"address":[23933176],"length":1,"stats":{"Line":2}},{"line":73,"address":[23838311],"length":1,"stats":{"Line":2}},{"line":74,"address":[23801553],"length":1,"stats":{"Line":2}},{"line":75,"address":[23720043],"length":1,"stats":{"Line":2}},{"line":79,"address":[19294784],"length":1,"stats":{"Line":0}},{"line":80,"address":[23933327],"length":1,"stats":{"Line":0}},{"line":81,"address":[23833282,23833500,23833162,23832973,23833125,23833049,23833024],"length":1,"stats":{"Line":0}},{"line":82,"address":[23837145,23837250,23837038,23837088],"length":1,"stats":{"Line":0}},{"line":86,"address":[23720848,23720816,23720824,23721205,23721057,23720895,23722321,23721531],"length":1,"stats":{"Line":8}},{"line":87,"address":[23840553,23839304,23839959,23839675,23839766,23840079,23840285],"length":1,"stats":{"Line":10}},{"line":89,"address":[23735054],"length":1,"stats":{"Line":2}},{"line":90,"address":[11546129],"length":1,"stats":{"Line":8}},{"line":92,"address":[23803427],"length":1,"stats":{"Line":2}},{"line":93,"address":[23735683],"length":1,"stats":{"Line":2}},{"line":95,"address":[23797526,23796798,23796686,23797601],"length":1,"stats":{"Line":8}},{"line":96,"address":[11613912],"length":1,"stats":{"Line":8}},{"line":97,"address":[19297216,19297316],"length":1,"stats":{"Line":4}},{"line":98,"address":[23729679,23729598],"length":1,"stats":{"Line":8}},{"line":102,"address":[11546178],"length":1,"stats":{"Line":12}},{"line":103,"address":[23731194,23730797,23730653,23731464,23727934,23730451],"length":1,"stats":{"Line":7}},{"line":104,"address":[23843008,23839459,23842657,23843402,23843665,23842856],"length":1,"stats":{"Line":7}},{"line":105,"address":[11745559],"length":1,"stats":{"Line":7}},{"line":108,"address":[23800364],"length":1,"stats":{"Line":2}},{"line":110,"address":[23838647],"length":1,"stats":{"Line":3}},{"line":111,"address":[19300256],"length":1,"stats":{"Line":2}},{"line":115,"address":[23842728,23842849],"length":1,"stats":{"Line":5}},{"line":119,"address":[23838967,23839078],"length":1,"stats":{"Line":5}},{"line":128,"address":[23740295,23740232],"length":1,"stats":{"Line":5}},{"line":131,"address":[23726737],"length":1,"stats":{"Line":3}},{"line":134,"address":[23741597,23741651,23741584,23741800,23741616,23742219,23741955,23741760],"length":1,"stats":{"Line":8}},{"line":135,"address":[11658436],"length":1,"stats":{"Line":8}},{"line":138,"address":[23728521,23728480,23728608,23730107,23728812,23728496,23729206,23728488],"length":1,"stats":{"Line":0}},{"line":139,"address":[11637913],"length":1,"stats":{"Line":0}},{"line":140,"address":[17983412,17983337,17983519,17982957],"length":1,"stats":{"Line":0}},{"line":141,"address":[23811295,23811066],"length":1,"stats":{"Line":0}},{"line":142,"address":[17984003,17984189],"length":1,"stats":{"Line":0}},{"line":146,"address":[23730192,23732121,23730848],"length":1,"stats":{"Line":0}},{"line":147,"address":[23842927],"length":1,"stats":{"Line":0}},{"line":148,"address":[23730279,23730379],"length":1,"stats":{"Line":0}},{"line":149,"address":[19304458,19304553,19305076,19469158,19304897,19469001],"length":1,"stats":{"Line":0}},{"line":156,"address":[24091023,23943419,23945865,23945215,24090889],"length":1,"stats":{"Line":0}},{"line":164,"address":[23846808,23846144,23848075],"length":1,"stats":{"Line":0}},{"line":165,"address":[17987775],"length":1,"stats":{"Line":0}},{"line":166,"address":[23733527,23733635],"length":1,"stats":{"Line":0}},{"line":167,"address":[23850307,23850402,23850746,23850879,23994953,23995087],"length":1,"stats":{"Line":0}},{"line":174,"address":[23946675,24091881,24092015,23949049,23948465],"length":1,"stats":{"Line":0}}],"covered":28,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","rows.rs"],"content":"use serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OfflineActionRow {\n    pub id: i64,\n    pub user_pubkey: String,\n    pub action_type: String,\n    pub target_id: Option<String>,\n    pub action_data: String,\n    pub local_id: String,\n    pub remote_id: Option<String>,\n    pub is_synced: bool,\n    pub created_at: i64,\n    pub synced_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncQueueItemRow {\n    pub id: i64,\n    pub action_type: String,\n    pub payload: String,\n    pub status: String,\n    pub retry_count: i32,\n    pub max_retries: i32,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub synced_at: Option<i64>,\n    pub error_message: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct CacheMetadataRow {\n    pub id: i64,\n    pub cache_key: String,\n    pub cache_type: String,\n    pub last_synced_at: Option<i64>,\n    pub last_accessed_at: Option<i64>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<i64>,\n    pub metadata: Option<String>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OptimisticUpdateRow {\n    pub id: i64,\n    pub update_id: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub original_data: Option<String>,\n    pub updated_data: String,\n    pub is_confirmed: bool,\n    pub created_at: i64,\n    pub confirmed_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncStatusRow {\n    pub id: i64,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: i64,\n    pub last_remote_sync: Option<i64>,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","sqlite_store.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheMetadataUpdate, CacheStatusSnapshot, CacheTypeStatus,\n    OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord, SyncQueueItem,\n    SyncQueueItemDraft, SyncResult, SyncStatusRecord, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::CacheType;\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::infrastructure::offline::mappers::{\n    cache_metadata_from_row, offline_action_from_row, optimistic_update_from_row,\n    optimistic_update_id_from_string, payload_from_optional_json_str, payload_to_string,\n    sync_queue_id_from_i64, sync_queue_item_from_row, sync_status_from_row,\n};\nuse crate::infrastructure::offline::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\nuse crate::shared::{ValidationFailureKind, error::AppError};\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse serde_json::Value;\nuse sqlx::{Pool, QueryBuilder, Row, Sqlite};\nuse std::collections::HashMap;\nuse std::convert::TryInto;\nuse uuid::Uuid;\n\npub struct SqliteOfflinePersistence {\n    pool: Pool<Sqlite>,\n}\n\nimpl SqliteOfflinePersistence {\n    pub fn new(pool: Pool<Sqlite>) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &Pool<Sqlite> {\n        &self.pool\n    }\n\n    pub async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\n        let payload = payload_to_string(&action.payload)?;\n\n        let existing = sqlx::query(\n            r#\"\n            SELECT id FROM sync_queue\n            WHERE action_type = ?1 AND payload = ?2\n              AND status IN ('pending', 'failed')\n            LIMIT 1\n            \"#,\n        )\n        .bind(action.action_type.as_str())\n        .bind(&payload)\n        .fetch_optional(self.pool())\n        .await?;\n\n        if existing.is_some() {\n            return Ok(false);\n        }\n\n        self.enqueue_sync(SyncQueueItemDraft::new(\n            action.action_type.clone(),\n            action.payload.clone(),\n            None,\n        ))\n        .await?;\n\n        Ok(true)\n    }\n\n    pub async fn list_pending_sync_queue(&self) -> Result<Vec<SyncQueueItem>, AppError> {\n        let rows = sqlx::query_as::<_, SyncQueueItemRow>(\n            r#\"\n            SELECT * FROM sync_queue\n            WHERE status IN ('pending', 'failed')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_queue_item_from_row).collect()\n    }\n\n    pub async fn list_recent_sync_queue(&self, limit: u32) -> Result<Vec<SyncQueueItem>, AppError> {\n        let rows = sqlx::query_as::<_, SyncQueueItemRow>(\n            r#\"\n            SELECT * FROM sync_queue\n            ORDER BY updated_at DESC\n            LIMIT ?1\n            \"#,\n        )\n        .bind(i64::from(limit))\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_queue_item_from_row).collect()\n    }\n\n    pub async fn list_stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError> {\n        let now = Utc::now().timestamp();\n        let rows = sqlx::query_as::<_, CacheMetadataRow>(\n            r#\"\n            SELECT * FROM cache_metadata\n            WHERE is_stale = 1\n               OR (expiry_time IS NOT NULL AND expiry_time < ?1)\n            ORDER BY COALESCE(last_synced_at, 0) ASC\n            \"#,\n        )\n        .bind(now)\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(cache_metadata_from_row).collect()\n    }\n\n    pub async fn list_unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError> {\n        let rows = sqlx::query_as::<_, OptimisticUpdateRow>(\n            r#\"\n            SELECT * FROM optimistic_updates\n            WHERE is_confirmed = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(optimistic_update_from_row).collect()\n    }\n\n    pub async fn list_sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError> {\n        let rows = sqlx::query_as::<_, SyncStatusRow>(\n            r#\"\n            SELECT\n                rowid as id,\n                entity_type,\n                entity_id,\n                local_version,\n                NULL AS remote_version,\n                last_local_update,\n                NULL AS last_remote_sync,\n                sync_status,\n                conflict_data\n            FROM sync_status\n            WHERE sync_status IN ('conflict', 'failed', 'pending')\n               OR sync_status LIKE 'invalid:%'\n            ORDER BY last_local_update DESC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_status_from_row).collect()\n    }\n\n    async fn get_offline_action_by_id(&self, id: i64) -> Result<OfflineActionRecord, AppError> {\n        let action = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE id = ?1\n            \"#,\n        )\n        .bind(id)\n        .fetch_one(self.pool())\n        .await?;\n\n        offline_action_from_row(action)\n    }\n}\n\n#[async_trait]\nimpl OfflinePersistence for SqliteOfflinePersistence {\n    async fn save_action(\n        &self,\n        draft: crate::domain::entities::offline::OfflineActionDraft,\n    ) -> Result<crate::domain::entities::offline::SavedOfflineAction, AppError> {\n        use crate::domain::entities::offline::{OfflineActionDraft, SavedOfflineAction};\n\n        let OfflineActionDraft {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        } = draft;\n\n        let local_id = Uuid::new_v4().to_string();\n        let action_data = payload_to_string(&payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO offline_actions (\n                user_pubkey, action_type, target_id, action_data,\n                local_id, is_synced, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .bind(action_type.as_str())\n        .bind(target_id.as_ref().map(|value| value.to_string()))\n        .bind(&action_data)\n        .bind(&local_id)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        let id = result.last_insert_rowid();\n        let action = self.get_offline_action_by_id(id).await?;\n\n        Ok(SavedOfflineAction::new(action.action_id.clone(), action))\n    }\n\n    async fn list_actions(\n        &self,\n        filter: crate::domain::entities::offline::OfflineActionFilter,\n    ) -> Result<Vec<crate::domain::entities::offline::OfflineActionRecord>, AppError> {\n        let mut builder: QueryBuilder<Sqlite> =\n            QueryBuilder::new(\"SELECT * FROM offline_actions WHERE 1=1\");\n\n        if let Some(user_pubkey) = filter.user_pubkey.as_ref() {\n            builder.push(\" AND user_pubkey = \");\n            builder.push_bind(user_pubkey.as_hex());\n        }\n\n        if let Some(is_synced) = filter.include_synced {\n            builder.push(\" AND is_synced = \");\n            builder.push_bind(if is_synced { 1 } else { 0 });\n        }\n\n        builder.push(\" ORDER BY created_at DESC\");\n\n        if let Some(limit) = filter.limit {\n            builder.push(\" LIMIT \");\n            builder.push_bind(limit as i64);\n        }\n\n        let query = builder.build_query_as::<OfflineActionRow>();\n        let actions = query.fetch_all(self.pool()).await?;\n\n        actions.into_iter().map(offline_action_from_row).collect()\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        let unsynced_actions = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_all(self.pool())\n        .await?;\n\n        let domain_actions = unsynced_actions\n            .into_iter()\n            .map(offline_action_from_row)\n            .collect::<Result<Vec<_>, AppError>>()?;\n\n        let mut synced_count: u32 = 0;\n\n        for action in domain_actions.iter() {\n            let enqueue_result = self\n                .enqueue_sync(SyncQueueItemDraft::new(\n                    action.action_type.clone(),\n                    action.payload.clone(),\n                    None,\n                ))\n                .await;\n\n            if enqueue_result.is_ok() {\n                let Some(record_id) = action.record_id else {\n                    continue;\n                };\n                let synced_at = Utc::now().timestamp();\n                sqlx::query(\n                    r#\"\n                    UPDATE offline_actions\n                    SET is_synced = 1, synced_at = ?1\n                    WHERE id = ?2\n                    \"#,\n                )\n                .bind(synced_at)\n                .bind(record_id)\n                .execute(self.pool())\n                .await?;\n                synced_count = synced_count.saturating_add(1);\n            }\n        }\n\n        let pending_result = sqlx::query(\n            r#\"\n            SELECT COUNT(*) as count\n            FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_one(self.pool())\n        .await?;\n\n        let pending_count: u32 = pending_result\n            .try_get::<i32, _>(\"count\")\n            .unwrap_or(0)\n            .try_into()\n            .unwrap_or(0);\n\n        Ok(SyncResult::new(synced_count, 0, pending_count))\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        let rows = sqlx::query_as::<_, CacheMetadataRow>(\n            r#\"\n            SELECT * FROM cache_metadata\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        let records = rows\n            .into_iter()\n            .map(cache_metadata_from_row)\n            .collect::<Result<Vec<_>, AppError>>()?;\n\n        let total_items = records.len() as u64;\n        let stale_items = records.iter().filter(|record| record.is_stale).count() as u64;\n\n        #[derive(Clone, Default)]\n        struct DocFieldSnapshot {\n            doc_version: Option<i64>,\n            blob_hash: Option<String>,\n            payload_bytes: Option<i64>,\n        }\n\n        #[derive(Default)]\n        struct CacheTypeGroup {\n            item_count: u64,\n            is_stale: bool,\n            last_synced_at: Option<DateTime<Utc>>,\n            latest_metadata: Option<(DateTime<Utc>, Value)>,\n            latest_doc_fields: Option<(DateTime<Utc>, DocFieldSnapshot)>,\n        }\n\n        let mut groups: HashMap<String, CacheTypeGroup> = HashMap::new();\n\n        for record in records {\n            let cache_type_key = record.cache_type.to_string();\n            let entry = groups.entry(cache_type_key).or_default();\n            entry.item_count = entry.item_count.saturating_add(1);\n            if record.is_stale {\n                entry.is_stale = true;\n            }\n            if let Some(last_synced_at) = record.last_synced_at {\n                let should_replace = entry\n                    .last_synced_at\n                    .map(|current| last_synced_at > current)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.last_synced_at = Some(last_synced_at);\n                }\n            }\n            if let Some(metadata) = record.metadata.clone() {\n                let timestamp = record\n                    .last_accessed_at\n                    .or(record.last_synced_at)\n                    .unwrap_or_else(Utc::now);\n                let should_replace = entry\n                    .latest_metadata\n                    .as_ref()\n                    .map(|(current_ts, _)| timestamp >= *current_ts)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.latest_metadata = Some((timestamp, metadata));\n                }\n            }\n            if record.doc_version.is_some()\n                || record.blob_hash.is_some()\n                || record.payload_bytes.is_some()\n            {\n                let timestamp = record\n                    .last_accessed_at\n                    .or(record.last_synced_at)\n                    .unwrap_or_else(Utc::now);\n                let should_replace = entry\n                    .latest_doc_fields\n                    .as_ref()\n                    .map(|(current_ts, _)| timestamp >= *current_ts)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.latest_doc_fields = Some((\n                        timestamp,\n                        DocFieldSnapshot {\n                            doc_version: record.doc_version,\n                            blob_hash: record.blob_hash.clone(),\n                            payload_bytes: record.payload_bytes,\n                        },\n                    ));\n                }\n            }\n        }\n\n        let mut cache_types = Vec::with_capacity(groups.len());\n        for (cache_type_name, summary) in groups {\n            let cache_type = CacheType::new(cache_type_name)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n            let metadata = summary\n                .latest_metadata\n                .as_ref()\n                .map(|(_, value)| value.clone());\n            let doc_version = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.doc_version);\n            let blob_hash = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.blob_hash.clone());\n            let payload_bytes = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.payload_bytes);\n            cache_types.push(CacheTypeStatus {\n                cache_type,\n                item_count: summary.item_count,\n                last_synced_at: summary.last_synced_at,\n                is_stale: summary.is_stale,\n                metadata,\n                doc_version,\n                blob_hash,\n                payload_bytes,\n            });\n        }\n\n        cache_types.sort_by(|a, b| a.cache_type.as_str().cmp(b.cache_type.as_str()));\n\n        Ok(CacheStatusSnapshot::new(\n            total_items,\n            stale_items,\n            cache_types,\n        ))\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        let payload_json = payload_to_string(&draft.payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO sync_queue (action_type, payload, status, created_at, updated_at)\n            VALUES (?1, ?2, 'pending', ?3, ?3)\n            \"#,\n        )\n        .bind(draft.action_type.as_str())\n        .bind(&payload_json)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        sync_queue_id_from_i64(result.last_insert_rowid())\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        let now = Utc::now().timestamp();\n        let metadata = update\n            .metadata\n            .map(|value| serde_json::to_string(&value))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        let expiry_time = update.expiry.map(|expiry| {\n            let seconds = expiry.signed_duration_since(Utc::now()).num_seconds();\n            now + seconds.max(0)\n        });\n        let is_stale = update.is_stale.unwrap_or(false);\n\n        sqlx::query(\n            r#\"\n            INSERT INTO cache_metadata (\n                cache_key, cache_type, last_synced_at, last_accessed_at,\n                data_version, is_stale, expiry_time, metadata, doc_version, blob_hash, payload_bytes\n            ) VALUES (?1, ?2, ?3, ?3, 1, ?4, ?5, ?6, ?7, ?8, ?9)\n            ON CONFLICT(cache_key) DO UPDATE SET\n                cache_type = excluded.cache_type,\n                last_synced_at = excluded.last_synced_at,\n                last_accessed_at = excluded.last_accessed_at,\n                data_version = data_version + 1,\n                is_stale = excluded.is_stale,\n                expiry_time = excluded.expiry_time,\n                metadata = excluded.metadata,\n                doc_version = excluded.doc_version,\n                blob_hash = excluded.blob_hash,\n                payload_bytes = excluded.payload_bytes\n            \"#,\n        )\n        .bind(update.cache_key.as_str())\n        .bind(update.cache_type.as_str())\n        .bind(now)\n        .bind(if is_stale { 1 } else { 0 })\n        .bind(expiry_time)\n        .bind(metadata)\n        .bind(update.doc_version)\n        .bind(update.blob_hash.as_deref())\n        .bind(update.payload_bytes)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        let update_id = Uuid::new_v4().to_string();\n        let created_at = Utc::now().timestamp();\n        let original = draft\n            .original_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated = payload_to_string(&draft.updated_data)?;\n\n        sqlx::query(\n            r#\"\n            INSERT INTO optimistic_updates (\n                update_id, entity_type, entity_id, original_data,\n                updated_data, is_confirmed, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(&update_id)\n        .bind(draft.entity_type.as_str())\n        .bind(draft.entity_id.as_str())\n        .bind(&original)\n        .bind(&updated)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        optimistic_update_id_from_string(update_id)\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        let confirmed_at = Utc::now().timestamp();\n\n        sqlx::query(\n            r#\"\n            UPDATE optimistic_updates\n            SET is_confirmed = 1, confirmed_at = ?1\n            WHERE update_id = ?2\n            \"#,\n        )\n        .bind(confirmed_at)\n        .bind(update_id.as_str())\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        let update = sqlx::query_as::<_, (Option<String>,)>(\n            r#\"\n                SELECT original_data FROM optimistic_updates\n                WHERE update_id = ?1\n                \"#,\n        )\n        .bind(update_id.as_str())\n        .fetch_optional(self.pool())\n        .await?;\n\n        if let Some((original_data,)) = update {\n            sqlx::query(r#\"DELETE FROM optimistic_updates WHERE update_id = ?1\"#)\n                .bind(update_id.as_str())\n                .execute(self.pool())\n                .await?;\n\n            return payload_from_optional_json_str(original_data);\n        }\n\n        Ok(None)\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        let now = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            DELETE FROM cache_metadata\n            WHERE expiry_time IS NOT NULL AND expiry_time < ?1\n            \"#,\n        )\n        .bind(now)\n        .execute(self.pool())\n        .await?;\n\n        result\n            .rows_affected()\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed u32\".to_string()))\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        let conflict_data = update\n            .conflict_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated_at = update.updated_at.timestamp();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO sync_status (\n                entity_type, entity_id, local_version, last_local_update,\n                sync_status, conflict_data\n            ) VALUES (?1, ?2, 1, ?3, ?4, ?5)\n            ON CONFLICT(entity_type, entity_id) DO UPDATE SET\n                local_version = local_version + 1,\n                last_local_update = excluded.last_local_update,\n                sync_status = excluded.sync_status,\n                conflict_data = excluded.conflict_data\n            \"#,\n        )\n        .bind(update.entity_type.as_str())\n        .bind(update.entity_id.as_str())\n        .bind(updated_at)\n        .bind(update.sync_status.as_str().as_ref())\n        .bind(&conflict_data)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\n        SqliteOfflinePersistence::enqueue_if_missing(self, action).await\n    }\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError> {\n        let limit = limit.unwrap_or(25).clamp(1, 200);\n        SqliteOfflinePersistence::list_recent_sync_queue(self, limit).await\n    }\n\n    async fn pending_sync_items(&self) -> Result<Vec<SyncQueueItem>, AppError> {\n        SqliteOfflinePersistence::list_pending_sync_queue(self).await\n    }\n\n    async fn stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError> {\n        SqliteOfflinePersistence::list_stale_cache_entries(self).await\n    }\n\n    async fn unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError> {\n        SqliteOfflinePersistence::list_unconfirmed_updates(self).await\n    }\n\n    async fn sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError> {\n        SqliteOfflinePersistence::list_sync_conflicts(self).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::offline::{\n        CacheMetadataUpdate, OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft,\n        SyncStatusUpdate,\n    };\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{\n        CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n        SyncQueueStatus, SyncStatus,\n    };\n    use chrono::Utc;\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    const PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    async fn setup_persistence() -> SqliteOfflinePersistence {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .unwrap();\n\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\n\n        SqliteOfflinePersistence::new(pool)\n    }\n\n    fn sample_draft() -> OfflineActionDraft {\n        OfflineActionDraft::new(\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\n            OfflineActionType::new(\"create_post\".to_string()).unwrap(),\n            Some(EntityId::new(\"post_123\".to_string()).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"content\":\"test\"}\"#).unwrap(),\n        )\n    }\n\n    #[tokio::test]\n    async fn test_save_offline_action() {\n        let persistence = setup_persistence().await;\n        let saved = persistence.save_action(sample_draft()).await.unwrap();\n\n        assert_eq!(saved.action.user_pubkey.as_hex(), PUBKEY);\n        assert_eq!(saved.action.sync_status, SyncStatus::Pending);\n        assert!(!saved.action.payload.as_json().is_null());\n    }\n\n    #[tokio::test]\n    async fn test_list_offline_actions() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let actions = persistence\n            .list_actions(OfflineActionFilter::new(\n                Some(PublicKey::from_hex_str(PUBKEY).unwrap()),\n                Some(false),\n                None,\n            ))\n            .await\n            .unwrap();\n\n        assert_eq!(actions.len(), 1);\n        assert_eq!(actions[0].user_pubkey.as_hex(), PUBKEY);\n    }\n\n    #[tokio::test]\n    async fn test_enqueue_and_pending_queue() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let unsynced = persistence\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\n            .await\n            .unwrap();\n        let action = unsynced.first().unwrap();\n\n        let inserted = persistence.enqueue_if_missing(action).await.unwrap();\n        assert!(inserted);\n\n        // 重複登録は false を返す\n        let duplicated = persistence.enqueue_if_missing(action).await.unwrap();\n        assert!(!duplicated);\n\n        let pending = persistence.list_pending_sync_queue().await.unwrap();\n        assert_eq!(pending.len(), 1);\n        assert_eq!(pending[0].status, SyncQueueStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn test_cache_metadata_and_status() {\n        let persistence = setup_persistence().await;\n        persistence\n            .upsert_cache_metadata(CacheMetadataUpdate {\n                cache_key: CacheKey::new(\"posts\".to_string()).unwrap(),\n                cache_type: CacheType::new(\"topic\".to_string()).unwrap(),\n                metadata: Some(serde_json::json!({\"last_id\": \"1\"})),\n                expiry: Some(Utc::now()),\n                is_stale: Some(true),\n                doc_version: None,\n                blob_hash: None,\n                payload_bytes: None,\n            })\n            .await\n            .unwrap();\n\n        let status = persistence.cache_status().await.unwrap();\n        assert_eq!(status.total_items, 1);\n        assert_eq!(status.stale_items, 1);\n        assert_eq!(status.cache_types.len(), 1);\n        assert!(status.cache_types[0].is_stale);\n    }\n\n    #[tokio::test]\n    async fn test_optimistic_update_lifecycle() {\n        let persistence = setup_persistence().await;\n        let draft = OptimisticUpdateDraft::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_1\".to_string()).unwrap(),\n            Some(OfflinePayload::from_json_str(r#\"{\"likes\":10}\"#).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"likes\":11}\"#).unwrap(),\n        );\n\n        let update_id = persistence.save_optimistic_update(draft).await.unwrap();\n        persistence\n            .confirm_optimistic_update(update_id.clone())\n            .await\n            .unwrap();\n\n        let rollback_id = persistence\n            .save_optimistic_update(OptimisticUpdateDraft::new(\n                EntityType::new(\"post\".to_string()).unwrap(),\n                EntityId::new(\"post_2\".to_string()).unwrap(),\n                Some(OfflinePayload::from_json_str(r#\"{\"likes\":1}\"#).unwrap()),\n                OfflinePayload::from_json_str(r#\"{\"likes\":2}\"#).unwrap(),\n            ))\n            .await\n            .unwrap();\n\n        let rolled_back = persistence\n            .rollback_optimistic_update(rollback_id)\n            .await\n            .unwrap();\n        assert!(rolled_back.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_sync_status_update() {\n        let persistence = setup_persistence().await;\n        let update = SyncStatusUpdate::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_3\".to_string()).unwrap(),\n            SyncStatus::Pending,\n            None,\n            Utc::now(),\n        );\n        persistence.update_sync_status(update).await.unwrap();\n\n        let conflicts = persistence.list_sync_conflicts().await.unwrap();\n        assert_eq!(conflicts.len(), 1);\n        assert_eq!(conflicts[0].entity_id.to_string(), \"post_3\");\n    }\n}\n","traces":[{"line":32,"address":[24754816],"length":1,"stats":{"Line":5}},{"line":36,"address":[24638192],"length":1,"stats":{"Line":2}},{"line":40,"address":[24639247,24638409,24638208,24638467,24639325,24638240,24638275,24638221],"length":1,"stats":{"Line":10}},{"line":41,"address":[25785693,25784971,25784822,25785095],"length":1,"stats":{"Line":5}},{"line":51,"address":[24639256,24638900,24638740,24638783],"length":1,"stats":{"Line":5}},{"line":52,"address":[24851980,24852051],"length":1,"stats":{"Line":5}},{"line":53,"address":[24639090,24638944,24638987,24639225],"length":1,"stats":{"Line":5}},{"line":54,"address":[24751802,24751901,24751140,24752061,24752221,24752421],"length":1,"stats":{"Line":10}},{"line":56,"address":[24752555,24752394],"length":1,"stats":{"Line":5}},{"line":57,"address":[24752598],"length":1,"stats":{"Line":1}},{"line":60,"address":[24756748,24756497,24757121,24756672,24757023,24757330,24756818,24757273],"length":1,"stats":{"Line":21}},{"line":61,"address":[24721391,24721467],"length":1,"stats":{"Line":4}},{"line":62,"address":[25786347],"length":1,"stats":{"Line":3}},{"line":63,"address":[24756664],"length":1,"stats":{"Line":2}},{"line":65,"address":[24853219,24853354,24853657,24851526,24853263,24853503],"length":1,"stats":{"Line":15}},{"line":67,"address":[24753253],"length":1,"stats":{"Line":4}},{"line":70,"address":[24722735,24722232,24722393,24722240,24722618,24722224,24722275],"length":1,"stats":{"Line":16}},{"line":78,"address":[24759201,24759343,24759249,24759481],"length":1,"stats":{"Line":8}},{"line":79,"address":[24716234,24715761,24715492,24716007,24715848,24715655],"length":1,"stats":{"Line":12}},{"line":81,"address":[24641762,24641581],"length":1,"stats":{"Line":5}},{"line":84,"address":[24760192,24760224,24760742,24760404,24760869,24760204,24760259,24760900],"length":1,"stats":{"Line":4}},{"line":92,"address":[24855275,24855662,24855370,24855228],"length":1,"stats":{"Line":2}},{"line":93,"address":[18896715,18896856,18896618],"length":1,"stats":{"Line":2}},{"line":94,"address":[24724164,24723939,24724323,24724045,24723663,24724553],"length":1,"stats":{"Line":4}},{"line":96,"address":[18897276,18897460],"length":1,"stats":{"Line":2}},{"line":99,"address":[18897754,18897600,18897608,18897651,18897616,18897794,18898221],"length":1,"stats":{"Line":10}},{"line":100,"address":[24761822,24761722],"length":1,"stats":{"Line":5}},{"line":109,"address":[24856743],"length":1,"stats":{"Line":3}},{"line":110,"address":[18898199,18898077,18897903,18897983],"length":1,"stats":{"Line":5}},{"line":111,"address":[24725301,24725478,24725877,24725638,24725390,24724997],"length":1,"stats":{"Line":10}},{"line":113,"address":[24757187,24757000],"length":1,"stats":{"Line":5}},{"line":116,"address":[24762963,24762928,24763306,24763423,24762920,24762912,24763081],"length":1,"stats":{"Line":10}},{"line":124,"address":[18899185,18899279,18899137,18899417],"length":1,"stats":{"Line":5}},{"line":125,"address":[11047460],"length":1,"stats":{"Line":10}},{"line":127,"address":[24727202,24727021],"length":1,"stats":{"Line":5}},{"line":130,"address":[24727352,24727738,24727360,24727855,24727395,24727513,24727344],"length":1,"stats":{"Line":10}},{"line":149,"address":[24646033,24646081,24646175,24646313],"length":1,"stats":{"Line":5}},{"line":150,"address":[24652967,24653546,24653073,24652804,24653319,24653160],"length":1,"stats":{"Line":10}},{"line":152,"address":[24653666,24653485],"length":1,"stats":{"Line":5}},{"line":155,"address":[18901341,18901360,18901795,18901538,18901916,18901328,18901395],"length":1,"stats":{"Line":8}},{"line":162,"address":[24763986],"length":1,"stats":{"Line":2}},{"line":163,"address":[24765736,24765878,24765642,24765562],"length":1,"stats":{"Line":4}},{"line":164,"address":[11700775],"length":1,"stats":{"Line":10}},{"line":166,"address":[24661753],"length":1,"stats":{"Line":3}},{"line":172,"address":[24831003,24829146,24828784,24828671,24832637,24830880,24828843,24829015,24832825],"length":1,"stats":{"Line":9}},{"line":179,"address":[24719486],"length":1,"stats":{"Line":2}},{"line":180,"address":[24925809],"length":1,"stats":{"Line":2}},{"line":181,"address":[24726535],"length":1,"stats":{"Line":2}},{"line":182,"address":[24712813],"length":1,"stats":{"Line":2}},{"line":185,"address":[24719705,24719635],"length":1,"stats":{"Line":4}},{"line":186,"address":[25898526,25897203,25897424,25897300],"length":1,"stats":{"Line":4}},{"line":187,"address":[24826024,24825866],"length":1,"stats":{"Line":4}},{"line":197,"address":[25897624,25897667,25897779,25898504],"length":1,"stats":{"Line":4}},{"line":198,"address":[24727323,24727445,24728041],"length":1,"stats":{"Line":4}},{"line":199,"address":[24797824,24795221,24797808,24795769,24795360],"length":1,"stats":{"Line":8}},{"line":200,"address":[24713848],"length":1,"stats":{"Line":2}},{"line":201,"address":[24713925],"length":1,"stats":{"Line":2}},{"line":202,"address":[24713999],"length":1,"stats":{"Line":2}},{"line":203,"address":[24832178,24832295,24832404,24832506],"length":1,"stats":{"Line":4}},{"line":204,"address":[11919276],"length":1,"stats":{"Line":8}},{"line":206,"address":[24831389,24831510],"length":1,"stats":{"Line":4}},{"line":207,"address":[24825124,24827766,24827582,24827644,24828131],"length":1,"stats":{"Line":6}},{"line":209,"address":[24928476,24928625],"length":1,"stats":{"Line":6}},{"line":212,"address":[11877606],"length":1,"stats":{"Line":8}},{"line":216,"address":[24791425],"length":1,"stats":{"Line":2}},{"line":219,"address":[24730676,24730754],"length":1,"stats":{"Line":4}},{"line":220,"address":[24730812],"length":1,"stats":{"Line":2}},{"line":221,"address":[18971430],"length":1,"stats":{"Line":2}},{"line":224,"address":[24833727,24833832],"length":1,"stats":{"Line":4}},{"line":225,"address":[24717216],"length":1,"stats":{"Line":2}},{"line":226,"address":[18971594],"length":1,"stats":{"Line":2}},{"line":229,"address":[24724035],"length":1,"stats":{"Line":2}},{"line":231,"address":[18971664],"length":1,"stats":{"Line":2}},{"line":232,"address":[24731159],"length":1,"stats":{"Line":0}},{"line":233,"address":[24835757],"length":1,"stats":{"Line":0}},{"line":236,"address":[24731194],"length":1,"stats":{"Line":2}},{"line":237,"address":[24731263,24731486,24731620,24730362,24732053],"length":1,"stats":{"Line":6}},{"line":239,"address":[24731986,24732179],"length":1,"stats":{"Line":4}},{"line":242,"address":[11817095,11817124],"length":1,"stats":{"Line":4}},{"line":250,"address":[24837749,24838260,24837792,24837920],"length":1,"stats":{"Line":2}},{"line":251,"address":[24719648,24719763,24719931],"length":1,"stats":{"Line":2}},{"line":252,"address":[24838314,24838773,24838182,24837441,24838059,24838483],"length":1,"stats":{"Line":4}},{"line":254,"address":[24934205,24933690,24933480,24933968],"length":1,"stats":{"Line":2}},{"line":259,"address":[25904662],"length":1,"stats":{"Line":1}},{"line":261,"address":[24802326,24803321,24803389,24802517],"length":1,"stats":{"Line":4}},{"line":262,"address":[25906556,25906426,25905704,25906372],"length":1,"stats":{"Line":4}},{"line":263,"address":[24729279],"length":1,"stats":{"Line":1}},{"line":264,"address":[24803927,24803426],"length":1,"stats":{"Line":2}},{"line":265,"address":[24803935],"length":1,"stats":{"Line":1}},{"line":266,"address":[24839127],"length":1,"stats":{"Line":1}},{"line":268,"address":[24722663,24722610,24719174,24722877,24721178],"length":1,"stats":{"Line":5}},{"line":270,"address":[24804465],"length":1,"stats":{"Line":1}},{"line":271,"address":[24736745],"length":1,"stats":{"Line":1}},{"line":274,"address":[24797669,24797624],"length":1,"stats":{"Line":2}},{"line":283,"address":[24835948],"length":1,"stats":{"Line":1}},{"line":284,"address":[24839892,24839785,24840074,24840001],"length":1,"stats":{"Line":2}},{"line":285,"address":[24934490,24936501,24936441,24934733,24934287,24932267],"length":1,"stats":{"Line":5}},{"line":286,"address":[24796345,24796220],"length":1,"stats":{"Line":2}},{"line":297,"address":[24834795,24835054,24834636,24834679],"length":1,"stats":{"Line":2}},{"line":298,"address":[24840395,24840504,24840606],"length":1,"stats":{"Line":2}},{"line":299,"address":[19578228],"length":1,"stats":{"Line":4}},{"line":301,"address":[18978362,18978191],"length":1,"stats":{"Line":2}},{"line":307,"address":[24798734],"length":1,"stats":{"Line":1}},{"line":310,"address":[24799184,24799135,24799231,24799992,24799413,24802237,24799537],"length":1,"stats":{"Line":10}},{"line":316,"address":[24739138,24739007,24738907,24738856],"length":1,"stats":{"Line":4}},{"line":317,"address":[11296996],"length":1,"stats":{"Line":9}},{"line":319,"address":[24731155,24726015,24725811,24726268],"length":1,"stats":{"Line":6}},{"line":324,"address":[24740114,24739953],"length":1,"stats":{"Line":4}},{"line":325,"address":[24844650,24849488,24849498],"length":1,"stats":{"Line":9}},{"line":343,"address":[18980838],"length":1,"stats":{"Line":3}},{"line":345,"address":[24726701,24726909,24726588,24726836],"length":1,"stats":{"Line":12}},{"line":346,"address":[24845199],"length":1,"stats":{"Line":3}},{"line":347,"address":[24803822],"length":1,"stats":{"Line":3}},{"line":348,"address":[24803894],"length":1,"stats":{"Line":3}},{"line":349,"address":[24736121,24736170],"length":1,"stats":{"Line":6}},{"line":350,"address":[18983683],"length":1,"stats":{"Line":3}},{"line":352,"address":[24810867,24810913],"length":1,"stats":{"Line":6}},{"line":353,"address":[24736207,24736297],"length":1,"stats":{"Line":6}},{"line":355,"address":[24843941,24843936],"length":1,"stats":{"Line":2}},{"line":357,"address":[24736405,24736336],"length":1,"stats":{"Line":5}},{"line":358,"address":[24842267],"length":1,"stats":{"Line":2}},{"line":361,"address":[18983930,18984574,18983786],"length":1,"stats":{"Line":7}},{"line":362,"address":[18984059,18984157,18983999],"length":1,"stats":{"Line":9}},{"line":364,"address":[24846365],"length":1,"stats":{"Line":3}},{"line":366,"address":[25913311],"length":1,"stats":{"Line":3}},{"line":369,"address":[24812784,24812797],"length":1,"stats":{"Line":2}},{"line":371,"address":[24804849,24804575],"length":1,"stats":{"Line":6}},{"line":372,"address":[24846651],"length":1,"stats":{"Line":3}},{"line":375,"address":[24848660,24848614],"length":1,"stats":{"Line":6}},{"line":376,"address":[24737284,24737162],"length":1,"stats":{"Line":6}},{"line":377,"address":[24848794],"length":1,"stats":{"Line":3}},{"line":379,"address":[25913964,25913892,25913808],"length":1,"stats":{"Line":3}},{"line":381,"address":[24943503],"length":1,"stats":{"Line":1}},{"line":383,"address":[24843308],"length":1,"stats":{"Line":1}},{"line":386,"address":[24805904,24805917],"length":1,"stats":{"Line":0}},{"line":388,"address":[25914489,25914078],"length":1,"stats":{"Line":2}},{"line":389,"address":[24805440],"length":1,"stats":{"Line":1}},{"line":391,"address":[25914171],"length":1,"stats":{"Line":1}},{"line":392,"address":[24805292],"length":1,"stats":{"Line":1}},{"line":393,"address":[24843430],"length":1,"stats":{"Line":1}},{"line":394,"address":[24744528],"length":1,"stats":{"Line":1}},{"line":401,"address":[18981245,18981315],"length":1,"stats":{"Line":4}},{"line":402,"address":[24843903,24843948,24843685,24843809],"length":1,"stats":{"Line":9}},{"line":403,"address":[18981989,18982122,18982201,18982376,18982076,18981674],"length":1,"stats":{"Line":15}},{"line":404,"address":[24809544,24810662,24809213,24809330,24809170],"length":1,"stats":{"Line":6}},{"line":405,"address":[24802758,24802586],"length":1,"stats":{"Line":6}},{"line":408,"address":[24849665,24849648,24846473],"length":1,"stats":{"Line":9}},{"line":409,"address":[24809713,24809786],"length":1,"stats":{"Line":6}},{"line":412,"address":[24806005,24806000],"length":1,"stats":{"Line":2}},{"line":413,"address":[25911844,25911904],"length":1,"stats":{"Line":6}},{"line":416,"address":[24735208,24738224,24738241],"length":1,"stats":{"Line":5}},{"line":417,"address":[24941504,24941571],"length":1,"stats":{"Line":6}},{"line":420,"address":[24813008,24813013],"length":1,"stats":{"Line":2}},{"line":421,"address":[18983026],"length":1,"stats":{"Line":3}},{"line":422,"address":[24803148],"length":1,"stats":{"Line":3}},{"line":423,"address":[24803188],"length":1,"stats":{"Line":3}},{"line":424,"address":[24846892],"length":1,"stats":{"Line":3}},{"line":425,"address":[18982938],"length":1,"stats":{"Line":3}},{"line":426,"address":[24845282],"length":1,"stats":{"Line":3}},{"line":428,"address":[24810202],"length":1,"stats":{"Line":3}},{"line":433,"address":[24806112,24806149,24801992],"length":1,"stats":{"Line":5}},{"line":435,"address":[24802110],"length":1,"stats":{"Line":2}},{"line":438,"address":[24940550],"length":1,"stats":{"Line":2}},{"line":442,"address":[24733754,24731992,24731763,24731647,24732163,24731885,24731728,24733045,24733078,24733660],"length":1,"stats":{"Line":14}},{"line":443,"address":[24739133,24738992,24738919,24739860],"length":1,"stats":{"Line":5}},{"line":444,"address":[24945554,24945399],"length":1,"stats":{"Line":6}},{"line":452,"address":[24849233,24849346,24849190,24849694],"length":1,"stats":{"Line":7}},{"line":453,"address":[24807306],"length":1,"stats":{"Line":3}},{"line":454,"address":[24746585],"length":1,"stats":{"Line":4}},{"line":455,"address":[24807345,24807425,24807615,24807519],"length":1,"stats":{"Line":7}},{"line":456,"address":[24733296,24733485,24733133,24731912,24732935,24732992],"length":1,"stats":{"Line":16}},{"line":458,"address":[24846166,24846286],"length":1,"stats":{"Line":5}},{"line":461,"address":[24846995,24849681,24847178,24846687,24849002,24846559,24849567,24849948,24850213,24846879,24846640,24849104],"length":1,"stats":{"Line":11}},{"line":462,"address":[24809047,24809117],"length":1,"stats":{"Line":5}},{"line":463,"address":[24734581,24736383,24734703,24735023],"length":1,"stats":{"Line":5}},{"line":465,"address":[24854288,24854272],"length":1,"stats":{"Line":5}},{"line":467,"address":[24816495,24819282,24819264],"length":1,"stats":{"Line":0}},{"line":468,"address":[24741902,24741676,24744688],"length":1,"stats":{"Line":6}},{"line":469,"address":[24854558],"length":1,"stats":{"Line":2}},{"line":470,"address":[24812639,24812585],"length":1,"stats":{"Line":2}},{"line":472,"address":[24748910],"length":1,"stats":{"Line":2}},{"line":493,"address":[24853513,24854649,24853556,24853675],"length":1,"stats":{"Line":4}},{"line":494,"address":[24853813,24853691,24854617],"length":1,"stats":{"Line":4}},{"line":495,"address":[24810125],"length":1,"stats":{"Line":3}},{"line":496,"address":[24817134],"length":1,"stats":{"Line":3}},{"line":498,"address":[24948787],"length":1,"stats":{"Line":3}},{"line":499,"address":[24749606,24749557],"length":1,"stats":{"Line":5}},{"line":500,"address":[24817827,24817496,24817374,24817095],"length":1,"stats":{"Line":5}},{"line":501,"address":[24848688,24848777],"length":1,"stats":{"Line":5}},{"line":502,"address":[24949153,24949105,24949247,24949348],"length":1,"stats":{"Line":6}},{"line":503,"address":[24852883,24853101,24853532,24850845,24852823,24853266],"length":1,"stats":{"Line":12}},{"line":505,"address":[24811384],"length":1,"stats":{"Line":4}},{"line":508,"address":[24755327,24754766,24755059,24751952,24752141,24754045,24751987,24754161,24752248,24752476,24751839],"length":1,"stats":{"Line":4}},{"line":512,"address":[24820281,24820205],"length":1,"stats":{"Line":2}},{"line":513,"address":[24752628,24752564],"length":1,"stats":{"Line":2}},{"line":514,"address":[24745689,24745991,24747157],"length":1,"stats":{"Line":1}},{"line":516,"address":[24816272,24816288],"length":1,"stats":{"Line":2}},{"line":518,"address":[24739442,24739292,24739125,24740348],"length":1,"stats":{"Line":2}},{"line":528,"address":[25922697,25922662],"length":1,"stats":{"Line":2}},{"line":529,"address":[24754086,24753369,24753287,24753482],"length":1,"stats":{"Line":2}},{"line":530,"address":[25922945,25922830,25923360],"length":1,"stats":{"Line":2}},{"line":531,"address":[18994169],"length":1,"stats":{"Line":1}},{"line":532,"address":[24821459],"length":1,"stats":{"Line":1}},{"line":533,"address":[24740015],"length":1,"stats":{"Line":1}},{"line":534,"address":[25922988,25923192,25923103,25923329],"length":1,"stats":{"Line":2}},{"line":535,"address":[11909585],"length":1,"stats":{"Line":4}},{"line":537,"address":[24740745],"length":1,"stats":{"Line":1}},{"line":540,"address":[24816869,24816464,24817440,24817409,24816399,24816499,24817941,24817834,24816621,24816728],"length":1,"stats":{"Line":5}},{"line":544,"address":[18996626,18996562],"length":1,"stats":{"Line":2}},{"line":553,"address":[24823977],"length":1,"stats":{"Line":1}},{"line":554,"address":[24749249,24749367,24749174,24749610],"length":1,"stats":{"Line":2}},{"line":555,"address":[24955857,24955671,24955768],"length":1,"stats":{"Line":2}},{"line":556,"address":[11333341],"length":1,"stats":{"Line":4}},{"line":558,"address":[24855890],"length":1,"stats":{"Line":1}},{"line":561,"address":[11335107,11335085],"length":1,"stats":{"Line":5}},{"line":571,"address":[24856773,24856730,24856886,24857190],"length":1,"stats":{"Line":2}},{"line":572,"address":[24744198,24744304,24744448],"length":1,"stats":{"Line":2}},{"line":573,"address":[25927544,25927200,25927392,25927791,25927284,25926689],"length":1,"stats":{"Line":4}},{"line":575,"address":[18999218,18999344],"length":1,"stats":{"Line":2}},{"line":576,"address":[24746258,24746006,24745302,24746209,24745424,24745908,24745536,24745216,24745079],"length":1,"stats":{"Line":7}},{"line":577,"address":[24826744,24826857,24826701,24827139],"length":1,"stats":{"Line":2}},{"line":578,"address":[24745590,24745353,24745459],"length":1,"stats":{"Line":2}},{"line":579,"address":[24827317,24826987,24825331,24827083,24827476,24827681],"length":1,"stats":{"Line":4}},{"line":581,"address":[24864388,24864531],"length":1,"stats":{"Line":2}},{"line":584,"address":[24826630],"length":1,"stats":{"Line":0}},{"line":587,"address":[24761029,24760320,24760281,24761571,24760442,24760554,24760355],"length":1,"stats":{"Line":5}},{"line":588,"address":[24828419],"length":1,"stats":{"Line":1}},{"line":596,"address":[24960130],"length":1,"stats":{"Line":1}},{"line":597,"address":[24761007,24760826,24760746,24760920],"length":1,"stats":{"Line":2}},{"line":598,"address":[24865456,24864997,24865598,24865942,24865758,24865510],"length":1,"stats":{"Line":4}},{"line":600,"address":[19002045,19001934],"length":1,"stats":{"Line":2}},{"line":603,"address":[24829358,24829344],"length":1,"stats":{"Line":0}},{"line":606,"address":[11930174],"length":1,"stats":{"Line":8}},{"line":607,"address":[24862752,24861243,24861350,24861575],"length":1,"stats":{"Line":4}},{"line":609,"address":[24825728,24825744],"length":1,"stats":{"Line":2}},{"line":611,"address":[24748792,24748961],"length":1,"stats":{"Line":4}},{"line":626,"address":[24823748,24823635,24824618,24823592],"length":1,"stats":{"Line":4}},{"line":627,"address":[24862000,24861876,24862698],"length":1,"stats":{"Line":4}},{"line":628,"address":[24962446],"length":1,"stats":{"Line":2}},{"line":629,"address":[25932102,25932639,25932294,25932051],"length":1,"stats":{"Line":4}},{"line":630,"address":[19003969,19003890],"length":1,"stats":{"Line":4}},{"line":631,"address":[19003929,19004071,19003977,19003643,19004214,19004285],"length":1,"stats":{"Line":4}},{"line":632,"address":[19592326,19592273],"length":1,"stats":{"Line":10}},{"line":634,"address":[24832045],"length":1,"stats":{"Line":2}},{"line":637,"address":[24869733,24869559,24870313,24870052,24869616,24869651,24869839,24869816],"length":1,"stats":{"Line":16}},{"line":638,"address":[11933703],"length":1,"stats":{"Line":4}},{"line":641,"address":[24865353,24865032,24864832,24864781,24865055,24865613,24864867,24864949],"length":1,"stats":{"Line":5}},{"line":645,"address":[24827079],"length":1,"stats":{"Line":1}},{"line":646,"address":[11946455],"length":1,"stats":{"Line":2}},{"line":649,"address":[24827784,24827619,24827535,24827701,24828011,24828272,24827807,24827584],"length":1,"stats":{"Line":17}},{"line":650,"address":[24834656,24834841,24834971],"length":1,"stats":{"Line":7}},{"line":653,"address":[19008181,19008287,19008064,19008491,19008752,19008264,19008099,19008015],"length":1,"stats":{"Line":13}},{"line":654,"address":[19008208,19008393,19008523],"length":1,"stats":{"Line":5}},{"line":657,"address":[19009055,19008832,19009032,19008783,19008949,19009520,19008867,19009259],"length":1,"stats":{"Line":12}},{"line":658,"address":[25937486,25937184,25937373],"length":1,"stats":{"Line":6}},{"line":661,"address":[24873619,24873784,24873701,24874272,24874011,24873584,24873535,24873807],"length":1,"stats":{"Line":12}},{"line":662,"address":[11882487],"length":1,"stats":{"Line":6}}],"covered":251,"coverable":257},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","bootstrap.rs"],"content":"use crate::application::services::p2p_service::{P2PService, P2PStack};\r\nuse crate::domain::p2p::P2PEvent;\r\nuse crate::infrastructure::p2p::{bootstrap_config, metrics};\r\nuse crate::shared::config::AppConfig;\r\nuse anyhow::Context;\r\nuse base64::prelude::*;\r\nuse rand_core::{OsRng, TryRngCore};\r\nuse std::path::{Path, PathBuf};\r\nuse tauri::Manager;\r\nuse tokio::fs;\r\nuse tokio::sync::broadcast;\r\n\r\npub struct P2PBootstrapper {\r\n    app_data_dir: PathBuf,\r\n    config: AppConfig,\r\n}\r\n\r\nimpl P2PBootstrapper {\r\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\r\n        let app_data_dir = app_handle\r\n            .path()\r\n            .app_data_dir()\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to get app data dir: {}\", e))?;\r\n\r\n        tracing::info!(\"App data directory: {:?}\", app_data_dir);\r\n\r\n        if !app_data_dir.exists() {\r\n            tracing::info!(\"Creating app data directory...\");\r\n            fs::create_dir_all(&app_data_dir)\r\n                .await\r\n                .with_context(|| format!(\"Failed to create app data dir at {app_data_dir:?}\"))?;\r\n            tracing::info!(\"App data directory created successfully\");\r\n        } else {\r\n            tracing::info!(\"App data directory already exists\");\r\n        }\r\n\r\n        let mut config = AppConfig::from_env();\r\n        let selection = bootstrap_config::load_effective_bootstrap_nodes();\r\n        config.network.bootstrap_peers = selection.nodes.clone();\r\n        config.network.bootstrap_source = selection.source;\r\n        tracing::info!(\r\n            \"Bootstrap peers source={:?} count={}\",\r\n            selection.source,\r\n            selection.nodes.len()\r\n        );\r\n\r\n        if let Err(err) = config.validate() {\r\n            return Err(anyhow::anyhow!(\r\n                \"Invalid application configuration: {}\",\r\n                err\r\n            ));\r\n        }\r\n\r\n        Ok(Self {\r\n            app_data_dir,\r\n            config,\r\n        })\r\n    }\r\n\r\n    pub fn app_data_dir(&self) -> &Path {\r\n        &self.app_data_dir\r\n    }\r\n\r\n    pub fn config(&self) -> &AppConfig {\r\n        &self.config\r\n    }\r\n\r\n    fn node_key_path(&self) -> PathBuf {\r\n        self.app_data_dir.join(\"p2p_node_secret.key\")\r\n    }\r\n\r\n    pub async fn build_stack(\r\n        &self,\r\n        event_sender: broadcast::Sender<P2PEvent>,\r\n    ) -> anyhow::Result<P2PStack> {\r\n        metrics::reset_all();\r\n        let secret_key = self.ensure_iroh_secret_key().await?;\r\n        let builder = P2PService::builder(secret_key, self.config.network.clone())\r\n            .with_event_sender(event_sender);\r\n\r\n        builder\r\n            .build()\r\n            .await\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to build P2P stack: {}\", e))\r\n    }\r\n\r\n    async fn ensure_iroh_secret_key(&self) -> anyhow::Result<iroh::SecretKey> {\r\n        let path = self.node_key_path();\r\n        match fs::read_to_string(&path).await {\r\n            Ok(contents) => {\r\n                let trimmed = contents.trim();\r\n                if trimmed.is_empty() {\r\n                    tracing::warn!(\r\n                        \"Persisted iroh secret key at {:?} was empty; regenerating\",\r\n                        path\r\n                    );\r\n                    return self.generate_and_store_secret(&path).await;\r\n                }\r\n\r\n                let bytes = BASE64_STANDARD.decode(trimmed).map_err(|e| {\r\n                    anyhow::anyhow!(\"Failed to decode persisted iroh secret key: {}\", e)\r\n                })?;\r\n                let secret_bytes: [u8; 32] = bytes\r\n                    .try_into()\r\n                    .map_err(|_| anyhow::anyhow!(\"Invalid iroh secret key length\"))?;\r\n                tracing::info!(\"Loaded persisted iroh secret key from {:?}\", path);\r\n                Ok(iroh::SecretKey::from_bytes(&secret_bytes))\r\n            }\r\n            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {\r\n                self.generate_and_store_secret(&path).await\r\n            }\r\n            Err(err) => {\r\n                tracing::warn!(\r\n                    \"Failed to read persisted iroh secret key at {:?}: {}. Regenerating.\",\r\n                    path,\r\n                    err\r\n                );\r\n                self.generate_and_store_secret(&path).await\r\n            }\r\n        }\r\n    }\r\n\r\n    async fn generate_and_store_secret(&self, path: &Path) -> anyhow::Result<iroh::SecretKey> {\r\n        let mut secret_bytes = [0u8; 32];\r\n        OsRng\r\n            .try_fill_bytes(&mut secret_bytes)\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to generate iroh secret key: {:?}\", e))?;\r\n        let encoded = BASE64_STANDARD.encode(secret_bytes);\r\n\r\n        if let Some(parent) = path.parent() {\r\n            fs::create_dir_all(parent).await?;\r\n        }\r\n\r\n        fs::write(path, encoded)\r\n            .await\r\n            .with_context(|| format!(\"Failed to write iroh secret key to {path:?}\"))?;\r\n\r\n        tracing::info!(\"Generated new iroh secret key at {:?}\", path);\r\n        Ok(iroh::SecretKey::from_bytes(&secret_bytes))\r\n    }\r\n\r\n    #[cfg(test)]\r\n    pub fn from_parts(app_data_dir: PathBuf, config: AppConfig) -> Self {\r\n        Self {\r\n            app_data_dir,\r\n            config,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use tempfile::TempDir;\r\n\r\n    fn test_bootstrapper(temp_dir: &TempDir) -> P2PBootstrapper {\r\n        P2PBootstrapper::from_parts(temp_dir.path().to_path_buf(), AppConfig::default())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn generates_secret_if_missing() {\r\n        let dir = TempDir::new().unwrap();\r\n        let bootstrapper = test_bootstrapper(&dir);\r\n        let secret = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n\r\n        let stored = tokio::fs::read_to_string(bootstrapper.node_key_path())\r\n            .await\r\n            .unwrap();\r\n        let stored_bytes = BASE64_STANDARD.decode(stored.trim()).unwrap();\r\n        let stored_secret =\r\n            iroh::SecretKey::from_bytes(&stored_bytes.try_into().expect(\"invalid length\"));\r\n\r\n        assert_eq!(secret.to_bytes(), stored_secret.to_bytes());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn reuses_existing_secret() {\r\n        let dir = TempDir::new().unwrap();\r\n        let bootstrapper = test_bootstrapper(&dir);\r\n        let first = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n        let second = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n\r\n        assert_eq!(first.to_bytes(), second.to_bytes());\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[16742108,16736744,16736959,16736736,16736768,16737014,16736830,16746465],"length":1,"stats":{"Line":0}},{"line":20,"address":[16598589,16598460,16598817,16603609],"length":1,"stats":{"Line":0}},{"line":23,"address":[25806160,25806183,25796657],"length":1,"stats":{"Line":0}},{"line":25,"address":[16737253,16867433,16867567,16737895,16737378],"length":1,"stats":{"Line":0}},{"line":27,"address":[16531562,16532690],"length":1,"stats":{"Line":0}},{"line":28,"address":[16736377,16607453,16608032,16607519,16736511],"length":1,"stats":{"Line":0}},{"line":29,"address":[16536094,16533255,16536229,16540564,16534280,16535982],"length":1,"stats":{"Line":0}},{"line":30,"address":[16527522,16523917,16529068,16529222,16527469],"length":1,"stats":{"Line":0}},{"line":31,"address":[16604021,16608662,16603890,16608640],"length":1,"stats":{"Line":0}},{"line":32,"address":[24304457,24430329,24304377,24430463],"length":1,"stats":{"Line":0}},{"line":34,"address":[16739033,16740631,16868921,16869055,16741132],"length":1,"stats":{"Line":0}},{"line":37,"address":[24303007],"length":1,"stats":{"Line":0}},{"line":38,"address":[16744038],"length":1,"stats":{"Line":0}},{"line":39,"address":[16612562,16612637],"length":1,"stats":{"Line":0}},{"line":40,"address":[16647896],"length":1,"stats":{"Line":0}},{"line":41,"address":[16649001,16649328],"length":1,"stats":{"Line":0}},{"line":47,"address":[16744849,16746051],"length":1,"stats":{"Line":0}},{"line":48,"address":[16746118,16746211],"length":1,"stats":{"Line":0}},{"line":54,"address":[16547282],"length":1,"stats":{"Line":0}},{"line":55,"address":[16547162],"length":1,"stats":{"Line":0}},{"line":56,"address":[16650086],"length":1,"stats":{"Line":0}},{"line":60,"address":[16615696],"length":1,"stats":{"Line":0}},{"line":61,"address":[16615701],"length":1,"stats":{"Line":0}},{"line":64,"address":[16652480],"length":1,"stats":{"Line":0}},{"line":65,"address":[16608792],"length":1,"stats":{"Line":0}},{"line":68,"address":[25806544],"length":1,"stats":{"Line":1}},{"line":69,"address":[16608832],"length":1,"stats":{"Line":1}},{"line":72,"address":[16608880],"length":1,"stats":{"Line":0}},{"line":76,"address":[24309486],"length":1,"stats":{"Line":0}},{"line":77,"address":[25807115,25806880,25807025,25807478,25806953],"length":1,"stats":{"Line":0}},{"line":78,"address":[16541901,16542110,16542288,16542000],"length":1,"stats":{"Line":0}},{"line":79,"address":[16651948],"length":1,"stats":{"Line":0}},{"line":81,"address":[16648489,16648099,16648591,16648153],"length":1,"stats":{"Line":0}},{"line":83,"address":[16654121,16653764,16653710,16652854,16653985],"length":1,"stats":{"Line":0}},{"line":84,"address":[16648703,16648688],"length":1,"stats":{"Line":0}},{"line":87,"address":[16652856,16653068,16653174,16652848,16652942,16653397,16652880,16656425],"length":1,"stats":{"Line":4}},{"line":88,"address":[16543183],"length":1,"stats":{"Line":1}},{"line":89,"address":[16749861,16749653,16749741,16749530],"length":1,"stats":{"Line":3}},{"line":90,"address":[16550848],"length":1,"stats":{"Line":1}},{"line":91,"address":[16551008,16550872],"length":1,"stats":{"Line":2}},{"line":92,"address":[16655613],"length":1,"stats":{"Line":1}},{"line":93,"address":[16553589,16670735,16670601,16551154,16554117],"length":1,"stats":{"Line":0}},{"line":97,"address":[11548245],"length":1,"stats":{"Line":0}},{"line":100,"address":[16544152,16546578,16551488,16544244,16544492],"length":1,"stats":{"Line":2}},{"line":101,"address":[16661354],"length":1,"stats":{"Line":0}},{"line":103,"address":[16750697,16750850,16752823,16751030],"length":1,"stats":{"Line":2}},{"line":105,"address":[24319792,24319801,24312918],"length":1,"stats":{"Line":0}},{"line":106,"address":[16770041,16650618,16770175,16651207,16650698],"length":1,"stats":{"Line":3}},{"line":107,"address":[16621090,16619986],"length":1,"stats":{"Line":2}},{"line":109,"address":[25813771,25813876,25809394],"length":1,"stats":{"Line":3}},{"line":110,"address":[11541484],"length":1,"stats":{"Line":4}},{"line":112,"address":[16623134],"length":1,"stats":{"Line":0}},{"line":113,"address":[24316778,24432943,24317306,24432809,24316618],"length":1,"stats":{"Line":0}},{"line":118,"address":[16625011,16623794,16618041,16625902],"length":1,"stats":{"Line":0}},{"line":123,"address":[16657682,16657664,16657712,16657930,16657994,16658730,16657759,16659218],"length":1,"stats":{"Line":4}},{"line":124,"address":[25817317],"length":1,"stats":{"Line":1}},{"line":125,"address":[16662160,16662610,16661852,16661984],"length":1,"stats":{"Line":2}},{"line":126,"address":[16626711],"length":1,"stats":{"Line":1}},{"line":127,"address":[16555355,16555344,16552288],"length":1,"stats":{"Line":0}},{"line":128,"address":[16552219,16552372],"length":1,"stats":{"Line":2}},{"line":130,"address":[16552384,16553138,16552485],"length":1,"stats":{"Line":4}},{"line":131,"address":[16659063,16658583,16657960,16659193,16658482,16658762],"length":1,"stats":{"Line":4}},{"line":134,"address":[16665117,16663068,16663407,16663297,16662437,16663542],"length":1,"stats":{"Line":6}},{"line":135,"address":[16546458,16545277,16546401,16546523,16546681],"length":1,"stats":{"Line":5}},{"line":136,"address":[16659590,16661430,16661408,16659459],"length":1,"stats":{"Line":1}},{"line":138,"address":[24321834,24433305,24321914,24433439,24322423],"length":1,"stats":{"Line":3}},{"line":139,"address":[16660114,16661122],"length":1,"stats":{"Line":3}},{"line":143,"address":[25820880],"length":1,"stats":{"Line":1}}],"covered":27,"coverable":68},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","bootstrap_config.rs"],"content":"//! Bootstrap node configuration helpers\nuse crate::shared::config::BootstrapSource;\nuse crate::shared::error::AppError;\nuse dirs;\nuse iroh::{EndpointAddr, EndpointId};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\nuse std::path::{Path, PathBuf};\nuse std::str::FromStr;\nuse tracing::{debug, info, trace, warn};\n\nfn find_bootstrap_config_path() -> Option<PathBuf> {\n    let primary = PathBuf::from(\"bootstrap_nodes.json\");\n    if primary.exists() {\n        return Some(primary);\n    }\n    let alt = PathBuf::from(\"src-tauri\").join(\"bootstrap_nodes.json\");\n    if alt.exists() {\n        return Some(alt);\n    }\n    None\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfig {\n    pub development: EnvironmentConfig,\n    pub staging: EnvironmentConfig,\n    pub production: EnvironmentConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EnvironmentConfig {\n    pub description: String,\n    pub nodes: Vec<String>,\n}\n\n#[derive(Debug, Clone)]\npub struct BootstrapSelection {\n    pub source: BootstrapSource,\n    pub nodes: Vec<String>,\n}\n\n#[derive(Debug, Clone)]\npub struct CliBootstrapInfo {\n    pub nodes: Vec<String>,\n    pub updated_at_ms: Option<u64>,\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CliBootstrapCacheFile {\n    nodes: Vec<String>,\n    updated_at_ms: Option<u64>,\n}\n\nimpl BootstrapConfig {\n    /// Load configuration from a JSON file\n    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, AppError> {\n        let content = fs::read_to_string(path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to read bootstrap config: {e}\"))\n        })?;\n\n        let config: BootstrapConfig = serde_json::from_str(&content).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to parse bootstrap config: {e}\"))\n        })?;\n\n        Ok(config)\n    }\n\n    /// Default configuration used when no file is available\n    pub fn default_config() -> Self {\n        Self {\n            development: EnvironmentConfig {\n                description: \"Local development bootstrap nodes\".to_string(),\n                nodes: vec![\"localhost:11223\".to_string(), \"localhost:11224\".to_string()],\n            },\n            staging: EnvironmentConfig {\n                description: \"Staging environment bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n            production: EnvironmentConfig {\n                description: \"Production bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n        }\n    }\n\n    /// Get node list for the given environment key\n    pub fn get_nodes(&self, environment: &str) -> Vec<String> {\n        match environment {\n            \"development\" | \"dev\" => self.development.nodes.clone(),\n            \"staging\" | \"stage\" => self.staging.nodes.clone(),\n            \"production\" | \"prod\" => self.production.nodes.clone(),\n            _ => {\n                warn!(\"Unknown environment: {}, using development\", environment);\n                self.development.nodes.clone()\n            }\n        }\n    }\n\n    /// Get SocketAddr list for the environment\n    pub fn get_socket_addrs(&self, environment: &str) -> Vec<SocketAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut addrs = Vec::new();\n\n        for node in nodes {\n            match node.parse::<SocketAddr>() {\n                Ok(addr) => addrs.push(addr),\n                Err(e) => {\n                    debug!(\"Failed to parse address {}: {}\", node, e);\n                }\n            }\n        }\n\n        addrs\n    }\n\n    /// Convert entries in the form \"<node_id>@<host:port>\" into EndpointAddr\n    pub fn get_node_addrs_with_id(&self, environment: &str) -> Vec<EndpointAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut out = Vec::new();\n\n        for node in nodes {\n            if let Some((id_part, addr_part)) = node.split_once('@') {\n                match (\n                    EndpointId::from_str(id_part),\n                    addr_part.parse::<SocketAddr>(),\n                ) {\n                    (Ok(node_id), Ok(sock)) => {\n                        out.push(EndpointAddr::new(node_id).with_ip_addr(sock));\n                    }\n                    (id_res, addr_res) => {\n                        debug!(\n                            \"Invalid node entry '{}': id_ok={}, addr_ok={}\",\n                            node,\n                            id_res.is_ok(),\n                            addr_res.is_ok()\n                        );\n                    }\n                }\n            } else if node.parse::<SocketAddr>().is_ok() {\n                warn!(\n                    \"Bootstrap node '{}' lacks NodeId; expected '<node_id>@<host:port>'. Skipping.\",\n                    node\n                );\n            } else {\n                debug!(\"Unrecognized bootstrap node entry: {}\", node);\n            }\n        }\n\n        out\n    }\n}\n\nfn parse_bootstrap_list(value: &str) -> Vec<String> {\n    value\n        .split(',')\n        .map(|s| s.trim().to_string())\n        .filter(|s| !s.is_empty())\n        .collect()\n}\n\nfn sanitize_bootstrap_node(entry: &str) -> Option<String> {\n    let trimmed = entry.trim();\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    let (node_id, addr_part) = match trimmed.split_once('@') {\n        Some((id, addr)) => (id.trim(), addr.trim()),\n        None => return Some(trimmed.to_string()),\n    };\n\n    let mut socket_addr = match addr_part.parse::<SocketAddr>() {\n        Ok(addr) => addr,\n        Err(err) => {\n            warn!(\"Invalid bootstrap node '{}': {}\", entry, err);\n            return None;\n        }\n    };\n\n    if socket_addr.ip().is_unspecified() {\n        let replacement = match socket_addr {\n            SocketAddr::V4(_) => IpAddr::V4(Ipv4Addr::LOCALHOST),\n            SocketAddr::V6(_) => IpAddr::V6(Ipv6Addr::LOCALHOST),\n        };\n        socket_addr.set_ip(replacement);\n        warn!(\n            original = %entry,\n            normalized = %format!(\"{node_id}@{socket_addr}\"),\n            \"Bootstrap node address was unspecified; replaced with loopback\"\n        );\n    }\n\n    Some(format!(\"{node_id}@{socket_addr}\"))\n}\n\nfn sanitize_bootstrap_nodes(nodes: &[String]) -> Vec<String> {\n    let mut normalized: Vec<String> = nodes\n        .iter()\n        .filter_map(|entry| sanitize_bootstrap_node(entry))\n        .collect();\n    normalized.sort();\n    normalized.dedup();\n    normalized\n}\n\n/// Read bootstrap nodes from environment variable if set\npub fn load_env_bootstrap_nodes() -> Option<Vec<String>> {\n    match std::env::var(\"KUKURI_BOOTSTRAP_PEERS\") {\n        Ok(raw) => {\n            let nodes = parse_bootstrap_list(&raw);\n            if nodes.is_empty() { None } else { Some(nodes) }\n        }\n        Err(_) => None,\n    }\n}\n\nfn format_node_addrs(node_addr: &EndpointAddr) -> Vec<String> {\n    let node_id = node_addr.id.to_string();\n    let direct: Vec<_> = node_addr.ip_addrs().cloned().collect();\n    if direct.is_empty() {\n        vec![node_id]\n    } else {\n        direct\n            .into_iter()\n            .map(|addr| format!(\"{node_id}@{addr}\"))\n            .collect()\n    }\n}\n\nfn load_bundle_bootstrap_strings() -> Vec<String> {\n    match load_bootstrap_node_addrs() {\n        Ok(node_addrs) => node_addrs\n            .iter()\n            .flat_map(format_node_addrs)\n            .collect::<Vec<_>>(),\n        Err(err) => {\n            warn!(\"Failed to load bundled bootstrap nodes: {}\", err);\n            Vec::new()\n        }\n    }\n}\n\n/// Decide effective bootstrap nodes. Priority: env > user config > bundled file (only when ENABLE_P2P_INTEGRATION=1)\npub fn load_effective_bootstrap_nodes() -> BootstrapSelection {\n    let integration_enabled = std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() == \"1\";\n\n    if let Some(nodes) = load_env_bootstrap_nodes() {\n        let nodes = sanitize_bootstrap_nodes(&nodes);\n        trace!(\"Using bootstrap peers from environment variable\");\n        return BootstrapSelection {\n            source: BootstrapSource::Env,\n            nodes,\n        };\n    }\n\n    let user_nodes = sanitize_bootstrap_nodes(&load_user_bootstrap_nodes());\n    if !user_nodes.is_empty() {\n        trace!(\"Using bootstrap peers from user configuration\");\n        return BootstrapSelection {\n            source: BootstrapSource::User,\n            nodes: user_nodes,\n        };\n    }\n\n    if integration_enabled {\n        let bundle_nodes = sanitize_bootstrap_nodes(&load_bundle_bootstrap_strings());\n        if !bundle_nodes.is_empty() {\n            trace!(\"Using bootstrap peers from bundled configuration\");\n            return BootstrapSelection {\n                source: BootstrapSource::Bundle,\n                nodes: bundle_nodes,\n            };\n        }\n    } else {\n        trace!(\"P2P integration disabled; skipping bundled bootstrap nodes\");\n    }\n\n    BootstrapSelection {\n        source: BootstrapSource::None,\n        nodes: Vec::new(),\n    }\n}\n\n/// Resolve current environment string\npub fn get_current_environment() -> String {\n    std::env::var(\"KUKURI_ENV\")\n        .or_else(|_| std::env::var(\"ENVIRONMENT\"))\n        .unwrap_or_else(|_| \"development\".to_string())\n}\n\n/// Load bootstrap nodes as SocketAddr\npub fn load_bootstrap_nodes() -> Result<Vec<SocketAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap nodes for environment: {}\", env);\n\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\"\n        && load_env_bootstrap_nodes().is_none()\n        && load_user_bootstrap_nodes().is_empty()\n    {\n        info!(\"P2P integration disabled; returning empty bootstrap node list\");\n        return Ok(Vec::new());\n    }\n\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_socket_addrs(&env);\n\n    if addrs.is_empty() {\n        warn!(\"No bootstrap nodes configured for environment: {}\", env);\n    } else {\n        info!(\"Loaded {} bootstrap nodes\", addrs.len());\n    }\n\n    Ok(addrs)\n}\n\n/// Load bootstrap nodes as EndpointAddr (requires node id)\npub fn load_bootstrap_node_addrs() -> Result<Vec<EndpointAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap NodeAddrs for environment: {}\", env);\n\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\"\n        && load_env_bootstrap_nodes().is_none()\n        && load_user_bootstrap_nodes().is_empty()\n    {\n        info!(\"P2P integration disabled; returning empty NodeAddr list\");\n        return Ok(Vec::new());\n    }\n\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_node_addrs_with_id(&env);\n    if addrs.is_empty() {\n        warn!(\n            \"No valid NodeId@Addr bootstrap entries for environment: {}\",\n            env\n        );\n    } else {\n        info!(\"Loaded {} NodeId@Addr bootstrap entries\", addrs.len());\n    }\n    Ok(addrs)\n}\n\n/// Validate bootstrap_nodes.json and log counts\npub fn validate_bootstrap_config() -> Result<(), AppError> {\n    let env = get_current_environment();\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        BootstrapConfig::default_config()\n    };\n\n    let nodes = config.get_nodes(&env);\n    let mut with_id = 0usize;\n    let mut socket_only = 0usize;\n    let mut invalid = 0usize;\n\n    for node in nodes {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            if EndpointId::from_str(id_part).is_ok() && addr_part.parse::<SocketAddr>().is_ok() {\n                with_id += 1;\n            } else {\n                invalid += 1;\n            }\n        } else if node.parse::<SocketAddr>().is_ok() {\n            socket_only += 1;\n        } else {\n            invalid += 1;\n        }\n    }\n\n    info!(\n        \"bootstrap_nodes.json validation (env={}): with_id={}, socket_only={}, invalid={}\",\n        env, with_id, socket_only, invalid\n    );\n\n    Ok(())\n}\n\n// =============== user-managed bootstrap config =================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct UserBootstrapConfig {\n    nodes: Vec<String>,\n}\n\nfn user_config_path() -> PathBuf {\n    let base = dirs::data_dir().unwrap_or_else(|| PathBuf::from(\".\"));\n    let dir = base.join(\"kukuri\");\n    let _ = fs::create_dir_all(&dir);\n    dir.join(\"user_bootstrap_nodes.json\")\n}\n\n/// Persist user-provided bootstrap nodes (node_id@host:port)\npub fn save_user_bootstrap_nodes(nodes: &[String]) -> Result<(), AppError> {\n    let path = user_config_path();\n    let normalized = sanitize_bootstrap_nodes(nodes);\n    let cfg = UserBootstrapConfig { nodes: normalized };\n    let json = serde_json::to_string_pretty(&cfg).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to serialize user bootstrap: {e}\"))\n    })?;\n    fs::write(&path, json).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to write user bootstrap file: {e}\"))\n    })?;\n    info!(\n        \"Saved user bootstrap nodes to {:?} ({} entries)\",\n        path,\n        nodes.len()\n    );\n    Ok(())\n}\n\n/// Remove user bootstrap configuration\npub fn clear_user_bootstrap_nodes() -> Result<(), AppError> {\n    let path = user_config_path();\n    if path.exists() {\n        fs::remove_file(&path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to remove user bootstrap file: {e}\"))\n        })?;\n        info!(\"Removed user bootstrap config at {:?}\", path);\n    }\n    Ok(())\n}\n\n/// Load user bootstrap nodes (raw strings)\npub fn load_user_bootstrap_nodes() -> Vec<String> {\n    let path = user_config_path();\n    if !path.exists() {\n        return vec![];\n    }\n    match fs::read_to_string(&path) {\n        Ok(content) => match serde_json::from_str::<UserBootstrapConfig>(&content) {\n            Ok(cfg) => cfg.nodes,\n            Err(e) => {\n                warn!(\"Invalid user bootstrap json: {}\", e);\n                vec![]\n            }\n        },\n        Err(e) => {\n            debug!(\"Failed to read user bootstrap file: {}\", e);\n            vec![]\n        }\n    }\n}\n\n/// Load user bootstrap nodes as EndpointAddr\npub fn load_user_bootstrap_node_addrs() -> Vec<EndpointAddr> {\n    let mut out = Vec::new();\n    for node in load_user_bootstrap_nodes() {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            match (\n                EndpointId::from_str(id_part),\n                addr_part.parse::<SocketAddr>(),\n            ) {\n                (Ok(node_id), Ok(sock)) => out.push(EndpointAddr::new(node_id).with_ip_addr(sock)),\n                _ => debug!(\"Invalid user bootstrap entry: {}\", node),\n            }\n        } else {\n            debug!(\"Skipping SocketAddr-only user bootstrap entry: {}\", node);\n        }\n    }\n    out\n}\n\nfn cli_bootstrap_path() -> PathBuf {\n    if let Ok(custom) = std::env::var(\"KUKURI_CLI_BOOTSTRAP_PATH\") {\n        return PathBuf::from(custom);\n    }\n    dirs::data_dir()\n        .unwrap_or_else(|| PathBuf::from(\".\"))\n        .join(\"kukuri\")\n        .join(\"cli_bootstrap_nodes.json\")\n}\n\npub fn load_cli_bootstrap_nodes() -> Option<CliBootstrapInfo> {\n    let path = cli_bootstrap_path();\n    if !path.exists() {\n        return None;\n    }\n\n    let content = fs::read_to_string(&path).ok()?;\n    let cache: CliBootstrapCacheFile = serde_json::from_str(&content).ok()?;\n\n    let nodes = sanitize_bootstrap_nodes(\n        &cache\n            .nodes\n            .into_iter()\n            .map(|entry| entry.trim().to_string())\n            .collect::<Vec<_>>(),\n    );\n\n    if nodes.is_empty() {\n        return None;\n    }\n\n    Some(CliBootstrapInfo {\n        nodes,\n        updated_at_ms: cache.updated_at_ms,\n        path,\n    })\n}\n\npub fn apply_cli_bootstrap_nodes() -> Result<Vec<String>, AppError> {\n    let info = load_cli_bootstrap_nodes().ok_or_else(|| {\n        AppError::ConfigurationError(\n            \"CLI bootstrap list is not available. Run cn-cli to export nodes.\".to_string(),\n        )\n    })?;\n    let normalized = sanitize_bootstrap_nodes(&info.nodes);\n    save_user_bootstrap_nodes(&normalized)?;\n    Ok(normalized)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::{Mutex, MutexGuard, OnceLock};\n\n    static CLI_BOOTSTRAP_ENV_GUARD: OnceLock<Mutex<()>> = OnceLock::new();\n\n    fn lock_cli_bootstrap_env() -> MutexGuard<'static, ()> {\n        CLI_BOOTSTRAP_ENV_GUARD\n            .get_or_init(|| Mutex::new(()))\n            .lock()\n            .expect(\"cli bootstrap env guard poisoned\")\n    }\n\n    fn temp_cli_path(suffix: &str) -> PathBuf {\n        let path = std::env::temp_dir().join(format!(\n            \"kukuri_cli_bootstrap_test_{}_{}.json\",\n            std::process::id(),\n            suffix\n        ));\n        if path.exists() {\n            let _ = fs::remove_file(&path);\n        }\n        path\n    }\n\n    #[test]\n    fn sanitize_bootstrap_nodes_rewrites_unspecified_addresses() {\n        let nodes = vec![\n            \"node1@0.0.0.0:11223\".to_string(),\n            \"node2@[::]:11223\".to_string(),\n            \" node3@127.0.0.1:11223 \".to_string(),\n        ];\n\n        let normalized = sanitize_bootstrap_nodes(&nodes);\n\n        assert!(normalized.contains(&\"node1@127.0.0.1:11223\".to_string()));\n        assert!(normalized.contains(&\"node2@[::1]:11223\".to_string()));\n        assert!(normalized.contains(&\"node3@127.0.0.1:11223\".to_string()));\n        assert_eq!(normalized.len(), 3);\n    }\n\n    #[test]\n    fn load_cli_bootstrap_nodes_returns_data_when_file_exists() {\n        let _guard = lock_cli_bootstrap_env();\n        let path = temp_cli_path(\"load\");\n        unsafe {\n            std::env::set_var(\"KUKURI_CLI_BOOTSTRAP_PATH\", &path);\n        }\n        let payload = r#\"{\"nodes\":[\"node1@127.0.0.1:1234\",\"node1@127.0.0.1:1234\",\"node2@[::1]:5678\"],\"updated_at_ms\":12345}\"#;\n        fs::write(&path, payload).expect(\"write cli bootstrap cache\");\n\n        let info = load_cli_bootstrap_nodes().expect(\"cli bootstrap info\");\n        assert_eq!(info.nodes.len(), 2);\n        assert_eq!(info.updated_at_ms, Some(12345));\n        assert_eq!(info.path, path);\n\n        unsafe {\n            std::env::remove_var(\"KUKURI_CLI_BOOTSTRAP_PATH\");\n        }\n        let _ = fs::remove_file(&info.path);\n    }\n\n    #[test]\n    fn load_cli_bootstrap_nodes_returns_none_when_missing() {\n        let _guard = lock_cli_bootstrap_env();\n        let path = temp_cli_path(\"missing\");\n        unsafe {\n            std::env::set_var(\"KUKURI_CLI_BOOTSTRAP_PATH\", &path);\n        }\n        assert!(load_cli_bootstrap_nodes().is_none());\n        unsafe {\n            std::env::remove_var(\"KUKURI_CLI_BOOTSTRAP_PATH\");\n        }\n    }\n}\n","traces":[{"line":13,"address":[23750320,23750990,23751022],"length":1,"stats":{"Line":0}},{"line":14,"address":[23736577],"length":1,"stats":{"Line":0}},{"line":15,"address":[23853269,23853337],"length":1,"stats":{"Line":0}},{"line":16,"address":[23949826],"length":1,"stats":{"Line":0}},{"line":18,"address":[23743621,23743502],"length":1,"stats":{"Line":0}},{"line":19,"address":[23849715],"length":1,"stats":{"Line":0}},{"line":20,"address":[23849805],"length":1,"stats":{"Line":0}},{"line":22,"address":[23818594],"length":1,"stats":{"Line":0}},{"line":59,"address":[23856108,23855568],"length":1,"stats":{"Line":0}},{"line":60,"address":[24733969,24734139,24734496,24734727],"length":1,"stats":{"Line":0}},{"line":61,"address":[24734583,24734518],"length":1,"stats":{"Line":0}},{"line":64,"address":[17992416,17991729,17991849,17992072,17992647],"length":1,"stats":{"Line":0}},{"line":65,"address":[23744918,23744983],"length":1,"stats":{"Line":0}},{"line":68,"address":[23850388],"length":1,"stats":{"Line":0}},{"line":72,"address":[23813947,23812960],"length":1,"stats":{"Line":0}},{"line":74,"address":[17993102],"length":1,"stats":{"Line":0}},{"line":78,"address":[23813565],"length":1,"stats":{"Line":0}},{"line":82,"address":[23851881],"length":1,"stats":{"Line":0}},{"line":90,"address":[23746176,23746987],"length":1,"stats":{"Line":0}},{"line":92,"address":[23857720],"length":1,"stats":{"Line":0}},{"line":93,"address":[23952600],"length":1,"stats":{"Line":0}},{"line":94,"address":[24736252],"length":1,"stats":{"Line":0}},{"line":96,"address":[23739728,23894265,23740330,23894399,23740205],"length":1,"stats":{"Line":0}},{"line":97,"address":[23754068],"length":1,"stats":{"Line":0}},{"line":103,"address":[23817864,23815504],"length":1,"stats":{"Line":0}},{"line":104,"address":[23954031],"length":1,"stats":{"Line":0}},{"line":105,"address":[23857632],"length":1,"stats":{"Line":0}},{"line":107,"address":[24737672,24737780,24737915,24737969],"length":1,"stats":{"Line":0}},{"line":108,"address":[23859677,23859827],"length":1,"stats":{"Line":0}},{"line":109,"address":[23741724,23741584],"length":1,"stats":{"Line":0}},{"line":110,"address":[23748466],"length":1,"stats":{"Line":0}},{"line":111,"address":[24107833,23954827,24107967,23954768],"length":1,"stats":{"Line":0}},{"line":116,"address":[17995732],"length":1,"stats":{"Line":0}},{"line":120,"address":[23821359,23817920,23824499],"length":1,"stats":{"Line":0}},{"line":121,"address":[23750159],"length":1,"stats":{"Line":0}},{"line":122,"address":[17997720],"length":1,"stats":{"Line":0}},{"line":124,"address":[23743476,23743773,23745168,23743719,23743584],"length":1,"stats":{"Line":0}},{"line":125,"address":[23862251,23865012,23862101],"length":1,"stats":{"Line":0}},{"line":126,"address":[23744228],"length":1,"stats":{"Line":0}},{"line":127,"address":[24740700],"length":1,"stats":{"Line":0}},{"line":128,"address":[23744165],"length":1,"stats":{"Line":0}},{"line":130,"address":[23819081],"length":1,"stats":{"Line":0}},{"line":131,"address":[23861193,23861293],"length":1,"stats":{"Line":0}},{"line":133,"address":[23758130],"length":1,"stats":{"Line":0}},{"line":134,"address":[23820997,23820568],"length":1,"stats":{"Line":0}},{"line":142,"address":[23828334,23825643],"length":1,"stats":{"Line":0}},{"line":143,"address":[23863540,23865118,24012393,24012527],"length":1,"stats":{"Line":0}},{"line":148,"address":[23903033,23753722,23753656,23903167],"length":1,"stats":{"Line":0}},{"line":152,"address":[23750636],"length":1,"stats":{"Line":0}},{"line":156,"address":[23756736],"length":1,"stats":{"Line":0}},{"line":157,"address":[23866624],"length":1,"stats":{"Line":0}},{"line":159,"address":[23868421,23868368],"length":1,"stats":{"Line":0}},{"line":160,"address":[23824768,23824793],"length":1,"stats":{"Line":0}},{"line":164,"address":[23871315,23868512],"length":1,"stats":{"Line":1}},{"line":165,"address":[23831783],"length":1,"stats":{"Line":1}},{"line":166,"address":[18004626],"length":1,"stats":{"Line":1}},{"line":167,"address":[23867045],"length":1,"stats":{"Line":0}},{"line":170,"address":[23867311,23866987],"length":1,"stats":{"Line":2}},{"line":171,"address":[23963573],"length":1,"stats":{"Line":1}},{"line":172,"address":[23831959],"length":1,"stats":{"Line":0}},{"line":175,"address":[23757519],"length":1,"stats":{"Line":1}},{"line":176,"address":[23832316],"length":1,"stats":{"Line":1}},{"line":177,"address":[23964040],"length":1,"stats":{"Line":0}},{"line":178,"address":[24009449,23863686,24009583,23866703,23866048],"length":1,"stats":{"Line":0}},{"line":179,"address":[18008285],"length":1,"stats":{"Line":0}},{"line":183,"address":[23757708],"length":1,"stats":{"Line":1}},{"line":184,"address":[23765002],"length":1,"stats":{"Line":1}},{"line":185,"address":[23751256],"length":1,"stats":{"Line":1}},{"line":186,"address":[23765039],"length":1,"stats":{"Line":1}},{"line":188,"address":[23867957],"length":1,"stats":{"Line":1}},{"line":189,"address":[23765515,23766309],"length":1,"stats":{"Line":1}},{"line":196,"address":[23825606],"length":1,"stats":{"Line":1}},{"line":199,"address":[23872912,23873144],"length":1,"stats":{"Line":1}},{"line":200,"address":[23829266],"length":1,"stats":{"Line":1}},{"line":202,"address":[23761699,23761664],"length":1,"stats":{"Line":2}},{"line":204,"address":[23867429,23867492],"length":1,"stats":{"Line":2}},{"line":205,"address":[24751356],"length":1,"stats":{"Line":1}},{"line":206,"address":[23867529],"length":1,"stats":{"Line":1}},{"line":210,"address":[23829998,23829536],"length":1,"stats":{"Line":0}},{"line":211,"address":[23761745],"length":1,"stats":{"Line":0}},{"line":212,"address":[23836520],"length":1,"stats":{"Line":0}},{"line":213,"address":[24751569,24751665],"length":1,"stats":{"Line":0}},{"line":214,"address":[23755198,23755136],"length":1,"stats":{"Line":0}},{"line":216,"address":[23755047],"length":1,"stats":{"Line":0}},{"line":220,"address":[23868862,23868176],"length":1,"stats":{"Line":0}},{"line":221,"address":[23868206],"length":1,"stats":{"Line":0}},{"line":222,"address":[23755545,23755605],"length":1,"stats":{"Line":0}},{"line":223,"address":[23830315,23830250],"length":1,"stats":{"Line":0}},{"line":224,"address":[23755800,23755894],"length":1,"stats":{"Line":0}},{"line":226,"address":[23830404,23830321],"length":1,"stats":{"Line":0}},{"line":228,"address":[23769968,23769997],"length":1,"stats":{"Line":0}},{"line":233,"address":[18010704,18011091],"length":1,"stats":{"Line":0}},{"line":234,"address":[23770183,23770959],"length":1,"stats":{"Line":0}},{"line":235,"address":[23969534,23969740],"length":1,"stats":{"Line":0}},{"line":239,"address":[23770289],"length":1,"stats":{"Line":0}},{"line":240,"address":[23873977,24014377,23873217,23873497,24014511,23873841],"length":1,"stats":{"Line":0}},{"line":241,"address":[23870027],"length":1,"stats":{"Line":0}},{"line":247,"address":[23758336,23760461,23759225],"length":1,"stats":{"Line":0}},{"line":248,"address":[23765143],"length":1,"stats":{"Line":0}},{"line":250,"address":[23971612],"length":1,"stats":{"Line":0}},{"line":251,"address":[23833396,23833213],"length":1,"stats":{"Line":0}},{"line":252,"address":[23905151,23765595,23765667,23905017,23766011,23766257],"length":1,"stats":{"Line":0}},{"line":253,"address":[24755900],"length":1,"stats":{"Line":0}},{"line":254,"address":[23759353],"length":1,"stats":{"Line":0}},{"line":255,"address":[23840881],"length":1,"stats":{"Line":0}},{"line":259,"address":[23875313,23877123],"length":1,"stats":{"Line":0}},{"line":260,"address":[23878914],"length":1,"stats":{"Line":0}},{"line":261,"address":[23973788,23974366,24111801,24111935,23973737],"length":1,"stats":{"Line":0}},{"line":262,"address":[23879532],"length":1,"stats":{"Line":0}},{"line":263,"address":[23767964],"length":1,"stats":{"Line":0}},{"line":264,"address":[23842708],"length":1,"stats":{"Line":0}},{"line":268,"address":[23760696],"length":1,"stats":{"Line":0}},{"line":269,"address":[24758808,24760279],"length":1,"stats":{"Line":0}},{"line":270,"address":[23777721],"length":1,"stats":{"Line":0}},{"line":271,"address":[23877327,24011929,24012063,23876704,23876757],"length":1,"stats":{"Line":0}},{"line":272,"address":[23771357],"length":1,"stats":{"Line":0}},{"line":273,"address":[23764517],"length":1,"stats":{"Line":0}},{"line":274,"address":[23764525],"length":1,"stats":{"Line":0}},{"line":278,"address":[23975406,23975357,23975892,24112793,24112927],"length":1,"stats":{"Line":0}},{"line":283,"address":[23837390],"length":1,"stats":{"Line":0}},{"line":288,"address":[23765600],"length":1,"stats":{"Line":0}},{"line":289,"address":[23840206],"length":1,"stats":{"Line":0}},{"line":290,"address":[18020000,18020016],"length":1,"stats":{"Line":0}},{"line":291,"address":[23840400,23840416],"length":1,"stats":{"Line":0}},{"line":295,"address":[23978992,23987943,23986505],"length":1,"stats":{"Line":0}},{"line":296,"address":[23884243],"length":1,"stats":{"Line":0}},{"line":297,"address":[23884339,24018505,24018639,23884831,23884683,23884260],"length":1,"stats":{"Line":0}},{"line":299,"address":[23879213,23880317],"length":1,"stats":{"Line":0}},{"line":300,"address":[23880486],"length":1,"stats":{"Line":0}},{"line":301,"address":[23849445],"length":1,"stats":{"Line":0}},{"line":303,"address":[23914473,23787715,23914607,23787202],"length":1,"stats":{"Line":0}},{"line":304,"address":[23856347,23855453],"length":1,"stats":{"Line":0}},{"line":307,"address":[23774855,23775085,23774556],"length":1,"stats":{"Line":0}},{"line":308,"address":[24762885,24764787,24764891,24764638,24764683],"length":1,"stats":{"Line":0}},{"line":310,"address":[23768953,23901209,23901343,23768440],"length":1,"stats":{"Line":0}},{"line":311,"address":[18023235,18024225],"length":1,"stats":{"Line":0}},{"line":314,"address":[18024290,18022697],"length":1,"stats":{"Line":0}},{"line":316,"address":[23886653,23886730],"length":1,"stats":{"Line":0}},{"line":317,"address":[24014543,23882828,24014409,23884574],"length":1,"stats":{"Line":0}},{"line":319,"address":[23851682,23983855,23851616,23983721,23852227],"length":1,"stats":{"Line":0}},{"line":322,"address":[23777410],"length":1,"stats":{"Line":0}},{"line":326,"address":[23782409,23783847,23774896],"length":1,"stats":{"Line":0}},{"line":327,"address":[23856451],"length":1,"stats":{"Line":0}},{"line":328,"address":[23850111,23849540,23849619,23849963,23977423,23977289],"length":1,"stats":{"Line":0}},{"line":330,"address":[23892125,23893229],"length":1,"stats":{"Line":0}},{"line":331,"address":[23790518],"length":1,"stats":{"Line":0}},{"line":332,"address":[23858421],"length":1,"stats":{"Line":0}},{"line":334,"address":[23895122,24016031,24015897,23895635],"length":1,"stats":{"Line":0}},{"line":335,"address":[23789693,23790587],"length":1,"stats":{"Line":0}},{"line":338,"address":[18031351,18031581,18031052],"length":1,"stats":{"Line":0}},{"line":339,"address":[23988441,23990359,23990186,23990467,23990235],"length":1,"stats":{"Line":0}},{"line":341,"address":[23903823,23777929,23903689,23777416],"length":1,"stats":{"Line":0}},{"line":342,"address":[23891601,23890611],"length":1,"stats":{"Line":0}},{"line":345,"address":[23784153,23785746],"length":1,"stats":{"Line":0}},{"line":346,"address":[18033293,18033370],"length":1,"stats":{"Line":0}},{"line":347,"address":[24777239,24985247,24775505,24985113],"length":1,"stats":{"Line":0}},{"line":352,"address":[23918441,23918575,23793443,23792898,23792832],"length":1,"stats":{"Line":0}},{"line":354,"address":[23992674],"length":1,"stats":{"Line":0}},{"line":358,"address":[24000439,23996944,24000242],"length":1,"stats":{"Line":0}},{"line":359,"address":[23865415],"length":1,"stats":{"Line":0}},{"line":360,"address":[23858793,23858563,23858512],"length":1,"stats":{"Line":0}},{"line":361,"address":[23797847,23797971,23797798],"length":1,"stats":{"Line":0}},{"line":363,"address":[23900986],"length":1,"stats":{"Line":0}},{"line":366,"address":[23900933,23901067],"length":1,"stats":{"Line":0}},{"line":367,"address":[23798214],"length":1,"stats":{"Line":0}},{"line":368,"address":[24780822],"length":1,"stats":{"Line":0}},{"line":369,"address":[23897182],"length":1,"stats":{"Line":0}},{"line":371,"address":[23897194,23897356,23897410],"length":1,"stats":{"Line":0}},{"line":372,"address":[23903034,23904969],"length":1,"stats":{"Line":0}},{"line":373,"address":[23905096,23905381,23905143,23905292,23905438],"length":1,"stats":{"Line":0}},{"line":374,"address":[23800816,23800902,23800912],"length":1,"stats":{"Line":0}},{"line":376,"address":[24000167,24000157,24000042],"length":1,"stats":{"Line":0}},{"line":378,"address":[23903475,23903981,23903829,23903942],"length":1,"stats":{"Line":0}},{"line":379,"address":[23861938,23861925,23861857],"length":1,"stats":{"Line":0}},{"line":381,"address":[18041598,18041611,18041545],"length":1,"stats":{"Line":0}},{"line":385,"address":[23903586,24023465,23903060,24023599],"length":1,"stats":{"Line":0}},{"line":390,"address":[23785273],"length":1,"stats":{"Line":0}},{"line":400,"address":[24000464,24000823],"length":1,"stats":{"Line":0}},{"line":401,"address":[23868929,23869296,23869308],"length":1,"stats":{"Line":0}},{"line":402,"address":[24000604,24000536],"length":1,"stats":{"Line":0}},{"line":403,"address":[23904201,23904265],"length":1,"stats":{"Line":0}},{"line":404,"address":[23794441],"length":1,"stats":{"Line":0}},{"line":408,"address":[23904464,23906942,23906969],"length":1,"stats":{"Line":0}},{"line":409,"address":[24784215],"length":1,"stats":{"Line":0}},{"line":410,"address":[23869444],"length":1,"stats":{"Line":0}},{"line":411,"address":[23801735],"length":1,"stats":{"Line":0}},{"line":412,"address":[23864903,23862599,23862667,23864944,23862953,23865175],"length":1,"stats":{"Line":0}},{"line":413,"address":[23903078,23903143],"length":1,"stats":{"Line":0}},{"line":415,"address":[23788594,23790251,23790839,23788439,23790608,23788230],"length":1,"stats":{"Line":0}},{"line":416,"address":[23865287,23865222],"length":1,"stats":{"Line":0}},{"line":418,"address":[23803723,23803420],"length":1,"stats":{"Line":0}},{"line":423,"address":[23802856],"length":1,"stats":{"Line":0}},{"line":427,"address":[18047049,18045168],"length":1,"stats":{"Line":0}},{"line":428,"address":[24003975],"length":1,"stats":{"Line":0}},{"line":429,"address":[23797783,23797700],"length":1,"stats":{"Line":0}},{"line":430,"address":[18045360,18047303,18045550,18045928,18047072],"length":1,"stats":{"Line":0}},{"line":431,"address":[23909495,23909430],"length":1,"stats":{"Line":0}},{"line":433,"address":[24027727,23909914,23909450,24027593,23909570],"length":1,"stats":{"Line":0}},{"line":435,"address":[24004106],"length":1,"stats":{"Line":0}},{"line":439,"address":[23909664,23911962,23913496],"length":1,"stats":{"Line":0}},{"line":440,"address":[23793063],"length":1,"stats":{"Line":0}},{"line":441,"address":[24006148,24006231],"length":1,"stats":{"Line":0}},{"line":442,"address":[23874714],"length":1,"stats":{"Line":0}},{"line":444,"address":[23807022,23806965],"length":1,"stats":{"Line":0}},{"line":445,"address":[23906001,23906171],"length":1,"stats":{"Line":0}},{"line":446,"address":[23807289],"length":1,"stats":{"Line":0}},{"line":447,"address":[23906318],"length":1,"stats":{"Line":0}},{"line":448,"address":[23807491,23807971,23923561,23923695,23807390],"length":1,"stats":{"Line":0}},{"line":449,"address":[23906901],"length":1,"stats":{"Line":0}},{"line":452,"address":[23874880],"length":1,"stats":{"Line":0}},{"line":453,"address":[23809620,23807136,23924191,23924057,23809142],"length":1,"stats":{"Line":0}},{"line":454,"address":[18050150],"length":1,"stats":{"Line":0}},{"line":460,"address":[23915168,23919397,23917952],"length":1,"stats":{"Line":0}},{"line":461,"address":[23810663],"length":1,"stats":{"Line":0}},{"line":462,"address":[23913785,23913560,23913839,23915089,23913623],"length":1,"stats":{"Line":0}},{"line":463,"address":[23811141,23810999],"length":1,"stats":{"Line":0}},{"line":464,"address":[23797643],"length":1,"stats":{"Line":0}},{"line":465,"address":[23872106],"length":1,"stats":{"Line":0}},{"line":466,"address":[24010652],"length":1,"stats":{"Line":0}},{"line":468,"address":[23916263,23916096],"length":1,"stats":{"Line":0}},{"line":469,"address":[24023631,23911155,24023497,23910481,23910811],"length":1,"stats":{"Line":0}},{"line":472,"address":[23910237,24023993,23912384,24024127],"length":1,"stats":{"Line":0}},{"line":475,"address":[23811038],"length":1,"stats":{"Line":0}},{"line":478,"address":[23814896,23815171,23815142],"length":1,"stats":{"Line":1}},{"line":479,"address":[23882673],"length":1,"stats":{"Line":1}},{"line":480,"address":[23919502],"length":1,"stats":{"Line":1}},{"line":482,"address":[24797834,24797491,24797723],"length":1,"stats":{"Line":0}},{"line":483,"address":[23914352,23914364],"length":1,"stats":{"Line":0}},{"line":488,"address":[23803091,23803053,23801696],"length":1,"stats":{"Line":1}},{"line":489,"address":[23801713],"length":1,"stats":{"Line":1}},{"line":490,"address":[24014829,24014897],"length":1,"stats":{"Line":2}},{"line":491,"address":[24798107],"length":1,"stats":{"Line":1}},{"line":494,"address":[23876677,23877678,23876500,23876452],"length":1,"stats":{"Line":2}},{"line":495,"address":[23915133,23914854,23915788,23914767],"length":1,"stats":{"Line":2}},{"line":498,"address":[23883877,23884004],"length":1,"stats":{"Line":2}},{"line":501,"address":[23816880,23816912],"length":1,"stats":{"Line":2}},{"line":505,"address":[24015771],"length":1,"stats":{"Line":1}},{"line":506,"address":[23802979],"length":1,"stats":{"Line":0}},{"line":509,"address":[23884343],"length":1,"stats":{"Line":1}},{"line":510,"address":[23919381],"length":1,"stats":{"Line":1}},{"line":511,"address":[24799001],"length":1,"stats":{"Line":1}},{"line":512,"address":[23877381],"length":1,"stats":{"Line":1}},{"line":516,"address":[23878628,23877888],"length":1,"stats":{"Line":0}},{"line":517,"address":[23884833,23885584,23885086],"length":1,"stats":{"Line":0}},{"line":518,"address":[23810895],"length":1,"stats":{"Line":0}},{"line":519,"address":[23810862],"length":1,"stats":{"Line":0}},{"line":522,"address":[23920153,23920291],"length":1,"stats":{"Line":0}},{"line":523,"address":[23885178,23885256,23885437],"length":1,"stats":{"Line":0}},{"line":524,"address":[23810596],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":249},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_bootstrap.rs"],"content":"﻿//! DHT基盤のブートストラップ実装\r\n//! irohのビルトインDHTディスカバリーを使用した分散型ピア発見\r\nuse super::utils::parse_node_addr;\r\nuse crate::shared::config::BootstrapSource;\nuse crate::shared::error::AppError;\nuse iroh::{Endpoint, EndpointAddr};\nuse iroh_gossip::{\r\n    api::{GossipSender, GossipTopic},\r\n    net::Gossip,\r\n    proto::TopicId,\r\n};\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse tokio::sync::{Mutex as TokioMutex, RwLock};\r\nuse tracing::{debug, info, warn};\r\n\r\nconst LOG_TARGET: &str = \"kukuri::p2p::dht\";\r\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\r\n\r\n/// DHT統合付きGossipサービス\r\npub struct DhtGossip {\n    gossip: Gossip,\n    senders: Arc<RwLock<HashMap<String, Arc<TokioMutex<GossipSender>>>>>,\n}\n\r\nimpl DhtGossip {\r\n    /// DHT統合付きGossipを作成\r\n    pub async fn new(endpoint: Arc<Endpoint>) -> Result<Self, AppError> {\r\n        info!(target: LOG_TARGET, \"Initializing DHT-integrated Gossip service\");\r\n\r\n        // iroh-gossipを作成\r\n        let gossip = Gossip::builder().spawn(endpoint.as_ref().clone());\r\n\r\n        info!(target: LOG_TARGET, \"DHT-integrated Gossip initialized successfully\");\r\n\r\n        Ok(Self {\n            gossip,\n            senders: Arc::new(RwLock::new(HashMap::new())),\n        })\n    }\r\n\r\n    /// トピックに参加\r\n    pub async fn join_topic(\r\n        &self,\r\n        topic: &[u8],\r\n        neighbors: Vec<EndpointAddr>,\n    ) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n\r\n        // subscribe には EndpointAddrのリストではなく、EndpointIdのリストが必要\n        let peer_ids: Vec<_> = neighbors.iter().map(|addr| addr.id).collect();\n        let topic: GossipTopic = self\r\n            .gossip\r\n            .subscribe(topic_id, peer_ids)\r\n            .await\r\n            .map_err(|e| {\r\n                super::metrics::record_join_failure();\r\n                warn!(\r\n                    target: LOG_TARGET,\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    error = ?e,\r\n                    \"Failed to join DHT topic\"\r\n                );\r\n                AppError::P2PError(format!(\"Failed to join topic: {e:?}\"))\r\n            })?;\r\n\r\n        // Sender を保存（Receiver は破棄しても参加状態は維持される）\r\n        let (sender, _receiver) = topic.split();\r\n        let sender = Arc::new(TokioMutex::new(sender));\r\n        let mut senders = self.senders.write().await;\r\n        senders.insert(topic_key, sender);\r\n\r\n        super::metrics::record_join_success();\r\n        let snap = super::metrics::snapshot();\r\n        info!(\r\n            target: METRICS_TARGET,\r\n            action = \"join\",\r\n            topic = %Self::fmt_topic_id(&topic_id),\r\n            joins = snap.joins,\r\n            join_failures = snap.join_details.failures,\r\n            leaves = snap.leaves,\r\n            broadcasts = snap.broadcasts_sent,\r\n            received = snap.messages_received,\r\n            \"Joined DHT topic\"\r\n        );\r\n        Ok(())\r\n    }\r\n\r\n    /// トピックから離脱\r\n    pub async fn leave_topic(&self, topic: &[u8]) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n        let mut senders = self.senders.write().await;\r\n        if senders.remove(&topic_key).is_some() {\r\n            super::metrics::record_leave_success();\r\n            let snap = super::metrics::snapshot();\r\n            info!(\r\n                target: METRICS_TARGET,\r\n                action = \"leave\",\r\n                topic = %Self::fmt_topic_id(&topic_id),\r\n                leaves = snap.leaves,\r\n                leave_failures = snap.leave_details.failures,\r\n                joins = snap.joins,\r\n                broadcasts = snap.broadcasts_sent,\r\n                received = snap.messages_received,\r\n                \"Left DHT topic\"\r\n            );\r\n            Ok(())\r\n        } else {\r\n            super::metrics::record_leave_failure();\r\n            debug!(\r\n                target: LOG_TARGET,\r\n                topic = %Self::fmt_topic_id(&topic_id),\r\n                \"Leave requested for non-joined topic\"\r\n            );\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /// メッセージをブロードキャスト\r\n    pub async fn broadcast(&self, topic: &[u8], message: Vec<u8>) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n\r\n        // 既存 Sender を探す。なければ参加して作成。\r\n        let sender_opt = {\r\n            let senders = self.senders.read().await;\r\n            senders.get(&topic_key).cloned()\r\n        };\r\n\r\n        let sender = match sender_opt {\r\n            Some(s) => s,\r\n            None => {\r\n                // 近傍指定なしで join（Receiver は破棄）\r\n                let topic: GossipTopic =\r\n                    self.gossip.subscribe(topic_id, vec![]).await.map_err(|e| {\r\n                        super::metrics::record_broadcast_failure();\r\n                        super::metrics::record_mainline_route_failure();\r\n                        warn!(\r\n                            target: LOG_TARGET,\r\n                            topic = %Self::fmt_topic_id(&topic_id),\r\n                            error = ?e,\r\n                            \"Failed to lazily subscribe before broadcast\"\r\n                        );\r\n                        AppError::P2PError(format!(\"Failed to subscribe before broadcast: {e:?}\"))\r\n                    })?;\r\n                let (sender, _receiver) = topic.split();\r\n                let sender = Arc::new(TokioMutex::new(sender));\r\n                let mut senders = self.senders.write().await;\r\n                senders.insert(topic_key.clone(), sender.clone());\r\n                sender\r\n            }\r\n        };\r\n\r\n        // ブロードキャスト\r\n        let guard = sender.lock().await;\r\n        let res = guard.broadcast(message.into()).await;\r\n\r\n        match res {\r\n            Ok(()) => {\r\n                super::metrics::record_broadcast_success();\r\n                super::metrics::record_mainline_route_success();\r\n                let snap = super::metrics::snapshot();\r\n                debug!(\r\n                    target: METRICS_TARGET,\r\n                    action = \"broadcast\",\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    broadcasts = snap.broadcasts_sent,\r\n                    broadcast_failures = snap.broadcast_details.failures,\r\n                    joins = snap.joins,\r\n                    leaves = snap.leaves,\r\n                    received = snap.messages_received,\r\n                    \"Broadcasted message on topic\"\r\n                );\r\n                Ok(())\r\n            }\r\n            Err(e) => {\r\n                super::metrics::record_broadcast_failure();\r\n                super::metrics::record_mainline_route_failure();\r\n                warn!(\r\n                    target: LOG_TARGET,\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    error = ?e,\r\n                    \"Failed to broadcast gossip message\"\r\n                );\r\n                Err(AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Gossipインスタンスを取得\r\n    pub fn gossip(&self) -> &Gossip {\r\n        &self.gossip\r\n    }\r\n\r\n    fn make_topic_id(topic: &[u8]) -> TopicId {\r\n        let hash = blake3::hash(topic);\r\n        TopicId::from_bytes(*hash.as_bytes())\r\n    }\r\n\r\n    fn topic_key(topic_id: &TopicId) -> String {\r\n        use std::fmt::Write as _;\r\n        let bytes = topic_id.as_bytes();\r\n        let mut s = String::with_capacity(64);\r\n        for b in bytes {\r\n            let _ = write!(&mut s, \"{b:02x}\");\r\n        }\r\n        s\r\n    }\r\n\r\n    fn fmt_topic_id(topic_id: &TopicId) -> String {\r\n        Self::topic_key(topic_id)\r\n    }\r\n}\r\n\r\n/// 共有シークレット管理（シンプル版）\r\npub mod secret {\r\n    use super::*;\r\n    use keyring::Entry;\r\n    use rand::Rng;\r\n\r\n    const SERVICE_NAME: &str = \"kukuri\";\r\n    const SECRET_KEY: &str = \"dht_secret\";\r\n\r\n    /// シークレットを取得または生成\r\n    pub async fn get_or_create_secret() -> Result<Vec<u8>, AppError> {\r\n        // キーリングから取得を試みる\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            if let Ok(secret_str) = entry.get_password() {\r\n                use base64::prelude::*;\r\n                if let Ok(secret) = BASE64_STANDARD.decode(secret_str) {\r\n                    return Ok(secret);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 新しいシークレットを生成\r\n        let mut rng = rand::rng();\n        let mut secret = vec![0u8; 32];\r\n        rng.fill(&mut secret[..]);\r\n\r\n        // キーリングに保存\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            use base64::prelude::*;\r\n            let secret_str = BASE64_STANDARD.encode(&secret);\r\n            let _ = entry.set_password(&secret_str);\r\n        }\r\n\r\n        Ok(secret)\r\n    }\r\n\r\n    /// シークレットをローテーション\r\n    pub async fn rotate_secret() -> Result<Vec<u8>, AppError> {\r\n        let mut rng = rand::rng();\n        let mut secret = vec![0u8; 32];\r\n        rng.fill(&mut secret[..]);\r\n\r\n        // キーリングに保存\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            use base64::prelude::*;\r\n            let secret_str = BASE64_STANDARD.encode(&secret);\r\n            let _ = entry.set_password(&secret_str);\r\n        }\r\n\r\n        info!(\"DHT secret rotated\");\r\n        Ok(secret)\r\n    }\r\n}\r\n\r\n/// フォールバック機構\r\npub mod fallback {\n    use super::*;\n    use crate::infrastructure::p2p::bootstrap_config;\n    use crate::infrastructure::p2p::metrics;\n\n    /// ハードコードされたブートストラップノード（将来的に設定ファイルから読み込み）\r\n    /// 形式: \"NodeId@Address\" (例: \"abc123...@192.168.1.1:11204\")\r\n    const FALLBACK_NODES: &[&str] = &[\r\n        // 本番環境用のブートストラップノードをここに追加\r\n        // 例: \"NodeId@IP:Port\"\r\n    ];\r\n\r\n    /// フォールバックノードに接続\r\n    pub async fn connect_to_fallback(endpoint: &Endpoint) -> Result<Vec<EndpointAddr>, AppError> {\n        let mut connected_nodes = Vec::new();\n\r\n        for node_str in FALLBACK_NODES {\r\n            match parse_node_addr(node_str) {\r\n                Ok(node_addr) => {\r\n                    // ノードに接続を試みる\r\n                    match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\r\n                        Ok(_) => {\r\n                            info!(\"Connected to fallback node: {}\", node_str);\r\n                            metrics::record_mainline_connection_success();\r\n                            connected_nodes.push(node_addr);\r\n                        }\r\n                        Err(e) => {\r\n                            metrics::record_mainline_connection_failure();\r\n                            debug!(\"Failed to connect to fallback node {}: {:?}\", node_str, e);\r\n                        }\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    metrics::record_mainline_connection_failure();\r\n                    debug!(\"Failed to parse node address {}: {:?}\", node_str, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if connected_nodes.is_empty() {\r\n            return Err(AppError::P2PError(\r\n                \"Failed to connect to any fallback nodes\".to_string(),\r\n            ));\r\n        }\r\n\r\n        metrics::record_bootstrap_source(BootstrapSource::Fallback);\r\n\r\n        Ok(connected_nodes)\r\n    }\r\n\r\n    /// ユーザーUI設定 または 設定ファイル（bootstrap_nodes.json）から NodeId@Addr を読み込み接続\r\n    pub async fn connect_from_config(endpoint: &Endpoint) -> Result<Vec<EndpointAddr>, AppError> {\n        // 1) ユーザー設定を優先\r\n        let mut node_addrs = bootstrap_config::load_user_bootstrap_node_addrs();\r\n        // 2) ユーザー設定が空なら、プロジェクト同梱のJSONを利用\r\n        if node_addrs.is_empty() {\r\n            node_addrs = bootstrap_config::load_bootstrap_node_addrs()?;\r\n        }\r\n        let mut connected = Vec::new();\r\n\r\n        for node_addr in node_addrs {\r\n            match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\r\n                Ok(_) => {\r\n                    info!(\"Connected to config bootstrap node: {}\", node_addr.id);\n                    metrics::record_mainline_connection_success();\r\n                    connected.push(node_addr);\r\n                }\r\n                Err(e) => {\r\n                    metrics::record_mainline_connection_failure();\r\n                    debug!(\"Failed to connect to config bootstrap node: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if connected.is_empty() {\r\n            return Err(AppError::P2PError(\r\n                \"Failed to connect to nodes from bootstrap_nodes.json\".to_string(),\r\n            ));\r\n        }\r\n\r\n        metrics::record_bootstrap_source(BootstrapSource::Fallback);\r\n\r\n        Ok(connected)\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[21590730,21587032,21587185,21587040,21587024,21590660,21590559,21587079],"length":1,"stats":{"Line":0}},{"line":29,"address":[21486789,21486890,21487391,21591465,21591599],"length":1,"stats":{"Line":0}},{"line":32,"address":[15628962,15631933,15629948],"length":1,"stats":{"Line":0}},{"line":34,"address":[21375853,21376454,21479391,21479257,21375929],"length":1,"stats":{"Line":0}},{"line":36,"address":[21458948],"length":1,"stats":{"Line":0}},{"line":37,"address":[17092174],"length":1,"stats":{"Line":0}},{"line":38,"address":[21589497,21590437],"length":1,"stats":{"Line":0}},{"line":43,"address":[21391456],"length":1,"stats":{"Line":0}},{"line":48,"address":[21391793],"length":1,"stats":{"Line":0}},{"line":49,"address":[21490872,21490941],"length":1,"stats":{"Line":0}},{"line":52,"address":[21496416,21491074,21490956,21496429],"length":1,"stats":{"Line":0}},{"line":53,"address":[17094420,17094666,17094239,17094838,17094478,17095249],"length":1,"stats":{"Line":0}},{"line":55,"address":[21392352],"length":1,"stats":{"Line":0}},{"line":56,"address":[21452678,21453424,21453601,21453298,21453358],"length":1,"stats":{"Line":0}},{"line":57,"address":[21465751,21467565,21465280,21460597,21466884],"length":1,"stats":{"Line":0}},{"line":58,"address":[21500439],"length":1,"stats":{"Line":0}},{"line":59,"address":[21486537,21486671,21391161,21390638,21391017,21391768,21392261,21392165],"length":1,"stats":{"Line":0}},{"line":61,"address":[21503245,21503738],"length":1,"stats":{"Line":0}},{"line":65,"address":[21392652,21391139],"length":1,"stats":{"Line":0}},{"line":69,"address":[21379351,21379609],"length":1,"stats":{"Line":0}},{"line":70,"address":[21461228,21461359],"length":1,"stats":{"Line":0}},{"line":71,"address":[15634226,15632411,15634640,15634317],"length":1,"stats":{"Line":0}},{"line":72,"address":[17096339,17096276],"length":1,"stats":{"Line":0}},{"line":74,"address":[21387588],"length":1,"stats":{"Line":0}},{"line":75,"address":[21387595],"length":1,"stats":{"Line":0}},{"line":76,"address":[21595064,21595798],"length":1,"stats":{"Line":0}},{"line":87,"address":[21499669],"length":1,"stats":{"Line":0}},{"line":91,"address":[21504400,21504911,21504370,21504594,21506914,21504447,21504352,21504637],"length":1,"stats":{"Line":0}},{"line":92,"address":[21498987],"length":1,"stats":{"Line":0}},{"line":93,"address":[21467919],"length":1,"stats":{"Line":0}},{"line":94,"address":[11459447],"length":1,"stats":{"Line":0}},{"line":95,"address":[15641976,15641200,15641279],"length":1,"stats":{"Line":0}},{"line":96,"address":[21470588],"length":1,"stats":{"Line":0}},{"line":97,"address":[15643383],"length":1,"stats":{"Line":0}},{"line":98,"address":[21507465,21599033,21599167,21509313,21507974,21508579,21507386],"length":1,"stats":{"Line":0}},{"line":109,"address":[21396433],"length":1,"stats":{"Line":0}},{"line":111,"address":[21600218],"length":1,"stats":{"Line":0}},{"line":112,"address":[21593945,21499861,21501450,21500388,21594079,21501347,21501035],"length":1,"stats":{"Line":0}},{"line":117,"address":[21469184],"length":1,"stats":{"Line":0}},{"line":122,"address":[21405552,21405614,21407145,21408527,21405859,21405506,21406268,21405488],"length":1,"stats":{"Line":0}},{"line":123,"address":[21398857],"length":1,"stats":{"Line":0}},{"line":124,"address":[21406034],"length":1,"stats":{"Line":0}},{"line":128,"address":[21399324,21398913,21399088,21399179],"length":1,"stats":{"Line":0}},{"line":129,"address":[17108411,17108348],"length":1,"stats":{"Line":0}},{"line":132,"address":[17108517],"length":1,"stats":{"Line":0}},{"line":133,"address":[21509715],"length":1,"stats":{"Line":0}},{"line":136,"address":[15657759,15648390,15647698,15656144,15646454,15647348,15658440,15656626,15647464],"length":1,"stats":{"Line":0}},{"line":138,"address":[17117239],"length":1,"stats":{"Line":0}},{"line":139,"address":[21408718],"length":1,"stats":{"Line":0}},{"line":140,"address":[21598511,21518585,21518964,21519715,21520112,21519108,21598377,21520208],"length":1,"stats":{"Line":0}},{"line":142,"address":[21616613,21616120],"length":1,"stats":{"Line":0}},{"line":146,"address":[21403959,21402446],"length":1,"stats":{"Line":0}},{"line":148,"address":[21512201,21512459],"length":1,"stats":{"Line":0}},{"line":149,"address":[21401185,21401054],"length":1,"stats":{"Line":0}},{"line":150,"address":[11438774],"length":1,"stats":{"Line":0}},{"line":151,"address":[21470391,21469728,21469799],"length":1,"stats":{"Line":0}},{"line":152,"address":[21512084],"length":1,"stats":{"Line":0}},{"line":157,"address":[11445584],"length":1,"stats":{"Line":0}},{"line":158,"address":[11520346],"length":1,"stats":{"Line":0}},{"line":160,"address":[21609736],"length":1,"stats":{"Line":0}},{"line":162,"address":[21513330],"length":1,"stats":{"Line":0}},{"line":163,"address":[21513403],"length":1,"stats":{"Line":0}},{"line":164,"address":[21609846],"length":1,"stats":{"Line":0}},{"line":165,"address":[21479547,21480302],"length":1,"stats":{"Line":0}},{"line":176,"address":[21610416],"length":1,"stats":{"Line":0}},{"line":178,"address":[15651005],"length":1,"stats":{"Line":0}},{"line":179,"address":[21513389],"length":1,"stats":{"Line":0}},{"line":180,"address":[21512209],"length":1,"stats":{"Line":0}},{"line":181,"address":[21512220,21595433,21513360,21513848,21595567,21512764],"length":1,"stats":{"Line":0}},{"line":187,"address":[21415295,21413783],"length":1,"stats":{"Line":0}},{"line":193,"address":[21516864],"length":1,"stats":{"Line":0}},{"line":197,"address":[17119520],"length":1,"stats":{"Line":0}},{"line":198,"address":[21417960],"length":1,"stats":{"Line":0}},{"line":199,"address":[21485731],"length":1,"stats":{"Line":0}},{"line":202,"address":[21411685,21411072],"length":1,"stats":{"Line":0}},{"line":204,"address":[21522614],"length":1,"stats":{"Line":0}},{"line":205,"address":[21485878],"length":1,"stats":{"Line":0}},{"line":206,"address":[21411341,21411152,21411224],"length":1,"stats":{"Line":0}},{"line":207,"address":[15658877],"length":1,"stats":{"Line":0}},{"line":209,"address":[21411307],"length":1,"stats":{"Line":0}},{"line":212,"address":[21486448],"length":1,"stats":{"Line":0}},{"line":213,"address":[21486465],"length":1,"stats":{"Line":0}},{"line":227,"address":[17120350,17120320,17120304,17120424,17121284,17122154],"length":1,"stats":{"Line":0}},{"line":229,"address":[17120383,17120489],"length":1,"stats":{"Line":0}},{"line":230,"address":[20824893,20824803],"length":1,"stats":{"Line":0}},{"line":232,"address":[20722202,20722080],"length":1,"stats":{"Line":0}},{"line":233,"address":[20790049],"length":1,"stats":{"Line":0}},{"line":239,"address":[20827261,20827317],"length":1,"stats":{"Line":0}},{"line":240,"address":[17121381],"length":1,"stats":{"Line":0}},{"line":241,"address":[20722961,20722874],"length":1,"stats":{"Line":0}},{"line":244,"address":[20722987],"length":1,"stats":{"Line":0}},{"line":246,"address":[20790858],"length":1,"stats":{"Line":0}},{"line":247,"address":[20790966,20791034],"length":1,"stats":{"Line":0}},{"line":250,"address":[14964003],"length":1,"stats":{"Line":0}},{"line":254,"address":[20829087,20830615,20828176,20828215,20828160,20828276],"length":1,"stats":{"Line":0}},{"line":255,"address":[20791489,20791584],"length":1,"stats":{"Line":0}},{"line":256,"address":[20923144],"length":1,"stats":{"Line":0}},{"line":257,"address":[20828434,20828533],"length":1,"stats":{"Line":0}},{"line":260,"address":[20822975],"length":1,"stats":{"Line":0}},{"line":262,"address":[20828670],"length":1,"stats":{"Line":0}},{"line":263,"address":[20724250,20724330],"length":1,"stats":{"Line":0}},{"line":266,"address":[17123706,17123133,17123879,17258447,17258313,17123056],"length":1,"stats":{"Line":0}},{"line":267,"address":[20785901],"length":1,"stats":{"Line":0}},{"line":285,"address":[12228824,12228848,12228910,12235985,12229272,12229032,12229075,12228816],"length":1,"stats":{"Line":0}},{"line":286,"address":[16661729],"length":1,"stats":{"Line":0}},{"line":288,"address":[12229125,12229222,12233658,12233595],"length":1,"stats":{"Line":0}},{"line":289,"address":[12233678,12234048],"length":1,"stats":{"Line":0}},{"line":290,"address":[16567822],"length":1,"stats":{"Line":0}},{"line":292,"address":[16623670,16628726,16623912,16628831,16624370],"length":1,"stats":{"Line":0}},{"line":294,"address":[16763081,16871897,16872031,16762876,16763574],"length":1,"stats":{"Line":0}},{"line":295,"address":[16557265],"length":1,"stats":{"Line":0}},{"line":296,"address":[16664273],"length":1,"stats":{"Line":0}},{"line":298,"address":[16549835],"length":1,"stats":{"Line":0}},{"line":299,"address":[24324907],"length":1,"stats":{"Line":0}},{"line":300,"address":[16559083,16666105,16666239,16558547],"length":1,"stats":{"Line":0}},{"line":304,"address":[16635693],"length":1,"stats":{"Line":0}},{"line":305,"address":[16670857],"length":1,"stats":{"Line":0}},{"line":306,"address":[16667092,16772521,16772655,16667628],"length":1,"stats":{"Line":0}},{"line":311,"address":[16666324,16666414],"length":1,"stats":{"Line":0}},{"line":312,"address":[16666638],"length":1,"stats":{"Line":0}},{"line":313,"address":[16553743],"length":1,"stats":{"Line":0}},{"line":317,"address":[16553716],"length":1,"stats":{"Line":0}},{"line":319,"address":[24328753],"length":1,"stats":{"Line":0}},{"line":323,"address":[16570082,16569808,16575726,16570024,16570863,16569887,16569840,16569816],"length":1,"stats":{"Line":0}},{"line":325,"address":[16570001],"length":1,"stats":{"Line":0}},{"line":327,"address":[16673012,16673112,16673503],"length":1,"stats":{"Line":0}},{"line":328,"address":[12236504,12237055],"length":1,"stats":{"Line":0}},{"line":330,"address":[12236470],"length":1,"stats":{"Line":0}},{"line":332,"address":[24331844,24336245,24331966,24336282,24336127],"length":1,"stats":{"Line":0}},{"line":333,"address":[16570054,16571353,16575621,16570895,16575138],"length":1,"stats":{"Line":0}},{"line":335,"address":[16639837,16639344,16639139,16741833,16741967],"length":1,"stats":{"Line":0}},{"line":336,"address":[16671000],"length":1,"stats":{"Line":0}},{"line":337,"address":[16566174],"length":1,"stats":{"Line":0}},{"line":339,"address":[16770722],"length":1,"stats":{"Line":0}},{"line":340,"address":[16632338],"length":1,"stats":{"Line":0}},{"line":341,"address":[16573347,16573883,16674703,16674569],"length":1,"stats":{"Line":0}},{"line":346,"address":[16678060],"length":1,"stats":{"Line":0}},{"line":347,"address":[16643219],"length":1,"stats":{"Line":0}},{"line":348,"address":[16561484],"length":1,"stats":{"Line":0}},{"line":352,"address":[16679745],"length":1,"stats":{"Line":0}},{"line":354,"address":[16636110],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":141},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_integration.rs"],"content":"//! DHT統合モジュール\n//! iroh-gossipとdistributed-topic-trackerの統合\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::{generate_topic_id, topic_id_bytes};\nuse crate::infrastructure::p2p::dht_bootstrap::DhtGossip;\nuse crate::shared::error::AppError;\n// use iroh_gossip::proto::Event as GossipEvent;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{debug, error};\n\n/// DHTイベントハンドラー\npub struct DhtEventHandler {\n    event_tx: mpsc::Sender<Event>,\n}\n\nimpl DhtEventHandler {\n    /// 新しいハンドラーを作成\n    pub fn new(event_tx: mpsc::Sender<Event>) -> Self {\n        Self { event_tx }\n    }\n\n    /// Gossipメッセージを処理\n    pub async fn handle_message(&self, data: &[u8], from: Option<String>) -> Result<(), AppError> {\n        debug!(\"Received message from {:?}\", from);\n\n        // メッセージをデシリアライズ\n        if let Ok(event) = self.deserialize_message(data).await {\n            // イベントチャンネルに送信\n            if let Err(e) = self.event_tx.send(event).await {\n                error!(\"Failed to send event: {:?}\", e);\n            }\n        }\n        Ok(())\n    }\n\n    /// メッセージをデシリアライズ\n    async fn deserialize_message(&self, data: &[u8]) -> Result<Event, AppError> {\n        bincode::serde::decode_from_slice::<Event, _>(data, bincode::config::standard())\n            .map(|(event, _)| event)\n            .map_err(|e| {\n                AppError::DeserializationError(format!(\"failed to deserialize DHT event: {e:?}\"))\n            })\n    }\n}\n\n/// DHT統合マネージャー\npub struct DhtIntegration {\n    dht_gossip: Arc<DhtGossip>,\n    event_handler: Option<DhtEventHandler>,\n}\n\nimpl DhtIntegration {\n    /// 新しい統合マネージャーを作成\n    pub fn new(dht_gossip: Arc<DhtGossip>) -> Self {\n        Self {\n            dht_gossip,\n            event_handler: None,\n        }\n    }\n\n    /// ????????????\n    pub fn set_event_handler(&mut self, event_tx: mpsc::Sender<Event>) {\n        self.event_handler = Some(DhtEventHandler::new(event_tx));\n    }\n\n    /// ???????\n    pub async fn join_topic(&self, topic: &str) -> Result<(), AppError> {\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.join_topic(&topic_bytes, vec![]).await?;\n        Ok(())\n    }\n\n    /// ????????\n    pub async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.leave_topic(&topic_bytes).await?;\n        Ok(())\n    }\n\n    /// ?????????????\n    pub async fn broadcast_event(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        // ???????????\n        let message = bincode::serde::encode_to_vec(event, bincode::config::standard())\n            .map_err(|e| AppError::SerializationError(format!(\"Failed to serialize: {e:?}\")))?;\n\n        // DHT?????????\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.broadcast(&topic_bytes, message).await?;\n\n        debug!(\n            \"Event broadcast to topic: {} (canonical: {})\",\n            topic, canonical\n        );\n        Ok(())\n    }\n}\n\n/// NostrとDHTのブリッジ\npub mod bridge {\n    use super::*;\n    use nostr_sdk::{Event as NostrEvent, JsonUtil};\n    use serde_json::json;\n    use std::convert::TryFrom;\n\n    /// NostrイベントをKukuriイベントに変換\n    pub fn nostr_to_kukuri(event: &NostrEvent) -> Result<Event, AppError> {\n        let timestamp_raw = event.created_at.as_secs();\n        let timestamp = i64::try_from(timestamp_raw).map_err(|_| {\n            AppError::DeserializationError(format!(\n                \"timestamp overflow when converting nostr event: {timestamp_raw}\"\n            ))\n        })?;\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(timestamp, 0).ok_or_else(|| {\n                AppError::DeserializationError(format!(\n                    \"invalid timestamp in nostr event: {timestamp}\"\n                ))\n            })?;\n\n        Ok(Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        })\n    }\n\n    /// KukuriイベントをNostrイベントに変換\n    pub fn kukuri_to_nostr(event: &Event) -> Result<NostrEvent, AppError> {\n        let payload = json!({\n            \"id\": event.id,\n            \"pubkey\": event.pubkey,\n            \"created_at\": event.created_at.timestamp(),\n            \"kind\": event.kind,\n            \"tags\": event.tags,\n            \"content\": event.content,\n            \"sig\": event.sig,\n        });\n\n        NostrEvent::from_json(payload.to_string())\n            .map_err(|e| AppError::NostrError(format!(\"Failed to convert event: {e}\")))\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use nostr_sdk::{EventBuilder, Keys, Tag};\n\n        #[test]\n        fn convert_nostr_to_domain_event() {\n            let keys = Keys::generate();\n            let event = EventBuilder::text_note(\"hello nostr to domain\")\n                .tags(vec![Tag::hashtag(\"kukuri\")])\n                .sign_with_keys(&keys)\n                .expect(\"signing succeeds\");\n\n            let converted = nostr_to_kukuri(&event).expect(\"conversion succeeds\");\n            assert_eq!(converted.id, event.id.to_string());\n            assert_eq!(converted.pubkey, event.pubkey.to_string());\n            assert_eq!(converted.kind, event.kind.as_u16() as u32);\n            assert_eq!(converted.content, event.content);\n            assert_eq!(converted.tags.len(), 1);\n            assert_eq!(converted.tags[0][0], \"t\");\n            assert_eq!(converted.sig, event.sig.to_string());\n        }\n\n        #[test]\n        fn convert_domain_to_nostr_event() {\n            let keys = Keys::generate();\n            let nostr_event = EventBuilder::text_note(\"roundtrip conversion\")\n                .tags(vec![Tag::hashtag(\"kukuri\")])\n                .sign_with_keys(&keys)\n                .expect(\"signing succeeds\");\n\n            let domain_event = nostr_to_kukuri(&nostr_event).expect(\"conversion succeeds\");\n\n            let rebuilt = kukuri_to_nostr(&domain_event).expect(\"rebuild succeeds\");\n            assert_eq!(rebuilt.id, nostr_event.id);\n            assert_eq!(rebuilt.pubkey, nostr_event.pubkey);\n            assert_eq!(rebuilt.kind, nostr_event.kind);\n            assert_eq!(rebuilt.content, nostr_event.content);\n            assert_eq!(rebuilt.tags, nostr_event.tags);\n            assert_eq!(rebuilt.sig, nostr_event.sig);\n            assert_eq!(rebuilt.created_at, nostr_event.created_at);\n        }\n    }\n}\n","traces":[{"line":19,"address":[26548112],"length":1,"stats":{"Line":0}},{"line":24,"address":[22293615,22296296,22293504,22293795,22298281,22295639,22293568,22293522],"length":1,"stats":{"Line":0}},{"line":25,"address":[22293767,22294443,22432815,22432681,22293914],"length":1,"stats":{"Line":0}},{"line":28,"address":[16430418,16431687,16431526,16429841],"length":1,"stats":{"Line":0}},{"line":30,"address":[22290457,22288262,22290721,22290584],"length":1,"stats":{"Line":0}},{"line":31,"address":[22253553,22252951,22389481,22389615,22253052],"length":1,"stats":{"Line":0}},{"line":34,"address":[22259494],"length":1,"stats":{"Line":0}},{"line":38,"address":[16434450,16434610,16434510,16434480,16434432,16434798],"length":1,"stats":{"Line":0}},{"line":39,"address":[22292999,22293086],"length":1,"stats":{"Line":0}},{"line":40,"address":[22194300,22194288],"length":1,"stats":{"Line":0}},{"line":41,"address":[16435090,16434864],"length":1,"stats":{"Line":0}},{"line":42,"address":[26554574,26554622],"length":1,"stats":{"Line":0}},{"line":55,"address":[26554800],"length":1,"stats":{"Line":0}},{"line":63,"address":[26554832,26554902],"length":1,"stats":{"Line":0}},{"line":64,"address":[22299166,22299245],"length":1,"stats":{"Line":0}},{"line":68,"address":[22263510,22262742,22262702,22262579,22263061,22262496,22262514,22262544],"length":1,"stats":{"Line":0}},{"line":69,"address":[22262682],"length":1,"stats":{"Line":0}},{"line":70,"address":[22297909,22297987],"length":1,"stats":{"Line":0}},{"line":71,"address":[16435877,16435513,16435676,16436153],"length":1,"stats":{"Line":0}},{"line":72,"address":[22256413],"length":1,"stats":{"Line":0}},{"line":76,"address":[22195778,22195760,22195808,22195966,22196006,22196282,22195843,22196731],"length":1,"stats":{"Line":0}},{"line":77,"address":[22182186],"length":1,"stats":{"Line":0}},{"line":78,"address":[22196053,22196131],"length":1,"stats":{"Line":0}},{"line":79,"address":[16436537,16437134,16436858,16436700],"length":1,"stats":{"Line":0}},{"line":80,"address":[22301090],"length":1,"stats":{"Line":0}},{"line":84,"address":[22183015,22183056,22183292,22183350,22186226,22183103,22184115,22182992],"length":1,"stats":{"Line":0}},{"line":86,"address":[22295985,22296112,22296380,22296797],"length":1,"stats":{"Line":0}},{"line":87,"address":[22258220,22260886,22260864],"length":1,"stats":{"Line":0}},{"line":90,"address":[22183585],"length":1,"stats":{"Line":0}},{"line":91,"address":[16438065,16438167],"length":1,"stats":{"Line":0}},{"line":92,"address":[22190106,22190681,22191224,22190931],"length":1,"stats":{"Line":0}},{"line":94,"address":[22389977,22259124,22259004,22390111,22259640],"length":1,"stats":{"Line":0}},{"line":98,"address":[26559423],"length":1,"stats":{"Line":0}},{"line":110,"address":[23670272,23671402],"length":1,"stats":{"Line":1}},{"line":111,"address":[15976854],"length":1,"stats":{"Line":1}},{"line":112,"address":[15970189,15971040,15969943],"length":1,"stats":{"Line":1}},{"line":113,"address":[16109542],"length":1,"stats":{"Line":0}},{"line":117,"address":[16108700,16108526,16109712,16108810],"length":1,"stats":{"Line":2}},{"line":119,"address":[16009365],"length":1,"stats":{"Line":0}},{"line":124,"address":[15896118],"length":1,"stats":{"Line":2}},{"line":125,"address":[15902442],"length":1,"stats":{"Line":1}},{"line":126,"address":[16012324],"length":1,"stats":{"Line":1}},{"line":128,"address":[16008517,16008587],"length":1,"stats":{"Line":2}},{"line":129,"address":[15903600,15903646,15902674],"length":1,"stats":{"Line":6}},{"line":130,"address":[16109042],"length":1,"stats":{"Line":2}},{"line":131,"address":[15909802],"length":1,"stats":{"Line":2}},{"line":136,"address":[15905580,15903696],"length":1,"stats":{"Line":1}},{"line":137,"address":[16110014,16110671,16110618,16111890],"length":1,"stats":{"Line":2}},{"line":140,"address":[23672567,23672503],"length":1,"stats":{"Line":2}},{"line":147,"address":[15912419,15912481],"length":1,"stats":{"Line":2}},{"line":148,"address":[15973590,15973568],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":51},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","discovery_options.rs"],"content":"use crate::shared::config::NetworkConfig;\nuse iroh::discovery::{\n    dns::DnsDiscovery,\n    mdns::MdnsDiscovery,\n    pkarr::{PkarrPublisher, dht::DhtDiscovery},\n};\n\n/// P2Pネットワークのディスカバリー設定\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct DiscoveryOptions {\n    pub enable_dns: bool,\n    pub enable_mainline: bool,\n    pub enable_local: bool,\n}\n\nimpl DiscoveryOptions {\n    pub fn new(enable_dns: bool, enable_mainline: bool, enable_local: bool) -> Self {\n        Self {\n            enable_dns,\n            enable_mainline,\n            enable_local,\n        }\n    }\n\n    pub fn with_mainline(mut self, enabled: bool) -> Self {\n        self.enable_mainline = enabled;\n        self\n    }\n\n    pub fn enable_mainline(&self) -> bool {\n        self.enable_mainline\n    }\n\n    pub fn apply_to_builder(\n        &self,\n        mut builder: iroh::endpoint::Builder,\n    ) -> iroh::endpoint::Builder {\n        builder = builder.clear_discovery();\n\n        if self.enable_dns {\n            builder = builder.discovery(PkarrPublisher::n0_dns());\n            builder = builder.discovery(DnsDiscovery::n0_dns());\n        }\n        if self.enable_mainline {\n            builder = builder.discovery(\n                DhtDiscovery::builder()\n                    .include_direct_addresses(true)\n                    .n0_dns_pkarr_relay(),\n            );\n        }\n        if self.enable_local {\n            builder = builder.discovery(MdnsDiscovery::builder());\n        }\n        builder\n    }\n}\n\nimpl Default for DiscoveryOptions {\n    fn default() -> Self {\n        Self {\n            enable_dns: true,\n            enable_mainline: true,\n            enable_local: false,\n        }\n    }\n}\n\nimpl From<&NetworkConfig> for DiscoveryOptions {\n    fn from(cfg: &NetworkConfig) -> Self {\n        Self {\n            enable_dns: cfg.enable_dns,\n            enable_mainline: cfg.enable_dht,\n            enable_local: cfg.enable_local,\n        }\n    }\n}\n","traces":[{"line":17,"address":[23810944],"length":1,"stats":{"Line":0}},{"line":25,"address":[15208432],"length":1,"stats":{"Line":0}},{"line":26,"address":[23916973],"length":1,"stats":{"Line":0}},{"line":27,"address":[15208481],"length":1,"stats":{"Line":0}},{"line":30,"address":[23804320],"length":1,"stats":{"Line":1}},{"line":31,"address":[24017397],"length":1,"stats":{"Line":2}},{"line":34,"address":[23811120,23812120,23812152],"length":1,"stats":{"Line":0}},{"line":38,"address":[23922697],"length":1,"stats":{"Line":0}},{"line":40,"address":[24017950,24017575],"length":1,"stats":{"Line":0}},{"line":41,"address":[23811317,23812199],"length":1,"stats":{"Line":0}},{"line":42,"address":[23805396,23804726],"length":1,"stats":{"Line":0}},{"line":44,"address":[23921153,23921771],"length":1,"stats":{"Line":0}},{"line":45,"address":[15209116,15209265,15209317],"length":1,"stats":{"Line":0}},{"line":46,"address":[23917702,23917642],"length":1,"stats":{"Line":0}},{"line":51,"address":[23818648,23819091],"length":1,"stats":{"Line":0}},{"line":52,"address":[15209378,15209549],"length":1,"stats":{"Line":0}},{"line":54,"address":[23811930],"length":1,"stats":{"Line":0}},{"line":69,"address":[23812256],"length":1,"stats":{"Line":0}},{"line":71,"address":[23887000],"length":1,"stats":{"Line":0}},{"line":72,"address":[24018549],"length":1,"stats":{"Line":0}},{"line":73,"address":[23880075],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":21},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","default.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse bincode::serde::encode_to_vec;\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info, warn};\n\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::{DistributionMetrics, DistributionStrategy};\nuse crate::infrastructure::p2p::{GossipService, NetworkService};\nuse crate::shared::error::AppError;\n\nuse super::state::DistributorState;\nuse super::{DynError, EventDistributor, P2PDistributionMetrics};\n\n/// デフォルトの EventDistributor 実装。\npub struct DefaultEventDistributor {\n    state: Arc<RwLock<DistributorState>>,\n    metrics: Arc<dyn DistributionMetrics>,\n    gossip_service: Arc<RwLock<Option<Arc<dyn GossipService>>>>,\n    network_service: Arc<RwLock<Option<Arc<dyn NetworkService>>>>,\n    default_topics: Arc<RwLock<Vec<String>>>,\n}\n\nimpl DefaultEventDistributor {\n    pub fn new() -> Self {\n        Self::with_strategy(DistributionStrategy::Hybrid)\n    }\n\n    pub fn with_strategy(strategy: DistributionStrategy) -> Self {\n        Self::with_strategy_and_metrics(\n            strategy,\n            Arc::new(P2PDistributionMetrics) as Arc<dyn DistributionMetrics>,\n        )\n    }\n\n    pub fn with_strategy_and_metrics(\n        strategy: DistributionStrategy,\n        metrics: Arc<dyn DistributionMetrics>,\n    ) -> Self {\n        Self {\n            state: Arc::new(RwLock::new(DistributorState::new(strategy))),\n            metrics,\n            gossip_service: Arc::new(RwLock::new(None)),\n            network_service: Arc::new(RwLock::new(None)),\n            default_topics: Arc::new(RwLock::new(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])),\n        }\n    }\n\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        let mut guard = self.gossip_service.write().await;\n        *guard = Some(gossip);\n    }\n\n    pub async fn set_network_service(&self, network: Arc<dyn NetworkService>) {\n        let mut guard = self.network_service.write().await;\n        *guard = Some(network);\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        let mut guard = self.default_topics.write().await;\n        guard.clear();\n        guard.extend(\n            topics\n                .into_iter()\n                .filter(|topic| !topic.trim().is_empty())\n                .map(|topic| topic.trim().to_string()),\n        );\n        if guard.is_empty() {\n            guard.push(DEFAULT_PUBLIC_TOPIC_ID.to_string());\n        }\n    }\n\n    async fn resolve_topics(&self, event: &Event) -> Vec<String> {\n        let mut topics: HashSet<String> = event\n            .tags\n            .iter()\n            .filter_map(|tag| {\n                if tag.is_empty() {\n                    return None;\n                }\n                match tag[0].as_str() {\n                    \"topic\" | \"t\" => tag.get(1).cloned(),\n                    _ => None,\n                }\n            })\n            .filter(|topic| !topic.trim().is_empty())\n            .map(|topic| topic.trim().to_string())\n            .collect();\n\n        if topics.is_empty() {\n            let defaults = self.default_topics.read().await;\n            topics.extend(defaults.iter().cloned());\n        }\n\n        let mut resolved: Vec<String> = topics.into_iter().collect();\n        resolved.sort();\n        resolved\n    }\n\n    async fn broadcast_via_gossip(&self, event: &Event, topics: &[String]) -> Result<(), DynError> {\n        if topics.is_empty() {\n            return Ok(());\n        }\n\n        let gossip = {\n            let guard = self.gossip_service.read().await;\n            guard.clone()\n        };\n\n        let Some(gossip) = gossip else {\n            warn!(\"GossipService not configured; skipping gossip broadcast\");\n            return Ok(());\n        };\n\n        for topic in topics {\n            if topic.is_empty() {\n                continue;\n            }\n\n            if let Err(err) = gossip.join_topic(topic, Vec::new()).await {\n                warn!(\"Joining topic {topic} failed before broadcast: {err}\");\n            }\n\n            gossip.broadcast(topic, event).await.map_err(|err| {\n                warn!(\n                    \"Failed to broadcast event {} on topic {} via gossip: {}\",\n                    event.id, topic, err\n                );\n                Box::new(err) as DynError\n            })?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_via_network(\n        &self,\n        event: &Event,\n        topics: &[String],\n    ) -> Result<(), DynError> {\n        if topics.is_empty() {\n            return Ok(());\n        }\n\n        let network = {\n            let guard = self.network_service.read().await;\n            guard.clone()\n        };\n\n        let Some(network) = network else {\n            return Ok(());\n        };\n\n        let payload = encode_to_vec(event, bincode::config::standard()).map_err(|err| {\n            Box::new(AppError::SerializationError(format!(\n                \"Failed to serialize event for DHT broadcast: {err}\"\n            ))) as DynError\n        })?;\n\n        for topic in topics {\n            if topic.is_empty() {\n                continue;\n            }\n\n            if let Err(err) = network.join_dht_topic(topic).await {\n                warn!(\"Failed to join DHT topic {topic} before broadcast: {}\", err);\n            }\n\n            network\n                .broadcast_dht(topic, payload.clone())\n                .await\n                .map_err(|err| Box::new(err) as DynError)?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_p2p(&self, event: &Event, topics: &[String]) -> Result<(), DynError> {\n        self.broadcast_via_gossip(event, topics).await?;\n        self.broadcast_via_network(event, topics).await?;\n        Ok(())\n    }\n\n    async fn broadcast_direct(&self, event: &Event, peer_id: &str) -> Result<(), DynError> {\n        if peer_id.trim().is_empty() {\n            warn!(\n                \"Direct distribution requested with empty peer id; falling back to standard P2P broadcast\"\n            );\n        } else {\n            let network = {\n                let guard = self.network_service.read().await;\n                guard.clone()\n            };\n\n            if let Some(network) = network {\n                if peer_id.contains('@') {\n                    if let Err(err) = network.add_peer(peer_id).await {\n                        warn!(\"Failed to add peer {peer_id} for direct distribution: {err}\");\n                    }\n                } else {\n                    warn!(\n                        \"Peer id \\\"{peer_id}\\\" is not in node_id@address format; skipping add_peer\"\n                    );\n                }\n            } else {\n                warn!(\n                    \"NetworkService not configured; direct distribution cannot target specific peer\"\n                );\n            }\n        }\n\n        let topics = self.resolve_topics(event).await;\n        self.broadcast_p2p(event, &topics).await\n    }\n\n    async fn distribute_internal(\n        &self,\n        event: &Event,\n        strategy: &DistributionStrategy,\n    ) -> Result<(), DynError> {\n        match strategy {\n            DistributionStrategy::Broadcast => {\n                debug!(\"Broadcasting event {} to all peers\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_p2p(event, &topics).await?;\n                info!(\"Event {} broadcasted via gossip/DHT\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Gossip => {\n                debug!(\"Distributing event {} via Gossip protocol\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_via_gossip(event, &topics).await?;\n                info!(\"Event {} distributed via gossip\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Direct(peer_id) => {\n                debug!(\"Sending event {} directly to peer {}\", event.id, peer_id);\n                self.broadcast_direct(event, peer_id).await?;\n                info!(\n                    \"Event {} distributed directly (peer {}) via fallback P2P path\",\n                    event.id, peer_id\n                );\n                Ok(())\n            }\n            DistributionStrategy::Hybrid => {\n                debug!(\"Distributing event {} using hybrid strategy\", event.id);\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::Nostr)).await?;\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::P2P)).await?;\n                Ok(())\n            }\n            DistributionStrategy::Nostr => {\n                debug!(\"Distributing event {} via Nostr relays\", event.id);\n                info!(\n                    \"Event {} marked for Nostr distribution (handled upstream)\",\n                    event.id\n                );\n                Ok(())\n            }\n            DistributionStrategy::P2P => {\n                debug!(\"Distributing event {} via P2P network\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_p2p(event, &topics).await?;\n                info!(\"Event {} distributed via P2P\", event.id);\n                Ok(())\n            }\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) async fn current_strategy(&self) -> DistributionStrategy {\n        self.state.read().await.strategy()\n    }\n}\n\nimpl Default for DefaultEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for DefaultEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        debug!(\n            \"Distributing event {} with strategy {:?}\",\n            event.id, strategy\n        );\n        self.metrics.record_attempt(&strategy);\n\n        match self.distribute_internal(event, &strategy).await {\n            Ok(()) => {\n                info!(\"Event {} distributed successfully\", event.id);\n                self.metrics.record_success(&strategy);\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"Failed to distribute event {}: {}\", event.id, e);\n                self.metrics.record_failure(&strategy);\n\n                let mut state = self.state.write().await;\n                state.record_failure(event.clone(), strategy);\n\n                Err(e)\n            }\n        }\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        let mut state = self.state.write().await;\n        Ok(state.pop_pending())\n    }\n\n    async fn set_strategy(&self, strategy: DistributionStrategy) {\n        let mut state = self.state.write().await;\n        debug!(\"Setting distribution strategy to {:?}\", strategy);\n        state.set_strategy(strategy);\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        let state = self.state.read().await;\n        Ok(state.pending_events_snapshot())\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        let mut state = self.state.write().await;\n        let failed_events = state.drain_failures();\n        let mut retry_count = 0;\n        let mut still_failed = Vec::new();\n\n        for (event, strategy) in failed_events {\n            debug!(\"Retrying distribution for event {}\", event.id);\n            match self.distribute_internal(&event, &strategy).await {\n                Ok(()) => {\n                    info!(\"Event {} successfully distributed on retry\", event.id);\n                    self.metrics.record_success(&strategy);\n                    retry_count += 1;\n                }\n                Err(e) => {\n                    error!(\"Event {} failed again on retry: {}\", event.id, e);\n                    self.metrics.record_failure(&strategy);\n                    still_failed.push((event, strategy));\n                }\n            }\n        }\n\n        state.restore_failures(still_failed);\n\n        Ok(retry_count)\n    }\n}\n","traces":[{"line":28,"address":[22976592],"length":1,"stats":{"Line":1}},{"line":29,"address":[18076748],"length":1,"stats":{"Line":2}},{"line":32,"address":[23044535,23044561,23044400],"length":1,"stats":{"Line":2}},{"line":34,"address":[17217198],"length":1,"stats":{"Line":2}},{"line":35,"address":[23175993],"length":1,"stats":{"Line":2}},{"line":39,"address":[22977753,22977720,22976816],"length":1,"stats":{"Line":2}},{"line":44,"address":[17217459,17217387],"length":1,"stats":{"Line":4}},{"line":46,"address":[22970133,22970035],"length":1,"stats":{"Line":3}},{"line":47,"address":[23081674,23081772],"length":1,"stats":{"Line":3}},{"line":48,"address":[22977729,22977349,22977291],"length":1,"stats":{"Line":3}},{"line":52,"address":[23038642,23038697,23038843,23038624,23039014,23038672,23039610,23039589],"length":1,"stats":{"Line":5}},{"line":53,"address":[23082519,23082566,23082626,23082742],"length":1,"stats":{"Line":4}},{"line":54,"address":[23039570,23039543,23039253],"length":1,"stats":{"Line":2}},{"line":57,"address":[23178363,23178192,23178534,23179130,23178162,23178144,23179109,23178217],"length":1,"stats":{"Line":0}},{"line":58,"address":[17219622,17219682,17219575,17219798],"length":1,"stats":{"Line":0}},{"line":59,"address":[23047511,23047538,23047221],"length":1,"stats":{"Line":0}},{"line":62,"address":[23179570,23179232,23179184,23179257,23180287,23179192,23179391,23180266],"length":1,"stats":{"Line":0}},{"line":63,"address":[11067409],"length":1,"stats":{"Line":0}},{"line":64,"address":[23083452,23083385],"length":1,"stats":{"Line":0}},{"line":65,"address":[23048491,23048343],"length":1,"stats":{"Line":0}},{"line":66,"address":[23083484],"length":1,"stats":{"Line":0}},{"line":68,"address":[23079993,23079968],"length":1,"stats":{"Line":0}},{"line":69,"address":[23085648,23085616],"length":1,"stats":{"Line":0}},{"line":71,"address":[23085437,23085285],"length":1,"stats":{"Line":0}},{"line":72,"address":[23041642,23041679],"length":1,"stats":{"Line":0}},{"line":76,"address":[23042096,23042356,23042414,23042109,23043751,23042990,23042191,23042144],"length":1,"stats":{"Line":4}},{"line":77,"address":[23049408,23049253],"length":1,"stats":{"Line":3}},{"line":80,"address":[23043792],"length":1,"stats":{"Line":0}},{"line":81,"address":[22982997],"length":1,"stats":{"Line":0}},{"line":82,"address":[23182392],"length":1,"stats":{"Line":0}},{"line":84,"address":[23043844],"length":1,"stats":{"Line":0}},{"line":85,"address":[22983052,22983104],"length":1,"stats":{"Line":0}},{"line":86,"address":[23086056],"length":1,"stats":{"Line":0}},{"line":89,"address":[22976249,22976224],"length":1,"stats":{"Line":0}},{"line":90,"address":[23082240,23082208],"length":1,"stats":{"Line":0}},{"line":93,"address":[22974876,22974955],"length":1,"stats":{"Line":3}},{"line":94,"address":[18082066,18081929,18081470],"length":1,"stats":{"Line":3}},{"line":95,"address":[17223076,17222986],"length":1,"stats":{"Line":6}},{"line":98,"address":[22968903,22968177],"length":1,"stats":{"Line":6}},{"line":99,"address":[22969011,22968930],"length":1,"stats":{"Line":6}},{"line":100,"address":[23087326],"length":1,"stats":{"Line":3}},{"line":103,"address":[23051223,23051886,23051200,23051295,23051248,23051557,23054216,23051472],"length":1,"stats":{"Line":12}},{"line":104,"address":[23051436,23051611],"length":1,"stats":{"Line":6}},{"line":105,"address":[23183200],"length":1,"stats":{"Line":0}},{"line":109,"address":[11763745],"length":1,"stats":{"Line":6}},{"line":110,"address":[17225047,17224968],"length":1,"stats":{"Line":6}},{"line":113,"address":[18084408],"length":1,"stats":{"Line":3}},{"line":114,"address":[23083667,23084401,23201961,23202118,23083880],"length":1,"stats":{"Line":0}},{"line":115,"address":[23084377],"length":1,"stats":{"Line":0}},{"line":118,"address":[23091589,23089343,23089209,23091435,23091517],"length":1,"stats":{"Line":15}},{"line":119,"address":[23091609,23091659],"length":1,"stats":{"Line":6}},{"line":123,"address":[11763765],"length":1,"stats":{"Line":6}},{"line":124,"address":[22988415,22987889,22987788,23103545,23103702],"length":1,"stats":{"Line":0}},{"line":127,"address":[11652281],"length":1,"stats":{"Line":6}},{"line":128,"address":[22976175,22976595,23090470,22976251,22976836,23090313],"length":1,"stats":{"Line":0}},{"line":132,"address":[23050751,23051309],"length":1,"stats":{"Line":0}},{"line":136,"address":[18086761],"length":1,"stats":{"Line":3}},{"line":139,"address":[18091392],"length":1,"stats":{"Line":3}},{"line":144,"address":[22985077,22985255],"length":1,"stats":{"Line":6}},{"line":145,"address":[23060028],"length":1,"stats":{"Line":0}},{"line":149,"address":[11729892],"length":1,"stats":{"Line":6}},{"line":150,"address":[18092468,18092405],"length":1,"stats":{"Line":6}},{"line":153,"address":[22979256],"length":1,"stats":{"Line":3}},{"line":154,"address":[23060879],"length":1,"stats":{"Line":3}},{"line":157,"address":[22983424,22979328,22979432,22979842,22979678,22983664],"length":1,"stats":{"Line":0}},{"line":158,"address":[23096203,23096143],"length":1,"stats":{"Line":0}},{"line":163,"address":[18093791,18093641,18092904,18093719,18093072],"length":1,"stats":{"Line":0}},{"line":164,"address":[23193695,23193619],"length":1,"stats":{"Line":0}},{"line":168,"address":[11761099],"length":1,"stats":{"Line":0}},{"line":169,"address":[17235638,17345145,17235537,17236164,17345302],"length":1,"stats":{"Line":0}},{"line":172,"address":[22990062,22987018,22989837,22989997,22986898,22990105,22987194],"length":1,"stats":{"Line":0}},{"line":173,"address":[23064626],"length":1,"stats":{"Line":0}},{"line":174,"address":[23092866,23096004,23095953,23091105,23092673],"length":1,"stats":{"Line":0}},{"line":175,"address":[23065217,23061898,23065216],"length":1,"stats":{"Line":0}},{"line":178,"address":[23093196],"length":1,"stats":{"Line":0}},{"line":181,"address":[23100460,23101405,23100391,23100617,23100416,23100804,23100368,23100672],"length":1,"stats":{"Line":10}},{"line":182,"address":[11627585],"length":1,"stats":{"Line":6}},{"line":183,"address":[22998344,22998241,22998534,22998836,22997779],"length":1,"stats":{"Line":6}},{"line":184,"address":[18098159],"length":1,"stats":{"Line":3}},{"line":187,"address":[22985168,22991468,22985191,22985216,22985278,22985554,22985448,22987373],"length":1,"stats":{"Line":0}},{"line":188,"address":[23098111,23098321,23106280],"length":1,"stats":{"Line":0}},{"line":189,"address":[18099475,18098779,18098962,18345321,18345455],"length":1,"stats":{"Line":0}},{"line":194,"address":[23103932,23103766,23104045,23105693],"length":1,"stats":{"Line":0}},{"line":195,"address":[23100375,23100454],"length":1,"stats":{"Line":0}},{"line":198,"address":[23100563],"length":1,"stats":{"Line":0}},{"line":199,"address":[22988052,22987928],"length":1,"stats":{"Line":0}},{"line":200,"address":[11843314],"length":1,"stats":{"Line":0}},{"line":201,"address":[23173574,23073340,23073967,23073441,23173417],"length":1,"stats":{"Line":0}},{"line":204,"address":[17346886,17242362,17242439,17242969,17346729],"length":1,"stats":{"Line":0}},{"line":209,"address":[23209593,23107151,23106605,23104606,23209750],"length":1,"stats":{"Line":0}},{"line":215,"address":[23098224,23099075,23106437,23106308],"length":1,"stats":{"Line":0}},{"line":216,"address":[11843355],"length":1,"stats":{"Line":0}},{"line":219,"address":[23112784],"length":1,"stats":{"Line":2}},{"line":224,"address":[23069349],"length":1,"stats":{"Line":3}},{"line":226,"address":[23107736,23107996,23206185,23108538,23206342],"length":1,"stats":{"Line":3}},{"line":227,"address":[11072913],"length":1,"stats":{"Line":2}},{"line":228,"address":[11754744],"length":1,"stats":{"Line":2}},{"line":229,"address":[23100950,23015029,23100793,23014925,23015571],"length":1,"stats":{"Line":3}},{"line":230,"address":[23008742],"length":1,"stats":{"Line":1}},{"line":233,"address":[22996999,22995063,22997541,23094537,23094694],"length":1,"stats":{"Line":0}},{"line":234,"address":[23011256,23008653,23012368,23023672],"length":1,"stats":{"Line":0}},{"line":235,"address":[11855158],"length":1,"stats":{"Line":0}},{"line":236,"address":[18348927,18123182,18123799,18123282,18348793],"length":1,"stats":{"Line":0}},{"line":237,"address":[23092843],"length":1,"stats":{"Line":0}},{"line":239,"address":[23111742],"length":1,"stats":{"Line":0}},{"line":240,"address":[23102377,23001898,23005490,23102534,23006056],"length":1,"stats":{"Line":0}},{"line":241,"address":[11723629],"length":1,"stats":{"Line":0}},{"line":242,"address":[18125816,18125220,18349785,18125320,18349919],"length":1,"stats":{"Line":0}},{"line":246,"address":[23226478],"length":1,"stats":{"Line":0}},{"line":249,"address":[18113297,18350281,18350415,18113817,18107977],"length":1,"stats":{"Line":3}},{"line":250,"address":[11754836],"length":1,"stats":{"Line":2}},{"line":251,"address":[11648939],"length":1,"stats":{"Line":2}},{"line":252,"address":[23132142],"length":1,"stats":{"Line":1}},{"line":255,"address":[18350911,18114983,18115493,18108008,18350777],"length":1,"stats":{"Line":3}},{"line":256,"address":[23215888,23310777,23310934,23217000,23217521],"length":1,"stats":{"Line":4}},{"line":260,"address":[23117129],"length":1,"stats":{"Line":2}},{"line":263,"address":[23006132,23098233,23098390,23005590,22995207],"length":1,"stats":{"Line":3}},{"line":264,"address":[11760466],"length":1,"stats":{"Line":2}},{"line":265,"address":[11754905],"length":1,"stats":{"Line":4}},{"line":266,"address":[23133072,23215401,23215558,23133718,23133176],"length":1,"stats":{"Line":6}},{"line":267,"address":[23129737],"length":1,"stats":{"Line":2}},{"line":273,"address":[18130400,18130435,18131083,18130679,18130384,18130392,18130550,18130513],"length":1,"stats":{"Line":4}},{"line":274,"address":[18130607,18130501,18130540,18130711],"length":1,"stats":{"Line":2}},{"line":279,"address":[23018112],"length":1,"stats":{"Line":0}},{"line":280,"address":[23231192],"length":1,"stats":{"Line":0}},{"line":286,"address":[23113173,23113054,23106159,23108622,23106409,23106039,23106112,23106297,23106450,23106700,23110690,23112561],"length":1,"stats":{"Line":8}},{"line":291,"address":[18353413,18371897,18372031,18353333,18353934],"length":1,"stats":{"Line":5}},{"line":295,"address":[23101691,23100465],"length":1,"stats":{"Line":4}},{"line":297,"address":[11328405],"length":1,"stats":{"Line":2}},{"line":299,"address":[23119529,23102763,23102213,23119686,23102111],"length":1,"stats":{"Line":3}},{"line":300,"address":[23117602,23116470],"length":1,"stats":{"Line":2}},{"line":301,"address":[23220502],"length":1,"stats":{"Line":1}},{"line":303,"address":[18355523],"length":1,"stats":{"Line":0}},{"line":304,"address":[23194806,23179123,23178573,23176767,23194649],"length":1,"stats":{"Line":0}},{"line":305,"address":[18358946,18357808],"length":1,"stats":{"Line":0}},{"line":307,"address":[12041756],"length":1,"stats":{"Line":0}},{"line":308,"address":[23222732,23222665],"length":1,"stats":{"Line":0}},{"line":310,"address":[23112974],"length":1,"stats":{"Line":0}},{"line":315,"address":[23120217,23120502,23120256,23120291,23120721,23120479,23121146,23120390],"length":1,"stats":{"Line":0}},{"line":316,"address":[19595492],"length":1,"stats":{"Line":0}},{"line":317,"address":[18360463,18360528],"length":1,"stats":{"Line":0}},{"line":320,"address":[23322894,23320791,23320591,23320560,23320495,23320954,23320748],"length":1,"stats":{"Line":4}},{"line":321,"address":[11838241],"length":1,"stats":{"Line":2}},{"line":322,"address":[23182824,23195334,23195177,23182745,23183358],"length":1,"stats":{"Line":3}},{"line":323,"address":[23122489,23123501],"length":1,"stats":{"Line":2}},{"line":326,"address":[18363136,18363618,18363270,18363097,18363379,18364053,18363171,18363403],"length":1,"stats":{"Line":5}},{"line":327,"address":[23223087,23223238,23222865],"length":1,"stats":{"Line":1}},{"line":328,"address":[23229064,23229143],"length":1,"stats":{"Line":2}},{"line":331,"address":[23192560,23192757,23193180,23192885,23192619,23193910,23198755,23192511,23192922],"length":1,"stats":{"Line":5}},{"line":332,"address":[23186107,23186284,23185859],"length":1,"stats":{"Line":1}},{"line":333,"address":[17366345,17366238],"length":1,"stats":{"Line":2}},{"line":334,"address":[23325132],"length":1,"stats":{"Line":1}},{"line":335,"address":[23125835],"length":1,"stats":{"Line":1}},{"line":337,"address":[23329905,23329790,23325227,23329973,23325355],"length":1,"stats":{"Line":3}},{"line":338,"address":[23198517,23198767,23199318,23202633,23202790],"length":1,"stats":{"Line":0}},{"line":339,"address":[11837666],"length":1,"stats":{"Line":0}},{"line":340,"address":[23196020],"length":1,"stats":{"Line":0}},{"line":341,"address":[23194872,23203161,23194225,23194323,23203318],"length":1,"stats":{"Line":0}},{"line":342,"address":[23227135],"length":1,"stats":{"Line":0}},{"line":343,"address":[23121286,23121238],"length":1,"stats":{"Line":0}},{"line":345,"address":[23126493],"length":1,"stats":{"Line":0}},{"line":346,"address":[23128356,23135929,23126525,23136086,23128905],"length":1,"stats":{"Line":0}},{"line":347,"address":[23130070,23128853],"length":1,"stats":{"Line":0}},{"line":348,"address":[23116333],"length":1,"stats":{"Line":0}},{"line":353,"address":[23235316],"length":1,"stats":{"Line":1}},{"line":355,"address":[23235414],"length":1,"stats":{"Line":1}}],"covered":84,"coverable":166},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","metrics.rs"],"content":"use crate::domain::p2p::distribution::{DistributionMetrics, DistributionStrategy};\nuse crate::infrastructure::p2p::metrics;\n\npub struct P2PDistributionMetrics;\n\nimpl DistributionMetrics for P2PDistributionMetrics {\n    fn record_success(&self, strategy: &DistributionStrategy) {\n        match strategy {\n            DistributionStrategy::Nostr => metrics::record_broadcast_success(),\n            DistributionStrategy::P2P\n            | DistributionStrategy::Broadcast\n            | DistributionStrategy::Gossip\n            | DistributionStrategy::Direct(_)\n            | DistributionStrategy::Hybrid => metrics::record_broadcast_success(),\n        }\n    }\n\n    fn record_failure(&self, strategy: &DistributionStrategy) {\n        match strategy {\n            DistributionStrategy::Nostr => metrics::record_broadcast_failure(),\n            DistributionStrategy::P2P\n            | DistributionStrategy::Broadcast\n            | DistributionStrategy::Gossip\n            | DistributionStrategy::Direct(_)\n            | DistributionStrategy::Hybrid => metrics::record_broadcast_failure(),\n        }\n    }\n}\n","traces":[{"line":7,"address":[20829008],"length":1,"stats":{"Line":1}},{"line":8,"address":[20719166],"length":1,"stats":{"Line":1}},{"line":9,"address":[20830738],"length":1,"stats":{"Line":1}},{"line":10,"address":[20925514],"length":1,"stats":{"Line":2}},{"line":18,"address":[15209840],"length":1,"stats":{"Line":0}},{"line":19,"address":[20712478],"length":1,"stats":{"Line":0}},{"line":20,"address":[20925618],"length":1,"stats":{"Line":0}},{"line":21,"address":[20794058],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","mod.rs"],"content":"use async_trait::async_trait;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\n\nmod default;\nmod metrics;\nmod state;\nmod strategy;\n\npub use default::DefaultEventDistributor;\npub use metrics::P2PDistributionMetrics;\npub use strategy::{NostrEventDistributor, P2PEventDistributor};\n\npub type DynError = Box<dyn std::error::Error + Send + Sync>;\n\n#[async_trait]\npub trait EventDistributor: Send + Sync {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), DynError>;\n    async fn receive(&self) -> Result<Option<Event>, DynError>;\n    async fn set_strategy(&self, strategy: DistributionStrategy);\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError>;\n    async fn retry_failed(&self) -> Result<u32, DynError>;\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","state.rs"],"content":"use std::collections::VecDeque;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\n\npub(crate) struct DistributorState {\n    strategy: DistributionStrategy,\n    pending_events: VecDeque<Event>,\n    failed_events: Vec<(Event, DistributionStrategy)>,\n}\n\nimpl DistributorState {\n    pub(crate) fn new(strategy: DistributionStrategy) -> Self {\n        Self {\n            strategy,\n            pending_events: VecDeque::new(),\n            failed_events: Vec::new(),\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn strategy(&self) -> DistributionStrategy {\n        self.strategy.clone()\n    }\n\n    pub(crate) fn set_strategy(&mut self, strategy: DistributionStrategy) {\n        self.strategy = strategy;\n    }\n\n    pub(crate) fn pop_pending(&mut self) -> Option<Event> {\n        self.pending_events.pop_front()\n    }\n\n    pub(crate) fn pending_events_snapshot(&self) -> Vec<Event> {\n        self.pending_events.iter().cloned().collect()\n    }\n\n    pub(crate) fn record_failure(&mut self, event: Event, strategy: DistributionStrategy) {\n        self.failed_events.push((event, strategy));\n    }\n\n    pub(crate) fn drain_failures(&mut self) -> Vec<(Event, DistributionStrategy)> {\n        std::mem::take(&mut self.failed_events)\n    }\n\n    pub(crate) fn restore_failures(&mut self, still_failed: Vec<(Event, DistributionStrategy)>) {\n        self.failed_events = still_failed;\n    }\n}\n","traces":[{"line":13,"address":[19850160,19850392],"length":1,"stats":{"Line":1}},{"line":16,"address":[19813422],"length":1,"stats":{"Line":2}},{"line":17,"address":[19745713],"length":1,"stats":{"Line":1}},{"line":22,"address":[16450560],"length":1,"stats":{"Line":1}},{"line":23,"address":[16450577],"length":1,"stats":{"Line":1}},{"line":26,"address":[19738969,19738912],"length":1,"stats":{"Line":1}},{"line":27,"address":[19732220,19732146],"length":1,"stats":{"Line":2}},{"line":30,"address":[19844960],"length":1,"stats":{"Line":0}},{"line":31,"address":[19945345],"length":1,"stats":{"Line":0}},{"line":34,"address":[13986608],"length":1,"stats":{"Line":1}},{"line":35,"address":[19845026],"length":1,"stats":{"Line":1}},{"line":38,"address":[16450848],"length":1,"stats":{"Line":0}},{"line":39,"address":[19945475],"length":1,"stats":{"Line":0}},{"line":42,"address":[16450960],"length":1,"stats":{"Line":1}},{"line":43,"address":[19732529],"length":1,"stats":{"Line":1}},{"line":46,"address":[19849200,19849257],"length":1,"stats":{"Line":1}},{"line":47,"address":[19845356,19845282],"length":1,"stats":{"Line":2}}],"covered":13,"coverable":17},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","strategy.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\nuse crate::infrastructure::p2p::{GossipService, NetworkService};\n\nuse super::default::DefaultEventDistributor;\nuse super::{DynError, EventDistributor};\n\n/// P2P 配信専用のディストリビューター。\npub struct P2PEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl P2PEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::P2P),\n        }\n    }\n\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        self.distributor.set_gossip_service(gossip).await;\n    }\n\n    pub async fn set_network_service(&self, network: Arc<dyn NetworkService>) {\n        self.distributor.set_network_service(network).await;\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        self.distributor.set_default_topics(topics).await;\n    }\n}\n\nimpl Default for P2PEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for P2PEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        self.distributor\n            .distribute(event, DistributionStrategy::P2P)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // 固定戦略のため何もしない\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        self.distributor.retry_failed().await\n    }\n}\n\n/// Nostr 配信専用のディストリビューター。\npub struct NostrEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl NostrEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::Nostr),\n        }\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        self.distributor.set_default_topics(topics).await;\n    }\n}\n\nimpl Default for NostrEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for NostrEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        self.distributor\n            .distribute(event, DistributionStrategy::Nostr)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // 固定戦略のため何もしない\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        self.distributor.retry_failed().await\n    }\n}\n","traces":[{"line":18,"address":[21043280],"length":1,"stats":{"Line":1}},{"line":20,"address":[16825613],"length":1,"stats":{"Line":1}},{"line":24,"address":[16944533,16944195,16943986,16944016,16944041,16943968,16944315,16944158],"length":1,"stats":{"Line":4}},{"line":25,"address":[16944185,16944242,16944139,16944347],"length":1,"stats":{"Line":2}},{"line":28,"address":[16907824,16908003,16907849,16907966,16908123,16907794,16908341,16907776],"length":1,"stats":{"Line":0}},{"line":29,"address":[16833211,16833419,16833257,16833314],"length":1,"stats":{"Line":0}},{"line":32,"address":[16833616,16834180,16833624,16833689,16833664,16833842,16833962,16833805],"length":1,"stats":{"Line":0}},{"line":33,"address":[21044658,21044692,21044762,21044846],"length":1,"stats":{"Line":0}},{"line":38,"address":[16908928],"length":1,"stats":{"Line":0}},{"line":39,"address":[16902008],"length":1,"stats":{"Line":0}},{"line":45,"address":[17009407,17009168,17009290,17009650,17009102,17009203,17009774,17010016,17009372],"length":1,"stats":{"Line":4}},{"line":50,"address":[17011384,17011542,17011269],"length":1,"stats":{"Line":3}},{"line":51,"address":[16892954],"length":1,"stats":{"Line":1}},{"line":52,"address":[11937278],"length":1,"stats":{"Line":3}},{"line":55,"address":[17010163,17010128,17010089,17010834,17010262,17010374,17010351,17010574],"length":1,"stats":{"Line":0}},{"line":56,"address":[16900750,16900433,16900618],"length":1,"stats":{"Line":0}},{"line":59,"address":[17107358,17107344,17107289],"length":1,"stats":{"Line":0}},{"line":63,"address":[17011941,17011445,17011417,17011657,17011129,17011302,17011203,17011168],"length":1,"stats":{"Line":0}},{"line":64,"address":[16901473,16901833,16901701],"length":1,"stats":{"Line":0}},{"line":67,"address":[17012016,17012051,17012441,17011977,17012120,17012206,17012234,17012656],"length":1,"stats":{"Line":0}},{"line":68,"address":[21180354,21180473,21180163],"length":1,"stats":{"Line":0}},{"line":78,"address":[16841200],"length":1,"stats":{"Line":1}},{"line":80,"address":[16841213],"length":1,"stats":{"Line":1}},{"line":84,"address":[16940272,16940570,16940450,16940224,16940788,16940297,16940413,16940232],"length":1,"stats":{"Line":0}},{"line":85,"address":[17040865,17040808,17040970,17040757],"length":1,"stats":{"Line":0}},{"line":90,"address":[16946384],"length":1,"stats":{"Line":0}},{"line":91,"address":[16834888],"length":1,"stats":{"Line":0}},{"line":97,"address":[21181222,21180787,21180686,21180752,21181564,21181334,21180874,21180956,21180983],"length":1,"stats":{"Line":4}},{"line":102,"address":[17013205,17013320,17013478],"length":1,"stats":{"Line":3}},{"line":103,"address":[17013178],"length":1,"stats":{"Line":1}},{"line":104,"address":[16896261,16896649,16896693,16896750,16896880],"length":1,"stats":{"Line":3}},{"line":107,"address":[11151411,11151510,11151599,11151622,11151822,11152082,11151337,11151376],"length":1,"stats":{"Line":0}},{"line":108,"address":[11934420],"length":1,"stats":{"Line":0}},{"line":111,"address":[17014441,17014496,17014510],"length":1,"stats":{"Line":0}},{"line":115,"address":[16905030,16905173,16905385,16905669,16905145,16904896,16904931,16904857],"length":1,"stats":{"Line":0}},{"line":116,"address":[11851412],"length":1,"stats":{"Line":0}},{"line":119,"address":[16973513,16973770,16973552,16973656,16974192,16973587,16973742,16973977],"length":1,"stats":{"Line":0}},{"line":120,"address":[17011990,17012121,17011795],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","tests.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse tokio::sync::{Mutex, mpsc};\n\nuse crate::domain::entities::{Event, EventKind};\nuse crate::domain::p2p::distribution::DistributionStrategy;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\n\nuse super::EventDistributor;\nuse super::default::DefaultEventDistributor;\nuse super::strategy::{NostrEventDistributor, P2PEventDistributor};\n\n#[derive(Clone, Default)]\nstruct DummyGossipService {\n    broadcasts: Arc<Mutex<Vec<(String, String)>>>,\n    joined: Arc<Mutex<HashSet<String>>>,\n}\n\nimpl DummyGossipService {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    async fn broadcast_count(&self) -> usize {\n        let guard = self.broadcasts.lock().await;\n        guard.len()\n    }\n}\n\n#[async_trait]\nimpl GossipService for DummyGossipService {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        let mut guard = self.joined.lock().await;\n        guard.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        let mut guard = self.joined.lock().await;\n        guard.remove(topic);\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        let mut guard = self.broadcasts.lock().await;\n        guard.push((topic.to_string(), event.id.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(&self, _topic: &str) -> Result<mpsc::Receiver<Event>, AppError> {\n        let (_tx, rx) = mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        let guard = self.joined.lock().await;\n        Ok(guard.iter().cloned().collect())\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(Vec::new())\n    }\n\n    async fn get_topic_stats(\n        &self,\n        topic: &str,\n    ) -> Result<Option<crate::domain::p2p::TopicStats>, AppError> {\n        let guard = self.joined.lock().await;\n        if guard.contains(topic) {\n            Ok(Some(crate::domain::p2p::TopicStats {\n                peer_count: 0,\n                message_count: 0,\n                last_activity: 0,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    async fn broadcast_message(&self, topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        let mut guard = self.broadcasts.lock().await;\n        guard.push((topic.to_string(), \"<raw>\".into()));\n        Ok(())\n    }\n}\n\nfn create_test_event() -> Event {\n    Event {\n        id: \"test_event_123\".to_string(),\n        pubkey: \"test_pubkey\".to_string(),\n        created_at: chrono::Utc::now(),\n        kind: EventKind::TextNote.into(),\n        tags: vec![],\n        content: \"Test event content\".to_string(),\n        sig: \"test_signature\".to_string(),\n    }\n}\n\n#[tokio::test]\nasync fn test_default_distributor_creation() {\n    let distributor = DefaultEventDistributor::new();\n    let strategy = distributor.current_strategy().await;\n    assert!(matches!(strategy, DistributionStrategy::Hybrid));\n}\n\n#[tokio::test]\nasync fn test_set_strategy() {\n    let distributor = DefaultEventDistributor::new();\n    distributor.set_strategy(DistributionStrategy::P2P).await;\n\n    let strategy = distributor.current_strategy().await;\n    assert!(matches!(strategy, DistributionStrategy::P2P));\n}\n\n#[tokio::test]\nasync fn test_distribute_event() {\n    let distributor = DefaultEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Broadcast)\n        .await;\n    assert!(result.is_ok());\n\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_hybrid_distribution() {\n    let distributor = DefaultEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Hybrid)\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_get_pending_events_empty() {\n    let distributor = DefaultEventDistributor::new();\n    let events = distributor.get_pending_events().await.unwrap();\n    assert_eq!(events.len(), 0);\n}\n\n#[tokio::test]\nasync fn test_p2p_distributor() {\n    let distributor = P2PEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Broadcast)\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_nostr_distributor() {\n    let distributor = NostrEventDistributor::new();\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::P2P)\n        .await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_retry_failed_with_no_failures() {\n    let distributor = DefaultEventDistributor::new();\n    let retry_count = distributor.retry_failed().await.unwrap();\n    assert_eq!(retry_count, 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","gossip_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::p2p::TopicStats;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait GossipService: Send + Sync {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError>;\r\n    async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError>;\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n}\n","traces":[{"line":8,"address":[13321248],"length":1,"stats":{"Line":0}},{"line":9,"address":[13321256],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_gossip_service.rs"],"content":"use super::GossipService;\r\nuse crate::domain::entities::Event;\r\nuse crate::infrastructure::p2p::utils::{ParsedPeer, parse_peer_hint};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\nuse futures::StreamExt;\r\nuse iroh::{discovery::static_provider::StaticProvider, protocol::Router};\r\nuse iroh_gossip::{\r\n    ALPN as GOSSIP_ALPN,\r\n    api::{Event as GossipApiEvent, GossipSender, GossipTopic},\r\n    net::Gossip,\r\n    proto::TopicId,\r\n};\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse std::time::Duration;\r\nuse tokio::sync::{Mutex as TokioMutex, RwLock, broadcast, mpsc};\r\nuse tokio::time::timeout;\r\n\r\nuse crate::domain::p2p::events::P2PEvent;\r\nuse crate::domain::p2p::message::{GossipMessage, MessageType};\r\nuse crate::domain::p2p::{TopicMesh, TopicStats, generate_topic_id, topic_id_bytes};\n\r\nconst LOG_TARGET: &str = \"kukuri::p2p::gossip\";\r\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\r\n\r\npub struct IrohGossipService {\r\n    endpoint: Arc<iroh::Endpoint>,\r\n    static_discovery: Arc<StaticProvider>,\r\n    gossip: Arc<Gossip>,\r\n    _router: Arc<Router>,\r\n    topics: Arc<RwLock<HashMap<String, TopicHandle>>>,\r\n    event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n}\r\n\r\nstruct TopicHandle {\r\n    sender: Arc<TokioMutex<GossipSender>>, // GossipSenderでbroadcast可能\r\n    receiver_task: tokio::task::JoinHandle<()>,\r\n    mesh: Arc<TopicMesh>,\r\n}\r\n\r\nimpl IrohGossipService {\r\n    pub fn new(\r\n        endpoint: Arc<iroh::Endpoint>,\r\n        static_discovery: Arc<StaticProvider>,\r\n    ) -> Result<Self, AppError> {\r\n        // Gossipインスタンスの作成\r\n        let gossip = Gossip::builder().spawn((*endpoint).clone());\r\n\r\n        // Routerの作成とGossipプロトコルの登録\r\n        let router = Router::builder((*endpoint).clone())\r\n            .accept(GOSSIP_ALPN, gossip.clone())\r\n            .spawn();\r\n\r\n        Ok(Self {\r\n            endpoint,\r\n            static_discovery,\r\n            gossip: Arc::new(gossip),\r\n            _router: Arc::new(router),\r\n            topics: Arc::new(RwLock::new(HashMap::new())),\r\n            event_tx: None,\r\n        })\r\n    }\r\n\r\n    pub fn set_event_sender(&mut self, tx: broadcast::Sender<P2PEvent>) {\r\n        self.event_tx = Some(tx);\r\n    }\r\n\r\n    pub fn local_peer_hint(&self) -> Option<String> {\r\n        let node_addr = self.endpoint.addr();\r\n        let node_id = node_addr.id.to_string();\r\n        node_addr\r\n            .ip_addrs()\r\n            .next()\r\n            .map(|addr| format!(\"{node_id}@{addr}\"))\r\n    }\r\n\r\n    fn create_topic_id(topic: &str) -> TopicId {\r\n        let bytes = topic_id_bytes(topic);\r\n        TopicId::from_bytes(bytes)\r\n    }\r\n\r\n    async fn apply_initial_peers(\r\n        &self,\r\n        topic: &str,\r\n        parsed_peers: &[ParsedPeer],\r\n    ) -> Result<(), AppError> {\r\n        if parsed_peers.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] applying {} initial peers to existing topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        for peer in parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] re-applying node addr {} for topic {}\",\r\n                    addr.id, topic\r\n                );\r\n                self.static_discovery.add_endpoint_info(addr.clone());\r\n            }\r\n        }\r\n\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        if peer_ids.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        let topics = self.topics.read().await;\r\n        if let Some(handle) = topics.get(topic) {\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n            if let Err(e) = sender.lock().await.join_peers(peer_ids).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            }\r\n        } else {\r\n            tracing::debug!(\"Topic {} not found when applying initial peers\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl GossipService for IrohGossipService {\r\n    fn local_peer_hint(&self) -> Option<String> {\r\n        IrohGossipService::local_peer_hint(self)\r\n    }\r\n\r\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\r\n        eprintln!(\r\n            \"[iroh_gossip_service] join_topic start: {} (initial peers: {:?})\",\r\n            topic, initial_peers\r\n        );\r\n        let parsed_peers: Vec<ParsedPeer> = initial_peers\r\n            .into_iter()\r\n            .filter_map(|entry| match parse_peer_hint(&entry) {\r\n                Ok(parsed) => Some(parsed),\r\n                Err(e) => {\r\n                    tracing::warn!(\"Failed to parse initial peer '{}': {:?}\", entry, e);\r\n                    None\r\n                }\r\n            })\r\n            .collect();\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] parsed {} peers for topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        {\r\n            let topics = self.topics.read().await;\r\n            if topics.contains_key(topic) {\r\n                drop(topics);\r\n                self.apply_initial_peers(topic, &parsed_peers).await?;\r\n                return Ok(());\r\n            }\r\n            drop(topics);\r\n        }\r\n\r\n        for peer in &parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                self.static_discovery.add_endpoint_info(addr.clone());\r\n            }\r\n        }\r\n\r\n        let canonical_topic = generate_topic_id(topic);\r\n        let topic_id = Self::create_topic_id(&canonical_topic);\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        eprintln!(\r\n            \"[iroh_gossip_service] subscribing topic {} (canonical {}) with {} peer hints\",\r\n            topic,\r\n            canonical_topic,\r\n            peer_ids.len()\r\n        );\r\n\r\n        let gossip_topic: GossipTopic = self\r\n            .gossip\r\n            .subscribe(topic_id, peer_ids.clone())\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to subscribe to topic: {e:?}\")))?;\r\n\r\n        let (sender_handle, mut receiver) = gossip_topic.split();\r\n\r\n        if !peer_ids.is_empty() {\r\n            if let Err(e) = sender_handle.join_peers(peer_ids.clone()).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            } else {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] join_peers issued for topic {} ({} peers)\",\r\n                    topic,\r\n                    peer_ids.len()\r\n                );\r\n            }\r\n        }\r\n\r\n        let wait_duration = Duration::from_secs(12);\r\n        match timeout(wait_duration, receiver.joined()).await {\r\n            Ok(Ok(peer)) => {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] first neighbor joined for topic {topic} ({peer:?})\"\r\n                );\r\n            }\r\n            Ok(Err(e)) => {\r\n                tracing::debug!(\"Waiting for neighbor on {} returned error: {:?}\", topic, e);\r\n            }\r\n            Err(_) => {\r\n                tracing::warn!(\r\n                    \"Timed out ({:?}) waiting for neighbor on {}\",\r\n                    wait_duration,\r\n                    topic\r\n                );\r\n            }\r\n        }\r\n\r\n        let sender = Arc::new(TokioMutex::new(sender_handle));\r\n        let mesh = Arc::new(TopicMesh::new(topic.to_string()));\r\n\r\n        // 受信タスクを起動（UI配信用にサブスクライバへ配布 & 任意でP2PEventを送出）\r\n        let topic_clone = topic.to_string();\r\n        let event_tx_clone = self.event_tx.clone();\r\n        let mesh_for_task = mesh.clone();\r\n        let receiver_task = tokio::spawn(async move {\r\n            while let Some(event) = receiver.next().await {\r\n                match event {\r\n                    Ok(GossipApiEvent::Received(msg)) => {\r\n                        let decoded_message = match GossipMessage::from_bytes(&msg.content) {\r\n                            Ok(message) => Some(message),\r\n                            Err(e) => {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload into GossipMessage\"\r\n                                );\r\n                                None\r\n                            }\r\n                        };\r\n\r\n                        if let Some(message) = decoded_message.as_ref() {\r\n                            if let Err(e) = mesh_for_task.handle_message(message.clone()).await {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to record gossip message in TopicMesh\"\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if let (Some(tx), Some(message)) =\r\n                            (event_tx_clone.as_ref(), decoded_message.clone())\r\n                        {\r\n                            let _ = tx.send(P2PEvent::MessageReceived {\r\n                                topic_id: topic_clone.clone(),\r\n                                message,\r\n                                _from_peer: msg.delivered_from.as_bytes().to_vec(),\r\n                            });\r\n                        }\r\n\r\n                        let event_result = if let Some(message) = decoded_message\r\n                            .as_ref()\r\n                            .filter(|m| matches!(m.msg_type, MessageType::NostrEvent))\r\n                        {\r\n                            serde_json::from_slice::<Event>(&message.payload)\r\n                        } else {\r\n                            // 後方互換のため、生バイト列をそのまま JSON として扱う\r\n                            serde_json::from_slice::<Event>(&msg.content)\r\n                        };\r\n\r\n                        match event_result {\r\n                            Ok(domain_event) => {\r\n                                match domain_event\r\n                                    .validate_nip01()\r\n                                    .and_then(|_| domain_event.validate_nip10_19())\r\n                                {\r\n                                    Ok(_) => {\r\n                                        super::metrics::record_receive_success();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::trace!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive\",\r\n                                            topic = %topic_clone,\r\n                                            received = snap.messages_received,\r\n                                            receive_failures = snap.receive_details.failures,\r\n                                            \"Validated gossip payload\"\r\n                                        );\r\n                                    }\r\n                                    Err(e) => {\r\n                                        super::metrics::record_receive_failure();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::warn!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive_failure\",\r\n                                            topic = %topic_clone,\r\n                                            failures = snap.receive_details.failures,\r\n                                            error = %e,\r\n                                            \"Dropped invalid Nostr event after validation\"\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                            Err(e) => {\r\n                                super::metrics::record_receive_failure();\r\n                                let snap = super::metrics::snapshot();\r\n                                tracing::warn!(\r\n                                    target: METRICS_TARGET,\r\n                                    action = \"receive_failure\",\r\n                                    topic = %topic_clone,\r\n                                    failures = snap.receive_details.failures,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload as Nostr event\"\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborUp(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.send(P2PEvent::PeerJoined {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor up on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, true).await;\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborDown(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.send(P2PEvent::PeerLeft {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor down on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, false).await;\r\n                    }\r\n                    Ok(GossipApiEvent::Lagged) => {\r\n                        tracing::warn!(\"Receiver lagged on topic {}\", topic_clone);\r\n                    }\r\n                    Err(e) => {\r\n                        tracing::error!(\"Gossip receiver error on {}: {:?}\", topic_clone, e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let handle = TopicHandle {\r\n            sender,\r\n            receiver_task,\r\n            mesh,\r\n        };\r\n\r\n        let mut topics = self.topics.write().await;\r\n        topics.insert(topic.to_string(), handle);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        let mut topics = self.topics.write().await;\r\n\r\n        if let Some(handle) = topics.remove(topic) {\r\n            // レシーバータスクをキャンセルし、Senderをドロップ\r\n            handle.receiver_task.abort();\r\n            drop(handle.sender);\r\n\r\n            tracing::info!(\"Left gossip topic: {}\", topic);\r\n        } else {\r\n            tracing::debug!(\"Topic not found: {}\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(handle) = topics.get(topic) {\r\n            // イベントをシリアライズ\r\n            let payload = serde_json::to_vec(event)?;\r\n            let sender_id = self.endpoint.addr().id.to_string().into_bytes();\r\n            let gossip_message = GossipMessage::new(MessageType::NostrEvent, payload, sender_id);\r\n            let message_bytes = gossip_message.to_bytes().map_err(|e| {\r\n                AppError::P2PError(format!(\"Failed to serialize gossip message: {e}\"))\r\n            })?;\r\n\r\n            // Senderを取得してブロードキャスト\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n\r\n            let guard = sender.lock().await;\r\n            guard\r\n                .broadcast(message_bytes.into())\r\n                .await\r\n                .map_err(|e| AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))?;\r\n\r\n            tracing::debug!(\"Broadcasted event to topic {}\", topic);\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn subscribe(&self, topic: &str) -> Result<mpsc::Receiver<Event>, AppError> {\r\n        // トピックに参加していることを確認\r\n        self.join_topic(topic, vec![]).await?;\r\n\r\n        let mesh = {\r\n            let topics = self.topics.read().await;\r\n            topics.get(topic).map(|handle| handle.mesh.clone())\r\n        };\r\n\r\n        if let Some(mesh) = mesh {\r\n            let topic_name = topic.to_string();\r\n            let subscription = mesh.subscribe().await;\r\n            let subscription_id = subscription.id;\r\n            let mut message_rx = subscription.receiver;\r\n            let mesh_clone = mesh.clone();\r\n            let (tx, rx) = mpsc::channel(100);\r\n\r\n            tokio::spawn(async move {\r\n                while let Some(message) = message_rx.recv().await {\r\n                    if !matches!(message.msg_type, MessageType::NostrEvent) {\r\n                        continue;\r\n                    }\r\n\r\n                    match serde_json::from_slice::<Event>(&message.payload) {\r\n                        Ok(domain_event) => {\r\n                            match domain_event\r\n                                .validate_nip01()\r\n                                .and_then(|_| domain_event.validate_nip10_19())\r\n                            {\r\n                                Ok(_) => {\r\n                                    if tx.send(domain_event.clone()).await.is_err() {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                Err(e) => {\r\n                                    tracing::debug!(\r\n                                        target: LOG_TARGET,\r\n                                        topic = %topic_name,\r\n                                        error = %e,\r\n                                        \"Dropped invalid domain event in subscription bridge\"\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                        Err(e) => {\r\n                            tracing::debug!(\r\n                                target: LOG_TARGET,\r\n                                topic = %topic_name,\r\n                                error = ?e,\r\n                                \"Failed to decode gossip payload into Event for subscription\"\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                mesh_clone.unsubscribe(subscription_id).await;\r\n            });\r\n\r\n            Ok(rx)\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n        Ok(topics.keys().cloned().collect())\r\n    }\r\n\r\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // iroh-gossipのAPIでピアリストを取得\r\n            // Note: iroh-gossip doesn't expose a direct way to get topic peers\r\n            // Return empty list for now\r\n            Ok(Vec::new())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError> {\r\n        let mesh = {\r\n            let topics = self.topics.read().await;\r\n            topics.get(topic).map(|handle| handle.mesh.clone())\r\n        };\r\n\r\n        if let Some(mesh) = mesh {\r\n            Ok(Some(mesh.get_stats().await))\r\n        } else {\r\n            Ok(None)\r\n        }\r\n    }\r\n\r\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // メッセージをブロードキャスト\r\n            // Simplified - actual implementation needs proper API\r\n            tracing::debug!(\r\n                \"Broadcasting raw message to topic {}: {} bytes\",\r\n                topic,\r\n                message.len()\r\n            );\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::domain::entities::Event;\r\n    use iroh::Endpoint;\r\n\r\n    fn should_run_p2p_tests(test_name: &str) -> bool {\r\n        if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\r\n            eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\r\n            false\r\n        } else {\r\n            true\r\n        }\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_broadcast_without_peers() {\r\n        if !should_run_p2p_tests(\"test_join_and_broadcast_without_peers\") {\r\n            return;\r\n        }\r\n        // エンドポイント作成（ローカル、ディスカバリ無し）\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Arc::new(\r\n            Endpoint::builder()\r\n                .discovery(static_discovery.clone())\r\n                .bind()\r\n                .await\r\n                .unwrap(),\r\n        );\r\n        let service = IrohGossipService::new(endpoint, static_discovery).unwrap();\r\n\r\n        // トピック参加\r\n        let topic = \"test-topic-ig\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n\r\n        // ダミーイベントでブロードキャスト（ピア不在でもエラーにならない）\r\n        let event = Event::new(1, \"hello igossip\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(topic, &event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_leave_topic() {\r\n        if !should_run_p2p_tests(\"test_join_and_leave_topic\") {\r\n            return;\r\n        }\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Arc::new(\r\n            Endpoint::builder()\r\n                .discovery(static_discovery.clone())\r\n                .bind()\r\n                .await\r\n                .unwrap(),\r\n        );\r\n        let service = IrohGossipService::new(endpoint, static_discovery).unwrap();\r\n\r\n        let topic = \"test-topic-leave\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n        let result = service.leave_topic(topic).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[20788244,20788396,20787152],"length":1,"stats":{"Line":0}},{"line":48,"address":[20825412,20826461,20825291],"length":1,"stats":{"Line":0}},{"line":51,"address":[20787450,20787630,20787525,20787685],"length":1,"stats":{"Line":0}},{"line":52,"address":[20712980,20713085,20713716],"length":1,"stats":{"Line":0}},{"line":55,"address":[20795037],"length":1,"stats":{"Line":0}},{"line":56,"address":[20719912],"length":1,"stats":{"Line":0}},{"line":57,"address":[20713149],"length":1,"stats":{"Line":0}},{"line":58,"address":[20719954,20720032],"length":1,"stats":{"Line":0}},{"line":59,"address":[20831544,20831657],"length":1,"stats":{"Line":0}},{"line":60,"address":[20788029,20787969],"length":1,"stats":{"Line":0}},{"line":61,"address":[20720289],"length":1,"stats":{"Line":0}},{"line":65,"address":[20832181,20832128],"length":1,"stats":{"Line":0}},{"line":66,"address":[19312000,19311939],"length":1,"stats":{"Line":0}},{"line":69,"address":[20927024,20927299],"length":1,"stats":{"Line":0}},{"line":70,"address":[20713990],"length":1,"stats":{"Line":0}},{"line":71,"address":[20927098],"length":1,"stats":{"Line":0}},{"line":72,"address":[19312202,19312143],"length":1,"stats":{"Line":0}},{"line":75,"address":[20832570,20832544],"length":1,"stats":{"Line":0}},{"line":78,"address":[20721232],"length":1,"stats":{"Line":0}},{"line":79,"address":[20714472],"length":1,"stats":{"Line":0}},{"line":80,"address":[20796008],"length":1,"stats":{"Line":0}},{"line":83,"address":[20927632],"length":1,"stats":{"Line":0}},{"line":88,"address":[20789448,20789608],"length":1,"stats":{"Line":0}},{"line":89,"address":[19313125],"length":1,"stats":{"Line":0}},{"line":92,"address":[20831670],"length":1,"stats":{"Line":0}},{"line":98,"address":[20796900,20796726],"length":1,"stats":{"Line":0}},{"line":99,"address":[20729696,20729164],"length":1,"stats":{"Line":0}},{"line":100,"address":[14970260],"length":1,"stats":{"Line":0}},{"line":104,"address":[14970399],"length":1,"stats":{"Line":0}},{"line":108,"address":[20721248,20721261,20715474,20715353],"length":1,"stats":{"Line":0}},{"line":109,"address":[20797072,20797154],"length":1,"stats":{"Line":0}},{"line":110,"address":[20790263],"length":1,"stats":{"Line":0}},{"line":113,"address":[11696879],"length":1,"stats":{"Line":0}},{"line":114,"address":[20833119,20833203],"length":1,"stats":{"Line":0}},{"line":115,"address":[20716744,20716658],"length":1,"stats":{"Line":0}},{"line":116,"address":[14971051],"length":1,"stats":{"Line":0}},{"line":117,"address":[11594018],"length":1,"stats":{"Line":0}},{"line":118,"address":[20764911,20726157,20764777,20726759,20726258],"length":1,"stats":{"Line":0}},{"line":121,"address":[19314954,19471641,19471798,19315489,19314685],"length":1,"stats":{"Line":0}},{"line":124,"address":[20731222],"length":1,"stats":{"Line":0}},{"line":130,"address":[20765712],"length":1,"stats":{"Line":0}},{"line":131,"address":[19472129],"length":1,"stats":{"Line":0}},{"line":134,"address":[11897783],"length":1,"stats":{"Line":0}},{"line":135,"address":[20841415,20841336],"length":1,"stats":{"Line":0}},{"line":139,"address":[20973083],"length":1,"stats":{"Line":0}},{"line":141,"address":[20773250,20775144,20773333,20773931,20773200],"length":1,"stats":{"Line":0}},{"line":142,"address":[20787138],"length":1,"stats":{"Line":0}},{"line":143,"address":[20890072],"length":1,"stats":{"Line":0}},{"line":144,"address":[20886637,20939919,20886184,20939785,20886788,20886293],"length":1,"stats":{"Line":0}},{"line":145,"address":[15028359],"length":1,"stats":{"Line":0}},{"line":150,"address":[20878431,20878518],"length":1,"stats":{"Line":0}},{"line":157,"address":[20841002,20841901,20841986,20842131],"length":1,"stats":{"Line":0}},{"line":158,"address":[20974056,20973969],"length":1,"stats":{"Line":0}},{"line":159,"address":[20835665],"length":1,"stats":{"Line":0}},{"line":160,"address":[20879515,20878993,20876143,20879614,20879226],"length":1,"stats":{"Line":0}},{"line":161,"address":[19475873],"length":1,"stats":{"Line":0}},{"line":163,"address":[20974103],"length":1,"stats":{"Line":0}},{"line":166,"address":[20877773,20877947],"length":1,"stats":{"Line":0}},{"line":167,"address":[20775091,20776003],"length":1,"stats":{"Line":0}},{"line":168,"address":[20769047],"length":1,"stats":{"Line":0}},{"line":172,"address":[20873980],"length":1,"stats":{"Line":0}},{"line":173,"address":[20879634,20879741],"length":1,"stats":{"Line":0}},{"line":174,"address":[20891821,20878100,20891808],"length":1,"stats":{"Line":0}},{"line":175,"address":[20878380],"length":1,"stats":{"Line":0}},{"line":182,"address":[20836595,20836757,20836510,20837865,20836663,20838300,20837717],"length":1,"stats":{"Line":0}},{"line":184,"address":[20874726],"length":1,"stats":{"Line":0}},{"line":185,"address":[11900881],"length":1,"stats":{"Line":0}},{"line":186,"address":[20988288,20988310,20976732],"length":1,"stats":{"Line":0}},{"line":188,"address":[20838385,20838127],"length":1,"stats":{"Line":0}},{"line":190,"address":[20977074,20976986],"length":1,"stats":{"Line":0}},{"line":191,"address":[20839055,20838718,20834137,20838600],"length":1,"stats":{"Line":0}},{"line":192,"address":[20841337,20778674,20841471,20779175,20778573],"length":1,"stats":{"Line":0}},{"line":194,"address":[20979717,20979636],"length":1,"stats":{"Line":0}},{"line":202,"address":[20848305,20845586],"length":1,"stats":{"Line":0}},{"line":203,"address":[11997363],"length":1,"stats":{"Line":0}},{"line":205,"address":[19480434,19480281],"length":1,"stats":{"Line":0}},{"line":209,"address":[20980439],"length":1,"stats":{"Line":0}},{"line":210,"address":[20848935,20909593,20849694,20909727,20849193],"length":1,"stats":{"Line":0}},{"line":213,"address":[20774089,20835353,20776114,20835487],"length":1,"stats":{"Line":0}},{"line":221,"address":[20852464,20852578],"length":1,"stats":{"Line":0}},{"line":222,"address":[20984182,20984280],"length":1,"stats":{"Line":0}},{"line":225,"address":[15025610,15025708],"length":1,"stats":{"Line":0}},{"line":226,"address":[15025823,15025723],"length":1,"stats":{"Line":0}},{"line":227,"address":[20888182,20888266],"length":1,"stats":{"Line":0}},{"line":228,"address":[20892308,20892448,20915154,20888274,20892112,20894320,20892188],"length":1,"stats":{"Line":0}},{"line":229,"address":[20989368,20989429,20988685,20988846,20988770,20988912],"length":1,"stats":{"Line":0}},{"line":230,"address":[20783432,20783493],"length":1,"stats":{"Line":0}},{"line":231,"address":[20895292],"length":1,"stats":{"Line":0}},{"line":232,"address":[20856701,20851682],"length":1,"stats":{"Line":0}},{"line":233,"address":[20900451],"length":1,"stats":{"Line":0}},{"line":234,"address":[19495065],"length":1,"stats":{"Line":0}},{"line":235,"address":[20947487,20901186,20947353,20900544,20900660],"length":1,"stats":{"Line":0}},{"line":241,"address":[20899484],"length":1,"stats":{"Line":0}},{"line":245,"address":[20782284,20784334],"length":1,"stats":{"Line":0}},{"line":246,"address":[20892359,20901116,20892517,20901035],"length":1,"stats":{"Line":0}},{"line":247,"address":[20866977,20911081,20911215,20866375,20866476],"length":1,"stats":{"Line":0}},{"line":256,"address":[21000044,21000009,21000072],"length":1,"stats":{"Line":0}},{"line":257,"address":[20903474,20901066,20903583],"length":1,"stats":{"Line":0}},{"line":259,"address":[20904122],"length":1,"stats":{"Line":0}},{"line":260,"address":[20868680],"length":1,"stats":{"Line":0}},{"line":261,"address":[20794012],"length":1,"stats":{"Line":0}},{"line":262,"address":[20900154,20900068],"length":1,"stats":{"Line":0}},{"line":266,"address":[19500551,19500639],"length":1,"stats":{"Line":0}},{"line":268,"address":[20873333,20873328],"length":1,"stats":{"Line":0}},{"line":270,"address":[20794688,20794769],"length":1,"stats":{"Line":0}},{"line":273,"address":[20904571,20904699],"length":1,"stats":{"Line":0}},{"line":276,"address":[19500813],"length":1,"stats":{"Line":0}},{"line":277,"address":[20862708],"length":1,"stats":{"Line":0}},{"line":278,"address":[20862811,20862718],"length":1,"stats":{"Line":0}},{"line":280,"address":[19511568,19511584],"length":1,"stats":{"Line":0}},{"line":283,"address":[20862881],"length":1,"stats":{"Line":0}},{"line":284,"address":[20869866],"length":1,"stats":{"Line":0}},{"line":285,"address":[19501140,19501211,19542486,19542329,19501733],"length":1,"stats":{"Line":0}},{"line":294,"address":[19501083],"length":1,"stats":{"Line":0}},{"line":295,"address":[20795116],"length":1,"stats":{"Line":0}},{"line":296,"address":[20804294],"length":1,"stats":{"Line":0}},{"line":297,"address":[20837471,20797413,20837337,20797337,20797914],"length":1,"stats":{"Line":0}},{"line":308,"address":[20900849],"length":1,"stats":{"Line":0}},{"line":309,"address":[21001233],"length":1,"stats":{"Line":0}},{"line":310,"address":[21005924],"length":1,"stats":{"Line":0}},{"line":311,"address":[20912569,20912703,20874391,20874467,20874968],"length":1,"stats":{"Line":0}},{"line":322,"address":[19489721],"length":1,"stats":{"Line":0}},{"line":323,"address":[20790654,20790972],"length":1,"stats":{"Line":0}},{"line":324,"address":[20858778],"length":1,"stats":{"Line":0}},{"line":325,"address":[20852110],"length":1,"stats":{"Line":0}},{"line":326,"address":[20895610],"length":1,"stats":{"Line":0}},{"line":327,"address":[20990500],"length":1,"stats":{"Line":0}},{"line":330,"address":[20944249,20944383,20890053,20890400],"length":1,"stats":{"Line":0}},{"line":332,"address":[20852238,20850506,20850332,20853936],"length":1,"stats":{"Line":0}},{"line":334,"address":[20893571],"length":1,"stats":{"Line":0}},{"line":335,"address":[15034121,15031271],"length":1,"stats":{"Line":0}},{"line":336,"address":[20786647],"length":1,"stats":{"Line":0}},{"line":337,"address":[20854670],"length":1,"stats":{"Line":0}},{"line":338,"address":[19492775],"length":1,"stats":{"Line":0}},{"line":339,"address":[20854577],"length":1,"stats":{"Line":0}},{"line":342,"address":[20892658,20944879,20892951,20944745],"length":1,"stats":{"Line":0}},{"line":344,"address":[11958919],"length":1,"stats":{"Line":0}},{"line":347,"address":[20851723,20907263,20869750,20907129],"length":1,"stats":{"Line":0}},{"line":349,"address":[15031078],"length":1,"stats":{"Line":0}},{"line":350,"address":[20945871,20909453,20909954,20889531,20945737],"length":1,"stats":{"Line":0}},{"line":362,"address":[15026248,15026333,15013891],"length":1,"stats":{"Line":0}},{"line":363,"address":[20786143,20786211],"length":1,"stats":{"Line":0}},{"line":365,"address":[20985670],"length":1,"stats":{"Line":0}},{"line":368,"address":[20805927,20805680,20805956,20810082,20805631,20805727,20806206,20808500,20805832],"length":1,"stats":{"Line":0}},{"line":369,"address":[20880974,20880598,20880804],"length":1,"stats":{"Line":0}},{"line":371,"address":[15054075,15053996],"length":1,"stats":{"Line":0}},{"line":373,"address":[20806659],"length":1,"stats":{"Line":0}},{"line":374,"address":[21013029],"length":1,"stats":{"Line":0}},{"line":376,"address":[15087967,15054288,15087833,15054824],"length":1,"stats":{"Line":0}},{"line":378,"address":[20840943,20808569,20840809],"length":1,"stats":{"Line":0}},{"line":381,"address":[20808470],"length":1,"stats":{"Line":0}},{"line":384,"address":[20924406,20921759,20921712,20921922,20922088,20922401,20921639,20927217],"length":1,"stats":{"Line":0}},{"line":385,"address":[21016990,21017072,21016736,21017217],"length":1,"stats":{"Line":0}},{"line":387,"address":[15063187,15058734,15058817],"length":1,"stats":{"Line":0}},{"line":389,"address":[15058921,15059031,15059203,15060431],"length":1,"stats":{"Line":0}},{"line":390,"address":[20886535,20886388],"length":1,"stats":{"Line":0}},{"line":391,"address":[20818970],"length":1,"stats":{"Line":0}},{"line":392,"address":[20805359,20805721,20809168,20806075,20805453,20809394],"length":1,"stats":{"Line":0}},{"line":393,"address":[20815974,20816034],"length":1,"stats":{"Line":0}},{"line":397,"address":[20923917,20924110],"length":1,"stats":{"Line":0}},{"line":398,"address":[20887345],"length":1,"stats":{"Line":0}},{"line":400,"address":[19555387],"length":1,"stats":{"Line":0}},{"line":401,"address":[20821030,20820346,20820526,20820759,20820580,20820875],"length":1,"stats":{"Line":0}},{"line":402,"address":[15060975],"length":1,"stats":{"Line":0}},{"line":403,"address":[19519410,19519470,19519664,19516458],"length":1,"stats":{"Line":0}},{"line":404,"address":[15063728,15061526,15063750],"length":1,"stats":{"Line":0}},{"line":406,"address":[19547238,19520456,19519803,19519919,19547081],"length":1,"stats":{"Line":0}},{"line":407,"address":[20926074],"length":1,"stats":{"Line":0}},{"line":409,"address":[21017723,21019242],"length":1,"stats":{"Line":0}},{"line":413,"address":[20922825,20922511,20925694,20922464,20923161,20922659,20922415,20923742],"length":1,"stats":{"Line":0}},{"line":415,"address":[11855569],"length":1,"stats":{"Line":0}},{"line":418,"address":[20926646,20927687,20927399,20927566],"length":1,"stats":{"Line":0}},{"line":419,"address":[20818087,20819968,20819977,20818160],"length":1,"stats":{"Line":0}},{"line":422,"address":[20825249],"length":1,"stats":{"Line":0}},{"line":423,"address":[20929838,20929958],"length":1,"stats":{"Line":0}},{"line":424,"address":[11787801],"length":1,"stats":{"Line":0}},{"line":425,"address":[20925085],"length":1,"stats":{"Line":0}},{"line":426,"address":[20826149],"length":1,"stats":{"Line":0}},{"line":427,"address":[20929045,20929127],"length":1,"stats":{"Line":0}},{"line":428,"address":[19525053,19524971],"length":1,"stats":{"Line":0}},{"line":430,"address":[20826976,20826585,20827007,20827074,20827181,20826373,20831043,20833505],"length":1,"stats":{"Line":0}},{"line":431,"address":[15067642,15067616,15067757,15068426,15067691],"length":1,"stats":{"Line":0}},{"line":432,"address":[20828483],"length":1,"stats":{"Line":0}},{"line":436,"address":[15069076,15069163],"length":1,"stats":{"Line":0}},{"line":437,"address":[20821711],"length":1,"stats":{"Line":0}},{"line":438,"address":[20889664,20889558],"length":1,"stats":{"Line":0}},{"line":440,"address":[21032992,21032976,21028126],"length":1,"stats":{"Line":0}},{"line":443,"address":[20887948,20888082,20889732,20888442,20889854],"length":1,"stats":{"Line":0}},{"line":447,"address":[19527521],"length":1,"stats":{"Line":0}},{"line":448,"address":[19547766,19527559,19527729,19528251,19547609],"length":1,"stats":{"Line":0}},{"line":457,"address":[20821784],"length":1,"stats":{"Line":0}},{"line":458,"address":[20817343,20835513,20817844,20835647,20815023],"length":1,"stats":{"Line":0}},{"line":468,"address":[20935783,20930014,20935868],"length":1,"stats":{"Line":0}},{"line":471,"address":[20819636],"length":1,"stats":{"Line":0}},{"line":473,"address":[20886520,20886172],"length":1,"stats":{"Line":0}},{"line":477,"address":[20826745,20827728,20826898,20826819,20827010,20826987,20826784,20827233],"length":1,"stats":{"Line":0}},{"line":478,"address":[11812004],"length":1,"stats":{"Line":0}},{"line":479,"address":[20933490,20933417],"length":1,"stats":{"Line":0}},{"line":482,"address":[21034226,21034147,21034315,21034338,21034063,21035301,21034112,21034561],"length":1,"stats":{"Line":0}},{"line":483,"address":[20821181,20821366,20821521],"length":1,"stats":{"Line":0}},{"line":485,"address":[20835586,20835958,20835513],"length":1,"stats":{"Line":0}},{"line":489,"address":[19534125,19534172],"length":1,"stats":{"Line":0}},{"line":491,"address":[20903558,20903452],"length":1,"stats":{"Line":0}},{"line":495,"address":[20936346,20935550,20935075,20935040,20935163,20934991,20935293,20935270,20936677],"length":1,"stats":{"Line":0}},{"line":497,"address":[19568847],"length":1,"stats":{"Line":0}},{"line":498,"address":[20905520,20905529,20904630,20904703],"length":1,"stats":{"Line":0}},{"line":501,"address":[21036523,21036359],"length":1,"stats":{"Line":0}},{"line":502,"address":[20940291,20939979,20940146,20939144],"length":1,"stats":{"Line":0}},{"line":504,"address":[20837127],"length":1,"stats":{"Line":0}},{"line":508,"address":[20898736,20898783,20898883,20898671,20901594,20899007,20899263,20898978],"length":1,"stats":{"Line":0}},{"line":509,"address":[11798135],"length":1,"stats":{"Line":0}},{"line":511,"address":[20906488,20906567,20907212,20908491],"length":1,"stats":{"Line":0}},{"line":514,"address":[20943160,20942850],"length":1,"stats":{"Line":0}},{"line":519,"address":[21038756],"length":1,"stats":{"Line":0}},{"line":521,"address":[20899763,20901403],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":215},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_network_service.rs"],"content":"use super::{\r\n    DiscoveryOptions, NetworkService, NetworkStats, Peer,\r\n    dht_bootstrap::{DhtGossip, secret},\r\n};\r\nuse crate::domain::p2p::{P2PEvent, generate_topic_id, topic_id_bytes};\r\nuse crate::shared::config::{BootstrapSource, NetworkConfig as AppNetworkConfig};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\nuse iroh::{Endpoint, EndpointAddr, discovery::static_provider::StaticProvider, protocol::Router};\r\nuse std::sync::Arc;\r\nuse tokio::sync::{RwLock, broadcast};\r\nuse tracing;\r\n\r\npub struct IrohNetworkService {\r\n    endpoint: Arc<Endpoint>,\r\n    router: Arc<Router>,\r\n    static_discovery: Arc<StaticProvider>,\r\n    connected: Arc<RwLock<bool>>,\r\n    peers: Arc<RwLock<Vec<Peer>>>,\r\n    stats: Arc<RwLock<NetworkStats>>,\r\n    dht_gossip: Option<Arc<DhtGossip>>,\r\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\r\n    network_config: Arc<RwLock<AppNetworkConfig>>,\r\n    bootstrap_peers: Arc<RwLock<Vec<String>>>,\r\n    bootstrap_source: Arc<RwLock<BootstrapSource>>,\r\n    p2p_event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n}\r\n\r\nimpl IrohNetworkService {\r\n    pub async fn new(\r\n        secret_key: iroh::SecretKey,\r\n        net_cfg: AppNetworkConfig,\r\n        discovery_options: DiscoveryOptions,\r\n        event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n    ) -> Result<Self, AppError> {\r\n        // Endpointの作成（設定に応じてディスカバリーを有効化）\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let builder = Endpoint::builder().secret_key(secret_key);\r\n        let builder = discovery_options.apply_to_builder(builder);\r\n        let builder = builder.discovery(static_discovery.clone());\r\n        let endpoint = builder\r\n            .bind()\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to bind endpoint: {e:?}\")))?;\r\n\r\n        // Routerの作成（Gossipプロトコルは別で設定）\r\n        let router = Router::builder(endpoint.clone()).spawn();\r\n\r\n        // ブートストラップ設定の検証（警告/件数ログのみ）\r\n        if let Err(e) = super::bootstrap_config::validate_bootstrap_config() {\r\n            tracing::warn!(\"bootstrap_nodes.json validation failed: {:?}\", e);\r\n        }\r\n\r\n        // DhtGossipの初期化\r\n        let dht_gossip = match DhtGossip::new(Arc::new(endpoint.clone())).await {\r\n            Ok(service) => Some(Arc::new(service)),\r\n            Err(e) => {\r\n                tracing::warn!(\"Failed to initialize DhtGossip: {:?}\", e);\r\n                None\r\n            }\r\n        };\r\n\r\n        let network_config = Arc::new(RwLock::new(net_cfg.clone()));\r\n        let endpoint = Arc::new(endpoint);\r\n        let service = Self {\r\n            endpoint: Arc::clone(&endpoint),\r\n            router: Arc::new(router),\r\n            static_discovery,\r\n            connected: Arc::new(RwLock::new(false)),\r\n            peers: Arc::new(RwLock::new(Vec::new())),\r\n            stats: Arc::new(RwLock::new(NetworkStats {\r\n                connected_peers: 0,\r\n                total_messages_sent: 0,\r\n                total_messages_received: 0,\r\n                bandwidth_up: 0,\r\n                bandwidth_down: 0,\r\n            })),\r\n            dht_gossip,\r\n            discovery_options: Arc::new(RwLock::new(discovery_options)),\r\n            network_config: Arc::clone(&network_config),\r\n            bootstrap_peers: Arc::new(RwLock::new(net_cfg.bootstrap_peers.clone())),\r\n            bootstrap_source: Arc::new(RwLock::new(net_cfg.bootstrap_source)),\r\n            p2p_event_tx: event_tx,\r\n        };\r\n\r\n        service.apply_bootstrap_peers_from_config().await;\r\n\r\n        Ok(service)\r\n    }\r\n\r\n    pub fn endpoint(&self) -> &Arc<Endpoint> {\r\n        &self.endpoint\r\n    }\r\n\r\n    pub fn static_discovery(&self) -> Arc<StaticProvider> {\r\n        Arc::clone(&self.static_discovery)\r\n    }\r\n\r\n    pub fn router(&self) -> &Arc<Router> {\r\n        &self.router\r\n    }\r\n\r\n    fn emit_event(&self, event: P2PEvent) {\r\n        if let Some(tx) = &self.p2p_event_tx {\r\n            let _ = tx.send(event);\r\n        }\r\n    }\r\n\r\n    async fn apply_bootstrap_peers_from_config(&self) {\r\n        let peers = { self.bootstrap_peers.read().await.clone() };\r\n        if peers.is_empty() {\r\n            return;\r\n        }\r\n        let source = *self.bootstrap_source.read().await;\r\n        let success_count = self.connect_bootstrap_nodes(&peers).await;\r\n        if success_count > 0 {\r\n            super::metrics::record_bootstrap_source(source);\r\n        }\r\n    }\r\n\r\n    async fn connect_bootstrap_nodes(&self, nodes: &[String]) -> usize {\r\n        let mut success_count = 0usize;\r\n        for peer in nodes {\r\n            let trimmed = peer.trim();\r\n            if trimmed.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            match self.add_peer(trimmed).await {\r\n                Ok(_) => {\r\n                    success_count += 1;\r\n                    tracing::info!(\"Connected to bootstrap peer from config: {}\", trimmed);\r\n                }\r\n                Err(err) => {\r\n                    tracing::warn!(\"Failed to connect to bootstrap peer '{}': {}\", trimmed, err);\r\n                }\r\n            }\r\n        }\r\n        success_count\r\n    }\r\n\r\n    pub fn node_id(&self) -> String {\r\n        self.endpoint.id().to_string()\r\n    }\r\n\r\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\r\n        *self.discovery_options.read().await\r\n    }\r\n\r\n    pub async fn node_addr(&self) -> Result<Vec<String>, AppError> {\r\n        // 直接アドレスを解決し、`node_id@ip:port` 形式で返却\r\n        self.endpoint.online().await;\r\n        let node_addr = self.endpoint.addr();\r\n        let node_id = node_addr.id.to_string();\r\n        let mut out = Vec::new();\r\n        for addr in node_addr.ip_addrs() {\r\n            out.push(format!(\"{node_id}@{addr}\"));\r\n        }\r\n        if out.is_empty() {\r\n            out.push(node_id);\r\n        }\r\n        Ok(out)\r\n    }\r\n\r\n    /// DHT????????????\r\n    pub async fn join_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.join_topic(&topic_bytes, vec![]).await?;\r\n            tracing::info!(\r\n                \"Joined DHT topic: {} (requested: {})\",\r\n                canonical,\r\n                topic_name\r\n            );\r\n        } else {\r\n            tracing::warn!(\"DHT service not available, using fallback\");\r\n            // ?????????????\r\n            self.connect_fallback().await?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// DHT?????????????\r\n    pub async fn leave_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.leave_topic(&topic_bytes).await?;\r\n            tracing::info!(\"Left DHT topic: {} (requested: {})\", canonical, topic_name);\r\n        }\r\n        Ok(())\r\n    }\r\n    /// DHT???????????????????\r\n    pub async fn broadcast_dht(&self, topic_name: &str, message: Vec<u8>) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.broadcast(&topic_bytes, message).await?;\r\n        } else {\r\n            return Err(AppError::P2PError(\"DHT service not available\".to_string()));\r\n        }\r\n        Ok(())\r\n    }\r\n    /// フォールバックモードでピアに接続\r\n    async fn connect_fallback(&self) -> Result<(), AppError> {\r\n        // 1) 設定ファイルからのブートストラップ接続を優先\r\n        let fallback_peers =\r\n            match super::dht_bootstrap::fallback::connect_from_config(&self.endpoint).await {\r\n                Ok(peers) => peers,\r\n                Err(_) => {\r\n                    // 2) ハードコードされたフォールバックに接続（なければ失敗）\r\n                    match super::dht_bootstrap::fallback::connect_to_fallback(&self.endpoint).await\r\n                    {\r\n                        Ok(peers) => peers,\r\n                        Err(err) => {\r\n                            super::metrics::record_mainline_reconnect_failure();\r\n                            return Err(err);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n        super::metrics::record_mainline_reconnect_success();\r\n\r\n        // フォールバックピアをピアリストに追加\r\n        let mut peers = self.peers.write().await;\r\n        let now = chrono::Utc::now().timestamp();\r\n\r\n        for node_addr in fallback_peers {\r\n            peers.push(Peer {\r\n                id: node_addr.id.to_string(),\r\n                address: format!(\"{}@fallback\", node_addr.id),\r\n                connected_at: now,\r\n                last_seen: now,\r\n            });\r\n            self.static_discovery.add_endpoint_info(node_addr);\r\n        }\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 共有シークレットをローテーション\r\n    pub async fn rotate_dht_secret(&self) -> Result<(), AppError> {\r\n        secret::rotate_secret()\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to rotate secret: {e:?}\")))?;\r\n        tracing::info!(\"DHT shared secret rotated\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl NetworkService for IrohNetworkService {\r\n    fn as_any(&self) -> &dyn std::any::Any {\r\n        self\r\n    }\r\n\r\n    async fn connect(&self) -> Result<(), AppError> {\r\n        let mut connected = self.connected.write().await;\r\n        let was_connected = *connected;\r\n        *connected = true;\r\n        drop(connected);\r\n        if !was_connected {\r\n            let node_id = self.endpoint.id().to_string();\r\n            let addresses = match self.node_addr().await {\r\n                Ok(addresses) => addresses,\r\n                Err(err) => {\r\n                    tracing::warn!(\"Failed to resolve node addresses on connect: {}\", err);\r\n                    Vec::new()\r\n                }\r\n            };\r\n            self.emit_event(P2PEvent::NetworkConnected { node_id, addresses });\r\n        }\r\n        tracing::info!(\"Network service connected\");\r\n        Ok(())\r\n    }\r\n\r\n    async fn disconnect(&self) -> Result<(), AppError> {\r\n        let mut connected = self.connected.write().await;\r\n        let was_connected = *connected;\r\n        *connected = false;\r\n        drop(connected);\r\n\r\n        // ピアリストをクリア\r\n        let mut peers = self.peers.write().await;\r\n        peers.clear();\r\n        super::metrics::set_mainline_connected_peers(0);\r\n\r\n        tracing::info!(\"Network service disconnected\");\r\n        if was_connected {\r\n            let node_id = self.endpoint.id().to_string();\r\n            self.emit_event(P2PEvent::NetworkDisconnected { node_id });\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError> {\r\n        let peers = self.peers.read().await;\r\n        Ok(peers.clone())\r\n    }\r\n\r\n    async fn add_peer(&self, address: &str) -> Result<(), AppError> {\r\n        // アドレスからNodeIdを抽出（例: \"node_id@socket_addr\"）\r\n        use iroh::EndpointId;\r\n        use std::net::SocketAddr;\r\n        use std::str::FromStr;\r\n\r\n        let parts: Vec<&str> = address.split('@').collect();\r\n        if parts.len() != 2 {\r\n            super::metrics::record_mainline_connection_failure();\r\n            return Err(\"Invalid address format: expected 'node_id@socket_addr'\".into());\r\n        }\r\n\r\n        let node_id = EndpointId::from_str(parts[0]).map_err(|e| {\r\n            super::metrics::record_mainline_connection_failure();\r\n            AppError::from(format!(\"Failed to parse node ID: {e}\"))\r\n        })?;\r\n        let socket_addr: SocketAddr = parts[1].parse().map_err(|e| {\r\n            super::metrics::record_mainline_connection_failure();\r\n            AppError::from(format!(\"Failed to parse socket address: {e}\"))\r\n        })?;\r\n\r\n        // NodeAddrを構築\r\n        let node_addr = EndpointAddr::new(node_id).with_ip_addr(socket_addr);\r\n        self.static_discovery.add_endpoint_info(node_addr.clone());\r\n\r\n        // ピアに接続\r\n        self.endpoint\r\n            .connect(node_addr.clone(), iroh_gossip::ALPN)\r\n            .await\r\n            .map_err(|e| {\r\n                super::metrics::record_mainline_connection_failure();\r\n                AppError::from(format!(\"Failed to connect to peer: {e}\"))\r\n            })?;\r\n\r\n        // ピアリストに追加\r\n        let mut peers = self.peers.write().await;\r\n        let now = chrono::Utc::now().timestamp();\r\n        peers.push(Peer {\r\n            id: node_addr.id.to_string(),\r\n            address: address.to_string(),\r\n            connected_at: now,\r\n            last_seen: now,\r\n        });\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::record_mainline_connection_success();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        tracing::info!(\"Added peer: {}\", address);\r\n        Ok(())\r\n    }\r\n\r\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError> {\r\n        let mut peers = self.peers.write().await;\r\n        peers.retain(|p| p.id != peer_id);\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        tracing::info!(\"Removed peer: {}\", peer_id);\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_stats(&self) -> Result<NetworkStats, AppError> {\r\n        let stats = self.stats.read().await;\r\n        Ok(stats.clone())\r\n    }\r\n\r\n    async fn is_connected(&self) -> bool {\r\n        let connected = self.connected.read().await;\r\n        *connected\r\n    }\r\n\r\n    async fn get_node_id(&self) -> Result<String, AppError> {\r\n        Ok(self.endpoint.id().to_string())\r\n    }\r\n\r\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\r\n        self.node_addr().await\r\n    }\r\n\r\n    async fn join_dht_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        IrohNetworkService::join_dht_topic(self, topic).await\r\n    }\r\n\r\n    async fn leave_dht_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        IrohNetworkService::leave_dht_topic(self, topic).await\r\n    }\r\n\r\n    async fn broadcast_dht(&self, topic: &str, message: Vec<u8>) -> Result<(), AppError> {\r\n        IrohNetworkService::broadcast_dht(self, topic, message).await\r\n    }\r\n\r\n    async fn apply_bootstrap_nodes(\r\n        &self,\r\n        nodes: Vec<String>,\r\n        source: BootstrapSource,\r\n    ) -> Result<(), AppError> {\r\n        let mut normalized: Vec<String> = nodes\r\n            .into_iter()\r\n            .map(|entry| entry.trim().to_string())\r\n            .filter(|entry| !entry.is_empty())\r\n            .collect();\r\n        normalized.sort();\r\n        normalized.dedup();\r\n\r\n        {\r\n            let mut cfg = self.network_config.write().await;\r\n            cfg.bootstrap_peers = normalized.clone();\r\n            cfg.bootstrap_source = source;\r\n        }\r\n        {\r\n            let mut peers = self.bootstrap_peers.write().await;\r\n            *peers = normalized.clone();\r\n        }\r\n        {\r\n            let mut stored_source = self.bootstrap_source.write().await;\r\n            *stored_source = source;\r\n        }\r\n\r\n        if normalized.is_empty() {\r\n            tracing::warn!(\"Bootstrap nodes list is empty; skipping connections\");\r\n            return Ok(());\r\n        }\r\n\r\n        let success = self.connect_bootstrap_nodes(&normalized).await;\r\n        if success > 0 {\r\n            super::metrics::record_bootstrap_source(source);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[16562064],"length":1,"stats":{"Line":0}},{"line":37,"address":[16569608,16569438],"length":1,"stats":{"Line":0}},{"line":38,"address":[16675611,16675678],"length":1,"stats":{"Line":0}},{"line":39,"address":[16637654],"length":1,"stats":{"Line":0}},{"line":40,"address":[16563431,16563104],"length":1,"stats":{"Line":0}},{"line":41,"address":[16644884,16645125,16645325,16645772,16644788],"length":1,"stats":{"Line":0}},{"line":43,"address":[19293376],"length":1,"stats":{"Line":0}},{"line":44,"address":[16688480,16688502,16680844],"length":1,"stats":{"Line":0}},{"line":47,"address":[24339147,24339328],"length":1,"stats":{"Line":0}},{"line":50,"address":[16578188,16578255],"length":1,"stats":{"Line":0}},{"line":51,"address":[16571954,16668223,16571352,16668089,16571453],"length":1,"stats":{"Line":0}},{"line":55,"address":[11636713],"length":1,"stats":{"Line":0}},{"line":56,"address":[16641630,16641765],"length":1,"stats":{"Line":0}},{"line":57,"address":[16780161],"length":1,"stats":{"Line":0}},{"line":58,"address":[16683777,16684448,16778575,16778441,16683920],"length":1,"stats":{"Line":0}},{"line":59,"address":[16684392],"length":1,"stats":{"Line":0}},{"line":63,"address":[16683836,16685555],"length":1,"stats":{"Line":0}},{"line":64,"address":[16685657,16685909],"length":1,"stats":{"Line":0}},{"line":66,"address":[16650792,16650876],"length":1,"stats":{"Line":0}},{"line":67,"address":[16651011,16650884],"length":1,"stats":{"Line":0}},{"line":69,"address":[16682241,16682313],"length":1,"stats":{"Line":0}},{"line":70,"address":[24344682,24344622],"length":1,"stats":{"Line":0}},{"line":71,"address":[16688065,16688203],"length":1,"stats":{"Line":0}},{"line":79,"address":[16583743,16583900],"length":1,"stats":{"Line":0}},{"line":80,"address":[16583937,16584017],"length":1,"stats":{"Line":0}},{"line":81,"address":[16570347,16570265],"length":1,"stats":{"Line":0}},{"line":82,"address":[24345394,24345479],"length":1,"stats":{"Line":0}},{"line":86,"address":[24345792,24346066,24345707,24337724],"length":1,"stats":{"Line":0}},{"line":88,"address":[16578056],"length":1,"stats":{"Line":0}},{"line":91,"address":[16578880],"length":1,"stats":{"Line":0}},{"line":95,"address":[16684816],"length":1,"stats":{"Line":0}},{"line":96,"address":[16572117],"length":1,"stats":{"Line":0}},{"line":99,"address":[16653664],"length":1,"stats":{"Line":0}},{"line":100,"address":[16785224],"length":1,"stats":{"Line":0}},{"line":103,"address":[16684864],"length":1,"stats":{"Line":0}},{"line":104,"address":[16572179],"length":1,"stats":{"Line":0}},{"line":105,"address":[16690537],"length":1,"stats":{"Line":0}},{"line":109,"address":[16689154,16689000,16688992,16689039,16689239,16689401,16689008,16690089],"length":1,"stats":{"Line":0}},{"line":110,"address":[11763839],"length":1,"stats":{"Line":0}},{"line":111,"address":[16654762,16654683],"length":1,"stats":{"Line":0}},{"line":114,"address":[11657938],"length":1,"stats":{"Line":0}},{"line":115,"address":[16686512,16685290],"length":1,"stats":{"Line":0}},{"line":116,"address":[16692516,16692460],"length":1,"stats":{"Line":0}},{"line":117,"address":[16787252],"length":1,"stats":{"Line":0}},{"line":121,"address":[16692546,16697004,16692759,16692915,16692802,16692528,16692576,16692607],"length":1,"stats":{"Line":0}},{"line":122,"address":[16588188],"length":1,"stats":{"Line":0}},{"line":123,"address":[16791545,16787649,16787516,16791440],"length":1,"stats":{"Line":0}},{"line":124,"address":[16691193],"length":1,"stats":{"Line":0}},{"line":125,"address":[16578572],"length":1,"stats":{"Line":0}},{"line":129,"address":[16687205,16687363,16691317],"length":1,"stats":{"Line":0}},{"line":131,"address":[16693394,16693230,16693354],"length":1,"stats":{"Line":0}},{"line":132,"address":[16588838,16588893,16676057,16676191],"length":1,"stats":{"Line":0}},{"line":134,"address":[16588739],"length":1,"stats":{"Line":0}},{"line":135,"address":[16875999,16875865,16788099,16789808,16790309],"length":1,"stats":{"Line":0}},{"line":139,"address":[16659925],"length":1,"stats":{"Line":0}},{"line":142,"address":[16578736],"length":1,"stats":{"Line":0}},{"line":143,"address":[16585552],"length":1,"stats":{"Line":0}},{"line":146,"address":[16691561,16691536,16691528,16691647,16692248,16691825,16691520,16691684],"length":1,"stats":{"Line":0}},{"line":147,"address":[16592913,16592789,16592683,16592730],"length":1,"stats":{"Line":0}},{"line":150,"address":[16654160,16654325,16654192,16654506,16654227,16655625,16654168,16654362],"length":1,"stats":{"Line":0}},{"line":152,"address":[11559081],"length":1,"stats":{"Line":0}},{"line":153,"address":[16661623],"length":1,"stats":{"Line":0}},{"line":154,"address":[24355128,24355207],"length":1,"stats":{"Line":0}},{"line":155,"address":[16580239],"length":1,"stats":{"Line":0}},{"line":156,"address":[16698584,16698652,16698794],"length":1,"stats":{"Line":0}},{"line":157,"address":[16793594,16793923],"length":1,"stats":{"Line":0}},{"line":159,"address":[16662076,16662003],"length":1,"stats":{"Line":0}},{"line":160,"address":[16793750],"length":1,"stats":{"Line":0}},{"line":162,"address":[16594322],"length":1,"stats":{"Line":0}},{"line":166,"address":[24358377,24360405,24356366,24356066,24356048,24356096,24356302,24356158],"length":1,"stats":{"Line":0}},{"line":167,"address":[16662815],"length":1,"stats":{"Line":0}},{"line":168,"address":[16698077,16698173],"length":1,"stats":{"Line":0}},{"line":169,"address":[16698204,16702348],"length":1,"stats":{"Line":0}},{"line":170,"address":[11568225],"length":1,"stats":{"Line":0}},{"line":171,"address":[16796775,16796895,16876495,16876361,16797408],"length":1,"stats":{"Line":0}},{"line":177,"address":[16663364,16663148,16663873,16745439,16745305],"length":1,"stats":{"Line":0}},{"line":179,"address":[24360689,24360825,24356353,24357300,24360414,24358286],"length":1,"stats":{"Line":0}},{"line":181,"address":[24359271],"length":1,"stats":{"Line":0}},{"line":185,"address":[16661140,16663187,16660496,16660466,16660733,16660448,16660690,16660543],"length":1,"stats":{"Line":0}},{"line":186,"address":[16702707],"length":1,"stats":{"Line":0}},{"line":187,"address":[16799263,16799359],"length":1,"stats":{"Line":0}},{"line":188,"address":[16667838],"length":1,"stats":{"Line":0}},{"line":189,"address":[16599888,16600641,16600184,16600123,16600340],"length":1,"stats":{"Line":0}},{"line":190,"address":[16703493,16703613,16781055,16780921],"length":1,"stats":{"Line":0}},{"line":192,"address":[16704670],"length":1,"stats":{"Line":0}},{"line":195,"address":[24363648,24363683,24363602,24363853,24364906,24363584,24364401],"length":1,"stats":{"Line":0}},{"line":196,"address":[16801929],"length":1,"stats":{"Line":0}},{"line":197,"address":[16705680,16705602],"length":1,"stats":{"Line":0}},{"line":198,"address":[16589065],"length":1,"stats":{"Line":0}},{"line":199,"address":[10952340],"length":1,"stats":{"Line":0}},{"line":201,"address":[17151207,17151392],"length":1,"stats":{"Line":0}},{"line":203,"address":[24364681],"length":1,"stats":{"Line":0}},{"line":206,"address":[16591167,16590024,16590110,16590016,16590048,16590237,16590355,16590511],"length":1,"stats":{"Line":0}},{"line":208,"address":[10973041],"length":1,"stats":{"Line":0}},{"line":210,"address":[16604591],"length":1,"stats":{"Line":0}},{"line":213,"address":[16597960,16597072,16597717,16597847],"length":1,"stats":{"Line":0}},{"line":215,"address":[24366392],"length":1,"stats":{"Line":0}},{"line":216,"address":[16591525],"length":1,"stats":{"Line":0}},{"line":217,"address":[16704277],"length":1,"stats":{"Line":0}},{"line":218,"address":[16605613],"length":1,"stats":{"Line":0}},{"line":224,"address":[16666179],"length":1,"stats":{"Line":0}},{"line":227,"address":[16803381,16805123,16804738],"length":1,"stats":{"Line":0}},{"line":228,"address":[16708926,16708993],"length":1,"stats":{"Line":0}},{"line":230,"address":[16593359,16592626,16592596,16592390],"length":1,"stats":{"Line":0}},{"line":231,"address":[16805770,16806190],"length":1,"stats":{"Line":0}},{"line":232,"address":[16606673],"length":1,"stats":{"Line":0}},{"line":233,"address":[24367916,24367984],"length":1,"stats":{"Line":0}},{"line":237,"address":[16667816],"length":1,"stats":{"Line":0}},{"line":241,"address":[11583888],"length":1,"stats":{"Line":0}},{"line":242,"address":[16668300,16668223],"length":1,"stats":{"Line":0}},{"line":243,"address":[16806833],"length":1,"stats":{"Line":0}},{"line":245,"address":[16668396],"length":1,"stats":{"Line":0}},{"line":249,"address":[16600688,16600696,16600850,16600893,16603026,16601085,16600751,16600704],"length":1,"stats":{"Line":0}},{"line":250,"address":[16608521,16610000,16607923,16608201,16608311,16608012,16607808],"length":1,"stats":{"Line":0}},{"line":251,"address":[16710824,16710910,16710736,16711129,16710973],"length":1,"stats":{"Line":0}},{"line":252,"address":[16714566,16712982,16714544],"length":1,"stats":{"Line":0}},{"line":253,"address":[24439753,24370301,24439887,24369774],"length":1,"stats":{"Line":0}},{"line":254,"address":[16713593],"length":1,"stats":{"Line":0}},{"line":260,"address":[24440192],"length":1,"stats":{"Line":0}},{"line":264,"address":[16739839,16740180,16744197,16740209,16741345,16740064,16739888,16739935,16740502],"length":1,"stats":{"Line":0}},{"line":265,"address":[11861055],"length":1,"stats":{"Line":0}},{"line":266,"address":[16782832,16782916],"length":1,"stats":{"Line":0}},{"line":267,"address":[16879366],"length":1,"stats":{"Line":0}},{"line":268,"address":[16680096],"length":1,"stats":{"Line":0}},{"line":269,"address":[16740998,16743667],"length":1,"stats":{"Line":0}},{"line":270,"address":[16879484,16879592],"length":1,"stats":{"Line":0}},{"line":271,"address":[16673366,16673449,16672307,16673546],"length":1,"stats":{"Line":0}},{"line":272,"address":[16783645],"length":1,"stats":{"Line":0}},{"line":273,"address":[16785399],"length":1,"stats":{"Line":0}},{"line":274,"address":[16748948,16749449,16748679,16776975,16776841],"length":1,"stats":{"Line":0}},{"line":275,"address":[16674684],"length":1,"stats":{"Line":0}},{"line":278,"address":[16785478],"length":1,"stats":{"Line":0}},{"line":280,"address":[16702735,16673226,16676401,16702601,16675871],"length":1,"stats":{"Line":0}},{"line":281,"address":[24444535],"length":1,"stats":{"Line":0}},{"line":284,"address":[16677664,16677439,16677343,16677693,16677392,16677986,16678622,16680601,16677548],"length":1,"stats":{"Line":0}},{"line":285,"address":[16752314,16752537,16752615,16752754],"length":1,"stats":{"Line":0}},{"line":286,"address":[16789856,16789772],"length":1,"stats":{"Line":0}},{"line":287,"address":[16671584],"length":1,"stats":{"Line":0}},{"line":288,"address":[17269330],"length":1,"stats":{"Line":0}},{"line":291,"address":[11908914],"length":1,"stats":{"Line":0}},{"line":292,"address":[16885236,16885157],"length":1,"stats":{"Line":0}},{"line":293,"address":[16790463],"length":1,"stats":{"Line":0}},{"line":295,"address":[16771039,16747319,16770905,16746782],"length":1,"stats":{"Line":0}},{"line":296,"address":[16789337],"length":1,"stats":{"Line":0}},{"line":297,"address":[16680404],"length":1,"stats":{"Line":0}},{"line":298,"address":[16791986],"length":1,"stats":{"Line":0}},{"line":300,"address":[24448566],"length":1,"stats":{"Line":0}},{"line":303,"address":[16680649,16680891,16680914,16680723,16681137,16680688,16680802,16681585],"length":1,"stats":{"Line":0}},{"line":304,"address":[16687805,16688145,16687990],"length":1,"stats":{"Line":0}},{"line":305,"address":[16681474,16681401],"length":1,"stats":{"Line":0}},{"line":308,"address":[16681758,16682027,16681861,16687094,16681696,16681631,16683430,16684245],"length":1,"stats":{"Line":0}},{"line":314,"address":[16788061],"length":1,"stats":{"Line":0}},{"line":315,"address":[16788219,16788132],"length":1,"stats":{"Line":0}},{"line":316,"address":[16682347],"length":1,"stats":{"Line":0}},{"line":317,"address":[16676580],"length":1,"stats":{"Line":0}},{"line":320,"address":[16687332,16682597,16682369,16682305,16683362,16687104],"length":1,"stats":{"Line":0}},{"line":321,"address":[24455318],"length":1,"stats":{"Line":0}},{"line":322,"address":[16893471],"length":1,"stats":{"Line":0}},{"line":324,"address":[16788806,16793280,16788426,16789254,16788562],"length":1,"stats":{"Line":0}},{"line":325,"address":[17278024],"length":1,"stats":{"Line":0}},{"line":326,"address":[16793310],"length":1,"stats":{"Line":0}},{"line":330,"address":[16676139,16675995],"length":1,"stats":{"Line":0}},{"line":331,"address":[16683077,16682994],"length":1,"stats":{"Line":0}},{"line":334,"address":[16751382,16750939,16751005,16751072,16751546,16751834],"length":1,"stats":{"Line":0}},{"line":335,"address":[16889450],"length":1,"stats":{"Line":0}},{"line":336,"address":[16676513,16675107,16676886,16676453,16676678],"length":1,"stats":{"Line":0}},{"line":337,"address":[16694512,16694740],"length":1,"stats":{"Line":0}},{"line":338,"address":[17278198],"length":1,"stats":{"Line":0}},{"line":339,"address":[16755423],"length":1,"stats":{"Line":0}},{"line":343,"address":[11863211],"length":1,"stats":{"Line":0}},{"line":344,"address":[16677720,16677787],"length":1,"stats":{"Line":0}},{"line":345,"address":[16677830,16677987],"length":1,"stats":{"Line":0}},{"line":346,"address":[24452837],"length":1,"stats":{"Line":0}},{"line":347,"address":[16752484],"length":1,"stats":{"Line":0}},{"line":353,"address":[11802402],"length":1,"stats":{"Line":0}},{"line":354,"address":[16795136,16795219],"length":1,"stats":{"Line":0}},{"line":355,"address":[24453620],"length":1,"stats":{"Line":0}},{"line":356,"address":[16795295],"length":1,"stats":{"Line":0}},{"line":358,"address":[16791408,16809513,16791952,16809647],"length":1,"stats":{"Line":0}},{"line":359,"address":[24454187],"length":1,"stats":{"Line":0}},{"line":362,"address":[16799376,16799665,16800453,16799327,16799636,16799520,16799423,16799923,16802449],"length":1,"stats":{"Line":0}},{"line":363,"address":[16799955,16799550,16799773],"length":1,"stats":{"Line":0}},{"line":364,"address":[16800193,16800280,16802464,16802489],"length":1,"stats":{"Line":0}},{"line":367,"address":[11285822],"length":1,"stats":{"Line":0}},{"line":368,"address":[16689279,16689196],"length":1,"stats":{"Line":0}},{"line":369,"address":[16764080],"length":1,"stats":{"Line":0}},{"line":371,"address":[16895681,16910511,16896225,16910377],"length":1,"stats":{"Line":0}},{"line":372,"address":[16896188],"length":1,"stats":{"Line":0}},{"line":375,"address":[16758825,16758983,16759072,16759318,16759779,16758864,16758899,16759095],"length":1,"stats":{"Line":0}},{"line":376,"address":[16766123,16765938,16766278],"length":1,"stats":{"Line":0}},{"line":377,"address":[16801634,16801715],"length":1,"stats":{"Line":0}},{"line":380,"address":[16759960,16759881,16760238,16760063,16760603,16759856,16760025,16759817],"length":1,"stats":{"Line":0}},{"line":381,"address":[24460654,24460371,24460530,24460427],"length":1,"stats":{"Line":0}},{"line":382,"address":[16685900,16685967],"length":1,"stats":{"Line":0}},{"line":385,"address":[16686080,16686173,16686041,16686110,16686238,16686261,16686510],"length":1,"stats":{"Line":0}},{"line":386,"address":[16693145],"length":1,"stats":{"Line":0}},{"line":389,"address":[16803215,16803299,16803264,16803952,16803487,16803691,16803464,16803381],"length":1,"stats":{"Line":0}},{"line":390,"address":[16700713,16700843,16700528],"length":1,"stats":{"Line":0}},{"line":393,"address":[16804165,16804271,16804749,16804248,16804048,16804083,16803999,16804488],"length":1,"stats":{"Line":0}},{"line":394,"address":[16804377,16804192,16804520],"length":1,"stats":{"Line":0}},{"line":397,"address":[16762751,16763240,16762835,16763000,16763023,16762800,16763501,16762917],"length":1,"stats":{"Line":0}},{"line":398,"address":[16901609,16901752,16901424],"length":1,"stats":{"Line":0}},{"line":401,"address":[24464310,24464160,24464051,24464884,24464275,24464016,24463935,24464623],"length":1,"stats":{"Line":0}},{"line":402,"address":[17286676,17286815,17286363],"length":1,"stats":{"Line":0}},{"line":405,"address":[16808462,16811238,16806688,16807054,16807594,16806875,16806616,16806735,16811646],"length":1,"stats":{"Line":0}},{"line":410,"address":[16765147],"length":1,"stats":{"Line":0}},{"line":412,"address":[16811680,16811712],"length":1,"stats":{"Line":0}},{"line":413,"address":[16695241,16695216],"length":1,"stats":{"Line":0}},{"line":415,"address":[16903739,16903842],"length":1,"stats":{"Line":0}},{"line":416,"address":[16807421],"length":1,"stats":{"Line":0}},{"line":419,"address":[16697049,16697588,16697770],"length":1,"stats":{"Line":0}},{"line":420,"address":[16904862,16904296],"length":1,"stats":{"Line":0}},{"line":421,"address":[16808154,16808258],"length":1,"stats":{"Line":0}},{"line":424,"address":[11831692],"length":1,"stats":{"Line":0}},{"line":425,"address":[16692528,16692069],"length":1,"stats":{"Line":0}},{"line":428,"address":[16690307,16692579,16692378],"length":1,"stats":{"Line":0}},{"line":429,"address":[16706577,16706681],"length":1,"stats":{"Line":0}},{"line":432,"address":[16706702],"length":1,"stats":{"Line":0}},{"line":433,"address":[16809848,16814575,16809676,16810361,16814441],"length":1,"stats":{"Line":0}},{"line":434,"address":[16768272],"length":1,"stats":{"Line":0}},{"line":437,"address":[16805689,16803032,16807414,16805795],"length":1,"stats":{"Line":0}},{"line":438,"address":[16701702],"length":1,"stats":{"Line":0}},{"line":439,"address":[16776475],"length":1,"stats":{"Line":0}},{"line":441,"address":[17291882],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":224},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","metrics.rs"],"content":"use crate::shared::config::BootstrapSource;\nuse crate::shared::metrics::{AtomicMetric, UNSET_TS, current_unix_ms, timestamp_to_option};\nuse crate::shared::validation::ValidationFailureKind;\nuse once_cell::sync::Lazy;\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::sync::Mutex;\nuse std::sync::atomic::{AtomicU64, Ordering};\n\nstatic JOIN_METRIC: AtomicMetric = AtomicMetric::new();\nstatic LEAVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic BROADCAST_METRIC: AtomicMetric = AtomicMetric::new();\nstatic RECEIVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic RECEIVE_FAILURES_BY_REASON: Lazy<Mutex<HashMap<ValidationFailureKind, u64>>> =\n    Lazy::new(|| Mutex::new(HashMap::new()));\nstatic MAINLINE_CONNECTION_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_ROUTING_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_RECONNECT_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_CONNECTED_PEERS: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_ENV_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_USER_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_BUNDLE_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_FALLBACK_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_LAST_SOURCE: AtomicU64 = AtomicU64::new(BootstrapSource::None as u8 as u64);\nstatic BOOTSTRAP_LAST_MS: AtomicU64 = AtomicU64::new(UNSET_TS);\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricDetails {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\nfn to_gossip_details(metric: &AtomicMetric) -> GossipMetricDetails {\n    let snapshot = metric.snapshot();\n    GossipMetricDetails {\n        total: snapshot.successes,\n        failures: snapshot.failures,\n        last_success_ms: snapshot.last_success_ms,\n        last_failure_ms: snapshot.last_failure_ms,\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ReceiveFailureBreakdown {\n    pub reason: String,\n    pub count: u64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricsSnapshot {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetails,\n    pub leave_details: GossipMetricDetails,\n    pub broadcast_details: GossipMetricDetails,\n    pub receive_details: GossipMetricDetails,\n    pub receive_failures_by_reason: Vec<ReceiveFailureBreakdown>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct MainlineMetricsSnapshot {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n    pub bootstrap: BootstrapMetricsSnapshot,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct P2PMetricsSnapshot {\n    pub gossip: GossipMetricsSnapshot,\n    pub mainline: MainlineMetricsSnapshot,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct BootstrapMetricsSnapshot {\n    pub env_uses: u64,\n    pub user_uses: u64,\n    pub bundle_uses: u64,\n    pub fallback_uses: u64,\n    pub last_source: Option<String>,\n    pub last_applied_ms: Option<u64>,\n}\n\n#[inline]\npub fn record_join_success() {\n    JOIN_METRIC.record_success();\n}\n\npub fn record_join_failure() {\n    JOIN_METRIC.record_failure();\n}\n\npub fn record_leave_success() {\n    LEAVE_METRIC.record_success();\n}\n\npub fn record_leave_failure() {\n    LEAVE_METRIC.record_failure();\n}\n\npub fn record_broadcast_success() {\n    BROADCAST_METRIC.record_success();\n}\n\npub fn record_broadcast_failure() {\n    BROADCAST_METRIC.record_failure();\n}\n\npub fn record_receive_success() {\n    RECEIVE_METRIC.record_success();\n}\n\npub fn record_receive_failure() {\n    record_receive_failure_with_reason(ValidationFailureKind::Generic);\n}\n\npub fn record_receive_failure_with_reason(kind: ValidationFailureKind) {\n    RECEIVE_METRIC.record_failure();\n    if let Ok(mut map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        *map.entry(kind).or_insert(0) += 1;\n    }\n}\n\npub fn record_mainline_connection_success() {\n    MAINLINE_CONNECTION_METRIC.record_success();\n}\n\npub fn record_mainline_connection_failure() {\n    MAINLINE_CONNECTION_METRIC.record_failure();\n}\n\npub fn set_mainline_connected_peers(count: u64) {\n    MAINLINE_CONNECTED_PEERS.store(count, Ordering::Relaxed);\n}\n\npub fn record_mainline_route_success() {\n    MAINLINE_ROUTING_METRIC.record_success();\n}\n\npub fn record_mainline_route_failure() {\n    MAINLINE_ROUTING_METRIC.record_failure();\n}\n\npub fn record_mainline_reconnect_success() {\n    MAINLINE_RECONNECT_METRIC.record_success();\n}\n\npub fn record_mainline_reconnect_failure() {\n    MAINLINE_RECONNECT_METRIC.record_failure();\n}\n\npub fn record_bootstrap_source(source: BootstrapSource) {\n    match source {\n        BootstrapSource::Env => {\n            BOOTSTRAP_ENV_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::User => {\n            BOOTSTRAP_USER_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::Bundle => {\n            BOOTSTRAP_BUNDLE_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::Fallback => {\n            BOOTSTRAP_FALLBACK_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::None => {}\n    }\n    BOOTSTRAP_LAST_SOURCE.store(source as u8 as u64, Ordering::Relaxed);\n    BOOTSTRAP_LAST_MS.store(current_unix_ms(), Ordering::Relaxed);\n}\n\npub fn reset_all() {\n    JOIN_METRIC.reset();\n    LEAVE_METRIC.reset();\n    BROADCAST_METRIC.reset();\n    RECEIVE_METRIC.reset();\n    if let Ok(mut map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        map.clear();\n    }\n    MAINLINE_CONNECTION_METRIC.reset();\n    MAINLINE_ROUTING_METRIC.reset();\n    MAINLINE_RECONNECT_METRIC.reset();\n    MAINLINE_CONNECTED_PEERS.store(0, Ordering::Relaxed);\n    BOOTSTRAP_ENV_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_USER_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_BUNDLE_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_FALLBACK_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_LAST_SOURCE.store(BootstrapSource::None as u8 as u64, Ordering::Relaxed);\n    BOOTSTRAP_LAST_MS.store(UNSET_TS, Ordering::Relaxed);\n}\n\npub fn snapshot() -> GossipMetricsSnapshot {\n    let join_details = to_gossip_details(&JOIN_METRIC);\n    let leave_details = to_gossip_details(&LEAVE_METRIC);\n    let broadcast_details = to_gossip_details(&BROADCAST_METRIC);\n    let receive_details = to_gossip_details(&RECEIVE_METRIC);\n    let receive_failures_by_reason = if let Ok(map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        map.iter()\n            .map(|(kind, count)| ReceiveFailureBreakdown {\n                reason: kind.as_str().to_string(),\n                count: *count,\n            })\n            .collect()\n    } else {\n        Vec::new()\n    };\n\n    GossipMetricsSnapshot {\n        joins: join_details.total,\n        leaves: leave_details.total,\n        broadcasts_sent: broadcast_details.total,\n        messages_received: receive_details.total,\n        join_details,\n        leave_details,\n        broadcast_details,\n        receive_details,\n        receive_failures_by_reason,\n    }\n}\n\npub fn mainline_snapshot() -> MainlineMetricsSnapshot {\n    let connection_details = MAINLINE_CONNECTION_METRIC.snapshot();\n    let routing_details = MAINLINE_ROUTING_METRIC.snapshot();\n    let reconnect_details = MAINLINE_RECONNECT_METRIC.snapshot();\n    let connected_peers = MAINLINE_CONNECTED_PEERS.load(Ordering::Relaxed);\n    let bootstrap = bootstrap_snapshot();\n\n    let connection_attempts = connection_details.successes + connection_details.failures;\n    let routing_attempts = routing_details.successes + routing_details.failures;\n    let routing_success_rate = if routing_attempts == 0 {\n        0.0\n    } else {\n        routing_details.successes as f64 / routing_attempts as f64\n    };\n    let reconnect_attempts = reconnect_details.successes + reconnect_details.failures;\n\n    MainlineMetricsSnapshot {\n        connected_peers,\n        connection_attempts,\n        connection_successes: connection_details.successes,\n        connection_failures: connection_details.failures,\n        connection_last_success_ms: connection_details.last_success_ms,\n        connection_last_failure_ms: connection_details.last_failure_ms,\n        routing_attempts,\n        routing_successes: routing_details.successes,\n        routing_failures: routing_details.failures,\n        routing_success_rate,\n        routing_last_success_ms: routing_details.last_success_ms,\n        routing_last_failure_ms: routing_details.last_failure_ms,\n        reconnect_attempts,\n        reconnect_successes: reconnect_details.successes,\n        reconnect_failures: reconnect_details.failures,\n        last_reconnect_success_ms: reconnect_details.last_success_ms,\n        last_reconnect_failure_ms: reconnect_details.last_failure_ms,\n        bootstrap,\n    }\n}\n\npub fn snapshot_full() -> P2PMetricsSnapshot {\n    P2PMetricsSnapshot {\n        gossip: snapshot(),\n        mainline: mainline_snapshot(),\n    }\n}\n\nfn bootstrap_snapshot() -> BootstrapMetricsSnapshot {\n    let last_source_code = BOOTSTRAP_LAST_SOURCE.load(Ordering::Relaxed);\n    let last_source = match last_source_code as u8 {\n        x if x == BootstrapSource::Env as u8 => Some(\"env\".to_string()),\n        x if x == BootstrapSource::User as u8 => Some(\"user\".to_string()),\n        x if x == BootstrapSource::Bundle as u8 => Some(\"bundle\".to_string()),\n        x if x == BootstrapSource::Fallback as u8 => Some(\"fallback\".to_string()),\n        _ => None,\n    };\n\n    BootstrapMetricsSnapshot {\n        env_uses: BOOTSTRAP_ENV_COUNT.load(Ordering::Relaxed),\n        user_uses: BOOTSTRAP_USER_COUNT.load(Ordering::Relaxed),\n        bundle_uses: BOOTSTRAP_BUNDLE_COUNT.load(Ordering::Relaxed),\n        fallback_uses: BOOTSTRAP_FALLBACK_COUNT.load(Ordering::Relaxed),\n        last_source,\n        last_applied_ms: timestamp_to_option(BOOTSTRAP_LAST_MS.load(Ordering::Relaxed)),\n    }\n}\n","traces":[{"line":15,"address":[15234608,15234626],"length":1,"stats":{"Line":2}},{"line":35,"address":[15227744],"length":1,"stats":{"Line":1}},{"line":36,"address":[22928146],"length":1,"stats":{"Line":1}},{"line":38,"address":[15227781],"length":1,"stats":{"Line":2}},{"line":39,"address":[22928170],"length":1,"stats":{"Line":2}},{"line":40,"address":[15159983],"length":1,"stats":{"Line":2}},{"line":41,"address":[15153209],"length":1,"stats":{"Line":2}},{"line":103,"address":[15269888],"length":1,"stats":{"Line":0}},{"line":104,"address":[15227841],"length":1,"stats":{"Line":0}},{"line":107,"address":[15366336],"length":1,"stats":{"Line":0}},{"line":108,"address":[15265969],"length":1,"stats":{"Line":0}},{"line":111,"address":[15153280],"length":1,"stats":{"Line":0}},{"line":112,"address":[15366353],"length":1,"stats":{"Line":0}},{"line":115,"address":[15153296],"length":1,"stats":{"Line":0}},{"line":116,"address":[15160081],"length":1,"stats":{"Line":0}},{"line":119,"address":[15266016],"length":1,"stats":{"Line":1}},{"line":120,"address":[15153313],"length":1,"stats":{"Line":1}},{"line":123,"address":[15366400],"length":1,"stats":{"Line":1}},{"line":124,"address":[15266033],"length":1,"stats":{"Line":1}},{"line":127,"address":[15160128],"length":1,"stats":{"Line":1}},{"line":128,"address":[15167105],"length":1,"stats":{"Line":1}},{"line":131,"address":[15153360],"length":1,"stats":{"Line":1}},{"line":132,"address":[15271649],"length":1,"stats":{"Line":1}},{"line":135,"address":[15167480,15167152],"length":1,"stats":{"Line":1}},{"line":136,"address":[21046063],"length":1,"stats":{"Line":1}},{"line":137,"address":[15160203],"length":1,"stats":{"Line":1}},{"line":138,"address":[15235075,15234994,15235168],"length":1,"stats":{"Line":2}},{"line":142,"address":[15272048],"length":1,"stats":{"Line":0}},{"line":143,"address":[15235281],"length":1,"stats":{"Line":0}},{"line":146,"address":[15272064],"length":1,"stats":{"Line":0}},{"line":147,"address":[21046401],"length":1,"stats":{"Line":0}},{"line":150,"address":[15167552],"length":1,"stats":{"Line":0}},{"line":151,"address":[15235324],"length":1,"stats":{"Line":0}},{"line":154,"address":[15235360],"length":1,"stats":{"Line":0}},{"line":155,"address":[15228433],"length":1,"stats":{"Line":0}},{"line":158,"address":[21046480],"length":1,"stats":{"Line":0}},{"line":159,"address":[15167617],"length":1,"stats":{"Line":0}},{"line":162,"address":[15266576],"length":1,"stats":{"Line":0}},{"line":163,"address":[15153873],"length":1,"stats":{"Line":0}},{"line":166,"address":[15160672],"length":1,"stats":{"Line":0}},{"line":167,"address":[15272177],"length":1,"stats":{"Line":0}},{"line":170,"address":[15160688],"length":1,"stats":{"Line":0}},{"line":171,"address":[15272203],"length":1,"stats":{"Line":0}},{"line":173,"address":[15270588],"length":1,"stats":{"Line":0}},{"line":176,"address":[15228569],"length":1,"stats":{"Line":0}},{"line":179,"address":[15235526],"length":1,"stats":{"Line":0}},{"line":182,"address":[15228627],"length":1,"stats":{"Line":0}},{"line":186,"address":[22929038],"length":1,"stats":{"Line":0}},{"line":187,"address":[22929069],"length":1,"stats":{"Line":0}},{"line":190,"address":[15271256,15270768],"length":1,"stats":{"Line":1}},{"line":191,"address":[15270772],"length":1,"stats":{"Line":1}},{"line":192,"address":[22929120],"length":1,"stats":{"Line":1}},{"line":193,"address":[21046780],"length":1,"stats":{"Line":1}},{"line":194,"address":[15272456],"length":1,"stats":{"Line":1}},{"line":195,"address":[21046804],"length":1,"stats":{"Line":1}},{"line":196,"address":[15235824,15235755],"length":1,"stats":{"Line":2}},{"line":198,"address":[15161160],"length":1,"stats":{"Line":2}},{"line":199,"address":[22929364],"length":1,"stats":{"Line":2}},{"line":200,"address":[15228992],"length":1,"stats":{"Line":2}},{"line":201,"address":[15367484],"length":1,"stats":{"Line":2}},{"line":202,"address":[21047043],"length":1,"stats":{"Line":2}},{"line":203,"address":[15267168],"length":1,"stats":{"Line":2}},{"line":204,"address":[15168250],"length":1,"stats":{"Line":2}},{"line":205,"address":[15367588],"length":1,"stats":{"Line":2}},{"line":206,"address":[15272830],"length":1,"stats":{"Line":2}},{"line":207,"address":[15229161],"length":1,"stats":{"Line":2}},{"line":210,"address":[15168416,15169117],"length":1,"stats":{"Line":1}},{"line":211,"address":[15267377],"length":1,"stats":{"Line":1}},{"line":212,"address":[21047298],"length":1,"stats":{"Line":2}},{"line":213,"address":[22929683],"length":1,"stats":{"Line":2}},{"line":214,"address":[15267431],"length":1,"stats":{"Line":2}},{"line":215,"address":[15273035],"length":1,"stats":{"Line":2}},{"line":216,"address":[15168580,15168683],"length":1,"stats":{"Line":2}},{"line":217,"address":[21047984,21048078,21048031],"length":1,"stats":{"Line":0}},{"line":218,"address":[15368537],"length":1,"stats":{"Line":0}},{"line":219,"address":[21048075],"length":1,"stats":{"Line":0}},{"line":223,"address":[15154858],"length":1,"stats":{"Line":0}},{"line":227,"address":[15236597],"length":1,"stats":{"Line":2}},{"line":228,"address":[15236602],"length":1,"stats":{"Line":2}},{"line":229,"address":[21047667],"length":1,"stats":{"Line":2}},{"line":230,"address":[15271735],"length":1,"stats":{"Line":2}},{"line":239,"address":[15269255,15268256],"length":1,"stats":{"Line":0}},{"line":240,"address":[15273870],"length":1,"stats":{"Line":0}},{"line":241,"address":[15155602],"length":1,"stats":{"Line":0}},{"line":242,"address":[15237142],"length":1,"stats":{"Line":0}},{"line":243,"address":[15162426],"length":1,"stats":{"Line":0}},{"line":244,"address":[15237206],"length":1,"stats":{"Line":0}},{"line":246,"address":[15273987,15274060],"length":1,"stats":{"Line":0}},{"line":247,"address":[15268545,15268448,15268561],"length":1,"stats":{"Line":0}},{"line":248,"address":[21048421,21048459],"length":1,"stats":{"Line":0}},{"line":249,"address":[15272515],"length":1,"stats":{"Line":0}},{"line":251,"address":[15274182],"length":1,"stats":{"Line":0}},{"line":253,"address":[15369046,15369602],"length":1,"stats":{"Line":0}},{"line":258,"address":[15237537],"length":1,"stats":{"Line":0}},{"line":259,"address":[21048602],"length":1,"stats":{"Line":0}},{"line":260,"address":[22931019],"length":1,"stats":{"Line":0}},{"line":261,"address":[15162853],"length":1,"stats":{"Line":0}},{"line":263,"address":[15230681],"length":1,"stats":{"Line":0}},{"line":264,"address":[15274385],"length":1,"stats":{"Line":0}},{"line":266,"address":[15272760],"length":1,"stats":{"Line":0}},{"line":267,"address":[15230728],"length":1,"stats":{"Line":0}},{"line":269,"address":[22931133],"length":1,"stats":{"Line":0}},{"line":270,"address":[15272810],"length":1,"stats":{"Line":0}},{"line":271,"address":[15369255],"length":1,"stats":{"Line":0}},{"line":272,"address":[15156209],"length":1,"stats":{"Line":0}},{"line":277,"address":[15269280,15269428],"length":1,"stats":{"Line":0}},{"line":279,"address":[15269296],"length":1,"stats":{"Line":0}},{"line":280,"address":[15274894],"length":1,"stats":{"Line":0}},{"line":284,"address":[22931728,22932631],"length":1,"stats":{"Line":0}},{"line":285,"address":[15170529],"length":1,"stats":{"Line":0}},{"line":286,"address":[15269511],"length":1,"stats":{"Line":0}},{"line":287,"address":[15269515],"length":1,"stats":{"Line":0}},{"line":288,"address":[15231552,15231492],"length":1,"stats":{"Line":0}},{"line":289,"address":[15275323],"length":1,"stats":{"Line":0}},{"line":290,"address":[15231725],"length":1,"stats":{"Line":0}},{"line":291,"address":[15269935],"length":1,"stats":{"Line":0}},{"line":295,"address":[15269626],"length":1,"stats":{"Line":0}},{"line":296,"address":[15270004],"length":1,"stats":{"Line":0}},{"line":297,"address":[22932311],"length":1,"stats":{"Line":0}},{"line":298,"address":[15370442],"length":1,"stats":{"Line":0}},{"line":300,"address":[15232031,15232115],"length":1,"stats":{"Line":0}}],"covered":47,"coverable":121},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","mod.rs"],"content":"pub mod bootstrap;\npub mod bootstrap_config;\npub mod dht_bootstrap;\npub mod dht_integration;\npub mod discovery_options;\npub mod event_distributor;\npub mod gossip_service;\npub mod iroh_gossip_service;\npub mod iroh_network_service;\npub mod metrics;\npub mod network_service;\npub mod utils;\n\npub use discovery_options::DiscoveryOptions;\npub use event_distributor::EventDistributor;\npub use gossip_service::GossipService;\npub use network_service::{NetworkService, NetworkStats, Peer};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","network_service.rs"],"content":"use crate::shared::{AppError, config::BootstrapSource};\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Peer {\n    pub id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkStats {\n    pub connected_peers: usize,\n    pub total_messages_sent: u64,\n    pub total_messages_received: u64,\n    pub bandwidth_up: u64,\n    pub bandwidth_down: u64,\n}\n\n#[async_trait]\npub trait NetworkService: Send + Sync {\n    // Type conversion helper for downcasting\n    fn as_any(&self) -> &dyn std::any::Any;\n\n    async fn connect(&self) -> Result<(), AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError>;\n    async fn add_peer(&self, address: &str) -> Result<(), AppError>;\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError>;\n    async fn get_stats(&self) -> Result<NetworkStats, AppError>;\n    async fn is_connected(&self) -> bool;\n    async fn get_node_id(&self) -> Result<String, AppError>;\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError>;\n\n    async fn join_dht_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn leave_dht_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast_dht(&self, _topic: &str, _message: Vec<u8>) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        _nodes: Vec<String>,\n        _source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","utils.rs"],"content":"use crate::shared::error::AppError;\nuse iroh::{EndpointAddr, EndpointId};\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\n#[derive(Debug, Clone)]\npub struct ParsedPeer {\n    pub node_id: EndpointId,\n    pub node_addr: Option<EndpointAddr>,\n}\n\npub fn parse_node_addr(value: &str) -> Result<EndpointAddr, AppError> {\n    let (node_part, addr_part) = value\n        .split_once('@')\n        .ok_or_else(|| AppError::P2PError(format!(\"Invalid node address format: {value}\")))?;\n\n    let node_id = EndpointId::from_str(node_part)\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n\n    let socket_addr: SocketAddr = addr_part\n        .parse()\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse socket address: {e}\")))?;\n\n    Ok(EndpointAddr::new(node_id).with_ip_addr(socket_addr))\n}\n\npub fn parse_peer_hint(value: &str) -> Result<ParsedPeer, AppError> {\n    if value.contains('@') {\n        let node_addr = parse_node_addr(value)?;\n        Ok(ParsedPeer {\n            node_id: node_addr.id,\n            node_addr: Some(node_addr),\n        })\n    } else {\n        let node_id = EndpointId::from_str(value)\n            .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n        Ok(ParsedPeer {\n            node_id,\n            node_addr: None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_parse_node_addr() {\n        let addr = parse_node_addr(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef@127.0.0.1:1234\",\n        )\n        .unwrap();\n        assert_eq!(addr.ip_addrs().count(), 1);\n    }\n\n    #[test]\n    fn test_parse_peer_hint_node_id() {\n        let node_id = EndpointId::from_str(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\",\n        )\n        .unwrap();\n        let parsed =\n            parse_peer_hint(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n                .unwrap();\n        assert_eq!(parsed.node_id, node_id);\n        assert!(parsed.node_addr.is_none());\n    }\n}\n","traces":[{"line":12,"address":[23031904],"length":1,"stats":{"Line":1}},{"line":13,"address":[23131212,23130875],"length":1,"stats":{"Line":1}},{"line":15,"address":[23950412,23951040,23951061],"length":1,"stats":{"Line":0}},{"line":17,"address":[23950475,23950656,23950326],"length":1,"stats":{"Line":2}},{"line":18,"address":[23132006,23131400,23131984],"length":1,"stats":{"Line":0}},{"line":20,"address":[23135248,23135393,23135709],"length":1,"stats":{"Line":2}},{"line":22,"address":[17273342,17273864,17273840],"length":1,"stats":{"Line":0}},{"line":24,"address":[23137105],"length":1,"stats":{"Line":1}},{"line":27,"address":[23033488],"length":1,"stats":{"Line":1}},{"line":28,"address":[23232859,23233215,23233528],"length":1,"stats":{"Line":2}},{"line":29,"address":[23232982,23233533,23233282],"length":1,"stats":{"Line":0}},{"line":30,"address":[23233415],"length":1,"stats":{"Line":0}},{"line":31,"address":[23027021],"length":1,"stats":{"Line":0}},{"line":32,"address":[23027085],"length":1,"stats":{"Line":0}},{"line":35,"address":[23136816,23136452,23136594],"length":1,"stats":{"Line":2}},{"line":36,"address":[23233217,23233622,23233600],"length":1,"stats":{"Line":0}},{"line":37,"address":[23951962],"length":1,"stats":{"Line":1}},{"line":39,"address":[23033778],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","cache_storage.rs"],"content":"use async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CacheEntry<T> {\n    pub data: T,\n    pub created_at: i64,\n    pub expires_at: Option<i64>,\n}\n\n#[async_trait]\npub trait CacheStorage: Send + Sync {\n    async fn set<T: Serialize + Send + Sync>(\n        &self,\n        key: &str,\n        value: T,\n        ttl: Option<Duration>,\n    ) -> Result<(), Box<dyn std::error::Error>>;\n    async fn get<T: for<'de> Deserialize<'de>>(\n        &self,\n        key: &str,\n    ) -> Result<Option<T>, Box<dyn std::error::Error>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn cleanup_expired(&self) -> Result<u32, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","file_storage.rs"],"content":"use async_trait::async_trait;\nuse std::path::{Path, PathBuf};\n\n#[async_trait]\npub trait FileStorage: Send + Sync {\n    async fn save_file(&self, path: &Path, data: &[u8]) -> Result<(), Box<dyn std::error::Error>>;\n    async fn read_file(&self, path: &Path) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn delete_file(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n    async fn file_exists(&self, path: &Path) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn list_files(\n        &self,\n        directory: &Path,\n    ) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>>;\n    async fn create_directory(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","group_key_store.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord, GroupKeyStore};\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nconst GROUP_KEY_INDEX_KEY: &str = \"group_key_index_v1\";\n\n#[derive(Debug, Serialize, Deserialize, Default)]\nstruct GroupKeyIndex {\n    version: u32,\n    entries: Vec<GroupKeyEntry>,\n}\n\npub struct SecureGroupKeyStore {\n    secure_storage: Arc<dyn SecureStorage>,\n}\n\nimpl SecureGroupKeyStore {\n    pub fn new(secure_storage: Arc<dyn SecureStorage>) -> Self {\n        Self { secure_storage }\n    }\n\n    fn storage_key(topic_id: &str, scope: &str, epoch: i64) -> String {\n        format!(\"group_key:{topic_id}:{scope}:{epoch}\")\n    }\n\n    async fn load_index(&self) -> Result<GroupKeyIndex, AppError> {\n        let Some(raw) = self.secure_storage.retrieve(GROUP_KEY_INDEX_KEY).await? else {\n            return Ok(GroupKeyIndex::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_index(&self, index: &GroupKeyIndex) -> Result<(), AppError> {\n        let json = serde_json::to_string(index)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(GROUP_KEY_INDEX_KEY, &json)\n            .await?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl GroupKeyStore for SecureGroupKeyStore {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n        let key = Self::storage_key(&record.topic_id, &record.scope, record.epoch);\n        self.secure_storage.store(&key, &record.key_b64).await?;\n\n        let mut index = self.load_index().await?;\n        let now = Utc::now().timestamp();\n        let mut updated = false;\n        for entry in index.entries.iter_mut() {\n            if entry.topic_id == record.topic_id\n                && entry.scope == record.scope\n                && entry.epoch == record.epoch\n            {\n                entry.stored_at = now;\n                updated = true;\n                break;\n            }\n        }\n        if !updated {\n            index.entries.push(GroupKeyEntry {\n                topic_id: record.topic_id.clone(),\n                scope: record.scope.clone(),\n                epoch: record.epoch,\n                stored_at: now,\n            });\n        }\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(&index).await?;\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let key = Self::storage_key(topic_id, scope, epoch);\n        let Some(value) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let stored_at = Utc::now().timestamp();\n        Ok(Some(GroupKeyRecord {\n            topic_id: topic_id.to_string(),\n            scope: scope.to_string(),\n            epoch,\n            key_b64: value,\n            stored_at,\n        }))\n    }\n\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let index = self.load_index().await?;\n        let mut latest_epoch = None;\n        for entry in index.entries.iter() {\n            if entry.topic_id == topic_id && entry.scope == scope {\n                latest_epoch = match latest_epoch {\n                    Some(epoch) if epoch >= entry.epoch => Some(epoch),\n                    _ => Some(entry.epoch),\n                };\n            }\n        }\n        let Some(epoch) = latest_epoch else {\n            return Ok(None);\n        };\n        self.get_key(topic_id, scope, epoch).await\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        let index = self.load_index().await?;\n        Ok(index.entries)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::storage::secure_storage::DefaultSecureStorage;\n\n    #[tokio::test]\n    async fn store_and_load_group_key_index() {\n        let secure = Arc::new(DefaultSecureStorage::new());\n        let store = SecureGroupKeyStore::new(secure);\n        let record = GroupKeyRecord {\n            topic_id: \"kukuri:topic1\".to_string(),\n            scope: \"friend\".to_string(),\n            epoch: 3,\n            key_b64: \"dGVzdGtleQ==\".to_string(),\n            stored_at: Utc::now().timestamp(),\n        };\n\n        store.store_key(record.clone()).await.expect(\"store key\");\n\n        let loaded = store\n            .get_key(&record.topic_id, &record.scope, record.epoch)\n            .await\n            .expect(\"load key\");\n        assert!(loaded.is_some());\n        let index = store.list_keys().await.expect(\"list keys\");\n        assert_eq!(index.len(), 1);\n        assert_eq!(index[0].epoch, 3);\n    }\n}\n","traces":[{"line":22,"address":[19020816],"length":1,"stats":{"Line":1}},{"line":26,"address":[19117280],"length":1,"stats":{"Line":1}},{"line":27,"address":[18918010],"length":1,"stats":{"Line":1}},{"line":30,"address":[19023109,19022768,19022819,19022784,19022906,19022946,19022776,19023836],"length":1,"stats":{"Line":4}},{"line":31,"address":[11624420],"length":1,"stats":{"Line":2}},{"line":32,"address":[18919322],"length":1,"stats":{"Line":1}},{"line":34,"address":[18905666,18905438,18905648,18905347],"length":1,"stats":{"Line":2}},{"line":37,"address":[19022480,19022448,19023719,19022461,19022527,19022652,19022695,19023290],"length":1,"stats":{"Line":4}},{"line":38,"address":[18912886,18912777,18913106,18913378],"length":1,"stats":{"Line":2}},{"line":39,"address":[18907088,18907106,18906274],"length":1,"stats":{"Line":0}},{"line":40,"address":[18981619,18981068,18981139,18981365,18980842,18981479],"length":1,"stats":{"Line":5}},{"line":41,"address":[18906427],"length":1,"stats":{"Line":1}},{"line":42,"address":[13161299,13160820,13160867,13160346,13160986,13161119],"length":1,"stats":{"Line":3}},{"line":43,"address":[19023601],"length":1,"stats":{"Line":1}},{"line":49,"address":[11903796],"length":1,"stats":{"Line":4}},{"line":50,"address":[18987174,18987289],"length":1,"stats":{"Line":2}},{"line":51,"address":[19090714,19090265,19091052,19089746,19090387,19091236],"length":1,"stats":{"Line":2}},{"line":53,"address":[11275758],"length":1,"stats":{"Line":2}},{"line":54,"address":[19091780,19091622],"length":1,"stats":{"Line":2}},{"line":55,"address":[19049769],"length":1,"stats":{"Line":1}},{"line":56,"address":[13229489,13229698],"length":1,"stats":{"Line":1}},{"line":57,"address":[18975415],"length":1,"stats":{"Line":0}},{"line":58,"address":[18982240],"length":1,"stats":{"Line":0}},{"line":59,"address":[18982285],"length":1,"stats":{"Line":0}},{"line":61,"address":[19057056],"length":1,"stats":{"Line":0}},{"line":62,"address":[18982324],"length":1,"stats":{"Line":0}},{"line":66,"address":[24085051],"length":1,"stats":{"Line":1}},{"line":67,"address":[19188625,19188796],"length":1,"stats":{"Line":2}},{"line":68,"address":[19050167],"length":1,"stats":{"Line":1}},{"line":69,"address":[19093912],"length":1,"stats":{"Line":1}},{"line":70,"address":[19057229],"length":1,"stats":{"Line":1}},{"line":74,"address":[19188670],"length":1,"stats":{"Line":1}},{"line":75,"address":[19092475],"length":1,"stats":{"Line":1}},{"line":77,"address":[11899632],"length":1,"stats":{"Line":1}},{"line":78,"address":[18976259],"length":1,"stats":{"Line":1}},{"line":81,"address":[18992417,18990560,18990712,18990598,18990830,18990494,18991245],"length":1,"stats":{"Line":5}},{"line":87,"address":[19051792],"length":1,"stats":{"Line":1}},{"line":88,"address":[11899684],"length":1,"stats":{"Line":2}},{"line":89,"address":[18978671],"length":1,"stats":{"Line":0}},{"line":91,"address":[18991782,18991867],"length":1,"stats":{"Line":2}},{"line":92,"address":[19059824],"length":1,"stats":{"Line":1}},{"line":93,"address":[19090846],"length":1,"stats":{"Line":1}},{"line":94,"address":[19191249],"length":1,"stats":{"Line":1}},{"line":95,"address":[19059780],"length":1,"stats":{"Line":1}},{"line":96,"address":[18978272],"length":1,"stats":{"Line":1}},{"line":101,"address":[19097152,19099017,19097316,19097710,19097087,19097199,19097461,19099358],"length":1,"stats":{"Line":0}},{"line":106,"address":[18986634,18987508,18986238,18986065,18985842],"length":1,"stats":{"Line":0}},{"line":107,"address":[19096438],"length":1,"stats":{"Line":0}},{"line":108,"address":[19061334,19061674,19061513],"length":1,"stats":{"Line":0}},{"line":109,"address":[19193247,19193577,19193791],"length":1,"stats":{"Line":0}},{"line":110,"address":[19093391,19093263],"length":1,"stats":{"Line":0}},{"line":111,"address":[18980647,18980579],"length":1,"stats":{"Line":0}},{"line":112,"address":[13234925],"length":1,"stats":{"Line":0}},{"line":116,"address":[18980137,18980201],"length":1,"stats":{"Line":0}},{"line":117,"address":[19061803],"length":1,"stats":{"Line":0}},{"line":119,"address":[11877874],"length":1,"stats":{"Line":0}},{"line":122,"address":[19055763,19055948,19056650,19056742,19056168,19055728,19055842,19055689],"length":1,"stats":{"Line":5}},{"line":123,"address":[19062797,19063128,19063583,19062984],"length":1,"stats":{"Line":1}},{"line":124,"address":[13236232],"length":1,"stats":{"Line":1}}],"covered":41,"coverable":59},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","join_request_store.rs"],"content":"use crate::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nconst JOIN_REQUEST_INDEX_PREFIX: &str = \"join_request_index_v1\";\nconst INVITE_USAGE_PREFIX: &str = \"invite_usage_v1\";\n\n#[derive(Debug, Serialize, Deserialize, Default)]\nstruct JoinRequestIndex {\n    version: u32,\n    event_ids: Vec<String>,\n}\n\npub struct SecureJoinRequestStore {\n    secure_storage: Arc<dyn SecureStorage>,\n}\n\nimpl SecureJoinRequestStore {\n    pub fn new(secure_storage: Arc<dyn SecureStorage>) -> Self {\n        Self { secure_storage }\n    }\n\n    fn index_key(owner_pubkey: &str) -> String {\n        format!(\"{JOIN_REQUEST_INDEX_PREFIX}:{owner_pubkey}\")\n    }\n\n    fn storage_key(owner_pubkey: &str, event_id: &str) -> String {\n        format!(\"join_request:{owner_pubkey}:{event_id}\")\n    }\n\n    fn invite_usage_key(owner_pubkey: &str, invite_event_id: &str) -> String {\n        format!(\"{INVITE_USAGE_PREFIX}:{owner_pubkey}:{invite_event_id}\")\n    }\n\n    async fn load_index(&self, owner_pubkey: &str) -> Result<JoinRequestIndex, AppError> {\n        let key = Self::index_key(owner_pubkey);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(JoinRequestIndex::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_index(\n        &self,\n        owner_pubkey: &str,\n        index: &JoinRequestIndex,\n    ) -> Result<(), AppError> {\n        let key = Self::index_key(owner_pubkey);\n        let json = serde_json::to_string(index)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl JoinRequestStore for SecureJoinRequestStore {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError> {\n        let key = Self::storage_key(owner_pubkey, &record.event.id);\n        let json = serde_json::to_string(&record)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n\n        let mut index = self.load_index(owner_pubkey).await?;\n        if !index.event_ids.iter().any(|id| id == &record.event.id) {\n            index.event_ids.push(record.event.id.clone());\n        }\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(owner_pubkey, &index).await?;\n        Ok(())\n    }\n\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let mut index = self.load_index(owner_pubkey).await?;\n        let mut records = Vec::with_capacity(index.event_ids.len());\n        let mut retained_ids = Vec::with_capacity(index.event_ids.len());\n\n        for event_id in index.event_ids.iter() {\n            let key = Self::storage_key(owner_pubkey, event_id);\n            if let Some(raw) = self.secure_storage.retrieve(&key).await? {\n                match serde_json::from_str::<JoinRequestRecord>(&raw) {\n                    Ok(record) => {\n                        retained_ids.push(event_id.clone());\n                        records.push(record);\n                    }\n                    Err(_) => {\n                        let _ = self.secure_storage.delete(&key).await;\n                    }\n                }\n            }\n        }\n\n        if retained_ids.len() != index.event_ids.len() {\n            index.event_ids = retained_ids;\n            if index.version == 0 {\n                index.version = 1;\n            }\n            self.save_index(owner_pubkey, &index).await?;\n        }\n\n        records.sort_by(|a, b| b.received_at.cmp(&a.received_at));\n        Ok(records)\n    }\n\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError> {\n        let key = Self::storage_key(owner_pubkey, event_id);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let record: JoinRequestRecord = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(record))\n    }\n\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n        let key = Self::storage_key(owner_pubkey, event_id);\n        let _ = self.secure_storage.delete(&key).await;\n\n        let mut index = self.load_index(owner_pubkey).await?;\n        index.event_ids.retain(|id| id != event_id);\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(owner_pubkey, &index).await?;\n        Ok(())\n    }\n\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError> {\n        let key = Self::invite_usage_key(owner_pubkey, invite_event_id);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let record: InviteUsageRecord = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(record))\n    }\n\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError> {\n        let key = Self::invite_usage_key(owner_pubkey, &record.invite_event_id);\n        let json = serde_json::to_string(&record)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::Event;\n    use crate::infrastructure::storage::secure_storage::DefaultSecureStorage;\n    use chrono::Utc;\n\n    #[tokio::test]\n    async fn store_and_load_join_request() {\n        let storage = Arc::new(DefaultSecureStorage::new());\n        let store = SecureJoinRequestStore::new(storage);\n\n        let event = Event {\n            id: \"event-1\".to_string(),\n            pubkey: \"pubkey-req\".to_string(),\n            created_at: Utc::now(),\n            kind: 39022,\n            tags: vec![],\n            content: \"{}\".to_string(),\n            sig: \"sig\".to_string(),\n        };\n        let record = JoinRequestRecord {\n            event: event.clone(),\n            topic_id: \"kukuri:topic1\".to_string(),\n            scope: \"friend\".to_string(),\n            requester_pubkey: \"pubkey-req\".to_string(),\n            target_pubkey: None,\n            requested_at: Some(100),\n            received_at: Utc::now().timestamp(),\n            invite_event_json: None,\n        };\n\n        store\n            .upsert_request(\"owner\", record.clone())\n            .await\n            .expect(\"store\");\n\n        let loaded = store.get_request(\"owner\", &event.id).await.expect(\"get\");\n        assert!(loaded.is_some());\n        assert_eq!(loaded.unwrap().event.id, event.id);\n\n        let list = store.list_requests(\"owner\").await.expect(\"list\");\n        assert_eq!(list.len(), 1);\n\n        store\n            .delete_request(\"owner\", &event.id)\n            .await\n            .expect(\"delete\");\n        let list = store.list_requests(\"owner\").await.expect(\"list empty\");\n        assert!(list.is_empty());\n    }\n\n    #[tokio::test]\n    async fn store_and_load_invite_usage() {\n        let storage = Arc::new(DefaultSecureStorage::new());\n        let store = SecureJoinRequestStore::new(storage);\n        let record = InviteUsageRecord {\n            invite_event_id: \"invite-1\".to_string(),\n            max_uses: 2,\n            used_count: 1,\n            last_used_at: Utc::now().timestamp(),\n        };\n\n        store\n            .upsert_invite_usage(\"owner\", record.clone())\n            .await\n            .expect(\"store\");\n\n        let loaded = store\n            .get_invite_usage(\"owner\", \"invite-1\")\n            .await\n            .expect(\"get\");\n        assert!(loaded.is_some());\n        assert_eq!(loaded.unwrap().used_count, 1);\n    }\n}\n","traces":[{"line":24,"address":[24766544],"length":1,"stats":{"Line":1}},{"line":28,"address":[24861360],"length":1,"stats":{"Line":1}},{"line":29,"address":[24662074],"length":1,"stats":{"Line":1}},{"line":32,"address":[19319456],"length":1,"stats":{"Line":1}},{"line":33,"address":[24861588],"length":1,"stats":{"Line":1}},{"line":36,"address":[24662448],"length":1,"stats":{"Line":1}},{"line":37,"address":[24648724],"length":1,"stats":{"Line":1}},{"line":40,"address":[24649504,24650280,24649214,24648944,24649174,24648962,24648992,24649036],"length":1,"stats":{"Line":4}},{"line":41,"address":[24761855],"length":1,"stats":{"Line":1}},{"line":42,"address":[11659108],"length":1,"stats":{"Line":2}},{"line":43,"address":[24657081],"length":1,"stats":{"Line":1}},{"line":45,"address":[24664176,24664194,24663898,24663805],"length":1,"stats":{"Line":2}},{"line":48,"address":[19321504],"length":1,"stats":{"Line":1}},{"line":53,"address":[24657604],"length":1,"stats":{"Line":1}},{"line":54,"address":[24763938,24763645,24764272,24763709],"length":1,"stats":{"Line":2}},{"line":55,"address":[24651186,24652112,24652130],"length":1,"stats":{"Line":0}},{"line":56,"address":[11577782],"length":1,"stats":{"Line":2}},{"line":57,"address":[24733429],"length":1,"stats":{"Line":1}},{"line":63,"address":[19600386],"length":1,"stats":{"Line":4}},{"line":68,"address":[24775329,24775480],"length":1,"stats":{"Line":2}},{"line":69,"address":[24768853,24768526,24768611,24769247],"length":1,"stats":{"Line":2}},{"line":70,"address":[24778450,24778432,24775781],"length":1,"stats":{"Line":0}},{"line":71,"address":[11825071],"length":1,"stats":{"Line":2}},{"line":73,"address":[11943382],"length":1,"stats":{"Line":2}},{"line":74,"address":[24844915,24845100,24846352,24846365],"length":1,"stats":{"Line":2}},{"line":75,"address":[24882035,24881963],"length":1,"stats":{"Line":2}},{"line":77,"address":[24880363],"length":1,"stats":{"Line":1}},{"line":78,"address":[19556055],"length":1,"stats":{"Line":1}},{"line":80,"address":[11941760],"length":1,"stats":{"Line":1}},{"line":81,"address":[24882502],"length":1,"stats":{"Line":1}},{"line":84,"address":[24882238,24881616,24883222,24881804,24881991,24881663,24881551,24886559],"length":1,"stats":{"Line":5}},{"line":85,"address":[24772253,24773361,24772414,24771978,24772786],"length":1,"stats":{"Line":1}},{"line":86,"address":[24765972,24766154],"length":1,"stats":{"Line":2}},{"line":87,"address":[24882839,24882937],"length":1,"stats":{"Line":2}},{"line":89,"address":[24841765,24840934,24841033,24841833],"length":1,"stats":{"Line":4}},{"line":90,"address":[19559401,19559913],"length":1,"stats":{"Line":2}},{"line":91,"address":[19597032],"length":1,"stats":{"Line":2}},{"line":92,"address":[24850194,24850123],"length":1,"stats":{"Line":2}},{"line":93,"address":[24885373],"length":1,"stats":{"Line":1}},{"line":94,"address":[24885543,24885418],"length":1,"stats":{"Line":2}},{"line":95,"address":[24982001],"length":1,"stats":{"Line":1}},{"line":98,"address":[24766628,24766939,24768821,24769082,24765236],"length":1,"stats":{"Line":0}},{"line":104,"address":[19021627,19021514,19023876],"length":1,"stats":{"Line":2}},{"line":105,"address":[24885701],"length":1,"stats":{"Line":0}},{"line":106,"address":[24767592],"length":1,"stats":{"Line":0}},{"line":107,"address":[24842198],"length":1,"stats":{"Line":0}},{"line":109,"address":[19597079],"length":1,"stats":{"Line":0}},{"line":112,"address":[24982750,24983152,24983184,24980443],"length":1,"stats":{"Line":2}},{"line":113,"address":[24776473],"length":1,"stats":{"Line":1}},{"line":116,"address":[24844981,24846508,24845105,24846558,24844879,24844832,24845521,24844771],"length":1,"stats":{"Line":5}},{"line":121,"address":[24845225],"length":1,"stats":{"Line":1}},{"line":122,"address":[19562720,19562993,19564011,19562817,19562467],"length":1,"stats":{"Line":2}},{"line":123,"address":[24884679],"length":1,"stats":{"Line":0}},{"line":125,"address":[24778351,24778617,24778258],"length":1,"stats":{"Line":2}},{"line":126,"address":[24888690,24888672,24888425],"length":1,"stats":{"Line":0}},{"line":127,"address":[24771739],"length":1,"stats":{"Line":1}},{"line":130,"address":[24846896,24846831,24847944,24847031,24846934,24849070,24847185,24847578],"length":1,"stats":{"Line":5}},{"line":131,"address":[24889338],"length":1,"stats":{"Line":1}},{"line":132,"address":[24885538,24885170,24885437,24885722],"length":1,"stats":{"Line":2}},{"line":134,"address":[11831525],"length":1,"stats":{"Line":1}},{"line":135,"address":[24773692,24774512,24774526],"length":1,"stats":{"Line":3}},{"line":136,"address":[24892152],"length":1,"stats":{"Line":1}},{"line":137,"address":[24848473],"length":1,"stats":{"Line":0}},{"line":139,"address":[19565965,19566239,19564486,19565819],"length":1,"stats":{"Line":1}},{"line":140,"address":[24887017],"length":1,"stats":{"Line":1}},{"line":143,"address":[24849527,24849406,24849925,24851025,24849292,24850975,24849248,24849187],"length":1,"stats":{"Line":5}},{"line":148,"address":[19029356],"length":1,"stats":{"Line":1}},{"line":149,"address":[11946756],"length":1,"stats":{"Line":2}},{"line":150,"address":[19030746],"length":1,"stats":{"Line":0}},{"line":152,"address":[24850476,24850892,24850569],"length":1,"stats":{"Line":2}},{"line":153,"address":[24783280,24783298,24783036],"length":1,"stats":{"Line":0}},{"line":154,"address":[19567977],"length":1,"stats":{"Line":1}},{"line":157,"address":[11952432],"length":1,"stats":{"Line":4}},{"line":162,"address":[19569180,19569045],"length":1,"stats":{"Line":2}},{"line":163,"address":[24859550,24858887,24858966,24859201],"length":1,"stats":{"Line":2}},{"line":164,"address":[24895424,24895442,24894273],"length":1,"stats":{"Line":0}},{"line":165,"address":[24991486,24990047,24991162,24990675,24990867],"length":1,"stats":{"Line":2}},{"line":166,"address":[24891084],"length":1,"stats":{"Line":1}}],"covered":65,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","mod.rs"],"content":"pub mod cache_storage;\npub mod file_storage;\npub mod group_key_store;\npub mod join_request_store;\npub mod profile_avatar_store;\npub mod secure_storage;\n\npub use group_key_store::SecureGroupKeyStore;\npub use join_request_store::SecureJoinRequestStore;\npub use secure_storage::SecureStorage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","profile_avatar_store.rs"],"content":"use std::{\n    collections::HashMap,\n    path::{Path, PathBuf},\n};\n\nuse serde::{Deserialize, Serialize};\nuse tokio::{fs, sync::Mutex};\n\nuse crate::{domain::entities::ProfileAvatarDocEntry, shared::AppError};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ProfileAvatarDocument {\n    next_version: u64,\n    entries: HashMap<String, ProfileAvatarDocEntry>,\n}\n\nimpl Default for ProfileAvatarDocument {\n    fn default() -> Self {\n        Self {\n            next_version: 1,\n            entries: HashMap::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileAvatarSyncPackage {\n    pub entry: ProfileAvatarDocEntry,\n    pub encrypted_blob: Vec<u8>,\n}\n\npub struct ProfileAvatarStore {\n    root_dir: PathBuf,\n    blobs_dir: PathBuf,\n    doc_path: PathBuf,\n    document: Mutex<ProfileAvatarDocument>,\n}\n\nimpl ProfileAvatarStore {\n    pub async fn new(root_dir: PathBuf) -> Result<Self, AppError> {\n        fs::create_dir_all(&root_dir).await.map_err(|err| {\n            AppError::Storage(format!(\"Failed to create profile avatar dir: {err}\"))\n        })?;\n\n        let blobs_dir = root_dir.join(\"blobs\");\n        fs::create_dir_all(&blobs_dir)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to create blobs dir: {err}\")))?;\n\n        let doc_path = root_dir.join(\"doc.json\");\n        let document = if fs::metadata(&doc_path).await.is_ok() {\n            let bytes = fs::read(&doc_path)\n                .await\n                .map_err(|err| AppError::Storage(format!(\"Failed to read avatar doc: {err}\")))?;\n            if bytes.is_empty() {\n                ProfileAvatarDocument::default()\n            } else {\n                serde_json::from_slice(&bytes).map_err(|err| {\n                    AppError::DeserializationError(format!(\"Failed to parse avatar doc: {err}\"))\n                })?\n            }\n        } else {\n            ProfileAvatarDocument::default()\n        };\n\n        Ok(Self {\n            root_dir,\n            blobs_dir,\n            doc_path,\n            document: Mutex::new(document),\n        })\n    }\n\n    pub fn root_dir(&self) -> &Path {\n        &self.root_dir\n    }\n\n    pub async fn write_encrypted_blob(\n        &self,\n        blob_hash: &str,\n        data: &[u8],\n    ) -> Result<PathBuf, AppError> {\n        let path = self.blobs_dir.join(blob_hash);\n        fs::write(&path, data)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to write encrypted blob: {err}\")))?;\n        Ok(path)\n    }\n\n    pub async fn read_encrypted_blob(&self, blob_hash: &str) -> Result<Vec<u8>, AppError> {\n        let path = self.blobs_dir.join(blob_hash);\n        fs::read(&path)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to read encrypted blob: {err}\")))\n    }\n\n    pub async fn encrypted_blob_exists(&self, blob_hash: &str) -> bool {\n        fs::metadata(self.blobs_dir.join(blob_hash)).await.is_ok()\n    }\n\n    pub async fn upsert_entry(\n        &self,\n        mut entry: ProfileAvatarDocEntry,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        let mut document = self.document.lock().await;\n        let version = document.next_version;\n        document.next_version += 1;\n        entry.version = version;\n        document.entries.insert(entry.npub.clone(), entry.clone());\n        self.persist(&document).await?;\n        Ok(entry)\n    }\n\n    pub async fn get_entry(&self, npub: &str) -> Result<Option<ProfileAvatarDocEntry>, AppError> {\n        let document = self.document.lock().await;\n        Ok(document.entries.get(npub).cloned())\n    }\n\n    pub async fn export_sync_package(\n        &self,\n        npub: &str,\n    ) -> Result<Option<ProfileAvatarSyncPackage>, AppError> {\n        let entry = {\n            let document = self.document.lock().await;\n            match document.entries.get(npub) {\n                Some(entry) => entry.clone(),\n                None => return Ok(None),\n            }\n        };\n        let blob = self.read_encrypted_blob(&entry.blob_hash).await?;\n        Ok(Some(ProfileAvatarSyncPackage {\n            entry,\n            encrypted_blob: blob,\n        }))\n    }\n\n    pub async fn import_sync_package(\n        &self,\n        package: ProfileAvatarSyncPackage,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        let ProfileAvatarSyncPackage {\n            entry,\n            encrypted_blob,\n        } = package;\n\n        // 既存エントリのバージョンより新しい場合のみ更新\n        let mut document = self.document.lock().await;\n        let should_update = match document.entries.get(&entry.npub) {\n            Some(current) => entry.version > current.version,\n            None => true,\n        };\n\n        if !should_update {\n            return Ok(document\n                .entries\n                .get(&entry.npub)\n                .cloned()\n                .expect(\"entry must exist\"));\n        }\n\n        self.write_encrypted_blob(&entry.blob_hash, &encrypted_blob)\n            .await?;\n        document.entries.insert(entry.npub.clone(), entry.clone());\n        document.next_version = document.next_version.max(entry.version + 1);\n        self.persist(&document).await?;\n        Ok(entry)\n    }\n\n    pub async fn entries_snapshot(&self) -> Vec<ProfileAvatarDocEntry> {\n        let document = self.document.lock().await;\n        document.entries.values().cloned().collect()\n    }\n\n    async fn persist(&self, document: &ProfileAvatarDocument) -> Result<(), AppError> {\n        let json = serde_json::to_vec_pretty(document).map_err(|err| {\n            AppError::SerializationError(format!(\"Failed to serialize avatar doc: {err}\"))\n        })?;\n        fs::write(&self.doc_path, json)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to persist avatar doc: {err}\")))\n    }\n}\n","traces":[{"line":18,"address":[13986992],"length":1,"stats":{"Line":2}},{"line":21,"address":[19739486],"length":1,"stats":{"Line":2}},{"line":40,"address":[19945856,19947056,19945827,19946309,19949808,19945903,19945824,19946070],"length":1,"stats":{"Line":8}},{"line":41,"address":[19815476,19814789,19814548,19814484,19818400,19814669,19815178,19818631],"length":1,"stats":{"Line":6}},{"line":42,"address":[19743751,19743686],"length":1,"stats":{"Line":0}},{"line":45,"address":[12980666,12980831],"length":1,"stats":{"Line":4}},{"line":46,"address":[19850998,19850435,19850538,19851293,19850752,19850850],"length":1,"stats":{"Line":8}},{"line":47,"address":[19734133,19733049,19733993,19733928,19733871],"length":1,"stats":{"Line":8}},{"line":48,"address":[19950208,19950230,19947382],"length":1,"stats":{"Line":0}},{"line":50,"address":[19748041,19748204],"length":1,"stats":{"Line":4}},{"line":51,"address":[11653959],"length":1,"stats":{"Line":6}},{"line":52,"address":[19811277,19810124,19809951,19810445,19810228,19809893],"length":1,"stats":{"Line":0}},{"line":53,"address":[11653982],"length":1,"stats":{"Line":0}},{"line":54,"address":[19854054,19852445,19854032],"length":1,"stats":{"Line":0}},{"line":55,"address":[13990083,13990242,13990461],"length":1,"stats":{"Line":0}},{"line":56,"address":[19949044,19949380],"length":1,"stats":{"Line":0}},{"line":58,"address":[13990307,13990248,13990511,13992183,13991952],"length":1,"stats":{"Line":0}},{"line":59,"address":[19819190,19819255],"length":1,"stats":{"Line":0}},{"line":63,"address":[12982079],"length":1,"stats":{"Line":2}},{"line":66,"address":[19949426],"length":1,"stats":{"Line":2}},{"line":67,"address":[19948140],"length":1,"stats":{"Line":2}},{"line":68,"address":[19853400],"length":1,"stats":{"Line":2}},{"line":69,"address":[13989460],"length":1,"stats":{"Line":2}},{"line":70,"address":[19816720],"length":1,"stats":{"Line":2}},{"line":74,"address":[19819424],"length":1,"stats":{"Line":0}},{"line":75,"address":[19950981],"length":1,"stats":{"Line":0}},{"line":78,"address":[19850624],"length":1,"stats":{"Line":2}},{"line":83,"address":[19751926,19752054],"length":1,"stats":{"Line":4}},{"line":84,"address":[19851028,19851407,19851128,19851328,19851625],"length":1,"stats":{"Line":8}},{"line":85,"address":[19388953],"length":1,"stats":{"Line":8}},{"line":86,"address":[19739040,19738873,19739062],"length":1,"stats":{"Line":0}},{"line":87,"address":[19745558],"length":1,"stats":{"Line":2}},{"line":90,"address":[19852209,19852083,19852797,19852048,19852249,19852018,19852000,19852479],"length":1,"stats":{"Line":8}},{"line":91,"address":[19821129,19821004],"length":1,"stats":{"Line":4}},{"line":92,"address":[13994030,13994305,13993933,13994223],"length":1,"stats":{"Line":8}},{"line":93,"address":[11608068],"length":1,"stats":{"Line":8}},{"line":94,"address":[19856752,19856774],"length":1,"stats":{"Line":0}},{"line":97,"address":[19857792,19857056,19857207,19857026,19857008,19857247,19857081,19857436],"length":1,"stats":{"Line":0}},{"line":98,"address":[19822191,19822066,19822348,19822114],"length":1,"stats":{"Line":0}},{"line":101,"address":[19822688],"length":1,"stats":{"Line":2}},{"line":105,"address":[19741440,19741505,19741581,19741704],"length":1,"stats":{"Line":4}},{"line":106,"address":[19823449,19823536],"length":1,"stats":{"Line":4}},{"line":107,"address":[19755912,19755793],"length":1,"stats":{"Line":2}},{"line":108,"address":[19748890],"length":1,"stats":{"Line":2}},{"line":109,"address":[19756315,19755881,19755932],"length":1,"stats":{"Line":4}},{"line":110,"address":[19742392,19741520,19742586,19742982],"length":1,"stats":{"Line":3}},{"line":111,"address":[19855570],"length":1,"stats":{"Line":2}},{"line":114,"address":[19757074,19757289,19757853,19757056,19757104,19757139,19757409,19757252],"length":1,"stats":{"Line":8}},{"line":115,"address":[19338343],"length":1,"stats":{"Line":4}},{"line":116,"address":[13998185,13998252],"length":1,"stats":{"Line":4}},{"line":119,"address":[12990848],"length":1,"stats":{"Line":1}},{"line":124,"address":[19857113,19857218,19857041,19856982],"length":1,"stats":{"Line":2}},{"line":125,"address":[19751495,19751562],"length":1,"stats":{"Line":2}},{"line":126,"address":[19957985],"length":1,"stats":{"Line":1}},{"line":127,"address":[19744859],"length":1,"stats":{"Line":0}},{"line":130,"address":[11681986],"length":1,"stats":{"Line":3}},{"line":131,"address":[19759321],"length":1,"stats":{"Line":1}},{"line":132,"address":[19759291],"length":1,"stats":{"Line":1}},{"line":137,"address":[19864096],"length":1,"stats":{"Line":1}},{"line":142,"address":[19820699],"length":1,"stats":{"Line":1}},{"line":143,"address":[19746144],"length":1,"stats":{"Line":1}},{"line":147,"address":[11689132],"length":1,"stats":{"Line":2}},{"line":148,"address":[19865013,19865106],"length":1,"stats":{"Line":2}},{"line":149,"address":[14001211],"length":1,"stats":{"Line":0}},{"line":150,"address":[19828417],"length":1,"stats":{"Line":1}},{"line":153,"address":[19760717],"length":1,"stats":{"Line":1}},{"line":154,"address":[19863720,19863607],"length":1,"stats":{"Line":0}},{"line":156,"address":[12993681],"length":1,"stats":{"Line":0}},{"line":161,"address":[19822274,19823095,19821593,19821845,19821967,19822457,19822148],"length":1,"stats":{"Line":5}},{"line":162,"address":[19746274,19747348,19747448,19747604,19747408,19747798],"length":1,"stats":{"Line":5}},{"line":163,"address":[19822494,19823073],"length":1,"stats":{"Line":1}},{"line":164,"address":[19864793],"length":1,"stats":{"Line":1}},{"line":165,"address":[19961984,19962215,19961580,19961390,19959367],"length":1,"stats":{"Line":2}},{"line":166,"address":[19961866],"length":1,"stats":{"Line":1}},{"line":169,"address":[12996016,12995824,12995832,12996128,12996543,12995979,12995856,12995891],"length":1,"stats":{"Line":0}},{"line":170,"address":[11001815],"length":1,"stats":{"Line":0}},{"line":171,"address":[19862629,19862564],"length":1,"stats":{"Line":0}},{"line":174,"address":[19763939,19764640,19763904,19764893,19763869,19763856,19764120,19764068],"length":1,"stats":{"Line":8}},{"line":175,"address":[19832919,19832187,19831809,19832688,19831927],"length":1,"stats":{"Line":4}},{"line":176,"address":[19825782,19825847],"length":1,"stats":{"Line":0}},{"line":178,"address":[19867664,19867413,19867196,19867737],"length":1,"stats":{"Line":8}},{"line":179,"address":[19963984,19963818,19963868,19964116,19963407],"length":1,"stats":{"Line":8}},{"line":180,"address":[19869734,19869712],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":83},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","secure_storage.rs"],"content":"use crate::application::ports::{\n    key_manager::{KeyMaterialStore, KeyPair},\n    secure_storage::SecureAccountStore,\n};\nuse crate::domain::entities::{\n    AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret,\n};\nuse crate::domain::value_objects::keychain::{KeyMaterialLedger, KeyMaterialRecord};\nuse crate::shared::error::AppError;\nuse anyhow::{Context, Result, anyhow};\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse keyring::Entry;\nuse nostr_sdk::{\n    FromBech32,\n    prelude::{Keys, PublicKey, SecretKey},\n};\nuse once_cell::sync::Lazy;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::sync::Mutex;\nuse tracing::{debug, error, warn};\n\nconst SERVICE_NAME: &str = \"kukuri\";\nconst ACCOUNTS_KEY: &str = \"accounts_metadata\";\nconst KEY_MANAGER_LEDGER_KEY: &str = \"key_manager_ledger\";\n\nstatic FALLBACK_STORE: Lazy<Mutex<HashMap<String, String>>> =\n    Lazy::new(|| Mutex::new(HashMap::new()));\n\nfn fallback_store(key: &str, value: &str) -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.insert(key.to_string(), value.to_string());\n    Ok(())\n}\n\nfn fallback_get(key: &str) -> Option<String> {\n    FALLBACK_STORE\n        .lock()\n        .ok()\n        .and_then(|guard| guard.get(key).cloned())\n}\n\nfn fallback_delete(key: &str) -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.remove(key);\n    Ok(())\n}\n\nfn fallback_has(key: &str) -> bool {\n    FALLBACK_STORE\n        .lock()\n        .ok()\n        .map(|guard| guard.contains_key(key))\n        .unwrap_or(false)\n}\n\nfn fallback_clear() -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.clear();\n    Ok(())\n}\n\nfn store_with_fallback(key: &str, value: &str) -> Result<()> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => {\n            if let Err(err) = entry.set_password(value) {\n                warn!(\n                    \"SecureStorage: keyring set_password failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        }\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    fallback_store(key, value)\n}\n\nfn retrieve_with_fallback(key: &str) -> Result<Option<String>> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.get_password() {\n            Ok(password) => {\n                let _ = fallback_store(key, &password);\n                return Ok(Some(password));\n            }\n            Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring get_password failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    Ok(fallback_get(key))\n}\n\nfn delete_with_fallback(key: &str) -> Result<()> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.delete_credential() {\n            Ok(()) | Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring delete failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    fallback_delete(key)\n}\n\nfn exists_with_fallback(key: &str) -> Result<bool> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.get_password() {\n            Ok(_) => return Ok(true),\n            Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring exists check failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    Ok(fallback_has(key))\n}\n\n#[derive(Debug)]\nstruct SecureStorageError(String);\n\nimpl fmt::Display for SecureStorageError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::error::Error for SecureStorageError {}\n\nfn boxed_error(e: anyhow::Error) -> Box<dyn std::error::Error + Send + Sync + 'static> {\n    Box::new(SecureStorageError(e.to_string()))\n}\n\n/// Secure storage trait used by the app and Tauri bridge.\n#[async_trait]\npub trait SecureStorage: Send + Sync {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n}\n\n/// Default SecureStorage implementation backed by keyring with in-memory fallback.\npub struct DefaultSecureStorage;\n\nimpl DefaultSecureStorage {\n    pub fn new() -> Self {\n        Self\n    }\n\n    /// Save private key by npub.\n    pub fn save_private_key(npub: &str, nsec: &str) -> Result<()> {\n        debug!(\"SecureStorage: Saving private key for npub={npub}\");\n        store_with_fallback(npub, nsec)\n    }\n\n    /// Get private key by npub.\n    pub fn get_private_key(npub: &str) -> Result<Option<String>> {\n        retrieve_with_fallback(npub)\n    }\n\n    /// Delete private key by npub.\n    pub fn delete_private_key(npub: &str) -> Result<()> {\n        delete_with_fallback(npub)\n    }\n\n    /// Save accounts metadata (includes current npub).\n    pub fn save_accounts_metadata(metadata: &AccountsMetadata) -> Result<()> {\n        let json =\n            serde_json::to_string(metadata).context(\"Failed to serialize accounts metadata\")?;\n        debug!(\"SecureStorage: Saving metadata JSON: {json}\");\n        store_with_fallback(ACCOUNTS_KEY, &json)?;\n\n        // Read-back check to ensure fallback has the latest value.\n        match retrieve_with_fallback(ACCOUNTS_KEY) {\n            Ok(Some(test_json)) => {\n                debug!(\n                    \"SecureStorage: Immediate read test succeeded, data length: {}\",\n                    test_json.len()\n                );\n            }\n            Ok(None) => {\n                warn!(\"SecureStorage: Metadata read-after-write returned empty result\");\n            }\n            Err(err) => {\n                error!(\"SecureStorage: Immediate metadata read failed: {err:?}\");\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Fetch accounts metadata or default.\n    pub fn get_accounts_metadata() -> Result<AccountsMetadata> {\n        debug!(\"SecureStorage: Getting accounts metadata...\");\n        match retrieve_with_fallback(ACCOUNTS_KEY) {\n            Ok(Some(json)) => {\n                debug!(\"SecureStorage: Retrieved metadata JSON: {json}\");\n                let metadata: AccountsMetadata = serde_json::from_str(&json)\n                    .context(\"Failed to deserialize accounts metadata\")?;\n                debug!(\n                    \"SecureStorage: Deserialized metadata - current_npub: {:?}, accounts: {}\",\n                    metadata.current_npub,\n                    metadata.accounts.len()\n                );\n                Ok(metadata)\n            }\n            Ok(None) => {\n                debug!(\"SecureStorage: No metadata entry found, returning default\");\n                Ok(AccountsMetadata::default())\n            }\n            Err(err) => {\n                error!(\"SecureStorage: Failed to get metadata: {err:?}\");\n                Err(err)\n            }\n        }\n    }\n\n    fn get_key_material_ledger() -> Result<KeyMaterialLedger> {\n        match retrieve_with_fallback(KEY_MANAGER_LEDGER_KEY) {\n            Ok(Some(json)) => {\n                debug!(\"SecureStorage: Retrieved key ledger JSON\");\n                serde_json::from_str(&json).context(\"Failed to deserialize key material ledger\")\n            }\n            Ok(None) => Ok(KeyMaterialLedger::default()),\n            Err(err) => Err(err),\n        }\n    }\n\n    fn save_key_material_ledger(ledger: &KeyMaterialLedger) -> Result<()> {\n        let json = serde_json::to_string(ledger).context(\"Failed to serialize key ledger\")?;\n        store_with_fallback(KEY_MANAGER_LEDGER_KEY, &json)\n    }\n}\n\nimpl Default for DefaultSecureStorage {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SecureStorage for DefaultSecureStorage {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        store_with_fallback(key, value).map_err(boxed_error)\n    }\n\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n        retrieve_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        delete_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        exists_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n        // keyring does not support listing; derive from stored metadata.\n        let metadata = Self::get_accounts_metadata().map_err(boxed_error)?;\n        Ok(metadata.accounts.keys().cloned().collect())\n    }\n\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // Remove all stored keys and metadata.\n        let metadata = Self::get_accounts_metadata().map_err(boxed_error)?;\n        for npub in metadata.accounts.keys() {\n            Self::delete_private_key(npub).map_err(boxed_error)?;\n        }\n        Self::save_accounts_metadata(&AccountsMetadata::default()).map_err(boxed_error)?;\n        delete_with_fallback(KEY_MANAGER_LEDGER_KEY).map_err(boxed_error)?;\n        fallback_clear().map_err(boxed_error)?;\n        Ok(())\n    }\n}\n\nfn to_storage_error(err: anyhow::Error) -> AppError {\n    AppError::Storage(err.to_string())\n}\n\nfn build_keypair_from_record(\n    record: &KeyMaterialRecord,\n    nsec: String,\n) -> Result<KeyPair, AppError> {\n    let secret_key = SecretKey::from_bech32(&nsec)\n        .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e}\")))?;\n    Ok(KeyPair {\n        public_key: record.public_key.clone(),\n        private_key: secret_key.display_secret().to_string(),\n        npub: record.npub.clone(),\n        nsec,\n    })\n}\n\n#[async_trait]\nimpl SecureAccountStore for DefaultSecureStorage {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError> {\n        let (mut metadata, nsec) = registration.into_metadata();\n        debug!(\"SecureStorage: Adding account npub={}\", metadata.npub);\n\n        Self::save_private_key(&metadata.npub, &nsec).map_err(to_storage_error)?;\n\n        let mut accounts = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.mark_used(Utc::now());\n        accounts\n            .accounts\n            .insert(metadata.npub.clone(), metadata.clone());\n        accounts.current_npub = Some(metadata.npub.clone());\n        Self::save_accounts_metadata(&accounts).map_err(to_storage_error)?;\n        {\n            let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n            let entry = ledger\n                .records\n                .entry(metadata.npub.clone())\n                .or_insert_with(|| {\n                    KeyMaterialRecord::new(metadata.npub.clone(), metadata.pubkey.clone())\n                });\n            entry.public_key = metadata.pubkey.clone();\n            entry.touch();\n            ledger.touch_current(&metadata.npub);\n            Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n        }\n\n        Ok(metadata)\n    }\n\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let mut accounts: Vec<AccountMetadata> = metadata.accounts.values().cloned().collect();\n        accounts.sort_by(|a, b| b.last_used.cmp(&a.last_used));\n        Ok(accounts)\n    }\n\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError> {\n        Self::delete_private_key(npub).map_err(to_storage_error)?;\n\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.accounts.remove(npub);\n        if metadata.current_npub.as_deref() == Some(npub) {\n            metadata.current_npub = metadata.accounts.keys().next().cloned();\n        }\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.remove(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n\n        Ok(())\n    }\n\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError> {\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let account = metadata\n            .accounts\n            .get_mut(npub)\n            .ok_or_else(|| AppError::NotFound(format!(\"Account not found: {npub}\")))?;\n        account.mark_used(Utc::now());\n        let updated = account.clone();\n        metadata.current_npub = Some(npub.to_string());\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.touch_current(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n\n        Ok(updated)\n    }\n\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError> {\n        Self::get_private_key(npub).map_err(to_storage_error)\n    }\n\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        if let Some(current) = metadata.current_npub.as_ref() {\n            if let Some(account) = metadata.accounts.get(current) {\n                if let Some(nsec) = Self::get_private_key(current).map_err(to_storage_error)? {\n                    return Ok(Some(CurrentAccountSecret {\n                        metadata: account.clone(),\n                        nsec,\n                    }));\n                }\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[async_trait]\nimpl KeyMaterialStore for DefaultSecureStorage {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        Self::save_private_key(&keypair.npub, &keypair.nsec).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        let entry = ledger\n            .records\n            .entry(keypair.npub.clone())\n            .or_insert_with(|| {\n                KeyMaterialRecord::new(keypair.npub.clone(), keypair.public_key.clone())\n            });\n        entry.public_key = keypair.public_key.clone();\n        entry.touch();\n        ledger.touch_current(&keypair.npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.remove(npub);\n        Self::delete_private_key(npub).map_err(to_storage_error)?;\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        match ledger.records.get(npub) {\n            Some(record) => {\n                let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n                if let Some(nsec) = nsec {\n                    build_keypair_from_record(record, nsec)\n                } else {\n                    Err(AppError::NotFound(format!(\n                        \"Private key not found for {}\",\n                        record.npub\n                    )))\n                }\n                .map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        let mut pairs = Vec::with_capacity(ledger.records.len());\n        for record in ledger.records.values() {\n            let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n            if let Some(nsec) = nsec {\n                pairs.push(build_keypair_from_record(record, nsec)?);\n            }\n        }\n        Ok(pairs)\n    }\n\n    async fn set_current(&self, npub: &str) -> Result<(), AppError> {\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        if !ledger.records.contains_key(npub) {\n            let public_key = match Self::get_private_key(npub).map_err(to_storage_error)? {\n                Some(nsec) => {\n                    let secret_key = SecretKey::from_bech32(&nsec).map_err(|e| {\n                        AppError::Crypto(format!(\"Invalid nsec stored for npub {npub}: {e:?}\"))\n                    })?;\n                    Keys::new(secret_key).public_key()\n                }\n                None => PublicKey::from_bech32(npub).map_err(|e| {\n                    AppError::Crypto(format!(\"Failed to decode npub {npub}: {e:?}\"))\n                })?,\n            };\n            let public_key_hex = public_key.to_hex();\n            ledger.upsert(KeyMaterialRecord::new(npub.to_string(), public_key_hex));\n        }\n        ledger.touch_current(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        if let Some(npub) = ledger.current_npub.as_deref() {\n            if let Some(record) = ledger.records.get(npub) {\n                let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n                if let Some(nsec) = nsec {\n                    return build_keypair_from_record(record, nsec).map(Some);\n                }\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[cfg(all(test, target_os = \"windows\"))]\nmod tests {\n    use super::*;\n    use crate::application::ports::secure_storage::SecureAccountStore;\n    use crate::domain::entities::AccountRegistration;\n\n    #[tokio::test]\n    async fn test_secure_storage_store_retrieve() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let result = storage.store(\"test_key\", \"test_value\").await;\n        assert!(result.is_ok());\n\n        // Retrieve the value\n        let result = storage.retrieve(\"test_key\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Some(\"test_value\".to_string()));\n\n        // Clean up\n        let _ = storage.delete(\"test_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_delete() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let _ = storage.store(\"test_delete_key\", \"test_value\").await;\n\n        // Delete it\n        let result = storage.delete(\"test_delete_key\").await;\n        assert!(result.is_ok());\n\n        // Verify it's deleted\n        let result = storage.retrieve(\"test_delete_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n\n        // Clean up\n        let _ = storage.delete(\"test_delete_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_exists() {\n        let storage = DefaultSecureStorage::new();\n\n        // Check non-existent key\n        let result = storage.exists(\"non_existent_key\").await;\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n\n        // Store a value\n        let _ = storage.store(\"test_exists_key\", \"test_value\").await;\n\n        // Check it exists\n        let result = storage.exists(\"test_exists_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n\n        // Clean up\n        let _ = storage.delete(\"test_exists_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_add_account() {\n        let storage = DefaultSecureStorage::new();\n        let registration = AccountRegistration {\n            npub: \"npub1test\".to_string(),\n            nsec: \"nsec1test\".to_string(),\n            pubkey: \"pubkey_test\".to_string(),\n            name: \"test_user\".to_string(),\n            display_name: \"Test User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let result = SecureAccountStore::add_account(&storage, registration).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_list_accounts() {\n        let storage = DefaultSecureStorage::new();\n        // Add an account\n        let registration = AccountRegistration {\n            npub: \"npub1list\".to_string(),\n            nsec: \"nsec1list\".to_string(),\n            pubkey: \"pubkey_list\".to_string(),\n            name: \"list_user\".to_string(),\n            display_name: \"List User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let _ = SecureAccountStore::add_account(&storage, registration).await;\n\n        let result = SecureAccountStore::list_accounts(&storage).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n        let accounts = result.unwrap();\n        assert!(accounts.iter().any(|a| a.npub == \"npub1list\"));\n    }\n}\n","traces":[{"line":29,"address":[22200288,22200306],"length":1,"stats":{"Line":2}},{"line":31,"address":[22187107,22186592],"length":1,"stats":{"Line":1}},{"line":32,"address":[22303449,22303291],"length":1,"stats":{"Line":1}},{"line":34,"address":[22400208,22400226,22399868],"length":1,"stats":{"Line":0}},{"line":35,"address":[22193559,22193869,22193667],"length":1,"stats":{"Line":2}},{"line":36,"address":[22299756],"length":1,"stats":{"Line":1}},{"line":39,"address":[22300000],"length":1,"stats":{"Line":2}},{"line":40,"address":[22268849],"length":1,"stats":{"Line":1}},{"line":43,"address":[22305734,22305696],"length":1,"stats":{"Line":2}},{"line":46,"address":[26562269,26561968],"length":1,"stats":{"Line":1}},{"line":47,"address":[26562001,26562142],"length":1,"stats":{"Line":1}},{"line":49,"address":[16442256,16442073,16442274],"length":1,"stats":{"Line":0}},{"line":50,"address":[22194533,22194638],"length":1,"stats":{"Line":2}},{"line":51,"address":[22300590],"length":1,"stats":{"Line":1}},{"line":54,"address":[22262704],"length":1,"stats":{"Line":0}},{"line":55,"address":[16442439],"length":1,"stats":{"Line":0}},{"line":58,"address":[22262816,22262843],"length":1,"stats":{"Line":0}},{"line":62,"address":[22301088,22301340],"length":1,"stats":{"Line":0}},{"line":63,"address":[22195175,22195319],"length":1,"stats":{"Line":0}},{"line":65,"address":[22306810,22306944,22306962],"length":1,"stats":{"Line":0}},{"line":66,"address":[22401573,22401664],"length":1,"stats":{"Line":0}},{"line":67,"address":[26562922],"length":1,"stats":{"Line":0}},{"line":70,"address":[22191036,22188816,22190982],"length":1,"stats":{"Line":2}},{"line":71,"address":[22203432,22202631],"length":1,"stats":{"Line":2}},{"line":72,"address":[22263556],"length":1,"stats":{"Line":1}},{"line":73,"address":[22402218,22402068],"length":1,"stats":{"Line":2}},{"line":74,"address":[22306450,22305869,22432521,22432655,22305970,22306314],"length":1,"stats":{"Line":0}},{"line":80,"address":[26563346],"length":1,"stats":{"Line":0}},{"line":81,"address":[22309385,22434799,22307359,22309860,22434665],"length":1,"stats":{"Line":0}},{"line":87,"address":[22191007],"length":1,"stats":{"Line":1}},{"line":90,"address":[22199424,22200188,22202142],"length":1,"stats":{"Line":2}},{"line":91,"address":[22405751],"length":1,"stats":{"Line":2}},{"line":92,"address":[16447068,16447250,16447356],"length":1,"stats":{"Line":5}},{"line":93,"address":[22267581],"length":1,"stats":{"Line":0}},{"line":94,"address":[22199813,22199945],"length":1,"stats":{"Line":0}},{"line":95,"address":[16447539],"length":1,"stats":{"Line":0}},{"line":98,"address":[22193457],"length":1,"stats":{"Line":0}},{"line":99,"address":[22312360,22311880,22435161,22311801,22435295],"length":1,"stats":{"Line":0}},{"line":105,"address":[22192823],"length":1,"stats":{"Line":0}},{"line":106,"address":[26791407,26571996,26571797,26791273,26572391,26571464],"length":1,"stats":{"Line":0}},{"line":112,"address":[22195281],"length":1,"stats":{"Line":1}},{"line":115,"address":[22273822,22271552],"length":1,"stats":{"Line":1}},{"line":116,"address":[22313623],"length":1,"stats":{"Line":1}},{"line":117,"address":[22211097,22210828,22211010],"length":1,"stats":{"Line":3}},{"line":119,"address":[22271969],"length":1,"stats":{"Line":0}},{"line":120,"address":[22399385,22399519,22278953,22279512,22279032],"length":1,"stats":{"Line":0}},{"line":126,"address":[22313767],"length":1,"stats":{"Line":0}},{"line":127,"address":[22203959,22206559,22206084,22325279,22325145],"length":1,"stats":{"Line":0}},{"line":133,"address":[22205985],"length":1,"stats":{"Line":1}},{"line":136,"address":[22210165,22210134,22207632],"length":1,"stats":{"Line":0}},{"line":137,"address":[22317527],"length":1,"stats":{"Line":0}},{"line":138,"address":[22319260,22319442,22319537],"length":1,"stats":{"Line":0}},{"line":139,"address":[22275797],"length":1,"stats":{"Line":0}},{"line":141,"address":[22319682],"length":1,"stats":{"Line":0}},{"line":142,"address":[22283529,22282970,22283049,22400377,22400511],"length":1,"stats":{"Line":0}},{"line":148,"address":[16455335],"length":1,"stats":{"Line":0}},{"line":149,"address":[22317719,22320557,22436127,22320082,22435993],"length":1,"stats":{"Line":0}},{"line":155,"address":[22319945],"length":1,"stats":{"Line":0}},{"line":162,"address":[22418064],"length":1,"stats":{"Line":0}},{"line":163,"address":[22286536],"length":1,"stats":{"Line":0}},{"line":169,"address":[22211888,22212133],"length":1,"stats":{"Line":0}},{"line":170,"address":[22286633,22286709],"length":1,"stats":{"Line":0}},{"line":200,"address":[22418464,22418976],"length":1,"stats":{"Line":0}},{"line":201,"address":[22318736,22318610,22318139,22432633,22432767],"length":1,"stats":{"Line":0}},{"line":202,"address":[16460313],"length":1,"stats":{"Line":0}},{"line":206,"address":[22213392],"length":1,"stats":{"Line":0}},{"line":207,"address":[22220389],"length":1,"stats":{"Line":0}},{"line":211,"address":[22206656],"length":1,"stats":{"Line":0}},{"line":212,"address":[22220430],"length":1,"stats":{"Line":0}},{"line":216,"address":[22328774,22323328,22330362],"length":1,"stats":{"Line":0}},{"line":217,"address":[22220466,22220663],"length":1,"stats":{"Line":0}},{"line":219,"address":[22281588,22395017,22395151,22281467,22282080],"length":1,"stats":{"Line":0}},{"line":220,"address":[22325750,22326862,22326988,22331986],"length":1,"stats":{"Line":0}},{"line":223,"address":[22283265,22283337],"length":1,"stats":{"Line":0}},{"line":224,"address":[22215676],"length":1,"stats":{"Line":0}},{"line":225,"address":[22324570,22324272],"length":1,"stats":{"Line":0}},{"line":231,"address":[26795321,26795455,26589555,26589356,26589975,26589023],"length":1,"stats":{"Line":0}},{"line":233,"address":[22321521],"length":1,"stats":{"Line":0}},{"line":234,"address":[22286786,22396505,22396639,22283425,22287264],"length":1,"stats":{"Line":0}},{"line":238,"address":[22220432],"length":1,"stats":{"Line":0}},{"line":242,"address":[22301669,22295264,22301591],"length":1,"stats":{"Line":0}},{"line":243,"address":[26595749,26595277,26595583,26596302,26796313,26796447],"length":1,"stats":{"Line":0}},{"line":244,"address":[22214934,22214317],"length":1,"stats":{"Line":0}},{"line":245,"address":[22215043],"length":1,"stats":{"Line":0}},{"line":246,"address":[22329512,22329022,22435743,22435609,22327779],"length":1,"stats":{"Line":0}},{"line":247,"address":[22330598,22330934,22329486],"length":1,"stats":{"Line":0}},{"line":249,"address":[22323401,22218178,22219818,22323535,22218302,22219473,22218829],"length":1,"stats":{"Line":0}},{"line":254,"address":[22293350],"length":1,"stats":{"Line":0}},{"line":257,"address":[22215018,22215106,22323897,22324031,22215675],"length":1,"stats":{"Line":0}},{"line":258,"address":[22290223],"length":1,"stats":{"Line":0}},{"line":260,"address":[22228731],"length":1,"stats":{"Line":0}},{"line":261,"address":[16578831,16578697,16475008,16474514,16469291],"length":1,"stats":{"Line":0}},{"line":262,"address":[22234434],"length":1,"stats":{"Line":0}},{"line":267,"address":[22436577,22434768],"length":1,"stats":{"Line":0}},{"line":268,"address":[22236158,22235479],"length":1,"stats":{"Line":0}},{"line":269,"address":[22338541],"length":1,"stats":{"Line":0}},{"line":270,"address":[22334760,22335252,22437593,22437727,22335104,22334637],"length":1,"stats":{"Line":0}},{"line":271,"address":[22222522,22223428],"length":1,"stats":{"Line":0}},{"line":273,"address":[22228643],"length":1,"stats":{"Line":0}},{"line":274,"address":[22434896],"length":1,"stats":{"Line":0}},{"line":278,"address":[22298144,22298460],"length":1,"stats":{"Line":0}},{"line":279,"address":[22230354,22230515],"length":1,"stats":{"Line":0}},{"line":280,"address":[26608319,26608416],"length":1,"stats":{"Line":0}},{"line":285,"address":[22223904],"length":1,"stats":{"Line":0}},{"line":286,"address":[22305425],"length":1,"stats":{"Line":0}},{"line":292,"address":[22442501,22442144,22442171,22442276,22441997,22442224,22442304],"length":1,"stats":{"Line":7}},{"line":297,"address":[22444054],"length":1,"stats":{"Line":1}},{"line":300,"address":[22539563,22539366,22539165,22538995,22539248,22539136,22539339],"length":1,"stats":{"Line":12}},{"line":304,"address":[22444694],"length":1,"stats":{"Line":2}},{"line":307,"address":[22333331,22333821,22333499,22333632,22333552,22333472,22333604],"length":1,"stats":{"Line":5}},{"line":308,"address":[22408470],"length":1,"stats":{"Line":1}},{"line":311,"address":[22327584,22327107,22327327,22327274,22327389,22327248,22327416],"length":1,"stats":{"Line":0}},{"line":312,"address":[26801018],"length":1,"stats":{"Line":0}},{"line":315,"address":[22342395,22341520,22341401,22341549,22342414,22341750,22341632],"length":1,"stats":{"Line":0}},{"line":317,"address":[22441102,22441353,22440806],"length":1,"stats":{"Line":0}},{"line":318,"address":[22335155,22335284],"length":1,"stats":{"Line":0}},{"line":321,"address":[22330931,22328855,22330515,22328923,22330647,22328697,22329030,22328816],"length":1,"stats":{"Line":0}},{"line":323,"address":[22329446,22330910,22329147],"length":1,"stats":{"Line":0}},{"line":324,"address":[22542771,22542491,22543872,22542631],"length":1,"stats":{"Line":0}},{"line":325,"address":[22405397,22404307,22405264],"length":1,"stats":{"Line":0}},{"line":327,"address":[22329741,22330612,22329692],"length":1,"stats":{"Line":0}},{"line":328,"address":[22404631,22404809,22405170],"length":1,"stats":{"Line":0}},{"line":329,"address":[16584727,16584589,16584509,16584834],"length":1,"stats":{"Line":0}},{"line":330,"address":[22404984],"length":1,"stats":{"Line":0}},{"line":334,"address":[22437120,22436992],"length":1,"stats":{"Line":0}},{"line":335,"address":[22342285,22342227],"length":1,"stats":{"Line":0}},{"line":338,"address":[22343252,22342368,22343230],"length":1,"stats":{"Line":0}},{"line":342,"address":[22336911,22337130,22336827],"length":1,"stats":{"Line":0}},{"line":343,"address":[22337088,22337712,22337734],"length":1,"stats":{"Line":0}},{"line":344,"address":[22306234],"length":1,"stats":{"Line":0}},{"line":345,"address":[22238116],"length":1,"stats":{"Line":0}},{"line":346,"address":[22306016,22306091],"length":1,"stats":{"Line":0}},{"line":347,"address":[22231394],"length":1,"stats":{"Line":0}},{"line":348,"address":[26609240],"length":1,"stats":{"Line":0}},{"line":354,"address":[22331207,22331435,22336023,22331340,22335929,22335717,22335804,22331168,22330991],"length":1,"stats":{"Line":0}},{"line":358,"address":[16585876],"length":1,"stats":{"Line":0}},{"line":359,"address":[16586044,16585965,16599401,16586557,16599535],"length":1,"stats":{"Line":0}},{"line":361,"address":[22452500,22448860,22449976,22450124],"length":1,"stats":{"Line":0}},{"line":363,"address":[22448562,22446273,22446548,22446169],"length":1,"stats":{"Line":0}},{"line":364,"address":[22415493,22415342],"length":1,"stats":{"Line":0}},{"line":365,"address":[22340930,22340784],"length":1,"stats":{"Line":0}},{"line":367,"address":[22334189,22335836,22334013],"length":1,"stats":{"Line":0}},{"line":368,"address":[22415736],"length":1,"stats":{"Line":0}},{"line":369,"address":[22409108,22408993,22410407],"length":1,"stats":{"Line":0}},{"line":371,"address":[22451537,22451241,22451149,22452453],"length":1,"stats":{"Line":0}},{"line":372,"address":[22348826,22348791,22348614],"length":1,"stats":{"Line":0}},{"line":374,"address":[22416387],"length":1,"stats":{"Line":0}},{"line":375,"address":[22448932,22448958,22447762,22448784],"length":1,"stats":{"Line":0}},{"line":376,"address":[22342888,22343022],"length":1,"stats":{"Line":0}},{"line":378,"address":[16589415],"length":1,"stats":{"Line":0}},{"line":379,"address":[22548327],"length":1,"stats":{"Line":0}},{"line":380,"address":[22335274],"length":1,"stats":{"Line":0}},{"line":381,"address":[22448139,22448032],"length":1,"stats":{"Line":0}},{"line":384,"address":[22342304],"length":1,"stats":{"Line":0}},{"line":387,"address":[16590797,16591681,16590704,16591700,16590585,16590734,16590885],"length":1,"stats":{"Line":0}},{"line":388,"address":[26810125,26810400,26810773],"length":1,"stats":{"Line":0}},{"line":389,"address":[22350713,22350872],"length":1,"stats":{"Line":0}},{"line":390,"address":[22550238,22550544,22550321,22550512],"length":1,"stats":{"Line":0}},{"line":391,"address":[22550332],"length":1,"stats":{"Line":0}},{"line":394,"address":[22419184,22419214,22421408,22421385,22419043,22419371,22421339,22419277],"length":1,"stats":{"Line":0}},{"line":395,"address":[22412667,22414475,22412543],"length":1,"stats":{"Line":0}},{"line":397,"address":[22352216,22351816,22353638,22351920],"length":1,"stats":{"Line":0}},{"line":398,"address":[22455053,22455225],"length":1,"stats":{"Line":0}},{"line":399,"address":[22455613,22455244],"length":1,"stats":{"Line":0}},{"line":400,"address":[22352516],"length":1,"stats":{"Line":0}},{"line":402,"address":[26811966,26813030,26812278,26812208],"length":1,"stats":{"Line":0}},{"line":403,"address":[22451766,22451858,22452146,22452578],"length":1,"stats":{"Line":0}},{"line":404,"address":[22452111],"length":1,"stats":{"Line":0}},{"line":405,"address":[22457867,22457980],"length":1,"stats":{"Line":0}},{"line":407,"address":[22457953],"length":1,"stats":{"Line":0}},{"line":410,"address":[22353870,22356107,22353961,22354055,22356179,22353840,22356064,22353699],"length":1,"stats":{"Line":0}},{"line":411,"address":[22555486,22553467,22553779],"length":1,"stats":{"Line":0}},{"line":412,"address":[22457649,22457490,22459052,22457328,22457307],"length":1,"stats":{"Line":0}},{"line":414,"address":[22415267],"length":1,"stats":{"Line":0}},{"line":415,"address":[16595145,16596789,16595265,16596768],"length":1,"stats":{"Line":0}},{"line":416,"address":[22459339,22459230],"length":1,"stats":{"Line":0}},{"line":417,"address":[22341083,22341125],"length":1,"stats":{"Line":0}},{"line":418,"address":[22554205,22554275],"length":1,"stats":{"Line":0}},{"line":419,"address":[22422996,22423878,22422881],"length":1,"stats":{"Line":0}},{"line":420,"address":[22554541,22554633,22554921,22555428],"length":1,"stats":{"Line":0}},{"line":421,"address":[22458454],"length":1,"stats":{"Line":0}},{"line":422,"address":[22348770,22348953],"length":1,"stats":{"Line":0}},{"line":424,"address":[22458714],"length":1,"stats":{"Line":0}},{"line":427,"address":[26815805,26815677,26815740,26815603,26815823,26815648,26815994],"length":1,"stats":{"Line":0}},{"line":428,"address":[22424599],"length":1,"stats":{"Line":0}},{"line":431,"address":[22357295,22358710,22358747,22358757,22357088,22357118,22357201,22356969],"length":1,"stats":{"Line":0}},{"line":432,"address":[22419584,22418227,22418526],"length":1,"stats":{"Line":0}},{"line":433,"address":[22456772,22456611],"length":1,"stats":{"Line":0}},{"line":434,"address":[22344126,22344225],"length":1,"stats":{"Line":0}},{"line":435,"address":[22419551,22418879],"length":1,"stats":{"Line":0}},{"line":436,"address":[22358562],"length":1,"stats":{"Line":0}},{"line":437,"address":[22358441],"length":1,"stats":{"Line":0}},{"line":438,"address":[16599058],"length":1,"stats":{"Line":0}},{"line":443,"address":[22557232],"length":1,"stats":{"Line":0}},{"line":449,"address":[22352464,22352569,22352669,22352334,22353900,22353924,22352497],"length":1,"stats":{"Line":0}},{"line":450,"address":[16601439,16600511,16600298],"length":1,"stats":{"Line":0}},{"line":451,"address":[22462840,22462932,22463770,22463236],"length":1,"stats":{"Line":0}},{"line":452,"address":[22465057,22464833,22465018],"length":1,"stats":{"Line":0}},{"line":454,"address":[22559630],"length":1,"stats":{"Line":0}},{"line":455,"address":[22463397,22463824,22463969,22463995],"length":1,"stats":{"Line":0}},{"line":456,"address":[22347339,22347202],"length":1,"stats":{"Line":0}},{"line":458,"address":[22559878],"length":1,"stats":{"Line":0}},{"line":459,"address":[22428474],"length":1,"stats":{"Line":0}},{"line":460,"address":[22360725],"length":1,"stats":{"Line":0}},{"line":461,"address":[22459739],"length":1,"stats":{"Line":0}},{"line":464,"address":[22361477,22361389,22362312,22361155,22361296,22361326,22362285,22362326],"length":1,"stats":{"Line":0}},{"line":465,"address":[22461265,22460529,22460824],"length":1,"stats":{"Line":0}},{"line":466,"address":[22361845],"length":1,"stats":{"Line":0}},{"line":467,"address":[22461078,22460953],"length":1,"stats":{"Line":0}},{"line":468,"address":[22429882,22429981],"length":1,"stats":{"Line":0}},{"line":471,"address":[22364388,22362743,22362558,22364344,22364303,22362528,22362387,22362649],"length":1,"stats":{"Line":0}},{"line":472,"address":[16603695,16603395,16604927],"length":1,"stats":{"Line":0}},{"line":473,"address":[22467813,22467639],"length":1,"stats":{"Line":0}},{"line":474,"address":[22363368],"length":1,"stats":{"Line":0}},{"line":475,"address":[22466598,22466268,22466352],"length":1,"stats":{"Line":0}},{"line":476,"address":[22363961,22364195,22363807,22363678],"length":1,"stats":{"Line":0}},{"line":477,"address":[22350103,22350199],"length":1,"stats":{"Line":0}},{"line":479,"address":[22424823,22424706],"length":1,"stats":{"Line":0}},{"line":486,"address":[22562634],"length":1,"stats":{"Line":0}},{"line":490,"address":[22469189,22470173,22469088,22469118,22471079,22469277,22468969,22471159],"length":1,"stats":{"Line":0}},{"line":491,"address":[22463801,22464088,22465570],"length":1,"stats":{"Line":0}},{"line":492,"address":[22464061,22464222],"length":1,"stats":{"Line":0}},{"line":493,"address":[22366578,22365304,22365372,22365582],"length":1,"stats":{"Line":0}},{"line":494,"address":[22365695,22365602,22365941,22366602],"length":1,"stats":{"Line":0}},{"line":495,"address":[22433661,22433790],"length":1,"stats":{"Line":0}},{"line":496,"address":[22470731,22470614],"length":1,"stats":{"Line":0}},{"line":499,"address":[26823796],"length":1,"stats":{"Line":0}},{"line":502,"address":[22465973,22465885,22465806,22468233,22468078,22465635,22468243,22465776],"length":1,"stats":{"Line":0}},{"line":503,"address":[22353377,22355534,22353676],"length":1,"stats":{"Line":0}},{"line":504,"address":[22353637,22353809,22355347],"length":1,"stats":{"Line":0}},{"line":505,"address":[22566954,22566887,22568507],"length":1,"stats":{"Line":0}},{"line":506,"address":[26826036],"length":1,"stats":{"Line":0}},{"line":507,"address":[22430176,22430448,22429525,22429231,22428795],"length":1,"stats":{"Line":0}},{"line":508,"address":[22468314,22468382],"length":1,"stats":{"Line":0}},{"line":510,"address":[22436342,22436547],"length":1,"stats":{"Line":0}},{"line":512,"address":[22367891,22367983,22369648,22369920,22368253,22368313],"length":1,"stats":{"Line":0}},{"line":513,"address":[22569054,22568986],"length":1,"stats":{"Line":0}},{"line":516,"address":[22354543,22355159],"length":1,"stats":{"Line":0}},{"line":517,"address":[22436757,22436687],"length":1,"stats":{"Line":0}},{"line":519,"address":[22470487],"length":1,"stats":{"Line":0}},{"line":520,"address":[26827285],"length":1,"stats":{"Line":0}},{"line":523,"address":[22431033,22431127,22432671,22430942,22432611,22432661,22430912,22430793],"length":1,"stats":{"Line":0}},{"line":524,"address":[22431235,22431527,22432666],"length":1,"stats":{"Line":0}},{"line":525,"address":[22438423,22438594],"length":1,"stats":{"Line":0}},{"line":526,"address":[22363935,22364103,22364820],"length":1,"stats":{"Line":0}},{"line":527,"address":[22364164,22364472,22364825,22364226],"length":1,"stats":{"Line":0}},{"line":528,"address":[22474288,22474417],"length":1,"stats":{"Line":0}},{"line":529,"address":[22439444,22439353],"length":1,"stats":{"Line":0}},{"line":533,"address":[22363972],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":249},{"path":["/","app","kukuri-tauri","src-tauri","src","lib.rs"],"content":"use std::sync::Arc;\n\nuse tauri::{Emitter, Manager};\nuse tokio::sync::broadcast;\nuse tracing::info;\n\n// モジュール定義\nmod application;\npub mod domain;\nmod infrastructure;\nmod presentation;\nmod shared;\nmod state;\n\npub use application::ports::repositories::TopicMetricsRepository;\npub use domain::entities::{TopicMetricsRecord, TopicMetricsSnapshot};\npub use infrastructure::database::{\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\n};\npub use shared::config::AppConfig;\n\npub mod ops {\n    pub mod p2p {\n        pub use crate::infrastructure::p2p::metrics;\n    }\n}\n\n#[doc(hidden)]\npub mod test_support {\n    pub mod application {\n        pub use crate::application::ports;\n        pub use crate::application::services;\n        pub use crate::application::shared;\n    }\n    pub mod domain {\n        pub use crate::domain::entities;\n        pub use crate::domain::p2p;\n        pub use crate::domain::value_objects;\n    }\n    pub mod infrastructure {\n        pub use crate::infrastructure::crypto;\n        pub use crate::infrastructure::database;\n        pub use crate::infrastructure::event;\n        pub use crate::infrastructure::offline;\n        pub use crate::infrastructure::p2p;\n        pub use crate::infrastructure::storage;\n    }\n    pub mod presentation {\n        pub use crate::presentation::dto;\n    }\n    pub mod shared {\n        pub use crate::shared::{config, error};\n    }\n}\n\n#[doc(hidden)]\npub mod contract_testing;\n\n// Tauriコマンドのインポート\n// v2アーキテクチャへの移行完了につき、旧コマンドのインポートは削除\nuse state::AppState;\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\n/// Run the Tauri application\n///\n/// # Panics\n///\n/// Panics if the Tauri application fails to run\npub fn run() {\n    // ログ設定の初期化\n    init_logging();\n\n    info!(\"Kukuri Tauri application starting...\");\n\n    tauri::Builder::default()\n        .plugin(tauri_plugin_opener::init())\n        .plugin(tauri_plugin_dialog::init())\n        .plugin(tauri_plugin_fs::init())\n        .invoke_handler(tauri::generate_handler![\n            // 認証関連コマンド\n            presentation::commands::generate_keypair,\n            presentation::commands::login,\n            presentation::commands::logout,\n            presentation::commands::export_private_key,\n            // セキュアストレージ関連コマンド\n            presentation::commands::add_account,\n            presentation::commands::list_accounts,\n            presentation::commands::switch_account,\n            presentation::commands::remove_account,\n            presentation::commands::get_current_account,\n            presentation::commands::secure_login,\n            // ユーザー関連コマンド\n            presentation::commands::get_user,\n            presentation::commands::get_user_by_pubkey,\n            presentation::commands::search_users,\n            presentation::commands::update_privacy_settings,\n            presentation::commands::follow_user,\n            presentation::commands::unfollow_user,\n            presentation::commands::get_followers,\n            presentation::commands::get_following,\n            presentation::commands::send_direct_message,\n            presentation::commands::list_direct_messages,\n            presentation::commands::list_direct_message_conversations,\n            presentation::commands::mark_direct_message_conversation_read,\n            presentation::commands::seed_direct_message_for_e2e,\n            presentation::commands::upload_profile_avatar,\n            presentation::commands::fetch_profile_avatar,\n            presentation::commands::profile_avatar_sync,\n            // トピック関連コマンド\n            presentation::commands::create_topic,\n            presentation::commands::enqueue_topic_creation,\n            presentation::commands::list_pending_topics,\n            presentation::commands::mark_pending_topic_synced,\n            presentation::commands::mark_pending_topic_failed,\n            presentation::commands::get_topics,\n            presentation::commands::update_topic,\n            presentation::commands::delete_topic,\n            presentation::commands::join_topic,\n            presentation::commands::leave_topic,\n            presentation::commands::get_topic_stats,\n            presentation::commands::list_trending_topics,\n            // ポスト関連コマンド\n            presentation::commands::create_post,\n            presentation::commands::get_posts,\n            presentation::commands::list_trending_posts,\n            presentation::commands::delete_post,\n            presentation::commands::bookmark_post,\n            presentation::commands::unbookmark_post,\n            presentation::commands::like_post,\n            presentation::commands::boost_post,\n            presentation::commands::get_bookmarked_post_ids,\n            presentation::commands::list_following_feed,\n            // Nostr関連コマンド\n            presentation::commands::initialize_nostr,\n            presentation::commands::publish_text_note,\n            presentation::commands::publish_topic_post,\n            presentation::commands::send_reaction,\n            presentation::commands::update_nostr_metadata,\n            presentation::commands::subscribe_to_topic,\n            presentation::commands::subscribe_to_user,\n            presentation::commands::disconnect_nostr,\n            presentation::commands::list_nostr_subscriptions,\n            // P2P関連コマンド\n            presentation::commands::initialize_p2p,\n            presentation::commands::join_p2p_topic,\n            presentation::commands::leave_p2p_topic,\n            presentation::commands::broadcast_to_topic,\n            presentation::commands::get_p2p_status,\n            presentation::commands::get_node_address,\n            presentation::commands::get_p2p_metrics,\n            // オフライン関連コマンド\n            presentation::commands::save_offline_action,\n            presentation::commands::get_offline_actions,\n            presentation::commands::sync_offline_actions,\n            presentation::commands::get_cache_status,\n            presentation::commands::list_sync_queue_items,\n            presentation::commands::add_to_sync_queue,\n            presentation::commands::update_cache_metadata,\n            presentation::commands::save_optimistic_update,\n            presentation::commands::confirm_optimistic_update,\n            presentation::commands::rollback_optimistic_update,\n            presentation::commands::cleanup_expired_cache,\n            presentation::commands::update_sync_status,\n            presentation::commands::record_offline_retry_outcome,\n            presentation::commands::get_offline_retry_metrics,\n            // Community Node commands\n            presentation::commands::set_community_node_config,\n            presentation::commands::get_community_node_config,\n            presentation::commands::clear_community_node_config,\n            presentation::commands::community_node_authenticate,\n            presentation::commands::community_node_clear_token,\n            presentation::commands::community_node_get_trust_anchor,\n            presentation::commands::community_node_set_trust_anchor,\n            presentation::commands::community_node_clear_trust_anchor,\n            presentation::commands::community_node_list_group_keys,\n            presentation::commands::community_node_list_labels,\n            presentation::commands::community_node_submit_report,\n            presentation::commands::community_node_trust_report_based,\n            presentation::commands::community_node_trust_communication_density,\n            presentation::commands::community_node_search,\n            presentation::commands::community_node_list_bootstrap_nodes,\n            presentation::commands::community_node_list_bootstrap_services,\n            presentation::commands::community_node_get_consent_status,\n            presentation::commands::community_node_accept_consents,\n            // Access Control (P2P join)\n            presentation::commands::access_control_issue_invite,\n            presentation::commands::access_control_request_join,\n            presentation::commands::access_control_list_join_requests,\n            presentation::commands::access_control_approve_join_request,\n            presentation::commands::access_control_reject_join_request,\n            // ユーティリティコマンド\n            presentation::commands::pubkey_to_npub,\n            presentation::commands::npub_to_pubkey,\n            // Bootstrap UI commands\n            presentation::commands::get_bootstrap_config,\n            presentation::commands::set_bootstrap_nodes,\n            presentation::commands::clear_bootstrap_nodes,\n            presentation::commands::apply_cli_bootstrap_nodes,\n            presentation::commands::get_relay_status,\n        ])\n        .setup(|app| {\n            // アプリケーション初期化処理\n            let app_handle = app.handle();\n\n            tauri::async_runtime::block_on(async move {\n                let app_state = AppState::new(app_handle)\n                    .await\n                    .expect(\"Failed to initialize app state\");\n                let offline_reindex_job = Arc::clone(&app_state.offline_reindex_job);\n                let user_service = Arc::clone(&app_state.user_service);\n                let user_search_service = Arc::clone(&app_state.user_search_service);\n                let event_service = Arc::clone(&app_state.event_service);\n                let p2p_service = Arc::clone(&app_state.p2p_service);\n                let offline_service = Arc::clone(&app_state.offline_service);\n                let profile_avatar_service = Arc::clone(&app_state.profile_avatar_service);\n\n                // P2P機能を初期化\n                if let Err(e) = app_state.initialize_p2p().await {\n                    tracing::warn!(\"Failed to initialize P2P: {}\", e);\n                }\n\n                // P2Pイベントハンドラーを起動\n                spawn_p2p_event_handler(app_handle.clone(), app_state.clone());\n\n                app_handle.manage(app_state.clone());\n                app_handle.manage(offline_reindex_job);\n                app_handle.manage(user_service);\n                app_handle.manage(user_search_service);\n                app_handle.manage(event_service);\n                app_handle.manage(p2p_service);\n                app_handle.manage(offline_service);\n                app_handle.manage(profile_avatar_service);\n            });\n\n            info!(\"Application setup complete\");\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn init_logging() {\n    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n    const DEFAULT_DIRECTIVES: &str = \"info,kukuri=debug\";\n    const MAINLINE_SUPPRESS_DIRECTIVE: &str = \"mainline::rpc::socket=error\";\n\n    let mut env_filter = tracing_subscriber::EnvFilter::try_from_default_env()\n        .unwrap_or_else(|_| DEFAULT_DIRECTIVES.into());\n\n    let suppress_mainline = std::env::var(\"RUST_LOG\")\n        .map(|value| !value.contains(\"mainline::rpc::socket\"))\n        .unwrap_or(true);\n\n    if suppress_mainline {\n        if let Ok(directive) = MAINLINE_SUPPRESS_DIRECTIVE.parse() {\n            env_filter = env_filter.add_directive(directive);\n        } else {\n            tracing::warn!(\n                \"Failed to parse mainline log suppression directive: {}\",\n                MAINLINE_SUPPRESS_DIRECTIVE\n            );\n        }\n    }\n\n    tracing_subscriber::registry()\n        .with(env_filter)\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n}\n\n/// P2Pイベントハンドラーを起動\nfn spawn_p2p_event_handler(app_handle: tauri::AppHandle, app_state: AppState) {\n    use serde::Serialize;\n\n    #[derive(Debug, Clone, Serialize)]\n    struct P2PMessageEvent {\n        topic_id: String,\n        message_type: String,\n        payload: Vec<u8>,\n        sender: Vec<u8>,\n        timestamp: i64,\n    }\n\n    #[derive(Debug, Clone, Serialize)]\n    struct P2PPeerEvent {\n        topic_id: String,\n        peer_id: Vec<u8>,\n        event_type: String, // \"joined\" or \"left\"\n    }\n\n    tauri::async_runtime::spawn(async move {\n        // event_rxを取得してRwLockを即座に解放\n        let rx = {\n            let p2p_state = app_state.p2p_state.read().await;\n            let mut event_rx = p2p_state.event_rx.write().await;\n            event_rx.take()\n        };\n\n        if let Some(mut rx) = rx {\n            loop {\n                match rx.recv().await {\n                    Ok(event) => match event {\n                        crate::domain::p2p::P2PEvent::MessageReceived {\n                            topic_id,\n                            message,\n                            _from_peer: _,\n                        } => {\n                            // 旧GossipMessage経路はUIの期待ペイロードと形状が異なるため、\n                            // 衝突回避のためイベント名を変更（デバッグ用途）\n                            let event_data = P2PMessageEvent {\n                                topic_id,\n                                message_type: format!(\"{:?}\", message.msg_type),\n                                payload: message.payload,\n                                sender: message.sender,\n                                timestamp: message.timestamp,\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://message/raw\", event_data) {\n                                tracing::error!(\"Failed to emit P2P raw message event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::PeerJoined { topic_id, peer_id } => {\n                            let event_data = P2PPeerEvent {\n                                topic_id,\n                                peer_id,\n                                event_type: \"joined\".to_string(),\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\n                                tracing::error!(\"Failed to emit P2P peer joined event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::PeerLeft { topic_id, peer_id } => {\n                            let event_data = P2PPeerEvent {\n                                topic_id,\n                                peer_id,\n                                event_type: \"left\".to_string(),\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\n                                tracing::error!(\"Failed to emit P2P peer left event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::NetworkConnected { node_id, addresses } => {\n                            if let Err(e) = app_handle.emit(\n                                \"p2p://network\",\n                                serde_json::json!({\n                                    \"event\": \"connected\",\n                                    \"nodeId\": node_id,\n                                    \"addresses\": addresses,\n                                }),\n                            ) {\n                                tracing::error!(\"Failed to emit P2P network connected: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::NetworkDisconnected { node_id } => {\n                            if let Err(e) = app_handle.emit(\n                                \"p2p://network\",\n                                serde_json::json!({\n                                    \"event\": \"disconnected\",\n                                    \"nodeId\": node_id,\n                                }),\n                            ) {\n                                tracing::error!(\"Failed to emit P2P network disconnected: {}\", e);\n                            }\n                        }\n                    },\n                    Err(broadcast::error::RecvError::Closed) => break,\n                    Err(broadcast::error::RecvError::Lagged(skipped)) => {\n                        tracing::warn!(\"P2P event handler lagged and skipped {} events\", skipped);\n                        continue;\n                    }\n                }\n            }\n\n            tracing::info!(\"P2P event handler terminated\");\n        }\n    });\n}\n","traces":[{"line":69,"address":[53812435,53812015],"length":1,"stats":{"Line":0}},{"line":71,"address":[21058182],"length":1,"stats":{"Line":9}},{"line":73,"address":[52219385],"length":1,"stats":{"Line":1}},{"line":75,"address":[81584059,81584102],"length":1,"stats":{"Line":0}},{"line":76,"address":[82090112,82090148],"length":1,"stats":{"Line":0}},{"line":77,"address":[25196547],"length":1,"stats":{"Line":0}},{"line":78,"address":[115609301,115609441],"length":1,"stats":{"Line":0}},{"line":79,"address":[115785416],"length":1,"stats":{"Line":9}},{"line":81,"address":[95091298],"length":1,"stats":{"Line":9}},{"line":82,"address":[64749898,64749888],"length":1,"stats":{"Line":0}},{"line":83,"address":[94438330],"length":1,"stats":{"Line":0}},{"line":84,"address":[40921376],"length":1,"stats":{"Line":0}},{"line":86,"address":[105065269,105064222],"length":1,"stats":{"Line":1}},{"line":87,"address":[125172672],"length":1,"stats":{"Line":1}},{"line":88,"address":[65559328],"length":1,"stats":{"Line":0}},{"line":89,"address":[44269411],"length":1,"stats":{"Line":0}},{"line":90,"address":[73989575],"length":1,"stats":{"Line":0}},{"line":91,"address":[70094128],"length":1,"stats":{"Line":0}},{"line":93,"address":[83717392],"length":1,"stats":{"Line":17}},{"line":94,"address":[66300153],"length":1,"stats":{"Line":8}},{"line":95,"address":[50256842],"length":1,"stats":{"Line":8}},{"line":96,"address":[124602316,124602348,124602254],"length":1,"stats":{"Line":1}},{"line":97,"address":[77636252],"length":1,"stats":{"Line":9}},{"line":98,"address":[116266693,116266762],"length":1,"stats":{"Line":2}},{"line":99,"address":[49763366],"length":1,"stats":{"Line":9}},{"line":100,"address":[111906547],"length":1,"stats":{"Line":1}},{"line":101,"address":[112992776],"length":1,"stats":{"Line":1}},{"line":102,"address":[90894608],"length":1,"stats":{"Line":0}},{"line":103,"address":[116345845],"length":1,"stats":{"Line":2}},{"line":104,"address":[66093968],"length":1,"stats":{"Line":1}},{"line":105,"address":[73494266],"length":1,"stats":{"Line":9}},{"line":106,"address":[87685119,87686591,87683647,87684383,87675551,87685855,87680703,87679231,87677023,87682911,87678495,87677759,87682175,87681439,87676287,87679967],"length":1,"stats":{"Line":12}},{"line":107,"address":[73391451],"length":1,"stats":{"Line":10}},{"line":108,"address":[120804261],"length":1,"stats":{"Line":21}},{"line":110,"address":[105399027],"length":1,"stats":{"Line":19}},{"line":111,"address":[112576259,112576453],"length":1,"stats":{"Line":1}},{"line":112,"address":[65654128,65654590],"length":1,"stats":{"Line":9}},{"line":113,"address":[105921915,105922955],"length":1,"stats":{"Line":1}},{"line":114,"address":[116346194],"length":1,"stats":{"Line":10}},{"line":115,"address":[124339338,124339160],"length":1,"stats":{"Line":2}},{"line":116,"address":[117729200],"length":1,"stats":{"Line":8}},{"line":117,"address":[83823822],"length":1,"stats":{"Line":10}},{"line":118,"address":[77060641],"length":1,"stats":{"Line":10}},{"line":119,"address":[62721971],"length":1,"stats":{"Line":8}},{"line":120,"address":[92763538],"length":1,"stats":{"Line":2}},{"line":121,"address":[81509307],"length":1,"stats":{"Line":1}},{"line":123,"address":[68456592],"length":1,"stats":{"Line":9}},{"line":124,"address":[116390070],"length":1,"stats":{"Line":8}},{"line":125,"address":[49772804,49773014],"length":1,"stats":{"Line":9}},{"line":126,"address":[125236944,125236912],"length":1,"stats":{"Line":2}},{"line":127,"address":[112167138],"length":1,"stats":{"Line":2}},{"line":128,"address":[52791876],"length":1,"stats":{"Line":10}},{"line":129,"address":[59207066,59205617],"length":1,"stats":{"Line":9}},{"line":130,"address":[68494819],"length":1,"stats":{"Line":1}},{"line":131,"address":[116824038],"length":1,"stats":{"Line":4}},{"line":132,"address":[114826214],"length":1,"stats":{"Line":7}},{"line":134,"address":[65516196],"length":1,"stats":{"Line":0}},{"line":135,"address":[29497732],"length":1,"stats":{"Line":0}},{"line":136,"address":[118889996,118889933],"length":1,"stats":{"Line":4}},{"line":137,"address":[105175246,105175211],"length":1,"stats":{"Line":3}},{"line":138,"address":[124296232],"length":1,"stats":{"Line":1}},{"line":139,"address":[92099440],"length":1,"stats":{"Line":5}},{"line":140,"address":[30973728],"length":1,"stats":{"Line":3}},{"line":141,"address":[62729047],"length":1,"stats":{"Line":1}},{"line":142,"address":[111651119,111651030],"length":1,"stats":{"Line":4}},{"line":144,"address":[102468222],"length":1,"stats":{"Line":0}},{"line":145,"address":[30966968],"length":1,"stats":{"Line":8}},{"line":146,"address":[71690922],"length":1,"stats":{"Line":6}},{"line":147,"address":[126840126,126840148,126840163],"length":1,"stats":{"Line":8}},{"line":148,"address":[44472752],"length":1,"stats":{"Line":15}},{"line":149,"address":[106032889],"length":1,"stats":{"Line":11}},{"line":150,"address":[29388043,29388095],"length":1,"stats":{"Line":14}},{"line":152,"address":[116715133],"length":1,"stats":{"Line":192}},{"line":153,"address":[62797050],"length":1,"stats":{"Line":192}},{"line":154,"address":[124686597],"length":1,"stats":{"Line":188}},{"line":155,"address":[65084814],"length":1,"stats":{"Line":1}},{"line":156,"address":[82196227],"length":1,"stats":{"Line":16}},{"line":157,"address":[53436784],"length":1,"stats":{"Line":8}},{"line":158,"address":[66157558],"length":1,"stats":{"Line":19}},{"line":159,"address":[115495952],"length":1,"stats":{"Line":19}},{"line":160,"address":[115386171],"length":1,"stats":{"Line":195}},{"line":161,"address":[73128036],"length":1,"stats":{"Line":5}},{"line":162,"address":[105774142],"length":1,"stats":{"Line":2}},{"line":163,"address":[124712993],"length":1,"stats":{"Line":2}},{"line":164,"address":[62729512],"length":1,"stats":{"Line":77}},{"line":165,"address":[35820527,35802197,35802622],"length":1,"stats":{"Line":75}},{"line":167,"address":[62834162],"length":1,"stats":{"Line":2}},{"line":168,"address":[35720089,35701527,35720170,35701840,35719843,35701995,35701762,35702265,35702294],"length":1,"stats":{"Line":2}},{"line":169,"address":[122069920],"length":1,"stats":{"Line":3}},{"line":170,"address":[71928176],"length":1,"stats":{"Line":0}},{"line":171,"address":[70751630,70751806,70754472,70751417],"length":1,"stats":{"Line":1}},{"line":172,"address":[112679528],"length":1,"stats":{"Line":79}},{"line":173,"address":[29762656],"length":1,"stats":{"Line":2}},{"line":174,"address":[105225813],"length":1,"stats":{"Line":1}},{"line":175,"address":[86980736],"length":1,"stats":{"Line":3}},{"line":176,"address":[82176699],"length":1,"stats":{"Line":0}},{"line":177,"address":[122573533,122574014,122573014,122574516,122575004,122574466,122573964,122573483,122575054,122572964],"length":1,"stats":{"Line":4}},{"line":178,"address":[82081558],"length":1,"stats":{"Line":4}},{"line":179,"address":[87428848],"length":1,"stats":{"Line":7}},{"line":180,"address":[40911602,40912408,40912400],"length":1,"stats":{"Line":0}},{"line":181,"address":[69514059],"length":1,"stats":{"Line":0}},{"line":182,"address":[121445104,121444897,121445036],"length":1,"stats":{"Line":1}},{"line":183,"address":[110993854,110993875,110993657],"length":1,"stats":{"Line":1}},{"line":184,"address":[103732780,103733081],"length":1,"stats":{"Line":5}},{"line":186,"address":[35805368],"length":1,"stats":{"Line":0}},{"line":187,"address":[117574865,117574664,117575022],"length":1,"stats":{"Line":0}},{"line":188,"address":[123688921,123688989],"length":1,"stats":{"Line":4}},{"line":189,"address":[105774466],"length":1,"stats":{"Line":0}},{"line":190,"address":[84824866,84825377,84825113,84825488,84825498],"length":1,"stats":{"Line":6}},{"line":192,"address":[35802987],"length":1,"stats":{"Line":9}},{"line":193,"address":[111264192,111264209,111264240,111264328],"length":1,"stats":{"Line":5}},{"line":195,"address":[125322736,125323264,125323235],"length":1,"stats":{"Line":14}},{"line":196,"address":[51019484],"length":1,"stats":{"Line":5}},{"line":197,"address":[94380336],"length":1,"stats":{"Line":14}},{"line":198,"address":[57579304],"length":1,"stats":{"Line":2}},{"line":199,"address":[111745209],"length":1,"stats":{"Line":1}},{"line":201,"address":[82291301],"length":1,"stats":{"Line":6}},{"line":203,"address":[25097952],"length":1,"stats":{"Line":0}},{"line":205,"address":[123653703,123653635],"length":1,"stats":{"Line":0}},{"line":206,"address":[94610590],"length":1,"stats":{"Line":11}},{"line":207,"address":[121421821,121422131,121422439],"length":1,"stats":{"Line":2}},{"line":208,"address":[65065317],"length":1,"stats":{"Line":2}},{"line":209,"address":[87171662],"length":1,"stats":{"Line":2}},{"line":210,"address":[114701360],"length":1,"stats":{"Line":2}},{"line":211,"address":[84697826,84697939],"length":1,"stats":{"Line":2}},{"line":212,"address":[70059494],"length":1,"stats":{"Line":3}},{"line":213,"address":[50344339],"length":1,"stats":{"Line":3}},{"line":214,"address":[47634948,47635123],"length":1,"stats":{"Line":4}},{"line":215,"address":[53437314],"length":1,"stats":{"Line":2}},{"line":218,"address":[115180255],"length":1,"stats":{"Line":2}},{"line":219,"address":[54515029],"length":1,"stats":{"Line":3}},{"line":223,"address":[66943456],"length":1,"stats":{"Line":0}},{"line":225,"address":[71692176],"length":1,"stats":{"Line":2}},{"line":226,"address":[35827310],"length":1,"stats":{"Line":0}},{"line":227,"address":[49708036,49708066],"length":1,"stats":{"Line":1}},{"line":228,"address":[66095040],"length":1,"stats":{"Line":11}},{"line":229,"address":[16934736],"length":1,"stats":{"Line":13}},{"line":230,"address":[40146725],"length":1,"stats":{"Line":19}},{"line":231,"address":[33399782],"length":1,"stats":{"Line":24}},{"line":232,"address":[31261075],"length":1,"stats":{"Line":20}},{"line":235,"address":[62798405,62799124],"length":1,"stats":{"Line":3}},{"line":236,"address":[49538408],"length":1,"stats":{"Line":0}},{"line":238,"address":[87523540,87523509],"length":1,"stats":{"Line":23}},{"line":242,"address":[77240656,77257868,77251735,77237679,77267113],"length":1,"stats":{"Line":12}},{"line":248,"address":[11115044],"length":1,"stats":{"Line":4}},{"line":249,"address":[124344848],"length":1,"stats":{"Line":9}},{"line":251,"address":[88126480],"length":1,"stats":{"Line":8}},{"line":252,"address":[58908000],"length":1,"stats":{"Line":9}},{"line":255,"address":[87689989,87690147],"length":1,"stats":{"Line":12}},{"line":256,"address":[96684789,96684800,96684817,96684768,96684773,96684784],"length":1,"stats":{"Line":3}},{"line":257,"address":[62731970],"length":1,"stats":{"Line":3}},{"line":259,"address":[66975567,66975358],"length":1,"stats":{"Line":18}},{"line":266,"address":[125263132],"length":1,"stats":{"Line":13}},{"line":267,"address":[123992480],"length":1,"stats":{"Line":23}},{"line":268,"address":[62831070],"length":1,"stats":{"Line":17}},{"line":273,"address":[33535715,33536007,33535919],"length":1,"stats":{"Line":16}},{"line":292,"address":[121221520],"length":1,"stats":{"Line":20}},{"line":294,"address":[35604784],"length":1,"stats":{"Line":37}},{"line":295,"address":[33511792],"length":1,"stats":{"Line":30}},{"line":296,"address":[69986095],"length":1,"stats":{"Line":10}},{"line":297,"address":[41015909,41015845,41015973,41015941,41015877],"length":1,"stats":{"Line":3}},{"line":300,"address":[116859403,116859022,116858850],"length":1,"stats":{"Line":1}},{"line":301,"address":[29327312],"length":1,"stats":{"Line":11}},{"line":302,"address":[83881376],"length":1,"stats":{"Line":4}},{"line":303,"address":[59389407,59389365,59389265],"length":1,"stats":{"Line":0}},{"line":304,"address":[41248801],"length":1,"stats":{"Line":17}},{"line":305,"address":[70842464],"length":1,"stats":{"Line":14}},{"line":306,"address":[66883239,66883099],"length":1,"stats":{"Line":22}},{"line":307,"address":[74046660,74050531],"length":1,"stats":{"Line":14}},{"line":308,"address":[122216944],"length":1,"stats":{"Line":15}},{"line":311,"address":[49920368,49920287,49920097,49919976],"length":1,"stats":{"Line":5}},{"line":312,"address":[70835697,70835651],"length":1,"stats":{"Line":5}},{"line":313,"address":[112604914,112605532,112605747,112605948,112605330,112605128],"length":1,"stats":{"Line":4}},{"line":314,"address":[40332345],"length":1,"stats":{"Line":6}},{"line":315,"address":[30117648],"length":1,"stats":{"Line":18}},{"line":316,"address":[121117130],"length":1,"stats":{"Line":18}},{"line":319,"address":[72115975],"length":1,"stats":{"Line":1}},{"line":320,"address":[29501657,29501779],"length":1,"stats":{"Line":9}},{"line":323,"address":[16867957],"length":1,"stats":{"Line":10}},{"line":324,"address":[40981457,40981440],"length":1,"stats":{"Line":7}},{"line":325,"address":[115611616,115611498],"length":1,"stats":{"Line":8}},{"line":326,"address":[28891321,28891227,28891286,28891023],"length":1,"stats":{"Line":10}},{"line":327,"address":[70767993],"length":1,"stats":{"Line":0}},{"line":330,"address":[125238151,125241999],"length":1,"stats":{"Line":7}},{"line":331,"address":[62726530],"length":1,"stats":{"Line":7}},{"line":334,"address":[123993521,123993488],"length":1,"stats":{"Line":14}},{"line":335,"address":[73460257],"length":1,"stats":{"Line":14}},{"line":336,"address":[73497093],"length":1,"stats":{"Line":3}},{"line":337,"address":[59354613],"length":1,"stats":{"Line":13}},{"line":338,"address":[66984991,66985358,66985267],"length":1,"stats":{"Line":14}},{"line":341,"address":[74846579],"length":1,"stats":{"Line":2}},{"line":342,"address":[25312268],"length":1,"stats":{"Line":8}},{"line":345,"address":[35831690,35832101,35832130],"length":1,"stats":{"Line":0}},{"line":346,"address":[82084510],"length":1,"stats":{"Line":1}},{"line":347,"address":[116798591,116798768],"length":1,"stats":{"Line":9}},{"line":348,"address":[29372868],"length":1,"stats":{"Line":7}},{"line":349,"address":[35801055,35801300,35798322,35798786,35798883],"length":1,"stats":{"Line":8}},{"line":350,"address":[124208653],"length":1,"stats":{"Line":6}},{"line":351,"address":[117194158,117194782],"length":1,"stats":{"Line":0}},{"line":354,"address":[29328069,29328125],"length":1,"stats":{"Line":2}},{"line":357,"address":[81545862,81546064,81545448,81545648,81546338],"length":1,"stats":{"Line":2}},{"line":358,"address":[120837679],"length":1,"stats":{"Line":0}},{"line":359,"address":[71793177],"length":1,"stats":{"Line":0}},{"line":360,"address":[65157744,65157728,65157763,65157733],"length":1,"stats":{"Line":0}},{"line":361,"address":[41114168],"length":1,"stats":{"Line":0}},{"line":362,"address":[28905325],"length":1,"stats":{"Line":4}},{"line":365,"address":[40200904],"length":1,"stats":{"Line":2}},{"line":369,"address":[59286944],"length":1,"stats":{"Line":3}},{"line":370,"address":[71762161],"length":1,"stats":{"Line":1}},{"line":371,"address":[40538594],"length":1,"stats":{"Line":1}},{"line":372,"address":[72559289],"length":1,"stats":{"Line":3}},{"line":377,"address":[122524674,122524629,122524899],"length":1,"stats":{"Line":4}}],"covered":176,"coverable":212},{"path":["/","app","kukuri-tauri","src-tauri","src","main.rs"],"content":"// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n    kukuri_lib::run();\n}\n","traces":[{"line":4,"address":[10959600],"length":1,"stats":{"Line":0}},{"line":5,"address":[10959601],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","access_control_commands.rs"],"content":"use crate::application::ports::join_request_store::JoinRequestRecord;\nuse crate::application::services::JoinRequestInput;\nuse crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::access_control_dto::{\n    AccessControlApproveJoinRequest, AccessControlApproveJoinResponse,\n    AccessControlIssueInviteRequest, AccessControlIssueInviteResponse, AccessControlJoinRequest,\n    AccessControlJoinResponse, AccessControlListJoinRequestsResponse,\n    AccessControlPendingJoinRequest, AccessControlRejectJoinRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse tauri::State;\n\n#[tauri::command]\npub async fn access_control_issue_invite(\n    state: State<'_, AppState>,\n    request: AccessControlIssueInviteRequest,\n) -> Result<ApiResponse<AccessControlIssueInviteResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let invite_event_json = state\n        .access_control_service\n        .issue_invite(\n            request.topic_id.trim(),\n            request.expires_in,\n            request.max_uses,\n            request.nonce,\n        )\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlIssueInviteResponse {\n        invite_event_json,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_request_join(\n    state: State<'_, AppState>,\n    request: AccessControlJoinRequest,\n) -> Result<ApiResponse<AccessControlJoinResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let result = state\n        .access_control_service\n        .request_join(JoinRequestInput {\n            topic_id: request.topic_id,\n            scope: request.scope,\n            invite_event_json: request.invite_event_json,\n            target_pubkey: request.target_pubkey,\n            broadcast_to_topic: request.broadcast_to_topic.unwrap_or(false),\n        })\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlJoinResponse {\n        event_id: result.event_id,\n        sent_topics: result.sent_topics,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_list_join_requests(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<AccessControlListJoinRequestsResponse>, AppError> {\n    let records = state\n        .access_control_service\n        .list_pending_join_requests()\n        .await?;\n    let items = records\n        .into_iter()\n        .map(map_pending_join_request)\n        .collect::<Vec<_>>();\n    Ok(ApiResponse::success(\n        AccessControlListJoinRequestsResponse { items },\n    ))\n}\n\n#[tauri::command]\npub async fn access_control_approve_join_request(\n    state: State<'_, AppState>,\n    request: AccessControlApproveJoinRequest,\n) -> Result<ApiResponse<AccessControlApproveJoinResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let result = state\n        .access_control_service\n        .approve_join_request(&request.event_id)\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlApproveJoinResponse {\n        event_id: result.event_id,\n        key_envelope_event_id: result.key_envelope_event_id,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_reject_join_request(\n    state: State<'_, AppState>,\n    request: AccessControlRejectJoinRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n    state\n        .access_control_service\n        .reject_join_request(&request.event_id)\n        .await?;\n    Ok(ApiResponse::success(()))\n}\n\nfn map_pending_join_request(record: JoinRequestRecord) -> AccessControlPendingJoinRequest {\n    AccessControlPendingJoinRequest {\n        event_id: record.event.id,\n        topic_id: record.topic_id,\n        scope: record.scope,\n        requester_pubkey: record.requester_pubkey,\n        target_pubkey: record.target_pubkey,\n        requested_at: record.requested_at,\n        received_at: record.received_at,\n        invite_event_json: record.invite_event_json,\n    }\n}\n","traces":[{"line":16,"address":[22358112],"length":1,"stats":{"Line":0}},{"line":20,"address":[22571747,22571473,22572119,22571592],"length":1,"stats":{"Line":0}},{"line":22,"address":[22360223,22358627,22360208],"length":1,"stats":{"Line":0}},{"line":24,"address":[25017841,25017115,25017489,25018092,25017429,25017709,25017270],"length":1,"stats":{"Line":0}},{"line":27,"address":[22440295],"length":1,"stats":{"Line":0}},{"line":28,"address":[22433438],"length":1,"stats":{"Line":0}},{"line":29,"address":[22440382],"length":1,"stats":{"Line":0}},{"line":30,"address":[25017384],"length":1,"stats":{"Line":0}},{"line":32,"address":[22358459,22359107,22358956,22359016,22359562,22359263],"length":1,"stats":{"Line":0}},{"line":34,"address":[22373263,22373448],"length":1,"stats":{"Line":0}},{"line":35,"address":[22572535],"length":1,"stats":{"Line":0}},{"line":40,"address":[25018736],"length":1,"stats":{"Line":0}},{"line":44,"address":[22574655,22573957,22573820,22573707],"length":1,"stats":{"Line":0}},{"line":46,"address":[22473550,22475904,22475919],"length":1,"stats":{"Line":0}},{"line":48,"address":[22368237,22368653,22367605,22368539,22367754,22368183,22369050],"length":1,"stats":{"Line":0}},{"line":50,"address":[25019728],"length":1,"stats":{"Line":0}},{"line":51,"address":[22367777],"length":1,"stats":{"Line":0}},{"line":52,"address":[25019506],"length":1,"stats":{"Line":0}},{"line":53,"address":[22473791],"length":1,"stats":{"Line":0}},{"line":54,"address":[22479422],"length":1,"stats":{"Line":0}},{"line":55,"address":[22435773],"length":1,"stats":{"Line":0}},{"line":57,"address":[22360690,22361803,22362218,22361426,22361483,22361640],"length":1,"stats":{"Line":0}},{"line":59,"address":[22436936,22436719],"length":1,"stats":{"Line":0}},{"line":60,"address":[22478687],"length":1,"stats":{"Line":0}},{"line":61,"address":[25020525],"length":1,"stats":{"Line":0}},{"line":66,"address":[22479888],"length":1,"stats":{"Line":0}},{"line":69,"address":[22480522,22480731,22480411,22480227,22480153,22480028],"length":1,"stats":{"Line":0}},{"line":72,"address":[11604119],"length":1,"stats":{"Line":0}},{"line":73,"address":[16618292,16618473],"length":1,"stats":{"Line":0}},{"line":77,"address":[22371039],"length":1,"stats":{"Line":0}},{"line":78,"address":[22445743],"length":1,"stats":{"Line":0}},{"line":83,"address":[22481056],"length":1,"stats":{"Line":0}},{"line":87,"address":[25023121,25023000,25023240,25023467],"length":1,"stats":{"Line":0}},{"line":89,"address":[22441167,22439419,22441152],"length":1,"stats":{"Line":0}},{"line":91,"address":[22372261,22372818,22371799,22371586,22371845,22372070,22371735],"length":1,"stats":{"Line":0}},{"line":93,"address":[22477678],"length":1,"stats":{"Line":0}},{"line":94,"address":[16618975,16619718,16619474,16620290,16619392,16619338],"length":1,"stats":{"Line":0}},{"line":96,"address":[22482780,22482535],"length":1,"stats":{"Line":0}},{"line":97,"address":[22482455],"length":1,"stats":{"Line":0}},{"line":98,"address":[16620159],"length":1,"stats":{"Line":0}},{"line":103,"address":[22484896],"length":1,"stats":{"Line":0}},{"line":107,"address":[22366890,22366777,22367027,22367231],"length":1,"stats":{"Line":0}},{"line":109,"address":[22381663,22381648,22380748],"length":1,"stats":{"Line":0}},{"line":110,"address":[25025267,25025791,25025886,25025473,25025375,25025443,25025668,25026126],"length":1,"stats":{"Line":0}},{"line":112,"address":[22367092],"length":1,"stats":{"Line":0}},{"line":113,"address":[22448352,22448672,22448808,22448958,22449092,22448726],"length":1,"stats":{"Line":0}},{"line":114,"address":[25025831,25025919],"length":1,"stats":{"Line":0}},{"line":117,"address":[22239589,22239024],"length":1,"stats":{"Line":0}},{"line":119,"address":[22306817],"length":1,"stats":{"Line":0}},{"line":120,"address":[16479619],"length":1,"stats":{"Line":0}},{"line":121,"address":[22306859],"length":1,"stats":{"Line":0}},{"line":122,"address":[16479667],"length":1,"stats":{"Line":0}},{"line":123,"address":[22306913],"length":1,"stats":{"Line":0}},{"line":124,"address":[22239183],"length":1,"stats":{"Line":0}},{"line":125,"address":[22338134],"length":1,"stats":{"Line":0}},{"line":126,"address":[22300029],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","auth_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse, Validate,\n            auth_dto::{\n                ExportPrivateKeyRequest, ExportPrivateKeyResponse, LoginResponse,\n                LoginWithNsecRequest,\n            },\n        },\n        handlers::AuthHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse serde::{Deserialize, Serialize};\nuse tauri::State;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GenerateKeypairResponse {\n    pub public_key: String,\n    pub nsec: String,\n    pub npub: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginRequest {\n    pub nsec: String,\n}\n\n/// 新しいキーペアを生成する\n#[tauri::command]\npub async fn generate_keypair(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<GenerateKeypairResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let response = handler.create_account().await?;\n\n    Ok(ApiResponse::success(GenerateKeypairResponse {\n        public_key: response.pubkey,\n        nsec: response.nsec,\n        npub: response.npub,\n    }))\n}\n\n/// nsecで既存アカウントにログイン\n#[tauri::command]\npub async fn login(\n    state: State<'_, AppState>,\n    request: LoginRequest,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let login_request = LoginWithNsecRequest { nsec: request.nsec };\n\n    let result = handler.login_with_nsec(login_request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ログアウト\n#[tauri::command]\npub async fn logout(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let current_user = handler.get_current_user().await?;\n\n    if let Some(user) = current_user {\n        handler.logout(user.npub).await?;\n    }\n\n    Ok(ApiResponse::success(()))\n}\n\n/// 秘寁E��をエクスポ�E��する\n#[tauri::command]\npub async fn export_private_key(\n    state: State<'_, AppState>,\n    request: ExportPrivateKeyRequest,\n) -> Result<ApiResponse<ExportPrivateKeyResponse>, AppError> {\n    request.validate().map_err(AppError::InvalidInput)?;\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let nsec = handler.export_private_key(&request.npub).await?;\n\n    Ok(ApiResponse::success(ExportPrivateKeyResponse { nsec }))\n}\n","traces":[{"line":32,"address":[15741216],"length":1,"stats":{"Line":0}},{"line":35,"address":[21605356,21605473],"length":1,"stats":{"Line":0}},{"line":36,"address":[21604829,21603896,21603993,21604103,21603760],"length":1,"stats":{"Line":0}},{"line":38,"address":[21494850,21495127],"length":1,"stats":{"Line":0}},{"line":39,"address":[21494742],"length":1,"stats":{"Line":0}},{"line":40,"address":[21701070],"length":1,"stats":{"Line":0}},{"line":41,"address":[15507076],"length":1,"stats":{"Line":0}},{"line":47,"address":[21563168],"length":1,"stats":{"Line":0}},{"line":51,"address":[15507809,15507920],"length":1,"stats":{"Line":0}},{"line":52,"address":[21563547],"length":1,"stats":{"Line":0}},{"line":54,"address":[11411777],"length":1,"stats":{"Line":0}},{"line":55,"address":[21570962],"length":1,"stats":{"Line":0}},{"line":60,"address":[21702879,21702720,21702787,21702752,21702728,21702937,21703218,21704023],"length":1,"stats":{"Line":0}},{"line":61,"address":[21608074,21608202],"length":1,"stats":{"Line":0}},{"line":62,"address":[21608466,21608122,21608858,21609205,21608355,21608273],"length":1,"stats":{"Line":0}},{"line":64,"address":[21504409,21504289],"length":1,"stats":{"Line":0}},{"line":65,"address":[15509785,15508840,15509647,15509884,15510158],"length":1,"stats":{"Line":0}},{"line":68,"address":[21703838,21704474],"length":1,"stats":{"Line":0}},{"line":73,"address":[21566224],"length":1,"stats":{"Line":0}},{"line":77,"address":[21608449,21608660,21608562,21609018],"length":1,"stats":{"Line":0}},{"line":78,"address":[21610283,21610392],"length":1,"stats":{"Line":0}},{"line":79,"address":[11554964],"length":1,"stats":{"Line":0}},{"line":81,"address":[21499559,21499784],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","community_node_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::community_node_dto::{\n    CommunityNodeAuthRequest, CommunityNodeAuthResponse, CommunityNodeBootstrapServicesRequest,\n    CommunityNodeConfigRequest, CommunityNodeConfigResponse, CommunityNodeConsentRequest,\n    CommunityNodeLabelsRequest, CommunityNodeReportRequest, CommunityNodeSearchRequest,\n    CommunityNodeTokenRequest, CommunityNodeTrustAnchorRequest, CommunityNodeTrustAnchorState,\n    CommunityNodeTrustRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse tauri::State;\n\n#[tauri::command]\npub async fn set_community_node_config(\n    state: State<'_, AppState>,\n    request: CommunityNodeConfigRequest,\n) -> Result<ApiResponse<CommunityNodeConfigResponse>, AppError> {\n    let result = state.community_node_handler.set_config(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_community_node_config(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<CommunityNodeConfigResponse>>, AppError> {\n    let result = state.community_node_handler.get_config().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn clear_community_node_config(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_config().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_authenticate(\n    state: State<'_, AppState>,\n    request: CommunityNodeAuthRequest,\n) -> Result<ApiResponse<CommunityNodeAuthResponse>, AppError> {\n    let result = state.community_node_handler.authenticate(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_clear_token(\n    state: State<'_, AppState>,\n    request: CommunityNodeTokenRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_token(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_get_trust_anchor(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<CommunityNodeTrustAnchorState>>, AppError> {\n    let result = state.community_node_handler.get_trust_anchor().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_set_trust_anchor(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustAnchorRequest,\n) -> Result<ApiResponse<CommunityNodeTrustAnchorState>, AppError> {\n    let result = state.community_node_handler.set_trust_anchor(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_clear_trust_anchor(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_trust_anchor().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_group_keys(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<crate::application::ports::group_key_store::GroupKeyEntry>>, AppError> {\n    let result = state.community_node_handler.list_group_keys().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_labels(\n    state: State<'_, AppState>,\n    request: CommunityNodeLabelsRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.list_labels(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_submit_report(\n    state: State<'_, AppState>,\n    request: CommunityNodeReportRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.submit_report(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_trust_report_based(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .trust_report_based(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_trust_communication_density(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .trust_communication_density(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_search(\n    state: State<'_, AppState>,\n    request: CommunityNodeSearchRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.search(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_bootstrap_nodes(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.list_bootstrap_nodes().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_bootstrap_services(\n    state: State<'_, AppState>,\n    request: CommunityNodeBootstrapServicesRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .list_bootstrap_services(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_get_consent_status(\n    state: State<'_, AppState>,\n    request: CommunityNodeTokenRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .get_consent_status(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_accept_consents(\n    state: State<'_, AppState>,\n    request: CommunityNodeConsentRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.accept_consents(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":14,"address":[22480640],"length":1,"stats":{"Line":0}},{"line":18,"address":[11667921],"length":1,"stats":{"Line":0}},{"line":19,"address":[22481359],"length":1,"stats":{"Line":0}},{"line":23,"address":[22485472],"length":1,"stats":{"Line":0}},{"line":26,"address":[22369016,22368964,22369081,22369233],"length":1,"stats":{"Line":0}},{"line":27,"address":[16623750],"length":1,"stats":{"Line":0}},{"line":31,"address":[22369568],"length":1,"stats":{"Line":0}},{"line":34,"address":[11676676],"length":1,"stats":{"Line":0}},{"line":35,"address":[22482855],"length":1,"stats":{"Line":0}},{"line":39,"address":[22444864],"length":1,"stats":{"Line":0}},{"line":43,"address":[11577857],"length":1,"stats":{"Line":0}},{"line":44,"address":[16625310],"length":1,"stats":{"Line":0}},{"line":48,"address":[22487824],"length":1,"stats":{"Line":0}},{"line":52,"address":[11772001],"length":1,"stats":{"Line":0}},{"line":53,"address":[22378687],"length":1,"stats":{"Line":0}},{"line":57,"address":[22490368],"length":1,"stats":{"Line":0}},{"line":60,"address":[22378977,22379091,22379029,22379254],"length":1,"stats":{"Line":0}},{"line":61,"address":[22386534],"length":1,"stats":{"Line":0}},{"line":65,"address":[22379680],"length":1,"stats":{"Line":0}},{"line":69,"address":[22491568,22491453,22491505,22491829],"length":1,"stats":{"Line":0}},{"line":70,"address":[22380631],"length":1,"stats":{"Line":0}},{"line":74,"address":[22374032],"length":1,"stats":{"Line":0}},{"line":77,"address":[22492485,22492433,22492710,22492547],"length":1,"stats":{"Line":0}},{"line":78,"address":[22374632],"length":1,"stats":{"Line":0}},{"line":82,"address":[22449344],"length":1,"stats":{"Line":0}},{"line":85,"address":[12347855,12348002,12347745,12347793],"length":1,"stats":{"Line":0}},{"line":86,"address":[22488056],"length":1,"stats":{"Line":0}},{"line":90,"address":[22375472],"length":1,"stats":{"Line":0}},{"line":94,"address":[12348975,12348711,12348600,12348648],"length":1,"stats":{"Line":0}},{"line":95,"address":[22489079],"length":1,"stats":{"Line":0}},{"line":99,"address":[22458080],"length":1,"stats":{"Line":0}},{"line":103,"address":[10959853],"length":1,"stats":{"Line":0}},{"line":104,"address":[12350222],"length":1,"stats":{"Line":0}},{"line":108,"address":[22495920],"length":1,"stats":{"Line":0}},{"line":112,"address":[22378077,22377998,22378128,22377883,22378309],"length":1,"stats":{"Line":0}},{"line":114,"address":[22494666],"length":1,"stats":{"Line":0}},{"line":115,"address":[11707393],"length":1,"stats":{"Line":0}},{"line":116,"address":[16632724],"length":1,"stats":{"Line":0}},{"line":120,"address":[22591680],"length":1,"stats":{"Line":0}},{"line":124,"address":[22460379,22460494,22460805,22460624,22460573],"length":1,"stats":{"Line":0}},{"line":126,"address":[22385786],"length":1,"stats":{"Line":0}},{"line":127,"address":[12352009,12351611,12351816,12351785,12351868],"length":1,"stats":{"Line":0}},{"line":128,"address":[22379396],"length":1,"stats":{"Line":0}},{"line":132,"address":[16633888],"length":1,"stats":{"Line":0}},{"line":136,"address":[22393640,22393692,22393755,22394035],"length":1,"stats":{"Line":0}},{"line":137,"address":[22593559],"length":1,"stats":{"Line":0}},{"line":141,"address":[22497312],"length":1,"stats":{"Line":0}},{"line":144,"address":[11710999],"length":1,"stats":{"Line":0}},{"line":145,"address":[22455893],"length":1,"stats":{"Line":0}},{"line":149,"address":[22462944],"length":1,"stats":{"Line":0}},{"line":153,"address":[22456267,22456461,22456512,22456693,22456382],"length":1,"stats":{"Line":0}},{"line":155,"address":[16636122],"length":1,"stats":{"Line":0}},{"line":156,"address":[22500437,22500184,22500288,22500232,22500015],"length":1,"stats":{"Line":0}},{"line":157,"address":[22382212],"length":1,"stats":{"Line":0}},{"line":161,"address":[22495104],"length":1,"stats":{"Line":0}},{"line":165,"address":[22457187,22457302,22457419,22457600,22457368],"length":1,"stats":{"Line":0}},{"line":167,"address":[22457330],"length":1,"stats":{"Line":0}},{"line":168,"address":[11590593],"length":1,"stats":{"Line":0}},{"line":169,"address":[22464639],"length":1,"stats":{"Line":0}},{"line":173,"address":[22397056],"length":1,"stats":{"Line":0}},{"line":177,"address":[11696673],"length":1,"stats":{"Line":0}},{"line":178,"address":[22458689],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","direct_message_commands.rs"],"content":"use crate::{\n    presentation::dto::{\n        ApiResponse,\n        direct_message_dto::{\n            DirectMessageConversationListDto, DirectMessagePage,\n            ListDirectMessageConversationsRequest, ListDirectMessagesRequest,\n            MarkDirectMessageConversationReadRequest, SeedDirectMessageRequest,\n            SeedDirectMessageResponse, SendDirectMessageRequest, SendDirectMessageResponse,\n        },\n    },\n    presentation::handlers::DirectMessageHandler,\n    shared::AppError,\n    state::AppState,\n};\nuse nostr_sdk::prelude::{FromBech32, Keys, SecretKey, ToBech32};\nuse tauri::State;\nuse tracing::warn;\n\nasync fn ensure_authenticated(\n    state: &State<'_, AppState>,\n    fallback_nsec: Option<&str>,\n) -> Result<String, AppError> {\n    if let Ok(pair) = state.key_manager.current_keypair().await {\n        return Ok(pair.npub.clone());\n    }\n\n    if let Some(user) = state.auth_service.get_current_user().await? {\n        if let Ok(nsec) = state.key_manager.export_private_key(&user.npub).await {\n            let restored = state.key_manager.import_private_key(&nsec).await?;\n            return Ok(restored.npub);\n        }\n    }\n\n    if let Some(nsec) = fallback_nsec {\n        if let Ok(secret_key) = SecretKey::from_bech32(nsec) {\n            let keys = Keys::new(secret_key);\n            if let Err(err) = state.key_manager.import_private_key(nsec).await {\n                warn!(\n                    error = %err,\n                    \"Failed to import fallback nsec during authentication; continuing with derived npub\"\n                );\n            }\n            return keys\n                .public_key()\n                .to_bech32()\n                .map_err(|err| AppError::Crypto(format!(\"Failed to convert npub: {err}\")));\n        }\n    }\n\n    Err(AppError::Unauthorized(\n        \"Authentication required: failed to load key material\".to_string(),\n    ))\n}\n\nfn is_e2e_allowed() -> bool {\n    cfg!(debug_assertions)\n        || tauri::is_dev()\n        || matches!(std::env::var(\"TAURI_ENV_DEBUG\"), Ok(value) if value == \"true\")\n}\n\n#[tauri::command]\npub async fn send_direct_message(\n    state: State<'_, AppState>,\n    request: SendDirectMessageRequest,\n) -> Result<ApiResponse<SendDirectMessageResponse>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler.send_direct_message(&owner_npub, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn list_direct_messages(\n    state: State<'_, AppState>,\n    request: ListDirectMessagesRequest,\n) -> Result<ApiResponse<DirectMessagePage>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler.list_direct_messages(&owner_npub, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn list_direct_message_conversations(\n    state: State<'_, AppState>,\n    request: ListDirectMessageConversationsRequest,\n) -> Result<ApiResponse<DirectMessageConversationListDto>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler\n        .list_direct_message_conversations(&owner_npub, request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn mark_direct_message_conversation_read(\n    state: State<'_, AppState>,\n    request: MarkDirectMessageConversationReadRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler\n        .mark_conversation_as_read(&owner_npub, request)\n        .await\n        .map(|_| ());\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn seed_direct_message_for_e2e(\n    state: State<'_, AppState>,\n    request: SeedDirectMessageRequest,\n) -> Result<ApiResponse<SeedDirectMessageResponse>, AppError> {\n    if !is_e2e_allowed() {\n        return Err(AppError::Unauthorized(\n            \"E2E direct message seeding is disabled\".to_string(),\n        ));\n    }\n\n    let owner_nsec = request.recipient_nsec.as_deref();\n    let owner_npub = ensure_authenticated(&state, owner_nsec).await?;\n    let content = request\n        .content\n        .unwrap_or_else(|| \"Seeded direct message for E2E\".to_string());\n    let created_at = request\n        .created_at\n        .unwrap_or_else(|| chrono::Utc::now().timestamp_millis());\n\n    let message = state\n        .direct_message_service\n        .seed_incoming_message_for_e2e(&owner_npub, &content, Some(created_at), owner_nsec)\n        .await?;\n\n    let response = SeedDirectMessageResponse {\n        conversation_npub: message.conversation_npub.clone(),\n        created_at: message.created_at_millis(),\n        content: message\n            .decrypted_content\n            .clone()\n            .unwrap_or_else(String::new),\n    };\n\n    Ok(ApiResponse::from_result(Ok(response)))\n}\n","traces":[{"line":19,"address":[24733792],"length":1,"stats":{"Line":0}},{"line":23,"address":[23956351,23955927,23955987,23956142],"length":1,"stats":{"Line":0}},{"line":24,"address":[24770075,24770157],"length":1,"stats":{"Line":0}},{"line":27,"address":[24727148,24728376,24729523],"length":1,"stats":{"Line":0}},{"line":28,"address":[24767318,24767202,24765281,24767640],"length":1,"stats":{"Line":0}},{"line":29,"address":[11649775],"length":1,"stats":{"Line":0}},{"line":30,"address":[24656921],"length":1,"stats":{"Line":0}},{"line":34,"address":[24662494,24661673],"length":1,"stats":{"Line":0}},{"line":35,"address":[24772458,24772398],"length":1,"stats":{"Line":0}},{"line":36,"address":[24737401],"length":1,"stats":{"Line":0}},{"line":37,"address":[24655996,24652619,24657424,24656083],"length":1,"stats":{"Line":0}},{"line":38,"address":[24785785,24664676,24664777,24785919,24665278],"length":1,"stats":{"Line":0}},{"line":43,"address":[24659657,24659728],"length":1,"stats":{"Line":0}},{"line":46,"address":[24659904,24659921],"length":1,"stats":{"Line":0}},{"line":50,"address":[24670051],"length":1,"stats":{"Line":0}},{"line":51,"address":[24737304],"length":1,"stats":{"Line":0}},{"line":62,"address":[24779440],"length":1,"stats":{"Line":0}},{"line":66,"address":[19034019,19034646,19034102,19034289,19034172],"length":1,"stats":{"Line":0}},{"line":67,"address":[24861997,24861834],"length":1,"stats":{"Line":0}},{"line":68,"address":[24993718,24994055,24992885,24993620],"length":1,"stats":{"Line":0}},{"line":69,"address":[24787977],"length":1,"stats":{"Line":0}},{"line":73,"address":[24795200],"length":1,"stats":{"Line":0}},{"line":77,"address":[24898427,24898497,24898959,24898608,24898344],"length":1,"stats":{"Line":0}},{"line":78,"address":[24094839,24094991],"length":1,"stats":{"Line":0}},{"line":79,"address":[11646780],"length":1,"stats":{"Line":0}},{"line":80,"address":[24996253],"length":1,"stats":{"Line":0}},{"line":84,"address":[24901616],"length":1,"stats":{"Line":0}},{"line":88,"address":[19037831,19037914,19038095,19038434,19037984],"length":1,"stats":{"Line":0}},{"line":89,"address":[24096557,24096706],"length":1,"stats":{"Line":0}},{"line":90,"address":[24865989,24865853,24866043,24866344],"length":1,"stats":{"Line":0}},{"line":91,"address":[24784350,24784431],"length":1,"stats":{"Line":0}},{"line":92,"address":[24900265,24901136,24901528,24901353,24901190],"length":1,"stats":{"Line":0}},{"line":93,"address":[24998020],"length":1,"stats":{"Line":0}},{"line":97,"address":[24859680],"length":1,"stats":{"Line":0}},{"line":101,"address":[24785355,24785536,24785425,24785272,24785875],"length":1,"stats":{"Line":0}},{"line":102,"address":[24799610,24799767],"length":1,"stats":{"Line":0}},{"line":103,"address":[24903199,24902854,24902908,24903307,24902718],"length":1,"stats":{"Line":0}},{"line":104,"address":[24999167,24999248],"length":1,"stats":{"Line":0}},{"line":105,"address":[24999313,24999367,24999530,24999679,24998442],"length":1,"stats":{"Line":0}},{"line":106,"address":[19041200],"length":1,"stats":{"Line":0}},{"line":107,"address":[24868214],"length":1,"stats":{"Line":0}},{"line":111,"address":[24903552],"length":1,"stats":{"Line":0}},{"line":115,"address":[24801128,24800991],"length":1,"stats":{"Line":0}},{"line":116,"address":[24794248],"length":1,"stats":{"Line":0}},{"line":117,"address":[24801134],"length":1,"stats":{"Line":0}},{"line":121,"address":[24868925,24869138],"length":1,"stats":{"Line":0}},{"line":122,"address":[24862846,24861871,24863459,24862217,24862391],"length":1,"stats":{"Line":0}},{"line":123,"address":[24900867],"length":1,"stats":{"Line":0}},{"line":125,"address":[24906828,24906816],"length":1,"stats":{"Line":0}},{"line":126,"address":[24788390,24788488],"length":1,"stats":{"Line":0}},{"line":128,"address":[24797008,24797012],"length":1,"stats":{"Line":0}},{"line":130,"address":[24901200,24901427,24901507,24901812,24902022,24901731],"length":1,"stats":{"Line":0}},{"line":132,"address":[24795345],"length":1,"stats":{"Line":0}},{"line":133,"address":[11777362],"length":1,"stats":{"Line":0}},{"line":136,"address":[25002312],"length":1,"stats":{"Line":0}},{"line":137,"address":[24789399],"length":1,"stats":{"Line":0}},{"line":138,"address":[24803224],"length":1,"stats":{"Line":0}},{"line":144,"address":[24906242],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","event_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::event::{\n    EventResponse, NostrMetadataDto, PublishTextNoteRequest, PublishTopicPostRequest,\n    SendReactionRequest, SubscribeRequest, UpdateMetadataRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// Nostrクライアントを初期化（ログイン時に呼び出す）\n#[tauri::command]\npub async fn initialize_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.initialize_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// テキストノートを投稿\n#[tauri::command]\npub async fn publish_text_note(\n    content: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTextNoteRequest { content };\n\n    let result = state.event_handler.publish_text_note(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピック投稿を作成\n#[tauri::command]\npub async fn publish_topic_post(\n    topic_id: String,\n    content: String,\n    reply_to: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTopicPostRequest {\n        topic_id,\n        content,\n        reply_to,\n    };\n\n    let result = state.event_handler.publish_topic_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// リアクションを送信\n#[tauri::command]\npub async fn send_reaction(\n    event_id: String,\n    reaction: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = SendReactionRequest { event_id, reaction };\n\n    let result = state.event_handler.send_reaction(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// メタデータを更新\n#[tauri::command]\npub async fn update_nostr_metadata(\n    metadata: NostrMetadataDto,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = UpdateMetadataRequest { metadata };\n\n    let result = state.event_handler.update_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_topic(\n    topic_id: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let request = SubscribeRequest { topic_id };\n\n    let result = state.event_handler.subscribe_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ユーザーをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_user(\n    pubkey: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.subscribe_to_user(pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のNostr購読状態を取得\n#[tauri::command]\npub async fn list_nostr_subscriptions(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.list_subscriptions().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// Nostrクライアントを切断\n#[tauri::command]\npub async fn disconnect_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.disconnect_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":13,"address":[20014416],"length":1,"stats":{"Line":0}},{"line":16,"address":[11552500],"length":1,"stats":{"Line":0}},{"line":17,"address":[19902295],"length":1,"stats":{"Line":0}},{"line":22,"address":[19983936],"length":1,"stats":{"Line":0}},{"line":26,"address":[20019233],"length":1,"stats":{"Line":0}},{"line":28,"address":[11442526],"length":1,"stats":{"Line":0}},{"line":29,"address":[14157473],"length":1,"stats":{"Line":0}},{"line":34,"address":[19977936],"length":1,"stats":{"Line":0}},{"line":46,"address":[11564161],"length":1,"stats":{"Line":0}},{"line":47,"address":[19985853],"length":1,"stats":{"Line":0}},{"line":52,"address":[19979104],"length":1,"stats":{"Line":0}},{"line":57,"address":[20117822],"length":1,"stats":{"Line":0}},{"line":59,"address":[20023102,20023442,20023154,20023217],"length":1,"stats":{"Line":0}},{"line":60,"address":[20023680],"length":1,"stats":{"Line":0}},{"line":65,"address":[19912368],"length":1,"stats":{"Line":0}},{"line":69,"address":[14160141],"length":1,"stats":{"Line":0}},{"line":71,"address":[11465937],"length":1,"stats":{"Line":0}},{"line":72,"address":[20119510],"length":1,"stats":{"Line":0}},{"line":77,"address":[14160928],"length":1,"stats":{"Line":0}},{"line":81,"address":[19906801],"length":1,"stats":{"Line":0}},{"line":83,"address":[11562798],"length":1,"stats":{"Line":0}},{"line":84,"address":[19914135],"length":1,"stats":{"Line":0}},{"line":89,"address":[19921280],"length":1,"stats":{"Line":0}},{"line":93,"address":[10799774],"length":1,"stats":{"Line":0}},{"line":94,"address":[20709485],"length":1,"stats":{"Line":0}},{"line":99,"address":[19915168],"length":1,"stats":{"Line":0}},{"line":102,"address":[20121569,20121621,20121683,20121846],"length":1,"stats":{"Line":0}},{"line":103,"address":[19983576],"length":1,"stats":{"Line":0}},{"line":108,"address":[19922864],"length":1,"stats":{"Line":0}},{"line":111,"address":[11453444],"length":1,"stats":{"Line":0}},{"line":112,"address":[19984296],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","mod.rs"],"content":"#![allow(unused_imports)]\r\n\r\npub mod access_control_commands;\npub mod auth_commands;\npub mod community_node_commands;\npub mod direct_message_commands;\npub mod event_commands;\npub mod offline_commands;\npub mod p2p_commands;\npub mod post_commands;\npub mod secure_storage_commands;\npub mod topic_commands;\npub mod user_commands;\npub mod utils_commands;\n\npub use access_control_commands::*;\npub use auth_commands::*;\npub use community_node_commands::*;\npub use direct_message_commands::*;\npub use event_commands::*;\npub use offline_commands::*;\npub use p2p_commands::*;\npub use post_commands::*;\npub use secure_storage_commands::*;\npub use topic_commands::*;\npub use user_commands::*;\npub use utils_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","offline_commands.rs"],"content":"use crate::infrastructure::offline::metrics::{\n    self, OfflineRetryMetricsSnapshot, RetryOutcomeMetadata, RetryOutcomeStatus,\n};\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, GetOfflineActionsRequest,\n    ListSyncQueueItemsRequest, OfflineAction, OfflineRetryMetricsResponse, OptimisticUpdateRequest,\n    RecordOfflineRetryOutcomeRequest, SaveOfflineActionRequest, SaveOfflineActionResponse,\n    SyncOfflineActionsRequest, SyncOfflineActionsResponse, SyncQueueItemResponse,\n    UpdateCacheMetadataRequest, UpdateSyncStatusRequest,\n};\nuse crate::presentation::dto::{ApiResponse, Validate};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// オフラインアクションを保存\n#[tauri::command]\npub async fn save_offline_action(\n    state: State<'_, AppState>,\n    request: SaveOfflineActionRequest,\n) -> Result<ApiResponse<SaveOfflineActionResponse>, AppError> {\n    let result = state.offline_handler.save_offline_action(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを取得\n#[tauri::command]\npub async fn get_offline_actions(\n    state: State<'_, AppState>,\n    request: GetOfflineActionsRequest,\n) -> Result<ApiResponse<Vec<OfflineAction>>, AppError> {\n    let result = state.offline_handler.get_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを同期\n#[tauri::command]\npub async fn sync_offline_actions(\n    state: State<'_, AppState>,\n    request: SyncOfflineActionsRequest,\n) -> Result<ApiResponse<SyncOfflineActionsResponse>, AppError> {\n    let result = state.offline_handler.sync_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュステータスを取得\n#[tauri::command]\npub async fn get_cache_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<CacheStatusResponse>, AppError> {\n    let result = state.offline_handler.get_cache_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期キューの状態を取得\n#[tauri::command]\npub async fn list_sync_queue_items(\n    state: State<'_, AppState>,\n    request: ListSyncQueueItemsRequest,\n) -> Result<ApiResponse<Vec<SyncQueueItemResponse>>, AppError> {\n    let result = state.offline_handler.list_sync_queue_items(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期キューに追加\n#[tauri::command]\npub async fn add_to_sync_queue(\n    state: State<'_, AppState>,\n    request: AddToSyncQueueRequest,\n) -> Result<ApiResponse<i64>, AppError> {\n    let result = state.offline_handler.add_to_sync_queue(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュメタデータを更新\n#[tauri::command]\npub async fn update_cache_metadata(\n    state: State<'_, AppState>,\n    request: UpdateCacheMetadataRequest,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state.offline_handler.update_cache_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を保存\n#[tauri::command]\npub async fn save_optimistic_update(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    original_data: Option<String>,\n    updated_data: String,\n) -> Result<ApiResponse<String>, AppError> {\n    let request = OptimisticUpdateRequest {\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n    };\n\n    let result = state.offline_handler.save_optimistic_update(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を確定\n#[tauri::command]\npub async fn confirm_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state\n        .offline_handler\n        .confirm_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新をロールバック\n#[tauri::command]\npub async fn rollback_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Option<String>>, AppError> {\n    let result = state\n        .offline_handler\n        .rollback_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 期限切れキャッシュをクリーンアップ\n#[tauri::command]\npub async fn cleanup_expired_cache(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<i32>, AppError> {\n    let result = state.offline_handler.cleanup_expired_cache().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期ステータスを更新\n#[tauri::command]\npub async fn update_sync_status(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    sync_status: String,\n    conflict_data: Option<String>,\n) -> Result<ApiResponse<Value>, AppError> {\n    let request = UpdateSyncStatusRequest {\n        entity_type,\n        entity_id,\n        sync_status,\n        conflict_data,\n    };\n\n    let result = state.offline_handler.update_sync_status(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn record_offline_retry_outcome(\n    request: RecordOfflineRetryOutcomeRequest,\n) -> Result<ApiResponse<OfflineRetryMetricsResponse>, AppError> {\n    request.validate()?;\n    let status = match request.status.as_str() {\n        \"success\" => RetryOutcomeStatus::Success,\n        _ => RetryOutcomeStatus::Failure,\n    };\n\n    let metadata = RetryOutcomeMetadata {\n        job_id: request.job_id.clone(),\n        job_reason: request.job_reason.clone(),\n        trigger: request.trigger.clone(),\n        user_pubkey: request.user_pubkey.clone(),\n        retry_count: request.retry_count.map(|value| value as u32),\n        max_retries: request.max_retries.map(|value| value as u32),\n        backoff_ms: request.backoff_ms,\n        duration_ms: request.duration_ms,\n        success_count: request.success_count.map(|value| value as u32),\n        failure_count: request.failure_count.map(|value| value as u32),\n        timestamp_ms: request.timestamp_ms,\n    };\n\n    let snapshot = metrics::record_outcome(status, &metadata);\n    Ok(ApiResponse::success(snapshot.into()))\n}\n\n#[tauri::command]\npub async fn get_offline_retry_metrics()\n-> Result<ApiResponse<OfflineRetryMetricsResponse>, AppError> {\n    let snapshot = metrics::snapshot();\n    Ok(ApiResponse::success(snapshot.into()))\n}\n\nimpl From<OfflineRetryMetricsSnapshot> for OfflineRetryMetricsResponse {\n    fn from(value: OfflineRetryMetricsSnapshot) -> Self {\n        Self {\n            total_success: value.total_success,\n            total_failure: value.total_failure,\n            consecutive_failure: value.consecutive_failure,\n            last_success_ms: value.last_success_ms,\n            last_failure_ms: value.last_failure_ms,\n            last_outcome: value.last_outcome.map(|status| match status {\n                RetryOutcomeStatus::Success => \"success\".to_string(),\n                RetryOutcomeStatus::Failure => \"failure\".to_string(),\n            }),\n            last_job_id: value.last_job_id,\n            last_job_reason: value.last_job_reason,\n            last_trigger: value.last_trigger,\n            last_user_pubkey: value.last_user_pubkey,\n            last_retry_count: value.last_retry_count.map(|v| v as i32),\n            last_max_retries: value.last_max_retries.map(|v| v as i32),\n            last_backoff_ms: value.last_backoff_ms,\n            last_duration_ms: value.last_duration_ms,\n            last_success_count: value.last_success_count.map(|v| v as i32),\n            last_failure_count: value.last_failure_count.map(|v| v as i32),\n            last_timestamp_ms: value.last_timestamp_ms,\n        }\n    }\n}\n","traces":[{"line":19,"address":[25003328],"length":1,"stats":{"Line":0}},{"line":23,"address":[25003632,25004050,25003747,25003684],"length":1,"stats":{"Line":0}},{"line":24,"address":[24791174],"length":1,"stats":{"Line":0}},{"line":29,"address":[24865952],"length":1,"stats":{"Line":0}},{"line":33,"address":[24904625,24904415,24904352,24904300],"length":1,"stats":{"Line":0}},{"line":34,"address":[23247141],"length":1,"stats":{"Line":0}},{"line":39,"address":[24806080],"length":1,"stats":{"Line":0}},{"line":43,"address":[11578734],"length":1,"stats":{"Line":0}},{"line":44,"address":[24806781],"length":1,"stats":{"Line":0}},{"line":49,"address":[24874704],"length":1,"stats":{"Line":0}},{"line":52,"address":[19221284],"length":1,"stats":{"Line":0}},{"line":53,"address":[24868375],"length":1,"stats":{"Line":0}},{"line":58,"address":[19048208],"length":1,"stats":{"Line":0}},{"line":62,"address":[10867076],"length":1,"stats":{"Line":0}},{"line":63,"address":[23249422],"length":1,"stats":{"Line":0}},{"line":68,"address":[25007728],"length":1,"stats":{"Line":0}},{"line":72,"address":[19049549,19049257,19049205,19049320],"length":1,"stats":{"Line":0}},{"line":73,"address":[24809211],"length":1,"stats":{"Line":0}},{"line":78,"address":[24877152],"length":1,"stats":{"Line":0}},{"line":82,"address":[24870789,24870459,24870577,24870514],"length":1,"stats":{"Line":0}},{"line":83,"address":[25009487],"length":1,"stats":{"Line":0}},{"line":88,"address":[25009664],"length":1,"stats":{"Line":0}},{"line":102,"address":[11589425],"length":1,"stats":{"Line":0}},{"line":103,"address":[25010720],"length":1,"stats":{"Line":0}},{"line":108,"address":[24804624],"length":1,"stats":{"Line":0}},{"line":112,"address":[24879953,24879546,24879658,24879772,24879721],"length":1,"stats":{"Line":0}},{"line":114,"address":[24879686],"length":1,"stats":{"Line":0}},{"line":115,"address":[11603150],"length":1,"stats":{"Line":0}},{"line":116,"address":[24915181],"length":1,"stats":{"Line":0}},{"line":121,"address":[24911408],"length":1,"stats":{"Line":0}},{"line":125,"address":[24880817,24880522,24880585,24880636,24880410],"length":1,"stats":{"Line":0}},{"line":127,"address":[25012102],"length":1,"stats":{"Line":0}},{"line":128,"address":[25012014,25012164,25012417,25012268,25012212],"length":1,"stats":{"Line":0}},{"line":129,"address":[25012477],"length":1,"stats":{"Line":0}},{"line":134,"address":[23254256],"length":1,"stats":{"Line":0}},{"line":137,"address":[11585188],"length":1,"stats":{"Line":0}},{"line":138,"address":[24881688],"length":1,"stats":{"Line":0}},{"line":143,"address":[24916928],"length":1,"stats":{"Line":0}},{"line":157,"address":[24875451,24875388,24875724,24875336],"length":1,"stats":{"Line":0}},{"line":158,"address":[24808128],"length":1,"stats":{"Line":0}},{"line":162,"address":[24918176],"length":1,"stats":{"Line":0}},{"line":165,"address":[24883424,24883252,24883337],"length":1,"stats":{"Line":0}},{"line":166,"address":[23256463],"length":1,"stats":{"Line":0}},{"line":167,"address":[24920314,24920271],"length":1,"stats":{"Line":0}},{"line":168,"address":[24918656],"length":1,"stats":{"Line":0}},{"line":172,"address":[24808818],"length":1,"stats":{"Line":0}},{"line":173,"address":[24918701],"length":1,"stats":{"Line":0}},{"line":174,"address":[24876724],"length":1,"stats":{"Line":0}},{"line":175,"address":[24802200],"length":1,"stats":{"Line":0}},{"line":176,"address":[24803232,24803238,24802268],"length":1,"stats":{"Line":0}},{"line":177,"address":[24915958,24915062,24915952],"length":1,"stats":{"Line":0}},{"line":178,"address":[24809191],"length":1,"stats":{"Line":0}},{"line":179,"address":[25015505],"length":1,"stats":{"Line":0}},{"line":180,"address":[24877862,24877051,24877856],"length":1,"stats":{"Line":0}},{"line":181,"address":[24803280,24803286,24802507],"length":1,"stats":{"Line":0}},{"line":182,"address":[24877187],"length":1,"stats":{"Line":0}},{"line":185,"address":[24877439],"length":1,"stats":{"Line":0}},{"line":186,"address":[24877521],"length":1,"stats":{"Line":0}},{"line":192,"address":[24916078],"length":1,"stats":{"Line":0}},{"line":193,"address":[24817215],"length":1,"stats":{"Line":0}},{"line":197,"address":[15209936,15211042,15211226],"length":1,"stats":{"Line":0}},{"line":199,"address":[23805568],"length":1,"stats":{"Line":0}},{"line":200,"address":[15210044],"length":1,"stats":{"Line":0}},{"line":201,"address":[23887176],"length":1,"stats":{"Line":0}},{"line":202,"address":[23923959],"length":1,"stats":{"Line":0}},{"line":203,"address":[23922334],"length":1,"stats":{"Line":0}},{"line":204,"address":[24660118,24660096],"length":1,"stats":{"Line":0}},{"line":208,"address":[23887309],"length":1,"stats":{"Line":0}},{"line":209,"address":[23819581],"length":1,"stats":{"Line":0}},{"line":210,"address":[15210249],"length":1,"stats":{"Line":0}},{"line":211,"address":[15210287],"length":1,"stats":{"Line":0}},{"line":212,"address":[24660198,24660192],"length":1,"stats":{"Line":0}},{"line":213,"address":[18914512,18914518],"length":1,"stats":{"Line":0}},{"line":214,"address":[23887597],"length":1,"stats":{"Line":0}},{"line":215,"address":[23880687],"length":1,"stats":{"Line":0}},{"line":216,"address":[24019185],"length":1,"stats":{"Line":0}},{"line":217,"address":[23924452],"length":1,"stats":{"Line":0}},{"line":218,"address":[23918966],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","p2p_commands.rs"],"content":"use crate::{\n    infrastructure::p2p::{bootstrap_config, metrics::GossipMetricDetails},\n    presentation::dto::{\n        ApiResponse,\n        p2p::{\n            BootstrapConfigResponse, BootstrapMetricsResponse, BroadcastRequest,\n            GossipMetricDetailsResponse, GossipMetricsResponse, JoinTopicRequest,\n            LeaveTopicRequest, MainlineMetricsResponse, NodeAddressResponse, P2PMetricsResponse,\n            P2PStatusResponse, RelayStatusResponse,\n        },\n    },\n    shared::AppError,\n    shared::config::BootstrapSource,\n    state::AppState,\n};\nuse std::collections::HashSet;\nuse tauri::State;\n\n/// P2P機能を初期化\n#[tauri::command]\npub async fn initialize_p2p(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let result = state.p2p_handler.initialize_p2p().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pトピックに参加\n#[tauri::command]\npub async fn join_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    #[allow(non_snake_case)] initialPeers: Vec<String>,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = JoinTopicRequest {\n        topic_id: topicId.clone(),\n        initial_peers: initialPeers,\n    };\n    let topic_id = request.topic_id.clone();\n\n    match state.p2p_handler.join_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.ensure_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to ensure UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// P2Pトピックから離脱\n#[tauri::command]\npub async fn leave_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = LeaveTopicRequest {\n        topic_id: topicId.clone(),\n    };\n    match state.p2p_handler.leave_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.stop_ui_subscription(&topicId).await {\n                tracing::warn!(\"Failed to stop UI subscription for {}: {}\", topicId, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックにメッセージをブロードキャスト\n#[tauri::command]\npub async fn broadcast_to_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    content: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = BroadcastRequest {\n        topic_id: topicId,\n        content,\n    };\n    let result = state.p2p_handler.broadcast_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pステータスを取得\n#[tauri::command]\npub async fn get_p2p_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<P2PStatusResponse>, AppError> {\n    let result = state.p2p_handler.get_p2p_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ノードアドレスを取得\n#[tauri::command]\npub async fn get_node_address(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<NodeAddressResponse>, AppError> {\n    let result = state.p2p_handler.get_node_address().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n// ================= Bootstrap UI コマンド =================\n\n#[tauri::command]\npub async fn get_bootstrap_config() -> Result<ApiResponse<BootstrapConfigResponse>, AppError> {\n    let user_nodes = bootstrap_config::load_user_bootstrap_nodes();\n    let selection = bootstrap_config::load_effective_bootstrap_nodes();\n    let env_locked = bootstrap_config::load_env_bootstrap_nodes().is_some();\n    let cli_info = bootstrap_config::load_cli_bootstrap_nodes();\n    let cli_nodes = cli_info\n        .as_ref()\n        .map(|info| info.nodes.clone())\n        .unwrap_or_default();\n    let cli_updated_at_ms = cli_info.and_then(|info| info.updated_at_ms);\n    let mode = if env_locked {\n        \"custom\".to_string()\n    } else if user_nodes.is_empty() {\n        \"default\".to_string()\n    } else {\n        \"custom\".to_string()\n    };\n    let source = match selection.source {\n        crate::shared::config::BootstrapSource::Env => \"env\",\n        crate::shared::config::BootstrapSource::User => \"user\",\n        crate::shared::config::BootstrapSource::Bundle => \"bundle\",\n        crate::shared::config::BootstrapSource::Fallback => \"fallback\",\n        crate::shared::config::BootstrapSource::None => \"none\",\n    }\n    .to_string();\n\n    Ok(ApiResponse::success(BootstrapConfigResponse {\n        mode,\n        nodes: user_nodes,\n        effective_nodes: selection.nodes,\n        source,\n        env_locked,\n        cli_nodes,\n        cli_updated_at_ms,\n    }))\n}\n\n#[tauri::command]\npub async fn set_bootstrap_nodes(nodes: Vec<String>) -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; bootstrap nodes are read-only\".to_string(),\n        ));\n    }\n\n    for node in &nodes {\n        if !node.contains('@') {\n            return Err(AppError::ConfigurationError(format!(\n                \"Invalid bootstrap node format (expected node_id@host:port): {node}\"\n            )));\n        }\n    }\n\n    bootstrap_config::save_user_bootstrap_nodes(&nodes)\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n#[tauri::command]\npub async fn clear_bootstrap_nodes() -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; bootstrap nodes are read-only\".to_string(),\n        ));\n    }\n\n    bootstrap_config::clear_user_bootstrap_nodes()\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n#[tauri::command]\npub async fn apply_cli_bootstrap_nodes(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<BootstrapConfigResponse>, AppError> {\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; CLI bootstrap list cannot be applied\".to_string(),\n        ));\n    }\n\n    let nodes = bootstrap_config::apply_cli_bootstrap_nodes()?;\n    state\n        .p2p_handler\n        .apply_bootstrap_nodes(nodes, BootstrapSource::User)\n        .await?;\n\n    get_bootstrap_config().await\n}\n\n#[tauri::command]\npub async fn get_relay_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<RelayStatusResponse>>, AppError> {\n    let p2p_status = state.p2p_handler.get_p2p_status().await?;\n    let selection = bootstrap_config::load_effective_bootstrap_nodes();\n    let default_status = match p2p_status.connection_status {\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Connected\n        | crate::presentation::dto::p2p::ConnectionStatusResponse::Disconnected => \"disconnected\",\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Connecting => \"connecting\",\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Error => \"error\",\n    };\n\n    let mut statuses = Vec::new();\n    let mut seen: HashSet<String> = HashSet::new();\n\n    for node in selection.nodes.iter() {\n        if seen.insert(node.clone()) {\n            statuses.push(RelayStatusResponse {\n                url: node.clone(),\n                status: default_status.to_string(),\n            });\n        }\n    }\n\n    for peer in p2p_status.peers {\n        let mut matched = None;\n        for candidate in selection.nodes.iter() {\n            if let Some((node_id, _)) = candidate.split_once('@') {\n                if node_id == peer.node_id {\n                    matched = Some(candidate.clone());\n                    break;\n                }\n            } else if candidate == &peer.address || candidate == &peer.node_id {\n                matched = Some(candidate.clone());\n                break;\n            }\n        }\n\n        if let Some(url) = matched {\n            if let Some(index) = statuses.iter().position(|entry| entry.url == url) {\n                statuses[index].status = \"connected\".to_string();\n                continue;\n            }\n        }\n\n        if seen.insert(peer.address.clone()) {\n            statuses.push(RelayStatusResponse {\n                url: peer.address,\n                status: \"connected\".to_string(),\n            });\n        }\n    }\n\n    Ok(ApiResponse::success(statuses))\n}\n\n/// Gossipメトリクスを取得\n#[tauri::command]\npub async fn get_p2p_metrics() -> Result<ApiResponse<P2PMetricsResponse>, AppError> {\n    use crate::infrastructure::p2p::metrics;\n    let snap = metrics::snapshot_full();\n    let response = P2PMetricsResponse {\n        gossip: GossipMetricsResponse {\n            joins: snap.gossip.joins,\n            leaves: snap.gossip.leaves,\n            broadcasts_sent: snap.gossip.broadcasts_sent,\n            messages_received: snap.gossip.messages_received,\n            join_details: to_response_details(&snap.gossip.join_details),\n            leave_details: to_response_details(&snap.gossip.leave_details),\n            broadcast_details: to_response_details(&snap.gossip.broadcast_details),\n            receive_details: to_response_details(&snap.gossip.receive_details),\n        },\n        mainline: MainlineMetricsResponse {\n            connected_peers: snap.mainline.connected_peers,\n            connection_attempts: snap.mainline.connection_attempts,\n            connection_successes: snap.mainline.connection_successes,\n            connection_failures: snap.mainline.connection_failures,\n            connection_last_success_ms: snap.mainline.connection_last_success_ms,\n            connection_last_failure_ms: snap.mainline.connection_last_failure_ms,\n            routing_attempts: snap.mainline.routing_attempts,\n            routing_successes: snap.mainline.routing_successes,\n            routing_failures: snap.mainline.routing_failures,\n            routing_success_rate: snap.mainline.routing_success_rate,\n            routing_last_success_ms: snap.mainline.routing_last_success_ms,\n            routing_last_failure_ms: snap.mainline.routing_last_failure_ms,\n            reconnect_attempts: snap.mainline.reconnect_attempts,\n            reconnect_successes: snap.mainline.reconnect_successes,\n            reconnect_failures: snap.mainline.reconnect_failures,\n            last_reconnect_success_ms: snap.mainline.last_reconnect_success_ms,\n            last_reconnect_failure_ms: snap.mainline.last_reconnect_failure_ms,\n            bootstrap: BootstrapMetricsResponse {\n                env_uses: snap.mainline.bootstrap.env_uses,\n                user_uses: snap.mainline.bootstrap.user_uses,\n                bundle_uses: snap.mainline.bootstrap.bundle_uses,\n                fallback_uses: snap.mainline.bootstrap.fallback_uses,\n                last_source: snap.mainline.bootstrap.last_source,\n                last_applied_ms: snap.mainline.bootstrap.last_applied_ms,\n            },\n        },\n    };\n    Ok(ApiResponse::success(response))\n}\n\nfn to_response_details(details: &GossipMetricDetails) -> GossipMetricDetailsResponse {\n    GossipMetricDetailsResponse {\n        total: details.total,\n        failures: details.failures,\n        last_success_ms: details.last_success_ms,\n        last_failure_ms: details.last_failure_ms,\n    }\n}\n","traces":[{"line":21,"address":[23925872,23926214,23925856,23926554,23926034,23925907,23925994,23925864],"length":1,"stats":{"Line":0}},{"line":22,"address":[18166513,18166790,18166565,18166627],"length":1,"stats":{"Line":0}},{"line":23,"address":[23912696],"length":1,"stats":{"Line":0}},{"line":28,"address":[24125888],"length":1,"stats":{"Line":0}},{"line":34,"address":[18167428],"length":1,"stats":{"Line":0}},{"line":37,"address":[23994923],"length":1,"stats":{"Line":0}},{"line":39,"address":[11507948],"length":1,"stats":{"Line":0}},{"line":41,"address":[24030779,24029846,24031132,24030893],"length":1,"stats":{"Line":0}},{"line":42,"address":[24033064,24035081,24035215,24033165,24033666],"length":1,"stats":{"Line":0}},{"line":44,"address":[24033073],"length":1,"stats":{"Line":0}},{"line":46,"address":[23988762,23989020],"length":1,"stats":{"Line":0}},{"line":52,"address":[24033872],"length":1,"stats":{"Line":0}},{"line":57,"address":[20716192],"length":1,"stats":{"Line":0}},{"line":59,"address":[23992093,23992231,23992315,23992540],"length":1,"stats":{"Line":0}},{"line":61,"address":[20717066,20717293,20716969,20716274],"length":1,"stats":{"Line":0}},{"line":62,"address":[18175065,18173774,18175199,18173172,18173273],"length":1,"stats":{"Line":0}},{"line":64,"address":[24038807],"length":1,"stats":{"Line":0}},{"line":66,"address":[24030984,24031224],"length":1,"stats":{"Line":0}},{"line":72,"address":[24033904],"length":1,"stats":{"Line":0}},{"line":81,"address":[11453681],"length":1,"stats":{"Line":0}},{"line":82,"address":[23922054],"length":1,"stats":{"Line":0}},{"line":87,"address":[23996832],"length":1,"stats":{"Line":0}},{"line":90,"address":[18176657,18176934,18176771,18176709],"length":1,"stats":{"Line":0}},{"line":91,"address":[24035638],"length":1,"stats":{"Line":0}},{"line":96,"address":[20721632],"length":1,"stats":{"Line":0}},{"line":99,"address":[24036150,24035987,24035873,24035925],"length":1,"stats":{"Line":0}},{"line":100,"address":[24041944],"length":1,"stats":{"Line":0}},{"line":106,"address":[18179924,18178126,18178080,18178096,18178245,18178215,18179833],"length":1,"stats":{"Line":0}},{"line":107,"address":[24036559],"length":1,"stats":{"Line":0}},{"line":108,"address":[24137056],"length":1,"stats":{"Line":0}},{"line":109,"address":[23924119,23924054],"length":1,"stats":{"Line":0}},{"line":110,"address":[24036919],"length":1,"stats":{"Line":0}},{"line":111,"address":[20722781,20722868],"length":1,"stats":{"Line":0}},{"line":113,"address":[24000272,24000256],"length":1,"stats":{"Line":0}},{"line":115,"address":[24037110,24037266,24038416,24038420],"length":1,"stats":{"Line":0}},{"line":116,"address":[24042866,24043089],"length":1,"stats":{"Line":0}},{"line":117,"address":[23999385,23999194],"length":1,"stats":{"Line":0}},{"line":118,"address":[20723175,20723291,20723082],"length":1,"stats":{"Line":0}},{"line":119,"address":[23938543,23938472],"length":1,"stats":{"Line":0}},{"line":121,"address":[23999273,23999335],"length":1,"stats":{"Line":0}},{"line":123,"address":[24037650,24037455],"length":1,"stats":{"Line":0}},{"line":124,"address":[20723303],"length":1,"stats":{"Line":0}},{"line":125,"address":[24137904],"length":1,"stats":{"Line":0}},{"line":126,"address":[18179165],"length":1,"stats":{"Line":0}},{"line":127,"address":[24041530],"length":1,"stats":{"Line":0}},{"line":128,"address":[24043207],"length":1,"stats":{"Line":0}},{"line":132,"address":[23931968],"length":1,"stats":{"Line":0}},{"line":133,"address":[23999628],"length":1,"stats":{"Line":0}},{"line":134,"address":[24138148],"length":1,"stats":{"Line":0}},{"line":135,"address":[24138182],"length":1,"stats":{"Line":0}},{"line":138,"address":[24043432],"length":1,"stats":{"Line":0}},{"line":144,"address":[24045405,24044051,24044110,24044188,24044080,24044878,24044048],"length":1,"stats":{"Line":0}},{"line":147,"address":[23932747,23932665],"length":1,"stats":{"Line":0}},{"line":148,"address":[23940768],"length":1,"stats":{"Line":0}},{"line":149,"address":[18181281],"length":1,"stats":{"Line":0}},{"line":153,"address":[24007598,24007742],"length":1,"stats":{"Line":0}},{"line":154,"address":[23940467,23939998],"length":1,"stats":{"Line":0}},{"line":155,"address":[24001333],"length":1,"stats":{"Line":0}},{"line":161,"address":[23933463,23933060,23932980,23933225],"length":1,"stats":{"Line":0}},{"line":162,"address":[18181472,18181490,18180697],"length":1,"stats":{"Line":0}},{"line":163,"address":[20724846,20724934],"length":1,"stats":{"Line":0}},{"line":167,"address":[24140384,24140430,24140400,24140479,24141034],"length":1,"stats":{"Line":0}},{"line":170,"address":[24001983,24002064],"length":1,"stats":{"Line":0}},{"line":171,"address":[23934658],"length":1,"stats":{"Line":0}},{"line":172,"address":[24046134],"length":1,"stats":{"Line":0}},{"line":176,"address":[20726168,20726268,20726027],"length":1,"stats":{"Line":0}},{"line":177,"address":[23934818,23934800,23934476],"length":1,"stats":{"Line":0}},{"line":178,"address":[24140745,24140846],"length":1,"stats":{"Line":0}},{"line":182,"address":[23941920],"length":1,"stats":{"Line":0}},{"line":185,"address":[24045056,24044938],"length":1,"stats":{"Line":0}},{"line":186,"address":[23929093],"length":1,"stats":{"Line":0}},{"line":187,"address":[23929062],"length":1,"stats":{"Line":0}},{"line":191,"address":[23935358,23935830,23935504,23935303],"length":1,"stats":{"Line":0}},{"line":192,"address":[18183785,18184061,18183156,18183683,18183295,18183003,18183233,18183900],"length":1,"stats":{"Line":0}},{"line":194,"address":[24003472],"length":1,"stats":{"Line":0}},{"line":195,"address":[11622353],"length":1,"stats":{"Line":0}},{"line":197,"address":[11622373],"length":1,"stats":{"Line":0}},{"line":201,"address":[23943792],"length":1,"stats":{"Line":0}},{"line":204,"address":[20728548,20729515,20728681,20728605,20728864],"length":1,"stats":{"Line":0}},{"line":205,"address":[24144272],"length":1,"stats":{"Line":0}},{"line":206,"address":[23938135],"length":1,"stats":{"Line":0}},{"line":207,"address":[24049679],"length":1,"stats":{"Line":0}},{"line":209,"address":[23938204],"length":1,"stats":{"Line":0}},{"line":210,"address":[24012969],"length":1,"stats":{"Line":0}},{"line":213,"address":[24049764],"length":1,"stats":{"Line":0}},{"line":214,"address":[24048187],"length":1,"stats":{"Line":0}},{"line":216,"address":[20729893,20730222,20729985],"length":1,"stats":{"Line":0}},{"line":217,"address":[23945729,23948789],"length":1,"stats":{"Line":0}},{"line":218,"address":[24009771],"length":1,"stats":{"Line":0}},{"line":219,"address":[20733306],"length":1,"stats":{"Line":0}},{"line":220,"address":[24053388],"length":1,"stats":{"Line":0}},{"line":225,"address":[20730159,20730268,20730448,20733136,20730395],"length":1,"stats":{"Line":0}},{"line":226,"address":[23932255],"length":1,"stats":{"Line":0}},{"line":227,"address":[23946733,23946539,23946041],"length":1,"stats":{"Line":0}},{"line":228,"address":[23939773],"length":1,"stats":{"Line":0}},{"line":229,"address":[24014710,24014645],"length":1,"stats":{"Line":0}},{"line":230,"address":[24007791],"length":1,"stats":{"Line":0}},{"line":233,"address":[24014656,24014945,24015029],"length":1,"stats":{"Line":0}},{"line":234,"address":[23933478,23933518],"length":1,"stats":{"Line":0}},{"line":239,"address":[24051217,24052001],"length":1,"stats":{"Line":0}},{"line":240,"address":[20732111,20733584,20733609,20732010],"length":1,"stats":{"Line":0}},{"line":241,"address":[20732245,20732298,20732642],"length":1,"stats":{"Line":0}},{"line":246,"address":[23934445,23933782],"length":1,"stats":{"Line":0}},{"line":247,"address":[24147717],"length":1,"stats":{"Line":0}},{"line":248,"address":[20732759],"length":1,"stats":{"Line":0}},{"line":249,"address":[24009162],"length":1,"stats":{"Line":0}},{"line":254,"address":[24013839],"length":1,"stats":{"Line":0}},{"line":259,"address":[23937135,23935489,23935424,23935440,23935558,23935588,23937090],"length":1,"stats":{"Line":0}},{"line":261,"address":[24052171],"length":1,"stats":{"Line":0}},{"line":263,"address":[24010482],"length":1,"stats":{"Line":0}},{"line":273,"address":[23950332],"length":1,"stats":{"Line":0}},{"line":301,"address":[23950711],"length":1,"stats":{"Line":0}},{"line":304,"address":[23888416],"length":1,"stats":{"Line":0}},{"line":306,"address":[23919611],"length":1,"stats":{"Line":0}},{"line":307,"address":[18061215],"length":1,"stats":{"Line":0}},{"line":308,"address":[23813699],"length":1,"stats":{"Line":0}},{"line":309,"address":[24019994],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":117},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","post_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            post_dto::{\n                BookmarkPostRequest, CreatePostRequest, DeletePostRequest,\n                FollowingFeedPageResponse, GetPostsRequest, ListFollowingFeedRequest,\n                ListTrendingPostsRequest, ListTrendingPostsResponse, PostResponse,\n                ReactToPostRequest,\n            },\n        },\n        handlers::PostHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// 投稿を作成する\n#[tauri::command]\npub async fn create_post(\n    state: State<'_, AppState>,\n    request: CreatePostRequest,\n) -> Result<ApiResponse<PostResponse>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.create_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を取得する\n#[tauri::command]\npub async fn get_posts(\n    state: State<'_, AppState>,\n    request: GetPostsRequest,\n) -> Result<ApiResponse<Vec<PostResponse>>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.get_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トレンドトピックごとの投稿を取得する\n#[tauri::command]\npub async fn list_trending_posts(\n    state: State<'_, AppState>,\n    request: ListTrendingPostsRequest,\n) -> Result<ApiResponse<ListTrendingPostsResponse>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.list_trending_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を削除する\n#[tauri::command]\npub async fn delete_post(\n    state: State<'_, AppState>,\n    request: DeletePostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.delete_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にリアクションする（内部ヘルパー）\nasync fn react_to_post(\n    state: &State<'_, AppState>,\n    request: ReactToPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.react_to_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブックマークする\n#[tauri::command]\npub async fn bookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.bookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ブックマークを解除する\n#[tauri::command]\npub async fn unbookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.unbookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にいいねする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn like_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"+\".to_string(),\n    };\n\n    react_to_post(&state, request).await\n}\n\n/// ブックマーク済み投稿IDを取得する\n#[tauri::command]\npub async fn get_bookmarked_post_ids(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<String>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.get_bookmarked_post_ids(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// フォロー中フィードを取得する\n#[tauri::command]\npub async fn list_following_feed(\n    state: State<'_, AppState>,\n    request: ListFollowingFeedRequest,\n) -> Result<ApiResponse<FollowingFeedPageResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.list_following_feed(&user_pubkey, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブーストする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn boost_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"boost\".to_string(),\n    };\n\n    react_to_post(&state, request).await\n}\n","traces":[{"line":19,"address":[23034544,23034560,23035282,23034552,23034677,23034595,23034717,23034900],"length":1,"stats":{"Line":0}},{"line":20,"address":[15211381,15211894,15211739,15211571,15211482],"length":1,"stats":{"Line":0}},{"line":23,"address":[17275248,17275476,17275376,17275420,17275683],"length":1,"stats":{"Line":0}},{"line":24,"address":[23035312,23035296],"length":1,"stats":{"Line":0}},{"line":25,"address":[23139958,23139936],"length":1,"stats":{"Line":0}},{"line":30,"address":[23336000],"length":1,"stats":{"Line":0}},{"line":35,"address":[23236043,23235938],"length":1,"stats":{"Line":0}},{"line":36,"address":[23236087,23236169],"length":1,"stats":{"Line":0}},{"line":37,"address":[23236213,23236284],"length":1,"stats":{"Line":0}},{"line":39,"address":[11420145],"length":1,"stats":{"Line":0}},{"line":40,"address":[23124281],"length":1,"stats":{"Line":0}},{"line":45,"address":[23138256],"length":1,"stats":{"Line":0}},{"line":50,"address":[15513898,15513999],"length":1,"stats":{"Line":0}},{"line":51,"address":[23338081,23337999],"length":1,"stats":{"Line":0}},{"line":52,"address":[23206573,23206644],"length":1,"stats":{"Line":0}},{"line":54,"address":[23238296,23237924,23238073,23237534],"length":1,"stats":{"Line":0}},{"line":55,"address":[23139564],"length":1,"stats":{"Line":0}},{"line":60,"address":[23207632],"length":1,"stats":{"Line":0}},{"line":65,"address":[23339531,23339426],"length":1,"stats":{"Line":0}},{"line":66,"address":[23133369,23133287],"length":1,"stats":{"Line":0}},{"line":67,"address":[23201221,23201292],"length":1,"stats":{"Line":0}},{"line":69,"address":[23339478,23339985,23339868,23340208],"length":1,"stats":{"Line":0}},{"line":70,"address":[15516336],"length":1,"stats":{"Line":0}},{"line":75,"address":[23202256],"length":1,"stats":{"Line":0}},{"line":80,"address":[23240623,23240728],"length":1,"stats":{"Line":0}},{"line":81,"address":[23128068,23128150],"length":1,"stats":{"Line":0}},{"line":82,"address":[23240969,23240898],"length":1,"stats":{"Line":0}},{"line":84,"address":[23142121,23142477,23141731,23142254],"length":1,"stats":{"Line":0}},{"line":85,"address":[23203521],"length":1,"stats":{"Line":0}},{"line":89,"address":[23028688],"length":1,"stats":{"Line":0}},{"line":93,"address":[23022147,23022427,23022202,23022275],"length":1,"stats":{"Line":0}},{"line":95,"address":[15213241,15213302],"length":1,"stats":{"Line":0}},{"line":96,"address":[23029832,23029750],"length":1,"stats":{"Line":0}},{"line":97,"address":[23141380,23141451],"length":1,"stats":{"Line":0}},{"line":99,"address":[23022220,23023693,23023391,23023259],"length":1,"stats":{"Line":0}},{"line":100,"address":[23105423],"length":1,"stats":{"Line":0}},{"line":105,"address":[23210736],"length":1,"stats":{"Line":0}},{"line":109,"address":[11440697],"length":1,"stats":{"Line":0}},{"line":111,"address":[23211541,23211691],"length":1,"stats":{"Line":0}},{"line":112,"address":[23242919,23243001],"length":1,"stats":{"Line":0}},{"line":113,"address":[23243045,23243116],"length":1,"stats":{"Line":0}},{"line":115,"address":[23205100,23205675,23205355,23204089],"length":1,"stats":{"Line":0}},{"line":116,"address":[17385596],"length":1,"stats":{"Line":0}},{"line":121,"address":[23249808],"length":1,"stats":{"Line":0}},{"line":125,"address":[11550633],"length":1,"stats":{"Line":0}},{"line":127,"address":[23146085,23146235],"length":1,"stats":{"Line":0}},{"line":128,"address":[23146361,23146279],"length":1,"stats":{"Line":0}},{"line":129,"address":[23132645,23132716],"length":1,"stats":{"Line":0}},{"line":131,"address":[19208988],"length":1,"stats":{"Line":0}},{"line":132,"address":[23251884],"length":1,"stats":{"Line":0}},{"line":137,"address":[23208416],"length":1,"stats":{"Line":0}},{"line":143,"address":[23347093],"length":1,"stats":{"Line":0}},{"line":146,"address":[11532225],"length":1,"stats":{"Line":0}},{"line":151,"address":[23251344],"length":1,"stats":{"Line":0}},{"line":154,"address":[23148723,23148593,23148860,23149208,23148648,23149978],"length":1,"stats":{"Line":0}},{"line":156,"address":[23217093,23216943],"length":1,"stats":{"Line":0}},{"line":157,"address":[23252257,23252339],"length":1,"stats":{"Line":0}},{"line":158,"address":[23248447,23248518],"length":1,"stats":{"Line":0}},{"line":160,"address":[23149670,23150025,23148666,23149768],"length":1,"stats":{"Line":0}},{"line":161,"address":[23349546],"length":1,"stats":{"Line":0}},{"line":166,"address":[23253328],"length":1,"stats":{"Line":0}},{"line":170,"address":[23211596,23211669,23212175,23211821,23211541],"length":1,"stats":{"Line":0}},{"line":172,"address":[23212150,23212300],"length":1,"stats":{"Line":0}},{"line":173,"address":[23151594,23151512],"length":1,"stats":{"Line":0}},{"line":174,"address":[23212541,23212470],"length":1,"stats":{"Line":0}},{"line":176,"address":[17391326,17392447,17392848,17392349],"length":1,"stats":{"Line":0}},{"line":177,"address":[23145563],"length":1,"stats":{"Line":0}},{"line":182,"address":[23145728],"length":1,"stats":{"Line":0}},{"line":188,"address":[23255781],"length":1,"stats":{"Line":0}},{"line":191,"address":[15527813,15527721,15527615,15527908],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":70},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","secure_storage_commands.rs"],"content":"use crate::{\n    domain::entities::AccountMetadata,\n    presentation::{\n        dto::{ApiResponse, auth_dto::LoginResponse},\n        handlers::secure_storage_handler::{\n            AddAccountRequest, AddAccountResponse, GetCurrentAccountResponse, SecureStorageHandler,\n            SwitchAccountResponse,\n        },\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\n/// アカウントを追加\n#[tauri::command]\npub async fn add_account(\n    state: State<'_, AppState>,\n    request: AddAccountRequest,\n) -> Result<ApiResponse<AddAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.add_account(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウント一覧を取得\n#[tauri::command]\npub async fn list_accounts(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<AccountMetadata>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.list_accounts().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを切り替え\n#[tauri::command]\npub async fn switch_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<SwitchAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.switch_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを削除\n#[tauri::command]\npub async fn remove_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.remove_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のアカウントを取得\n#[tauri::command]\npub async fn get_current_account(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<GetCurrentAccountResponse>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.get_current_account().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// セキュアログイン\n#[tauri::command]\npub async fn secure_login(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.secure_login(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":17,"address":[23352896],"length":1,"stats":{"Line":0}},{"line":21,"address":[23153971,23153856],"length":1,"stats":{"Line":0}},{"line":22,"address":[11534385],"length":1,"stats":{"Line":0}},{"line":23,"address":[23259082],"length":1,"stats":{"Line":0}},{"line":28,"address":[23222528],"length":1,"stats":{"Line":0}},{"line":31,"address":[23253825,23253939],"length":1,"stats":{"Line":0}},{"line":32,"address":[19272612],"length":1,"stats":{"Line":0}},{"line":33,"address":[23254409],"length":1,"stats":{"Line":0}},{"line":38,"address":[23148704],"length":1,"stats":{"Line":0}},{"line":42,"address":[23155990,23155875],"length":1,"stats":{"Line":0}},{"line":43,"address":[11518225],"length":1,"stats":{"Line":0}},{"line":44,"address":[23261034],"length":1,"stats":{"Line":0}},{"line":49,"address":[15531200],"length":1,"stats":{"Line":0}},{"line":53,"address":[23217862,23217747],"length":1,"stats":{"Line":0}},{"line":54,"address":[15531443,15531552,15531619,15531776],"length":1,"stats":{"Line":0}},{"line":55,"address":[23150560],"length":1,"stats":{"Line":0}},{"line":60,"address":[15532240],"length":1,"stats":{"Line":0}},{"line":63,"address":[23256884,23257001],"length":1,"stats":{"Line":0}},{"line":64,"address":[11539879],"length":1,"stats":{"Line":0}},{"line":65,"address":[23257455],"length":1,"stats":{"Line":0}},{"line":70,"address":[23226416],"length":1,"stats":{"Line":0}},{"line":74,"address":[23257910,23257795],"length":1,"stats":{"Line":0}},{"line":75,"address":[11466417],"length":1,"stats":{"Line":0}},{"line":76,"address":[23220330],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","topic_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            topic_dto::{\n                CreateTopicRequest, DeleteTopicRequest, EnqueueTopicCreationRequest,\n                EnqueueTopicCreationResponse, GetTopicStatsRequest, JoinTopicRequest,\n                ListTrendingTopicsRequest, ListTrendingTopicsResponse,\n                MarkPendingTopicFailedRequest, MarkPendingTopicSyncedRequest, PendingTopicResponse,\n                TopicResponse, TopicStatsResponse, UpdateTopicRequest,\n            },\n        },\n        handlers::TopicHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// トピックを作成する\n#[tauri::command]\npub async fn create_topic(\n    state: State<'_, AppState>,\n    request: CreateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.create_topic(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフライン用のトピック作成をキューに登録する\n#[tauri::command]\npub async fn enqueue_topic_creation(\n    state: State<'_, AppState>,\n    request: EnqueueTopicCreationRequest,\n) -> Result<ApiResponse<EnqueueTopicCreationResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.enqueue_topic_creation(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピック作成を取得する\n#[tauri::command]\npub async fn list_pending_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<PendingTopicResponse>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.list_pending_topics(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピックを同期済みに更新する\n#[tauri::command]\npub async fn mark_pending_topic_synced(\n    state: State<'_, AppState>,\n    request: MarkPendingTopicSyncedRequest,\n) -> Result<ApiResponse<PendingTopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler\n        .mark_pending_topic_synced(request, &user_pubkey)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピックを失敗としてマークする\n#[tauri::command]\npub async fn mark_pending_topic_failed(\n    state: State<'_, AppState>,\n    request: MarkPendingTopicFailedRequest,\n) -> Result<ApiResponse<PendingTopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler\n        .mark_pending_topic_failed(request, &user_pubkey)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// すべてのトピックを取得する\n#[tauri::command]\npub async fn get_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<TopicResponse>>, AppError> {\n    let user_pubkey = state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key)\n        .ok();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_all_topics(user_pubkey.as_deref()).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを更新する\n#[tauri::command]\npub async fn update_topic(\n    state: State<'_, AppState>,\n    request: UpdateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.update_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを削除する\n#[tauri::command]\npub async fn delete_topic(\n    state: State<'_, AppState>,\n    request: DeleteTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.delete_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックに参加する\n#[tauri::command]\npub async fn join_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let topic_id = request.topic_id.clone();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    match handler.join_topic(request, &user_pubkey).await {\n        Ok(_) => {\n            if let Err(e) = state.ensure_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to ensure UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックから離脱する\n#[tauri::command]\npub async fn leave_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let topic_id = request.topic_id.clone();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    match handler.leave_topic(request, &user_pubkey).await {\n        Ok(_) => {\n            if let Err(e) = state.stop_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to stop UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックの統計情報を取得する\n#[tauri::command]\npub async fn get_topic_stats(\n    state: State<'_, AppState>,\n    request: GetTopicStatsRequest,\n) -> Result<ApiResponse<TopicStatsResponse>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_topic_stats(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トレンドトピック一覧を取得する\n#[tauri::command]\npub async fn list_trending_topics(\n    state: State<'_, AppState>,\n    request: Option<ListTrendingTopicsRequest>,\n) -> Result<ApiResponse<ListTrendingTopicsResponse>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let payload = request.unwrap_or_default();\n    let result = handler.list_trending_topics(payload).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":20,"address":[18981973,18981840,18982196,18982578,18982013,18981856,18981848,18981891],"length":1,"stats":{"Line":0}},{"line":21,"address":[19024005,19024207,19024387,19024533,19024110],"length":1,"stats":{"Line":0}},{"line":24,"address":[19228052],"length":1,"stats":{"Line":0}},{"line":25,"address":[13162304,13162320],"length":1,"stats":{"Line":0}},{"line":26,"address":[19024774,19024752],"length":1,"stats":{"Line":0}},{"line":31,"address":[18982160],"length":1,"stats":{"Line":0}},{"line":35,"address":[11441500],"length":1,"stats":{"Line":0}},{"line":36,"address":[18996826,18996989],"length":1,"stats":{"Line":0}},{"line":37,"address":[19196704,19195593,19196945,19196374],"length":1,"stats":{"Line":0}},{"line":38,"address":[19058676],"length":1,"stats":{"Line":0}},{"line":43,"address":[18991024],"length":1,"stats":{"Line":0}},{"line":47,"address":[18998548,18998268,18998899,18998323,18998396],"length":1,"stats":{"Line":0}},{"line":48,"address":[19059866,19059703],"length":1,"stats":{"Line":0}},{"line":49,"address":[11710927],"length":1,"stats":{"Line":0}},{"line":50,"address":[19104349],"length":1,"stats":{"Line":0}},{"line":55,"address":[18999968],"length":1,"stats":{"Line":0}},{"line":58,"address":[11524271],"length":1,"stats":{"Line":0}},{"line":59,"address":[19061651,19061494],"length":1,"stats":{"Line":0}},{"line":60,"address":[19068901,19068748,19068650,19067914],"length":1,"stats":{"Line":0}},{"line":61,"address":[18987590],"length":1,"stats":{"Line":0}},{"line":66,"address":[19104416],"length":1,"stats":{"Line":0}},{"line":70,"address":[19104651,19105276,19104931,19104706,19104779],"length":1,"stats":{"Line":0}},{"line":71,"address":[19201683,19201840],"length":1,"stats":{"Line":0}},{"line":72,"address":[24108843,24109101,24108998,24109439],"length":1,"stats":{"Line":0}},{"line":73,"address":[13243467,13243333,13243160],"length":1,"stats":{"Line":0}},{"line":74,"address":[19107757,19107325,19107424,19107616,19106372],"length":1,"stats":{"Line":0}},{"line":75,"address":[18989529],"length":1,"stats":{"Line":0}},{"line":80,"address":[19202736],"length":1,"stats":{"Line":0}},{"line":84,"address":[13244203,13244331,13244483,13244828,13244258],"length":1,"stats":{"Line":0}},{"line":85,"address":[19107139,19107296],"length":1,"stats":{"Line":0}},{"line":86,"address":[19065319,19065474,19065589,19065947],"length":1,"stats":{"Line":0}},{"line":87,"address":[19004811,19004677,19004504],"length":1,"stats":{"Line":0}},{"line":88,"address":[11631775],"length":1,"stats":{"Line":0}},{"line":89,"address":[13245721],"length":1,"stats":{"Line":0}},{"line":94,"address":[13245856],"length":1,"stats":{"Line":0}},{"line":97,"address":[19066284,19066716,19066525,19066428,19066884],"length":1,"stats":{"Line":0}},{"line":100,"address":[11420591],"length":1,"stats":{"Line":0}},{"line":101,"address":[19067815,19067792],"length":1,"stats":{"Line":0}},{"line":103,"address":[24112279,24112202],"length":1,"stats":{"Line":0}},{"line":104,"address":[11538898],"length":1,"stats":{"Line":0}},{"line":105,"address":[19074469],"length":1,"stats":{"Line":0}},{"line":110,"address":[19106096],"length":1,"stats":{"Line":0}},{"line":114,"address":[11641728,11641657],"length":1,"stats":{"Line":0}},{"line":115,"address":[19111010],"length":1,"stats":{"Line":0}},{"line":116,"address":[19107175,19107358,19106440,19107578],"length":1,"stats":{"Line":0}},{"line":117,"address":[19113363],"length":1,"stats":{"Line":0}},{"line":122,"address":[13249504],"length":1,"stats":{"Line":0}},{"line":126,"address":[11428201,11428269],"length":1,"stats":{"Line":0}},{"line":127,"address":[19002854],"length":1,"stats":{"Line":0}},{"line":128,"address":[11428220],"length":1,"stats":{"Line":0}},{"line":129,"address":[19209788],"length":1,"stats":{"Line":0}},{"line":134,"address":[24116512],"length":1,"stats":{"Line":0}},{"line":138,"address":[11533583],"length":1,"stats":{"Line":0}},{"line":139,"address":[19004598],"length":1,"stats":{"Line":0}},{"line":140,"address":[19004848,19004764],"length":1,"stats":{"Line":0}},{"line":141,"address":[19078738,19080232,19079964,19079676],"length":1,"stats":{"Line":0}},{"line":143,"address":[13253443,13251543,13253332,13253667],"length":1,"stats":{"Line":0}},{"line":144,"address":[19083017,19081167,19083151,19081769,19081268],"length":1,"stats":{"Line":0}},{"line":146,"address":[13255602],"length":1,"stats":{"Line":0}},{"line":148,"address":[19080579,19080831],"length":1,"stats":{"Line":0}},{"line":154,"address":[19001936],"length":1,"stats":{"Line":0}},{"line":158,"address":[19084407,19083693,19083757,19083860,19084021],"length":1,"stats":{"Line":0}},{"line":159,"address":[24122314],"length":1,"stats":{"Line":0}},{"line":160,"address":[13257324,13257408],"length":1,"stats":{"Line":0}},{"line":161,"address":[19198870],"length":1,"stats":{"Line":0}},{"line":163,"address":[19004179,19002279,19004068,19004403],"length":1,"stats":{"Line":0}},{"line":164,"address":[19123577,19122975,19123076,19124959,19124825],"length":1,"stats":{"Line":0}},{"line":166,"address":[19122978],"length":1,"stats":{"Line":0}},{"line":168,"address":[19217423,19217171],"length":1,"stats":{"Line":0}},{"line":174,"address":[19119680],"length":1,"stats":{"Line":0}},{"line":178,"address":[19014070,19013955],"length":1,"stats":{"Line":0}},{"line":179,"address":[19220650,19220546,19220295,19220429],"length":1,"stats":{"Line":0}},{"line":180,"address":[19082392],"length":1,"stats":{"Line":0}},{"line":185,"address":[19120704],"length":1,"stats":{"Line":0}},{"line":189,"address":[19089701,19089818],"length":1,"stats":{"Line":0}},{"line":190,"address":[19221521,19221449],"length":1,"stats":{"Line":0}},{"line":191,"address":[24127876,24127541,24127755],"length":1,"stats":{"Line":0}},{"line":192,"address":[24128093],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","user_commands.rs"],"content":"use crate::application::ports::repositories::FollowListSort;\nuse crate::application::services::offline_service::OfflineServiceTrait;\nuse crate::application::services::user_search_service::{\n    DEFAULT_LIMIT as SEARCH_DEFAULT_LIMIT, MAX_LIMIT as SEARCH_MAX_LIMIT, SearchSort,\n    SearchUsersParams,\n};\nuse crate::application::services::{\n    OfflineService, ProfileAvatarService, UploadProfileAvatarInput, UserSearchService, UserService,\n};\nuse crate::domain::entities::offline::CacheMetadataUpdate;\nuse crate::domain::value_objects::offline::{CacheKey, CacheType};\nuse crate::presentation::dto::{\n    ApiResponse, Validate,\n    profile_avatar_dto::{\n        FetchProfileAvatarRequest, FetchProfileAvatarResponse, ProfileAvatarSyncRequest,\n        ProfileAvatarSyncResponse, UploadProfileAvatarRequest, UploadProfileAvatarResponse,\n    },\n    user_dto::{\n        GetFollowersRequest, GetFollowingRequest, PaginatedUserProfiles, SearchUsersRequest,\n        SearchUsersResponse, UpdatePrivacySettingsRequest, UserProfile as UserProfileDto,\n    },\n};\nuse crate::shared::AppError;\nuse chrono::{Duration, Utc};\nuse nostr_sdk::prelude::{FromBech32, PublicKey};\nuse serde_json::{Value, json};\nuse std::sync::Arc;\nuse tauri::State;\n\nfn map_user_to_profile(user: crate::domain::entities::User) -> UserProfileDto {\n    UserProfileDto {\n        npub: user.npub,\n        pubkey: user.pubkey,\n        name: user.name,\n        display_name: Some(user.profile.display_name),\n        about: Some(user.profile.bio),\n        picture: user.profile.avatar_url,\n        banner: None,\n        website: None,\n        nip05: user.nip05,\n        is_profile_public: Some(user.public_profile),\n        show_online_status: Some(user.show_online_status),\n    }\n}\n\n#[tauri::command]\npub async fn get_user(\n    npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service.get_user(&npub).await.and_then(|user| {\n        user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n            .transpose()\n    });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_user_by_pubkey(\n    pubkey: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service\n        .get_user_by_pubkey(&pubkey)\n        .await\n        .and_then(|user| {\n            user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .transpose()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn search_users(\n    request: SearchUsersRequest,\n    user_search_service: State<'_, Arc<UserSearchService>>,\n) -> Result<ApiResponse<SearchUsersResponse>, AppError> {\n    request.validate()?;\n\n    let trimmed_query = request.query.trim().to_string();\n    let limit = request\n        .limit\n        .map(|value| value as usize)\n        .unwrap_or(SEARCH_DEFAULT_LIMIT)\n        .clamp(1, SEARCH_MAX_LIMIT);\n    let sort = SearchSort::try_from_str(request.sort.as_deref())?;\n    let viewer_pubkey = if let Some(npub) = request.viewer_npub.as_deref() {\n        Some(\n            PublicKey::from_bech32(npub)\n                .map_err(|_| AppError::InvalidInput(\"Invalid viewer npub\".into()))?\n                .to_hex(),\n        )\n    } else {\n        None\n    };\n\n    let params = SearchUsersParams {\n        query: trimmed_query,\n        cursor: request.cursor.clone(),\n        limit,\n        sort,\n        allow_incomplete: request.allow_incomplete.unwrap_or(false),\n        viewer_pubkey,\n    };\n\n    let result = user_search_service.search(params).await?;\n    let response = SearchUsersResponse {\n        items: result.users.into_iter().map(map_user_to_profile).collect(),\n        next_cursor: result.next_cursor,\n        has_more: result.has_more,\n        total_count: result.total_count as u64,\n        took_ms: result.took_ms.min(u64::MAX as u128) as u64,\n    };\n\n    Ok(ApiResponse::success(response))\n}\n\n#[tauri::command]\npub async fn update_privacy_settings(\n    request: UpdatePrivacySettingsRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    request.validate()?;\n\n    let result = user_service\n        .update_privacy_settings(\n            &request.npub,\n            request.public_profile,\n            request.show_online_status,\n        )\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn follow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service.follow_user(&follower_npub, &target_npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn unfollow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service\n        .unfollow_user(&follower_npub, &target_npub)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_followers(\n    request: GetFollowersRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<PaginatedUserProfiles>, AppError> {\n    let limit = request.limit.unwrap_or(25).min(100) as usize;\n    let sort = match request.sort.as_deref() {\n        Some(value) => FollowListSort::try_from(value)\n            .map_err(|_| AppError::InvalidInput(format!(\"Unsupported followers sort: {value}\")))?,\n        None => FollowListSort::Recent,\n    };\n    let search = request\n        .search\n        .as_ref()\n        .map(|s| s.trim())\n        .filter(|s| !s.is_empty());\n    let result = user_service\n        .get_followers_paginated(\n            &request.npub,\n            request.cursor.as_deref(),\n            limit,\n            sort,\n            search,\n            request.viewer_npub.as_deref(),\n        )\n        .await\n        .map(|page| PaginatedUserProfiles {\n            items: page.users.into_iter().map(map_user_to_profile).collect(),\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            total_count: page.total_count,\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_following(\n    request: GetFollowingRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<PaginatedUserProfiles>, AppError> {\n    let limit = request.limit.unwrap_or(25).min(100) as usize;\n    let sort = match request.sort.as_deref() {\n        Some(value) => FollowListSort::try_from(value)\n            .map_err(|_| AppError::InvalidInput(format!(\"Unsupported following sort: {value}\")))?,\n        None => FollowListSort::Recent,\n    };\n    let search = request\n        .search\n        .as_ref()\n        .map(|s| s.trim())\n        .filter(|s| !s.is_empty());\n    let result = user_service\n        .get_following_paginated(\n            &request.npub,\n            request.cursor.as_deref(),\n            limit,\n            sort,\n            search,\n            request.viewer_npub.as_deref(),\n        )\n        .await\n        .map(|page| PaginatedUserProfiles {\n            items: page.users.into_iter().map(map_user_to_profile).collect(),\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            total_count: page.total_count,\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn upload_profile_avatar(\n    request: UploadProfileAvatarRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n) -> Result<ApiResponse<UploadProfileAvatarResponse>, AppError> {\n    let input = UploadProfileAvatarInput {\n        npub: request.npub,\n        bytes: request.bytes,\n        format: request.format,\n        access_level: request.access_level,\n    };\n    let result = avatar_service\n        .upload_avatar(input)\n        .await\n        .map(UploadProfileAvatarResponse::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn fetch_profile_avatar(\n    request: FetchProfileAvatarRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n) -> Result<ApiResponse<FetchProfileAvatarResponse>, AppError> {\n    let result = avatar_service\n        .fetch_avatar(&request.npub)\n        .await\n        .map(FetchProfileAvatarResponse::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn profile_avatar_sync(\n    request: ProfileAvatarSyncRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n    offline_service: State<'_, Arc<OfflineService>>,\n) -> Result<ApiResponse<ProfileAvatarSyncResponse>, AppError> {\n    let npub = request.npub.clone();\n    let response = match avatar_service.fetch_avatar(&request.npub).await {\n        Ok(result) => {\n            let current_version = result.metadata.version;\n            let fetch_response = FetchProfileAvatarResponse::from(result);\n\n            if let Some(known) = request.known_doc_version {\n                if known >= current_version {\n                    ProfileAvatarSyncResponse {\n                        npub,\n                        current_version: Some(current_version),\n                        updated: false,\n                        avatar: None,\n                    }\n                } else {\n                    ProfileAvatarSyncResponse {\n                        npub,\n                        current_version: Some(current_version),\n                        updated: true,\n                        avatar: Some(fetch_response),\n                    }\n                }\n            } else {\n                ProfileAvatarSyncResponse {\n                    npub,\n                    current_version: Some(current_version),\n                    updated: true,\n                    avatar: Some(fetch_response),\n                }\n            }\n        }\n        Err(AppError::NotFound(_)) => ProfileAvatarSyncResponse {\n            npub,\n            current_version: None,\n            updated: false,\n            avatar: None,\n        },\n        Err(err) => return Err(err),\n    };\n\n    record_profile_avatar_sync_metadata(offline_service.as_ref(), &request, &response).await?;\n\n    Ok(ApiResponse::success(response))\n}\n\nasync fn record_profile_avatar_sync_metadata(\n    offline_service: &OfflineService,\n    request: &ProfileAvatarSyncRequest,\n    response: &ProfileAvatarSyncResponse,\n) -> Result<(), AppError> {\n    let cache_key = CacheKey::new(format!(\"doc::profile_avatar::{}\", request.npub))\n        .map_err(AppError::InvalidInput)?;\n    let cache_type =\n        CacheType::new(\"profile_avatar\".to_string()).map_err(AppError::InvalidInput)?;\n\n    let payload_bytes = response\n        .avatar\n        .as_ref()\n        .and_then(|avatar| i64::try_from(avatar.size_bytes).ok());\n\n    let metadata = json!({\n        \"npub\": request.npub,\n        \"source\": request.source,\n        \"requestedAt\": request.requested_at,\n        \"retryCount\": request.retry_count,\n        \"jobId\": request.job_id,\n        \"knownDocVersion\": request.known_doc_version,\n        \"result\": {\n            \"updated\": response.updated,\n            \"currentVersion\": response.current_version,\n            \"avatar\": response.avatar.as_ref().map(|avatar| {\n                json!({\n                    \"blobHash\": avatar.blob_hash,\n                    \"docVersion\": avatar.doc_version,\n                    \"sizeBytes\": avatar.size_bytes,\n                })\n            }),\n        },\n        \"loggedAt\": Utc::now().to_rfc3339(),\n    });\n\n    let update = CacheMetadataUpdate {\n        cache_key,\n        cache_type,\n        metadata: Some(metadata),\n        expiry: Some(Utc::now() + Duration::minutes(30)),\n        is_stale: Some(false),\n        doc_version: response.current_version.map(|version| version as i64),\n        blob_hash: response\n            .avatar\n            .as_ref()\n            .map(|avatar| avatar.blob_hash.clone()),\n        payload_bytes,\n    };\n\n    offline_service.upsert_cache_metadata(update).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::services::OfflineService;\n    use crate::domain::entities::ProfileAvatarAccessLevel;\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    #[tokio::test]\n    async fn record_profile_avatar_sync_metadata_persists_cache_entry() {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .expect(\"sqlite memory pool\");\n        sqlx::migrate!(\"./migrations\")\n            .run(&pool)\n            .await\n            .expect(\"migrations\");\n\n        let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n        let offline_service = OfflineService::new(persistence);\n\n        let request = ProfileAvatarSyncRequest {\n            npub: \"npub1test\".to_string(),\n            known_doc_version: Some(2),\n            source: Some(\"profile-avatar-sync-worker:interval\".to_string()),\n            requested_at: Some(\"2025-11-12T00:00:00Z\".to_string()),\n            retry_count: Some(1),\n            job_id: Some(\"job-42\".to_string()),\n        };\n\n        let response = ProfileAvatarSyncResponse {\n            npub: \"npub1test\".to_string(),\n            current_version: Some(4),\n            updated: true,\n            avatar: Some(FetchProfileAvatarResponse {\n                npub: \"npub1test\".to_string(),\n                blob_hash: \"bafy-avatar\".to_string(),\n                format: \"image/png\".to_string(),\n                size_bytes: 1_024,\n                access_level: ProfileAvatarAccessLevel::ContactsOnly,\n                share_ticket: \"ticket\".to_string(),\n                doc_version: 4,\n                updated_at: \"2025-11-12T00:00:00Z\".to_string(),\n                content_sha256: \"abcd\".to_string(),\n                data_base64: \"AAECAw==\".to_string(),\n            }),\n        };\n\n        record_profile_avatar_sync_metadata(&offline_service, &request, &response)\n            .await\n            .expect(\"metadata recorded\");\n\n        let row: (String, Option<i64>, Option<String>, Option<i64>) = sqlx::query_as(\n            \"SELECT cache_key, doc_version, blob_hash, payload_bytes FROM cache_metadata WHERE cache_key = ?1\",\n        )\n        .bind(\"doc::profile_avatar::npub1test\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"metadata row\");\n\n        assert_eq!(row.0, \"doc::profile_avatar::npub1test\");\n        assert_eq!(row.1, Some(4));\n        assert_eq!(row.2.as_deref(), Some(\"bafy-avatar\"));\n        assert_eq!(row.3, Some(1_024));\n    }\n}\n","traces":[{"line":30,"address":[16017520],"length":1,"stats":{"Line":0}},{"line":32,"address":[16017548],"length":1,"stats":{"Line":0}},{"line":33,"address":[15980806],"length":1,"stats":{"Line":0}},{"line":34,"address":[16012017],"length":1,"stats":{"Line":0}},{"line":35,"address":[23674322],"length":1,"stats":{"Line":0}},{"line":36,"address":[16016055],"length":1,"stats":{"Line":0}},{"line":37,"address":[16017787],"length":1,"stats":{"Line":0}},{"line":40,"address":[23674547],"length":1,"stats":{"Line":0}},{"line":41,"address":[16016256],"length":1,"stats":{"Line":0}},{"line":42,"address":[16112704],"length":1,"stats":{"Line":0}},{"line":47,"address":[23714864],"length":1,"stats":{"Line":0}},{"line":51,"address":[11530158],"length":1,"stats":{"Line":0}},{"line":52,"address":[16153997,16153934,16153984],"length":1,"stats":{"Line":0}},{"line":55,"address":[16015166],"length":1,"stats":{"Line":0}},{"line":59,"address":[16053680],"length":1,"stats":{"Line":0}},{"line":63,"address":[16057997,16057954,16058216,16057782,16057897,16058278],"length":1,"stats":{"Line":0}},{"line":64,"address":[16022793],"length":1,"stats":{"Line":0}},{"line":65,"address":[16015973,16015925,16016029,16016170,16015786],"length":1,"stats":{"Line":0}},{"line":66,"address":[16058576],"length":1,"stats":{"Line":0}},{"line":67,"address":[16054704,16054717,16054654],"length":1,"stats":{"Line":0}},{"line":70,"address":[15941662],"length":1,"stats":{"Line":0}},{"line":74,"address":[21190720],"length":1,"stats":{"Line":0}},{"line":78,"address":[15956307,15956404,15958374,15956185],"length":1,"stats":{"Line":0}},{"line":80,"address":[21191257,21191415],"length":1,"stats":{"Line":0}},{"line":81,"address":[16059484,16059583],"length":1,"stats":{"Line":0}},{"line":83,"address":[21194704,21194708],"length":1,"stats":{"Line":0}},{"line":86,"address":[16156253,16157658,16156080],"length":1,"stats":{"Line":0}},{"line":87,"address":[15957078,15956905,15957207],"length":1,"stats":{"Line":0}},{"line":89,"address":[21192023,21192463,21192096,21192286],"length":1,"stats":{"Line":0}},{"line":90,"address":[16056322,16058880,16058898],"length":1,"stats":{"Line":0}},{"line":94,"address":[21192042],"length":1,"stats":{"Line":0}},{"line":99,"address":[23718789],"length":1,"stats":{"Line":0}},{"line":102,"address":[16018505],"length":1,"stats":{"Line":0}},{"line":106,"address":[16157355,16157746,16157255,16158331,16155558],"length":1,"stats":{"Line":0}},{"line":108,"address":[16158264,16158457],"length":1,"stats":{"Line":0}},{"line":109,"address":[16063727],"length":1,"stats":{"Line":0}},{"line":110,"address":[16062119],"length":1,"stats":{"Line":0}},{"line":111,"address":[15945490],"length":1,"stats":{"Line":0}},{"line":112,"address":[15945503],"length":1,"stats":{"Line":0}},{"line":115,"address":[15959452],"length":1,"stats":{"Line":0}},{"line":119,"address":[16020928],"length":1,"stats":{"Line":0}},{"line":123,"address":[16159593,16159781,16159703],"length":1,"stats":{"Line":0}},{"line":125,"address":[16063417,16063479,16063845,16063324,16063543],"length":1,"stats":{"Line":0}},{"line":127,"address":[16159865],"length":1,"stats":{"Line":0}},{"line":128,"address":[16021426],"length":1,"stats":{"Line":0}},{"line":131,"address":[19273236],"length":1,"stats":{"Line":0}},{"line":132,"address":[16021908],"length":1,"stats":{"Line":0}},{"line":136,"address":[16160544],"length":1,"stats":{"Line":0}},{"line":141,"address":[16022286,16022338,16022401,16022638],"length":1,"stats":{"Line":0}},{"line":142,"address":[16029779],"length":1,"stats":{"Line":0}},{"line":146,"address":[23723552],"length":1,"stats":{"Line":0}},{"line":151,"address":[16065709,16065892,16065553,16065438,16065666],"length":1,"stats":{"Line":0}},{"line":152,"address":[15948929],"length":1,"stats":{"Line":0}},{"line":153,"address":[11642449],"length":1,"stats":{"Line":0}},{"line":154,"address":[15949363],"length":1,"stats":{"Line":0}},{"line":158,"address":[16024272],"length":1,"stats":{"Line":0}},{"line":162,"address":[16031522,16031666],"length":1,"stats":{"Line":0}},{"line":163,"address":[23725170],"length":1,"stats":{"Line":0}},{"line":164,"address":[16066947,16067213,16067057],"length":1,"stats":{"Line":0}},{"line":165,"address":[16026336,16026358,16025112],"length":1,"stats":{"Line":0}},{"line":166,"address":[16163369],"length":1,"stats":{"Line":0}},{"line":168,"address":[16063322,16063077],"length":1,"stats":{"Line":0}},{"line":171,"address":[23726912,23726921],"length":1,"stats":{"Line":0}},{"line":172,"address":[16064672,16064684],"length":1,"stats":{"Line":0}},{"line":173,"address":[16063446,16063741,16064319,16063817,16064172],"length":1,"stats":{"Line":0}},{"line":175,"address":[21199199],"length":1,"stats":{"Line":0}},{"line":176,"address":[16069155],"length":1,"stats":{"Line":0}},{"line":178,"address":[15950923],"length":1,"stats":{"Line":0}},{"line":180,"address":[16067574],"length":1,"stats":{"Line":0}},{"line":182,"address":[11442721],"length":1,"stats":{"Line":0}},{"line":183,"address":[23726992,23727280,23727198],"length":1,"stats":{"Line":0}},{"line":184,"address":[15952122,15952037],"length":1,"stats":{"Line":0}},{"line":185,"address":[16068818],"length":1,"stats":{"Line":0}},{"line":186,"address":[16068854],"length":1,"stats":{"Line":0}},{"line":187,"address":[21200558],"length":1,"stats":{"Line":0}},{"line":189,"address":[16164714],"length":1,"stats":{"Line":0}},{"line":193,"address":[21200672],"length":1,"stats":{"Line":0}},{"line":197,"address":[16065506,16065362],"length":1,"stats":{"Line":0}},{"line":198,"address":[16069490],"length":1,"stats":{"Line":0}},{"line":199,"address":[16065777,16065933,16065667],"length":1,"stats":{"Line":0}},{"line":200,"address":[15959960,15961184,15961206],"length":1,"stats":{"Line":0}},{"line":201,"address":[15959737],"length":1,"stats":{"Line":0}},{"line":203,"address":[16166346,16166101],"length":1,"stats":{"Line":0}},{"line":206,"address":[15968361,15968352],"length":1,"stats":{"Line":0}},{"line":207,"address":[15954636,15954624],"length":1,"stats":{"Line":0}},{"line":208,"address":[16035791,16035289,16035213,16034918,16035644],"length":1,"stats":{"Line":0}},{"line":210,"address":[23728435],"length":1,"stats":{"Line":0}},{"line":211,"address":[16035043],"length":1,"stats":{"Line":0}},{"line":213,"address":[16028171],"length":1,"stats":{"Line":0}},{"line":215,"address":[15953590],"length":1,"stats":{"Line":0}},{"line":217,"address":[15967502,15967766,15967948,15967562,15966491],"length":1,"stats":{"Line":0}},{"line":218,"address":[21203204,21202928,21203122],"length":1,"stats":{"Line":0}},{"line":219,"address":[23729754,23729669],"length":1,"stats":{"Line":0}},{"line":220,"address":[16167906],"length":1,"stats":{"Line":0}},{"line":221,"address":[16067574],"length":1,"stats":{"Line":0}},{"line":222,"address":[16167946],"length":1,"stats":{"Line":0}},{"line":224,"address":[16028890],"length":1,"stats":{"Line":0}},{"line":228,"address":[15961776],"length":1,"stats":{"Line":0}},{"line":233,"address":[16168309],"length":1,"stats":{"Line":0}},{"line":234,"address":[16071903],"length":1,"stats":{"Line":0}},{"line":235,"address":[23730265],"length":1,"stats":{"Line":0}},{"line":236,"address":[16029910],"length":1,"stats":{"Line":0}},{"line":238,"address":[15969704,15969200,15969428,15969769,15969315,15969482],"length":1,"stats":{"Line":0}},{"line":239,"address":[16072216],"length":1,"stats":{"Line":0}},{"line":240,"address":[16030397,16030084,16030287,16030538,16030341],"length":1,"stats":{"Line":0}},{"line":242,"address":[15956036],"length":1,"stats":{"Line":0}},{"line":246,"address":[15956224],"length":1,"stats":{"Line":0}},{"line":250,"address":[16031492,16031100,16031203,16030985,16031427,16031157],"length":1,"stats":{"Line":0}},{"line":251,"address":[16073164],"length":1,"stats":{"Line":0}},{"line":252,"address":[11568241],"length":1,"stats":{"Line":0}},{"line":254,"address":[16069628],"length":1,"stats":{"Line":0}},{"line":258,"address":[15957104],"length":1,"stats":{"Line":0}},{"line":263,"address":[16074323,16074154],"length":1,"stats":{"Line":0}},{"line":264,"address":[11453903],"length":1,"stats":{"Line":0}},{"line":265,"address":[16076598],"length":1,"stats":{"Line":0}},{"line":266,"address":[23733293],"length":1,"stats":{"Line":0}},{"line":267,"address":[16032930,16033007],"length":1,"stats":{"Line":0}},{"line":269,"address":[16039943],"length":1,"stats":{"Line":0}},{"line":270,"address":[16075708,16075109],"length":1,"stats":{"Line":0}},{"line":273,"address":[16033738],"length":1,"stats":{"Line":0}},{"line":280,"address":[23733827],"length":1,"stats":{"Line":0}},{"line":282,"address":[16033463],"length":1,"stats":{"Line":0}},{"line":288,"address":[15972316],"length":1,"stats":{"Line":0}},{"line":290,"address":[16040096],"length":1,"stats":{"Line":0}},{"line":300,"address":[16041164],"length":1,"stats":{"Line":0}},{"line":303,"address":[10805630],"length":1,"stats":{"Line":0}},{"line":305,"address":[16077060,16077254],"length":1,"stats":{"Line":0}},{"line":308,"address":[16012736],"length":1,"stats":{"Line":1}},{"line":313,"address":[15900385,15900510,15905841,15900874],"length":1,"stats":{"Line":2}},{"line":314,"address":[16019114],"length":1,"stats":{"Line":0}},{"line":315,"address":[16013496,16013888,16013672],"length":1,"stats":{"Line":2}},{"line":318,"address":[15975914,15975750],"length":1,"stats":{"Line":2}},{"line":321,"address":[16022896,16022905],"length":1,"stats":{"Line":2}},{"line":323,"address":[21054747,21056413,21055292,21055375,21052380,21054827],"length":1,"stats":{"Line":3}},{"line":333,"address":[16077616,16020410,16078472,16078522,16020479],"length":1,"stats":{"Line":3}},{"line":334,"address":[15974766,15975601,15975570],"length":1,"stats":{"Line":1}},{"line":341,"address":[23679363,23679300],"length":1,"stats":{"Line":2}},{"line":347,"address":[16117885],"length":1,"stats":{"Line":1}},{"line":348,"address":[15979505,15979437],"length":1,"stats":{"Line":2}},{"line":349,"address":[15986523],"length":1,"stats":{"Line":1}},{"line":350,"address":[16017715,16019016,16019008],"length":1,"stats":{"Line":3}},{"line":351,"address":[15911851],"length":1,"stats":{"Line":1}},{"line":358,"address":[11569124],"length":1,"stats":{"Line":2}}],"covered":15,"coverable":143},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","utils_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::shared::AppError;\nuse nostr_sdk::prelude::*;\n\n/// 16進数の公開鍵をnpub（Bech32形式）に変換\n#[tauri::command]\npub fn pubkey_to_npub(pubkey: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_hex(&pubkey)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効な公開鍵: {e}\")))?;\n\n    let npub = public_key\n        .to_bech32()\n        .map_err(|e| AppError::InvalidInput(format!(\"Bech32変換エラー: {e}\")))?;\n\n    Ok(ApiResponse::success(npub))\n}\n\n/// npub（Bech32形式）を16進数の公開鍵に変換\n#[tauri::command]\npub fn npub_to_pubkey(npub: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_bech32(&npub)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効なnpub: {e}\")))?;\n\n    Ok(ApiResponse::success(public_key.to_hex()))\n}\n","traces":[{"line":7,"address":[12948378,12948410,12947616],"length":1,"stats":{"Line":0}},{"line":8,"address":[12837866,12838078,12838552,12837790],"length":1,"stats":{"Line":0}},{"line":9,"address":[12944496,12944512,12943959],"length":1,"stats":{"Line":0}},{"line":11,"address":[12949611,12949886,12949514],"length":1,"stats":{"Line":0}},{"line":13,"address":[12913472,12913070,12913489],"length":1,"stats":{"Line":0}},{"line":15,"address":[12845238,12845426],"length":1,"stats":{"Line":0}},{"line":20,"address":[12913648,12914067],"length":1,"stats":{"Line":0}},{"line":21,"address":[12906818,12907026,12906750],"length":1,"stats":{"Line":0}},{"line":22,"address":[12945099,12945280,12945302],"length":1,"stats":{"Line":0}},{"line":24,"address":[12945087,12945164],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","access_control_dto.rs"],"content":"use crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlIssueInviteRequest {\n    pub topic_id: String,\n    pub expires_in: Option<i64>,\n    pub max_uses: Option<i64>,\n    pub nonce: Option<String>,\n}\n\nimpl Validate for AccessControlIssueInviteRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.trim().is_empty() {\n            return Err(\"topic_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlIssueInviteResponse {\n    pub invite_event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlJoinRequest {\n    pub topic_id: Option<String>,\n    pub scope: Option<String>,\n    pub invite_event_json: Option<serde_json::Value>,\n    pub target_pubkey: Option<String>,\n    pub broadcast_to_topic: Option<bool>,\n}\n\nimpl Validate for AccessControlJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.invite_event_json.is_none() {\n            let topic = self.topic_id.as_ref().map(|v| v.trim()).unwrap_or(\"\");\n            if topic.is_empty() {\n                return Err(\"topic_id is required when invite_event_json is absent\".to_string());\n            }\n            if let Some(scope) = self.scope.as_ref() {\n                if scope.trim().is_empty() {\n                    return Err(\"scope must not be empty when provided\".to_string());\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlJoinResponse {\n    pub event_id: String,\n    pub sent_topics: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlPendingJoinRequest {\n    pub event_id: String,\n    pub topic_id: String,\n    pub scope: String,\n    pub requester_pubkey: String,\n    pub target_pubkey: Option<String>,\n    pub requested_at: Option<i64>,\n    pub received_at: i64,\n    pub invite_event_json: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlListJoinRequestsResponse {\n    pub items: Vec<AccessControlPendingJoinRequest>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlApproveJoinRequest {\n    pub event_id: String,\n}\n\nimpl Validate for AccessControlApproveJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.event_id.trim().is_empty() {\n            return Err(\"event_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlApproveJoinResponse {\n    pub event_id: String,\n    pub key_envelope_event_id: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlRejectJoinRequest {\n    pub event_id: String,\n}\n\nimpl Validate for AccessControlRejectJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.event_id.trim().is_empty() {\n            return Err(\"event_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[14258512],"length":1,"stats":{"Line":0}},{"line":14,"address":[16451166],"length":1,"stats":{"Line":0}},{"line":15,"address":[14364517],"length":1,"stats":{"Line":0}},{"line":17,"address":[16451206],"length":1,"stats":{"Line":0}},{"line":36,"address":[14251888],"length":1,"stats":{"Line":0}},{"line":37,"address":[14464992],"length":1,"stats":{"Line":0}},{"line":38,"address":[14259024,14259033,14258746],"length":1,"stats":{"Line":0}},{"line":39,"address":[14370302],"length":1,"stats":{"Line":0}},{"line":40,"address":[14465146],"length":1,"stats":{"Line":0}},{"line":42,"address":[14258914,14258812],"length":1,"stats":{"Line":0}},{"line":43,"address":[14252140],"length":1,"stats":{"Line":0}},{"line":44,"address":[14368816],"length":1,"stats":{"Line":0}},{"line":48,"address":[16451346],"length":1,"stats":{"Line":0}},{"line":81,"address":[14364976],"length":1,"stats":{"Line":0}},{"line":82,"address":[14266062],"length":1,"stats":{"Line":0}},{"line":83,"address":[16451761],"length":1,"stats":{"Line":0}},{"line":85,"address":[14259122],"length":1,"stats":{"Line":0}},{"line":101,"address":[14259216],"length":1,"stats":{"Line":0}},{"line":102,"address":[14333982],"length":1,"stats":{"Line":0}},{"line":103,"address":[14465585],"length":1,"stats":{"Line":0}},{"line":105,"address":[14327090],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","auth_dto.rs"],"content":"use super::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginResponse {\n    pub success: bool,\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginWithNsecRequest {\n    pub nsec: String,\n}\n\nimpl Validate for LoginWithNsecRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.trim().is_empty() {\n            return Err(\"秘密鍵が必要です\".to_string());\n        }\n        if !self.nsec.starts_with(\"nsec1\") {\n            return Err(\"無効な秘密鍵形式です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ExportPrivateKeyRequest {\n    pub npub: String,\n}\n\nimpl Validate for ExportPrivateKeyRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.npub.trim().is_empty() {\n            return Err(\"npub is required\".to_string());\n        }\n        if !self.npub.starts_with(\"npub1\") {\n            return Err(\"npub must start with npub1\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ExportPrivateKeyResponse {\n    pub nsec: String,\n}\n","traces":[{"line":17,"address":[13162672],"length":1,"stats":{"Line":0}},{"line":18,"address":[13162704],"length":1,"stats":{"Line":0}},{"line":19,"address":[18908471],"length":1,"stats":{"Line":0}},{"line":21,"address":[13162740],"length":1,"stats":{"Line":0}},{"line":22,"address":[14395615],"length":1,"stats":{"Line":0}},{"line":24,"address":[18922348],"length":1,"stats":{"Line":0}},{"line":41,"address":[18915408],"length":1,"stats":{"Line":0}},{"line":42,"address":[18915440],"length":1,"stats":{"Line":0}},{"line":43,"address":[19121799],"length":1,"stats":{"Line":0}},{"line":45,"address":[14395780],"length":1,"stats":{"Line":0}},{"line":46,"address":[14395871],"length":1,"stats":{"Line":0}},{"line":48,"address":[19027132],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","community_node_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeRoleConfig {\n    pub labels: bool,\n    pub trust: bool,\n    pub search: bool,\n    pub bootstrap: bool,\n}\n\nimpl Default for CommunityNodeRoleConfig {\n    fn default() -> Self {\n        Self {\n            labels: true,\n            trust: true,\n            search: false,\n            bootstrap: true,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigNodeRequest {\n    pub base_url: String,\n    pub roles: Option<CommunityNodeRoleConfig>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigRequest {\n    pub nodes: Vec<CommunityNodeConfigNodeRequest>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigNodeResponse {\n    pub base_url: String,\n    pub roles: CommunityNodeRoleConfig,\n    pub has_token: bool,\n    pub token_expires_at: Option<i64>,\n    pub pubkey: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigResponse {\n    pub nodes: Vec<CommunityNodeConfigNodeResponse>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeAuthResponse {\n    pub expires_at: i64,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeLabelsRequest {\n    pub base_url: Option<String>,\n    pub target: String,\n    pub topic: Option<String>,\n    pub limit: Option<usize>,\n    pub cursor: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustRequest {\n    pub base_url: Option<String>,\n    pub subject: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustAnchorRequest {\n    pub attester: String,\n    pub claim: Option<String>,\n    pub topic: Option<String>,\n    pub weight: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustAnchorState {\n    pub attester: String,\n    pub claim: Option<String>,\n    pub topic: Option<String>,\n    pub weight: f64,\n    pub issued_at: i64,\n    pub event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeSearchRequest {\n    pub base_url: Option<String>,\n    pub topic: String,\n    pub q: Option<String>,\n    pub limit: Option<usize>,\n    pub cursor: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConsentRequest {\n    pub base_url: Option<String>,\n    pub policy_ids: Option<Vec<String>>,\n    pub accept_all_current: Option<bool>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeReportRequest {\n    pub base_url: Option<String>,\n    pub report_event_json: Option<serde_json::Value>,\n    pub target: Option<String>,\n    pub reason: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeAuthRequest {\n    pub base_url: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTokenRequest {\n    pub base_url: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeBootstrapServicesRequest {\n    pub base_url: Option<String>,\n    pub topic_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","direct_message_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// 送信要求。暗号化や署名はサービス側で処理する想定。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SendDirectMessageRequest {\n    pub recipient_npub: String,\n    pub content: String,\n    pub client_message_id: Option<String>,\n}\n\n/// 送信結果。最小限のメタデータのみ保持。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SendDirectMessageResponse {\n    pub event_id: Option<String>,\n    pub queued: bool,\n}\n\n/// 単一メッセージの DTO。UI 側では `client_message_id` で楽観更新を照合する。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageDto {\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub content: String,\n    pub created_at: i64,\n    pub delivered: bool,\n}\n\n/// カーソル付きメッセージ取得リクエスト。\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct ListDirectMessagesRequest {\n    pub conversation_npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub direction: Option<MessagePageDirection>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct ListDirectMessageConversationsRequest {\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n}\n\n/// 取得方向。将来的な前方/後方スクロールを想定。\n#[derive(Debug, Serialize, Deserialize, Clone, Copy, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum MessagePageDirection {\n    #[default]\n    Backward,\n    Forward,\n}\n\n/// カーソルページ。`has_more` は UI のロード制御用。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessagePage {\n    pub items: Vec<DirectMessageDto>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageConversationSummaryDto {\n    pub conversation_npub: String,\n    pub unread_count: u64,\n    pub last_read_at: i64,\n    pub last_message: Option<DirectMessageDto>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageConversationListDto {\n    pub items: Vec<DirectMessageConversationSummaryDto>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct MarkDirectMessageConversationReadRequest {\n    pub conversation_npub: String,\n    pub last_read_at: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SeedDirectMessageRequest {\n    pub content: Option<String>,\n    pub created_at: Option<i64>,\n    pub recipient_nsec: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SeedDirectMessageResponse {\n    pub conversation_npub: String,\n    pub created_at: i64,\n    pub content: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\nuse crate::presentation::dto::Validate;\nuse nostr_sdk::prelude::Url;\nuse serde::{Deserialize, Serialize};\n\r\nfn default_true() -> bool {\n    true\n}\n\nconst MAX_NIP65_RELAYS: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Nip65RelayDto {\n    pub url: String,\n    #[serde(default = \"default_true\")]\n    pub read: bool,\n    #[serde(default = \"default_true\")]\n    pub write: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NostrMetadataDto {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub website: Option<String>,\n    pub relays: Option<Vec<Nip65RelayDto>>,\n    #[serde(rename = \"kukuri_privacy\")]\n    pub privacy: Option<PrivacyPreferencesDto>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct PrivacyPreferencesDto {\n    pub public_profile: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTextNoteRequest {\r\n    pub content: String,\r\n}\r\n\r\nimpl Validate for PublishTextNoteRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTopicPostRequest {\r\n    pub topic_id: String,\r\n    pub content: String,\r\n    pub reply_to: Option<String>,\r\n}\r\n\r\nimpl Validate for PublishTopicPostRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SendReactionRequest {\r\n    pub event_id: String,\r\n    pub reaction: String,\r\n}\r\n\r\nimpl Validate for SendReactionRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.event_id.is_empty() {\r\n            return Err(\"Event ID is required\".to_string());\r\n        }\r\n        if self.reaction.is_empty() {\r\n            return Err(\"Reaction cannot be empty\".to_string());\r\n        }\r\n        if self.reaction.len() > 20 {\r\n            return Err(\"Reaction is too long (max 20 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct UpdateMetadataRequest {\r\n    pub metadata: NostrMetadataDto,\r\n}\r\n\r\nimpl Validate for UpdateMetadataRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        // 各フィールドの長さチェック\r\n        if let Some(name) = &self.metadata.name {\r\n            if name.len() > 100 {\r\n                return Err(\"Name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(display_name) = &self.metadata.display_name {\r\n            if display_name.len() > 100 {\r\n                return Err(\"Display name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(about) = &self.metadata.about {\n            if about.len() > 1000 {\n                return Err(\"About is too long (max 1000 characters)\".to_string());\n            }\n        }\n        if let Some(relays) = &self.metadata.relays {\n            if relays.len() > MAX_NIP65_RELAYS {\n                return Err(format!(\n                    \"Relay list is too long (max {MAX_NIP65_RELAYS} entries)\"\n                ));\n            }\n            for relay in relays {\n                if relay.url.trim().is_empty() {\n                    return Err(\"Relay URL cannot be empty\".to_string());\n                }\n                let parsed = Url::parse(relay.url.as_str())\n                    .map_err(|_| \"Relay URL must be a valid websocket URL\".to_string())?;\n                match parsed.scheme() {\n                    \"ws\" | \"wss\" => {}\n                    _ => {\n                        return Err(\"Relay URL must use ws:// or wss://\".to_string());\n                    }\n                }\n            }\n        }\n        // URLの検証は省略（実際の実装では必要に応じて追加）\n        Ok(())\n    }\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SubscribeRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for SubscribeRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct EventResponse {\r\n    pub event_id: String,\r\n    pub success: bool,\r\n    pub message: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct NostrSubscriptionStateDto {\r\n    pub target: String,\r\n    pub target_type: String,\r\n    pub status: String,\r\n    pub last_synced_at: Option<i64>,\r\n    pub last_attempt_at: Option<i64>,\r\n    pub failure_count: i64,\r\n    pub error_message: Option<String>,\r\n}\r\n\r\nimpl From<SubscriptionRecord> for NostrSubscriptionStateDto {\r\n    fn from(record: SubscriptionRecord) -> Self {\r\n        let (target_type, target_value) = match record.target {\r\n            SubscriptionTarget::Topic(id) => (\"topic\".to_string(), id),\r\n            SubscriptionTarget::User(id) => (\"user\".to_string(), id),\r\n        };\r\n        Self {\r\n            target: target_value,\r\n            target_type,\r\n            status: record.status.as_str().to_string(),\r\n            last_synced_at: record.last_synced_at,\r\n            last_attempt_at: record.last_attempt_at,\r\n            failure_count: record.failure_count,\r\n            error_message: record.error_message,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":49,"address":[21404992],"length":1,"stats":{"Line":0}},{"line":50,"address":[21517728],"length":1,"stats":{"Line":0}},{"line":51,"address":[21411837],"length":1,"stats":{"Line":0}},{"line":53,"address":[21418798],"length":1,"stats":{"Line":0}},{"line":54,"address":[15659433],"length":1,"stats":{"Line":0}},{"line":56,"address":[21521754],"length":1,"stats":{"Line":0}},{"line":68,"address":[21479792],"length":1,"stats":{"Line":0}},{"line":69,"address":[21523518],"length":1,"stats":{"Line":0}},{"line":70,"address":[21479850],"length":1,"stats":{"Line":0}},{"line":72,"address":[12242315],"length":1,"stats":{"Line":0}},{"line":73,"address":[21412124],"length":1,"stats":{"Line":0}},{"line":75,"address":[12242393],"length":1,"stats":{"Line":0}},{"line":76,"address":[15659720],"length":1,"stats":{"Line":0}},{"line":78,"address":[15659705],"length":1,"stats":{"Line":0}},{"line":89,"address":[21518192],"length":1,"stats":{"Line":0}},{"line":90,"address":[21522158],"length":1,"stats":{"Line":0}},{"line":91,"address":[21487066],"length":1,"stats":{"Line":0}},{"line":93,"address":[21412315],"length":1,"stats":{"Line":0}},{"line":94,"address":[21487146],"length":1,"stats":{"Line":0}},{"line":96,"address":[21480201],"length":1,"stats":{"Line":0}},{"line":97,"address":[21405702],"length":1,"stats":{"Line":0}},{"line":99,"address":[21419447],"length":1,"stats":{"Line":0}},{"line":109,"address":[21620437,21618848],"length":1,"stats":{"Line":0}},{"line":111,"address":[12242878],"length":1,"stats":{"Line":0}},{"line":112,"address":[21419609],"length":1,"stats":{"Line":0}},{"line":113,"address":[21522550],"length":1,"stats":{"Line":0}},{"line":116,"address":[21405982,21405865],"length":1,"stats":{"Line":0}},{"line":117,"address":[21487510],"length":1,"stats":{"Line":0}},{"line":118,"address":[21487571],"length":1,"stats":{"Line":0}},{"line":121,"address":[21406006,21406127],"length":1,"stats":{"Line":0}},{"line":122,"address":[21619207],"length":1,"stats":{"Line":0}},{"line":123,"address":[21487723],"length":1,"stats":{"Line":0}},{"line":126,"address":[21522919,21522793],"length":1,"stats":{"Line":0}},{"line":127,"address":[21413071],"length":1,"stats":{"Line":0}},{"line":128,"address":[21524644],"length":1,"stats":{"Line":0}},{"line":132,"address":[21524617,21524814],"length":1,"stats":{"Line":0}},{"line":133,"address":[21619674],"length":1,"stats":{"Line":0}},{"line":134,"address":[15661047],"length":1,"stats":{"Line":0}},{"line":136,"address":[21413868,21413598,21413422],"length":1,"stats":{"Line":0}},{"line":137,"address":[15661715,15661696,15661340],"length":1,"stats":{"Line":0}},{"line":138,"address":[21413948,21413798],"length":1,"stats":{"Line":0}},{"line":139,"address":[21407180,21407269],"length":1,"stats":{"Line":0}},{"line":141,"address":[21519979],"length":1,"stats":{"Line":0}},{"line":147,"address":[21619378],"length":1,"stats":{"Line":0}},{"line":157,"address":[21520144],"length":1,"stats":{"Line":0}},{"line":158,"address":[21620542],"length":1,"stats":{"Line":0}},{"line":159,"address":[21421259],"length":1,"stats":{"Line":0}},{"line":161,"address":[21407484],"length":1,"stats":{"Line":0}},{"line":184,"address":[21490232,21489088,21489603],"length":1,"stats":{"Line":0}},{"line":185,"address":[21421350,21421682],"length":1,"stats":{"Line":0}},{"line":186,"address":[21414401,21414519],"length":1,"stats":{"Line":0}},{"line":187,"address":[21421437,21421875],"length":1,"stats":{"Line":0}},{"line":192,"address":[21526641,21526343],"length":1,"stats":{"Line":0}},{"line":193,"address":[21521091],"length":1,"stats":{"Line":0}},{"line":194,"address":[21526683],"length":1,"stats":{"Line":0}},{"line":195,"address":[15662707],"length":1,"stats":{"Line":0}},{"line":196,"address":[12245475],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct EventResponse {\n    pub id: String,\n    pub kind: u32,\n    pub pubkey: String,\n    pub content: String,\n    pub tags: Vec<Vec<String>>,\n    pub created_at: i64,\n    pub sig: String,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","mod.rs"],"content":"// DTOモジュール\npub mod access_control_dto;\npub mod auth_dto;\npub mod community_node_dto;\npub mod direct_message_dto;\npub mod event;\npub mod offline;\npub mod p2p;\npub mod post_dto;\npub mod profile_avatar_dto;\npub mod topic_dto;\npub mod user_dto;\n\n// 共通のレスポンス型\nuse crate::shared::AppError;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ApiResponse<T> {\n    pub success: bool,\n    pub data: Option<T>,\n    pub error: Option<String>,\n    pub error_code: Option<String>,\n    pub error_details: Option<serde_json::Value>,\n}\n\nimpl<T> ApiResponse<T> {\n    pub fn success(data: T) -> Self {\n        Self {\n            success: true,\n            data: Some(data),\n            error: None,\n            error_code: None,\n            error_details: None,\n        }\n    }\n\n    pub fn from_app_error(error: AppError) -> Self {\n        let error_details = match error {\n            AppError::RateLimited {\n                retry_after_seconds,\n                ..\n            } => Some(json!({ \"retry_after_seconds\": retry_after_seconds })),\n            _ => None,\n        };\n\n        Self {\n            success: false,\n            data: None,\n            error: Some(error.user_message()),\n            error_code: Some(error.code().to_string()),\n            error_details,\n        }\n    }\n\n    pub fn from_result(result: crate::shared::Result<T>) -> Self {\n        match result {\n            Ok(data) => Self::success(data),\n            Err(err) => Self::from_app_error(err),\n        }\n    }\n}\n\n// ページネーション\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PaginationRequest {\n    pub limit: Option<u32>,\n    pub offset: Option<u32>,\n}\n\nimpl Default for PaginationRequest {\n    fn default() -> Self {\n        Self {\n            limit: Some(50),\n            offset: Some(0),\n        }\n    }\n}\n\n// バリデーショントレイト\npub trait Validate {\n    fn validate(&self) -> Result<(), String>;\n}\n","traces":[{"line":29,"address":[18141840,18143440,18142080,18132432,18144256,18134592,18132016,18139792,18143632,18136224,18134368,18137824,18141312,18143824,18133664,18139520,18135840,18138288,18142496,18141104,18142704,18143248,18140896,18139984,18133440,18136704,18136976,18141664,18142976,18135120,18135568,18140704,18142304,18139088,18137168,18133888,18131792,18138560,18132208,18137360,18138096,18138816,18132624,18133248,18136032,18134848,18140256,18137600,18140464,18133056,18132864,18135344,18139296,18143984,18134160,18136432,18141488],"length":1,"stats":{"Line":0}},{"line":32,"address":[15241584,15242979,15249472,15242081,15240497,15245648,15248753,15251335,15245907,15246128,15252384,15243747,15244769,15245251,15240721,15242771,15249952,15251160,15246976,15248979,15245040,15250400,15246339,15248163,15252003,15241360,15246771,15240256,15242291,15244547,15249200,15248547,15251792,15252179,15240963,15249680,15248355,15246545,15242512,15250673,15243939,15245443,15241155,15241857,15244355,15247904,15251521,15250944,15247203,15239985,15243379,15247409,15247633,15243587,15250195,15244145,15243171],"length":1,"stats":{"Line":0}},{"line":39,"address":[15198944,15202149,15177040,15173264,15188240,15218240,15171680,15219285,15205395,15212432,15204886,15173824,15200592,15185584,15172166,15174880,15207056,15181856,15201642,15184998,15194160,15187168,15198918,15185024,15186652,15211846,15180757,15175366,15179670,15192504,15196784,15183929,15175392,15191440,15197360,15175952,15176480,15202736,15214550,15203222,15216656,15192528,15210800,15181840,15193600,15205408,15187728,15216074,15174304,15186096,15198432,15187152,15195222,15204299,15178624,15183952,15206474,15215574,15216096,15201072,15179184,15200004,15191414,15215008,15188214,15193579,15196304,15217712,15190960,15202176,15172192,15213488,15212912,15195722,15193094,15178598,15210776,15190373,15206496,15188794,15184512,15209690,15204320,15197846,15208597,15199510,15214991,15171120,15172758,15180250,15180784,15177526,15192000,15178112,15189301,15203814,15218806,15214000,15205974,15209190,15207563,15189894,15182416,15189328,15182902,15173237,15194634,15217136,15211360,15194656,15196800,15212928,15218219,15179696,15201088,15207584,15208143,15213980,15197872,15183481,15195744,15210272,15200032,15217152,15177552,15211872,15186070,15174320,15176459,15182928,15208624,15181340,15203248,15190400,15209712],"length":1,"stats":{"Line":0}},{"line":40,"address":[15384214,15388486,15420678,15385286,15391718,15419590,15421718,15414182,15405622,15408838,15422806,15429190,15393878,15397046,15396022,15416342,15387414,15423894,15417414,15431334,15415270,15392790,15390646,15404534,15412038,15398118,15399190,15406694,15407750,15426022,15428102,15430246,15401334,15413126,15427094,15386358,15400262,15410966,15394950,15389574,15402422,15418502,15424966,15409894,15403494],"length":1,"stats":{"Line":0}},{"line":41,"address":[22966954,22979415,22990528,22964423,22975546,22976596,22982010,22981533,22982679,22960061,22985837,22951994,22980928,22949415,22971258,22966535,22973386,22975127,22977213,22957965,22971837,22954791,22993277,22949357,22956294,22984749,22953661,22957370,22968695,22982621,22983097,22954733,22962205,22977690,22984144,22950906,22961191,22991133,22965437,22950429,22960119,22964848,22946215,22948359,22977271,22949834,22955821,22972967,22979357,22990103,22948301,22963748,22976125,22983719,22963335,22962263,22988023,22983661,22951517,22963277,22967565,22989504,22992247,22975069,22972314,22987965,22948778,22989037,22970839,22969114,22947287,22956951,22979840,22991610,22964365,22946634,22956893,22978343,22958989,22961606,22973981,22981591,22993335,22961133,22965495,22980503,22980445,22993760,22953719,22978768,22986314,22955879,22946157,22968048,22978285,22986967,22960538,22955204,22974464,22958023,22954138,22953066,22969751,22968637,22985895,22976183,22972909,22985226,22947229,22974039,22992666,22958435,22992189,22952647,22947712,22989095,22991191,22970176,22971895,22969693,22986909,22951575,22952589,22965914,22967623,22962682,22950487,22959047,22966477,22970781,22984807,22987386,22988442,22959466,22990045],"length":1,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[15291812,15282244,15255444,15254356,15262900,15247924,15272532,15256516,15273604,15278980,15260756,15283284,15289668,15266100,15268260,15288660,15284372,15275748,15263988,15251140,15261828,15274692,15265060,15267188,15252212,15280068,15285460,15250052,15277908,15248980,15245780,15257588,15258612,15290756,15246852,15253284,15271460,15281156,15259684,15292900,15270404,15269316,15276836,15286532,15287588],"length":1,"stats":{"Line":0}},{"line":51,"address":[15250602,15253735,15276193,15256967,15281706,15261203,15255990,15276292,15253834,15251591,15258032,15262378,15260135,15263345,15270954,15279437,15293357,15247309,15280624,15257066,15280525,15252762,15279536,15282694,15260234,15273082,15278464,15258128,15250503,15248474,15264445,15267645,15251690,15270855,15277386,15246231,15261302,15265511,15274061,15293456,15254900,15274160,15259162,15284922,15266551,15292362,15291207,15283840,15246330,15272010,15268810,15269872,15288039,15247408,15283741,15265607,15266650,15288138,15289197,15259063,15284823,15291306,15287082,15290224,15249530,15269773,15286983,15275242,15262279,15282790,15272983,15249431,15254801,15292263,15281607,15275143,15286010,15290125,15271911,15248375,15263444,15267744,15277287,15268711,15285911,15278365,15255891,15264544,15289101,15252663],"length":1,"stats":{"Line":0}},{"line":52,"address":[22981040,22948890,22966095,22954250,22962794,22992778,22948960,22986496,22974576,22976708,22965032,22981112,22989613,22946816,22959648,22967136,22957482,22969226,22977872,22993944,22968160,22968232,22974648,22984328,22993872,22973568,22962864,22975728,22958544,22960650,22967066,22979952,22964960,22975658,22977802,22982192,22990640,22961790,22951088,22982122,22991792,22954320,22989683,22972426,22984256,22963860,22955316,22978880,22985338,22969296,22952106,22952176,22987568,22953248,22957552,22960720,22947896,22958614,22956478,22966023,22971370,22978952,22983278,22946746,22953178,22992848,22971440,22970360,22976778,22985408,22988554,22980024,22947824,22959578,22986426,22961718,22973498,22972496,22970288,22990712,22950016,22963930,22991722,22983206,22949946,22951018,22956406,22987498,22988624,22955386],"length":1,"stats":{"Line":0}},{"line":57,"address":[15229472,15230528,15230832,15231408,15226640,15231552,15229616,15231984,15227792,15229232,15229920,15230224,15229328,15228640,15231840,15227648,15232416,15230384,15226384,15227952,15226240,15226784,15228368,15230080,15231696,15227216,15226928,15228224,15228784,15228512,15228928,15230688,15232272,15231104,15228064,15231248,15227360,15229072,15230960,15226096,15226528,15227072,15232128,15229776,15227504],"length":1,"stats":{"Line":0}},{"line":58,"address":[15340706,15339654,15341858,15339347,15337826,15336114,15337669,15336946,15336802,15335971,15338950,15341286,15338387,15337091,15338658,15341427,15342290,15336661,15342002,15339106,15340835,15341570,15342146,15340979,15338805,15338514,15337378,15336259,15337237,15340562,15340406,15340101,15338098,15340259,15339797,15339202,15341125,15341714,15336402,15336515,15339493,15339954,15338242,15337522,15337941],"length":1,"stats":{"Line":0}},{"line":59,"address":[15434975,15437297,15436726,15432982,15434703,15438463,15436263,15435262,15438319,15435417,15437148,15434287,15438031,15433263,15433412,15437753,15436121,15438751,15437591,15437441,15438180,15432433,15433694,15437023,15434135,15433839,15436415,15435809,15436873,15434407,15434564,15436567,15434849,15435124,15433118,15432721,15433553,15435959,15435563,15432575,15432863,15433983,15435668,15437894,15438607],"length":1,"stats":{"Line":0}},{"line":60,"address":[15303195,15301897,15306380,15305515,15301468,15302620,15305212,15302055,15301223,15301603,15306523,15302892,15306811,15305943,15302331,15303747,15304607,15305359,15305052,15305637,15306076,15306665,15301332,15307099,15304023,15303049,15303331,15302179,15303609,15304153,15305799,15302475,15301067,15307243,15303903,15304748,15300935,15302754,15304907,15306955,15306239,15303467,15301755,15304311,15304444],"length":1,"stats":{"Line":0}},{"line":73,"address":[15225776],"length":1,"stats":{"Line":0}},{"line":75,"address":[15232563],"length":1,"stats":{"Line":0}},{"line":76,"address":[15338499],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline.rs"],"content":"use crate::domain::value_objects::offline::SyncStatus;\nuse crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct OfflineAction {\r\n    pub id: i64,\r\n    pub user_pubkey: String,\r\n    pub action_type: String,\r\n    pub target_id: Option<String>,\r\n    pub action_data: String,\r\n    pub local_id: String,\r\n    pub remote_id: Option<String>,\r\n    pub is_synced: bool,\r\n    pub created_at: i64,\r\n    pub synced_at: Option<i64>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub error_message: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SaveOfflineActionRequest {\r\n    pub user_pubkey: String,\r\n    pub action_type: String,\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub data: String,\r\n}\r\n\r\nimpl Validate for SaveOfflineActionRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.user_pubkey.is_empty() {\r\n            return Err(\"User pubkey is required\".to_string());\r\n        }\r\n        if self.action_type.is_empty() {\r\n            return Err(\"Action type is required\".to_string());\r\n        }\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.data.is_empty() {\r\n            return Err(\"Data is required\".to_string());\r\n        }\r\n        if self.data.len() > 200_000 {\r\n            return Err(\"Data is too large (max 200KB)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SaveOfflineActionResponse {\r\n    pub local_id: String,\r\n    pub action: OfflineAction,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct GetOfflineActionsRequest {\r\n    pub user_pubkey: Option<String>,\r\n    pub is_synced: Option<bool>,\r\n    pub limit: Option<i32>,\r\n}\r\n\r\nimpl Validate for GetOfflineActionsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if let Some(limit) = self.limit {\r\n            if limit <= 0 || limit > 1000 {\r\n                return Err(\"Limit must be between 1 and 1000\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SyncOfflineActionsRequest {\r\n    pub user_pubkey: String,\r\n}\r\n\r\nimpl Validate for SyncOfflineActionsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.user_pubkey.is_empty() {\r\n            return Err(\"User pubkey is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SyncOfflineActionsResponse {\r\n    pub synced_count: i32,\r\n    pub failed_count: i32,\r\n    pub pending_count: i32,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CacheTypeStatus {\n    pub cache_type: String,\n    pub item_count: i64,\n    pub last_synced_at: Option<i64>,\n    pub is_stale: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub metadata: Option<Value>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_version: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub blob_hash: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payload_bytes: Option<i64>,\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct CacheStatusResponse {\n    pub total_items: i64,\n    pub stale_items: i64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ListSyncQueueItemsRequest {\n    pub limit: Option<i32>,\n}\n\nimpl Validate for ListSyncQueueItemsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if let Some(limit) = self.limit {\n            if !(1..=200).contains(&limit) {\n                return Err(\"Limit must be between 1 and 200\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncQueueItemResponse {\n    pub id: i64,\n    pub action_type: String,\n    pub status: String,\n    pub retry_count: i32,\n    pub max_retries: i32,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub synced_at: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error_message: Option<String>,\n    pub payload: Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddToSyncQueueRequest {\n    pub action_type: String,\r\n    pub payload: serde_json::Value,\r\n    pub priority: Option<i32>,\r\n}\r\n\r\nimpl Validate for AddToSyncQueueRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.action_type.is_empty() {\r\n            return Err(\"Action type is required\".to_string());\r\n        }\r\n        if let Some(priority) = self.priority {\r\n            if !(0..=10).contains(&priority) {\r\n                return Err(\"Priority must be between 0 and 10\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UpdateCacheMetadataRequest {\n    pub cache_key: String,\n    pub cache_type: String,\n    pub metadata: Option<serde_json::Value>,\n    pub expiry_seconds: Option<i64>,\n    pub is_stale: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_version: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub blob_hash: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payload_bytes: Option<i64>,\n}\n\r\nimpl Validate for UpdateCacheMetadataRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.cache_key.is_empty() {\r\n            return Err(\"Cache key is required\".to_string());\r\n        }\r\n        if self.cache_type.is_empty() {\r\n            return Err(\"Cache type is required\".to_string());\r\n        }\r\n        if let Some(ttl) = self.expiry_seconds {\r\n            if ttl <= 0 {\r\n                return Err(\"Expiry seconds must be positive\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct OptimisticUpdateRequest {\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub original_data: Option<String>,\r\n    pub updated_data: String,\r\n}\r\n\r\nimpl Validate for OptimisticUpdateRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.updated_data.is_empty() {\r\n            return Err(\"Updated data is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct UpdateSyncStatusRequest {\n    pub entity_type: String,\n    pub entity_id: String,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n\nimpl Validate for UpdateSyncStatusRequest {\n    fn validate(&self) -> Result<(), String> {\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.sync_status.is_empty() {\n            return Err(\"Sync status is required\".to_string());\n        }\n        let status = self.sync_status.as_str();\n        let parsed = SyncStatus::from(status);\n        let legacy_allowed = matches!(status, \"syncing\" | \"synced\");\n        if matches!(parsed, SyncStatus::Unknown(_)) && !legacy_allowed {\n            return Err(\"Invalid sync status. Supported values include pending, sent_to_nostr, sent_to_p2p, fully_synced, failed, conflict, invalid:<reason>\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OfflineRetryMetricsResponse {\n    pub total_success: u64,\n    pub total_failure: u64,\n    pub consecutive_failure: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n    pub last_outcome: Option<String>,\n    pub last_job_id: Option<String>,\n    pub last_job_reason: Option<String>,\n    pub last_trigger: Option<String>,\n    pub last_user_pubkey: Option<String>,\n    pub last_retry_count: Option<i32>,\n    pub last_max_retries: Option<i32>,\n    pub last_backoff_ms: Option<u64>,\n    pub last_duration_ms: Option<u64>,\n    pub last_success_count: Option<i32>,\n    pub last_failure_count: Option<i32>,\n    pub last_timestamp_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RecordOfflineRetryOutcomeRequest {\n    pub job_id: Option<String>,\n    pub status: String,\n    pub job_reason: Option<String>,\n    pub trigger: Option<String>,\n    pub user_pubkey: Option<String>,\n    pub retry_count: Option<i32>,\n    pub max_retries: Option<i32>,\n    pub backoff_ms: Option<u64>,\n    pub duration_ms: Option<u64>,\n    pub success_count: Option<i32>,\n    pub failure_count: Option<i32>,\n    pub timestamp_ms: Option<u64>,\n}\n\nimpl Validate for RecordOfflineRetryOutcomeRequest {\n    fn validate(&self) -> Result<(), String> {\n        match self.status.as_str() {\n            \"success\" | \"failure\" => {}\n            other => return Err(format!(\"Unsupported status: {other}\")),\n        }\n        if let Some(value) = self.retry_count {\n            if value < 0 {\n                return Err(\"retry_count must be >= 0\".to_string());\n            }\n        }\n        if let Some(value) = self.max_retries {\n            if value <= 0 {\n                return Err(\"max_retries must be > 0\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[23923600],"length":1,"stats":{"Line":0}},{"line":35,"address":[23881590],"length":1,"stats":{"Line":0}},{"line":36,"address":[24020099],"length":1,"stats":{"Line":0}},{"line":38,"address":[23807012],"length":1,"stats":{"Line":0}},{"line":39,"address":[23807106],"length":1,"stats":{"Line":0}},{"line":41,"address":[23923731],"length":1,"stats":{"Line":0}},{"line":42,"address":[23820945],"length":1,"stats":{"Line":0}},{"line":44,"address":[15214594],"length":1,"stats":{"Line":0}},{"line":45,"address":[23821024],"length":1,"stats":{"Line":0}},{"line":47,"address":[23881841],"length":1,"stats":{"Line":0}},{"line":48,"address":[18061651],"length":1,"stats":{"Line":0}},{"line":50,"address":[15214752],"length":1,"stats":{"Line":0}},{"line":51,"address":[23814219],"length":1,"stats":{"Line":0}},{"line":53,"address":[23814204],"length":1,"stats":{"Line":0}},{"line":73,"address":[23882112],"length":1,"stats":{"Line":0}},{"line":74,"address":[18061848],"length":1,"stats":{"Line":0}},{"line":75,"address":[23882161,23882192],"length":1,"stats":{"Line":0}},{"line":76,"address":[18061911],"length":1,"stats":{"Line":0}},{"line":79,"address":[23814365],"length":1,"stats":{"Line":0}},{"line":90,"address":[23920384],"length":1,"stats":{"Line":0}},{"line":91,"address":[15215134],"length":1,"stats":{"Line":0}},{"line":92,"address":[23814523],"length":1,"stats":{"Line":0}},{"line":94,"address":[23821484],"length":1,"stats":{"Line":0}},{"line":138,"address":[18062112],"length":1,"stats":{"Line":1}},{"line":139,"address":[15215256],"length":1,"stats":{"Line":1}},{"line":140,"address":[23924492],"length":1,"stats":{"Line":1}},{"line":141,"address":[23889416],"length":1,"stats":{"Line":0}},{"line":144,"address":[23882473],"length":1,"stats":{"Line":1}},{"line":173,"address":[24021040],"length":1,"stats":{"Line":1}},{"line":174,"address":[24021070],"length":1,"stats":{"Line":1}},{"line":175,"address":[23920726],"length":1,"stats":{"Line":0}},{"line":177,"address":[23926299,23926370],"length":1,"stats":{"Line":2}},{"line":178,"address":[24021161],"length":1,"stats":{"Line":1}},{"line":179,"address":[23808133],"length":1,"stats":{"Line":0}},{"line":182,"address":[23920822],"length":1,"stats":{"Line":1}},{"line":203,"address":[23814992],"length":1,"stats":{"Line":1}},{"line":204,"address":[23889760],"length":1,"stats":{"Line":1}},{"line":205,"address":[23924913],"length":1,"stats":{"Line":0}},{"line":207,"address":[15215682],"length":1,"stats":{"Line":1}},{"line":208,"address":[23808345],"length":1,"stats":{"Line":0}},{"line":210,"address":[23889857,23889926],"length":1,"stats":{"Line":2}},{"line":211,"address":[23889935],"length":1,"stats":{"Line":1}},{"line":212,"address":[15215865],"length":1,"stats":{"Line":0}},{"line":215,"address":[24021498],"length":1,"stats":{"Line":1}},{"line":229,"address":[18062816],"length":1,"stats":{"Line":0}},{"line":230,"address":[23921246],"length":1,"stats":{"Line":0}},{"line":231,"address":[24021642],"length":1,"stats":{"Line":0}},{"line":233,"address":[23890075],"length":1,"stats":{"Line":0}},{"line":234,"address":[23822408],"length":1,"stats":{"Line":0}},{"line":236,"address":[23822393],"length":1,"stats":{"Line":0}},{"line":237,"address":[23815508],"length":1,"stats":{"Line":0}},{"line":239,"address":[23808709],"length":1,"stats":{"Line":0}},{"line":253,"address":[23891001,23890320],"length":1,"stats":{"Line":0}},{"line":254,"address":[23815622],"length":1,"stats":{"Line":0}},{"line":255,"address":[23822627],"length":1,"stats":{"Line":0}},{"line":257,"address":[18063156],"length":1,"stats":{"Line":0}},{"line":258,"address":[23925590],"length":1,"stats":{"Line":0}},{"line":260,"address":[18063235],"length":1,"stats":{"Line":0}},{"line":261,"address":[23815902],"length":1,"stats":{"Line":0}},{"line":263,"address":[15216438],"length":1,"stats":{"Line":0}},{"line":264,"address":[23883660],"length":1,"stats":{"Line":0}},{"line":265,"address":[23809095,23809237],"length":1,"stats":{"Line":0}},{"line":266,"address":[23927587],"length":1,"stats":{"Line":0}},{"line":267,"address":[23816167],"length":1,"stats":{"Line":0}},{"line":269,"address":[23927642],"length":1,"stats":{"Line":0}},{"line":313,"address":[23809504],"length":1,"stats":{"Line":0}},{"line":314,"address":[23823300],"length":1,"stats":{"Line":0}},{"line":315,"address":[23891085],"length":1,"stats":{"Line":0}},{"line":316,"address":[23823414],"length":1,"stats":{"Line":0}},{"line":318,"address":[23891143,23891340],"length":1,"stats":{"Line":0}},{"line":319,"address":[23823593],"length":1,"stats":{"Line":0}},{"line":320,"address":[23926496],"length":1,"stats":{"Line":0}},{"line":323,"address":[23928130,23928216],"length":1,"stats":{"Line":0}},{"line":324,"address":[23809941],"length":1,"stats":{"Line":0}},{"line":325,"address":[23823729],"length":1,"stats":{"Line":0}},{"line":328,"address":[23922655],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":76},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OfflineActionResponse {\n    pub id: String,\n    pub action_type: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub payload: serde_json::Value,\n    pub created_at: i64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p.rs"],"content":"use crate::application::services::p2p_service::{\n    ConnectionStatus as ServiceConnectionStatus, PeerStatus as ServicePeerStatus,\n};\nuse crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ConnectionStatusResponse {\n    Connected,\n    Connecting,\n    Disconnected,\n    Error,\n}\n\nimpl From<ServiceConnectionStatus> for ConnectionStatusResponse {\n    fn from(value: ServiceConnectionStatus) -> Self {\n        match value {\n            ServiceConnectionStatus::Connected => ConnectionStatusResponse::Connected,\n            ServiceConnectionStatus::Connecting => ConnectionStatusResponse::Connecting,\n            ServiceConnectionStatus::Disconnected => ConnectionStatusResponse::Disconnected,\n            ServiceConnectionStatus::Error => ConnectionStatusResponse::Error,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerStatusResponse {\n    pub node_id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\nimpl From<ServicePeerStatus> for PeerStatusResponse {\n    fn from(value: ServicePeerStatus) -> Self {\n        Self {\n            node_id: value.node_id,\n            address: value.address,\n            connected_at: value.connected_at,\n            last_seen: value.last_seen,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub connected: bool,\n    pub connection_status: ConnectionStatusResponse,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicStatus>,\n    pub peer_count: usize,\n    pub peers: Vec<PeerStatusResponse>,\n    pub metrics_summary: GossipMetricsSummaryResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStatus {\n    pub topic_id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinTopicRequest {\n    pub topic_id: String,\n    pub initial_peers: Vec<String>,\n}\n\nimpl Validate for JoinTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        // 初期ピアのフォーマット検証は省略（実際には必要に応じて追加）\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LeaveTopicRequest {\n    pub topic_id: String,\n}\n\nimpl Validate for LeaveTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BroadcastRequest {\n    pub topic_id: String,\n    pub content: String,\n}\n\nimpl Validate for BroadcastRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        if self.content.is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if self.content.len() > 50000 {\n            return Err(\"Content is too large (max 50000 bytes)\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NodeAddressResponse {\n    pub addresses: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfigResponse {\n    pub mode: String,\n    pub nodes: Vec<String>,\n    pub effective_nodes: Vec<String>,\n    pub source: String,\n    pub env_locked: bool,\n    #[serde(default)]\n    pub cli_nodes: Vec<String>,\n    #[serde(default)]\n    pub cli_updated_at_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RelayStatusResponse {\n    pub url: String,\n    pub status: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetailsResponse,\n    pub leave_details: GossipMetricDetailsResponse,\n    pub broadcast_details: GossipMetricDetailsResponse,\n    pub receive_details: GossipMetricDetailsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricDetailsResponse {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MainlineMetricsResponse {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n    pub bootstrap: BootstrapMetricsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PMetricsResponse {\n    pub gossip: GossipMetricsResponse,\n    pub mainline: MainlineMetricsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapMetricsResponse {\n    pub env_uses: u64,\n    pub user_uses: u64,\n    pub bundle_uses: u64,\n    pub fallback_uses: u64,\n    pub last_source: Option<String>,\n    pub last_applied_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummaryResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n","traces":[{"line":17,"address":[15270400],"length":1,"stats":{"Line":0}},{"line":18,"address":[15275991],"length":1,"stats":{"Line":0}},{"line":19,"address":[15164520],"length":1,"stats":{"Line":0}},{"line":20,"address":[15274383],"length":1,"stats":{"Line":0}},{"line":21,"address":[15274390],"length":1,"stats":{"Line":0}},{"line":22,"address":[15239277],"length":1,"stats":{"Line":0}},{"line":36,"address":[15370848],"length":1,"stats":{"Line":0}},{"line":38,"address":[22932755],"length":1,"stats":{"Line":0}},{"line":39,"address":[15370877],"length":1,"stats":{"Line":0}},{"line":40,"address":[15270536],"length":1,"stats":{"Line":0}},{"line":41,"address":[15164620],"length":1,"stats":{"Line":0}},{"line":72,"address":[15370976],"length":1,"stats":{"Line":0}},{"line":73,"address":[15371006],"length":1,"stats":{"Line":0}},{"line":74,"address":[23093707],"length":1,"stats":{"Line":0}},{"line":77,"address":[15276236],"length":1,"stats":{"Line":0}},{"line":87,"address":[15276320],"length":1,"stats":{"Line":0}},{"line":88,"address":[15158062],"length":1,"stats":{"Line":0}},{"line":89,"address":[15274731],"length":1,"stats":{"Line":0}},{"line":91,"address":[15171836],"length":1,"stats":{"Line":0}},{"line":102,"address":[15164944],"length":1,"stats":{"Line":0}},{"line":103,"address":[15164974],"length":1,"stats":{"Line":0}},{"line":104,"address":[23093962],"length":1,"stats":{"Line":0}},{"line":106,"address":[15276491],"length":1,"stats":{"Line":0}},{"line":107,"address":[23094044],"length":1,"stats":{"Line":0}},{"line":109,"address":[15371353],"length":1,"stats":{"Line":0}},{"line":110,"address":[15165160],"length":1,"stats":{"Line":0}},{"line":112,"address":[15165145],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub node_id: String,\n    pub connected_peers: Vec<String>,\n    pub subscribed_topics: Vec<String>,\n    pub stats: P2PStats,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStats {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub bytes_sent: u64,\n    pub bytes_received: u64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","post_dto.rs"],"content":"use super::{PaginationRequest, Validate};\nuse serde::{Deserialize, Serialize};\n\n// レスポンスDTO\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PostResponse {\n    pub id: String,\n    pub content: String,\n    pub author_pubkey: String,\n    pub author_npub: String,\n    pub topic_id: String,\n    pub scope: Option<String>,\n    pub epoch: Option<i64>,\n    pub is_encrypted: bool,\n    pub created_at: i64,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: u32,\n    pub is_synced: bool,\n}\n\n// リクエストDTO\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreatePostRequest {\n    pub content: String,\n    pub topic_id: String,\n    pub media_urls: Option<Vec<String>>,\n    pub scope: Option<String>,\n}\n\nimpl Validate for CreatePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.content.trim().is_empty() {\n            return Err(\"投稿内容が空です\".to_string());\n        }\n        if self.content.len() > 5000 {\n            return Err(\"投稿内容が長すぎます（最大5000文字）\".to_string());\n        }\n        if self.topic_id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        if let Some(scope) = &self.scope {\n            let normalized = scope.trim();\n            if !normalized.is_empty()\n                && normalized != \"public\"\n                && normalized != \"friend_plus\"\n                && normalized != \"friend\"\n                && normalized != \"invite\"\n            {\n                return Err(\"スコープが不正です\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetPostsRequest {\n    pub topic_id: Option<String>,\n    pub author_pubkey: Option<String>,\n    pub pagination: Option<PaginationRequest>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DeletePostRequest {\n    pub post_id: String,\n    pub reason: Option<String>,\n}\n\nimpl Validate for DeletePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ReactToPostRequest {\n    pub post_id: String,\n    pub reaction: String,\n}\n\nimpl Validate for ReactToPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        if self.reaction.trim().is_empty() {\n            return Err(\"リアクションが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BookmarkPostRequest {\n    pub post_id: String,\n}\n\nimpl Validate for BookmarkPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListTrendingPostsRequest {\n    pub topic_ids: Vec<String>,\n    pub per_topic: Option<u32>,\n}\n\nimpl Validate for ListTrendingPostsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_ids.is_empty() {\n            return Err(\"トピックIDを少なくとも1つ指定してください\".to_string());\n        }\n        if let Some(per_topic) = self.per_topic {\n            if per_topic == 0 {\n                return Err(\"トピックごとの取得件数は1以上を指定してください\".to_string());\n            }\n            if per_topic > 20 {\n                return Err(\"トピックごとの取得件数は最大20件までです\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TrendingTopicPostsResponse {\n    pub topic_id: String,\n    pub topic_name: String,\n    pub relative_rank: u32,\n    pub posts: Vec<PostResponse>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListTrendingPostsResponse {\n    pub generated_at: i64,\n    pub topics: Vec<TrendingTopicPostsResponse>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListFollowingFeedRequest {\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub include_reactions: Option<bool>,\n}\n\nimpl Validate for ListFollowingFeedRequest {\n    fn validate(&self) -> Result<(), String> {\n        if let Some(limit) = self.limit {\n            if limit == 0 {\n                return Err(\"取得件数は1以上で指定してください\".to_string());\n            }\n            if limit > 100 {\n                return Err(\"取得件数は最大100件までです\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FollowingFeedPageResponse {\n    pub items: Vec<PostResponse>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub server_time: i64,\n}\n","traces":[{"line":32,"address":[24776896],"length":1,"stats":{"Line":0}},{"line":33,"address":[24778582],"length":1,"stats":{"Line":0}},{"line":34,"address":[24741865],"length":1,"stats":{"Line":0}},{"line":36,"address":[18914634],"length":1,"stats":{"Line":0}},{"line":37,"address":[24660446],"length":1,"stats":{"Line":0}},{"line":39,"address":[24777049],"length":1,"stats":{"Line":0}},{"line":40,"address":[24773259],"length":1,"stats":{"Line":0}},{"line":42,"address":[24773214,24773323],"length":1,"stats":{"Line":0}},{"line":43,"address":[24873699],"length":1,"stats":{"Line":0}},{"line":44,"address":[24667437],"length":1,"stats":{"Line":0}},{"line":45,"address":[19323593],"length":1,"stats":{"Line":0}},{"line":46,"address":[24667505],"length":1,"stats":{"Line":0}},{"line":47,"address":[24773449],"length":1,"stats":{"Line":0}},{"line":48,"address":[24735361],"length":1,"stats":{"Line":0}},{"line":50,"address":[24779081],"length":1,"stats":{"Line":0}},{"line":53,"address":[24773383],"length":1,"stats":{"Line":0}},{"line":71,"address":[24777520],"length":1,"stats":{"Line":0}},{"line":72,"address":[18915214],"length":1,"stats":{"Line":0}},{"line":73,"address":[24874033],"length":1,"stats":{"Line":0}},{"line":75,"address":[24874018],"length":1,"stats":{"Line":0}},{"line":86,"address":[19323936],"length":1,"stats":{"Line":0}},{"line":87,"address":[24773776],"length":1,"stats":{"Line":0}},{"line":88,"address":[24674905],"length":1,"stats":{"Line":0}},{"line":90,"address":[24674868],"length":1,"stats":{"Line":0}},{"line":91,"address":[24779509],"length":1,"stats":{"Line":0}},{"line":93,"address":[24874278],"length":1,"stats":{"Line":0}},{"line":103,"address":[18915600],"length":1,"stats":{"Line":0}},{"line":104,"address":[24742846],"length":1,"stats":{"Line":0}},{"line":105,"address":[24779665],"length":1,"stats":{"Line":0}},{"line":107,"address":[24779650],"length":1,"stats":{"Line":0}},{"line":118,"address":[24668240],"length":1,"stats":{"Line":0}},{"line":119,"address":[24774192],"length":1,"stats":{"Line":0}},{"line":120,"address":[24778154],"length":1,"stats":{"Line":0}},{"line":122,"address":[24779791,24779863],"length":1,"stats":{"Line":0}},{"line":123,"address":[24778226],"length":1,"stats":{"Line":0}},{"line":124,"address":[24675373],"length":1,"stats":{"Line":0}},{"line":126,"address":[24661673],"length":1,"stats":{"Line":0}},{"line":127,"address":[24668474],"length":1,"stats":{"Line":0}},{"line":130,"address":[24743118],"length":1,"stats":{"Line":0}},{"line":156,"address":[24778400],"length":1,"stats":{"Line":0}},{"line":157,"address":[24780072],"length":1,"stats":{"Line":0}},{"line":158,"address":[24675569],"length":1,"stats":{"Line":0}},{"line":159,"address":[24668620],"length":1,"stats":{"Line":0}},{"line":161,"address":[24743416],"length":1,"stats":{"Line":0}},{"line":162,"address":[24778553],"length":1,"stats":{"Line":0}},{"line":165,"address":[24675581],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","profile_avatar_dto.rs"],"content":"use base64::Engine as _;\nuse base64::engine::general_purpose::STANDARD as BASE64_STANDARD;\nuse serde::{Deserialize, Serialize};\n\nuse crate::application::services::ProfileAvatarFetchResult;\nuse crate::domain::entities::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry};\n\n#[derive(Debug, Deserialize)]\npub struct UploadProfileAvatarRequest {\n    pub npub: String,\n    pub bytes: Vec<u8>,\n    pub format: String,\n    pub access_level: ProfileAvatarAccessLevel,\n}\n\n#[derive(Debug, Serialize)]\npub struct UploadProfileAvatarResponse {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub doc_version: u64,\n    pub updated_at: String,\n    pub content_sha256: String,\n}\n\nimpl From<ProfileAvatarDocEntry> for UploadProfileAvatarResponse {\n    fn from(value: ProfileAvatarDocEntry) -> Self {\n        Self {\n            npub: value.npub,\n            blob_hash: value.blob_hash,\n            format: value.format,\n            size_bytes: value.size_bytes,\n            access_level: value.access_level,\n            share_ticket: value.share_ticket,\n            doc_version: value.version,\n            updated_at: value.updated_at.to_rfc3339(),\n            content_sha256: value.content_sha256,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct FetchProfileAvatarRequest {\n    pub npub: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct FetchProfileAvatarResponse {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub doc_version: u64,\n    pub updated_at: String,\n    pub content_sha256: String,\n    pub data_base64: String,\n}\n\nimpl From<ProfileAvatarFetchResult> for FetchProfileAvatarResponse {\n    fn from(value: ProfileAvatarFetchResult) -> Self {\n        let metadata = value.metadata;\n        Self {\n            npub: metadata.npub,\n            blob_hash: metadata.blob_hash,\n            format: metadata.format,\n            size_bytes: metadata.size_bytes,\n            access_level: metadata.access_level,\n            share_ticket: metadata.share_ticket,\n            doc_version: metadata.version,\n            updated_at: metadata.updated_at.to_rfc3339(),\n            content_sha256: metadata.content_sha256,\n            data_base64: BASE64_STANDARD.encode(value.bytes),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct ProfileAvatarSyncRequest {\n    pub npub: String,\n    pub known_doc_version: Option<u64>,\n    #[serde(default)]\n    pub source: Option<String>,\n    #[serde(default)]\n    pub requested_at: Option<String>,\n    #[serde(default)]\n    pub retry_count: Option<u32>,\n    #[serde(default)]\n    pub job_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ProfileAvatarSyncResponse {\n    pub npub: String,\n    pub current_version: Option<u64>,\n    pub updated: bool,\n    pub avatar: Option<FetchProfileAvatarResponse>,\n}\n","traces":[{"line":30,"address":[21483328,21483886],"length":1,"stats":{"Line":0}},{"line":32,"address":[21408757],"length":1,"stats":{"Line":0}},{"line":33,"address":[21422534],"length":1,"stats":{"Line":0}},{"line":34,"address":[23964424],"length":1,"stats":{"Line":0}},{"line":35,"address":[21621885],"length":1,"stats":{"Line":0}},{"line":36,"address":[21422585],"length":1,"stats":{"Line":0}},{"line":37,"address":[15663139],"length":1,"stats":{"Line":0}},{"line":38,"address":[21490379],"length":1,"stats":{"Line":0}},{"line":39,"address":[21483463],"length":1,"stats":{"Line":0}},{"line":40,"address":[21490484],"length":1,"stats":{"Line":0}},{"line":65,"address":[21623388,21622528,21623569],"length":1,"stats":{"Line":0}},{"line":66,"address":[21522181],"length":1,"stats":{"Line":0}},{"line":68,"address":[21622604],"length":1,"stats":{"Line":0}},{"line":69,"address":[21522262],"length":1,"stats":{"Line":0}},{"line":70,"address":[21484176],"length":1,"stats":{"Line":0}},{"line":71,"address":[21416394],"length":1,"stats":{"Line":0}},{"line":72,"address":[21491143],"length":1,"stats":{"Line":0}},{"line":73,"address":[21423394],"length":1,"stats":{"Line":0}},{"line":74,"address":[21423423],"length":1,"stats":{"Line":0}},{"line":75,"address":[23965308],"length":1,"stats":{"Line":0}},{"line":76,"address":[21423511],"length":1,"stats":{"Line":0}},{"line":77,"address":[21416575],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","topic_dto.rs"],"content":"use super::{Validate, offline::OfflineAction};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n// レスポンスDTO\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct TopicResponse {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub description: String,\r\n    pub image_url: Option<String>,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub is_joined: bool,\r\n    pub visibility: String,\r\n    pub created_at: i64,\r\n    pub updated_at: i64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct PendingTopicResponse {\r\n    pub pending_id: String,\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub status: String,\r\n    pub offline_action_id: String,\r\n    pub synced_topic_id: Option<String>,\r\n    pub error_message: Option<String>,\r\n    pub created_at: i64,\r\n    pub updated_at: i64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct EnqueueTopicCreationRequest {\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub visibility: Option<String>,\r\n}\r\n\r\nimpl Validate for EnqueueTopicCreationRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.name.trim().is_empty() {\r\n            return Err(\"トピック名が必要です\".to_string());\r\n        }\r\n        if self.name.len() > 100 {\r\n            return Err(\"トピック名は100文字以内で入力してください\".to_string());\r\n        }\r\n        if let Some(description) = &self.description {\r\n            if description.len() > 500 {\r\n                return Err(\"説明は500文字以内で入力してください\".to_string());\r\n            }\r\n        }\r\n        if let Some(visibility) = &self.visibility {\r\n            if visibility != \"public\" && visibility != \"private\" {\r\n                return Err(\"visibility must be 'public' or 'private'\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct EnqueueTopicCreationResponse {\r\n    pub pending_topic: PendingTopicResponse,\r\n    pub offline_action: OfflineAction,\r\n}\r\n\r\n// リクエストDTO\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct CreateTopicRequest {\r\n    pub name: String,\r\n    pub description: String,\r\n    pub image_url: Option<String>,\r\n    pub visibility: Option<String>,\r\n}\r\n\r\nimpl Validate for CreateTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.name.trim().is_empty() {\r\n            return Err(\"トピック名が必要です\".to_string());\r\n        }\r\n        if self.name.len() > 100 {\r\n            return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\r\n        }\r\n        if self.description.len() > 500 {\r\n            return Err(\"説明が長すぎます（最大500文字）\".to_string());\r\n        }\r\n\r\n        // URLのバリデーション（もし提供されている場合）\r\n        if let Some(visibility) = &self.visibility {\r\n            if visibility != \"public\" && visibility != \"private\" {\r\n                return Err(\"visibility must be 'public' or 'private'\".to_string());\r\n            }\r\n        }\r\n\r\n        if let Some(url) = &self.image_url {\r\n            if !url.is_empty() && !url.starts_with(\"http\") {\r\n                return Err(\"無効な画像URLです\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct UpdateTopicRequest {\r\n    pub id: String,\r\n    pub name: Option<String>,\r\n    pub description: Option<String>,\r\n    pub image_url: Option<String>,\r\n}\r\n\r\nimpl Validate for UpdateTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n\r\n        if let Some(name) = &self.name {\r\n            if name.len() > 100 {\r\n                return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\r\n            }\r\n        }\r\n\r\n        if let Some(desc) = &self.description {\r\n            if desc.len() > 500 {\r\n                return Err(\"説明が長すぎます（最大500文字）\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct JoinTopicRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for JoinTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct GetTopicStatsRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for GetTopicStatsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct DeleteTopicRequest {\r\n    pub id: String,\r\n}\r\n\r\nimpl Validate for DeleteTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct MarkPendingTopicSyncedRequest {\r\n    pub pending_id: String,\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for MarkPendingTopicSyncedRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.pending_id.trim().is_empty() {\r\n            return Err(\"pending_id is required\".to_string());\r\n        }\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"topic_id is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct MarkPendingTopicFailedRequest {\r\n    pub pending_id: String,\r\n    pub error_message: Option<String>,\r\n}\r\n\r\nimpl Validate for MarkPendingTopicFailedRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.pending_id.trim().is_empty() {\r\n            return Err(\"pending_id is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct TopicStatsResponse {\r\n    pub topic_id: String,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub active_users_24h: u32,\r\n    pub trending_score: f64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Default)]\r\npub struct ListTrendingTopicsRequest {\r\n    pub limit: Option<u32>,\r\n}\r\n\r\nimpl Validate for ListTrendingTopicsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if let Some(limit) = self.limit {\r\n            if limit == 0 {\r\n                return Err(\"取得件数は1以上で指定してください\".to_string());\r\n            }\r\n            if limit > 100 {\r\n                return Err(\"取得件数は最大100件までです\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct TrendingTopicDto {\r\n    pub topic_id: String,\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub trending_score: f64,\r\n    pub rank: u32,\r\n    pub score_change: Option<f64>,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct ListTrendingTopicsResponse {\r\n    pub generated_at: i64,\r\n    pub topics: Vec<TrendingTopicDto>,\r\n}\r\n","traces":[{"line":40,"address":[23030912],"length":1,"stats":{"Line":0}},{"line":41,"address":[23142454],"length":1,"stats":{"Line":0}},{"line":42,"address":[17278519],"length":1,"stats":{"Line":0}},{"line":44,"address":[23098794],"length":1,"stats":{"Line":0}},{"line":45,"address":[23140964],"length":1,"stats":{"Line":0}},{"line":47,"address":[23024279,23024388],"length":1,"stats":{"Line":0}},{"line":48,"address":[23142684],"length":1,"stats":{"Line":0}},{"line":49,"address":[23142747],"length":1,"stats":{"Line":0}},{"line":52,"address":[23237603,23237486],"length":1,"stats":{"Line":0}},{"line":53,"address":[23038338,23038296],"length":1,"stats":{"Line":0}},{"line":54,"address":[23141242],"length":1,"stats":{"Line":0}},{"line":58,"address":[23237635],"length":1,"stats":{"Line":0}},{"line":78,"address":[23038448],"length":1,"stats":{"Line":0}},{"line":79,"address":[23106246],"length":1,"stats":{"Line":0}},{"line":80,"address":[23137479],"length":1,"stats":{"Line":0}},{"line":82,"address":[23038522],"length":1,"stats":{"Line":0}},{"line":83,"address":[19325610],"length":1,"stats":{"Line":0}},{"line":85,"address":[23237911],"length":1,"stats":{"Line":0}},{"line":86,"address":[23038727],"length":1,"stats":{"Line":0}},{"line":90,"address":[23099514,23099623],"length":1,"stats":{"Line":0}},{"line":91,"address":[23038867,23038796],"length":1,"stats":{"Line":0}},{"line":92,"address":[23141771],"length":1,"stats":{"Line":0}},{"line":96,"address":[23143351,23143496],"length":1,"stats":{"Line":0}},{"line":97,"address":[23038976,23039011],"length":1,"stats":{"Line":0}},{"line":98,"address":[17279588],"length":1,"stats":{"Line":0}},{"line":102,"address":[23141872],"length":1,"stats":{"Line":0}},{"line":115,"address":[23025360],"length":1,"stats":{"Line":0}},{"line":116,"address":[19326147],"length":1,"stats":{"Line":0}},{"line":117,"address":[23032260],"length":1,"stats":{"Line":0}},{"line":120,"address":[19326183,19326289],"length":1,"stats":{"Line":0}},{"line":121,"address":[23039302],"length":1,"stats":{"Line":0}},{"line":122,"address":[23238674],"length":1,"stats":{"Line":0}},{"line":126,"address":[19326425,19326310],"length":1,"stats":{"Line":0}},{"line":127,"address":[23025681],"length":1,"stats":{"Line":0}},{"line":128,"address":[23138418],"length":1,"stats":{"Line":0}},{"line":132,"address":[19326451],"length":1,"stats":{"Line":0}},{"line":142,"address":[19326528],"length":1,"stats":{"Line":0}},{"line":143,"address":[23238878],"length":1,"stats":{"Line":0}},{"line":144,"address":[23142497],"length":1,"stats":{"Line":0}},{"line":146,"address":[23100434],"length":1,"stats":{"Line":0}},{"line":156,"address":[23032720],"length":1,"stats":{"Line":0}},{"line":157,"address":[23138670],"length":1,"stats":{"Line":0}},{"line":158,"address":[23032801],"length":1,"stats":{"Line":0}},{"line":160,"address":[23100594],"length":1,"stats":{"Line":0}},{"line":170,"address":[23138800],"length":1,"stats":{"Line":0}},{"line":171,"address":[23026126],"length":1,"stats":{"Line":0}},{"line":172,"address":[23032961],"length":1,"stats":{"Line":0}},{"line":174,"address":[23144450],"length":1,"stats":{"Line":0}},{"line":185,"address":[23033040],"length":1,"stats":{"Line":0}},{"line":186,"address":[23040048],"length":1,"stats":{"Line":0}},{"line":187,"address":[23040121],"length":1,"stats":{"Line":0}},{"line":189,"address":[23239396],"length":1,"stats":{"Line":0}},{"line":190,"address":[23139141],"length":1,"stats":{"Line":0}},{"line":192,"address":[23143062],"length":1,"stats":{"Line":0}},{"line":203,"address":[23143152],"length":1,"stats":{"Line":0}},{"line":204,"address":[23040302],"length":1,"stats":{"Line":0}},{"line":205,"address":[23143233],"length":1,"stats":{"Line":0}},{"line":207,"address":[23239650],"length":1,"stats":{"Line":0}},{"line":226,"address":[23040432],"length":1,"stats":{"Line":0}},{"line":227,"address":[23139400],"length":1,"stats":{"Line":0}},{"line":228,"address":[23139424],"length":1,"stats":{"Line":0}},{"line":229,"address":[17281051],"length":1,"stats":{"Line":0}},{"line":231,"address":[23026807],"length":1,"stats":{"Line":0}},{"line":232,"address":[23040584],"length":1,"stats":{"Line":0}},{"line":235,"address":[23108252],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","user_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UserProfile {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub website: Option<String>,\n    pub nip05: Option<String>,\n    pub is_profile_public: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PaginatedUserProfiles {\n    pub items: Vec<UserProfile>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SearchUsersRequest {\n    pub query: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub allow_incomplete: Option<bool>,\n    pub viewer_npub: Option<String>,\n}\n\nimpl crate::presentation::dto::Validate for SearchUsersRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.query.trim().is_empty() {\n            return Err(\"検索キーワードを入力してください\".to_string());\n        }\n        if let Some(limit) = self.limit {\n            if limit == 0 || limit > 50 {\n                return Err(\"limit は 1〜50 の範囲で指定してください\".to_string());\n            }\n        }\n        if let Some(sort) = self.sort.as_deref() {\n            if sort != \"relevance\" && sort != \"recency\" {\n                return Err(\"sort は relevance または recency を指定してください\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SearchUsersResponse {\n    pub items: Vec<UserProfile>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n    pub took_ms: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GetFollowersRequest {\n    pub npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub search: Option<String>,\n    pub viewer_npub: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GetFollowingRequest {\n    pub npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub search: Option<String>,\n    pub viewer_npub: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UpdatePrivacySettingsRequest {\n    pub npub: String,\n    pub public_profile: bool,\n    pub show_online_status: bool,\n}\n\nimpl crate::presentation::dto::Validate for UpdatePrivacySettingsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.npub.trim().is_empty() {\n            return Err(\"npub is required\".to_string());\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[16019072],"length":1,"stats":{"Line":0}},{"line":38,"address":[15987926],"length":1,"stats":{"Line":0}},{"line":39,"address":[16019157],"length":1,"stats":{"Line":0}},{"line":41,"address":[15981109,15981034],"length":1,"stats":{"Line":0}},{"line":42,"address":[16019235,16019355],"length":1,"stats":{"Line":0}},{"line":43,"address":[16119663],"length":1,"stats":{"Line":0}},{"line":46,"address":[16019247,16019375],"length":1,"stats":{"Line":0}},{"line":47,"address":[23681667,23681709],"length":1,"stats":{"Line":0}},{"line":48,"address":[16019461],"length":1,"stats":{"Line":0}},{"line":51,"address":[15913502],"length":1,"stats":{"Line":0}},{"line":92,"address":[15988352],"length":1,"stats":{"Line":0}},{"line":93,"address":[15906862],"length":1,"stats":{"Line":0}},{"line":94,"address":[16019617],"length":1,"stats":{"Line":0}},{"line":96,"address":[18131698],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","auth_handler.rs"],"content":"use crate::{\n    application::services::AuthService,\n    presentation::dto::{\n        Validate,\n        auth_dto::{CreateAccountResponse, LoginResponse, LoginWithNsecRequest},\n    },\n    shared::error::AppError,\n};\nuse std::sync::Arc;\n\npub struct AuthHandler {\n    auth_service: Arc<AuthService>,\n}\n\nimpl AuthHandler {\n    pub fn new(auth_service: Arc<AuthService>) -> Self {\n        Self { auth_service }\n    }\n\n    pub async fn create_account(&self) -> Result<CreateAccountResponse, AppError> {\n        let (user, keypair) = self.auth_service.create_account_with_keys().await?;\n\n        Ok(CreateAccountResponse {\n            npub: user.npub.clone(),\n            nsec: keypair.nsec.clone(),\n            pubkey: user.pubkey.clone(),\n        })\n    }\n\n    pub async fn login_with_nsec(\n        &self,\n        request: LoginWithNsecRequest,\n    ) -> Result<LoginResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let user = self.auth_service.login_with_nsec(&request.nsec).await?;\n\n        Ok(LoginResponse {\n            success: true,\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn logout(&self, npub: String) -> Result<(), AppError> {\n        let _ = npub;\n        self.auth_service.logout().await?;\n        Ok(())\n    }\n\n    pub async fn get_current_user(&self) -> Result<Option<LoginResponse>, AppError> {\n        match self.auth_service.get_current_user().await? {\n            Some(user) => Ok(Some(LoginResponse {\n                success: true,\n                npub: user.npub,\n                pubkey: user.pubkey,\n            })),\n            None => Ok(None),\n        }\n    }\n\n    pub async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.auth_service.export_private_key(npub).await\n    }\n}\n","traces":[{"line":16,"address":[16120064],"length":1,"stats":{"Line":0}},{"line":20,"address":[15913800,15913944,15915184,15913824,15913792,15914131,15913859,15913981],"length":1,"stats":{"Line":0}},{"line":21,"address":[19289287],"length":1,"stats":{"Line":0}},{"line":23,"address":[15921860],"length":1,"stats":{"Line":0}},{"line":24,"address":[16026104],"length":1,"stats":{"Line":0}},{"line":25,"address":[16020671],"length":1,"stats":{"Line":0}},{"line":26,"address":[16024675],"length":1,"stats":{"Line":0}},{"line":30,"address":[15983008],"length":1,"stats":{"Line":0}},{"line":34,"address":[15915378,15915803,15915491,15915585],"length":1,"stats":{"Line":0}},{"line":36,"address":[19294516],"length":1,"stats":{"Line":0}},{"line":38,"address":[16122551],"length":1,"stats":{"Line":0}},{"line":40,"address":[20562620],"length":1,"stats":{"Line":0}},{"line":41,"address":[23684423],"length":1,"stats":{"Line":0}},{"line":45,"address":[15910040,15910908,15910420,15910799,15910115,15910218,15910080,15910032],"length":1,"stats":{"Line":0}},{"line":47,"address":[19218113],"length":1,"stats":{"Line":0}},{"line":48,"address":[20563866],"length":1,"stats":{"Line":0}},{"line":51,"address":[15924858,15925005,15924696,15924704,15924739,15924688,15926024,15924821],"length":1,"stats":{"Line":0}},{"line":52,"address":[11734868],"length":1,"stats":{"Line":0}},{"line":53,"address":[20564880,20564946],"length":1,"stats":{"Line":0}},{"line":55,"address":[15986342],"length":1,"stats":{"Line":0}},{"line":56,"address":[16028422],"length":1,"stats":{"Line":0}},{"line":58,"address":[15986263],"length":1,"stats":{"Line":0}},{"line":62,"address":[15993808,15993826,15993891,15993856,15994193,15994049,15994469,15994012],"length":1,"stats":{"Line":0}},{"line":63,"address":[11548676],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","community_node_handler.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyStore};\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::presentation::dto::community_node_dto::{\n    CommunityNodeAuthRequest, CommunityNodeAuthResponse, CommunityNodeBootstrapServicesRequest,\n    CommunityNodeConfigRequest, CommunityNodeConfigResponse, CommunityNodeConsentRequest,\n    CommunityNodeLabelsRequest, CommunityNodeReportRequest, CommunityNodeRoleConfig,\n    CommunityNodeSearchRequest, CommunityNodeTokenRequest, CommunityNodeTrustAnchorRequest,\n    CommunityNodeTrustAnchorState, CommunityNodeTrustRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::Utc;\nuse nostr_sdk::prelude::{\n    Event as NostrEvent, EventBuilder, FromBech32, Keys, Kind, PublicKey, SecretKey, Tag,\n};\nuse reqwest::{Client, Method, StatusCode, Url};\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nconst COMMUNITY_NODE_CONFIG_KEY: &str = \"community_node_config_v2\";\nconst COMMUNITY_NODE_CONFIG_LEGACY_KEY: &str = \"community_node_config_v1\";\nconst COMMUNITY_NODE_TRUST_ANCHOR_KEY: &str = \"community_node_trust_anchor_v1\";\nconst COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY: &str = \"community_node_bootstrap_cache_v1\";\nconst AUTH_KIND: u16 = 22242;\nconst NODE_DESCRIPTOR_KIND: u16 = 39000;\nconst TOPIC_SERVICE_KIND: u16 = 39001;\nconst LABEL_KIND: u16 = 39006;\nconst ATTESTATION_KIND: u16 = 39010;\nconst TRUST_ANCHOR_KIND: u16 = 39011;\nconst KIP_NAMESPACE: &str = \"kukuri\";\nconst KIP_VERSION: &str = \"1\";\nconst KIP_NODE_DESCRIPTOR_SCHEMA: &str = \"kukuri-node-desc-v1\";\nconst KIP_TOPIC_SERVICE_SCHEMA: &str = \"kukuri-topic-service-v1\";\nconst KIP_ATTESTATION_SCHEMA: &str = \"kukuri-attest-v1\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct CommunityNodeConfig {\n    #[serde(default)]\n    nodes: Vec<CommunityNodeConfigNode>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CommunityNodeConfigNode {\n    base_url: String,\n    #[serde(default)]\n    roles: CommunityNodeRoleConfig,\n    access_token: Option<String>,\n    token_expires_at: Option<i64>,\n    pubkey: Option<String>,\n}\n\nimpl CommunityNodeConfigNode {\n    fn new(base_url: String, roles: CommunityNodeRoleConfig) -> Self {\n        Self {\n            base_url,\n            roles,\n            access_token: None,\n            token_expires_at: None,\n            pubkey: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct LegacyCommunityNodeConfig {\n    base_url: String,\n    access_token: Option<String>,\n    token_expires_at: Option<i64>,\n    pubkey: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct StoredTrustAnchor {\n    attester: String,\n    claim: Option<String>,\n    topic: Option<String>,\n    weight: f64,\n    issued_at: i64,\n    event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct BootstrapCache {\n    #[serde(default)]\n    nodes: BootstrapCacheEntry,\n    #[serde(default)]\n    services: HashMap<String, BootstrapCacheEntry>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct BootstrapCacheEntry {\n    #[serde(default)]\n    items: Vec<serde_json::Value>,\n    #[serde(default)]\n    next_refresh_at: Option<i64>,\n    #[serde(default)]\n    updated_at: Option<i64>,\n    #[serde(default)]\n    stale: bool,\n}\n\nimpl From<StoredTrustAnchor> for CommunityNodeTrustAnchorState {\n    fn from(anchor: StoredTrustAnchor) -> Self {\n        Self {\n            attester: anchor.attester,\n            claim: anchor.claim,\n            topic: anchor.topic,\n            weight: anchor.weight,\n            issued_at: anchor.issued_at,\n            event_json: anchor.event_json,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\nstruct AuthChallengeResponse {\n    challenge: String,\n    #[serde(rename = \"expires_at\")]\n    _expires_at: i64,\n}\n\n#[derive(Debug, Deserialize)]\nstruct AuthVerifyResponse {\n    access_token: String,\n    #[serde(rename = \"token_type\")]\n    _token_type: String,\n    expires_at: i64,\n    pubkey: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CommunityNodeSearchPayload {\n    items: Vec<serde_json::Value>,\n    next_cursor: Option<String>,\n    total: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct BootstrapHttpResponse {\n    items: Vec<serde_json::Value>,\n    #[serde(default)]\n    next_refresh_at: Option<i64>,\n}\n\n#[derive(Debug, Clone)]\nstruct BootstrapAggregateResult {\n    items: Vec<serde_json::Value>,\n    next_refresh_at: Option<i64>,\n}\n\npub struct CommunityNodeHandler {\n    key_manager: Arc<dyn KeyManager>,\n    secure_storage: Arc<dyn SecureStorage>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n    client: Client,\n}\n\nimpl CommunityNodeHandler {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        secure_storage: Arc<dyn SecureStorage>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n    ) -> Self {\n        Self {\n            key_manager,\n            secure_storage,\n            group_key_store,\n            client: Client::new(),\n        }\n    }\n\n    pub async fn set_config(\n        &self,\n        request: CommunityNodeConfigRequest,\n    ) -> Result<CommunityNodeConfigResponse, AppError> {\n        let mut config = self.load_config().await?.unwrap_or_default();\n        let mut existing = HashMap::new();\n        for node in config.nodes.drain(..) {\n            existing.insert(node.base_url.clone(), node);\n        }\n\n        let mut next_nodes = Vec::new();\n        let mut seen = HashMap::new();\n        for node_request in request.nodes {\n            let base_url = normalize_base_url(&node_request.base_url)?;\n            if seen.contains_key(&base_url) {\n                continue;\n            }\n            seen.insert(base_url.clone(), true);\n            let roles = node_request.roles.unwrap_or_default();\n            let mut node = existing\n                .remove(&base_url)\n                .unwrap_or_else(|| CommunityNodeConfigNode::new(base_url.clone(), roles.clone()));\n            if node.base_url != base_url {\n                node.access_token = None;\n                node.token_expires_at = None;\n                node.pubkey = None;\n            }\n            node.base_url = base_url;\n            node.roles = roles;\n            next_nodes.push(node);\n        }\n        config.nodes = next_nodes;\n        self.save_config(&config).await?;\n        Ok(config_response(&config))\n    }\n\n    pub async fn get_config(&self) -> Result<Option<CommunityNodeConfigResponse>, AppError> {\n        let Some(config) = self.load_config().await? else {\n            return Ok(None);\n        };\n        if config.nodes.is_empty() {\n            return Ok(None);\n        }\n        Ok(Some(config_response(&config)))\n    }\n\n    pub async fn clear_config(&self) -> Result<(), AppError> {\n        self.secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let _ = self\n            .secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await;\n        Ok(())\n    }\n\n    pub async fn clear_token(&self, request: CommunityNodeTokenRequest) -> Result<(), AppError> {\n        let base_url = normalize_base_url(&request.base_url)?;\n        let mut config = self.require_config().await?;\n        let node = find_node_mut(&mut config, &base_url)?;\n        node.access_token = None;\n        node.token_expires_at = None;\n        node.pubkey = None;\n        self.save_config(&config).await\n    }\n\n    pub async fn get_trust_anchor(\n        &self,\n    ) -> Result<Option<CommunityNodeTrustAnchorState>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_TRUST_ANCHOR_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(None);\n        };\n        let stored: StoredTrustAnchor = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(stored.into()))\n    }\n\n    pub async fn set_trust_anchor(\n        &self,\n        request: CommunityNodeTrustAnchorRequest,\n    ) -> Result<CommunityNodeTrustAnchorState, AppError> {\n        let attester = request.attester.trim().to_string();\n        if attester.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Attester is required\",\n            ));\n        }\n        PublicKey::from_hex(&attester).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid attester pubkey: {err}\"),\n            )\n        })?;\n\n        let weight = request.weight.unwrap_or(1.0);\n        if !weight.is_finite() || !(0.0..=1.0).contains(&weight) {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Weight must be between 0 and 1\",\n            ));\n        }\n\n        let claim = normalize_optional_value(request.claim);\n        let topic = normalize_optional_value(request.topic);\n\n        let keypair = self.key_manager.current_keypair().await?;\n        let secret_key = SecretKey::from_bech32(&keypair.nsec)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid nsec: {err}\")))?;\n        let keys = Keys::new(secret_key);\n        let mut tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"ver\", KIP_VERSION])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"attester\", &attester])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"weight\", &weight.to_string()])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n        ];\n        if let Some(value) = claim.as_ref() {\n            tags.push(\n                Tag::parse([\"claim\", value])\n                    .map_err(|err| AppError::NostrError(err.to_string()))?,\n            );\n        }\n        if let Some(value) = topic.as_ref() {\n            tags.push(\n                Tag::parse([\"t\", value]).map_err(|err| AppError::NostrError(err.to_string()))?,\n            );\n        }\n\n        let event = EventBuilder::new(Kind::Custom(TRUST_ANCHOR_KIND), \"\")\n            .tags(tags)\n            .sign_with_keys(&keys)?;\n        let event_json = serde_json::to_value(&event)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        let issued_at = event.created_at.as_secs() as i64;\n\n        let stored = StoredTrustAnchor {\n            attester,\n            claim,\n            topic,\n            weight,\n            issued_at,\n            event_json,\n        };\n        let raw = serde_json::to_string(&stored)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_TRUST_ANCHOR_KEY, &raw)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n\n        Ok(stored.into())\n    }\n\n    pub async fn clear_trust_anchor(&self) -> Result<(), AppError> {\n        self.secure_storage\n            .delete(COMMUNITY_NODE_TRUST_ANCHOR_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    pub async fn authenticate(\n        &self,\n        request: CommunityNodeAuthRequest,\n    ) -> Result<CommunityNodeAuthResponse, AppError> {\n        let base_url = normalize_base_url(&request.base_url)?;\n        let mut config = self.require_config().await?;\n        let node = find_node_mut(&mut config, &base_url)?;\n        let keypair = self.key_manager.current_keypair().await?;\n        let challenge = self\n            .request_auth_challenge(&node.base_url, &keypair.public_key)\n            .await?;\n        let auth_event = build_auth_event(&node.base_url, &challenge.challenge, &keypair.nsec)?;\n        let verified = self.verify_auth(&node.base_url, &auth_event).await?;\n        node.access_token = Some(verified.access_token.clone());\n        node.token_expires_at = Some(verified.expires_at);\n        node.pubkey = Some(verified.pubkey.clone());\n        self.save_config(&config).await?;\n\n        Ok(CommunityNodeAuthResponse {\n            expires_at: verified.expires_at,\n            pubkey: verified.pubkey,\n        })\n    }\n\n    pub async fn list_group_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        self.group_key_store.list_keys().await\n    }\n\n    pub async fn list_labels(\n        &self,\n        request: CommunityNodeLabelsRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Labels,\n        )?;\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut last_error: Option<AppError> = None;\n        let now = Utc::now().timestamp();\n        let current_pubkey = self\n            .key_manager\n            .current_keypair()\n            .await\n            .ok()\n            .map(|pair| pair.public_key);\n\n        for node in nodes {\n            let expected_pubkey =\n                resolve_expected_pubkey(node.pubkey.as_deref(), current_pubkey.as_deref());\n\n            let url = build_url(&node.base_url, \"/v1/labels\");\n            let mut builder = self\n                .authorized_request(node, Method::GET, url, true)\n                .await?;\n            builder = builder.query(&[\n                (\"target\", request.target.clone()),\n                (\"limit\", request.limit.unwrap_or(50).to_string()),\n            ]);\n            if let Some(topic) = request.topic.clone() {\n                builder = builder.query(&[(\"topic\", topic)]);\n            }\n            if let Some(cursor) = request.cursor.clone() {\n                builder = builder.query(&[(\"cursor\", cursor)]);\n            }\n            match request_json::<serde_json::Value>(builder).await {\n                Ok(response) => {\n                    if let Some(list) = response.get(\"items\").and_then(|value| value.as_array()) {\n                        for item in list {\n                            if validate_kip_event_json(item, LABEL_KIND, expected_pubkey, now)\n                                .is_some()\n                            {\n                                items.push(item.clone());\n                            }\n                        }\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node labels are unavailable\".to_string())\n            }));\n        }\n\n        Ok(json!({ \"items\": items }))\n    }\n\n    pub async fn submit_report(\n        &self,\n        request: CommunityNodeReportRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, request.base_url.as_deref())?;\n        let url = build_url(&node.base_url, \"/v1/reports\");\n        let builder = self\n            .authorized_request(node, Method::POST, url, true)\n            .await?\n            .json(&request);\n        request_json(builder).await\n    }\n\n    pub async fn trust_report_based(\n        &self,\n        request: CommunityNodeTrustRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Trust,\n        )?;\n        self.aggregate_trust_scores(nodes, \"/v1/trust/report-based\", &request.subject)\n            .await\n    }\n\n    pub async fn trust_communication_density(\n        &self,\n        request: CommunityNodeTrustRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Trust,\n        )?;\n        self.aggregate_trust_scores(nodes, \"/v1/trust/communication-density\", &request.subject)\n            .await\n    }\n\n    pub async fn search(\n        &self,\n        request: CommunityNodeSearchRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Search,\n        )?;\n        self.aggregate_search(nodes, request).await\n    }\n\n    pub async fn list_bootstrap_nodes(&self) -> Result<serde_json::Value, AppError> {\n        let config = self.load_config().await?.unwrap_or_default();\n        let nodes =\n            select_nodes_for_role(&config, None, CommunityNodeRole::Bootstrap).unwrap_or_default();\n        let now = Utc::now().timestamp();\n        let mut cache = self.load_bootstrap_cache().await?;\n        let mut entry = cache.nodes.clone();\n        let mut items = sanitize_bootstrap_items(NODE_DESCRIPTOR_KIND, &entry.items, now, None);\n        entry.items = items.clone();\n        let mut last_error: Option<AppError> = None;\n\n        if !nodes.is_empty() && (items.is_empty() || should_refresh_bootstrap(&entry, now)) {\n            match self.aggregate_bootstrap(nodes, \"/v1/bootstrap/nodes\").await {\n                Ok(result) => {\n                    let fetched =\n                        sanitize_bootstrap_items(NODE_DESCRIPTOR_KIND, &result.items, now, None);\n                    entry.items = fetched.clone();\n                    entry.next_refresh_at = result.next_refresh_at;\n                    entry.updated_at = Some(now);\n                    entry.stale = false;\n                    items = fetched;\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        entry.updated_at = entry.updated_at.or(Some(now));\n        cache.nodes = entry;\n        self.save_bootstrap_cache(&cache).await?;\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n            return Err(AppError::NotFound(\n                \"Community node bootstrap data is unavailable\".to_string(),\n            ));\n        }\n\n        Ok(json!({\n            \"items\": items,\n            \"next_refresh_at\": cache.nodes.next_refresh_at\n        }))\n    }\n\n    pub async fn list_bootstrap_services(\n        &self,\n        request: CommunityNodeBootstrapServicesRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.load_config().await?.unwrap_or_default();\n        let nodes = if request.base_url.is_some() {\n            select_nodes_for_role(\n                &config,\n                request.base_url.as_deref(),\n                CommunityNodeRole::Bootstrap,\n            )?\n        } else {\n            select_nodes_for_role(&config, None, CommunityNodeRole::Bootstrap).unwrap_or_default()\n        };\n\n        let topic_id = request.topic_id;\n        let path = format!(\"/v1/bootstrap/topics/{}/services\", topic_id);\n        let now = Utc::now().timestamp();\n        let mut cache = self.load_bootstrap_cache().await?;\n        let mut entry = cache.services.get(&topic_id).cloned().unwrap_or_default();\n        let mut items =\n            sanitize_bootstrap_items(TOPIC_SERVICE_KIND, &entry.items, now, Some(&topic_id));\n        entry.items = items.clone();\n        let mut last_error: Option<AppError> = None;\n\n        if !nodes.is_empty() && (items.is_empty() || should_refresh_bootstrap(&entry, now)) {\n            match self.aggregate_bootstrap(nodes, &path).await {\n                Ok(result) => {\n                    let fetched = sanitize_bootstrap_items(\n                        TOPIC_SERVICE_KIND,\n                        &result.items,\n                        now,\n                        Some(&topic_id),\n                    );\n                    entry.items = fetched.clone();\n                    entry.next_refresh_at = result.next_refresh_at;\n                    entry.updated_at = Some(now);\n                    entry.stale = false;\n                    items = fetched;\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        entry.updated_at = entry.updated_at.or(Some(now));\n        cache.services.insert(topic_id.clone(), entry);\n        self.save_bootstrap_cache(&cache).await?;\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n            return Err(AppError::NotFound(\n                \"Community node bootstrap data is unavailable\".to_string(),\n            ));\n        }\n\n        Ok(json!({\n            \"items\": items,\n            \"next_refresh_at\": cache\n                .services\n                .get(&topic_id)\n                .and_then(|entry| entry.next_refresh_at)\n        }))\n    }\n\n    pub async fn ingest_bootstrap_event(\n        &self,\n        event: &crate::domain::entities::Event,\n    ) -> Result<(), AppError> {\n        let kind = match u16::try_from(event.kind) {\n            Ok(kind) => kind,\n            Err(_) => return Ok(()),\n        };\n        if kind != NODE_DESCRIPTOR_KIND && kind != TOPIC_SERVICE_KIND {\n            return Ok(());\n        }\n\n        let event_json = json!({\n            \"id\": event.id,\n            \"pubkey\": event.pubkey,\n            \"created_at\": event.created_at.timestamp(),\n            \"kind\": event.kind,\n            \"tags\": event.tags,\n            \"content\": event.content,\n            \"sig\": event.sig,\n        });\n\n        let now = Utc::now().timestamp();\n        let Some(nostr_event) = validate_kip_event_json(&event_json, kind, None, now) else {\n            return Ok(());\n        };\n\n        let mut cache = self.load_bootstrap_cache().await?;\n        let exp = event_tag_value(&nostr_event, \"exp\").and_then(|value| value.parse::<i64>().ok());\n\n        if kind == NODE_DESCRIPTOR_KIND {\n            merge_bootstrap_entry(\n                &mut cache.nodes,\n                kind,\n                &nostr_event,\n                event_json,\n                exp,\n                now,\n                None,\n            );\n        } else {\n            let Some(topic_id) = event_tag_value(&nostr_event, \"t\").map(|value| value.to_string())\n            else {\n                return Ok(());\n            };\n            let entry = cache.services.entry(topic_id.clone()).or_default();\n            merge_bootstrap_entry(\n                entry,\n                kind,\n                &nostr_event,\n                event_json,\n                exp,\n                now,\n                Some(topic_id.as_str()),\n            );\n        }\n\n        self.save_bootstrap_cache(&cache).await?;\n        Ok(())\n    }\n\n    pub async fn get_consent_status(\n        &self,\n        request: CommunityNodeTokenRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, Some(&request.base_url))?;\n        let url = build_url(&node.base_url, \"/v1/consents/status\");\n        let builder = self\n            .authorized_request(node, Method::GET, url, true)\n            .await?;\n        request_json(builder).await\n    }\n\n    pub async fn accept_consents(\n        &self,\n        request: CommunityNodeConsentRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, request.base_url.as_deref())?;\n        let url = build_url(&node.base_url, \"/v1/consents\");\n        let builder = self\n            .authorized_request(node, Method::POST, url, true)\n            .await?\n            .json(&request);\n        request_json(builder).await\n    }\n\n    async fn require_config(&self) -> Result<CommunityNodeConfig, AppError> {\n        self.load_config()\n            .await?\n            .filter(|cfg| !cfg.nodes.is_empty())\n            .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n    }\n\n    async fn load_config(&self) -> Result<Option<CommunityNodeConfig>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_CONFIG_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return self.load_legacy_config().await;\n        };\n        let parsed = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(parsed))\n    }\n\n    async fn load_legacy_config(&self) -> Result<Option<CommunityNodeConfig>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(None);\n        };\n        let legacy: LegacyCommunityNodeConfig = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        if legacy.base_url.trim().is_empty() {\n            return Ok(None);\n        }\n        let base_url = normalize_base_url(&legacy.base_url)?;\n        let mut node = CommunityNodeConfigNode::new(base_url, CommunityNodeRoleConfig::default());\n        node.access_token = legacy.access_token;\n        node.token_expires_at = legacy.token_expires_at;\n        node.pubkey = legacy.pubkey;\n        let config = CommunityNodeConfig { nodes: vec![node] };\n        self.save_config(&config).await?;\n        let _ = self\n            .secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await;\n        Ok(Some(config))\n    }\n\n    async fn save_config(&self, config: &CommunityNodeConfig) -> Result<(), AppError> {\n        let json = serde_json::to_string(config)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_CONFIG_KEY, &json)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    async fn load_bootstrap_cache(&self) -> Result<BootstrapCache, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(BootstrapCache::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_bootstrap_cache(&self, cache: &BootstrapCache) -> Result<(), AppError> {\n        let json = serde_json::to_string(cache)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY, &json)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    async fn authorized_request(\n        &self,\n        node: &CommunityNodeConfigNode,\n        method: Method,\n        url: String,\n        require_auth: bool,\n    ) -> Result<reqwest::RequestBuilder, AppError> {\n        let builder = self.client.request(method, url);\n        let Some(token) = node.access_token.as_ref() else {\n            if require_auth {\n                return Err(AppError::Unauthorized(\n                    \"Community node token is missing\".to_string(),\n                ));\n            }\n            return Ok(builder);\n        };\n        if let Some(exp) = node.token_expires_at {\n            if exp <= Utc::now().timestamp() {\n                if !require_auth {\n                    return Ok(builder);\n                }\n                return Err(AppError::Unauthorized(\n                    \"Community node token has expired\".to_string(),\n                ));\n            }\n        }\n        Ok(builder.bearer_auth(token))\n    }\n\n    async fn aggregate_trust_scores(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        path: &str,\n        subject: &str,\n    ) -> Result<serde_json::Value, AppError> {\n        let mut scores: Vec<f64> = Vec::new();\n        let mut sources: Vec<serde_json::Value> = Vec::new();\n        let mut last_error: Option<AppError> = None;\n        let now = Utc::now().timestamp();\n        let current_pubkey = self\n            .key_manager\n            .current_keypair()\n            .await\n            .ok()\n            .map(|pair| pair.public_key);\n\n        for node in nodes {\n            let expected_pubkey =\n                resolve_expected_pubkey(node.pubkey.as_deref(), current_pubkey.as_deref());\n            let url = build_url(&node.base_url, path);\n            let builder = match self.authorized_request(node, Method::GET, url, true).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n            let builder = builder.query(&[(\"subject\", subject.to_string())]);\n            match request_json::<serde_json::Value>(builder).await {\n                Ok(response) => {\n                    if let Some(score) = response.get(\"score\").and_then(|value| value.as_f64()) {\n                        if !validate_attestation_payload(&response, expected_pubkey, now) {\n                            last_error = Some(AppError::validation(\n                                ValidationFailureKind::Generic,\n                                \"Community node attestation is invalid\",\n                            ));\n                            continue;\n                        }\n                        scores.push(score);\n                        sources.push(json!({\n                            \"base_url\": node.base_url.clone(),\n                            \"score\": score,\n                        }));\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if scores.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node trust score is unavailable\".to_string())\n            }));\n        }\n\n        let sum: f64 = scores.iter().sum();\n        let avg = sum / scores.len() as f64;\n\n        Ok(json!({\n            \"score\": avg,\n            \"sources\": sources,\n        }))\n    }\n\n    async fn aggregate_search(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        request: CommunityNodeSearchRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let use_composite_cursor = nodes.len() > 1;\n        let cursor_map = request\n            .cursor\n            .as_ref()\n            .and_then(|raw| parse_cursor_map(raw, use_composite_cursor));\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut next_cursor_map: HashMap<String, String> = HashMap::new();\n        let mut total: i64 = 0;\n        let mut last_error: Option<AppError> = None;\n\n        for node in nodes {\n            let url = build_url(&node.base_url, \"/v1/search\");\n            let builder = match self.authorized_request(node, Method::GET, url, true).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n\n            let mut builder = builder.query(&[(\"topic\", request.topic.clone())]);\n            if let Some(query) = request.q.clone() {\n                builder = builder.query(&[(\"q\", query)]);\n            }\n            if let Some(limit) = request.limit {\n                builder = builder.query(&[(\"limit\", limit.to_string())]);\n            }\n            let node_cursor = if use_composite_cursor {\n                cursor_map\n                    .as_ref()\n                    .and_then(|map| map.get(&node.base_url).cloned())\n            } else {\n                request.cursor.clone()\n            };\n            if let Some(cursor) = node_cursor {\n                builder = builder.query(&[(\"cursor\", cursor)]);\n            }\n\n            match request_json::<CommunityNodeSearchPayload>(builder).await {\n                Ok(response) => {\n                    total += response.total.unwrap_or(response.items.len() as i64);\n                    if let Some(next_cursor) = response.next_cursor {\n                        next_cursor_map.insert(node.base_url.clone(), next_cursor);\n                    }\n                    items.extend(response.items);\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n        }\n\n        let next_cursor = if next_cursor_map.is_empty() {\n            None\n        } else {\n            Some(\n                serde_json::to_string(&next_cursor_map)\n                    .map_err(|err| AppError::SerializationError(err.to_string()))?,\n            )\n        };\n\n        Ok(json!({\n            \"topic\": request.topic,\n            \"query\": request.q,\n            \"items\": items,\n            \"next_cursor\": next_cursor,\n            \"total\": total,\n        }))\n    }\n\n    async fn aggregate_bootstrap(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        path: &str,\n    ) -> Result<BootstrapAggregateResult, AppError> {\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut next_refresh_at: Option<i64> = None;\n        let mut last_error: Option<AppError> = None;\n\n        for node in nodes {\n            let url = build_url(&node.base_url, path);\n            let builder = match self.authorized_request(node, Method::GET, url, false).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n            match request_json::<BootstrapHttpResponse>(builder).await {\n                Ok(response) => {\n                    items.extend(response.items);\n                    if let Some(refresh) = response.next_refresh_at {\n                        next_refresh_at = Some(match next_refresh_at {\n                            Some(current) => current.min(refresh),\n                            None => refresh,\n                        });\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node bootstrap data is unavailable\".to_string())\n            }));\n        }\n\n        Ok(BootstrapAggregateResult {\n            items,\n            next_refresh_at,\n        })\n    }\n\n    async fn request_auth_challenge(\n        &self,\n        base_url: &str,\n        pubkey: &str,\n    ) -> Result<AuthChallengeResponse, AppError> {\n        let url = build_url(base_url, \"/v1/auth/challenge\");\n        let builder = self.client.post(url).json(&json!({ \"pubkey\": pubkey }));\n        request_json(builder).await\n    }\n\n    async fn verify_auth(\n        &self,\n        base_url: &str,\n        auth_event: &NostrEvent,\n    ) -> Result<AuthVerifyResponse, AppError> {\n        let url = build_url(base_url, \"/v1/auth/verify\");\n        let payload = json!({ \"auth_event_json\": auth_event });\n        let builder = self.client.post(url).json(&payload);\n        request_json(builder).await\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum CommunityNodeRole {\n    Labels,\n    Trust,\n    Search,\n    Bootstrap,\n}\n\nfn role_enabled(roles: &CommunityNodeRoleConfig, role: CommunityNodeRole) -> bool {\n    match role {\n        CommunityNodeRole::Labels => roles.labels,\n        CommunityNodeRole::Trust => roles.trust,\n        CommunityNodeRole::Search => roles.search,\n        CommunityNodeRole::Bootstrap => roles.bootstrap,\n    }\n}\n\nfn find_node<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: &str,\n) -> Result<&'a CommunityNodeConfigNode, AppError> {\n    config\n        .nodes\n        .iter()\n        .find(|node| node.base_url == base_url)\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn find_node_mut<'a>(\n    config: &'a mut CommunityNodeConfig,\n    base_url: &str,\n) -> Result<&'a mut CommunityNodeConfigNode, AppError> {\n    config\n        .nodes\n        .iter_mut()\n        .find(|node| node.base_url == base_url)\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn select_node<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: Option<&str>,\n) -> Result<&'a CommunityNodeConfigNode, AppError> {\n    if let Some(raw) = base_url {\n        let base_url = normalize_base_url(raw)?;\n        return find_node(config, &base_url);\n    }\n    config\n        .nodes\n        .first()\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn select_nodes_for_role<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: Option<&str>,\n    role: CommunityNodeRole,\n) -> Result<Vec<&'a CommunityNodeConfigNode>, AppError> {\n    if let Some(raw) = base_url {\n        let base_url = normalize_base_url(raw)?;\n        let node = find_node(config, &base_url)?;\n        return Ok(vec![node]);\n    }\n\n    let nodes: Vec<_> = config\n        .nodes\n        .iter()\n        .filter(|node| role_enabled(&node.roles, role))\n        .collect();\n    if nodes.is_empty() {\n        return Err(AppError::NotFound(\n            \"Community node role is not configured\".to_string(),\n        ));\n    }\n    Ok(nodes)\n}\n\nfn parse_cursor_map(raw: &str, enable: bool) -> Option<HashMap<String, String>> {\n    if !enable {\n        return None;\n    }\n    serde_json::from_str::<HashMap<String, String>>(raw).ok()\n}\n\nfn normalize_base_url(raw: &str) -> Result<String, AppError> {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    let url = Url::parse(&trimmed).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid URL: {err}\"),\n        )\n    })?;\n    match url.scheme() {\n        \"http\" | \"https\" => Ok(trimmed),\n        _ => Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"URL scheme must be http or https\",\n        )),\n    }\n}\n\nfn normalize_optional_value(value: Option<String>) -> Option<String> {\n    value\n        .map(|val| val.trim().to_string())\n        .filter(|val| !val.is_empty())\n}\n\nfn build_url(base_url: &str, path: &str) -> String {\n    let base = base_url.trim_end_matches('/');\n    let path = path.trim_start_matches('/');\n    format!(\"{base}/{path}\")\n}\n\nfn validate_kip_event_json(\n    event_json: &serde_json::Value,\n    expected_kind: u16,\n    expected_pubkey: Option<&str>,\n    now: i64,\n) -> Option<NostrEvent> {\n    let event: NostrEvent = serde_json::from_value(event_json.clone()).ok()?;\n    if event.kind.as_u16() != expected_kind {\n        return None;\n    }\n    if let Some(expected_pubkey) = expected_pubkey {\n        let expected_pubkey = expected_pubkey.trim();\n        if expected_pubkey.is_empty() {\n            return None;\n        }\n        if event.pubkey.to_string() != expected_pubkey {\n            return None;\n        }\n    }\n    if event.verify().is_err() {\n        return None;\n    }\n    if !validate_kip_tags(&event) {\n        return None;\n    }\n    if !validate_kip_requirements(&event, expected_kind, now) {\n        return None;\n    }\n    Some(event)\n}\n\nfn validate_attestation_payload(\n    response: &serde_json::Value,\n    expected_pubkey: Option<&str>,\n    now: i64,\n) -> bool {\n    let Some(attestation) = response.get(\"attestation\") else {\n        return false;\n    };\n    if attestation.is_null() {\n        return false;\n    }\n    let exp = match attestation.get(\"exp\").and_then(|value| value.as_i64()) {\n        Some(exp) => exp,\n        None => return false,\n    };\n    if exp <= now {\n        return false;\n    }\n    let Some(event_json) = attestation.get(\"event_json\") else {\n        return false;\n    };\n    validate_kip_event_json(event_json, ATTESTATION_KIND, expected_pubkey, now).is_some()\n}\n\nfn resolve_expected_pubkey<'a>(\n    node_pubkey: Option<&'a str>,\n    current_pubkey: Option<&str>,\n) -> Option<&'a str> {\n    let node_pubkey = node_pubkey\n        .map(str::trim)\n        .filter(|value| !value.is_empty())?;\n    if let Some(current_pubkey) = current_pubkey {\n        if node_pubkey.eq_ignore_ascii_case(current_pubkey) {\n            return None;\n        }\n    }\n    Some(node_pubkey)\n}\n\nfn event_tag_value<'a>(event: &'a NostrEvent, name: &str) -> Option<&'a str> {\n    event.tags.iter().find_map(|tag| {\n        let values = tag.as_slice();\n        if values.first().map(|value| value.as_str()) == Some(name) {\n            values.get(1).map(|value| value.as_str())\n        } else {\n            None\n        }\n    })\n}\n\nfn event_tag(event: &NostrEvent, name: &str) -> Option<Vec<String>> {\n    event.tags.iter().find_map(|tag| {\n        let values = tag.as_slice();\n        if values.first().map(|value| value.as_str()) == Some(name) {\n            Some(values.to_vec())\n        } else {\n            None\n        }\n    })\n}\n\nfn has_tag(event: &NostrEvent, name: &str) -> bool {\n    event\n        .tags\n        .iter()\n        .any(|tag| tag.as_slice().first().map(|value| value.as_str()) == Some(name))\n}\n\nfn require_tag_value<'a>(event: &'a NostrEvent, name: &str) -> Option<&'a str> {\n    let value = event_tag_value(event, name)?;\n    if value.trim().is_empty() {\n        return None;\n    }\n    Some(value)\n}\n\nfn require_exp_tag(event: &NostrEvent, now: i64) -> Option<i64> {\n    let exp = require_tag_value(event, \"exp\")?\n        .trim()\n        .parse::<i64>()\n        .ok()?;\n    if exp <= now {\n        return None;\n    }\n    Some(exp)\n}\n\nfn validate_schema(event: &NostrEvent, expected: &str) -> bool {\n    let content = event.content.trim();\n    let parsed: serde_json::Value = match serde_json::from_str(content) {\n        Ok(value) => value,\n        Err(_) => return false,\n    };\n    let schema = match parsed.get(\"schema\").and_then(|value| value.as_str()) {\n        Some(value) => value,\n        None => return false,\n    };\n    schema == expected\n}\n\nfn validate_scope(scope: &str, allow_public: bool) -> bool {\n    match scope {\n        \"friend_plus\" | \"friend\" | \"invite\" => true,\n        \"public\" => allow_public,\n        _ => false,\n    }\n}\n\nfn validate_kip_tags(event: &NostrEvent) -> bool {\n    let namespace = match require_tag_value(event, \"k\") {\n        Some(value) => value.trim(),\n        None => return false,\n    };\n    if namespace != KIP_NAMESPACE {\n        return false;\n    }\n    let version = match require_tag_value(event, \"ver\") {\n        Some(value) => value.trim(),\n        None => return false,\n    };\n    if version != KIP_VERSION {\n        return false;\n    }\n    true\n}\n\nfn validate_kip_requirements(event: &NostrEvent, expected_kind: u16, now: i64) -> bool {\n    match expected_kind {\n        NODE_DESCRIPTOR_KIND => {\n            if require_tag_value(event, \"d\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_NODE_DESCRIPTOR_SCHEMA) {\n                return false;\n            }\n        }\n        TOPIC_SERVICE_KIND => {\n            if require_tag_value(event, \"d\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"t\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"role\").is_none() {\n                return false;\n            }\n            let scope = match require_tag_value(event, \"scope\") {\n                Some(value) => value.trim(),\n                None => return false,\n            };\n            if !validate_scope(scope.trim(), true) {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_TOPIC_SERVICE_SCHEMA) {\n                return false;\n            }\n        }\n        LABEL_KIND => {\n            if require_tag_value(event, \"target\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"label\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"policy_url\").is_none()\n                && require_tag_value(event, \"policy\").is_none()\n            {\n                return false;\n            }\n            if has_tag(event, \"policy_ref\") && require_tag_value(event, \"policy_ref\").is_none() {\n                return false;\n            }\n        }\n        ATTESTATION_KIND => {\n            let sub_tag = match event_tag(event, \"sub\") {\n                Some(tag) => tag,\n                None => return false,\n            };\n            if sub_tag.len() < 3 {\n                return false;\n            }\n            if sub_tag\n                .get(1)\n                .map(|value| value.trim().is_empty())\n                .unwrap_or(true)\n                || sub_tag\n                    .get(2)\n                    .map(|value| value.trim().is_empty())\n                    .unwrap_or(true)\n            {\n                return false;\n            }\n            if require_tag_value(event, \"claim\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_ATTESTATION_SCHEMA) {\n                return false;\n            }\n        }\n        TRUST_ANCHOR_KIND => {\n            if require_tag_value(event, \"attester\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"weight\").is_none() {\n                return false;\n            }\n        }\n        _ => return false,\n    }\n    true\n}\n\nfn should_refresh_bootstrap(entry: &BootstrapCacheEntry, now: i64) -> bool {\n    if entry.stale {\n        return true;\n    }\n    if let Some(next_refresh_at) = entry.next_refresh_at {\n        if next_refresh_at <= now {\n            return true;\n        }\n    }\n    false\n}\n\nfn sanitize_bootstrap_items(\n    expected_kind: u16,\n    items: &[serde_json::Value],\n    now: i64,\n    topic_filter: Option<&str>,\n) -> Vec<serde_json::Value> {\n    let mut map: HashMap<String, (NostrEvent, serde_json::Value)> = HashMap::new();\n\n    for item in items {\n        let Some(event) = validate_kip_event_json(item, expected_kind, None, now) else {\n            continue;\n        };\n        if let Some(topic) = topic_filter {\n            if event_tag_value(&event, \"t\") != Some(topic) {\n                continue;\n            }\n        }\n        let Some(key) = addressable_key(&event) else {\n            continue;\n        };\n        let replace = match map.get(&key) {\n            Some((existing, _)) => is_newer_addressable(&event, existing),\n            None => true,\n        };\n        if replace {\n            map.insert(key, (event, item.clone()));\n        }\n    }\n\n    let mut entries: Vec<(NostrEvent, serde_json::Value)> = map.into_values().collect();\n    entries.sort_by(|(left, _), (right, _)| {\n        let left_ts = left.created_at.as_secs();\n        let right_ts = right.created_at.as_secs();\n        match right_ts.cmp(&left_ts) {\n            Ordering::Equal => left.id.to_string().cmp(&right.id.to_string()),\n            other => other,\n        }\n    });\n\n    entries.into_iter().map(|(_, value)| value).collect()\n}\n\nfn merge_bootstrap_entry(\n    entry: &mut BootstrapCacheEntry,\n    expected_kind: u16,\n    event: &NostrEvent,\n    event_json: serde_json::Value,\n    exp: Option<i64>,\n    now: i64,\n    topic_filter: Option<&str>,\n) {\n    let mut items = sanitize_bootstrap_items(expected_kind, &entry.items, now, topic_filter);\n    insert_or_replace_addressable(&mut items, event, event_json);\n    entry.items = items;\n    entry.updated_at = Some(now);\n    entry.stale = true;\n    if let Some(exp) = exp {\n        entry.next_refresh_at = Some(match entry.next_refresh_at {\n            Some(current) => current.min(exp),\n            None => exp,\n        });\n    }\n}\n\nfn insert_or_replace_addressable(\n    items: &mut Vec<serde_json::Value>,\n    event: &NostrEvent,\n    event_json: serde_json::Value,\n) {\n    let Some(key) = addressable_key(event) else {\n        return;\n    };\n\n    for item in items.iter_mut() {\n        let Ok(existing) = serde_json::from_value::<NostrEvent>(item.clone()) else {\n            continue;\n        };\n        if addressable_key(&existing).as_deref() != Some(&key) {\n            continue;\n        }\n        if is_newer_addressable(event, &existing) {\n            *item = event_json;\n        }\n        return;\n    }\n\n    items.push(event_json);\n}\n\nfn addressable_key(event: &NostrEvent) -> Option<String> {\n    let d_tag = event_tag_value(event, \"d\")?;\n    Some(format!(\n        \"{}:{}:{}\",\n        event.kind.as_u16(),\n        event.pubkey,\n        d_tag\n    ))\n}\n\nfn is_newer_addressable(candidate: &NostrEvent, existing: &NostrEvent) -> bool {\n    let candidate_ts = candidate.created_at.as_secs();\n    let existing_ts = existing.created_at.as_secs();\n    match candidate_ts.cmp(&existing_ts) {\n        Ordering::Greater => true,\n        Ordering::Less => false,\n        Ordering::Equal => candidate.id.to_string() < existing.id.to_string(),\n    }\n}\n\nfn config_response(config: &CommunityNodeConfig) -> CommunityNodeConfigResponse {\n    CommunityNodeConfigResponse {\n        nodes: config\n            .nodes\n            .iter()\n            .map(|node| {\n                crate::presentation::dto::community_node_dto::CommunityNodeConfigNodeResponse {\n                    base_url: node.base_url.clone(),\n                    roles: node.roles.clone(),\n                    has_token: node.access_token.is_some(),\n                    token_expires_at: node.token_expires_at,\n                    pubkey: node.pubkey.clone(),\n                }\n            })\n            .collect(),\n    }\n}\n\nfn build_auth_event(base_url: &str, challenge: &str, nsec: &str) -> Result<NostrEvent, AppError> {\n    let secret_key =\n        SecretKey::from_bech32(nsec).map_err(|err| AppError::Crypto(err.to_string()))?;\n    let keys = Keys::new(secret_key);\n    let tags = vec![\n        Tag::parse([\"relay\", base_url]).map_err(|err| AppError::NostrError(err.to_string()))?,\n        Tag::parse([\"challenge\", challenge])\n            .map_err(|err| AppError::NostrError(err.to_string()))?,\n    ];\n    let event = EventBuilder::new(Kind::Custom(AUTH_KIND), \"\")\n        .tags(tags)\n        .sign_with_keys(&keys)?;\n    Ok(event)\n}\n\nasync fn request_json<T: DeserializeOwned>(\n    builder: reqwest::RequestBuilder,\n) -> Result<T, AppError> {\n    let response = builder\n        .send()\n        .await\n        .map_err(|err| AppError::Network(err.to_string()))?;\n    let status = response.status();\n    let headers = response.headers().clone();\n    let body = response\n        .text()\n        .await\n        .map_err(|err| AppError::Network(err.to_string()))?;\n    if !status.is_success() {\n        if status == StatusCode::TOO_MANY_REQUESTS {\n            let retry_after = headers\n                .get(\"Retry-After\")\n                .and_then(|value| value.to_str().ok())\n                .and_then(|value| value.parse::<u64>().ok())\n                .unwrap_or(60);\n            return Err(AppError::rate_limited(\n                \"Community node rate limited\",\n                retry_after,\n            ));\n        }\n        return Err(AppError::Network(format!(\n            \"Community node error ({status}): {body}\"\n        )));\n    }\n    serde_json::from_str(&body).map_err(|err| AppError::DeserializationError(err.to_string()))\n}\n\n#[cfg(test)]\nmod community_node_validation_tests {\n    use super::*;\n    use nostr_sdk::prelude::{EventBuilder, Keys, Kind, Tag};\n\n    fn build_event_json(\n        keys: &Keys,\n        kind: u16,\n        tags: Vec<Tag>,\n        content: &str,\n    ) -> serde_json::Value {\n        let event = EventBuilder::new(Kind::Custom(kind), content)\n            .tags(tags)\n            .sign_with_keys(keys)\n            .expect(\"signed\");\n        serde_json::to_value(event).expect(\"event json\")\n    }\n\n    fn build_label_tags(exp: i64) -> Vec<Tag> {\n        let exp_str = exp.to_string();\n        vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n            Tag::parse([\"target\", \"event:deadbeef\"]).expect(\"target\"),\n            Tag::parse([\"label\", \"spam\"]).expect(\"label\"),\n            Tag::parse([\"policy_url\", \"https://example.com/policy\"]).expect(\"policy_url\"),\n        ]\n    }\n\n    fn build_label_event_json(keys: &Keys, exp: i64) -> serde_json::Value {\n        build_event_json(keys, LABEL_KIND, build_label_tags(exp), \"\")\n    }\n\n    fn build_node_descriptor_event_json(keys: &Keys, exp: i64, schema: &str) -> serde_json::Value {\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"d\", \"descriptor\"]).expect(\"d\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({ \"schema\": schema }).to_string();\n        build_event_json(keys, NODE_DESCRIPTOR_KIND, tags, content.as_str())\n    }\n\n    #[test]\n    fn validate_kip_event_json_accepts_valid_label() {\n        let keys = Keys::generate();\n        let pubkey = keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(pubkey.as_str()), now);\n        assert!(validated.is_some());\n    }\n\n    #[test]\n    fn validate_kip_event_json_accepts_without_expected_pubkey() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_some());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_expired_event() {\n        let keys = Keys::generate();\n        let pubkey = keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now - 1);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(pubkey.as_str()), now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_wrong_pubkey() {\n        let keys = Keys::generate();\n        let other_keys = Keys::generate();\n        let other_pubkey = other_keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(other_pubkey.as_str()), now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_k_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"k\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_ver_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"ver\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_policy_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"policy_url\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_invalid_schema() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let event_json = build_node_descriptor_event_json(&keys, now + 60, \"invalid-schema\");\n        let validated = validate_kip_event_json(&event_json, NODE_DESCRIPTOR_KIND, None, now);\n        assert!(validated.is_none());\n    }\n}\n\n#[cfg(test)]\nmod community_node_handler_tests {\n    use super::*;\n    use crate::application::ports::group_key_store::GroupKeyStore;\n    use crate::infrastructure::crypto::DefaultKeyManager;\n    use crate::infrastructure::storage::{SecureGroupKeyStore, SecureStorage};\n    use crate::presentation::dto::community_node_dto::CommunityNodeConfigNodeRequest;\n    use async_trait::async_trait;\n    use chrono::Utc;\n    use std::collections::HashMap;\n    use std::sync::mpsc;\n    use std::thread;\n    use std::time::Duration;\n    use tiny_http::{Header, Response, Server};\n    use tokio::sync::Mutex;\n\n    #[derive(Default)]\n    struct InMemorySecureStorage {\n        entries: Mutex<HashMap<String, String>>,\n    }\n\n    #[async_trait]\n    impl SecureStorage for InMemorySecureStorage {\n        async fn store(\n            &self,\n            key: &str,\n            value: &str,\n        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries\n                .lock()\n                .await\n                .insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn retrieve(\n            &self,\n            key: &str,\n        ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.get(key).cloned())\n        }\n\n        async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries.lock().await.remove(key);\n            Ok(())\n        }\n\n        async fn exists(\n            &self,\n            key: &str,\n        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.contains_key(key))\n        }\n\n        async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.keys().cloned().collect())\n        }\n\n        async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries.lock().await.clear();\n            Ok(())\n        }\n    }\n\n    fn test_handler() -> CommunityNodeHandler {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        CommunityNodeHandler::new(key_manager, secure_storage, group_key_store)\n    }\n\n    fn to_domain_event(event: &NostrEvent) -> crate::domain::entities::Event {\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(event.created_at.as_secs() as i64, 0)\n                .expect(\"timestamp\");\n        crate::domain::entities::Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event\n                .tags\n                .iter()\n                .map(|tag| tag.as_slice().to_vec())\n                .collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        }\n    }\n\n    #[derive(Debug)]\n    struct CapturedRequest {\n        path: String,\n        params: HashMap<String, String>,\n    }\n\n    fn spawn_json_server(\n        response_body: serde_json::Value,\n    ) -> (\n        String,\n        mpsc::Receiver<CapturedRequest>,\n        thread::JoinHandle<()>,\n    ) {\n        let server = Server::http(\"127.0.0.1:0\").expect(\"server\");\n        let base_url = format!(\"http://{}\", server.server_addr());\n        let (tx, rx) = mpsc::channel();\n        let handle = thread::spawn(move || {\n            for request in server.incoming_requests().take(1) {\n                let url = request.url();\n                let parsed = Url::parse(&format!(\"http://localhost{url}\")).expect(\"request url\");\n                let params = parsed\n                    .query_pairs()\n                    .map(|(key, value)| (key.to_string(), value.to_string()))\n                    .collect();\n                let captured = CapturedRequest {\n                    path: parsed.path().to_string(),\n                    params,\n                };\n                let _ = tx.send(captured);\n\n                let mut response = Response::from_string(response_body.to_string());\n                response.add_header(\n                    Header::from_bytes(\"Content-Type\", \"application/json\").expect(\"header\"),\n                );\n                let _ = request.respond(response);\n            }\n        });\n        (base_url, rx, handle)\n    }\n\n    fn build_config_node(\n        base_url: String,\n        roles: CommunityNodeRoleConfig,\n    ) -> CommunityNodeConfigNode {\n        let mut node = CommunityNodeConfigNode::new(base_url, roles);\n        node.access_token = Some(\"test-token\".to_string());\n        node.token_expires_at = Some(Utc::now().timestamp() + 600);\n        node\n    }\n\n    fn build_attestation_event(exp: i64) -> serde_json::Value {\n        let keys = Keys::generate();\n        let exp_str = exp.to_string();\n        let subject = keys.public_key().to_string();\n        let tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"sub\", \"pubkey\", subject.as_str()]).expect(\"sub\"),\n            Tag::parse([\"claim\", \"reputation\"]).expect(\"claim\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({\n            \"schema\": KIP_ATTESTATION_SCHEMA,\n            \"subject\": format!(\"pubkey:{subject}\"),\n            \"claim\": \"reputation\",\n            \"value\": { \"score\": 0.5 },\n            \"expires\": exp\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(ATTESTATION_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        serde_json::to_value(event).expect(\"event json\")\n    }\n\n    #[tokio::test]\n    async fn set_config_normalizes_and_deduplicates_nodes() {\n        let handler = test_handler();\n        let request = CommunityNodeConfigRequest {\n            nodes: vec![\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://example.com/\".to_string(),\n                    roles: Some(CommunityNodeRoleConfig {\n                        labels: true,\n                        trust: false,\n                        search: true,\n                        bootstrap: false,\n                    }),\n                },\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://example.com\".to_string(),\n                    roles: None,\n                },\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://node2.example.com\".to_string(),\n                    roles: None,\n                },\n            ],\n        };\n\n        let response = handler.set_config(request).await.expect(\"set config\");\n        assert_eq!(response.nodes.len(), 2);\n        assert_eq!(response.nodes[0].base_url, \"https://example.com\");\n        assert_eq!(response.nodes[1].base_url, \"https://node2.example.com\");\n        assert!(response.nodes[0].roles.search);\n        assert!(!response.nodes[0].roles.bootstrap);\n\n        let loaded = handler.get_config().await.expect(\"get config\");\n        assert!(loaded.is_some());\n    }\n\n    #[tokio::test]\n    async fn trust_anchor_roundtrip() {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let keypair = key_manager.generate_keypair().await.expect(\"keypair\");\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        let handler = CommunityNodeHandler::new(key_manager, secure_storage, group_key_store);\n\n        let request = CommunityNodeTrustAnchorRequest {\n            attester: keypair.public_key.clone(),\n            claim: Some(\"trust:v1\".to_string()),\n            topic: Some(\"kukuri:topic1\".to_string()),\n            weight: Some(0.6),\n        };\n        let stored = handler.set_trust_anchor(request).await.expect(\"set\");\n        let loaded = handler\n            .get_trust_anchor()\n            .await\n            .expect(\"get\")\n            .expect(\"stored\");\n        assert_eq!(loaded.attester, stored.attester);\n        assert_eq!(loaded.weight, 0.6);\n        assert_eq!(loaded.claim, Some(\"trust:v1\".to_string()));\n        assert_eq!(loaded.topic, Some(\"kukuri:topic1\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn trust_anchor_rejects_invalid_weight() {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let keypair = key_manager.generate_keypair().await.expect(\"keypair\");\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        let handler = CommunityNodeHandler::new(key_manager, secure_storage, group_key_store);\n\n        let request = CommunityNodeTrustAnchorRequest {\n            attester: keypair.public_key.clone(),\n            claim: None,\n            topic: None,\n            weight: Some(1.5),\n        };\n        assert!(handler.set_trust_anchor(request).await.is_err());\n    }\n\n    #[tokio::test]\n    async fn ingest_bootstrap_descriptor_populates_cache() {\n        let handler = test_handler();\n        let keys = Keys::generate();\n        let now = Utc::now().timestamp();\n        let exp = now + 600;\n\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"d\", \"descriptor\"]).expect(\"d\"),\n            Tag::parse([\"k\", \"kukuri\"]).expect(\"k\"),\n            Tag::parse([\"ver\", \"1\"]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n            Tag::parse([\"role\", \"bootstrap\"]).expect(\"role\"),\n        ];\n        let content = json!({\n            \"schema\": \"kukuri-node-desc-v1\",\n            \"name\": \"Test Node\",\n            \"roles\": [\"bootstrap\"],\n            \"endpoints\": { \"http\": \"https://node.example\" }\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(NODE_DESCRIPTOR_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        let domain_event = to_domain_event(&event);\n\n        handler\n            .ingest_bootstrap_event(&domain_event)\n            .await\n            .expect(\"ingest\");\n\n        let response = handler.list_bootstrap_nodes().await.expect(\"list\");\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items array\");\n        assert!(!items.is_empty());\n    }\n\n    #[tokio::test]\n    async fn ingest_bootstrap_topic_service_populates_cache() {\n        let handler = test_handler();\n        let keys = Keys::generate();\n        let now = Utc::now().timestamp();\n        let exp = now + 600;\n        let topic_id = \"kukuri:topic1\";\n        let d_tag = format!(\"topic_service:{topic_id}:bootstrap:public\");\n\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"d\", d_tag.as_str()]).expect(\"d\"),\n            Tag::parse([\"t\", topic_id]).expect(\"t\"),\n            Tag::parse([\"role\", \"bootstrap\"]).expect(\"role\"),\n            Tag::parse([\"scope\", \"public\"]).expect(\"scope\"),\n            Tag::parse([\"k\", \"kukuri\"]).expect(\"k\"),\n            Tag::parse([\"ver\", \"1\"]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({\n            \"schema\": \"kukuri-topic-service-v1\",\n            \"topic\": topic_id,\n            \"role\": \"bootstrap\",\n            \"scope\": \"public\"\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(TOPIC_SERVICE_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        let domain_event = to_domain_event(&event);\n\n        handler\n            .ingest_bootstrap_event(&domain_event)\n            .await\n            .expect(\"ingest\");\n\n        let response = handler\n            .list_bootstrap_services(CommunityNodeBootstrapServicesRequest {\n                base_url: None,\n                topic_id: topic_id.to_string(),\n            })\n            .await\n            .expect(\"list services\");\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items array\");\n        assert!(!items.is_empty());\n    }\n\n    #[tokio::test]\n    async fn trust_report_based_aggregates_scores_across_nodes() {\n        let exp = Utc::now().timestamp() + 600;\n        let event_json = build_attestation_event(exp);\n        let response1 = json!({\n            \"score\": 0.2,\n            \"attestation\": { \"exp\": exp, \"event_json\": event_json.clone() }\n        });\n        let response2 = json!({\n            \"score\": 0.6,\n            \"attestation\": { \"exp\": exp, \"event_json\": event_json }\n        });\n\n        let (base_url1, rx1, handle1) = spawn_json_server(response1);\n        let (base_url2, rx2, handle2) = spawn_json_server(response2);\n\n        let handler = test_handler();\n        let roles = CommunityNodeRoleConfig {\n            labels: false,\n            trust: true,\n            search: false,\n            bootstrap: false,\n        };\n        let config = CommunityNodeConfig {\n            nodes: vec![\n                build_config_node(base_url1.clone(), roles.clone()),\n                build_config_node(base_url2.clone(), roles),\n            ],\n        };\n        handler.save_config(&config).await.expect(\"save config\");\n\n        let response = handler\n            .trust_report_based(CommunityNodeTrustRequest {\n                base_url: None,\n                subject: \"npub1testsubject\".to_string(),\n            })\n            .await\n            .expect(\"trust response\");\n\n        let score = response\n            .get(\"score\")\n            .and_then(|value| value.as_f64())\n            .expect(\"score\");\n        assert!((score - 0.4).abs() < 1e-9);\n\n        let sources = response\n            .get(\"sources\")\n            .and_then(|value| value.as_array())\n            .expect(\"sources\");\n        assert_eq!(sources.len(), 2);\n        assert!(sources.iter().any(|value| {\n            value.get(\"base_url\") == Some(&serde_json::Value::String(base_url1.clone()))\n                && value.get(\"score\") == Some(&serde_json::Value::from(0.2))\n        }));\n        assert!(sources.iter().any(|value| {\n            value.get(\"base_url\") == Some(&serde_json::Value::String(base_url2.clone()))\n                && value.get(\"score\") == Some(&serde_json::Value::from(0.6))\n        }));\n\n        let req1 = rx1.recv_timeout(Duration::from_secs(2)).expect(\"request 1\");\n        assert_eq!(req1.path, \"/v1/trust/report-based\");\n        assert_eq!(\n            req1.params.get(\"subject\"),\n            Some(&\"npub1testsubject\".to_string())\n        );\n\n        let req2 = rx2.recv_timeout(Duration::from_secs(2)).expect(\"request 2\");\n        assert_eq!(req2.path, \"/v1/trust/report-based\");\n        assert_eq!(\n            req2.params.get(\"subject\"),\n            Some(&\"npub1testsubject\".to_string())\n        );\n\n        handle1.join().expect(\"server1\");\n        handle2.join().expect(\"server2\");\n    }\n\n    #[tokio::test]\n    async fn search_aggregates_items_and_composes_cursor_for_multiple_nodes() {\n        let response1 = json!({\n            \"items\": [ { \"id\": \"a\" } ],\n            \"next_cursor\": \"next-1\",\n            \"total\": 2\n        });\n        let response2 = json!({\n            \"items\": [ { \"id\": \"b\" }, { \"id\": \"c\" } ],\n            \"next_cursor\": \"next-2\",\n            \"total\": 3\n        });\n\n        let (base_url1, rx1, handle1) = spawn_json_server(response1);\n        let (base_url2, rx2, handle2) = spawn_json_server(response2);\n\n        let handler = test_handler();\n        let roles = CommunityNodeRoleConfig {\n            labels: false,\n            trust: false,\n            search: true,\n            bootstrap: false,\n        };\n        let config = CommunityNodeConfig {\n            nodes: vec![\n                build_config_node(base_url1.clone(), roles.clone()),\n                build_config_node(base_url2.clone(), roles),\n            ],\n        };\n        handler.save_config(&config).await.expect(\"save config\");\n\n        let mut cursor_map = HashMap::new();\n        cursor_map.insert(base_url1.clone(), \"cursor-1\".to_string());\n        cursor_map.insert(base_url2.clone(), \"cursor-2\".to_string());\n        let cursor = serde_json::to_string(&cursor_map).expect(\"cursor map\");\n        let response = handler\n            .search(CommunityNodeSearchRequest {\n                base_url: None,\n                topic: \"kukuri:topic1\".to_string(),\n                q: Some(\"rust\".to_string()),\n                limit: Some(5),\n                cursor: Some(cursor),\n            })\n            .await\n            .expect(\"search\");\n\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items\");\n        assert_eq!(items.len(), 3);\n\n        let total = response\n            .get(\"total\")\n            .and_then(|value| value.as_i64())\n            .expect(\"total\");\n        assert_eq!(total, 5);\n\n        assert_eq!(\n            response.get(\"topic\"),\n            Some(&serde_json::Value::String(\"kukuri:topic1\".to_string()))\n        );\n        assert_eq!(\n            response.get(\"query\"),\n            Some(&serde_json::Value::String(\"rust\".to_string()))\n        );\n\n        let next_cursor = response\n            .get(\"next_cursor\")\n            .and_then(|value| value.as_str())\n            .expect(\"next_cursor\");\n        let cursor_map: HashMap<String, String> =\n            serde_json::from_str(next_cursor).expect(\"cursor map\");\n        assert_eq!(cursor_map.get(&base_url1), Some(&\"next-1\".to_string()));\n        assert_eq!(cursor_map.get(&base_url2), Some(&\"next-2\".to_string()));\n\n        let req1 = rx1.recv_timeout(Duration::from_secs(2)).expect(\"request 1\");\n        assert_eq!(req1.path, \"/v1/search\");\n        assert_eq!(req1.params.get(\"topic\"), Some(&\"kukuri:topic1\".to_string()));\n        assert_eq!(req1.params.get(\"q\"), Some(&\"rust\".to_string()));\n        assert_eq!(req1.params.get(\"limit\"), Some(&\"5\".to_string()));\n        assert_eq!(req1.params.get(\"cursor\"), Some(&\"cursor-1\".to_string()));\n\n        let req2 = rx2.recv_timeout(Duration::from_secs(2)).expect(\"request 2\");\n        assert_eq!(req2.path, \"/v1/search\");\n        assert_eq!(req2.params.get(\"topic\"), Some(&\"kukuri:topic1\".to_string()));\n        assert_eq!(req2.params.get(\"q\"), Some(&\"rust\".to_string()));\n        assert_eq!(req2.params.get(\"limit\"), Some(&\"5\".to_string()));\n        assert_eq!(req2.params.get(\"cursor\"), Some(&\"cursor-2\".to_string()));\n\n        handle1.join().expect(\"server1\");\n        handle2.join().expect(\"server2\");\n    }\n}\n","traces":[{"line":57,"address":[12756368],"length":1,"stats":{"Line":1}},{"line":107,"address":[23139584],"length":1,"stats":{"Line":1}},{"line":109,"address":[23026883],"length":1,"stats":{"Line":1}},{"line":110,"address":[23145197],"length":1,"stats":{"Line":1}},{"line":111,"address":[23033720],"length":1,"stats":{"Line":1}},{"line":112,"address":[17281267],"length":1,"stats":{"Line":1}},{"line":113,"address":[23101560],"length":1,"stats":{"Line":1}},{"line":114,"address":[17281276],"length":1,"stats":{"Line":1}},{"line":163,"address":[12851526,12851567,12851312],"length":1,"stats":{"Line":1}},{"line":172,"address":[12754964],"length":1,"stats":{"Line":1}},{"line":176,"address":[12645296],"length":1,"stats":{"Line":1}},{"line":180,"address":[11594860,11594932],"length":1,"stats":{"Line":2}},{"line":181,"address":[12639366],"length":1,"stats":{"Line":1}},{"line":182,"address":[12714023,12714093,12714265,12717187,12714217],"length":1,"stats":{"Line":3}},{"line":183,"address":[20417405,20414761],"length":1,"stats":{"Line":0}},{"line":186,"address":[12714413],"length":1,"stats":{"Line":1}},{"line":187,"address":[12646661],"length":1,"stats":{"Line":1}},{"line":188,"address":[12853020,12853265,12853130,12853319],"length":1,"stats":{"Line":4}},{"line":189,"address":[12722342,12721807,12722164],"length":1,"stats":{"Line":2}},{"line":190,"address":[15220036,15220193],"length":1,"stats":{"Line":2}},{"line":193,"address":[20415934,20416004],"length":1,"stats":{"Line":2}},{"line":194,"address":[12722572],"length":1,"stats":{"Line":1}},{"line":195,"address":[12641127,12641214],"length":1,"stats":{"Line":2}},{"line":197,"address":[12722784,12724968,12724944],"length":1,"stats":{"Line":3}},{"line":198,"address":[12648596,12648072,12648148],"length":1,"stats":{"Line":2}},{"line":199,"address":[12759730],"length":1,"stats":{"Line":0}},{"line":200,"address":[12641592],"length":1,"stats":{"Line":0}},{"line":201,"address":[12648430],"length":1,"stats":{"Line":0}},{"line":203,"address":[12758010,12758457],"length":1,"stats":{"Line":1}},{"line":204,"address":[12641940],"length":1,"stats":{"Line":1}},{"line":205,"address":[12754658],"length":1,"stats":{"Line":1}},{"line":207,"address":[12714899],"length":1,"stats":{"Line":1}},{"line":208,"address":[12656951,12656414,12652575,12656700,12654222],"length":1,"stats":{"Line":1}},{"line":209,"address":[12759552,12759665],"length":1,"stats":{"Line":2}},{"line":212,"address":[12756344,12756403,12756654,12756336,12757491,12756528,12756491,12756368],"length":1,"stats":{"Line":4}},{"line":213,"address":[12651644,12650552,12650598,12650766,12650655],"length":1,"stats":{"Line":2}},{"line":214,"address":[12857868],"length":1,"stats":{"Line":0}},{"line":216,"address":[12761187,12761103],"length":1,"stats":{"Line":2}},{"line":217,"address":[12726107],"length":1,"stats":{"Line":0}},{"line":219,"address":[12761291,12761193],"length":1,"stats":{"Line":2}},{"line":222,"address":[15223944,15224337,15223936,15223952,15223999,15224109,15224173,15224908],"length":1,"stats":{"Line":0}},{"line":223,"address":[12762310,12762468,12761873,12761644,12762040,12762154,12761802],"length":1,"stats":{"Line":0}},{"line":225,"address":[12763730,12763597,12763490,12763359,12763537],"length":1,"stats":{"Line":0}},{"line":226,"address":[12652406,12652912,12652936],"length":1,"stats":{"Line":0}},{"line":227,"address":[12720377,12720575,12720306,12720177],"length":1,"stats":{"Line":0}},{"line":230,"address":[12645092,12645893,12645754,12646031,12645801],"length":1,"stats":{"Line":0}},{"line":231,"address":[12758816],"length":1,"stats":{"Line":0}},{"line":234,"address":[12653120,12654921,12653264,12653756,12653155,12653072,12655010,12653080],"length":1,"stats":{"Line":0}},{"line":235,"address":[12859665,12860019,12859526,12859816],"length":1,"stats":{"Line":0}},{"line":236,"address":[20421692,20421844,20422334,20423111,20421483,20421980],"length":1,"stats":{"Line":0}},{"line":237,"address":[12860703,12860575,12860389],"length":1,"stats":{"Line":0}},{"line":238,"address":[12764245,12764361],"length":1,"stats":{"Line":0}},{"line":239,"address":[12760517],"length":1,"stats":{"Line":0}},{"line":240,"address":[12760562],"length":1,"stats":{"Line":0}},{"line":241,"address":[11592444],"length":1,"stats":{"Line":0}},{"line":244,"address":[20423536],"length":1,"stats":{"Line":1}},{"line":247,"address":[12723285,12725466,12724023,12723665,12723412,12723483,12723757],"length":1,"stats":{"Line":5}},{"line":250,"address":[11024948],"length":1,"stats":{"Line":3}},{"line":251,"address":[12767671,12769168,12769192],"length":1,"stats":{"Line":0}},{"line":252,"address":[12762172,12762050],"length":1,"stats":{"Line":2}},{"line":253,"address":[12663289],"length":1,"stats":{"Line":0}},{"line":255,"address":[12731033,12731159,12731753],"length":1,"stats":{"Line":2}},{"line":256,"address":[12762889,12763744,12763762],"length":1,"stats":{"Line":0}},{"line":257,"address":[12663775,12664071],"length":1,"stats":{"Line":2}},{"line":260,"address":[12767840],"length":1,"stats":{"Line":1}},{"line":264,"address":[12658640,12658462],"length":1,"stats":{"Line":2}},{"line":265,"address":[12726528,12726612],"length":1,"stats":{"Line":2}},{"line":266,"address":[12666964,12665832],"length":1,"stats":{"Line":0}},{"line":267,"address":[12770352],"length":1,"stats":{"Line":0}},{"line":271,"address":[12659151,12658810,12658914,12659983,12669264],"length":1,"stats":{"Line":2}},{"line":272,"address":[12779250],"length":1,"stats":{"Line":0}},{"line":273,"address":[20437473],"length":1,"stats":{"Line":0}},{"line":274,"address":[12676262],"length":1,"stats":{"Line":0}},{"line":278,"address":[20427397,20427236],"length":1,"stats":{"Line":2}},{"line":279,"address":[12865590,12865497],"length":1,"stats":{"Line":2}},{"line":280,"address":[12765180,12765362],"length":1,"stats":{"Line":2}},{"line":281,"address":[12770756],"length":1,"stats":{"Line":1}},{"line":286,"address":[15231594,15231395],"length":1,"stats":{"Line":2}},{"line":287,"address":[12659573,12659723],"length":1,"stats":{"Line":2}},{"line":289,"address":[12659738,12660669,12667301,12659841,12658527,12660073],"length":1,"stats":{"Line":2}},{"line":290,"address":[12667812,12667604,12668121,12674234],"length":1,"stats":{"Line":2}},{"line":291,"address":[12654313,12662640,12662662],"length":1,"stats":{"Line":0}},{"line":292,"address":[12867305],"length":1,"stats":{"Line":1}},{"line":293,"address":[15233224,15233766,15234508,15234583,15233403,15234098,15238478,15234933,15235250,15234816,15238174,15233310],"length":1,"stats":{"Line":5}},{"line":294,"address":[12767254,12767692,12767379],"length":1,"stats":{"Line":2}},{"line":295,"address":[13110368,12868012,13110386],"length":1,"stats":{"Line":0}},{"line":296,"address":[12867928,12868141,12868411],"length":1,"stats":{"Line":2}},{"line":297,"address":[12972050,12972032,12729883],"length":1,"stats":{"Line":0}},{"line":298,"address":[12655436,12655250,12655768],"length":1,"stats":{"Line":2}},{"line":299,"address":[12772360,13014224,13014242],"length":1,"stats":{"Line":0}},{"line":300,"address":[12772580,12772841,12772323,12772497],"length":1,"stats":{"Line":3}},{"line":301,"address":[13016016,13016034,12774441],"length":1,"stats":{"Line":0}},{"line":303,"address":[12769349],"length":1,"stats":{"Line":1}},{"line":304,"address":[12663935,12663524,12663835],"length":1,"stats":{"Line":3}},{"line":305,"address":[12773757,12773796,12773478,12773402],"length":1,"stats":{"Line":2}},{"line":306,"address":[12775600,12775618,12769773],"length":1,"stats":{"Line":0}},{"line":309,"address":[12731784,12731377],"length":1,"stats":{"Line":2}},{"line":310,"address":[12664371,12664029,12664471],"length":1,"stats":{"Line":3}},{"line":311,"address":[12739125,12739212,12744560,12744578,12738894,12738787],"length":1,"stats":{"Line":2}},{"line":315,"address":[12671050,12671510,12673326,12671829,12671576],"length":1,"stats":{"Line":3}},{"line":316,"address":[12657697],"length":1,"stats":{"Line":1}},{"line":317,"address":[12776309,12776073],"length":1,"stats":{"Line":1}},{"line":318,"address":[12871480,12871244,12871056,12872592],"length":1,"stats":{"Line":2}},{"line":319,"address":[20438160,20438178,20433336],"length":1,"stats":{"Line":0}},{"line":320,"address":[12740018,12739850],"length":1,"stats":{"Line":2}},{"line":330,"address":[12872274,12872037,12871955,12872561],"length":1,"stats":{"Line":2}},{"line":331,"address":[12677104,12677122,12672914],"length":1,"stats":{"Line":0}},{"line":332,"address":[12772066,12772137,12773777,12771818,12773343,12773473],"length":1,"stats":{"Line":5}},{"line":333,"address":[12775950],"length":1,"stats":{"Line":1}},{"line":334,"address":[11691734],"length":1,"stats":{"Line":3}},{"line":335,"address":[12661025,12663504,12663528],"length":1,"stats":{"Line":0}},{"line":337,"address":[12667628,12667894],"length":1,"stats":{"Line":2}},{"line":340,"address":[15242370,15242200,15242330,15242192,15242243,15242525,15242208,15242924],"length":1,"stats":{"Line":0}},{"line":341,"address":[20439207,20439327,20438757,20439105,20439406,20438876,20438947],"length":1,"stats":{"Line":0}},{"line":343,"address":[11738278],"length":1,"stats":{"Line":0}},{"line":344,"address":[12739064,12739040,12738898],"length":1,"stats":{"Line":0}},{"line":345,"address":[12780936],"length":1,"stats":{"Line":0}},{"line":348,"address":[12746128],"length":1,"stats":{"Line":0}},{"line":352,"address":[12672246,12672019,12671621,12671850],"length":1,"stats":{"Line":0}},{"line":353,"address":[12673262,12672152,12671985,12672306,12672702,12671689],"length":1,"stats":{"Line":0}},{"line":354,"address":[12784741,12784153,12784363,12784501],"length":1,"stats":{"Line":0}},{"line":355,"address":[11605132],"length":1,"stats":{"Line":0}},{"line":356,"address":[20442373,20442556,20442884,20442033,20442672,20442327,20443637],"length":1,"stats":{"Line":0}},{"line":357,"address":[12673861,12674060],"length":1,"stats":{"Line":0}},{"line":358,"address":[11704102],"length":1,"stats":{"Line":0}},{"line":359,"address":[15246172,15246695,15246955,15246368],"length":1,"stats":{"Line":0}},{"line":360,"address":[12881384,12882293,12882999,12881761,12881580,12878040],"length":1,"stats":{"Line":0}},{"line":361,"address":[15247482,15247647],"length":1,"stats":{"Line":0}},{"line":362,"address":[20444503],"length":1,"stats":{"Line":0}},{"line":363,"address":[12787885],"length":1,"stats":{"Line":0}},{"line":364,"address":[11708090],"length":1,"stats":{"Line":0}},{"line":366,"address":[12788571],"length":1,"stats":{"Line":0}},{"line":367,"address":[15248500],"length":1,"stats":{"Line":0}},{"line":368,"address":[12883325],"length":1,"stats":{"Line":0}},{"line":372,"address":[12677640,12677962,12678227,12677648,12677683,12677774,12677632,12677811],"length":1,"stats":{"Line":0}},{"line":373,"address":[12789305,12789498,12789253,12789369],"length":1,"stats":{"Line":0}},{"line":376,"address":[12685216],"length":1,"stats":{"Line":0}},{"line":380,"address":[12746495,12746745,12747160,12748075,12746431,12746619],"length":1,"stats":{"Line":0}},{"line":382,"address":[12686266],"length":1,"stats":{"Line":0}},{"line":383,"address":[12672531],"length":1,"stats":{"Line":0}},{"line":384,"address":[12789383],"length":1,"stats":{"Line":0}},{"line":386,"address":[12686676],"length":1,"stats":{"Line":0}},{"line":387,"address":[12789718],"length":1,"stats":{"Line":0}},{"line":388,"address":[12886247,12886180],"length":1,"stats":{"Line":0}},{"line":389,"address":[12687141,12687401,12687003,12687565],"length":1,"stats":{"Line":0}},{"line":392,"address":[12755040,12753444,12755257,12754858,12754923],"length":1,"stats":{"Line":0}},{"line":394,"address":[12795911,12795888],"length":1,"stats":{"Line":0}},{"line":396,"address":[12793737,12792154,12793545,12792285,12793800],"length":1,"stats":{"Line":0}},{"line":397,"address":[20450512,20451562],"length":1,"stats":{"Line":0}},{"line":400,"address":[12758244],"length":1,"stats":{"Line":0}},{"line":401,"address":[12690882,12691224,12690704,12690952,12690555],"length":1,"stats":{"Line":0}},{"line":403,"address":[11599824],"length":1,"stats":{"Line":0}},{"line":404,"address":[12691114,12691550,12691725],"length":1,"stats":{"Line":0}},{"line":405,"address":[12752137,12751971],"length":1,"stats":{"Line":0}},{"line":406,"address":[12684388,12684480],"length":1,"stats":{"Line":0}},{"line":408,"address":[12691789],"length":1,"stats":{"Line":0}},{"line":409,"address":[15256121,15256333],"length":1,"stats":{"Line":0}},{"line":411,"address":[15256425],"length":1,"stats":{"Line":0}},{"line":412,"address":[12795195,12795403],"length":1,"stats":{"Line":0}},{"line":414,"address":[12797159,12790254,12792427,12792736],"length":1,"stats":{"Line":0}},{"line":415,"address":[12887545],"length":1,"stats":{"Line":0}},{"line":416,"address":[12674505,12679440,12674724,12679449],"length":1,"stats":{"Line":0}},{"line":417,"address":[12688629,12688564],"length":1,"stats":{"Line":0}},{"line":418,"address":[12793269,12793399],"length":1,"stats":{"Line":0}},{"line":421,"address":[15253235],"length":1,"stats":{"Line":0}},{"line":426,"address":[12887619],"length":1,"stats":{"Line":0}},{"line":427,"address":[12749854,12749187],"length":1,"stats":{"Line":0}},{"line":432,"address":[12793858],"length":1,"stats":{"Line":0}},{"line":433,"address":[15253692,15254546,15257408],"length":1,"stats":{"Line":0}},{"line":434,"address":[12792190],"length":1,"stats":{"Line":0}},{"line":438,"address":[12689384,12690243,12689496],"length":1,"stats":{"Line":0}},{"line":441,"address":[12761088],"length":1,"stats":{"Line":0}},{"line":445,"address":[12796520,12796675,12796798,12797188,12797825,12796578],"length":1,"stats":{"Line":0}},{"line":446,"address":[12893884,12893771,12893570,12894229],"length":1,"stats":{"Line":0}},{"line":447,"address":[15258791,15258679],"length":1,"stats":{"Line":0}},{"line":448,"address":[12688207,12688312,12688143,12688379,12687728,12687877],"length":1,"stats":{"Line":0}},{"line":450,"address":[11601526],"length":1,"stats":{"Line":0}},{"line":451,"address":[12695392,12695276],"length":1,"stats":{"Line":0}},{"line":452,"address":[12895056,12894719,12894841,12893046],"length":1,"stats":{"Line":0}},{"line":455,"address":[12682352],"length":1,"stats":{"Line":1}},{"line":459,"address":[11629545],"length":1,"stats":{"Line":2}},{"line":461,"address":[12696896],"length":1,"stats":{"Line":1}},{"line":462,"address":[12683153],"length":1,"stats":{"Line":1}},{"line":463,"address":[12799972],"length":1,"stats":{"Line":1}},{"line":465,"address":[12683914,12683497,12684197,12683853,12683666],"length":1,"stats":{"Line":3}},{"line":466,"address":[12802072,12802380,12800948,12802581,12802171],"length":1,"stats":{"Line":4}},{"line":469,"address":[12897504],"length":1,"stats":{"Line":0}},{"line":473,"address":[12684670,12684798,12685261,12686081,12684725,12684909],"length":1,"stats":{"Line":0}},{"line":475,"address":[12692000],"length":1,"stats":{"Line":0}},{"line":476,"address":[12797937],"length":1,"stats":{"Line":0}},{"line":477,"address":[12803700],"length":1,"stats":{"Line":0}},{"line":479,"address":[12767266,12767453,12767514,12767097,12767797],"length":1,"stats":{"Line":0}},{"line":480,"address":[11866876],"length":1,"stats":{"Line":0}},{"line":483,"address":[12693296],"length":1,"stats":{"Line":1}},{"line":487,"address":[11646556],"length":1,"stats":{"Line":2}},{"line":489,"address":[12761983],"length":1,"stats":{"Line":1}},{"line":490,"address":[12805698],"length":1,"stats":{"Line":1}},{"line":491,"address":[20462571],"length":1,"stats":{"Line":1}},{"line":493,"address":[12695158,12694885,12694547,12693684],"length":1,"stats":{"Line":3}},{"line":496,"address":[12808559,12807056,12807032,12807024,12807118,12807311,12807417,12807561],"length":1,"stats":{"Line":4}},{"line":497,"address":[11637698,11637788],"length":1,"stats":{"Line":2}},{"line":498,"address":[20464856,20464711],"length":1,"stats":{"Line":2}},{"line":500,"address":[12696713,12696780],"length":1,"stats":{"Line":2}},{"line":501,"address":[12903124,12902146,12903940,12905000,12903352],"length":1,"stats":{"Line":1}},{"line":502,"address":[12690843,12691016],"length":1,"stats":{"Line":2}},{"line":503,"address":[12691031,12691122],"length":1,"stats":{"Line":2}},{"line":504,"address":[12807842,12807934],"length":1,"stats":{"Line":2}},{"line":505,"address":[12772970],"length":1,"stats":{"Line":1}},{"line":507,"address":[20466456,20466664,20466804,20466541],"length":1,"stats":{"Line":2}},{"line":508,"address":[11844030],"length":1,"stats":{"Line":0}},{"line":509,"address":[12808832],"length":1,"stats":{"Line":0}},{"line":510,"address":[12808888,12809099],"length":1,"stats":{"Line":0}},{"line":512,"address":[15269951,15269876],"length":1,"stats":{"Line":0}},{"line":513,"address":[12706528],"length":1,"stats":{"Line":0}},{"line":514,"address":[12811087],"length":1,"stats":{"Line":0}},{"line":515,"address":[12805570],"length":1,"stats":{"Line":0}},{"line":516,"address":[12692878],"length":1,"stats":{"Line":0}},{"line":518,"address":[12905344],"length":1,"stats":{"Line":0}},{"line":519,"address":[12706080,12706874],"length":1,"stats":{"Line":0}},{"line":524,"address":[12698385,12700036],"length":1,"stats":{"Line":2}},{"line":525,"address":[12774788],"length":1,"stats":{"Line":1}},{"line":526,"address":[19405959],"length":1,"stats":{"Line":1}},{"line":528,"address":[12707639,12707758],"length":1,"stats":{"Line":2}},{"line":529,"address":[12807714,12806723],"length":1,"stats":{"Line":0}},{"line":530,"address":[20470034],"length":1,"stats":{"Line":0}},{"line":532,"address":[12811791],"length":1,"stats":{"Line":0}},{"line":533,"address":[12813374],"length":1,"stats":{"Line":0}},{"line":537,"address":[12907084,12907132,12908038],"length":1,"stats":{"Line":2}},{"line":543,"address":[12770080],"length":1,"stats":{"Line":1}},{"line":547,"address":[11856347,11856220],"length":1,"stats":{"Line":2}},{"line":548,"address":[20472164,20471566,20471666],"length":1,"stats":{"Line":2}},{"line":550,"address":[12909844],"length":1,"stats":{"Line":0}},{"line":551,"address":[12909867],"length":1,"stats":{"Line":0}},{"line":552,"address":[20471960],"length":1,"stats":{"Line":0}},{"line":555,"address":[12696696,12696829],"length":1,"stats":{"Line":2}},{"line":558,"address":[12809582],"length":1,"stats":{"Line":1}},{"line":559,"address":[12778443,12778849],"length":1,"stats":{"Line":2}},{"line":560,"address":[12910508,12910578],"length":1,"stats":{"Line":2}},{"line":561,"address":[11759813],"length":1,"stats":{"Line":1}},{"line":562,"address":[12698598,12698392],"length":1,"stats":{"Line":2}},{"line":563,"address":[12705572,12705450],"length":1,"stats":{"Line":2}},{"line":565,"address":[15276092,15276184],"length":1,"stats":{"Line":2}},{"line":566,"address":[12773808],"length":1,"stats":{"Line":1}},{"line":568,"address":[12713097,12713238,12713006,12713405],"length":1,"stats":{"Line":2}},{"line":569,"address":[15277030,15276784,15273215,15276657],"length":1,"stats":{"Line":0}},{"line":570,"address":[12781672],"length":1,"stats":{"Line":0}},{"line":573,"address":[12818496],"length":1,"stats":{"Line":0}},{"line":574,"address":[12813133],"length":1,"stats":{"Line":0}},{"line":575,"address":[15277543],"length":1,"stats":{"Line":0}},{"line":577,"address":[12775235,12775160],"length":1,"stats":{"Line":0}},{"line":578,"address":[15277907],"length":1,"stats":{"Line":0}},{"line":579,"address":[12782375],"length":1,"stats":{"Line":0}},{"line":580,"address":[12914000],"length":1,"stats":{"Line":0}},{"line":581,"address":[12707727],"length":1,"stats":{"Line":0}},{"line":583,"address":[20475208],"length":1,"stats":{"Line":0}},{"line":584,"address":[12707963,12707064],"length":1,"stats":{"Line":0}},{"line":589,"address":[12775915,12773968],"length":1,"stats":{"Line":2}},{"line":590,"address":[15278431],"length":1,"stats":{"Line":1}},{"line":591,"address":[11761511],"length":1,"stats":{"Line":1}},{"line":593,"address":[12820228,12820347],"length":1,"stats":{"Line":2}},{"line":594,"address":[12818720,12820070],"length":1,"stats":{"Line":0}},{"line":595,"address":[12717238],"length":1,"stats":{"Line":0}},{"line":597,"address":[12816275],"length":1,"stats":{"Line":0}},{"line":598,"address":[15280520],"length":1,"stats":{"Line":0}},{"line":602,"address":[12815342,12814777,12814825,12815249,12816080],"length":1,"stats":{"Line":3}},{"line":604,"address":[12716264,12716289,12716351],"length":1,"stats":{"Line":3}},{"line":606,"address":[12915594],"length":1,"stats":{"Line":1}},{"line":607,"address":[13014517,13014512],"length":1,"stats":{"Line":2}},{"line":611,"address":[12710880],"length":1,"stats":{"Line":2}},{"line":615,"address":[12704388,12704547],"length":1,"stats":{"Line":4}},{"line":616,"address":[12786097],"length":1,"stats":{"Line":2}},{"line":617,"address":[15281637],"length":1,"stats":{"Line":0}},{"line":619,"address":[12917680,12917729],"length":1,"stats":{"Line":3}},{"line":620,"address":[15281684],"length":1,"stats":{"Line":0}},{"line":623,"address":[12920327,12917803,12918468,12918525,12920358,12917722],"length":1,"stats":{"Line":4}},{"line":626,"address":[12705373,12705445],"length":1,"stats":{"Line":2}},{"line":633,"address":[12819409,12819476],"length":1,"stats":{"Line":2}},{"line":634,"address":[12720600],"length":1,"stats":{"Line":1}},{"line":635,"address":[12781813],"length":1,"stats":{"Line":0}},{"line":638,"address":[12822061,12820221,12819689,12817151,12819793,12820853],"length":1,"stats":{"Line":2}},{"line":639,"address":[20483071,20483277,20484884,20484864],"length":1,"stats":{"Line":4}},{"line":641,"address":[12921420],"length":1,"stats":{"Line":1}},{"line":643,"address":[12826713],"length":1,"stats":{"Line":1}},{"line":645,"address":[12921515],"length":1,"stats":{"Line":1}},{"line":646,"address":[12783048],"length":1,"stats":{"Line":1}},{"line":648,"address":[20483470],"length":1,"stats":{"Line":1}},{"line":649,"address":[12921581],"length":1,"stats":{"Line":1}},{"line":652,"address":[12790103,12789887,12791472,12791494],"length":1,"stats":{"Line":4}},{"line":654,"address":[12922302],"length":1,"stats":{"Line":0}},{"line":656,"address":[20483645,20483762],"length":1,"stats":{"Line":2}},{"line":659,"address":[12790370],"length":1,"stats":{"Line":1}},{"line":660,"address":[12825510],"length":1,"stats":{"Line":1}},{"line":661,"address":[12715666],"length":1,"stats":{"Line":1}},{"line":663,"address":[12783520],"length":1,"stats":{"Line":1}},{"line":664,"address":[12825596,12825694],"length":1,"stats":{"Line":2}},{"line":668,"address":[15286182,15286277,15286567,15286688,15286065,15281476],"length":1,"stats":{"Line":2}},{"line":669,"address":[12822365],"length":1,"stats":{"Line":1}},{"line":672,"address":[12784592],"length":1,"stats":{"Line":0}},{"line":676,"address":[11738409],"length":1,"stats":{"Line":0}},{"line":677,"address":[12827797,12827652,12828133,12827460],"length":1,"stats":{"Line":0}},{"line":678,"address":[15288077,15287965],"length":1,"stats":{"Line":0}},{"line":679,"address":[12718537,12718798,12718473,12718073,12718219],"length":1,"stats":{"Line":0}},{"line":681,"address":[12725726,12725225,12724053,12725168,12725315,12725451],"length":1,"stats":{"Line":0}},{"line":682,"address":[11740098],"length":1,"stats":{"Line":0}},{"line":685,"address":[12726416],"length":1,"stats":{"Line":0}},{"line":689,"address":[11618031],"length":1,"stats":{"Line":0}},{"line":690,"address":[12926925,12927270,12926616,12926812],"length":1,"stats":{"Line":0}},{"line":691,"address":[12788540,12788424],"length":1,"stats":{"Line":0}},{"line":692,"address":[12827101,12827165,12827270,12826838,12827337,12826689],"length":1,"stats":{"Line":0}},{"line":694,"address":[19379270],"length":1,"stats":{"Line":0}},{"line":695,"address":[11679030],"length":1,"stats":{"Line":0}},{"line":696,"address":[15291318,15289752,15291643,15291452],"length":1,"stats":{"Line":0}},{"line":699,"address":[12790760,12790160,12790123,12790000,12790035,12790280,12789976,12789968],"length":1,"stats":{"Line":4}},{"line":700,"address":[12729582,12729818,12729926,12729683,12729399,12729272],"length":1,"stats":{"Line":4}},{"line":701,"address":[12715558,12715663,12715720,12715870,12716019,12715615],"length":1,"stats":{"Line":3}},{"line":702,"address":[12832832,12832841],"length":1,"stats":{"Line":2}},{"line":703,"address":[11612218,11612182],"length":1,"stats":{"Line":0}},{"line":706,"address":[12833131,12832992,12833361,12832960,12832968,12833198,12834520,12833027],"length":1,"stats":{"Line":4}},{"line":707,"address":[12791800,12791204,12791457,12791539,12791275,12791050,12792559],"length":1,"stats":{"Line":6}},{"line":710,"address":[11799935],"length":1,"stats":{"Line":4}},{"line":711,"address":[12799840,12799864,12798683],"length":1,"stats":{"Line":0}},{"line":712,"address":[20492098,20492221],"length":1,"stats":{"Line":3}},{"line":713,"address":[12929608,12930961,12931055,12930380],"length":1,"stats":{"Line":2}},{"line":715,"address":[12717392,12717291,12717664],"length":1,"stats":{"Line":2}},{"line":716,"address":[12718498,12717616,12718480],"length":1,"stats":{"Line":0}},{"line":717,"address":[12835810],"length":1,"stats":{"Line":1}},{"line":720,"address":[12793232,12796922,12793264,12793554,12793240,12793311,12793654,12793871],"length":1,"stats":{"Line":4}},{"line":721,"address":[12797148,12793720,12794124,12793508,12793815,12794024,12794406],"length":1,"stats":{"Line":5}},{"line":724,"address":[20494156,20494221,20494287,20494440,20493968],"length":1,"stats":{"Line":3}},{"line":725,"address":[12837088,12837112,12832470],"length":1,"stats":{"Line":0}},{"line":726,"address":[12733482,12733611],"length":1,"stats":{"Line":1}},{"line":727,"address":[12832638],"length":1,"stats":{"Line":1}},{"line":729,"address":[12719896,12720107,12720520,12722456],"length":1,"stats":{"Line":0}},{"line":730,"address":[12933544,12937616,12937634],"length":1,"stats":{"Line":0}},{"line":731,"address":[12734381,12734194],"length":1,"stats":{"Line":0}},{"line":732,"address":[15297129],"length":1,"stats":{"Line":0}},{"line":734,"address":[12734429,12734592,12734816,12736170],"length":1,"stats":{"Line":0}},{"line":735,"address":[15297406,15297553,15298689],"length":1,"stats":{"Line":0}},{"line":736,"address":[12837956],"length":1,"stats":{"Line":0}},{"line":737,"address":[12838165],"length":1,"stats":{"Line":0}},{"line":738,"address":[12839842],"length":1,"stats":{"Line":0}},{"line":739,"address":[12934842,12934902],"length":1,"stats":{"Line":0}},{"line":740,"address":[12736651,12736338,12732773,12735878,12735967],"length":1,"stats":{"Line":0}},{"line":741,"address":[20497830,20498033,20497962,20498676],"length":1,"stats":{"Line":0}},{"line":744,"address":[15295510,15299439,15300092,15299959,15299390],"length":1,"stats":{"Line":0}},{"line":745,"address":[12836539],"length":1,"stats":{"Line":0}},{"line":748,"address":[12937776,12937789,12937849,12938607,12937808,12938011,12939052,12937971],"length":1,"stats":{"Line":4}},{"line":749,"address":[12842122,12841520,12841626,12841850],"length":1,"stats":{"Line":2}},{"line":750,"address":[20500138,20500976,20500994],"length":1,"stats":{"Line":0}},{"line":751,"address":[12807178,12806654,12806884,12807440,12806955,12807287],"length":1,"stats":{"Line":5}},{"line":752,"address":[12843603],"length":1,"stats":{"Line":1}},{"line":753,"address":[12841566,12842044,12842339,12842091,12842207],"length":1,"stats":{"Line":3}},{"line":754,"address":[12938944,12939256,12939232],"length":1,"stats":{"Line":0}},{"line":755,"address":[15302126],"length":1,"stats":{"Line":1}},{"line":758,"address":[12726336,12726470,12727524,12726371,12726328,12726518,12726320,12726681],"length":1,"stats":{"Line":4}},{"line":759,"address":[15302733,15302856,15303191,15303093,15303433,15302923,15303951],"length":1,"stats":{"Line":5}},{"line":762,"address":[11645460],"length":1,"stats":{"Line":3}},{"line":763,"address":[20502688,20502105,20502712],"length":1,"stats":{"Line":0}},{"line":764,"address":[12727092,12727214],"length":1,"stats":{"Line":2}},{"line":765,"address":[12727283,12727533],"length":1,"stats":{"Line":2}},{"line":767,"address":[12808863,12808779,12809392,12809410],"length":1,"stats":{"Line":2}},{"line":770,"address":[12942380,12941339,12941935,12941177,12941117,12941104,12941299,12941136],"length":1,"stats":{"Line":4}},{"line":771,"address":[12941882,12941386,12941610,12941280],"length":1,"stats":{"Line":2}},{"line":772,"address":[12810010,12810866,12810848],"length":1,"stats":{"Line":0}},{"line":773,"address":[20503668,20503739,20504071,20503962,20504224,20503438],"length":1,"stats":{"Line":5}},{"line":774,"address":[12941715],"length":1,"stats":{"Line":1}},{"line":775,"address":[12803487,12803619,12803371,12803324,12802846],"length":1,"stats":{"Line":3}},{"line":776,"address":[12736272,12735984,12736296],"length":1,"stats":{"Line":0}},{"line":777,"address":[12735950],"length":1,"stats":{"Line":1}},{"line":780,"address":[12942720],"length":1,"stats":{"Line":1}},{"line":787,"address":[12736750,12736865],"length":1,"stats":{"Line":2}},{"line":788,"address":[12943161,12943224],"length":1,"stats":{"Line":2}},{"line":789,"address":[12804819],"length":1,"stats":{"Line":0}},{"line":790,"address":[12843496],"length":1,"stats":{"Line":0}},{"line":791,"address":[12847401],"length":1,"stats":{"Line":0}},{"line":794,"address":[12812216],"length":1,"stats":{"Line":0}},{"line":796,"address":[12842919,12842949],"length":1,"stats":{"Line":2}},{"line":797,"address":[12811876,12811782],"length":1,"stats":{"Line":2}},{"line":798,"address":[12811919],"length":1,"stats":{"Line":0}},{"line":799,"address":[12843109],"length":1,"stats":{"Line":0}},{"line":801,"address":[12848805],"length":1,"stats":{"Line":0}},{"line":802,"address":[12805059],"length":1,"stats":{"Line":0}},{"line":806,"address":[12846921,12847257],"length":1,"stats":{"Line":2}},{"line":809,"address":[12847632],"length":1,"stats":{"Line":1}},{"line":815,"address":[12944503],"length":1,"stats":{"Line":1}},{"line":816,"address":[12806182],"length":1,"stats":{"Line":1}},{"line":817,"address":[12731658],"length":1,"stats":{"Line":1}},{"line":818,"address":[20506664,20506731],"length":1,"stats":{"Line":2}},{"line":819,"address":[12806926,12806762,12806415,12806553],"length":1,"stats":{"Line":4}},{"line":822,"address":[12848558,12848623,12848906,12848127,12848689],"length":1,"stats":{"Line":3}},{"line":824,"address":[12850944,12850967],"length":1,"stats":{"Line":0}},{"line":826,"address":[12746286,12748500,12748692,12748755,12746155],"length":1,"stats":{"Line":5}},{"line":827,"address":[20511574,20509994],"length":1,"stats":{"Line":2}},{"line":829,"address":[20511692],"length":1,"stats":{"Line":1}},{"line":830,"address":[12738292,12739424,12743581,12743710],"length":1,"stats":{"Line":3}},{"line":831,"address":[12811866],"length":1,"stats":{"Line":1}},{"line":832,"address":[15313460],"length":1,"stats":{"Line":0}},{"line":833,"address":[12812560,12812635,12812039],"length":1,"stats":{"Line":0}},{"line":837,"address":[12737524,12737336],"length":1,"stats":{"Line":1}},{"line":838,"address":[20507962,20507653,20506505,20512764],"length":1,"stats":{"Line":4}},{"line":839,"address":[12746771],"length":1,"stats":{"Line":1}},{"line":840,"address":[15314473,15309191,15309406,15314464],"length":1,"stats":{"Line":4}},{"line":841,"address":[20508413,20508329],"length":1,"stats":{"Line":2}},{"line":842,"address":[20508427,20508508],"length":1,"stats":{"Line":0}},{"line":843,"address":[12747203],"length":1,"stats":{"Line":0}},{"line":848,"address":[12850130],"length":1,"stats":{"Line":1}},{"line":849,"address":[20508779,20508933],"length":1,"stats":{"Line":1}},{"line":850,"address":[12846623],"length":1,"stats":{"Line":1}},{"line":855,"address":[15309233],"length":1,"stats":{"Line":0}},{"line":856,"address":[12814653,12816265],"length":1,"stats":{"Line":0}},{"line":861,"address":[15311179],"length":1,"stats":{"Line":1}},{"line":862,"address":[12735149,12736417,12738464],"length":1,"stats":{"Line":0}},{"line":863,"address":[12738478],"length":1,"stats":{"Line":0}},{"line":867,"address":[12853398,12853558],"length":1,"stats":{"Line":2}},{"line":868,"address":[12851991],"length":1,"stats":{"Line":1}},{"line":870,"address":[12750133,12749213],"length":1,"stats":{"Line":1}},{"line":876,"address":[12855200],"length":1,"stats":{"Line":1}},{"line":881,"address":[12855912,12855755],"length":1,"stats":{"Line":2}},{"line":882,"address":[12852055,12851995],"length":1,"stats":{"Line":2}},{"line":885,"address":[12864112,12855973,12864147],"length":1,"stats":{"Line":3}},{"line":886,"address":[12820889],"length":1,"stats":{"Line":1}},{"line":887,"address":[20514422],"length":1,"stats":{"Line":1}},{"line":888,"address":[20514496],"length":1,"stats":{"Line":1}},{"line":889,"address":[20514515],"length":1,"stats":{"Line":1}},{"line":891,"address":[20514545,20516516,20514676,20516711,20516648],"length":1,"stats":{"Line":5}},{"line":892,"address":[12741758,12744513],"length":1,"stats":{"Line":2}},{"line":893,"address":[12861317,12856477,12855819,12861185],"length":1,"stats":{"Line":3}},{"line":894,"address":[12751809],"length":1,"stats":{"Line":1}},{"line":895,"address":[12958221],"length":1,"stats":{"Line":0}},{"line":896,"address":[12861837,12863873,12863798],"length":1,"stats":{"Line":0}},{"line":901,"address":[15320984,15321167],"length":1,"stats":{"Line":1}},{"line":902,"address":[12958658],"length":1,"stats":{"Line":1}},{"line":903,"address":[12862539,12862331],"length":1,"stats":{"Line":1}},{"line":905,"address":[12752791],"length":1,"stats":{"Line":1}},{"line":906,"address":[12746146,12746048],"length":1,"stats":{"Line":1}},{"line":908,"address":[12862760,12863265],"length":1,"stats":{"Line":2}},{"line":909,"address":[12863232,12863119],"length":1,"stats":{"Line":2}},{"line":911,"address":[15322430,15322459,15323376,15323411],"length":1,"stats":{"Line":4}},{"line":913,"address":[12864798,12864731],"length":1,"stats":{"Line":0}},{"line":915,"address":[12859331,12859229],"length":1,"stats":{"Line":2}},{"line":916,"address":[12828200,12828461],"length":1,"stats":{"Line":1}},{"line":919,"address":[12865340,12858162,12857488,12858513,12865157],"length":1,"stats":{"Line":5}},{"line":920,"address":[12754015],"length":1,"stats":{"Line":1}},{"line":921,"address":[12822200,12821863,12822095],"length":1,"stats":{"Line":2}},{"line":922,"address":[12740643,12740700,12741033],"length":1,"stats":{"Line":3}},{"line":923,"address":[12857571,12857388],"length":1,"stats":{"Line":2}},{"line":925,"address":[12859089],"length":1,"stats":{"Line":1}},{"line":927,"address":[12754151],"length":1,"stats":{"Line":0}},{"line":928,"address":[15317330,15316427],"length":1,"stats":{"Line":0}},{"line":933,"address":[12823317],"length":1,"stats":{"Line":1}},{"line":934,"address":[12748654],"length":1,"stats":{"Line":0}},{"line":935,"address":[12955022],"length":1,"stats":{"Line":0}},{"line":939,"address":[12823357,12823599,12823541,12823779],"length":1,"stats":{"Line":3}},{"line":940,"address":[12854765],"length":1,"stats":{"Line":0}},{"line":943,"address":[20517285,20517003,20517060,20517337],"length":1,"stats":{"Line":2}},{"line":944,"address":[12761410,12756021,12761392],"length":1,"stats":{"Line":0}},{"line":948,"address":[12859398,12861033,12858991],"length":1,"stats":{"Line":2}},{"line":957,"address":[12761552],"length":1,"stats":{"Line":0}},{"line":962,"address":[20523099],"length":1,"stats":{"Line":0}},{"line":963,"address":[20523243],"length":1,"stats":{"Line":0}},{"line":964,"address":[12755082],"length":1,"stats":{"Line":0}},{"line":966,"address":[15325026,15324149,15324267,15325400,15325341],"length":1,"stats":{"Line":0}},{"line":967,"address":[12862345,12863017],"length":1,"stats":{"Line":0}},{"line":968,"address":[12867112,12866993,12864813,12865221],"length":1,"stats":{"Line":0}},{"line":969,"address":[12963893],"length":1,"stats":{"Line":0}},{"line":970,"address":[12750937],"length":1,"stats":{"Line":0}},{"line":971,"address":[12757908,12757980,12757769],"length":1,"stats":{"Line":0}},{"line":975,"address":[12761951,12764643,12762683,12762375,12764819],"length":1,"stats":{"Line":0}},{"line":976,"address":[12823526],"length":1,"stats":{"Line":0}},{"line":977,"address":[12830502],"length":1,"stats":{"Line":0}},{"line":978,"address":[12867647,12867462],"length":1,"stats":{"Line":0}},{"line":979,"address":[12862003,12861910],"length":1,"stats":{"Line":0}},{"line":980,"address":[12823961,12823855],"length":1,"stats":{"Line":0}},{"line":981,"address":[12865888],"length":1,"stats":{"Line":0}},{"line":985,"address":[12962124],"length":1,"stats":{"Line":0}},{"line":986,"address":[15325167,15324892],"length":1,"stats":{"Line":0}},{"line":991,"address":[15325445],"length":1,"stats":{"Line":0}},{"line":992,"address":[12868048,12866543,12866810],"length":1,"stats":{"Line":0}},{"line":993,"address":[20526398],"length":1,"stats":{"Line":0}},{"line":997,"address":[12831289],"length":1,"stats":{"Line":0}},{"line":998,"address":[12862410],"length":1,"stats":{"Line":0}},{"line":999,"address":[20524729],"length":1,"stats":{"Line":0}},{"line":1003,"address":[20526480],"length":1,"stats":{"Line":0}},{"line":1008,"address":[12868402],"length":1,"stats":{"Line":0}},{"line":1009,"address":[15328382,15327607,15327675],"length":1,"stats":{"Line":0}},{"line":1010,"address":[12870106,12870810,12871020],"length":1,"stats":{"Line":0}},{"line":1013,"address":[12753024],"length":1,"stats":{"Line":0}},{"line":1018,"address":[12966466,12966338],"length":1,"stats":{"Line":0}},{"line":1019,"address":[12872342,12871748,12871699],"length":1,"stats":{"Line":0}},{"line":1020,"address":[12835437,12835327],"length":1,"stats":{"Line":0}},{"line":1021,"address":[12835637,12835469,12834842],"length":1,"stats":{"Line":0}},{"line":1033,"address":[12768240],"length":1,"stats":{"Line":1}},{"line":1034,"address":[12761281],"length":1,"stats":{"Line":1}},{"line":1035,"address":[12761319],"length":1,"stats":{"Line":0}},{"line":1036,"address":[12754550],"length":1,"stats":{"Line":1}},{"line":1037,"address":[12829158],"length":1,"stats":{"Line":1}},{"line":1038,"address":[12867286],"length":1,"stats":{"Line":0}},{"line":1042,"address":[12754608],"length":1,"stats":{"Line":0}},{"line":1046,"address":[12754650],"length":1,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[12754720,12754737],"length":1,"stats":{"Line":0}},{"line":1050,"address":[12829374,12829360],"length":1,"stats":{"Line":0}},{"line":1053,"address":[12768624],"length":1,"stats":{"Line":0}},{"line":1057,"address":[12754906],"length":1,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[12761760,12761777],"length":1,"stats":{"Line":0}},{"line":1061,"address":[12968096,12968110],"length":1,"stats":{"Line":0}},{"line":1064,"address":[12836640,12837045],"length":1,"stats":{"Line":0}},{"line":1068,"address":[12755160],"length":1,"stats":{"Line":0}},{"line":1069,"address":[20530188,20530287,20530361],"length":1,"stats":{"Line":0}},{"line":1070,"address":[12769254,12769128],"length":1,"stats":{"Line":0}},{"line":1072,"address":[12755274],"length":1,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[12968624,12968638],"length":1,"stats":{"Line":0}},{"line":1078,"address":[12968720,12969568],"length":1,"stats":{"Line":1}},{"line":1083,"address":[12872335],"length":1,"stats":{"Line":1}},{"line":1084,"address":[12762789,12762531,12762706],"length":1,"stats":{"Line":0}},{"line":1085,"address":[20531102,20530964,20531207,20531457],"length":1,"stats":{"Line":0}},{"line":1086,"address":[12872851,12872953],"length":1,"stats":{"Line":0}},{"line":1089,"address":[12762602],"length":1,"stats":{"Line":1}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[12756800,12756817],"length":1,"stats":{"Line":2}},{"line":1094,"address":[12872544,12873203],"length":1,"stats":{"Line":2}},{"line":1095,"address":[12770462],"length":1,"stats":{"Line":1}},{"line":1096,"address":[12756666],"length":1,"stats":{"Line":1}},{"line":1099,"address":[12756574],"length":1,"stats":{"Line":1}},{"line":1102,"address":[12831440],"length":1,"stats":{"Line":1}},{"line":1103,"address":[12756892],"length":1,"stats":{"Line":1}},{"line":1104,"address":[12756901],"length":1,"stats":{"Line":0}},{"line":1106,"address":[12873559],"length":1,"stats":{"Line":1}},{"line":1109,"address":[12870670,12869664,12870640],"length":1,"stats":{"Line":1}},{"line":1110,"address":[15332635],"length":1,"stats":{"Line":1}},{"line":1111,"address":[12831679,12832125,12831755,12832592],"length":1,"stats":{"Line":2}},{"line":1112,"address":[20533118],"length":1,"stats":{"Line":0}},{"line":1113,"address":[12839544],"length":1,"stats":{"Line":0}},{"line":1114,"address":[12758029],"length":1,"stats":{"Line":0}},{"line":1117,"address":[12838983,12839136],"length":1,"stats":{"Line":2}},{"line":1118,"address":[20532608],"length":1,"stats":{"Line":1}},{"line":1119,"address":[12876097],"length":1,"stats":{"Line":0}},{"line":1120,"address":[12970873],"length":1,"stats":{"Line":0}},{"line":1126,"address":[20533152],"length":1,"stats":{"Line":1}},{"line":1127,"address":[12832781],"length":1,"stats":{"Line":1}},{"line":1128,"address":[20533243,20533216],"length":1,"stats":{"Line":2}},{"line":1129,"address":[12971488,12971497],"length":1,"stats":{"Line":2}},{"line":1132,"address":[20533424],"length":1,"stats":{"Line":1}},{"line":1133,"address":[12971603],"length":1,"stats":{"Line":1}},{"line":1134,"address":[12875202],"length":1,"stats":{"Line":1}},{"line":1135,"address":[12876871],"length":1,"stats":{"Line":1}},{"line":1138,"address":[12833360,12834083,12834403],"length":1,"stats":{"Line":1}},{"line":1144,"address":[12871536,12871742],"length":1,"stats":{"Line":1}},{"line":1145,"address":[12759100,12759013],"length":1,"stats":{"Line":2}},{"line":1146,"address":[12833730],"length":1,"stats":{"Line":0}},{"line":1148,"address":[12871809,12871860],"length":1,"stats":{"Line":2}},{"line":1149,"address":[12877470,12877520],"length":1,"stats":{"Line":2}},{"line":1150,"address":[12972320],"length":1,"stats":{"Line":1}},{"line":1151,"address":[20534293],"length":1,"stats":{"Line":0}},{"line":1153,"address":[12833943,12833877],"length":1,"stats":{"Line":2}},{"line":1154,"address":[12759462],"length":1,"stats":{"Line":1}},{"line":1157,"address":[12772972,12773260],"length":1,"stats":{"Line":2}},{"line":1158,"address":[12841313],"length":1,"stats":{"Line":0}},{"line":1160,"address":[12841143],"length":1,"stats":{"Line":1}},{"line":1161,"address":[12834241],"length":1,"stats":{"Line":1}},{"line":1163,"address":[12766461],"length":1,"stats":{"Line":1}},{"line":1164,"address":[12766495],"length":1,"stats":{"Line":1}},{"line":1166,"address":[20534705],"length":1,"stats":{"Line":1}},{"line":1169,"address":[12876464,12876918],"length":1,"stats":{"Line":1}},{"line":1174,"address":[12876518],"length":1,"stats":{"Line":1}},{"line":1175,"address":[20534933],"length":1,"stats":{"Line":0}},{"line":1177,"address":[12872649],"length":1,"stats":{"Line":1}},{"line":1178,"address":[12834608],"length":1,"stats":{"Line":0}},{"line":1180,"address":[12876953,12876609,12876944],"length":1,"stats":{"Line":3}},{"line":1181,"address":[12760035],"length":1,"stats":{"Line":1}},{"line":1182,"address":[12841543],"length":1,"stats":{"Line":0}},{"line":1184,"address":[12973120],"length":1,"stats":{"Line":1}},{"line":1185,"address":[12766909],"length":1,"stats":{"Line":0}},{"line":1187,"address":[12878362,12878435],"length":1,"stats":{"Line":2}},{"line":1188,"address":[12834796],"length":1,"stats":{"Line":0}},{"line":1190,"address":[15335742,15335773],"length":1,"stats":{"Line":1}},{"line":1193,"address":[12760336],"length":1,"stats":{"Line":1}},{"line":1197,"address":[15335928,15336049],"length":1,"stats":{"Line":2}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[12873308,12873296],"length":1,"stats":{"Line":0}},{"line":1200,"address":[12767239,12767294],"length":1,"stats":{"Line":0}},{"line":1201,"address":[12835122],"length":1,"stats":{"Line":0}},{"line":1202,"address":[15336126],"length":1,"stats":{"Line":0}},{"line":1205,"address":[12760548],"length":1,"stats":{"Line":0}},{"line":1208,"address":[20535616],"length":1,"stats":{"Line":1}},{"line":1209,"address":[12873424,12873372],"length":1,"stats":{"Line":2}},{"line":1210,"address":[12873456],"length":1,"stats":{"Line":1}},{"line":1211,"address":[12760937,12760928,12760783,12760859],"length":1,"stats":{"Line":4}},{"line":1212,"address":[12760871,12760969,12760960],"length":1,"stats":{"Line":3}},{"line":1214,"address":[12760850],"length":1,"stats":{"Line":1}},{"line":1219,"address":[12974064],"length":1,"stats":{"Line":1}},{"line":1220,"address":[20536080,20536020],"length":1,"stats":{"Line":2}},{"line":1221,"address":[12877787],"length":1,"stats":{"Line":1}},{"line":1222,"address":[15336921,15336833,15336912,15336749],"length":1,"stats":{"Line":4}},{"line":1223,"address":[12775038],"length":1,"stats":{"Line":1}},{"line":1225,"address":[12879541],"length":1,"stats":{"Line":1}},{"line":1230,"address":[12974448],"length":1,"stats":{"Line":1}},{"line":1231,"address":[12761404],"length":1,"stats":{"Line":1}},{"line":1234,"address":[12878096,12878128,12878224,12878233],"length":1,"stats":{"Line":4}},{"line":1237,"address":[12974688],"length":1,"stats":{"Line":1}},{"line":1238,"address":[15337292,15337187],"length":1,"stats":{"Line":2}},{"line":1239,"address":[12761719],"length":1,"stats":{"Line":1}},{"line":1240,"address":[12974853],"length":1,"stats":{"Line":0}},{"line":1242,"address":[12768553],"length":1,"stats":{"Line":1}},{"line":1245,"address":[12836400],"length":1,"stats":{"Line":1}},{"line":1246,"address":[12975097,12974902],"length":1,"stats":{"Line":1}},{"line":1250,"address":[12874722],"length":1,"stats":{"Line":1}},{"line":1251,"address":[12768848],"length":1,"stats":{"Line":1}},{"line":1253,"address":[12775808],"length":1,"stats":{"Line":1}},{"line":1256,"address":[12769447,12768880],"length":1,"stats":{"Line":1}},{"line":1257,"address":[15337673],"length":1,"stats":{"Line":1}},{"line":1258,"address":[15337712],"length":1,"stats":{"Line":1}},{"line":1259,"address":[12880485],"length":1,"stats":{"Line":1}},{"line":1260,"address":[15337877],"length":1,"stats":{"Line":0}},{"line":1262,"address":[12844224,12843976,12844233,12843881],"length":1,"stats":{"Line":4}},{"line":1263,"address":[12975622],"length":1,"stats":{"Line":1}},{"line":1264,"address":[12776292],"length":1,"stats":{"Line":0}},{"line":1266,"address":[12762598,12762644],"length":1,"stats":{"Line":2}},{"line":1269,"address":[12875440],"length":1,"stats":{"Line":1}},{"line":1271,"address":[12844292],"length":1,"stats":{"Line":1}},{"line":1272,"address":[12837466,12837498],"length":1,"stats":{"Line":2}},{"line":1273,"address":[12881183],"length":1,"stats":{"Line":0}},{"line":1277,"address":[12762928],"length":1,"stats":{"Line":1}},{"line":1278,"address":[15338493],"length":1,"stats":{"Line":1}},{"line":1279,"address":[15338553],"length":1,"stats":{"Line":1}},{"line":1280,"address":[12976066],"length":1,"stats":{"Line":1}},{"line":1282,"address":[12769820],"length":1,"stats":{"Line":1}},{"line":1283,"address":[20538106],"length":1,"stats":{"Line":0}},{"line":1285,"address":[12881363],"length":1,"stats":{"Line":1}},{"line":1286,"address":[12776904],"length":1,"stats":{"Line":1}},{"line":1287,"address":[12875841],"length":1,"stats":{"Line":1}},{"line":1289,"address":[15338731],"length":1,"stats":{"Line":1}},{"line":1295,"address":[12772159,12770000],"length":1,"stats":{"Line":1}},{"line":1296,"address":[12976341],"length":1,"stats":{"Line":1}},{"line":1298,"address":[15338888],"length":1,"stats":{"Line":1}},{"line":1299,"address":[12777494],"length":1,"stats":{"Line":0}},{"line":1301,"address":[12777453],"length":1,"stats":{"Line":1}},{"line":1302,"address":[12845300],"length":1,"stats":{"Line":0}},{"line":1304,"address":[12845272],"length":1,"stats":{"Line":1}},{"line":1309,"address":[12770188],"length":1,"stats":{"Line":1}},{"line":1310,"address":[12763866],"length":1,"stats":{"Line":0}},{"line":1312,"address":[12838405],"length":1,"stats":{"Line":1}},{"line":1313,"address":[12845457],"length":1,"stats":{"Line":0}},{"line":1315,"address":[20538860],"length":1,"stats":{"Line":1}},{"line":1316,"address":[12882310],"length":1,"stats":{"Line":0}},{"line":1318,"address":[12845478],"length":1,"stats":{"Line":1}},{"line":1319,"address":[12777808],"length":1,"stats":{"Line":1}},{"line":1320,"address":[15339586],"length":1,"stats":{"Line":0}},{"line":1322,"address":[15339658],"length":1,"stats":{"Line":1}},{"line":1323,"address":[20539108],"length":1,"stats":{"Line":0}},{"line":1325,"address":[12977233],"length":1,"stats":{"Line":1}},{"line":1326,"address":[12977311],"length":1,"stats":{"Line":0}},{"line":1328,"address":[12882496],"length":1,"stats":{"Line":1}},{"line":1333,"address":[15339024],"length":1,"stats":{"Line":1}},{"line":1334,"address":[12838905],"length":1,"stats":{"Line":0}},{"line":1336,"address":[20539236],"length":1,"stats":{"Line":1}},{"line":1337,"address":[12977455],"length":1,"stats":{"Line":0}},{"line":1339,"address":[15339892],"length":1,"stats":{"Line":1}},{"line":1340,"address":[12764457],"length":1,"stats":{"Line":1}},{"line":1342,"address":[12838996],"length":1,"stats":{"Line":1}},{"line":1343,"address":[12977581],"length":1,"stats":{"Line":1}},{"line":1345,"address":[15340111],"length":1,"stats":{"Line":1}},{"line":1347,"address":[20539572,20539454],"length":1,"stats":{"Line":1}},{"line":1352,"address":[12845060],"length":1,"stats":{"Line":1}},{"line":1353,"address":[12846192],"length":1,"stats":{"Line":1}},{"line":1354,"address":[12846179],"length":1,"stats":{"Line":0}},{"line":1356,"address":[12883097,12883024],"length":1,"stats":{"Line":2}},{"line":1357,"address":[15340393],"length":1,"stats":{"Line":0}},{"line":1359,"address":[12846387,12846335],"length":1,"stats":{"Line":2}},{"line":1361,"address":[12882128,12882137],"length":1,"stats":{"Line":2}},{"line":1363,"address":[12877701,12877649],"length":1,"stats":{"Line":2}},{"line":1365,"address":[12840137,12840128],"length":1,"stats":{"Line":2}},{"line":1368,"address":[12778734],"length":1,"stats":{"Line":0}},{"line":1370,"address":[12778843],"length":1,"stats":{"Line":1}},{"line":1371,"address":[12881844],"length":1,"stats":{"Line":0}},{"line":1373,"address":[12883475,12883515],"length":1,"stats":{"Line":2}},{"line":1374,"address":[12878011],"length":1,"stats":{"Line":0}},{"line":1376,"address":[12772105,12772068],"length":1,"stats":{"Line":2}},{"line":1377,"address":[12846847],"length":1,"stats":{"Line":0}},{"line":1381,"address":[15339169],"length":1,"stats":{"Line":0}},{"line":1382,"address":[12978540],"length":1,"stats":{"Line":0}},{"line":1384,"address":[12765405],"length":1,"stats":{"Line":0}},{"line":1388,"address":[12876019],"length":1,"stats":{"Line":0}},{"line":1390,"address":[12877279],"length":1,"stats":{"Line":1}},{"line":1393,"address":[12840176],"length":1,"stats":{"Line":0}},{"line":1394,"address":[12765604],"length":1,"stats":{"Line":0}},{"line":1395,"address":[12847143],"length":1,"stats":{"Line":0}},{"line":1397,"address":[15341151,15341176],"length":1,"stats":{"Line":0}},{"line":1398,"address":[12765649],"length":1,"stats":{"Line":0}},{"line":1402,"address":[12882303],"length":1,"stats":{"Line":0}},{"line":1405,"address":[12882320,12883137,12884351],"length":1,"stats":{"Line":1}},{"line":1411,"address":[12779545],"length":1,"stats":{"Line":1}},{"line":1413,"address":[12885994,12884238,12884154,12885870,12884413,12885946],"length":1,"stats":{"Line":4}},{"line":1414,"address":[12878850,12879210],"length":1,"stats":{"Line":2}},{"line":1417,"address":[12780335,12780388],"length":1,"stats":{"Line":2}},{"line":1418,"address":[12841390,12841262],"length":1,"stats":{"Line":2}},{"line":1422,"address":[12780656,12780487],"length":1,"stats":{"Line":2}},{"line":1425,"address":[15342555,15342475],"length":1,"stats":{"Line":4}},{"line":1426,"address":[12980241,12980190],"length":1,"stats":{"Line":0}},{"line":1427,"address":[12980180],"length":1,"stats":{"Line":2}},{"line":1429,"address":[15342637],"length":1,"stats":{"Line":2}},{"line":1430,"address":[12849126,12848719],"length":1,"stats":{"Line":1}},{"line":1434,"address":[12840624,12840791],"length":1,"stats":{"Line":2}},{"line":1435,"address":[12979386,12979306,12980816,12980870,12981162],"length":1,"stats":{"Line":2}},{"line":1436,"address":[12980886],"length":1,"stats":{"Line":0}},{"line":1437,"address":[12774620],"length":1,"stats":{"Line":0}},{"line":1438,"address":[12767853],"length":1,"stats":{"Line":0}},{"line":1439,"address":[15343398,15343350],"length":1,"stats":{"Line":0}},{"line":1440,"address":[15343385],"length":1,"stats":{"Line":0}},{"line":1444,"address":[12773109,12774896,12774924],"length":1,"stats":{"Line":3}},{"line":1447,"address":[12781968,12782758],"length":1,"stats":{"Line":1}},{"line":1456,"address":[12768444,12768324],"length":1,"stats":{"Line":2}},{"line":1457,"address":[20543463],"length":1,"stats":{"Line":1}},{"line":1458,"address":[12881288],"length":1,"stats":{"Line":1}},{"line":1459,"address":[12782510],"length":1,"stats":{"Line":1}},{"line":1460,"address":[12885434],"length":1,"stats":{"Line":1}},{"line":1461,"address":[12775582,12775746],"length":1,"stats":{"Line":2}},{"line":1462,"address":[12887117,12887199],"length":1,"stats":{"Line":2}},{"line":1463,"address":[12843561,12843470],"length":1,"stats":{"Line":0}},{"line":1464,"address":[20543834],"length":1,"stats":{"Line":1}},{"line":1469,"address":[12777139,12777164,12775824],"length":1,"stats":{"Line":1}},{"line":1474,"address":[12843742,12843670],"length":1,"stats":{"Line":2}},{"line":1478,"address":[12769222,12769319,12769530],"length":1,"stats":{"Line":2}},{"line":1479,"address":[12844151,12844185],"length":1,"stats":{"Line":0}},{"line":1482,"address":[15345196,15345262],"length":1,"stats":{"Line":0}},{"line":1485,"address":[20545044,20545270],"length":1,"stats":{"Line":0}},{"line":1486,"address":[20545097],"length":1,"stats":{"Line":0}},{"line":1491,"address":[12850993],"length":1,"stats":{"Line":1}},{"line":1494,"address":[12983488],"length":1,"stats":{"Line":1}},{"line":1495,"address":[12883158,12883544],"length":1,"stats":{"Line":1}},{"line":1496,"address":[15346024],"length":1,"stats":{"Line":1}},{"line":1498,"address":[12770565],"length":1,"stats":{"Line":1}},{"line":1504,"address":[12777648,12777987],"length":1,"stats":{"Line":0}},{"line":1505,"address":[12777678],"length":1,"stats":{"Line":0}},{"line":1506,"address":[12845508],"length":1,"stats":{"Line":0}},{"line":1507,"address":[12883647],"length":1,"stats":{"Line":0}},{"line":1508,"address":[15346464],"length":1,"stats":{"Line":0}},{"line":1509,"address":[20545956],"length":1,"stats":{"Line":0}},{"line":1510,"address":[12771057,12770992],"length":1,"stats":{"Line":0}},{"line":1514,"address":[12889520],"length":1,"stats":{"Line":1}},{"line":1516,"address":[12883966],"length":1,"stats":{"Line":1}},{"line":1532,"address":[12888352,12890333,12890560],"length":1,"stats":{"Line":0}},{"line":1533,"address":[12892240,12890376,12890154,12892258],"length":1,"stats":{"Line":0}},{"line":1535,"address":[12888665],"length":1,"stats":{"Line":0}},{"line":1536,"address":[12985417,12985339,12986774,12986066,12986982,12985792,12985951,12985271],"length":1,"stats":{"Line":0}},{"line":1537,"address":[12890677,12890563,12890931,13016386,13016368],"length":1,"stats":{"Line":0}},{"line":1538,"address":[12890850,12891248,12891052],"length":1,"stats":{"Line":0}},{"line":1539,"address":[12889552,13014864,13014882],"length":1,"stats":{"Line":0}},{"line":1541,"address":[12779946,12780373,12780092,12780423],"length":1,"stats":{"Line":0}},{"line":1542,"address":[12889908],"length":1,"stats":{"Line":0}},{"line":1543,"address":[12848133],"length":1,"stats":{"Line":0}},{"line":1544,"address":[20548480],"length":1,"stats":{"Line":0}},{"line":1547,"address":[12848944,12848752,12848688,12848880,12848816],"length":1,"stats":{"Line":2}},{"line":1550,"address":[12788865,12797698,12788795,12799797,12794554,12797045,12796971,12789136,12796743,12794203,12788349,12789518,12793975,12797316,12800450,12799723,12796525,12791840,12793757,12791271,12788567,12794936,12800068,12791499,12791569,12791053,12794283,12799277,12799495,12792222],"length":1,"stats":{"Line":8}},{"line":1552,"address":[12799517,12796765,12796700,12788589,12791228,12788797,12799337,12796831,12799583,12788655,12791501,12788409,12793817,12794063,12796973,12791113,12791359,12791293,12794205,12796585,12799725,12788524,12793997,12793932,12799452],"length":1,"stats":{"Line":8}},{"line":1553,"address":[12858100,12863328,12849920,12863168,12862848,12862688,12862866,12863026,12863346,12852624,12860852,12863186,12855338,12862706,12863008],"length":1,"stats":{"Line":0}},{"line":1554,"address":[12786213,12780892,12775474,12780699,12783461,12775281,12783654,12778178,12786406,12777985],"length":1,"stats":{"Line":4}},{"line":1555,"address":[12899113,12888181,12893599,12890885,12896361],"length":1,"stats":{"Line":2}},{"line":1556,"address":[20551203,20552055,20563023,20550511,20558850,20561602,20550983,20553374,20559063,20556631,20562139,20553215,20553587,20556088,20559167,20561443,20550670,20553907,20561919,20556411,20550883,20555929,20558691,20553687,20556301,20557527,20559387,20561815,20554759,20560271],"length":1,"stats":{"Line":8}},{"line":1558,"address":[11639586,11787506,11776434,11772882,11776146],"length":1,"stats":{"Line":6}},{"line":1559,"address":[12897171,12907362,12907522,12907184,12907504,12907824,12907664,12899895,12905403,12907344,12907842,12894467,12907682,12907202,12902651],"length":1,"stats":{"Line":0}},{"line":1560,"address":[12994650,12997406,12989384,12992088,12989222,12991926,13000158,13000320,12997568,12994812],"length":1,"stats":{"Line":4}},{"line":1561,"address":[12776318,12787254,12784502,12781811,12776383,12781746,12779087,12784567,12787319,12779022],"length":1,"stats":{"Line":0}},{"line":1562,"address":[13000431,12989793,13000745,12992497,12997679,12997993,12995243,12994923,12989495,12992199],"length":1,"stats":{"Line":0}},{"line":1564,"address":[12906489,12906537,12906432,12906441,12906480,12906528,12906336,12906345,12906384,12906393],"length":1,"stats":{"Line":0}},{"line":1565,"address":[12864656,12864548,12864784,12864740,12864592,12864528,12864720,12864676,12864612,12864804],"length":1,"stats":{"Line":0}},{"line":1567,"address":[12776815,12782265,12785015,12779519,12787767],"length":1,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1572,"address":[12785957,12783253,12788681,12791357,12794189,12783173,12788601,12785877,12791437,12794109],"length":1,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[12897836,12903600,12889063,12903138,12894491,12891767,12892324,12895092,12903280,12903298,12889620,12903120,12902960,12897247,12903440,12899999,12900588,12903458,12903618,12902978],"length":1,"stats":{"Line":4}}],"covered":413,"coverable":774},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","direct_message_handler.rs"],"content":"use crate::application::services::{\n    DirectMessageConversationPageResult, DirectMessagePageResult, DirectMessageService,\n    DirectMessageServiceDirection, SendDirectMessageResult,\n};\nuse crate::domain::entities::DirectMessage;\nuse crate::presentation::dto::direct_message_dto::{\n    DirectMessageConversationListDto, DirectMessageConversationSummaryDto, DirectMessageDto,\n    DirectMessagePage, ListDirectMessageConversationsRequest, ListDirectMessagesRequest,\n    MarkDirectMessageConversationReadRequest, MessagePageDirection as RequestDirection,\n    SendDirectMessageRequest, SendDirectMessageResponse,\n};\nuse crate::shared::AppError;\nuse std::sync::Arc;\n\npub struct DirectMessageHandler {\n    service: Arc<DirectMessageService>,\n}\n\nimpl DirectMessageHandler {\n    pub fn new(service: Arc<DirectMessageService>) -> Self {\n        Self { service }\n    }\n\n    pub async fn send_direct_message(\n        &self,\n        owner_npub: &str,\n        request: SendDirectMessageRequest,\n    ) -> Result<SendDirectMessageResponse, AppError> {\n        let result = self\n            .service\n            .send_direct_message(\n                owner_npub,\n                &request.recipient_npub,\n                &request.content,\n                request.client_message_id.clone(),\n            )\n            .await?;\n\n        Ok(to_send_response(result))\n    }\n\n    pub async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        request: ListDirectMessagesRequest,\n    ) -> Result<DirectMessagePage, AppError> {\n        let limit = request.limit.map(|value| value as usize);\n        let direction = request\n            .direction\n            .map(map_direction)\n            .unwrap_or(DirectMessageServiceDirection::Backward);\n\n        let page = self\n            .service\n            .list_direct_messages(\n                owner_npub,\n                &request.conversation_npub,\n                request.cursor.as_deref(),\n                limit,\n                direction,\n            )\n            .await?;\n\n        Ok(to_page_dto(page))\n    }\n\n    pub async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        request: ListDirectMessageConversationsRequest,\n    ) -> Result<DirectMessageConversationListDto, AppError> {\n        let limit = request.limit.map(|value| value as usize);\n        let page: DirectMessageConversationPageResult = self\n            .service\n            .list_direct_message_conversations(owner_npub, request.cursor.as_deref(), limit)\n            .await?;\n\n        let items = page\n            .items\n            .into_iter()\n            .map(|summary| DirectMessageConversationSummaryDto {\n                conversation_npub: summary.conversation_npub,\n                unread_count: summary.unread_count,\n                last_read_at: summary.last_read_at,\n                last_message: summary.last_message.map(map_direct_message_to_dto),\n            })\n            .collect();\n\n        Ok(DirectMessageConversationListDto {\n            items,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n        })\n    }\n\n    pub async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        request: MarkDirectMessageConversationReadRequest,\n    ) -> Result<(), AppError> {\n        self.service\n            .mark_conversation_as_read(owner_npub, &request.conversation_npub, request.last_read_at)\n            .await\n    }\n}\n\nfn to_send_response(result: SendDirectMessageResult) -> SendDirectMessageResponse {\n    SendDirectMessageResponse {\n        event_id: result.event_id,\n        queued: result.queued,\n    }\n}\n\nfn to_page_dto(page: DirectMessagePageResult) -> DirectMessagePage {\n    let items = page\n        .items\n        .into_iter()\n        .map(map_direct_message_to_dto)\n        .collect();\n\n    DirectMessagePage {\n        items,\n        next_cursor: page.next_cursor,\n        has_more: page.has_more,\n    }\n}\n\nfn map_direction(direction: RequestDirection) -> DirectMessageServiceDirection {\n    match direction {\n        RequestDirection::Backward => DirectMessageServiceDirection::Backward,\n        RequestDirection::Forward => DirectMessageServiceDirection::Forward,\n    }\n}\n\nfn map_direct_message_to_dto(message: DirectMessage) -> DirectMessageDto {\n    let content = message.decrypted_content.clone().unwrap_or_default();\n    DirectMessageDto {\n        event_id: message.event_id.clone(),\n        client_message_id: message.client_message_id.clone(),\n        sender_npub: message.sender_npub.clone(),\n        recipient_npub: message.recipient_npub.clone(),\n        content,\n        created_at: message.created_at_millis(),\n        delivered: message.delivered,\n    }\n}\n","traces":[{"line":20,"address":[15239600],"length":1,"stats":{"Line":0}},{"line":24,"address":[15307376],"length":1,"stats":{"Line":0}},{"line":29,"address":[26611077,26610530,26610470,26610172,26610760,26610842],"length":1,"stats":{"Line":0}},{"line":33,"address":[15307842],"length":1,"stats":{"Line":0}},{"line":34,"address":[23001359],"length":1,"stats":{"Line":0}},{"line":35,"address":[15301024],"length":1,"stats":{"Line":0}},{"line":37,"address":[11627217],"length":1,"stats":{"Line":0}},{"line":39,"address":[15301646,15301819],"length":1,"stats":{"Line":0}},{"line":42,"address":[15440544],"length":1,"stats":{"Line":0}},{"line":47,"address":[15346258,15346104,15347712,15347716],"length":1,"stats":{"Line":0}},{"line":48,"address":[15241765,15241812],"length":1,"stats":{"Line":0}},{"line":51,"address":[15241804],"length":1,"stats":{"Line":0}},{"line":53,"address":[15242053,15241862,15242340,15242833,15242126,15242484],"length":1,"stats":{"Line":0}},{"line":57,"address":[15241913],"length":1,"stats":{"Line":0}},{"line":58,"address":[15441274],"length":1,"stats":{"Line":0}},{"line":62,"address":[15346181,15346627,15347313,15346932,15346750,15346687],"length":1,"stats":{"Line":0}},{"line":64,"address":[15303518,15303743],"length":1,"stats":{"Line":0}},{"line":67,"address":[15304032],"length":1,"stats":{"Line":0}},{"line":72,"address":[15243616,15243478,15245008,15245012],"length":1,"stats":{"Line":0}},{"line":73,"address":[15342708,15342592,15342969,15343102,15342764,15343419],"length":1,"stats":{"Line":0}},{"line":75,"address":[15311456],"length":1,"stats":{"Line":0}},{"line":76,"address":[23005643,23005305,23005009,23005126,23004756,23005066],"length":1,"stats":{"Line":0}},{"line":78,"address":[26614416,26614617],"length":1,"stats":{"Line":0}},{"line":81,"address":[15444336,15444518,15444590],"length":1,"stats":{"Line":0}},{"line":82,"address":[15349588],"length":1,"stats":{"Line":0}},{"line":83,"address":[15305909],"length":1,"stats":{"Line":0}},{"line":84,"address":[15245089],"length":1,"stats":{"Line":0}},{"line":85,"address":[15231341],"length":1,"stats":{"Line":0}},{"line":89,"address":[23005862],"length":1,"stats":{"Line":0}},{"line":91,"address":[15230847],"length":1,"stats":{"Line":0}},{"line":92,"address":[23005855],"length":1,"stats":{"Line":0}},{"line":96,"address":[26615312],"length":1,"stats":{"Line":0}},{"line":101,"address":[23006933,23006772,23007165,23006982],"length":1,"stats":{"Line":0}},{"line":102,"address":[15350185],"length":1,"stats":{"Line":0}},{"line":103,"address":[11086061],"length":1,"stats":{"Line":0}},{"line":107,"address":[15239200],"length":1,"stats":{"Line":0}},{"line":109,"address":[15232439],"length":1,"stats":{"Line":0}},{"line":110,"address":[15307067],"length":1,"stats":{"Line":0}},{"line":114,"address":[15307413,15307136],"length":1,"stats":{"Line":0}},{"line":115,"address":[15232565,15232650],"length":1,"stats":{"Line":0}},{"line":123,"address":[15314226],"length":1,"stats":{"Line":0}},{"line":124,"address":[15349382],"length":1,"stats":{"Line":0}},{"line":128,"address":[23007824],"length":1,"stats":{"Line":0}},{"line":129,"address":[26616553],"length":1,"stats":{"Line":0}},{"line":130,"address":[15232872],"length":1,"stats":{"Line":0}},{"line":131,"address":[15307471],"length":1,"stats":{"Line":0}},{"line":135,"address":[15247362,15247412,15246656],"length":1,"stats":{"Line":0}},{"line":136,"address":[15349630,15349558],"length":1,"stats":{"Line":0}},{"line":138,"address":[15307616],"length":1,"stats":{"Line":0}},{"line":139,"address":[15349727],"length":1,"stats":{"Line":0}},{"line":140,"address":[15351441],"length":1,"stats":{"Line":0}},{"line":141,"address":[15246979],"length":1,"stats":{"Line":0}},{"line":143,"address":[15240106],"length":1,"stats":{"Line":0}},{"line":144,"address":[23008371],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","event_handler.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::application::services::event_service::EventServiceTrait;\nuse crate::infrastructure::event::EventManagerHandle;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::event::{\n    EventResponse, NostrMetadataDto, NostrSubscriptionStateDto, PublishTextNoteRequest,\n    PublishTopicPostRequest, SendReactionRequest, SubscribeRequest, UpdateMetadataRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse serde_json::json;\nuse std::sync::Arc;\n\npub struct EventHandler {\n    event_service: Arc<dyn EventServiceTrait>,\n    key_manager: Arc<dyn KeyManager>,\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl EventHandler {\n    pub fn new(\n        event_service: Arc<dyn EventServiceTrait>,\n        key_manager: Arc<dyn KeyManager>,\n        event_manager: Arc<dyn EventManagerHandle>,\n    ) -> Self {\n        Self {\n            event_service,\n            key_manager,\n            event_manager,\n        }\n    }\n\n    /// Nostrクライアントを初期化\n    pub async fn initialize_nostr(&self) -> Result<serde_json::Value, AppError> {\n        let keypair = self\n            .key_manager\n            .current_keypair()\n            .await\n            .map_err(|err| match err {\n                AppError::NotFound(_) | AppError::Unauthorized(_) => {\n                    AppError::Unauthorized(format!(\"No active account: {err}\"))\n                }\n                other => other,\n            })?;\n\n        self.event_manager\n            .initialize_with_keypair(keypair)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))?;\n\n        self.event_service.initialize().await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// テキストノートを投稿\n    pub async fn publish_text_note(\n        &self,\n        request: PublishTextNoteRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_text_note(&request.content)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Text note published successfully\".to_string()),\n        })\n    }\n\n    /// トピック投稿を作成\n    pub async fn publish_topic_post(\n        &self,\n        request: PublishTopicPostRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_topic_post(\n                &request.topic_id,\n                &request.content,\n                request.reply_to.as_deref(),\n                None,\n                None,\n            )\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Topic post published successfully\".to_string()),\n        })\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(\n        &self,\n        request: SendReactionRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .send_reaction(&request.event_id, &request.reaction)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Reaction sent successfully\".to_string()),\n        })\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(\n        &self,\n        request: UpdateMetadataRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let metadata = NostrMetadataDto {\n            name: request.metadata.name,\n            display_name: request.metadata.display_name,\n            about: request.metadata.about,\n            picture: request.metadata.picture,\n            banner: request.metadata.banner,\n            nip05: request.metadata.nip05,\n            lud16: request.metadata.lud16,\n            website: request.metadata.website,\n            relays: request.metadata.relays,\n            privacy: request.metadata.privacy,\n        };\n\n        let event_id = self.event_service.update_metadata(metadata).await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Metadata updated successfully\".to_string()),\n        })\n    }\n\n    /// トピックをサブスクライブ\n    pub async fn subscribe_to_topic(\n        &self,\n        request: SubscribeRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        request.validate()?;\n\n        self.event_service\n            .subscribe_to_topic(&request.topic_id)\n            .await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// ユーザーをサブスクライブ\n    pub async fn subscribe_to_user(&self, pubkey: String) -> Result<serde_json::Value, AppError> {\n        if pubkey.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Public key is required\".to_string(),\n            ));\n        }\n\n        self.event_service.subscribe_to_user(&pubkey).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// Nostrクライアントを切断\n    pub async fn disconnect_nostr(&self) -> Result<serde_json::Value, AppError> {\n        self.event_service.disconnect().await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// 現在のNostr購読状態一覧を取得\n    pub async fn list_subscriptions(&self) -> Result<serde_json::Value, AppError> {\n        let records = self.event_service.list_subscriptions().await?;\n        let subscriptions: Vec<NostrSubscriptionStateDto> =\n            records.into_iter().map(Into::into).collect();\n        Ok(json!({ \"subscriptions\": subscriptions }))\n    }\n}\n","traces":[{"line":20,"address":[23145424],"length":1,"stats":{"Line":0}},{"line":33,"address":[15371553,15370064,15370370,15370273,15370072,15370555,15370096,15370143],"length":1,"stats":{"Line":0}},{"line":34,"address":[23144245,23145393,23144040,23144525,23144683,23145073,23144328],"length":1,"stats":{"Line":0}},{"line":37,"address":[11616673],"length":1,"stats":{"Line":0}},{"line":38,"address":[23243168,23243190,23243477],"length":1,"stats":{"Line":0}},{"line":40,"address":[15372985,15372941],"length":1,"stats":{"Line":0}},{"line":42,"address":[23043914],"length":1,"stats":{"Line":0}},{"line":45,"address":[23103580,23103731,23103878,23103231,23102932,23103492,23103301],"length":1,"stats":{"Line":0}},{"line":46,"address":[23042291],"length":1,"stats":{"Line":0}},{"line":47,"address":[10909505],"length":1,"stats":{"Line":0}},{"line":48,"address":[23037248,23035875,23037266],"length":1,"stats":{"Line":0}},{"line":50,"address":[11541977],"length":1,"stats":{"Line":0}},{"line":51,"address":[23242638,23242730],"length":1,"stats":{"Line":0}},{"line":55,"address":[23148912],"length":1,"stats":{"Line":0}},{"line":59,"address":[23030936,23031024,23030817,23031265],"length":1,"stats":{"Line":0}},{"line":61,"address":[23044981,23045498,23045965,23045190,23044763,23044922,23045304],"length":1,"stats":{"Line":0}},{"line":63,"address":[15373785],"length":1,"stats":{"Line":0}},{"line":64,"address":[11650753],"length":1,"stats":{"Line":0}},{"line":66,"address":[23045683],"length":1,"stats":{"Line":0}},{"line":67,"address":[23113180],"length":1,"stats":{"Line":0}},{"line":69,"address":[23113339,23113411],"length":1,"stats":{"Line":0}},{"line":74,"address":[23032224],"length":1,"stats":{"Line":0}},{"line":78,"address":[23040013,23039296,23039418,23039515],"length":1,"stats":{"Line":0}},{"line":80,"address":[23245776,23246602,23246248,23246796,23246135,23246469,23247282],"length":1,"stats":{"Line":0}},{"line":83,"address":[23039616],"length":1,"stats":{"Line":0}},{"line":84,"address":[23245968],"length":1,"stats":{"Line":0}},{"line":85,"address":[23107549],"length":1,"stats":{"Line":0}},{"line":86,"address":[23114559],"length":1,"stats":{"Line":0}},{"line":87,"address":[15375643],"length":1,"stats":{"Line":0}},{"line":89,"address":[11617252],"length":1,"stats":{"Line":0}},{"line":91,"address":[23150549],"length":1,"stats":{"Line":0}},{"line":92,"address":[23146350],"length":1,"stats":{"Line":0}},{"line":94,"address":[23150517,23150445],"length":1,"stats":{"Line":0}},{"line":99,"address":[23152512],"length":1,"stats":{"Line":0}},{"line":103,"address":[23147298,23147176,23147389,23147689],"length":1,"stats":{"Line":0}},{"line":105,"address":[23109256,23109533,23109474,23109742,23109862,23110056,23110529],"length":1,"stats":{"Line":0}},{"line":107,"address":[23116294],"length":1,"stats":{"Line":0}},{"line":108,"address":[11601265],"length":1,"stats":{"Line":0}},{"line":110,"address":[23153937],"length":1,"stats":{"Line":0}},{"line":111,"address":[23148090],"length":1,"stats":{"Line":0}},{"line":113,"address":[23153833,23153905],"length":1,"stats":{"Line":0}},{"line":118,"address":[23117472],"length":1,"stats":{"Line":0}},{"line":122,"address":[17290706,17291935,17290822,17291657],"length":1,"stats":{"Line":0}},{"line":125,"address":[23118103],"length":1,"stats":{"Line":0}},{"line":126,"address":[23050390],"length":1,"stats":{"Line":0}},{"line":127,"address":[23149381],"length":1,"stats":{"Line":0}},{"line":128,"address":[23155012],"length":1,"stats":{"Line":0}},{"line":129,"address":[23153411],"length":1,"stats":{"Line":0}},{"line":130,"address":[23118338],"length":1,"stats":{"Line":0}},{"line":131,"address":[23036865],"length":1,"stats":{"Line":0}},{"line":132,"address":[23249984],"length":1,"stats":{"Line":0}},{"line":133,"address":[23149663],"length":1,"stats":{"Line":0}},{"line":134,"address":[17291310],"length":1,"stats":{"Line":0}},{"line":137,"address":[23051092,23050220,23051448,23051812,23051224],"length":1,"stats":{"Line":0}},{"line":139,"address":[23112877],"length":1,"stats":{"Line":0}},{"line":140,"address":[23150726],"length":1,"stats":{"Line":0}},{"line":142,"address":[23156541,23156469],"length":1,"stats":{"Line":0}},{"line":147,"address":[23114768],"length":1,"stats":{"Line":0}},{"line":151,"address":[17294673,17294880,17295121,17294792],"length":1,"stats":{"Line":0}},{"line":153,"address":[23157354,23157841,23157622,23157726,23158273,23157195,23157413],"length":1,"stats":{"Line":0}},{"line":154,"address":[23054425],"length":1,"stats":{"Line":0}},{"line":155,"address":[23054790,23054549,23054187,23054637,23054913,23054502],"length":1,"stats":{"Line":0}},{"line":157,"address":[23254310,23254218],"length":1,"stats":{"Line":0}},{"line":161,"address":[23041867,23043080,23042295,23041656,23041648,23041696,23042982,23041737],"length":1,"stats":{"Line":0}},{"line":162,"address":[23055719,23055604],"length":1,"stats":{"Line":0}},{"line":163,"address":[23116800],"length":1,"stats":{"Line":0}},{"line":164,"address":[17296295],"length":1,"stats":{"Line":0}},{"line":165,"address":[23160287],"length":1,"stats":{"Line":0}},{"line":169,"address":[23041894,23041970,23042606,23042053,23042327,23043089],"length":1,"stats":{"Line":0}},{"line":171,"address":[23056451,23056359],"length":1,"stats":{"Line":0}},{"line":175,"address":[23159744,23160069,23159795,23159760,23159919,23159882,23159752,23160817],"length":1,"stats":{"Line":0}},{"line":176,"address":[15385601,15385665,15386029,15385557,15385785,15386490],"length":1,"stats":{"Line":0}},{"line":178,"address":[23050584,23050498],"length":1,"stats":{"Line":0}},{"line":182,"address":[23257264,23258769,23257315,23257418,23257272,23257280,23257466,23257616],"length":1,"stats":{"Line":0}},{"line":183,"address":[11755604],"length":1,"stats":{"Line":0}},{"line":184,"address":[23058653,23058840],"length":1,"stats":{"Line":0}},{"line":186,"address":[23126713,23126662,23127195],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","mod.rs"],"content":"pub mod auth_handler;\npub mod community_node_handler;\npub mod direct_message_handler;\npub mod event_handler;\npub mod offline_handler;\npub mod p2p_handler;\npub mod post_handler;\npub mod secure_storage_handler;\npub mod topic_handler;\n\npub use auth_handler::AuthHandler;\npub use community_node_handler::CommunityNodeHandler;\npub use direct_message_handler::DirectMessageHandler;\npub use event_handler::EventHandler;\npub use offline_handler::OfflineHandler;\npub use p2p_handler::P2PHandler;\npub use post_handler::PostHandler;\npub use secure_storage_handler::SecureStorageHandler;\npub use topic_handler::TopicHandler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","offline_handler.rs"],"content":"use crate::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateDraft,\n    SyncQueueItem, SyncQueueItemDraft, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, SyncQueueId, SyncStatus,\n};\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, CacheTypeStatus, GetOfflineActionsRequest,\n    ListSyncQueueItemsRequest, OfflineAction, OptimisticUpdateRequest, SaveOfflineActionRequest,\n    SaveOfflineActionResponse, SyncOfflineActionsRequest, SyncOfflineActionsResponse,\n    SyncQueueItemResponse, UpdateCacheMetadataRequest, UpdateSyncStatusRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{Duration, Utc};\nuse serde_json::{Value, json};\nuse std::convert::{TryFrom, TryInto};\nuse std::sync::Arc;\n\npub struct OfflineHandler {\n    offline_service: Arc<dyn OfflineServiceTrait>,\n}\n\nimpl OfflineHandler {\n    pub fn new(offline_service: Arc<dyn OfflineServiceTrait>) -> Self {\n        Self { offline_service }\n    }\n    pub async fn save_offline_action(\n        &self,\n        request: SaveOfflineActionRequest,\n    ) -> Result<SaveOfflineActionResponse, AppError> {\n        request.validate()?;\n\n        let params = SaveOfflineActionParams {\n            user_pubkey: parse_public_key(&request.user_pubkey)?,\n            action_type: parse_action_type(&request.action_type)?,\n            entity_type: parse_entity_type(&request.entity_type)?,\n            entity_id: parse_entity_id(&request.entity_id)?,\n            payload: parse_payload(&request.data)?,\n        };\n\n        let saved = self.offline_service.save_action(params).await?;\n        let action = map_action_record(&saved.action)?;\n\n        Ok(SaveOfflineActionResponse {\n            local_id: saved.local_id.to_string(),\n            action,\n        })\n    }\n\n    pub async fn get_offline_actions(\n        &self,\n        request: GetOfflineActionsRequest,\n    ) -> Result<Vec<OfflineAction>, AppError> {\n        request.validate()?;\n\n        let query = OfflineActionsQuery {\n            user_pubkey: match request.user_pubkey.as_deref() {\n                Some(value) => Some(parse_public_key(value)?),\n                None => None,\n            },\n            include_synced: request.is_synced,\n            limit: request.limit.map(|value| value as u32),\n        };\n\n        let actions = self.offline_service.list_actions(query).await?;\n        actions\n            .iter()\n            .map(map_action_record)\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub async fn sync_offline_actions(\n        &self,\n        request: SyncOfflineActionsRequest,\n    ) -> Result<SyncOfflineActionsResponse, AppError> {\n        request.validate()?;\n\n        let pubkey = parse_public_key(&request.user_pubkey)?;\n        let result = self.offline_service.sync_actions(pubkey).await?;\n\n        Ok(SyncOfflineActionsResponse {\n            synced_count: i32::try_from(result.synced_count)\n                .map_err(|_| AppError::Internal(\"Synced count overflowed i32\".to_string()))?,\n            failed_count: i32::try_from(result.failed_count)\n                .map_err(|_| AppError::Internal(\"Failed count overflowed i32\".to_string()))?,\n            pending_count: i32::try_from(result.pending_count)\n                .map_err(|_| AppError::Internal(\"Pending count overflowed i32\".to_string()))?,\n        })\n    }\n\n    pub async fn get_cache_status(&self) -> Result<CacheStatusResponse, AppError> {\n        let snapshot = self.offline_service.cache_status().await?;\n        map_cache_status(snapshot)\n    }\n\n    pub async fn add_to_sync_queue(&self, request: AddToSyncQueueRequest) -> Result<i64, AppError> {\n        request.validate()?;\n\n        let draft = SyncQueueItemDraft::new(\n            parse_action_type(&request.action_type)?,\n            OfflinePayload::new(request.payload.clone())\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            request\n                .priority\n                .map(|value| {\n                    u8::try_from(value).map_err(|_| {\n                        AppError::validation(\n                            ValidationFailureKind::Generic,\n                            \"Priority must fit in u8\",\n                        )\n                    })\n                })\n                .transpose()?,\n        );\n        let queue_id = self.offline_service.enqueue_sync(draft).await?;\n\n        if let Some(cache_type) = request\n            .payload\n            .get(\"cacheType\")\n            .and_then(|value| value.as_str())\n        {\n            if let Err(err) = self\n                .record_sync_queue_metadata(cache_type, &request.payload, queue_id)\n                .await\n            {\n                tracing::warn!(\n                    target: \"offline::handler\",\n                    error = %err,\n                    \"failed to update sync_queue metadata for {cache_type}\"\n                );\n            }\n        }\n        Ok(queue_id.value())\n    }\n\n    pub async fn list_sync_queue_items(\n        &self,\n        request: ListSyncQueueItemsRequest,\n    ) -> Result<Vec<SyncQueueItemResponse>, AppError> {\n        request.validate()?;\n        let limit = request\n            .limit\n            .map(|value| {\n                u32::try_from(value).map_err(|_| {\n                    AppError::validation(\n                        ValidationFailureKind::Generic,\n                        \"Limit must fit in u32\".to_string(),\n                    )\n                })\n            })\n            .transpose()?;\n\n        let items = self.offline_service.recent_sync_queue_items(limit).await?;\n\n        items\n            .iter()\n            .map(map_sync_queue_item)\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub async fn update_cache_metadata(\n        &self,\n        request: UpdateCacheMetadataRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = CacheMetadataUpdate {\n            cache_key: CacheKey::new(request.cache_key)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            cache_type: CacheType::new(request.cache_type)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            metadata: request.metadata,\n            is_stale: request.is_stale,\n            expiry: request\n                .expiry_seconds\n                .map(|seconds| {\n                    if seconds <= 0 {\n                        return Err(AppError::validation(\n                            ValidationFailureKind::Generic,\n                            \"Expiry seconds must be positive\".to_string(),\n                        ));\n                    }\n                    Ok(Utc::now() + Duration::seconds(seconds))\n                })\n                .transpose()?,\n            doc_version: request.doc_version,\n            blob_hash: request.blob_hash,\n            payload_bytes: request.payload_bytes,\n        };\n\n        self.offline_service.upsert_cache_metadata(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn save_optimistic_update(\n        &self,\n        request: OptimisticUpdateRequest,\n    ) -> Result<String, AppError> {\n        request.validate()?;\n\n        let draft = OptimisticUpdateDraft::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            match request.original_data {\n                Some(ref data) => Some(parse_payload(data)?),\n                None => None,\n            },\n            parse_payload(&request.updated_data)?,\n        );\n\n        let update_id = self.offline_service.save_optimistic_update(draft).await?;\n        Ok(update_id.to_string())\n    }\n\n    pub async fn confirm_optimistic_update(&self, update_id: String) -> Result<Value, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id)\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        self.offline_service.confirm_optimistic_update(id).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn rollback_optimistic_update(\n        &self,\n        update_id: String,\n    ) -> Result<Option<String>, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id)\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let original = self.offline_service.rollback_optimistic_update(id).await?;\n\n        let serialized = original\n            .map(|payload| serde_json::to_string(&payload.into_inner()))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n\n        Ok(serialized)\n    }\n\n    pub async fn cleanup_expired_cache(&self) -> Result<i32, AppError> {\n        let cleaned = self.offline_service.cleanup_expired_cache().await?;\n        cleaned\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed i32\".to_string()))\n    }\n\n    pub async fn update_sync_status(\n        &self,\n        request: UpdateSyncStatusRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = SyncStatusUpdate::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            map_sync_status(&request.sync_status),\n            parse_optional_payload(request.conflict_data)?,\n            Utc::now(),\n        );\n\n        self.offline_service.update_sync_status(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n}\n\nfn parse_public_key(value: &str) -> Result<PublicKey, AppError> {\n    PublicKey::from_hex_str(value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_action_type(value: &str) -> Result<OfflineActionType, AppError> {\n    OfflineActionType::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_entity_type(value: &str) -> Result<EntityType, AppError> {\n    EntityType::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_entity_id(value: &str) -> Result<EntityId, AppError> {\n    EntityId::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_payload(data: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(data)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_optional_payload(data: Option<String>) -> Result<Option<OfflinePayload>, AppError> {\n    match data {\n        Some(raw) => {\n            let parsed =\n                serde_json::from_str::<Value>(&raw).unwrap_or_else(|_| Value::String(raw.clone()));\n            OfflinePayload::new(parsed)\n                .map(Some)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        }\n        None => Ok(None),\n    }\n}\n\nimpl OfflineHandler {\n    async fn record_sync_queue_metadata(\n        &self,\n        cache_type_str: &str,\n        payload: &Value,\n        queue_id: SyncQueueId,\n    ) -> Result<(), AppError> {\n        let cache_key = CacheKey::new(format!(\"sync_queue::{cache_type_str}\"))\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let cache_type = CacheType::new(\"sync_queue\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        // NOTE: 現状は sync_queue を仮想的なキャッシュ種別としてまとめている。\n        // 将来的にキャッシュ種類ごとのキュー状況を分離する場合はここで cache_type を切り替える。\n\n        let requested_at = payload\n            .get(\"requestedAt\")\n            .and_then(|value| value.as_str())\n            .map(|value| value.to_string())\n            .unwrap_or_else(|| Utc::now().to_rfc3339());\n\n        let metadata = json!({\n            \"cacheType\": cache_type_str,\n            \"requestedAt\": requested_at,\n            \"requestedBy\": payload.get(\"userPubkey\").and_then(|value| value.as_str()),\n            \"source\": payload.get(\"source\").and_then(|value| value.as_str()).unwrap_or(\"unknown\"),\n            \"queueItemId\": queue_id.value(),\n        });\n\n        let doc_version = payload\n            .get(\"docVersion\")\n            .or_else(|| payload.get(\"doc_version\"))\n            .and_then(|value| value.as_i64());\n        let blob_hash = payload\n            .get(\"blobHash\")\n            .or_else(|| payload.get(\"blob_hash\"))\n            .and_then(|value| value.as_str())\n            .map(|value| value.to_string());\n        let payload_bytes = payload\n            .get(\"payloadBytes\")\n            .or_else(|| payload.get(\"payload_bytes\"))\n            .or_else(|| payload.get(\"sizeBytes\"))\n            .and_then(|value| value.as_i64());\n\n        let update = CacheMetadataUpdate {\n            cache_key,\n            cache_type,\n            metadata: Some(metadata),\n            expiry: Some(Utc::now() + Duration::minutes(30)),\n            is_stale: Some(true),\n            doc_version,\n            blob_hash,\n            payload_bytes,\n        };\n\n        self.offline_service.upsert_cache_metadata(update).await\n    }\n}\n\npub(crate) fn map_action_record(record: &OfflineActionRecord) -> Result<OfflineAction, AppError> {\n    Ok(OfflineAction {\n        id: record.record_id.unwrap_or_default(),\n        user_pubkey: record.user_pubkey.as_hex().to_string(),\n        action_type: record.action_type.as_str().to_string(),\n        target_id: record.target_id.as_ref().map(ToString::to_string),\n        action_data: serde_json::to_string(record.payload.as_json())\n            .map_err(|err| AppError::SerializationError(err.to_string()))?,\n        local_id: record.action_id.to_string(),\n        remote_id: record.remote_id.as_ref().map(ToString::to_string),\n        is_synced: matches!(record.sync_status, SyncStatus::FullySynced),\n        created_at: record.created_at.timestamp(),\n        synced_at: record.synced_at.map(|ts| ts.timestamp()),\n        error_message: record.error_message.clone(),\n    })\n}\n\nfn map_sync_queue_item(item: &SyncQueueItem) -> Result<SyncQueueItemResponse, AppError> {\n    Ok(SyncQueueItemResponse {\n        id: item.id.value(),\n        action_type: item.action_type.as_str().to_string(),\n        status: item.status.as_str().to_string(),\n        retry_count: i32::try_from(item.retry_count)\n            .map_err(|_| AppError::Internal(\"retry_count overflowed i32\".to_string()))?,\n        max_retries: i32::try_from(item.max_retries)\n            .map_err(|_| AppError::Internal(\"max_retries overflowed i32\".to_string()))?,\n        created_at: item.created_at.timestamp(),\n        updated_at: item.updated_at.timestamp(),\n        synced_at: item.synced_at.map(|ts| ts.timestamp()),\n        error_message: item.error_message.clone(),\n        payload: item.payload.as_json().clone(),\n    })\n}\n\nfn map_cache_status(snapshot: CacheStatusSnapshot) -> Result<CacheStatusResponse, AppError> {\n    let cache_types = snapshot\n        .cache_types\n        .into_iter()\n        .map(|status| {\n            Ok(CacheTypeStatus {\n                cache_type: status.cache_type.to_string(),\n                item_count: status.item_count.try_into().map_err(|_| {\n                    AppError::Internal(\"Cache item count overflowed i64\".to_string())\n                })?,\n                last_synced_at: status.last_synced_at.map(|dt| dt.timestamp()),\n                is_stale: status.is_stale,\n                metadata: status.metadata,\n                doc_version: status.doc_version,\n                blob_hash: status.blob_hash.clone(),\n                payload_bytes: status.payload_bytes,\n            })\n        })\n        .collect::<Result<Vec<_>, AppError>>()?;\n\n    Ok(CacheStatusResponse {\n        total_items: snapshot\n            .total_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Total items overflowed i64\".to_string()))?,\n        stale_items: snapshot\n            .stale_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Stale items overflowed i64\".to_string()))?,\n        cache_types,\n    })\n}\n\nfn map_sync_status(value: &str) -> SyncStatus {\n    match value {\n        \"pending\" => SyncStatus::Pending,\n        \"syncing\" => SyncStatus::SentToP2P,\n        \"synced\" => SyncStatus::FullySynced,\n        \"failed\" => SyncStatus::Failed,\n        \"conflict\" => SyncStatus::Conflict,\n        other => SyncStatus::from(other),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::offline_store::OfflinePersistence;\n    use crate::application::services::offline_service::OfflineService;\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\n    use sqlx::sqlite::SqlitePoolOptions;\n    use sqlx::{Pool, Sqlite};\n    use std::sync::Arc;\n\n    async fn setup_handler() -> (OfflineHandler, Pool<Sqlite>) {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"in-memory sqlite\");\n        sqlx::migrate!(\"./migrations\")\n            .run(&pool)\n            .await\n            .expect(\"migrations\");\n\n        let persistence: Arc<dyn OfflinePersistence> =\n            Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n        let service = OfflineService::new(persistence);\n        (OfflineHandler::new(Arc::new(service)), pool)\n    }\n\n    #[tokio::test]\n    async fn add_to_sync_queue_records_metadata_entry() {\n        let (handler, pool) = setup_handler().await;\n        let request = AddToSyncQueueRequest {\n            action_type: \"manual_sync_refresh\".to_string(),\n            payload: serde_json::json!({\n                \"cacheType\": \"offline_actions\",\n                \"requestedAt\": \"2025-11-09T00:00:00Z\",\n                \"source\": \"sync_status_indicator\",\n                \"userPubkey\": \"npub1testexample\",\n                \"docVersion\": 7,\n                \"blobHash\": \"bafy-doc-test\",\n                \"payloadBytes\": 5120\n            }),\n            priority: Some(5),\n        };\n\n        let queue_id = handler.add_to_sync_queue(request).await.expect(\"queue id\");\n\n        let (cache_key, cache_type, metadata, doc_version, blob_hash, payload_bytes): (\n            String,\n            String,\n            Option<String>,\n            Option<i64>,\n            Option<String>,\n            Option<i64>,\n        ) = sqlx::query_as(\n            r#\"\n                SELECT cache_key, cache_type, metadata, doc_version, blob_hash, payload_bytes\n                FROM cache_metadata\n                WHERE cache_key = 'sync_queue::offline_actions'\n                \"#,\n        )\n        .fetch_one(&pool)\n        .await\n        .expect(\"metadata row\");\n\n        assert_eq!(cache_key, \"sync_queue::offline_actions\");\n        assert_eq!(cache_type, \"sync_queue\");\n\n        let json = metadata.expect(\"metadata json\");\n        let parsed: serde_json::Value = serde_json::from_str(&json).expect(\"parse metadata\");\n        assert_eq!(\n            parsed.get(\"queueItemId\").and_then(|value| value.as_i64()),\n            Some(queue_id)\n        );\n        assert_eq!(\n            parsed.get(\"requestedBy\").and_then(|value| value.as_str()),\n            Some(\"npub1testexample\")\n        );\n        assert_eq!(\n            parsed.get(\"source\").and_then(|value| value.as_str()),\n            Some(\"sync_status_indicator\")\n        );\n        assert_eq!(doc_version, Some(7));\n        assert_eq!(blob_hash.as_deref(), Some(\"bafy-doc-test\"));\n        assert_eq!(payload_bytes, Some(5120));\n    }\n\n    #[tokio::test]\n    async fn cache_status_includes_doc_fields() {\n        let (handler, _) = setup_handler().await;\n        handler\n            .update_cache_metadata(UpdateCacheMetadataRequest {\n                cache_key: \"doc::profile_avatar::npub1\".to_string(),\n                cache_type: \"profile_avatar\".to_string(),\n                metadata: Some(json!({ \"cacheType\": \"profile_avatar\" })),\n                expiry_seconds: Some(1800),\n                is_stale: Some(true),\n                doc_version: Some(12),\n                blob_hash: Some(\"bafy-test-hash\".to_string()),\n                payload_bytes: Some(10_240),\n            })\n            .await\n            .expect(\"metadata write\");\n\n        let snapshot = handler.get_cache_status().await.expect(\"cache status\");\n        let entry = snapshot\n            .cache_types\n            .into_iter()\n            .find(|value| value.cache_type == \"profile_avatar\")\n            .expect(\"profile avatar cache\");\n\n        assert_eq!(entry.doc_version, Some(12));\n        assert_eq!(entry.blob_hash.as_deref(), Some(\"bafy-test-hash\"));\n        assert_eq!(entry.payload_bytes, Some(10_240));\n    }\n\n    #[tokio::test]\n    async fn list_sync_queue_items_returns_recent_rows() {\n        let (handler, pool) = setup_handler().await;\n\n        let first_id = handler\n            .add_to_sync_queue(AddToSyncQueueRequest {\n                action_type: \"manual_sync_refresh\".to_string(),\n                payload: serde_json::json!({\n                    \"cacheType\": \"offline_actions\",\n                    \"source\": \"sync_status_indicator\"\n                }),\n                priority: Some(3),\n            })\n            .await\n            .expect(\"first queue id\");\n\n        let second_id = handler\n            .add_to_sync_queue(AddToSyncQueueRequest {\n                action_type: \"manual_sync_refresh\".to_string(),\n                payload: serde_json::json!({\n                    \"cacheType\": \"cache_metadata\",\n                    \"source\": \"sync_status_indicator\"\n                }),\n                priority: Some(2),\n            })\n            .await\n            .expect(\"second queue id\");\n\n        sqlx::query(\n            r#\"\n            UPDATE sync_queue\n            SET status = 'failed',\n                error_message = 'timeout',\n                updated_at = strftime('%s','now')\n            WHERE id = ?1\n            \"#,\n        )\n        .bind(first_id)\n        .execute(&pool)\n        .await\n        .expect(\"update queue row\");\n\n        let items = handler\n            .list_sync_queue_items(ListSyncQueueItemsRequest { limit: Some(10) })\n            .await\n            .expect(\"queue items\");\n\n        assert!(\n            items.len() >= 2,\n            \"expected at least two queue items, got {}\",\n            items.len()\n        );\n\n        let failed = items\n            .iter()\n            .find(|item| item.id == first_id)\n            .expect(\"failed queue item present\");\n        assert_eq!(failed.status, \"failed\");\n        assert_eq!(failed.error_message.as_deref(), Some(\"timeout\"));\n\n        assert!(\n            items.iter().any(|item| item.id == second_id),\n            \"second queue id should be present\"\n        );\n    }\n}\n","traces":[{"line":31,"address":[13651248],"length":1,"stats":{"Line":1}},{"line":34,"address":[13534640],"length":1,"stats":{"Line":0}},{"line":38,"address":[13647697,13647916,13650844,13647819],"length":1,"stats":{"Line":0}},{"line":41,"address":[13541961,13542299,13544919,13542123],"length":1,"stats":{"Line":0}},{"line":42,"address":[13654124,13653948,13653762],"length":1,"stats":{"Line":0}},{"line":43,"address":[19328780,19329120,19328963],"length":1,"stats":{"Line":0}},{"line":44,"address":[13652942,13653118,13652756],"length":1,"stats":{"Line":0}},{"line":45,"address":[13536437,13536943,13536623],"length":1,"stats":{"Line":0}},{"line":48,"address":[11682276],"length":1,"stats":{"Line":0}},{"line":49,"address":[13538695,13538544,13538848],"length":1,"stats":{"Line":0}},{"line":51,"address":[13545821],"length":1,"stats":{"Line":0}},{"line":52,"address":[13613410],"length":1,"stats":{"Line":0}},{"line":53,"address":[13651724],"length":1,"stats":{"Line":0}},{"line":57,"address":[13546112],"length":1,"stats":{"Line":0}},{"line":61,"address":[13546372,13546494,13546595,13547519],"length":1,"stats":{"Line":0}},{"line":64,"address":[13546556,13546719],"length":1,"stats":{"Line":0}},{"line":68,"address":[21315027],"length":1,"stats":{"Line":0}},{"line":69,"address":[13555334,13553826,13555328],"length":1,"stats":{"Line":0}},{"line":72,"address":[11678129],"length":1,"stats":{"Line":0}},{"line":73,"address":[13754198,13754369],"length":1,"stats":{"Line":0}},{"line":79,"address":[13548368],"length":1,"stats":{"Line":0}},{"line":83,"address":[21316890,21316981,21317585,21316771],"length":1,"stats":{"Line":0}},{"line":85,"address":[13755665,13755195,13755048,13755371],"length":1,"stats":{"Line":0}},{"line":86,"address":[11687345],"length":1,"stats":{"Line":0}},{"line":88,"address":[13756654],"length":1,"stats":{"Line":0}},{"line":89,"address":[13655670,13655785,13656576,13655944],"length":1,"stats":{"Line":0}},{"line":90,"address":[13549976,13550704,13550718],"length":1,"stats":{"Line":0}},{"line":91,"address":[19335843,19335986,19336386,19335724],"length":1,"stats":{"Line":0}},{"line":92,"address":[13660656,13660670,13660036],"length":1,"stats":{"Line":0}},{"line":93,"address":[13618454,13617966,13618319,13618081],"length":1,"stats":{"Line":0}},{"line":94,"address":[13660752,13660766,13660319],"length":1,"stats":{"Line":0}},{"line":98,"address":[13662504,13662512,13662690,13662642,13662547,13662839,13662496,13663483],"length":1,"stats":{"Line":4}},{"line":99,"address":[13619175,13619048,13618925,13618973,13619596],"length":1,"stats":{"Line":3}},{"line":100,"address":[13657631],"length":1,"stats":{"Line":1}},{"line":103,"address":[13545216,13548617,13545251,13547497,13545296,13545544,13545343,13547817],"length":1,"stats":{"Line":4}},{"line":104,"address":[13658217,13660493,13658457,13658360],"length":1,"stats":{"Line":2}},{"line":107,"address":[13627238,13627563,13627393],"length":1,"stats":{"Line":2}},{"line":108,"address":[13662963,13662656,13663042,13663223,13662917,13662803],"length":1,"stats":{"Line":5}},{"line":109,"address":[13628055,13627835,13629226,13627648,13627718],"length":1,"stats":{"Line":2}},{"line":110,"address":[21321738,21321475,21321727,21321860,21321640],"length":1,"stats":{"Line":4}},{"line":112,"address":[13625552],"length":1,"stats":{"Line":1}},{"line":113,"address":[19343293,19343328],"length":1,"stats":{"Line":1}},{"line":114,"address":[13551057],"length":1,"stats":{"Line":0}},{"line":115,"address":[13667692],"length":1,"stats":{"Line":0}},{"line":120,"address":[13759908],"length":1,"stats":{"Line":0}},{"line":122,"address":[11674271],"length":1,"stats":{"Line":3}},{"line":124,"address":[13664935,13664799],"length":1,"stats":{"Line":2}},{"line":127,"address":[13667753,13667744],"length":1,"stats":{"Line":2}},{"line":129,"address":[13630519,13629981,13629970,13630355,13630064,13629941],"length":1,"stats":{"Line":6}},{"line":130,"address":[13562189,13562214],"length":1,"stats":{"Line":2}},{"line":131,"address":[11668710],"length":1,"stats":{"Line":4}},{"line":133,"address":[13667962,13667360,13763759,13763625,13667461],"length":1,"stats":{"Line":0}},{"line":140,"address":[19340811,19343181],"length":1,"stats":{"Line":2}},{"line":143,"address":[13557920],"length":1,"stats":{"Line":1}},{"line":147,"address":[13551999,13551528,13551315,13551433],"length":1,"stats":{"Line":2}},{"line":148,"address":[13764567,13764669,13765015,13764858],"length":1,"stats":{"Line":2}},{"line":150,"address":[13559440],"length":1,"stats":{"Line":1}},{"line":151,"address":[13627277,13627312],"length":1,"stats":{"Line":1}},{"line":152,"address":[13634285],"length":1,"stats":{"Line":0}},{"line":153,"address":[13627325],"length":1,"stats":{"Line":0}},{"line":154,"address":[13627330],"length":1,"stats":{"Line":0}},{"line":160,"address":[21326693,21327621,21326349,21326814,21327009,21327372],"length":1,"stats":{"Line":3}},{"line":162,"address":[13665068,13665239],"length":1,"stats":{"Line":2}},{"line":168,"address":[13552800],"length":1,"stats":{"Line":1}},{"line":172,"address":[13560046,13562383,13559930,13560182],"length":1,"stats":{"Line":2}},{"line":175,"address":[13560286,13562356,13560413,13560479,13560694,13560108,13560367],"length":1,"stats":{"Line":5}},{"line":177,"address":[13666767,13666884,13667123,13666492,13666686,13666813],"length":1,"stats":{"Line":5}},{"line":179,"address":[13568033],"length":1,"stats":{"Line":1}},{"line":180,"address":[13667024],"length":1,"stats":{"Line":1}},{"line":181,"address":[13670975,13671140,13671623],"length":1,"stats":{"Line":2}},{"line":193,"address":[13629215],"length":1,"stats":{"Line":1}},{"line":194,"address":[13636162],"length":1,"stats":{"Line":1}},{"line":195,"address":[21329660],"length":1,"stats":{"Line":1}},{"line":198,"address":[13669844,13673097,13672296,13671551,13671705,13672572],"length":1,"stats":{"Line":3}},{"line":199,"address":[13668721,13668629],"length":1,"stats":{"Line":2}},{"line":202,"address":[13638864],"length":1,"stats":{"Line":0}},{"line":206,"address":[13635006,13632267,13632480,13632389],"length":1,"stats":{"Line":0}},{"line":209,"address":[13571619,13571762,13571937],"length":1,"stats":{"Line":0}},{"line":210,"address":[13676433,13678591,13676835,13676612],"length":1,"stats":{"Line":0}},{"line":211,"address":[13565287],"length":1,"stats":{"Line":0}},{"line":212,"address":[21333763,21333626],"length":1,"stats":{"Line":0}},{"line":213,"address":[13675272],"length":1,"stats":{"Line":0}},{"line":215,"address":[13572902,13573080,13572450],"length":1,"stats":{"Line":0}},{"line":218,"address":[13635768,13632328,13634082,13634161,13635066,13635435],"length":1,"stats":{"Line":0}},{"line":219,"address":[13673676,13673517],"length":1,"stats":{"Line":0}},{"line":222,"address":[19353072,19354134,19353155,19353120,19353080,19353302,19355017,19354214],"length":1,"stats":{"Line":0}},{"line":223,"address":[13678172,13678066],"length":1,"stats":{"Line":0}},{"line":224,"address":[13678962],"length":1,"stats":{"Line":0}},{"line":225,"address":[21336579],"length":1,"stats":{"Line":0}},{"line":226,"address":[13678251],"length":1,"stats":{"Line":0}},{"line":230,"address":[19353710,19353394,19353878,19353609,19353667,19354103,19353532],"length":1,"stats":{"Line":0}},{"line":231,"address":[13679976,13680087,13679933,13680282,13680579],"length":1,"stats":{"Line":0}},{"line":232,"address":[11805361],"length":1,"stats":{"Line":0}},{"line":234,"address":[13644208,13644300],"length":1,"stats":{"Line":0}},{"line":237,"address":[13563312],"length":1,"stats":{"Line":0}},{"line":241,"address":[13577396,13577290],"length":1,"stats":{"Line":0}},{"line":242,"address":[13677141],"length":1,"stats":{"Line":0}},{"line":243,"address":[13563707],"length":1,"stats":{"Line":0}},{"line":244,"address":[13645235],"length":1,"stats":{"Line":0}},{"line":248,"address":[13776856,13776937,13777046,13777221,13776714,13776983,13777465],"length":1,"stats":{"Line":0}},{"line":249,"address":[13645269,13645423,13645312,13645621,13645926],"length":1,"stats":{"Line":0}},{"line":250,"address":[11602142],"length":1,"stats":{"Line":0}},{"line":252,"address":[13578631,13579114,13578824,13579193],"length":1,"stats":{"Line":0}},{"line":253,"address":[13647134,13647120],"length":1,"stats":{"Line":0}},{"line":255,"address":[13678010,13678432,13678450],"length":1,"stats":{"Line":0}},{"line":257,"address":[13646742],"length":1,"stats":{"Line":0}},{"line":260,"address":[13579664,13579823,13579699,13579656,13580436,13579973,13579648,13579786],"length":1,"stats":{"Line":0}},{"line":261,"address":[11586036],"length":1,"stats":{"Line":0}},{"line":262,"address":[13573392,13573286],"length":1,"stats":{"Line":0}},{"line":264,"address":[13573486,13573472],"length":1,"stats":{"Line":0}},{"line":267,"address":[21341760],"length":1,"stats":{"Line":0}},{"line":271,"address":[13576488,13573928,13574047,13574138],"length":1,"stats":{"Line":0}},{"line":274,"address":[13567325,13567643,13567468],"length":1,"stats":{"Line":0}},{"line":275,"address":[13781040,13780862,13780683],"length":1,"stats":{"Line":0}},{"line":276,"address":[13567933,13568115],"length":1,"stats":{"Line":0}},{"line":277,"address":[13574926,13575201,13575058],"length":1,"stats":{"Line":0}},{"line":278,"address":[13649918],"length":1,"stats":{"Line":0}},{"line":281,"address":[13583524,13583814,13580962,13582525,13584484,13582446],"length":1,"stats":{"Line":0}},{"line":282,"address":[13688335,13688427],"length":1,"stats":{"Line":0}},{"line":286,"address":[13683840,13684012,13683986],"length":1,"stats":{"Line":0}},{"line":287,"address":[13784232,13784315],"length":1,"stats":{"Line":0}},{"line":288,"address":[13652704,13652792,13652812],"length":1,"stats":{"Line":0}},{"line":291,"address":[19363037,19362848,19363015],"length":1,"stats":{"Line":1}},{"line":292,"address":[13646057,13645947],"length":1,"stats":{"Line":2}},{"line":293,"address":[13688134,13688157,13688043],"length":1,"stats":{"Line":2}},{"line":296,"address":[13578336,13578515,13578541],"length":1,"stats":{"Line":0}},{"line":297,"address":[13578473,13578363],"length":1,"stats":{"Line":0}},{"line":298,"address":[13653238,13653147,13653261],"length":1,"stats":{"Line":0}},{"line":301,"address":[13578739,13578765,13578560],"length":1,"stats":{"Line":0}},{"line":302,"address":[13578587,13578697],"length":1,"stats":{"Line":0}},{"line":303,"address":[13578749,13578635,13578726],"length":1,"stats":{"Line":0}},{"line":306,"address":[13578956,13578784,13578930],"length":1,"stats":{"Line":0}},{"line":307,"address":[21347000,21347083],"length":1,"stats":{"Line":0}},{"line":308,"address":[13684752,13684840,13684860],"length":1,"stats":{"Line":0}},{"line":311,"address":[13688832,13689327],"length":1,"stats":{"Line":0}},{"line":312,"address":[21347190],"length":1,"stats":{"Line":0}},{"line":313,"address":[13688963],"length":1,"stats":{"Line":0}},{"line":314,"address":[13647335,13647018,13647312,13646937],"length":1,"stats":{"Line":0}},{"line":316,"address":[13689115,13689251],"length":1,"stats":{"Line":0}},{"line":317,"address":[13785598],"length":1,"stats":{"Line":0}},{"line":318,"address":[13586294,13586401,13586425],"length":1,"stats":{"Line":0}},{"line":320,"address":[13646849],"length":1,"stats":{"Line":0}},{"line":325,"address":[19364304],"length":1,"stats":{"Line":1}},{"line":331,"address":[19364793,19369481,19365306,19365002,19364688,19365126,19365060],"length":1,"stats":{"Line":5}},{"line":332,"address":[13587094,13587610,13587264,13592015,13587384],"length":1,"stats":{"Line":2}},{"line":333,"address":[13574214,13573970,13574130,13574405,13573819,13574084],"length":1,"stats":{"Line":5}},{"line":334,"address":[21349333,21353153,21349098,21348981,21348911],"length":1,"stats":{"Line":2}},{"line":338,"address":[13691135,13690963],"length":1,"stats":{"Line":2}},{"line":340,"address":[13585577,13585568],"length":1,"stats":{"Line":2}},{"line":341,"address":[13578838,13578816],"length":1,"stats":{"Line":2}},{"line":342,"address":[19370112,19370126],"length":1,"stats":{"Line":2}},{"line":344,"address":[19369269,19366039,19366828,19367266,19367509,19367193,19366708,19365972,19367582,19367063],"length":1,"stats":{"Line":5}},{"line":347,"address":[13727296,13656912,13727305,13656832],"length":1,"stats":{"Line":4}},{"line":348,"address":[13762457,13692537,13692398,13692315,13762448],"length":1,"stats":{"Line":5}},{"line":349,"address":[13688913,13688833],"length":1,"stats":{"Line":2}},{"line":352,"address":[13657964,13658056],"length":1,"stats":{"Line":2}},{"line":354,"address":[13592688,13592693],"length":1,"stats":{"Line":2}},{"line":355,"address":[19370208,19370217],"length":1,"stats":{"Line":2}},{"line":356,"address":[13658172,13658258],"length":1,"stats":{"Line":2}},{"line":358,"address":[13578997,13578992],"length":1,"stats":{"Line":2}},{"line":359,"address":[13792096,13792105],"length":1,"stats":{"Line":2}},{"line":360,"address":[13792150,13792128,13789907],"length":1,"stats":{"Line":3}},{"line":361,"address":[13651439,13651531],"length":1,"stats":{"Line":2}},{"line":363,"address":[13579104,13579109],"length":1,"stats":{"Line":2}},{"line":364,"address":[21354112,21354117],"length":1,"stats":{"Line":2}},{"line":365,"address":[13792240,13792249],"length":1,"stats":{"Line":2}},{"line":370,"address":[13689850],"length":1,"stats":{"Line":1}},{"line":371,"address":[13577222,13577290],"length":1,"stats":{"Line":2}},{"line":372,"address":[13690112],"length":1,"stats":{"Line":1}},{"line":378,"address":[13654841,13659829,13659202,13659268],"length":1,"stats":{"Line":3}},{"line":382,"address":[13594387,13594576,13592960],"length":1,"stats":{"Line":0}},{"line":383,"address":[13692926],"length":1,"stats":{"Line":0}},{"line":384,"address":[13586014],"length":1,"stats":{"Line":0}},{"line":385,"address":[13697544],"length":1,"stats":{"Line":0}},{"line":386,"address":[13653965,13653886],"length":1,"stats":{"Line":0}},{"line":387,"address":[13692167,13692101],"length":1,"stats":{"Line":0}},{"line":388,"address":[13661319,13661007,13661076],"length":1,"stats":{"Line":0}},{"line":389,"address":[13593511,13594610,13594592],"length":1,"stats":{"Line":0}},{"line":390,"address":[13661243],"length":1,"stats":{"Line":0}},{"line":391,"address":[21354919,21354853],"length":1,"stats":{"Line":0}},{"line":392,"address":[13593727],"length":1,"stats":{"Line":0}},{"line":393,"address":[13586798],"length":1,"stats":{"Line":0}},{"line":394,"address":[13655585,13654678,13655584],"length":1,"stats":{"Line":0}},{"line":395,"address":[21355143],"length":1,"stats":{"Line":0}},{"line":399,"address":[13663848,13663933,13662528],"length":1,"stats":{"Line":1}},{"line":400,"address":[21357009],"length":1,"stats":{"Line":1}},{"line":401,"address":[13794118],"length":1,"stats":{"Line":1}},{"line":402,"address":[19372265],"length":1,"stats":{"Line":1}},{"line":403,"address":[13794175,13794260],"length":1,"stats":{"Line":2}},{"line":404,"address":[13588066,13588234,13587996],"length":1,"stats":{"Line":2}},{"line":405,"address":[13795584,13795598,13794474],"length":1,"stats":{"Line":0}},{"line":406,"address":[13663218,13662896,13663051],"length":1,"stats":{"Line":2}},{"line":407,"address":[13589392,13589406,13588434],"length":1,"stats":{"Line":0}},{"line":408,"address":[13699913],"length":1,"stats":{"Line":1}},{"line":409,"address":[19372940],"length":1,"stats":{"Line":1}},{"line":410,"address":[19372965,19373856,19373857],"length":1,"stats":{"Line":1}},{"line":411,"address":[19373043],"length":1,"stats":{"Line":1}},{"line":412,"address":[13698551,13698626],"length":1,"stats":{"Line":2}},{"line":416,"address":[13700343,13699360,13700314],"length":1,"stats":{"Line":1}},{"line":417,"address":[13589526,13589794],"length":1,"stats":{"Line":1}},{"line":420,"address":[13697359,13696416],"length":1,"stats":{"Line":1}},{"line":421,"address":[13658343,13658982],"length":1,"stats":{"Line":2}},{"line":422,"address":[13702055],"length":1,"stats":{"Line":1}},{"line":423,"address":[19375856,19375220,19375036,19374952],"length":1,"stats":{"Line":2}},{"line":424,"address":[13701422],"length":1,"stats":{"Line":0}},{"line":426,"address":[13696717,13697568,13697569],"length":1,"stats":{"Line":3}},{"line":427,"address":[13702505],"length":1,"stats":{"Line":1}},{"line":428,"address":[19375323],"length":1,"stats":{"Line":1}},{"line":429,"address":[13702547],"length":1,"stats":{"Line":1}},{"line":430,"address":[13696980],"length":1,"stats":{"Line":1}},{"line":431,"address":[13701022],"length":1,"stats":{"Line":1}},{"line":436,"address":[21358423],"length":1,"stats":{"Line":1}},{"line":437,"address":[21357933,21358063,21358237,21358638],"length":1,"stats":{"Line":2}},{"line":440,"address":[13701534,13701520,13699853],"length":1,"stats":{"Line":0}},{"line":441,"address":[13583183,13583300,13583608,13583647],"length":1,"stats":{"Line":2}},{"line":444,"address":[13697694,13696264,13697680],"length":1,"stats":{"Line":0}},{"line":445,"address":[21358376],"length":1,"stats":{"Line":1}},{"line":449,"address":[21360048],"length":1,"stats":{"Line":0}},{"line":451,"address":[13659714,13659773],"length":1,"stats":{"Line":0}},{"line":452,"address":[13598913,13598997],"length":1,"stats":{"Line":0}},{"line":453,"address":[19376381,19376297],"length":1,"stats":{"Line":0}},{"line":454,"address":[13666785,13666866],"length":1,"stats":{"Line":0}},{"line":455,"address":[19376406,19376476],"length":1,"stats":{"Line":0}},{"line":456,"address":[21360352],"length":1,"stats":{"Line":0}}],"covered":97,"coverable":224},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","p2p_handler.rs"],"content":"use crate::application::services::p2p_service::P2PServiceTrait;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::p2p::{\n    BroadcastRequest, GossipMetricsSummaryResponse, JoinTopicRequest, LeaveTopicRequest,\n    NodeAddressResponse, P2PStatusResponse, TopicStatus,\n};\nuse crate::shared::{AppError, config::BootstrapSource};\nuse std::sync::Arc;\n\npub struct P2PHandler {\n    p2p_service: Arc<dyn P2PServiceTrait>,\n}\n\nimpl P2PHandler {\n    pub fn new(p2p_service: Arc<dyn P2PServiceTrait>) -> Self {\n        Self { p2p_service }\n    }\n\n    /// P2Pネットワークを初期化\n    pub async fn initialize_p2p(&self) -> Result<(), AppError> {\n        self.p2p_service.initialize().await\n    }\n\n    /// P2Pトピックに参加\n    pub async fn join_topic(&self, request: JoinTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .join_topic(&request.topic_id, request.initial_peers)\n            .await\n    }\n\n    /// P2Pトピックから離脱\n    pub async fn leave_topic(&self, request: LeaveTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service.leave_topic(&request.topic_id).await\n    }\n\n    /// トピックにメッセージをブロードキャスト\n    pub async fn broadcast_to_topic(&self, request: BroadcastRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .broadcast_message(&request.topic_id, &request.content)\n            .await\n    }\n\n    /// P2Pステータスを取得\n    pub async fn get_p2p_status(&self) -> Result<P2PStatusResponse, AppError> {\n        let status = self.p2p_service.get_status().await?;\n        let crate::application::services::p2p_service::P2PStatus {\n            connected,\n            connection_status,\n            endpoint_id,\n            active_topics,\n            peer_count,\n            peers,\n            metrics_summary,\n        } = status;\n\n        // サービスから取得したステータスをDTOに変換\n        let topic_statuses: Vec<TopicStatus> = active_topics\n            .into_iter()\n            .map(|topic| TopicStatus {\n                topic_id: topic.id,\n                peer_count: topic.peer_count,\n                message_count: topic.message_count,\n                last_activity: topic.last_activity,\n            })\n            .collect();\n\n        Ok(P2PStatusResponse {\n            connected,\n            connection_status: connection_status.into(),\n            endpoint_id,\n            active_topics: topic_statuses,\n            peer_count,\n            peers: peers.into_iter().map(Into::into).collect(),\n            metrics_summary: GossipMetricsSummaryResponse {\n                joins: metrics_summary.joins,\n                leaves: metrics_summary.leaves,\n                broadcasts_sent: metrics_summary.broadcasts_sent,\n                messages_received: metrics_summary.messages_received,\n            },\n        })\n    }\n\n    /// ノードアドレスを取得\n    pub async fn get_node_address(&self) -> Result<NodeAddressResponse, AppError> {\n        let addresses = self.p2p_service.get_node_addresses().await?;\n\n        Ok(NodeAddressResponse { addresses })\n    }\n\n    pub async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        self.p2p_service.apply_bootstrap_nodes(nodes, source).await\n    }\n}\n","traces":[{"line":15,"address":[20834000],"length":1,"stats":{"Line":0}},{"line":20,"address":[20795920,20795971,20796246,20796058,20795928,20796511,20795936,20796095],"length":1,"stats":{"Line":0}},{"line":21,"address":[20796085,20796278,20796149,20796037],"length":1,"stats":{"Line":0}},{"line":25,"address":[24812224,24812259,24812342,24813419,24812995,24812304,24813102,24812508],"length":1,"stats":{"Line":0}},{"line":26,"address":[20736160,20735953,20736072],"length":1,"stats":{"Line":0}},{"line":28,"address":[20796971,20797567,20797174,20797241],"length":1,"stats":{"Line":0}},{"line":29,"address":[20729273],"length":1,"stats":{"Line":0}},{"line":30,"address":[20736831,20736011,20736425,20736378,20736630],"length":1,"stats":{"Line":0}},{"line":34,"address":[20841568,20841744,20842187,20842597,20841520,20841528,20842282,20841606],"length":1,"stats":{"Line":0}},{"line":35,"address":[20723425,20723632,20723544],"length":1,"stats":{"Line":0}},{"line":37,"address":[20842009,20842314,20841899,20841771],"length":1,"stats":{"Line":0}},{"line":41,"address":[20731891,20731184,20731231,20731139,20731383,20731104,20732313,20731992],"length":1,"stats":{"Line":0}},{"line":42,"address":[20837272,20837485,20837394],"length":1,"stats":{"Line":0}},{"line":44,"address":[20738520,20738797,20738738,20739105],"length":1,"stats":{"Line":0}},{"line":45,"address":[20806390],"length":1,"stats":{"Line":0}},{"line":46,"address":[11634641],"length":1,"stats":{"Line":0}},{"line":50,"address":[24815728,24815720,24815958,24815712,24816101,24815763,24815894,24817922],"length":1,"stats":{"Line":0}},{"line":51,"address":[20808406,20807237,20807376,20807285,20807505],"length":1,"stats":{"Line":0}},{"line":53,"address":[20844920],"length":1,"stats":{"Line":0}},{"line":54,"address":[20740412],"length":1,"stats":{"Line":0}},{"line":55,"address":[20843310],"length":1,"stats":{"Line":0}},{"line":56,"address":[20843355],"length":1,"stats":{"Line":0}},{"line":57,"address":[20740515],"length":1,"stats":{"Line":0}},{"line":58,"address":[20801368],"length":1,"stats":{"Line":0}},{"line":59,"address":[20845112],"length":1,"stats":{"Line":0}},{"line":63,"address":[24817004,24817160],"length":1,"stats":{"Line":0}},{"line":65,"address":[20734864,20734913],"length":1,"stats":{"Line":0}},{"line":66,"address":[20728091],"length":1,"stats":{"Line":0}},{"line":67,"address":[20840821],"length":1,"stats":{"Line":0}},{"line":68,"address":[20741881],"length":1,"stats":{"Line":0}},{"line":69,"address":[14982429],"length":1,"stats":{"Line":0}},{"line":73,"address":[20734258],"length":1,"stats":{"Line":0}},{"line":75,"address":[20843726],"length":1,"stats":{"Line":0}},{"line":76,"address":[20940224],"length":1,"stats":{"Line":0}},{"line":77,"address":[24817304],"length":1,"stats":{"Line":0}},{"line":79,"address":[20801824,20801935],"length":1,"stats":{"Line":0}},{"line":80,"address":[20844082],"length":1,"stats":{"Line":0}},{"line":81,"address":[20802002],"length":1,"stats":{"Line":0}},{"line":82,"address":[20808938],"length":1,"stats":{"Line":0}},{"line":83,"address":[20940498],"length":1,"stats":{"Line":0}},{"line":84,"address":[20940506],"length":1,"stats":{"Line":0}},{"line":90,"address":[24818427,24819098,24818569,24818272,24818307,24818256,24818390,24818264],"length":1,"stats":{"Line":0}},{"line":91,"address":[20841237,20841631,20841752,20840997,20841109,20841045],"length":1,"stats":{"Line":0}},{"line":93,"address":[20841525],"length":1,"stats":{"Line":0}},{"line":96,"address":[20735856],"length":1,"stats":{"Line":0}},{"line":101,"address":[20804171,20803993,20803924,20803876],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","post_handler.rs"],"content":"use crate::{\n    application::services::{AuthService, PostService, TopicService},\n    domain::entities::Post,\n    presentation::dto::{\n        Validate,\n        post_dto::{\n            BookmarkPostRequest, CreatePostRequest, DeletePostRequest, FollowingFeedPageResponse,\n            GetPostsRequest, ListFollowingFeedRequest, ListTrendingPostsRequest,\n            ListTrendingPostsResponse, PostResponse, ReactToPostRequest,\n            TrendingTopicPostsResponse,\n        },\n    },\n    shared::error::AppError,\n};\nuse chrono::Utc;\nuse futures::future::join_all;\nuse std::sync::Arc;\n\npub struct PostHandler {\n    post_service: Arc<PostService>,\n    auth_service: Arc<AuthService>,\n    topic_service: Arc<TopicService>,\n}\n\nimpl PostHandler {\n    async fn map_post(post: Post) -> PostResponse {\n        let author_pubkey = post.author.pubkey.clone();\n        let npub = tokio::task::spawn_blocking({\n            let pubkey = author_pubkey.clone();\n            move || {\n                use nostr_sdk::prelude::*;\n                PublicKey::from_hex(&pubkey)\n                    .ok()\n                    .and_then(|pk| pk.to_bech32().ok())\n                    .unwrap_or(pubkey)\n            }\n        })\n        .await\n        .unwrap_or(author_pubkey.clone());\n\n        PostResponse {\n            id: post.id.to_string(),\n            content: post.content,\n            author_pubkey: author_pubkey.clone(),\n            author_npub: npub,\n            topic_id: post.topic_id,\n            scope: post.scope,\n            epoch: post.epoch,\n            is_encrypted: post.is_encrypted,\n            created_at: post.created_at.timestamp(),\n            likes: post.likes,\n            boosts: post.boosts,\n            replies: post.replies.len() as u32,\n            is_synced: post.is_synced,\n        }\n    }\n\n    async fn map_posts(posts: Vec<Post>) -> Vec<PostResponse> {\n        let futures = posts.into_iter().map(Self::map_post);\n        join_all(futures).await\n    }\n\n    pub fn new(\n        post_service: Arc<PostService>,\n        auth_service: Arc<AuthService>,\n        topic_service: Arc<TopicService>,\n    ) -> Self {\n        Self {\n            post_service,\n            auth_service,\n            topic_service,\n        }\n    }\n\n    pub async fn create_post(&self, request: CreatePostRequest) -> Result<PostResponse, AppError> {\n        // 入力検証\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        // 現在のユーザーを取得\n        let current_user =\n            self.auth_service.get_current_user().await?.ok_or_else(|| {\n                AppError::Unauthorized(\"ユーザーが認証されていません\".to_string())\n            })?;\n\n        // サービス層を呼び出し\n        let post = self\n            .post_service\n            .create_post(\n                request.content,\n                current_user,\n                request.topic_id,\n                request.scope,\n            )\n            .await?;\n\n        // DTOに変換\n        Ok(Self::map_post(post).await)\n    }\n\n    pub async fn get_posts(&self, request: GetPostsRequest) -> Result<Vec<PostResponse>, AppError> {\n        let pagination = request.pagination.unwrap_or_default();\n\n        let posts = if let Some(topic_id) = request.topic_id {\n            self.post_service\n                .get_posts_by_topic(&topic_id, pagination.limit.unwrap_or(50) as usize)\n                .await?\n        } else if let Some(author) = request.author_pubkey {\n            self.post_service\n                .get_posts_by_author(&author, pagination.limit.unwrap_or(50) as usize)\n                .await?\n        } else {\n            self.post_service\n                .get_recent_posts(pagination.limit.unwrap_or(50) as usize)\n                .await?\n        };\n\n        let results = Self::map_posts(posts).await;\n        Ok(results)\n    }\n\n    pub async fn delete_post(&self, request: DeletePostRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service.delete_post(&request.post_id).await?;\n        Ok(())\n    }\n\n    pub async fn react_to_post(&self, request: ReactToPostRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .react_to_post(&request.post_id, &request.reaction)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn bookmark_post(\n        &self,\n        request: BookmarkPostRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .bookmark_post(&request.post_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn unbookmark_post(\n        &self,\n        request: BookmarkPostRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .unbookmark_post(&request.post_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    /// ユーザーのブックマーク済み投稿IDを取得\n    pub async fn get_bookmarked_post_ids(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let post_ids = self\n            .post_service\n            .get_bookmarked_post_ids(user_pubkey)\n            .await?;\n        Ok(post_ids)\n    }\n\n    pub async fn list_trending_posts(\n        &self,\n        request: ListTrendingPostsRequest,\n    ) -> Result<ListTrendingPostsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let per_topic = request.per_topic.unwrap_or(3).clamp(1, 20) as usize;\n        let mut topics = Vec::new();\n\n        for (index, topic_id) in request.topic_ids.iter().enumerate() {\n            if let Some(topic) = self.topic_service.get_topic(topic_id).await? {\n                let posts = self\n                    .post_service\n                    .get_posts_by_topic(topic_id, per_topic)\n                    .await?;\n                let responses = Self::map_posts(posts).await;\n                topics.push(TrendingTopicPostsResponse {\n                    topic_id: topic.id.clone(),\n                    topic_name: topic.name.clone(),\n                    relative_rank: (index + 1) as u32,\n                    posts: responses,\n                });\n            }\n        }\n\n        let generated_at = self\n            .topic_service\n            .latest_metrics_generated_at()\n            .await?\n            .unwrap_or_else(|| Utc::now().timestamp_millis());\n\n        Ok(ListTrendingPostsResponse {\n            generated_at,\n            topics,\n        })\n    }\n\n    pub async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        request: ListFollowingFeedRequest,\n    ) -> Result<FollowingFeedPageResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let limit = request.limit.unwrap_or(20).clamp(1, 100) as usize;\n        let _include_reactions = request.include_reactions.unwrap_or(false);\n        let feed = self\n            .post_service\n            .list_following_feed(follower_pubkey, request.cursor.as_deref(), limit)\n            .await?;\n        let items = Self::map_posts(feed.items).await;\n\n        Ok(FollowingFeedPageResponse {\n            items,\n            next_cursor: feed.next_cursor,\n            has_more: feed.has_more,\n            server_time: feed.server_time,\n        })\n    }\n}\n","traces":[{"line":26,"address":[16940849,16940931,16940832,16941134,16943094,16940896,16943225,16941451],"length":1,"stats":{"Line":0}},{"line":27,"address":[16842157],"length":1,"stats":{"Line":0}},{"line":28,"address":[16903713,16903477,16903208,16903265],"length":1,"stats":{"Line":0}},{"line":29,"address":[26617750],"length":1,"stats":{"Line":0}},{"line":30,"address":[16947783,16947536,16945224,16947811],"length":1,"stats":{"Line":0}},{"line":32,"address":[17044178,17044080,17043996],"length":1,"stats":{"Line":0}},{"line":34,"address":[16949472,16949486],"length":1,"stats":{"Line":0}},{"line":35,"address":[17044147],"length":1,"stats":{"Line":0}},{"line":38,"address":[16903277,16903549,16903049,16903371,16903244],"length":1,"stats":{"Line":0}},{"line":39,"address":[17042089,17042233,17041621,17043703],"length":1,"stats":{"Line":0}},{"line":42,"address":[11083481],"length":1,"stats":{"Line":0}},{"line":43,"address":[16829249],"length":1,"stats":{"Line":0}},{"line":44,"address":[16903888],"length":1,"stats":{"Line":0}},{"line":46,"address":[16910928],"length":1,"stats":{"Line":0}},{"line":47,"address":[16947743],"length":1,"stats":{"Line":0}},{"line":48,"address":[11083806],"length":1,"stats":{"Line":0}},{"line":49,"address":[17042603],"length":1,"stats":{"Line":0}},{"line":50,"address":[16942245],"length":1,"stats":{"Line":0}},{"line":51,"address":[26618812],"length":1,"stats":{"Line":0}},{"line":52,"address":[16836407],"length":1,"stats":{"Line":0}},{"line":53,"address":[16843393],"length":1,"stats":{"Line":0}},{"line":54,"address":[16904283],"length":1,"stats":{"Line":0}},{"line":58,"address":[11085552,11085619,11086216,11085712,11085584,11085752,11085919,11085555],"length":1,"stats":{"Line":0}},{"line":59,"address":[16906084,16905979],"length":1,"stats":{"Line":0}},{"line":60,"address":[26620686,26620795,26620599],"length":1,"stats":{"Line":0}},{"line":63,"address":[16838720],"length":1,"stats":{"Line":0}},{"line":75,"address":[11086429,11087253,11088411,11086307,11086352,11086272,11089463,11086739],"length":1,"stats":{"Line":0}},{"line":77,"address":[16949561,16949041,16949319,16949208],"length":1,"stats":{"Line":0}},{"line":80,"address":[11505724],"length":1,"stats":{"Line":0}},{"line":82,"address":[26624878],"length":1,"stats":{"Line":0}},{"line":86,"address":[11088253,11088557,11088323,11088898,11088631,11087858],"length":1,"stats":{"Line":0}},{"line":89,"address":[16915253],"length":1,"stats":{"Line":0}},{"line":90,"address":[16946487],"length":1,"stats":{"Line":0}},{"line":91,"address":[16847603],"length":1,"stats":{"Line":0}},{"line":92,"address":[16946600],"length":1,"stats":{"Line":0}},{"line":94,"address":[10860698],"length":1,"stats":{"Line":0}},{"line":97,"address":[11505771],"length":1,"stats":{"Line":0}},{"line":100,"address":[16835968,16838145,16836375,16836125,16836003,16836048,16837529,16839390],"length":1,"stats":{"Line":0}},{"line":101,"address":[16952965],"length":1,"stats":{"Line":0}},{"line":103,"address":[16843335],"length":1,"stats":{"Line":0}},{"line":104,"address":[16949347,16950373,16950679,16949590,16949636,16950489],"length":1,"stats":{"Line":0}},{"line":105,"address":[16955049],"length":1,"stats":{"Line":0}},{"line":106,"address":[16955193,16954693,16956005,16956215,16955849,16955253],"length":1,"stats":{"Line":0}},{"line":107,"address":[11460895],"length":1,"stats":{"Line":0}},{"line":108,"address":[16949756,16949960,16950006,16950966,16951082,16951275],"length":1,"stats":{"Line":0}},{"line":109,"address":[11091450],"length":1,"stats":{"Line":0}},{"line":110,"address":[16912902,16911927,16911018,16912746,16911867,16913115],"length":1,"stats":{"Line":0}},{"line":112,"address":[16949780,16950120,16950166,16951446,16951562,16951763,16951891],"length":1,"stats":{"Line":0}},{"line":113,"address":[16950073],"length":1,"stats":{"Line":0}},{"line":114,"address":[16913382,16912027,16912087,16911039,16913226,16913603],"length":1,"stats":{"Line":0}},{"line":117,"address":[11528647],"length":1,"stats":{"Line":0}},{"line":118,"address":[16853573],"length":1,"stats":{"Line":0}},{"line":121,"address":[16848269,16848169,16847219,16847769,16847104,16847184,16847139,16847350],"length":1,"stats":{"Line":0}},{"line":122,"address":[16840960,16840538,16840745,16840651],"length":1,"stats":{"Line":0}},{"line":124,"address":[26629838,26629453,26629658,26630101,26630274,26629577],"length":1,"stats":{"Line":0}},{"line":125,"address":[16957912],"length":1,"stats":{"Line":0}},{"line":128,"address":[16855991,16855510,16855379,16856491,16856391,16855264,16855344,16855299],"length":1,"stats":{"Line":0}},{"line":129,"address":[16916798,16916314,16916427,16916521],"length":1,"stats":{"Line":0}},{"line":131,"address":[16842466,16842108,16842726,16842365,16842597,16842154,16841913],"length":1,"stats":{"Line":0}},{"line":132,"address":[16855771],"length":1,"stats":{"Line":0}},{"line":133,"address":[16960701,16960469,16960837,16960065,16960551,16960415],"length":1,"stats":{"Line":0}},{"line":134,"address":[16924038],"length":1,"stats":{"Line":0}},{"line":137,"address":[26631472],"length":1,"stats":{"Line":0}},{"line":142,"address":[17056057,17056264,17056170,17056492],"length":1,"stats":{"Line":0}},{"line":144,"address":[16961968,16961867,16961656,16962099,16961464,16962228,16961610],"length":1,"stats":{"Line":0}},{"line":145,"address":[16959911],"length":1,"stats":{"Line":0}},{"line":146,"address":[16843395,16843341,16843627,16843040,16843477,16843763],"length":1,"stats":{"Line":0}},{"line":147,"address":[17056804],"length":1,"stats":{"Line":0}},{"line":150,"address":[16962256],"length":1,"stats":{"Line":0}},{"line":155,"address":[11098505,11098712,11098618,11098940],"length":1,"stats":{"Line":0}},{"line":157,"address":[16963315,16962826,16962872,16963083,16963184,16962680,16963444],"length":1,"stats":{"Line":0}},{"line":158,"address":[16858247],"length":1,"stats":{"Line":0}},{"line":159,"address":[16960896,16961483,16961197,16961619,16961251,16961333],"length":1,"stats":{"Line":0}},{"line":160,"address":[16926468],"length":1,"stats":{"Line":0}},{"line":164,"address":[16961824],"length":1,"stats":{"Line":0}},{"line":168,"address":[16958414,16958512,16958188,16958231,16958694,16958773,16958076],"length":1,"stats":{"Line":0}},{"line":171,"address":[26633971,26634294,26634099,26634479,26634068,26634152],"length":1,"stats":{"Line":0}},{"line":172,"address":[11100197],"length":1,"stats":{"Line":0}},{"line":175,"address":[16859840],"length":1,"stats":{"Line":0}},{"line":179,"address":[16920925,16921229,16921113,16921671],"length":1,"stats":{"Line":0}},{"line":181,"address":[16965017,16964888],"length":1,"stats":{"Line":0}},{"line":182,"address":[16846778],"length":1,"stats":{"Line":0}},{"line":184,"address":[16853688,16854913,16853585,16854836],"length":1,"stats":{"Line":0}},{"line":185,"address":[11613564],"length":1,"stats":{"Line":0}},{"line":186,"address":[16961960,16961732,16962106,16962222,16962479,16961914],"length":1,"stats":{"Line":0}},{"line":188,"address":[16855935],"length":1,"stats":{"Line":0}},{"line":189,"address":[11538994],"length":1,"stats":{"Line":0}},{"line":190,"address":[16927959,16931173,16931329,16928727],"length":1,"stats":{"Line":0}},{"line":191,"address":[16929072,16929314],"length":1,"stats":{"Line":0}},{"line":192,"address":[16922164],"length":1,"stats":{"Line":0}},{"line":193,"address":[16929156],"length":1,"stats":{"Line":0}},{"line":194,"address":[26636183,26636391],"length":1,"stats":{"Line":0}},{"line":195,"address":[16922346],"length":1,"stats":{"Line":0}},{"line":200,"address":[16857159,16857451,16854881,16855045,16854999,16856888,16857004],"length":1,"stats":{"Line":0}},{"line":203,"address":[11552804],"length":1,"stats":{"Line":0}},{"line":204,"address":[17063744,17063748],"length":1,"stats":{"Line":0}},{"line":206,"address":[16963161],"length":1,"stats":{"Line":0}},{"line":208,"address":[16864185],"length":1,"stats":{"Line":0}},{"line":212,"address":[17063776],"length":1,"stats":{"Line":0}},{"line":217,"address":[16963720,16963857,16963970,16964377],"length":1,"stats":{"Line":0}},{"line":219,"address":[11105536,11105659],"length":1,"stats":{"Line":0}},{"line":220,"address":[16865159],"length":1,"stats":{"Line":0}},{"line":221,"address":[11106620,11105749,11105867,11105919,11106152,11106282],"length":1,"stats":{"Line":0}},{"line":223,"address":[16969788],"length":1,"stats":{"Line":0}},{"line":224,"address":[16865672,16866028,16865348,16864834,16865405,16865493],"length":1,"stats":{"Line":0}},{"line":225,"address":[11538656],"length":1,"stats":{"Line":0}},{"line":227,"address":[16969519],"length":1,"stats":{"Line":0}},{"line":229,"address":[16971108],"length":1,"stats":{"Line":0}},{"line":230,"address":[16866618],"length":1,"stats":{"Line":0}},{"line":231,"address":[17065944],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":110},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","secure_storage_handler.rs"],"content":"use crate::{\n    application::ports::secure_storage::SecureAccountStore,\n    application::services::AuthService,\n    domain::entities::{AccountMetadata, AccountRegistration},\n    presentation::dto::{Validate, auth_dto::LoginResponse},\n    shared::error::AppError,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountRequest {\n    pub nsec: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl Validate for AddAccountRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.is_empty() {\n            return Err(\"nsec is required\".into());\n        }\n        if self.name.is_empty() {\n            return Err(\"name is required\".into());\n        }\n        if self.display_name.is_empty() {\n            return Err(\"display_name is required\".into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SwitchAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetCurrentAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub metadata: AccountMetadata,\n}\n\npub struct SecureStorageHandler {\n    auth_service: Arc<AuthService>,\n    secure_store: Arc<dyn SecureAccountStore>,\n}\n\nimpl SecureStorageHandler {\n    pub fn new(auth_service: Arc<AuthService>, secure_store: Arc<dyn SecureAccountStore>) -> Self {\n        Self {\n            auth_service,\n            secure_store,\n        }\n    }\n\n    pub async fn add_account(\n        &self,\n        request: AddAccountRequest,\n    ) -> Result<AddAccountResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n        let AddAccountRequest {\n            nsec,\n            name,\n            display_name,\n            picture,\n        } = request;\n\n        // nsecから公開鍵とnpubを生成\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        // セキュアストレージに保存\n        let registration = AccountRegistration {\n            npub: user.npub.clone(),\n            nsec,\n            pubkey: user.pubkey.clone(),\n            name,\n            display_name,\n            picture,\n        };\n        self.secure_store.add_account(registration).await?;\n\n        Ok(AddAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        self.secure_store.list_accounts().await\n    }\n\n    pub async fn switch_account(&self, npub: String) -> Result<SwitchAccountResponse, AppError> {\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // 秘密鍵を取得してログイン\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(SwitchAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn remove_account(&self, npub: String) -> Result<(), AppError> {\n        self.secure_store.remove_account(&npub).await\n    }\n\n    pub async fn get_current_account(&self) -> Result<Option<GetCurrentAccountResponse>, AppError> {\n        if let Some(current) = self.secure_store.current_account().await? {\n            let user = self.auth_service.login_with_nsec(&current.nsec).await?;\n\n            Ok(Some(GetCurrentAccountResponse {\n                npub: user.npub,\n                nsec: current.nsec,\n                pubkey: user.pubkey,\n                metadata: current.metadata,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn secure_login(&self, npub: String) -> Result<LoginResponse, AppError> {\n        // セキュアストレージから秘密鍵を取得\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // ログイン処理\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(LoginResponse {\n            success: true,\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n}\n","traces":[{"line":20,"address":[20846544],"length":1,"stats":{"Line":0}},{"line":21,"address":[14984238],"length":1,"stats":{"Line":0}},{"line":22,"address":[20846602],"length":1,"stats":{"Line":0}},{"line":24,"address":[20846587],"length":1,"stats":{"Line":0}},{"line":25,"address":[20811567],"length":1,"stats":{"Line":0}},{"line":27,"address":[20811552],"length":1,"stats":{"Line":0}},{"line":28,"address":[20736914],"length":1,"stats":{"Line":0}},{"line":30,"address":[17158547],"length":1,"stats":{"Line":0}},{"line":60,"address":[20943280],"length":1,"stats":{"Line":0}},{"line":67,"address":[20811760],"length":1,"stats":{"Line":0}},{"line":71,"address":[20812384,20813067,20812762,20812241],"length":1,"stats":{"Line":0}},{"line":73,"address":[20805539],"length":1,"stats":{"Line":0}},{"line":74,"address":[20847650],"length":1,"stats":{"Line":0}},{"line":75,"address":[20944148],"length":1,"stats":{"Line":0}},{"line":76,"address":[20843846],"length":1,"stats":{"Line":0}},{"line":80,"address":[20843912,20843486,20844311,20844713,20845654,20844079],"length":1,"stats":{"Line":0}},{"line":84,"address":[17160356],"length":1,"stats":{"Line":0}},{"line":86,"address":[20732213],"length":1,"stats":{"Line":0}},{"line":91,"address":[20807249,20805395,20807334,20807570],"length":1,"stats":{"Line":0}},{"line":93,"address":[20740300],"length":1,"stats":{"Line":0}},{"line":94,"address":[17161780],"length":1,"stats":{"Line":0}},{"line":95,"address":[20814998],"length":1,"stats":{"Line":0}},{"line":99,"address":[20810158,20810195,20810611,20810032,20810067,20810024,20810346,20810016],"length":1,"stats":{"Line":0}},{"line":100,"address":[20749353,20749546,20749301,20749417],"length":1,"stats":{"Line":0}},{"line":103,"address":[20848831,20848978,20850103,20851831,20849340,20848784,20848744,20848736],"length":1,"stats":{"Line":0}},{"line":105,"address":[11715404,11715496],"length":1,"stats":{"Line":0}},{"line":108,"address":[14992561,14991454,14991817,14992096,14992328,14991937,14991572,14991631],"length":1,"stats":{"Line":0}},{"line":110,"address":[20818739],"length":1,"stats":{"Line":0}},{"line":111,"address":[20812336,20811935,20812153,20811888,20812000,20810917],"length":1,"stats":{"Line":0}},{"line":112,"address":[11715577],"length":1,"stats":{"Line":0}},{"line":114,"address":[17166491,17167017,17164662,17166189,17166345],"length":1,"stats":{"Line":0}},{"line":116,"address":[20820202],"length":1,"stats":{"Line":0}},{"line":117,"address":[20951690],"length":1,"stats":{"Line":0}},{"line":118,"address":[20855290],"length":1,"stats":{"Line":0}},{"line":122,"address":[20856048,20856826,20856086,20856467,20856731,20856000,20856008,20856207],"length":1,"stats":{"Line":0}},{"line":123,"address":[11007886],"length":1,"stats":{"Line":0}},{"line":126,"address":[20953359,20953738,20953566,20954684,20953312,20953288,20953280,20953502],"length":1,"stats":{"Line":0}},{"line":127,"address":[11634223],"length":1,"stats":{"Line":0}},{"line":128,"address":[20953553,20955420,20954430,20954693,20954329],"length":1,"stats":{"Line":0}},{"line":130,"address":[20748944],"length":1,"stats":{"Line":0}},{"line":131,"address":[20860267],"length":1,"stats":{"Line":0}},{"line":132,"address":[17170103],"length":1,"stats":{"Line":0}},{"line":133,"address":[20858701],"length":1,"stats":{"Line":0}},{"line":134,"address":[20742093],"length":1,"stats":{"Line":0}},{"line":137,"address":[20748296],"length":1,"stats":{"Line":0}},{"line":141,"address":[17172443,17170920,17171150,17170912,17171007,17173931,17170960,17171504],"length":1,"stats":{"Line":0}},{"line":143,"address":[20856093,20856400,20856280,20855732,20857121,20857093,20856010,20856806,20856559],"length":1,"stats":{"Line":0}},{"line":145,"address":[20859879],"length":1,"stats":{"Line":0}},{"line":146,"address":[11709100],"length":1,"stats":{"Line":0}},{"line":147,"address":[11705256],"length":1,"stats":{"Line":0}},{"line":150,"address":[11674000,11674153],"length":1,"stats":{"Line":0}},{"line":153,"address":[11592503],"length":1,"stats":{"Line":0}},{"line":155,"address":[20862142],"length":1,"stats":{"Line":0}},{"line":157,"address":[20858142],"length":1,"stats":{"Line":0}},{"line":158,"address":[20752254],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","topic_handler.rs"],"content":"use crate::{\n    application::services::TopicService,\n    domain::entities::{PendingTopic, TopicVisibility},\n    presentation::dto::{\n        Validate,\n        topic_dto::{\n            CreateTopicRequest, DeleteTopicRequest, EnqueueTopicCreationRequest,\n            EnqueueTopicCreationResponse, GetTopicStatsRequest, JoinTopicRequest,\n            ListTrendingTopicsRequest, ListTrendingTopicsResponse, MarkPendingTopicFailedRequest,\n            MarkPendingTopicSyncedRequest, PendingTopicResponse, TopicResponse, TopicStatsResponse,\n            TrendingTopicDto, UpdateTopicRequest,\n        },\n    },\n    presentation::handlers::offline_handler::map_action_record,\n    shared::error::AppError,\n};\nuse chrono::Utc;\nuse std::sync::Arc;\n\npub struct TopicHandler {\n    topic_service: Arc<TopicService>,\n}\n\nimpl TopicHandler {\n    pub fn new(topic_service: Arc<TopicService>) -> Self {\n        Self { topic_service }\n    }\n\n    pub async fn create_topic(\n        &self,\n        request: CreateTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let visibility = match request.visibility.as_deref() {\n            Some(\"private\") => TopicVisibility::Private,\n            _ => TopicVisibility::Public,\n        };\n        let topic = self\n            .topic_service\n            .create_topic(\n                request.name,\n                Some(request.description),\n                visibility,\n                user_pubkey,\n            )\n            .await?;\n\n        Ok(TopicResponse {\n            id: topic.id.to_string(),\n            name: topic.name,\n            description: topic.description.unwrap_or_default(),\n            image_url: topic.image_url,\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            visibility: topic.visibility.as_str().to_string(),\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn enqueue_topic_creation(\n        &self,\n        request: EnqueueTopicCreationRequest,\n        user_pubkey: &str,\n    ) -> Result<EnqueueTopicCreationResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let visibility = match request.visibility.as_deref() {\n            Some(\"private\") => TopicVisibility::Private,\n            _ => TopicVisibility::Public,\n        };\n        let result = self\n            .topic_service\n            .enqueue_topic_creation(user_pubkey, request.name, request.description, visibility)\n            .await?;\n\n        Ok(EnqueueTopicCreationResponse {\n            pending_topic: map_pending_topic(result.pending_topic),\n            offline_action: map_action_record(&result.offline_action)?,\n        })\n    }\n\n    pub async fn list_pending_topics(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<PendingTopicResponse>, AppError> {\n        let topics = self.topic_service.list_pending_topics(user_pubkey).await?;\n        Ok(topics.into_iter().map(map_pending_topic).collect())\n    }\n\n    pub async fn mark_pending_topic_synced(\n        &self,\n        request: MarkPendingTopicSyncedRequest,\n        user_pubkey: &str,\n    ) -> Result<PendingTopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let pending = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        if pending.user_pubkey != user_pubkey {\n            return Err(AppError::Unauthorized(\n                \"You cannot modify this pending topic\".to_string(),\n            ));\n        }\n\n        self.topic_service\n            .mark_pending_topic_synced(&request.pending_id, &request.topic_id)\n            .await?;\n\n        let updated = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        Ok(map_pending_topic(updated))\n    }\n\n    pub async fn mark_pending_topic_failed(\n        &self,\n        request: MarkPendingTopicFailedRequest,\n        user_pubkey: &str,\n    ) -> Result<PendingTopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let pending = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        if pending.user_pubkey != user_pubkey {\n            return Err(AppError::Unauthorized(\n                \"You cannot modify this pending topic\".to_string(),\n            ));\n        }\n\n        self.topic_service\n            .mark_pending_topic_failed(&request.pending_id, request.error_message.clone())\n            .await?;\n\n        let updated = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        Ok(map_pending_topic(updated))\n    }\n\n    pub async fn update_topic(\n        &self,\n        request: UpdateTopicRequest,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let mut topic = self\n            .topic_service\n            .get_topic(&request.id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Topic not found\".to_string()))?;\n\n        if let Some(name) = request.name {\n            topic.name = name;\n        }\n        if let Some(description) = request.description {\n            topic.description = Some(description);\n        }\n        if let Some(image_url) = request.image_url {\n            topic.image_url = if image_url.is_empty() {\n                None\n            } else {\n                Some(image_url)\n            };\n        }\n        topic.updated_at = Utc::now();\n\n        self.topic_service.update_topic(&topic).await?;\n\n        Ok(TopicResponse {\n            id: topic.id.clone(),\n            name: topic.name.clone(),\n            description: topic.description.clone().unwrap_or_default(),\n            image_url: topic.image_url.clone(),\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            visibility: topic.visibility.as_str().to_string(),\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn delete_topic(&self, request: DeleteTopicRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service.delete_topic(&request.id).await?;\n        Ok(())\n    }\n\n    pub async fn get_all_topics(\n        &self,\n        user_pubkey: Option<&str>,\n    ) -> Result<Vec<TopicResponse>, AppError> {\n        let topics = self\n            .topic_service\n            .list_topics_with_membership(user_pubkey)\n            .await?;\n\n        Ok(topics\n            .into_iter()\n            .map(|t| TopicResponse {\n                id: t.id.to_string(),\n                name: t.name,\n                description: t.description.unwrap_or_default(),\n                image_url: t.image_url,\n                member_count: t.member_count,\n                post_count: t.post_count,\n                is_joined: t.is_joined,\n                visibility: t.visibility.as_str().to_string(),\n                created_at: t.created_at.timestamp(),\n                updated_at: t.updated_at.timestamp(),\n            })\n            .collect())\n    }\n\n    pub async fn join_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .join_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .leave_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn get_topic_stats(\n        &self,\n        request: GetTopicStatsRequest,\n    ) -> Result<TopicStatsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let (member_count, post_count) = self\n            .topic_service\n            .get_topic_stats(&request.topic_id)\n            .await?;\n\n        let active_users_24h = member_count.min(post_count);\n        let trending_score = if member_count == 0 && post_count == 0 {\n            0.0\n        } else {\n            (post_count as f64 * 0.6) + (member_count as f64 * 0.4)\n        };\n\n        Ok(TopicStatsResponse {\n            topic_id: request.topic_id,\n            member_count,\n            post_count,\n            active_users_24h,\n            trending_score,\n        })\n    }\n\n    pub async fn list_trending_topics(\n        &self,\n        request: ListTrendingTopicsRequest,\n    ) -> Result<ListTrendingTopicsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let limit = request.limit.unwrap_or(10).clamp(1, 100) as usize;\n        let result = self.topic_service.list_trending_topics(limit).await?;\n\n        let topics: Vec<TrendingTopicDto> = result\n            .entries\n            .into_iter()\n            .enumerate()\n            .map(|(index, entry)| TrendingTopicDto {\n                topic_id: entry.topic.id.clone(),\n                name: entry.topic.name.clone(),\n                description: entry.topic.description.clone(),\n                member_count: entry.topic.member_count,\n                post_count: entry.topic.post_count,\n                trending_score: entry.trending_score,\n                rank: (index as u32) + 1,\n                score_change: None,\n            })\n            .collect();\n\n        Ok(ListTrendingTopicsResponse {\n            generated_at: result.generated_at,\n            topics,\n        })\n    }\n}\n\nfn map_pending_topic(topic: PendingTopic) -> PendingTopicResponse {\n    PendingTopicResponse {\n        pending_id: topic.pending_id,\n        name: topic.name,\n        description: topic.description,\n        status: topic.status.as_str().to_string(),\n        offline_action_id: topic.offline_action_id,\n        synced_topic_id: topic.synced_topic_id,\n        error_message: topic.error_message,\n        created_at: topic.created_at.timestamp(),\n        updated_at: topic.updated_at.timestamp(),\n    }\n}\n","traces":[{"line":25,"address":[23052528],"length":1,"stats":{"Line":0}},{"line":29,"address":[23045760],"length":1,"stats":{"Line":0}},{"line":34,"address":[23127742,23127979,23127864,23128562],"length":1,"stats":{"Line":0}},{"line":36,"address":[23060183,23060314],"length":1,"stats":{"Line":0}},{"line":37,"address":[17300956,17300903],"length":1,"stats":{"Line":0}},{"line":38,"address":[17300942],"length":1,"stats":{"Line":0}},{"line":40,"address":[23164204,23163314,23163888,23163968,23163537,23163618],"length":1,"stats":{"Line":0}},{"line":43,"address":[23053546],"length":1,"stats":{"Line":0}},{"line":44,"address":[17301116],"length":1,"stats":{"Line":0}},{"line":48,"address":[23047516,23046283,23046951,23047102,23047011,23047250],"length":1,"stats":{"Line":0}},{"line":50,"address":[23261154],"length":1,"stats":{"Line":0}},{"line":51,"address":[23165782],"length":1,"stats":{"Line":0}},{"line":52,"address":[23129165],"length":1,"stats":{"Line":0}},{"line":53,"address":[23129205],"length":1,"stats":{"Line":0}},{"line":54,"address":[23260868],"length":1,"stats":{"Line":0}},{"line":55,"address":[23054620],"length":1,"stats":{"Line":0}},{"line":56,"address":[23054631],"length":1,"stats":{"Line":0}},{"line":57,"address":[23129378],"length":1,"stats":{"Line":0}},{"line":58,"address":[23047952,23047869],"length":1,"stats":{"Line":0}},{"line":59,"address":[23129491],"length":1,"stats":{"Line":0}},{"line":60,"address":[23122628],"length":1,"stats":{"Line":0}},{"line":64,"address":[23049376],"length":1,"stats":{"Line":0}},{"line":69,"address":[23050054,23049817,23050577,23049939],"length":1,"stats":{"Line":0}},{"line":71,"address":[23124610,23124741],"length":1,"stats":{"Line":0}},{"line":72,"address":[23063954,23064007],"length":1,"stats":{"Line":0}},{"line":73,"address":[23168521],"length":1,"stats":{"Line":0}},{"line":75,"address":[23167414,23167736,23167153,23167075,23168517,23167488,23166906],"length":1,"stats":{"Line":0}},{"line":77,"address":[23263410],"length":1,"stats":{"Line":0}},{"line":78,"address":[10946592],"length":1,"stats":{"Line":0}},{"line":80,"address":[14401441],"length":1,"stats":{"Line":0}},{"line":81,"address":[23057772],"length":1,"stats":{"Line":0}},{"line":82,"address":[23164150,23163878,23163946],"length":1,"stats":{"Line":0}},{"line":86,"address":[23164928],"length":1,"stats":{"Line":0}},{"line":90,"address":[14403071,14402484,14402611,14402523,14402721],"length":1,"stats":{"Line":0}},{"line":91,"address":[23052982,23053166],"length":1,"stats":{"Line":0}},{"line":94,"address":[23060160],"length":1,"stats":{"Line":0}},{"line":99,"address":[23166938,23166404,23166681,23166571],"length":1,"stats":{"Line":0}},{"line":101,"address":[23136043,23135641,23136218,23135466,23137033,23136503,23135963,23135687],"length":1,"stats":{"Line":0}},{"line":103,"address":[23172350],"length":1,"stats":{"Line":0}},{"line":104,"address":[11647772],"length":1,"stats":{"Line":0}},{"line":105,"address":[23061719,23063920,23063934],"length":1,"stats":{"Line":0}},{"line":107,"address":[23268150,23267968],"length":1,"stats":{"Line":0}},{"line":108,"address":[23129972],"length":1,"stats":{"Line":0}},{"line":109,"address":[23173403],"length":1,"stats":{"Line":0}},{"line":113,"address":[23055640,23056120,23055313,23055267,23055766,23055084,23055894],"length":1,"stats":{"Line":0}},{"line":114,"address":[23068909],"length":1,"stats":{"Line":0}},{"line":115,"address":[11586962],"length":1,"stats":{"Line":0}},{"line":117,"address":[14405722,14406239,14406384,14406946,14405944,14405914,14406147,14406668,14406961],"length":1,"stats":{"Line":0}},{"line":119,"address":[23130558],"length":1,"stats":{"Line":0}},{"line":120,"address":[23069849,23067566,23069789,23070033,23070232,23069885],"length":1,"stats":{"Line":0}},{"line":121,"address":[11648017,11648050],"length":1,"stats":{"Line":0}},{"line":123,"address":[14406770,14406577],"length":1,"stats":{"Line":0}},{"line":126,"address":[14407168],"length":1,"stats":{"Line":0}},{"line":131,"address":[23271001,23271258,23270891,23270724],"length":1,"stats":{"Line":0}},{"line":133,"address":[23139593,23140455,23140973,23139995,23139639,23140170,23139915,23139418],"length":1,"stats":{"Line":0}},{"line":135,"address":[23064798],"length":1,"stats":{"Line":0}},{"line":136,"address":[11689388],"length":1,"stats":{"Line":0}},{"line":137,"address":[23271959,23274144,23274158],"length":1,"stats":{"Line":0}},{"line":139,"address":[23177136,23177318],"length":1,"stats":{"Line":0}},{"line":140,"address":[23073080],"length":1,"stats":{"Line":0}},{"line":141,"address":[23059067],"length":1,"stats":{"Line":0}},{"line":145,"address":[23177324,23177868,23177487,23178122,23178348,23177541,23177994],"length":1,"stats":{"Line":0}},{"line":146,"address":[23133693],"length":1,"stats":{"Line":0}},{"line":147,"address":[23176025,23177514,23178074,23177916,23177574,23177760],"length":1,"stats":{"Line":0}},{"line":149,"address":[23178238,23178499,23178284,23179338,23179353,23178046,23178748,23178579,23179044],"length":1,"stats":{"Line":0}},{"line":151,"address":[23134498],"length":1,"stats":{"Line":0}},{"line":152,"address":[11572795],"length":1,"stats":{"Line":0}},{"line":153,"address":[23061168,23061182,23060708],"length":1,"stats":{"Line":0}},{"line":155,"address":[17314965,17315166],"length":1,"stats":{"Line":0}},{"line":158,"address":[23061264],"length":1,"stats":{"Line":0}},{"line":162,"address":[23061895,23061645,23062134,23061788],"length":1,"stats":{"Line":0}},{"line":164,"address":[23179060,23178980,23180879,23178507,23179229,23178664,23179482,23178710],"length":1,"stats":{"Line":0}},{"line":166,"address":[23075740],"length":1,"stats":{"Line":0}},{"line":167,"address":[23069126,23068827,23068887,23069325,23068490,23068978],"length":1,"stats":{"Line":0}},{"line":168,"address":[11522010],"length":1,"stats":{"Line":0}},{"line":170,"address":[23137734,23137339,23137471],"length":1,"stats":{"Line":0}},{"line":171,"address":[23276004,23276084],"length":1,"stats":{"Line":0}},{"line":173,"address":[23138066,23137768,23137553],"length":1,"stats":{"Line":0}},{"line":174,"address":[23181517,23181629],"length":1,"stats":{"Line":0}},{"line":176,"address":[23077239,23077693,23077050],"length":1,"stats":{"Line":0}},{"line":177,"address":[23063626,23063548,23063756,23063862,23063736],"length":1,"stats":{"Line":0}},{"line":178,"address":[23145258],"length":1,"stats":{"Line":0}},{"line":180,"address":[23176336],"length":1,"stats":{"Line":0}},{"line":183,"address":[23277117,23276631],"length":1,"stats":{"Line":0}},{"line":185,"address":[11728246],"length":1,"stats":{"Line":0}},{"line":187,"address":[23183461],"length":1,"stats":{"Line":0}},{"line":188,"address":[17318839],"length":1,"stats":{"Line":0}},{"line":189,"address":[23078414],"length":1,"stats":{"Line":0}},{"line":190,"address":[23177511,23177436],"length":1,"stats":{"Line":0}},{"line":191,"address":[23064834],"length":1,"stats":{"Line":0}},{"line":192,"address":[23183197],"length":1,"stats":{"Line":0}},{"line":193,"address":[23071711],"length":1,"stats":{"Line":0}},{"line":194,"address":[17319241],"length":1,"stats":{"Line":0}},{"line":195,"address":[17319251,17319333],"length":1,"stats":{"Line":0}},{"line":196,"address":[17319352],"length":1,"stats":{"Line":0}},{"line":197,"address":[14414676],"length":1,"stats":{"Line":0}},{"line":201,"address":[23185073,23185173,23184096,23184048,23184673,23184254,23184056,23184131],"length":1,"stats":{"Line":0}},{"line":202,"address":[23180497,23180290,23180712,23180403],"length":1,"stats":{"Line":0}},{"line":204,"address":[17321945,17322832,17322173,17322655,17322081,17322369],"length":1,"stats":{"Line":0}},{"line":205,"address":[23142912],"length":1,"stats":{"Line":0}},{"line":208,"address":[23075328],"length":1,"stats":{"Line":0}},{"line":212,"address":[23187197,23187383,23187151,23187481,23187028,23187696],"length":1,"stats":{"Line":0}},{"line":215,"address":[11603652],"length":1,"stats":{"Line":0}},{"line":217,"address":[23076086,23076270],"length":1,"stats":{"Line":0}},{"line":219,"address":[17324000,17324566,17324787],"length":1,"stats":{"Line":0}},{"line":220,"address":[23069734],"length":1,"stats":{"Line":0}},{"line":221,"address":[23083604],"length":1,"stats":{"Line":0}},{"line":222,"address":[23186510],"length":1,"stats":{"Line":0}},{"line":223,"address":[23083732],"length":1,"stats":{"Line":0}},{"line":224,"address":[23144596],"length":1,"stats":{"Line":0}},{"line":225,"address":[23182718],"length":1,"stats":{"Line":0}},{"line":226,"address":[17324328],"length":1,"stats":{"Line":0}},{"line":227,"address":[23070116,23070034],"length":1,"stats":{"Line":0}},{"line":228,"address":[23151660],"length":1,"stats":{"Line":0}},{"line":229,"address":[23144798],"length":1,"stats":{"Line":0}},{"line":234,"address":[23145264],"length":1,"stats":{"Line":0}},{"line":239,"address":[23070905,23071018,23071112,23071340],"length":1,"stats":{"Line":0}},{"line":241,"address":[23071096,23071731,23071499,23071242,23071288,23071600,23071860],"length":1,"stats":{"Line":0}},{"line":242,"address":[23084951],"length":1,"stats":{"Line":0}},{"line":243,"address":[11519156],"length":1,"stats":{"Line":0}},{"line":244,"address":[23078436],"length":1,"stats":{"Line":0}},{"line":247,"address":[23146480],"length":1,"stats":{"Line":0}},{"line":252,"address":[23184825,23185032,23185260,23184938],"length":1,"stats":{"Line":0}},{"line":254,"address":[23072312,23072715,23072816,23072947,23073076,23072458,23072504],"length":1,"stats":{"Line":0}},{"line":255,"address":[23146999],"length":1,"stats":{"Line":0}},{"line":256,"address":[11515908],"length":1,"stats":{"Line":0}},{"line":257,"address":[23285940],"length":1,"stats":{"Line":0}},{"line":260,"address":[23073104],"length":1,"stats":{"Line":0}},{"line":264,"address":[17327583,17327790,17327696,17328008],"length":1,"stats":{"Line":0}},{"line":266,"address":[23087896,23087412,23088246,23087623,23087731,23087366,23087230],"length":1,"stats":{"Line":0}},{"line":268,"address":[23087325],"length":1,"stats":{"Line":0}},{"line":269,"address":[11643713],"length":1,"stats":{"Line":0}},{"line":271,"address":[23074073,23074181],"length":1,"stats":{"Line":0}},{"line":272,"address":[23074188,23074261],"length":1,"stats":{"Line":0}},{"line":273,"address":[23088023],"length":1,"stats":{"Line":0}},{"line":275,"address":[23190850],"length":1,"stats":{"Line":0}},{"line":278,"address":[14423554],"length":1,"stats":{"Line":0}},{"line":279,"address":[23148879],"length":1,"stats":{"Line":0}},{"line":283,"address":[14423545],"length":1,"stats":{"Line":0}},{"line":287,"address":[17328848],"length":1,"stats":{"Line":0}},{"line":291,"address":[23156753,23156361,23156246,23156465],"length":1,"stats":{"Line":0}},{"line":293,"address":[23156434,23156545],"length":1,"stats":{"Line":0}},{"line":294,"address":[23193069,23194020,23193362,23193603,23193423],"length":1,"stats":{"Line":0}},{"line":296,"address":[23075665,23075858],"length":1,"stats":{"Line":0}},{"line":300,"address":[17330486,17331053,17330818,17330448],"length":1,"stats":{"Line":0}},{"line":301,"address":[23192871],"length":1,"stats":{"Line":0}},{"line":302,"address":[23289363],"length":1,"stats":{"Line":0}},{"line":303,"address":[23090116],"length":1,"stats":{"Line":0}},{"line":304,"address":[23157946],"length":1,"stats":{"Line":0}},{"line":305,"address":[23289509],"length":1,"stats":{"Line":0}},{"line":306,"address":[23157968],"length":1,"stats":{"Line":0}},{"line":307,"address":[23151055,23151277],"length":1,"stats":{"Line":0}},{"line":308,"address":[23076502],"length":1,"stats":{"Line":0}},{"line":312,"address":[23194235],"length":1,"stats":{"Line":0}},{"line":313,"address":[23188643],"length":1,"stats":{"Line":0}},{"line":319,"address":[23152319,23151376,23152124],"length":1,"stats":{"Line":0}},{"line":321,"address":[23151406],"length":1,"stats":{"Line":0}},{"line":322,"address":[23289951],"length":1,"stats":{"Line":0}},{"line":323,"address":[23083681],"length":1,"stats":{"Line":0}},{"line":324,"address":[14426057,14426135],"length":1,"stats":{"Line":0}},{"line":325,"address":[23189731],"length":1,"stats":{"Line":0}},{"line":326,"address":[23151651],"length":1,"stats":{"Line":0}},{"line":327,"address":[23077094],"length":1,"stats":{"Line":0}},{"line":328,"address":[17331436],"length":1,"stats":{"Line":0}},{"line":329,"address":[23193844],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":165},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","ipc","direct_message_notifier.rs"],"content":"use crate::application::ports::direct_message_notifier::DirectMessageNotifier;\nuse crate::domain::entities::DirectMessage;\nuse crate::shared::AppError;\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter};\n\n#[derive(Clone)]\npub struct IpcDirectMessageNotifier {\n    app_handle: AppHandle,\n}\n\nimpl IpcDirectMessageNotifier {\n    pub fn new(app_handle: &AppHandle) -> Self {\n        Self {\n            app_handle: app_handle.clone(),\n        }\n    }\n}\n\n#[derive(Serialize, Clone)]\nstruct DirectMessagePayload {\n    event_id: Option<String>,\n    client_message_id: Option<String>,\n    sender_npub: String,\n    recipient_npub: String,\n    content: String,\n    created_at: i64,\n    delivered: bool,\n    direction: &'static str,\n    increment_amount: u32,\n}\n\n#[derive(Serialize, Clone)]\nstruct DirectMessageEventPayload {\n    owner_npub: String,\n    conversation_npub: String,\n    message: DirectMessagePayload,\n}\n\n#[async_trait]\nimpl DirectMessageNotifier for IpcDirectMessageNotifier {\n    async fn notify(&self, owner_npub: &str, message: &DirectMessage) -> Result<(), AppError> {\n        let payload = DirectMessageEventPayload {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: message.conversation_npub.clone(),\n            message: DirectMessagePayload {\n                event_id: message.event_id.clone(),\n                client_message_id: message.client_message_id.clone(),\n                sender_npub: message.sender_npub.clone(),\n                recipient_npub: message.recipient_npub.clone(),\n                content: message.decrypted_content.clone().unwrap_or_default(),\n                created_at: message.created_at_millis(),\n                delivered: message.delivered,\n                direction: message.direction.as_str(),\n                increment_amount: if message.direction\n                    == crate::domain::entities::MessageDirection::Inbound\n                {\n                    1\n                } else {\n                    0\n                },\n            },\n        };\n\n        self.app_handle\n            .emit(\"direct-message:received\", payload)\n            .map_err(|err| {\n                AppError::Internal(format!(\"Failed to emit direct message event: {err}\"))\n            })\n    }\n}\n","traces":[{"line":14,"address":[12872576],"length":1,"stats":{"Line":0}},{"line":16,"address":[12903784],"length":1,"stats":{"Line":0}},{"line":43,"address":[13021940,13021806,13021869,13021963,13023191,13021776,13021720],"length":1,"stats":{"Line":0}},{"line":45,"address":[12917540],"length":1,"stats":{"Line":0}},{"line":46,"address":[20678788],"length":1,"stats":{"Line":0}},{"line":47,"address":[12986024],"length":1,"stats":{"Line":0}},{"line":66,"address":[12986331],"length":1,"stats":{"Line":0}},{"line":68,"address":[13118258,13118032],"length":1,"stats":{"Line":0}},{"line":69,"address":[17313614,17313662],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","ipc","mod.rs"],"content":"pub mod direct_message_notifier;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","mod.rs"],"content":"pub mod commands;\npub mod dto;\npub mod handlers;\npub mod ipc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","config.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[repr(u8)]\n#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum BootstrapSource {\n    Env,\n    User,\n    Bundle,\n    Fallback,\n    #[default]\n    None,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AppConfig {\n    pub database: DatabaseConfig,\n    pub network: NetworkConfig,\n    pub sync: SyncConfig,\n    pub storage: StorageConfig,\n    pub metrics: MetricsConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    pub url: String,\n    pub max_connections: u32,\n    pub connection_timeout: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkConfig {\n    pub bootstrap_peers: Vec<String>,\n    pub max_peers: u32,\n    pub connection_timeout: u64,\n    pub retry_interval: u64,\n    // DHT/Discovery 関連フラグ\n    pub enable_dht: bool,\n    pub enable_dns: bool,\n    pub enable_local: bool,\n    #[serde(default)]\n    pub bootstrap_source: BootstrapSource,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncConfig {\n    pub auto_sync: bool,\n    pub sync_interval: u64,\n    pub max_retry: u32,\n    pub batch_size: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StorageConfig {\n    pub data_dir: String,\n    pub cache_size: u64,\n    pub cache_ttl: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsConfig {\n    pub enabled: bool,\n    pub interval_minutes: u64,\n    pub ttl_hours: u64,\n    pub score_weights: MetricsScoreWeightsConfig,\n    #[serde(default)]\n    pub prometheus_port: Option<u16>,\n    #[serde(default)]\n    pub emit_histogram: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsScoreWeightsConfig {\n    pub posts: f64,\n    pub unique_authors: f64,\n    pub boosts: f64,\n}\n\nimpl Default for AppConfig {\n    fn default() -> Self {\n        Self {\n            database: DatabaseConfig {\n                url: \"sqlite:data/kukuri.db\".to_string(),\n                max_connections: 5,\n                connection_timeout: 30,\n            },\n            network: NetworkConfig {\n                bootstrap_peers: vec![],\n                max_peers: 50,\n                connection_timeout: 30,\n                retry_interval: 60,\n                enable_dht: true,\n                enable_dns: true,\n                enable_local: false,\n                bootstrap_source: BootstrapSource::None,\n            },\n            sync: SyncConfig {\n                auto_sync: true,\n                sync_interval: 300, // 5 minutes\n                max_retry: 3,\n                batch_size: 100,\n            },\n            storage: StorageConfig {\n                data_dir: \"./data\".to_string(),\n                cache_size: 100 * 1024 * 1024, // 100MB\n                cache_ttl: 3600,               // 1 hour\n            },\n            metrics: MetricsConfig::default(),\n        }\n    }\n}\n\nimpl Default for MetricsConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            interval_minutes: 5,\n            ttl_hours: 48,\n            score_weights: MetricsScoreWeightsConfig::default(),\n            prometheus_port: None,\n            emit_histogram: false,\n        }\n    }\n}\n\nimpl Default for MetricsScoreWeightsConfig {\n    fn default() -> Self {\n        Self {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        }\n    }\n}\n\nimpl AppConfig {\n    pub fn from_env() -> Self {\n        // 既定値\n        let mut cfg = Self::default();\n        let mut bootstrap_source = BootstrapSource::None;\n\n        // ネットワーク設定の環境変数反映\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DHT\") {\n            cfg.network.enable_dht = parse_bool(&v, cfg.network.enable_dht);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DNS\") {\n            cfg.network.enable_dns = parse_bool(&v, cfg.network.enable_dns);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_LOCAL\") {\n            cfg.network.enable_local = parse_bool(&v, cfg.network.enable_local);\n        }\n\n        if let Ok(v) = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\") {\n            let peers: Vec<String> = v\n                .split(',')\n                .map(|s| s.trim().to_string())\n                .filter(|s| !s.is_empty())\n                .collect();\n            if !peers.is_empty() {\n                cfg.network.bootstrap_peers = peers;\n                bootstrap_source = BootstrapSource::Env;\n            }\n        }\n\n        cfg.network.bootstrap_source = bootstrap_source;\n\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_ENABLED\") {\n            cfg.metrics.enabled = parse_bool(&v, cfg.metrics.enabled);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_INTERVAL_MINUTES\") {\n            if let Some(value) = parse_u64(&v) {\n                cfg.metrics.interval_minutes = value.max(1);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_TTL_HOURS\") {\n            if let Some(value) = parse_u64(&v) {\n                cfg.metrics.ttl_hours = value.max(1);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_POSTS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.posts = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_UNIQUE_AUTHORS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.unique_authors = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_BOOSTS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.boosts = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_PROMETHEUS_PORT\") {\n            if let Some(value) = parse_u16(&v) {\n                cfg.metrics.prometheus_port = if value == 0 { None } else { Some(value) };\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_EMIT_HISTOGRAM\") {\n            cfg.metrics.emit_histogram = parse_bool(&v, cfg.metrics.emit_histogram);\n        }\n\n        cfg\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if self.database.max_connections == 0 {\n            return Err(\"Database max_connections must be greater than 0\".to_string());\n        }\n        if self.network.max_peers == 0 {\n            return Err(\"Network max_peers must be greater than 0\".to_string());\n        }\n        if self.metrics.enabled {\n            if self.metrics.interval_minutes == 0 {\n                return Err(\"Metrics interval_minutes must be greater than 0\".to_string());\n            }\n            if self.metrics.ttl_hours == 0 {\n                return Err(\"Metrics ttl_hours must be greater than 0\".to_string());\n            }\n        }\n        if let Some(port) = self.metrics.prometheus_port {\n            if port == 0 {\n                return Err(\"Metrics prometheus_port must be greater than 0\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\nfn parse_bool(s: &str, default: bool) -> bool {\n    match s.to_ascii_lowercase().as_str() {\n        \"1\" | \"true\" | \"yes\" | \"on\" => true,\n        \"0\" | \"false\" | \"no\" | \"off\" => false,\n        _ => default,\n    }\n}\n\nfn parse_u64(value: &str) -> Option<u64> {\n    value.trim().parse::<u64>().ok()\n}\n\nfn parse_f64(value: &str) -> Option<f64> {\n    value.trim().parse::<f64>().ok()\n}\n\nfn parse_u16(value: &str) -> Option<u16> {\n    value.trim().parse::<u16>().ok()\n}\n","traces":[{"line":80,"address":[21425057,21424288],"length":1,"stats":{"Line":1}},{"line":82,"address":[21410571],"length":1,"stats":{"Line":1}},{"line":87,"address":[21527316],"length":1,"stats":{"Line":1}},{"line":97,"address":[21529060],"length":1,"stats":{"Line":1}},{"line":103,"address":[21527645],"length":1,"stats":{"Line":1}},{"line":108,"address":[21527697],"length":1,"stats":{"Line":1}},{"line":114,"address":[23094976],"length":1,"stats":{"Line":1}},{"line":119,"address":[21485934],"length":1,"stats":{"Line":1}},{"line":127,"address":[21425216],"length":1,"stats":{"Line":1}},{"line":137,"address":[21528144,21533224,21528588],"length":1,"stats":{"Line":0}},{"line":139,"address":[21529815],"length":1,"stats":{"Line":0}},{"line":140,"address":[21411552],"length":1,"stats":{"Line":0}},{"line":143,"address":[21524339,21524264],"length":1,"stats":{"Line":0}},{"line":144,"address":[23095326,23095428],"length":1,"stats":{"Line":0}},{"line":146,"address":[21624970,21625051],"length":1,"stats":{"Line":0}},{"line":147,"address":[21412132,21412030],"length":1,"stats":{"Line":0}},{"line":149,"address":[21524946,21525018],"length":1,"stats":{"Line":0}},{"line":150,"address":[21412467,21412365],"length":1,"stats":{"Line":0}},{"line":153,"address":[21426337,21426409],"length":1,"stats":{"Line":0}},{"line":154,"address":[15667004,15667109],"length":1,"stats":{"Line":0}},{"line":156,"address":[21491253,21491200],"length":1,"stats":{"Line":0}},{"line":157,"address":[23100336,23100361],"length":1,"stats":{"Line":0}},{"line":159,"address":[21525696,21525622,21525925],"length":1,"stats":{"Line":0}},{"line":160,"address":[21529716,21529638],"length":1,"stats":{"Line":0}},{"line":161,"address":[21626271],"length":1,"stats":{"Line":0}},{"line":165,"address":[21494842],"length":1,"stats":{"Line":0}},{"line":167,"address":[21413336,21413430],"length":1,"stats":{"Line":0}},{"line":168,"address":[21530121,21530223],"length":1,"stats":{"Line":0}},{"line":170,"address":[21488357,21488285],"length":1,"stats":{"Line":0}},{"line":171,"address":[21413816,21414062,21413921],"length":1,"stats":{"Line":0}},{"line":172,"address":[21488646,21488595],"length":1,"stats":{"Line":0}},{"line":175,"address":[21495634,21495706],"length":1,"stats":{"Line":0}},{"line":176,"address":[21532630,21532525,21532771],"length":1,"stats":{"Line":0}},{"line":177,"address":[21489016,21489067],"length":1,"stats":{"Line":0}},{"line":180,"address":[21421319,21421391],"length":1,"stats":{"Line":0}},{"line":181,"address":[21531298,21531403,21531546],"length":1,"stats":{"Line":0}},{"line":182,"address":[21428657,21428613],"length":1,"stats":{"Line":0}},{"line":185,"address":[21414958,21415030],"length":1,"stats":{"Line":0}},{"line":186,"address":[15669478,15669385,15669603],"length":1,"stats":{"Line":0}},{"line":187,"address":[21422074,21422036],"length":1,"stats":{"Line":0}},{"line":190,"address":[21496871,21496943],"length":1,"stats":{"Line":0}},{"line":191,"address":[21422351,21422476,21422258],"length":1,"stats":{"Line":0}},{"line":192,"address":[15669949,15669987],"length":1,"stats":{"Line":0}},{"line":195,"address":[21490336,21490408],"length":1,"stats":{"Line":0}},{"line":196,"address":[21422744,21422916,21422651],"length":1,"stats":{"Line":0}},{"line":197,"address":[23099666,23099693],"length":1,"stats":{"Line":0}},{"line":200,"address":[21528960,21528888],"length":1,"stats":{"Line":0}},{"line":201,"address":[21529011,21529101],"length":1,"stats":{"Line":0}},{"line":204,"address":[21533149],"length":1,"stats":{"Line":0}},{"line":207,"address":[21529456],"length":1,"stats":{"Line":0}},{"line":208,"address":[21498302],"length":1,"stats":{"Line":0}},{"line":209,"address":[21529492],"length":1,"stats":{"Line":0}},{"line":211,"address":[21533489],"length":1,"stats":{"Line":0}},{"line":212,"address":[23100502],"length":1,"stats":{"Line":0}},{"line":214,"address":[21498451],"length":1,"stats":{"Line":0}},{"line":215,"address":[23100604],"length":1,"stats":{"Line":0}},{"line":216,"address":[21533622],"length":1,"stats":{"Line":0}},{"line":218,"address":[21533686],"length":1,"stats":{"Line":0}},{"line":219,"address":[23100688],"length":1,"stats":{"Line":0}},{"line":222,"address":[23100577,23100752],"length":1,"stats":{"Line":0}},{"line":223,"address":[21491727],"length":1,"stats":{"Line":0}},{"line":224,"address":[15671468],"length":1,"stats":{"Line":0}},{"line":227,"address":[23100778],"length":1,"stats":{"Line":0}},{"line":231,"address":[21417770,21417248],"length":1,"stats":{"Line":0}},{"line":232,"address":[21417293,21417368],"length":1,"stats":{"Line":0}},{"line":233,"address":[21630456],"length":1,"stats":{"Line":0}},{"line":234,"address":[15671870],"length":1,"stats":{"Line":0}},{"line":235,"address":[21630811],"length":1,"stats":{"Line":0}},{"line":239,"address":[21530496],"length":1,"stats":{"Line":0}},{"line":240,"address":[21536094],"length":1,"stats":{"Line":0}},{"line":243,"address":[21530560],"length":1,"stats":{"Line":0}},{"line":244,"address":[21417870],"length":1,"stats":{"Line":0}},{"line":247,"address":[21534560],"length":1,"stats":{"Line":0}},{"line":248,"address":[21424718],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":74},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","error.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse serde::Serialize;\nuse thiserror::Error;\n\n#[derive(Debug, Error, Serialize)]\npub enum AppError {\n    #[error(\"Database error: {0}\")]\n    Database(String),\n    #[error(\"Network error: {0}\")]\n    Network(String),\n    #[error(\"Crypto error: {0}\")]\n    Crypto(String),\n    #[error(\"Storage error: {0}\")]\n    Storage(String),\n    #[error(\"Auth error: {0}\")]\n    Auth(String),\n    #[error(\"Unauthorized: {0}\")]\n    Unauthorized(String),\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n    #[error(\"Validation error ({kind}): {message}\")]\n    ValidationError {\n        kind: ValidationFailureKind,\n        message: String,\n    },\n    #[error(\"Rate limited: {message}\")]\n    RateLimited {\n        message: String,\n        retry_after_seconds: u64,\n    },\n    #[error(\"Nostr error: {0}\")]\n    NostrError(String),\n    #[error(\"P2P error: {0}\")]\n    P2PError(String),\n    #[error(\"Configuration error: {0}\")]\n    ConfigurationError(String),\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n    #[error(\"Deserialization error: {0}\")]\n    DeserializationError(String),\n    #[error(\"Not implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n}\n\nimpl AppError {\n    pub fn validation(kind: ValidationFailureKind, message: impl Into<String>) -> Self {\n        AppError::ValidationError {\n            kind,\n            message: message.into(),\n        }\n    }\n\n    pub fn validation_kind(&self) -> Option<ValidationFailureKind> {\n        match self {\n            AppError::ValidationError { kind, .. } => Some(*kind),\n            _ => None,\n        }\n    }\n\n    pub fn validation_message(&self) -> Option<&str> {\n        match self {\n            AppError::ValidationError { message, .. } => Some(message.as_str()),\n            _ => None,\n        }\n    }\n\n    pub fn validation_mapper(kind: ValidationFailureKind) -> impl FnOnce(String) -> Self {\n        move |message| AppError::validation(kind, message)\n    }\n\n    pub fn rate_limited(message: impl Into<String>, retry_after_seconds: u64) -> Self {\n        AppError::RateLimited {\n            message: message.into(),\n            retry_after_seconds,\n        }\n    }\n\n    pub fn code(&self) -> &'static str {\n        match self {\n            AppError::Database(_) => \"DATABASE_ERROR\",\n            AppError::Network(_) => \"NETWORK_ERROR\",\n            AppError::Crypto(_) => \"CRYPTO_ERROR\",\n            AppError::Storage(_) => \"STORAGE_ERROR\",\n            AppError::Auth(_) => \"AUTH_ERROR\",\n            AppError::Unauthorized(_) => \"UNAUTHORIZED\",\n            AppError::NotFound(_) => \"NOT_FOUND\",\n            AppError::InvalidInput(_) => \"INVALID_INPUT\",\n            AppError::ValidationError { .. } => \"VALIDATION_ERROR\",\n            AppError::RateLimited { .. } => \"RATE_LIMITED\",\n            AppError::NostrError(_) => \"NOSTR_ERROR\",\n            AppError::P2PError(_) => \"P2P_ERROR\",\n            AppError::ConfigurationError(_) => \"CONFIGURATION_ERROR\",\n            AppError::SerializationError(_) => \"SERIALIZATION_ERROR\",\n            AppError::DeserializationError(_) => \"DESERIALIZATION_ERROR\",\n            AppError::NotImplemented(_) => \"NOT_IMPLEMENTED\",\n            AppError::Internal(_) => \"INTERNAL_ERROR\",\n        }\n    }\n\n    pub fn user_message(&self) -> String {\n        match self {\n            AppError::Database(_) => \"Database operation failed\".to_string(),\n            AppError::Network(_) => \"Network request failed\".to_string(),\n            AppError::Crypto(_) => \"Cryptographic operation failed\".to_string(),\n            AppError::Storage(_) => \"Storage access failed\".to_string(),\n            AppError::Auth(_) => \"Authentication failed\".to_string(),\n            AppError::Unauthorized(_) => {\n                \"You are not authorized to perform this action\".to_string()\n            }\n            AppError::NotFound(_) => \"The requested resource was not found\".to_string(),\n            AppError::InvalidInput(_) => \"Input data is invalid\".to_string(),\n            AppError::ValidationError { message, .. } => {\n                format!(\"Validation failed: {message}\")\n            }\n            AppError::RateLimited { message, .. } => message.clone(),\n            AppError::NostrError(_) => \"Nostr operation failed\".to_string(),\n            AppError::P2PError(_) => \"Peer-to-peer operation failed\".to_string(),\n            AppError::ConfigurationError(_) => \"Configuration error detected\".to_string(),\n            AppError::SerializationError(_) => \"Serialization error occurred\".to_string(),\n            AppError::DeserializationError(_) => \"Deserialization error occurred\".to_string(),\n            AppError::NotImplemented(_) => \"This feature is not implemented\".to_string(),\n            AppError::Internal(_) => \"An internal error occurred\".to_string(),\n        }\n    }\n}\n\nimpl From<sqlx::Error> for AppError {\n    fn from(err: sqlx::Error) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error>> for AppError {\n    fn from(err: Box<dyn std::error::Error>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error + Send + Sync>> for AppError {\n    fn from(err: Box<dyn std::error::Error + Send + Sync>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<String> for AppError {\n    fn from(err: String) -> Self {\n        AppError::Internal(err)\n    }\n}\n\nimpl From<&str> for AppError {\n    fn from(err: &str) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::EventId> for AppError {\n    fn from(_: nostr_sdk::prelude::EventId) -> Self {\n        AppError::NostrError(\"Invalid EventId conversion\".to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::Error> for AppError {\n    fn from(err: nostr_sdk::event::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::secp256k1::Error> for AppError {\n    fn from(err: nostr_sdk::prelude::secp256k1::Error) -> Self {\n        AppError::Crypto(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::key::Error> for AppError {\n    fn from(err: nostr_sdk::key::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::builder::Error> for AppError {\n    fn from(err: nostr_sdk::event::builder::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<serde_json::Error> for AppError {\n    fn from(err: serde_json::Error) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<anyhow::Error> for AppError {\n    fn from(err: anyhow::Error) -> Self {\n        AppError::P2PError(err.to_string())\n    }\n}\n\nimpl From<sqlx::migrate::MigrateError> for AppError {\n    fn from(err: sqlx::migrate::MigrateError) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<iroh::endpoint::Builder> for AppError {\n    fn from(err: iroh::endpoint::Builder) -> Self {\n        AppError::P2PError(format!(\"Endpoint builder error: {err:?}\"))\n    }\n}\n\npub type Result<T> = std::result::Result<T, AppError>;\n","traces":[{"line":50,"address":[16610272,16610384],"length":1,"stats":{"Line":1}},{"line":53,"address":[26641394,26641527],"length":1,"stats":{"Line":1}},{"line":57,"address":[16671344],"length":1,"stats":{"Line":1}},{"line":58,"address":[16678282],"length":1,"stats":{"Line":1}},{"line":59,"address":[16603560],"length":1,"stats":{"Line":1}},{"line":60,"address":[16709501],"length":1,"stats":{"Line":1}},{"line":64,"address":[24371792],"length":1,"stats":{"Line":1}},{"line":65,"address":[16809901],"length":1,"stats":{"Line":1}},{"line":66,"address":[16709546],"length":1,"stats":{"Line":1}},{"line":67,"address":[16671460],"length":1,"stats":{"Line":0}},{"line":71,"address":[16678416],"length":1,"stats":{"Line":3}},{"line":72,"address":[16715219,16715200],"length":1,"stats":{"Line":0}},{"line":75,"address":[16810032],"length":1,"stats":{"Line":1}},{"line":77,"address":[16610753],"length":1,"stats":{"Line":1}},{"line":82,"address":[26641920],"length":1,"stats":{"Line":0}},{"line":83,"address":[24372053],"length":1,"stats":{"Line":0}},{"line":84,"address":[26641956],"length":1,"stats":{"Line":0}},{"line":85,"address":[16597134],"length":1,"stats":{"Line":0}},{"line":86,"address":[16810232],"length":1,"stats":{"Line":0}},{"line":87,"address":[16678706],"length":1,"stats":{"Line":0}},{"line":88,"address":[16709916],"length":1,"stats":{"Line":0}},{"line":89,"address":[16810310],"length":1,"stats":{"Line":0}},{"line":90,"address":[16709968],"length":1,"stats":{"Line":0}},{"line":91,"address":[16810362],"length":1,"stats":{"Line":0}},{"line":92,"address":[16710020],"length":1,"stats":{"Line":0}},{"line":93,"address":[16810414],"length":1,"stats":{"Line":0}},{"line":94,"address":[16671960],"length":1,"stats":{"Line":0}},{"line":95,"address":[16715682],"length":1,"stats":{"Line":0}},{"line":96,"address":[16597417],"length":1,"stats":{"Line":0}},{"line":97,"address":[16714080],"length":1,"stats":{"Line":0}},{"line":98,"address":[26642311],"length":1,"stats":{"Line":0}},{"line":99,"address":[16611246],"length":1,"stats":{"Line":0}},{"line":100,"address":[16672101],"length":1,"stats":{"Line":0}},{"line":104,"address":[16715840],"length":1,"stats":{"Line":0}},{"line":105,"address":[16714222],"length":1,"stats":{"Line":0}},{"line":106,"address":[16597618],"length":1,"stats":{"Line":0}},{"line":107,"address":[16611406],"length":1,"stats":{"Line":0}},{"line":108,"address":[16604458],"length":1,"stats":{"Line":0}},{"line":109,"address":[24372678],"length":1,"stats":{"Line":0}},{"line":110,"address":[16716018],"length":1,"stats":{"Line":0}},{"line":112,"address":[16716046],"length":1,"stats":{"Line":0}},{"line":114,"address":[16710490],"length":1,"stats":{"Line":0}},{"line":115,"address":[16604598],"length":1,"stats":{"Line":0}},{"line":116,"address":[16672434],"length":1,"stats":{"Line":0}},{"line":117,"address":[24372827],"length":1,"stats":{"Line":0}},{"line":119,"address":[24372944],"length":1,"stats":{"Line":0}},{"line":120,"address":[16716284],"length":1,"stats":{"Line":0}},{"line":121,"address":[16672616],"length":1,"stats":{"Line":0}},{"line":122,"address":[24373025],"length":1,"stats":{"Line":0}},{"line":123,"address":[16598074],"length":1,"stats":{"Line":0}},{"line":124,"address":[16716387],"length":1,"stats":{"Line":0}},{"line":125,"address":[16598124],"length":1,"stats":{"Line":0}},{"line":126,"address":[16604933],"length":1,"stats":{"Line":0}},{"line":132,"address":[16811264,16811387],"length":1,"stats":{"Line":1}},{"line":133,"address":[26643064,26643113],"length":1,"stats":{"Line":2}},{"line":138,"address":[24373312,24373443],"length":1,"stats":{"Line":0}},{"line":139,"address":[16605200,16605143],"length":1,"stats":{"Line":0}},{"line":144,"address":[16715267,16715136],"length":1,"stats":{"Line":0}},{"line":145,"address":[24373495,24373552],"length":1,"stats":{"Line":0}},{"line":150,"address":[16716944],"length":1,"stats":{"Line":0}},{"line":151,"address":[24373635],"length":1,"stats":{"Line":0}},{"line":156,"address":[16716976],"length":1,"stats":{"Line":0}},{"line":157,"address":[16811783],"length":1,"stats":{"Line":0}},{"line":162,"address":[16605552],"length":1,"stats":{"Line":0}},{"line":163,"address":[16711485],"length":1,"stats":{"Line":0}},{"line":168,"address":[16673440,16673563],"length":1,"stats":{"Line":0}},{"line":169,"address":[24373901,24373843],"length":1,"stats":{"Line":0}},{"line":174,"address":[16673584],"length":1,"stats":{"Line":0}},{"line":175,"address":[16599014],"length":1,"stats":{"Line":0}},{"line":180,"address":[16812160],"length":1,"stats":{"Line":0}},{"line":181,"address":[16812173],"length":1,"stats":{"Line":0}},{"line":186,"address":[16673760,16673883],"length":1,"stats":{"Line":0}},{"line":187,"address":[16715885,16715827],"length":1,"stats":{"Line":0}},{"line":192,"address":[16680960,16680832],"length":1,"stats":{"Line":0}},{"line":193,"address":[16812461,16812403],"length":1,"stats":{"Line":0}},{"line":198,"address":[16674064,16674192],"length":1,"stats":{"Line":0}},{"line":199,"address":[16712195,16712253],"length":1,"stats":{"Line":0}},{"line":204,"address":[16606416,16606539],"length":1,"stats":{"Line":0}},{"line":205,"address":[16599709,16599651],"length":1,"stats":{"Line":0}},{"line":210,"address":[16613536,16613762],"length":1,"stats":{"Line":0}},{"line":211,"address":[16674450,16674390],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":81},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","metrics.rs"],"content":"use std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub const UNSET_TS: u64 = 0;\n\n#[derive(Debug)]\npub struct AtomicMetric {\n    success: AtomicU64,\n    failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct AtomicSnapshot {\n    pub successes: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\nimpl AtomicMetric {\n    pub const fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(UNSET_TS),\n            last_failure_ms: AtomicU64::new(UNSET_TS),\n        }\n    }\n\n    pub fn record_success(&self) {\n        self.success.fetch_add(1, Ordering::Relaxed);\n        self.last_success_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    pub fn record_failure(&self) {\n        self.failure.fetch_add(1, Ordering::Relaxed);\n        self.last_failure_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    pub fn snapshot(&self) -> AtomicSnapshot {\n        AtomicSnapshot {\n            successes: self.success.load(Ordering::Relaxed),\n            failures: self.failure.load(Ordering::Relaxed),\n            last_success_ms: timestamp_to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: timestamp_to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n        }\n    }\n\n    pub fn reset(&self) {\n        self.success.store(0, Ordering::Relaxed);\n        self.failure.store(0, Ordering::Relaxed);\n        self.last_success_ms.store(UNSET_TS, Ordering::Relaxed);\n        self.last_failure_ms.store(UNSET_TS, Ordering::Relaxed);\n    }\n}\n\n#[inline]\npub fn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|duration| duration.as_millis() as u64)\n        .unwrap_or(UNSET_TS)\n}\n\n#[inline]\npub fn timestamp_to_option(value: u64) -> Option<u64> {\n    if value == UNSET_TS { None } else { Some(value) }\n}\n","traces":[{"line":23,"address":[18990400],"length":1,"stats":{"Line":0}},{"line":25,"address":[19121966],"length":1,"stats":{"Line":0}},{"line":26,"address":[18915702],"length":1,"stats":{"Line":0}},{"line":27,"address":[19027230],"length":1,"stats":{"Line":0}},{"line":28,"address":[18990486],"length":1,"stats":{"Line":0}},{"line":32,"address":[18909056],"length":1,"stats":{"Line":1}},{"line":33,"address":[19025710],"length":1,"stats":{"Line":1}},{"line":34,"address":[19122194,19122167],"length":1,"stats":{"Line":2}},{"line":35,"address":[18990624],"length":1,"stats":{"Line":1}},{"line":38,"address":[18915936],"length":1,"stats":{"Line":1}},{"line":39,"address":[18990686],"length":1,"stats":{"Line":1}},{"line":40,"address":[18915979,18916006],"length":1,"stats":{"Line":2}},{"line":41,"address":[13163508],"length":1,"stats":{"Line":1}},{"line":44,"address":[19122320],"length":1,"stats":{"Line":1}},{"line":46,"address":[19025918],"length":1,"stats":{"Line":1}},{"line":47,"address":[19022006],"length":1,"stats":{"Line":2}},{"line":48,"address":[18909330],"length":1,"stats":{"Line":2}},{"line":49,"address":[18990891],"length":1,"stats":{"Line":2}},{"line":53,"address":[18984064],"length":1,"stats":{"Line":1}},{"line":54,"address":[19022189],"length":1,"stats":{"Line":1}},{"line":55,"address":[18984100],"length":1,"stats":{"Line":1}},{"line":56,"address":[18916319],"length":1,"stats":{"Line":1}},{"line":57,"address":[21057946],"length":1,"stats":{"Line":1}},{"line":62,"address":[18984192],"length":1,"stats":{"Line":1}},{"line":63,"address":[13163908],"length":1,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[19026320,19026335],"length":1,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[19028000],"length":1,"stats":{"Line":2}},{"line":71,"address":[21058106],"length":1,"stats":{"Line":2}}],"covered":23,"coverable":30},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","mod.rs"],"content":"#![allow(unused_imports)]\n\npub mod config;\npub mod error;\npub mod metrics;\npub mod rate_limiter;\npub mod validation;\n\npub use config::AppConfig;\npub use error::{AppError, Result};\npub use rate_limiter::RateLimiter;\npub use validation::ValidationFailureKind;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","rate_limiter.rs"],"content":"use crate::shared::AppError;\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tokio::sync::Mutex;\n\npub struct RateLimiter {\n    requests: Mutex<HashMap<String, Vec<Instant>>>,\n    max_requests: usize,\n    window: Duration,\n}\n\nimpl RateLimiter {\n    pub fn new(max_requests: usize, window: Duration) -> Self {\n        Self {\n            requests: Mutex::new(HashMap::new()),\n            max_requests,\n            window,\n        }\n    }\n\n    pub async fn check_and_record(&self, key: &str, message: &str) -> Result<(), AppError> {\n        let mut guard = self.requests.lock().await;\n        let now = Instant::now();\n        let entries = guard.entry(key.to_string()).or_default();\n        entries.retain(|instant| now.duration_since(*instant) < self.window);\n        if entries.len() >= self.max_requests {\n            let retry_after = self\n                .window\n                .checked_sub(now.duration_since(entries[0]))\n                .unwrap_or_default();\n            return Err(AppError::rate_limited(\n                message,\n                retry_after.as_secs().max(1),\n            ));\n        }\n        entries.push(now);\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[14465664],"length":1,"stats":{"Line":2}},{"line":15,"address":[14252645],"length":1,"stats":{"Line":2}},{"line":21,"address":[14369662,14369392,14369456,14369503,14370874,14369702,14369840,14369420],"length":1,"stats":{"Line":4}},{"line":22,"address":[14334752,14334511,14334632,14334572],"length":1,"stats":{"Line":2}},{"line":23,"address":[14371737,14371822],"length":1,"stats":{"Line":2}},{"line":24,"address":[14371837],"length":1,"stats":{"Line":1}},{"line":25,"address":[14372544,14372565,14371965],"length":1,"stats":{"Line":3}},{"line":26,"address":[14253713],"length":1,"stats":{"Line":1}},{"line":27,"address":[14372279,14372083],"length":1,"stats":{"Line":2}},{"line":29,"address":[14370579,14370463],"length":1,"stats":{"Line":2}},{"line":31,"address":[14370785],"length":1,"stats":{"Line":1}},{"line":32,"address":[14372348],"length":1,"stats":{"Line":1}},{"line":33,"address":[14254094],"length":1,"stats":{"Line":1}},{"line":36,"address":[22028733],"length":1,"stats":{"Line":1}},{"line":37,"address":[14372138],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","validation.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// Nostr イベント検証やアプリケーションレベルのバリデーション失敗理由。\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub enum ValidationFailureKind {\n    /// 汎用的なバリデーションエラー。\n    Generic,\n    /// NIP-01 の基本整合性（ID 再計算・署名・タイムスタンプなど）違反。\n    Nip01Integrity,\n    /// NIP-10 のタグ構造（marker・relay URL 等）違反。\n    Nip10TagStructure,\n    /// NIP-19 の bech32 エンコードが不正な場合。\n    Nip19Encoding,\n    /// NIP-19 の TLV セクションが仕様外な場合。\n    Nip19Tlv,\n    /// サポート外の `kind` が指定された場合。\n    UnsupportedKind,\n    /// kind:30078 の必須タグ欠如や識別子不正。\n    Kind30078TagMissing,\n    /// kind:30078 のタグ値に不一致がある場合。\n    Kind30078TagMismatch,\n    /// kind:30078 の content スキーマが仕様外。\n    Kind30078ContentSchema,\n    /// kind:30078 の content サイズが許容範囲を超えた場合。\n    Kind30078ContentSize,\n    /// content のサイズが制限を超過。\n    ContentTooLarge,\n    /// tags の件数が制限を超過、またはタグ内容が UTF-8 ではない。\n    TagLimitExceeded,\n    /// 非 UTF-8 文字列が含まれている場合。\n    Utf8Invalid,\n    /// 許容できないタイムスタンプやプレシデンス違反。\n    TimestampOutOfRange,\n    /// PRE（Parameterized Replaceable Event）の古いリビジョンを拒否した場合。\n    PrecedenceRejected,\n}\n\nimpl ValidationFailureKind {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            ValidationFailureKind::Generic => \"generic\",\n            ValidationFailureKind::Nip01Integrity => \"nip01_integrity\",\n            ValidationFailureKind::Nip10TagStructure => \"nip10_tag_structure\",\n            ValidationFailureKind::Nip19Encoding => \"nip19_encoding\",\n            ValidationFailureKind::Nip19Tlv => \"nip19_tlv\",\n            ValidationFailureKind::UnsupportedKind => \"unsupported_kind\",\n            ValidationFailureKind::Kind30078TagMissing => \"kind30078_tag_missing\",\n            ValidationFailureKind::Kind30078TagMismatch => \"kind30078_tag_mismatch\",\n            ValidationFailureKind::Kind30078ContentSchema => \"kind30078_content_schema\",\n            ValidationFailureKind::Kind30078ContentSize => \"kind30078_content_size\",\n            ValidationFailureKind::ContentTooLarge => \"content_too_large\",\n            ValidationFailureKind::TagLimitExceeded => \"tag_limit_exceeded\",\n            ValidationFailureKind::Utf8Invalid => \"utf8_invalid\",\n            ValidationFailureKind::TimestampOutOfRange => \"timestamp_out_of_range\",\n            ValidationFailureKind::PrecedenceRejected => \"precedence_rejected\",\n        }\n    }\n}\n\nimpl fmt::Display for ValidationFailureKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\nimpl FromStr for ValidationFailureKind {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"generic\" => Ok(ValidationFailureKind::Generic),\n            \"nip01_integrity\" => Ok(ValidationFailureKind::Nip01Integrity),\n            \"nip10_tag_structure\" => Ok(ValidationFailureKind::Nip10TagStructure),\n            \"nip19_encoding\" => Ok(ValidationFailureKind::Nip19Encoding),\n            \"nip19_tlv\" => Ok(ValidationFailureKind::Nip19Tlv),\n            \"unsupported_kind\" => Ok(ValidationFailureKind::UnsupportedKind),\n            \"kind30078_tag_missing\" => Ok(ValidationFailureKind::Kind30078TagMissing),\n            \"kind30078_tag_mismatch\" => Ok(ValidationFailureKind::Kind30078TagMismatch),\n            \"kind30078_content_schema\" => Ok(ValidationFailureKind::Kind30078ContentSchema),\n            \"kind30078_content_size\" => Ok(ValidationFailureKind::Kind30078ContentSize),\n            \"content_too_large\" => Ok(ValidationFailureKind::ContentTooLarge),\n            \"tag_limit_exceeded\" => Ok(ValidationFailureKind::TagLimitExceeded),\n            \"utf8_invalid\" => Ok(ValidationFailureKind::Utf8Invalid),\n            \"timestamp_out_of_range\" => Ok(ValidationFailureKind::TimestampOutOfRange),\n            \"precedence_rejected\" => Ok(ValidationFailureKind::PrecedenceRejected),\n            _ => Err(()),\n        }\n    }\n}\n","traces":[{"line":40,"address":[24875056],"length":1,"stats":{"Line":0}},{"line":41,"address":[24675749],"length":1,"stats":{"Line":0}},{"line":42,"address":[24778660],"length":1,"stats":{"Line":0}},{"line":43,"address":[24875118],"length":1,"stats":{"Line":0}},{"line":44,"address":[24662072],"length":1,"stats":{"Line":0}},{"line":45,"address":[24778738],"length":1,"stats":{"Line":0}},{"line":46,"address":[24675884],"length":1,"stats":{"Line":0}},{"line":47,"address":[24780438],"length":1,"stats":{"Line":0}},{"line":48,"address":[24662176],"length":1,"stats":{"Line":0}},{"line":49,"address":[24662202],"length":1,"stats":{"Line":0}},{"line":50,"address":[24662228],"length":1,"stats":{"Line":0}},{"line":51,"address":[24669038],"length":1,"stats":{"Line":0}},{"line":52,"address":[24676037],"length":1,"stats":{"Line":0}},{"line":53,"address":[24669084],"length":1,"stats":{"Line":0}},{"line":54,"address":[24775027],"length":1,"stats":{"Line":0}},{"line":55,"address":[24778986],"length":1,"stats":{"Line":0}},{"line":56,"address":[18916673],"length":1,"stats":{"Line":0}},{"line":62,"address":[24779056],"length":1,"stats":{"Line":0}},{"line":63,"address":[24737026],"length":1,"stats":{"Line":0}},{"line":69,"address":[24676224],"length":1,"stats":{"Line":0}},{"line":71,"address":[24875560,24875614],"length":1,"stats":{"Line":0}},{"line":72,"address":[24779159,24779233],"length":1,"stats":{"Line":0}},{"line":73,"address":[24875716,24875642],"length":1,"stats":{"Line":0}},{"line":74,"address":[24676455,24676381],"length":1,"stats":{"Line":0}},{"line":75,"address":[24669530,24669456],"length":1,"stats":{"Line":0}},{"line":76,"address":[24781011,24781085],"length":1,"stats":{"Line":0}},{"line":77,"address":[18917152,18917078],"length":1,"stats":{"Line":0}},{"line":78,"address":[24779465,24779539],"length":1,"stats":{"Line":0}},{"line":79,"address":[24662876,24662950],"length":1,"stats":{"Line":0}},{"line":80,"address":[24775631,24775705],"length":1,"stats":{"Line":0}},{"line":81,"address":[24676738,24676812],"length":1,"stats":{"Line":0}},{"line":82,"address":[12246927,12246853],"length":1,"stats":{"Line":0}},{"line":83,"address":[24744671,24744600],"length":1,"stats":{"Line":0}},{"line":84,"address":[24663128,24663199],"length":1,"stats":{"Line":0}},{"line":85,"address":[12247000,12247045],"length":1,"stats":{"Line":0}},{"line":86,"address":[24744734],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","app","kukuri-tauri","src-tauri","src","state.rs"],"content":"use crate::application::ports::key_manager::{KeyManager, KeyMaterialStore};\r\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::ScoreWeights;\nuse crate::domain::p2p::P2PEvent;\n\r\n// アプリケーションサービスのインポート\r\nuse crate::application::ports::auth_lifecycle::AuthLifecyclePort;\nuse crate::application::ports::cache::PostCache;\nuse crate::application::ports::event_topic_store::EventTopicStore;\nuse crate::application::ports::group_key_store::GroupKeyStore;\nuse crate::application::ports::join_request_store::JoinRequestStore;\nuse crate::application::ports::messaging_gateway::MessagingGateway;\nuse crate::application::ports::offline_store::OfflinePersistence;\nuse crate::application::ports::repositories::{\r\n    BookmarkRepository, DirectMessageRepository, EventRepository, PendingTopicRepository,\r\n    PostRepository, TopicMetricsRepository, TopicRepository, UserRepository,\r\n};\r\nuse crate::application::ports::secure_storage::SecureAccountStore;\r\nuse crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\r\nuse crate::application::services::event_service::EventServiceTrait;\r\nuse crate::application::services::offline_service::OfflineServiceTrait;\r\nuse crate::application::services::p2p_service::P2PServiceTrait;\r\nuse crate::application::services::sync_service::{SyncParticipant, SyncServiceTrait};\r\nuse crate::application::services::{\n    AccessControlService, AuthService, DirectMessageService, EventService, OfflineService,\n    PostService, ProfileAvatarService, SubscriptionStateMachine, SyncService, TopicService,\n    UserSearchService, UserService,\n};\n// プレゼンテーション層のハンドラーのインポート\r\nuse crate::application::services::auth_lifecycle::DefaultAuthLifecycle;\r\nuse crate::infrastructure::{\r\n    cache::PostCacheService,\r\n    crypto::{DefaultKeyManager, DefaultSignatureService, SignatureService},\r\n    database::{\r\n        Repository, SqliteSubscriptionStateRepository, connection_pool::ConnectionPool,\r\n        sqlite_repository::SqliteRepository,\r\n    },\r\n    event::{\r\n        EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\r\n        LegacyEventManagerHandle, RepositoryEventTopicStore,\r\n    },\r\n    jobs::{\r\n        trending_metrics_job::TrendingMetricsJob,\r\n        trending_metrics_metrics::TrendingMetricsRecorder,\r\n        trending_metrics_server::spawn_prometheus_exporter,\r\n    },\r\n    messaging::NostrMessagingGateway,\r\n    offline::{OfflineReindexJob, SqliteOfflinePersistence},\r\n    p2p::{\r\n        GossipService, NetworkService,\r\n        bootstrap::P2PBootstrapper,\r\n        event_distributor::{DefaultEventDistributor, EventDistributor},\r\n    },\r\n    storage::{\n        SecureGroupKeyStore, SecureJoinRequestStore, SecureStorage,\n        secure_storage::DefaultSecureStorage,\n    },\n};\r\nuse crate::presentation::handlers::{\n    CommunityNodeHandler, EventHandler, OfflineHandler, P2PHandler, SecureStorageHandler,\n};\nuse crate::presentation::ipc::direct_message_notifier::IpcDirectMessageNotifier;\r\n\r\nuse nostr_sdk::prelude::{Event as NostrEvent, Kind, TagStandard, ToBech32};\r\nuse std::collections::{HashSet as StdHashSet, VecDeque as StdVecDeque};\r\nuse std::sync::Arc;\r\nuse tauri::{Emitter, async_runtime};\r\nuse tokio::sync::RwLock;\r\nuse tokio::sync::broadcast;\r\nuse tokio::time::{Duration, sleep};\r\n\r\nconst P2P_DEDUP_MAX: usize = 8192;\r\nconst DEFAULT_SYNC_INTERVAL_SECS: u64 = 30;\r\n\r\n/// P2P関連の状態\r\npub struct P2PState {\r\n    /// Message event channel\r\n    pub event_rx: Arc<RwLock<Option<broadcast::Receiver<P2PEvent>>>>,\r\n    /// GossipService 本体（UI購読導線で使用）\r\n    pub gossip_service: Arc<dyn GossipService>,\r\n    /// UI購読済みトピック集合（重複購読防止）\r\n    pub ui_subscribed_topics: Arc<RwLock<std::collections::HashSet<String>>>,\r\n    /// 受信イベントIDの重複排除用セット\r\n    pub seen_event_ids: Arc<RwLock<StdHashSet<String>>>,\r\n    /// 受信イベントIDの順序（容量制御用）\r\n    pub seen_event_order: Arc<RwLock<StdVecDeque<String>>>,\r\n}\r\n\r\n/// アプリケーション全体の状態を管理する構造体\r\n#[derive(Clone)]\r\npub struct AppState {\r\n    pub app_handle: tauri::AppHandle,\r\n    // 既存のマネージャー（Phase5でArc<dyn KeyManager>へ移行済み）\r\n    pub key_manager: Arc<dyn KeyManager>,\r\n    pub event_manager: Arc<dyn EventManagerHandle>,\r\n    pub p2p_state: Arc<RwLock<P2PState>>,\r\n    pub offline_reindex_job: Arc<OfflineReindexJob>,\r\n\r\n    // 新アーキテクチャのサービス層\r\n    pub auth_service: Arc<AuthService>,\r\n    pub post_service: Arc<PostService>,\r\n    pub topic_service: Arc<TopicService>,\r\n    pub user_service: Arc<UserService>,\r\n    pub user_search_service: Arc<UserSearchService>,\r\n    pub event_service: Arc<EventService>,\r\n    pub direct_message_service: Arc<DirectMessageService>,\r\n    pub sync_service: Arc<dyn SyncServiceTrait>,\n    pub p2p_service: Arc<dyn P2PServiceTrait>,\n    pub offline_service: Arc<OfflineService>,\n    pub profile_avatar_service: Arc<ProfileAvatarService>,\n    #[allow(dead_code)]\n    pub group_key_store: Arc<dyn GroupKeyStore>,\n    pub access_control_service: Arc<AccessControlService>,\n\r\n    // プレゼンテーション層のハンドラー（最適化用）\r\n    pub secure_storage_handler: Arc<SecureStorageHandler>,\n    pub event_handler: Arc<EventHandler>,\n    pub p2p_handler: Arc<P2PHandler>,\n    pub offline_handler: Arc<OfflineHandler>,\n    pub community_node_handler: Arc<CommunityNodeHandler>,\n}\n\r\nimpl AppState {\r\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\r\n        let bootstrapper = P2PBootstrapper::new(app_handle).await?;\r\n        let metrics_config = bootstrapper.config().metrics.clone();\r\n        let app_data_dir = bootstrapper.app_data_dir().to_path_buf();\r\n        let profile_avatar_dir = app_data_dir.join(\"profile_avatars\");\r\n\r\n        // Use absolute path for database\r\n        let db_path = app_data_dir.join(\"kukuri.db\");\r\n\r\n        // Debug logging\r\n        tracing::info!(\"Database path: {:?}\", db_path);\r\n\r\n        // Ensure the database file path is canonical\r\n        let db_path_str = db_path\r\n            .to_str()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid database path encoding\"))?;\r\n\r\n        // Format database URL for sqlx\r\n        // On Windows, sqlx may need a specific format\r\n        let db_url = if cfg!(windows) {\r\n            // Try Windows-specific format\r\n            tracing::info!(\"Using Windows database URL format\");\r\n            format!(\"sqlite:{}?mode=rwc\", db_path_str.replace('\\\\', \"/\"))\r\n        } else {\r\n            format!(\"sqlite://{db_path_str}?mode=rwc\")\r\n        };\r\n\r\n        tracing::info!(\"Database URL: {db_url}\");\r\n\r\n        // 新アーキテクチャのリポジトリとサービスを初期化\r\n        let connection_pool = ConnectionPool::new(&db_url).await?;\r\n        let repository = Arc::new(SqliteRepository::new(connection_pool.clone()));\r\n        let topic_metrics_repository: Arc<dyn TopicMetricsRepository> =\r\n            Arc::clone(&repository) as Arc<dyn TopicMetricsRepository>;\r\n        let event_topic_store: Arc<dyn EventTopicStore> = Arc::new(RepositoryEventTopicStore::new(\r\n            Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n        ));\r\n        let subscription_repository: Arc<dyn SubscriptionStateRepository> = Arc::new(\r\n            SqliteSubscriptionStateRepository::new(connection_pool.clone()),\r\n        );\r\n\r\n        // リポジトリのマイグレーションを実行\r\n        repository.initialize().await?;\r\n\r\n        let sqlite_pool = connection_pool.get_pool().clone();\r\n\r\n        let event_manager: Arc<dyn EventManagerHandle> = Arc::new(\r\n            LegacyEventManagerHandle::new_with_connection_pool(connection_pool.clone()),\r\n        );\r\n        let offline_persistence_concrete =\r\n            Arc::new(SqliteOfflinePersistence::new(sqlite_pool.clone()));\r\n        let offline_persistence: Arc<dyn OfflinePersistence> = offline_persistence_concrete.clone();\r\n        let offline_reindex_job =\r\n            OfflineReindexJob::create(Some(app_handle.clone()), Arc::clone(&offline_persistence));\r\n        offline_reindex_job.trigger();\r\n        let offline_service = Arc::new(OfflineService::new(Arc::clone(&offline_persistence)));\r\n\r\n        // インフラストラクチャサービスの初期化\r\n        let secure_storage_impl = Arc::new(DefaultSecureStorage::new());\n        let key_material_store: Arc<dyn KeyMaterialStore> = secure_storage_impl.clone();\n        let key_manager: Arc<dyn KeyManager> = Arc::new(DefaultKeyManager::with_store(Arc::clone(\n            &key_material_store,\n        )));\n        let secure_storage: Arc<dyn SecureStorage> = secure_storage_impl.clone();\n        let secure_account_store: Arc<dyn SecureAccountStore> = secure_storage_impl.clone();\n        let group_key_store: Arc<dyn GroupKeyStore> =\n            Arc::new(SecureGroupKeyStore::new(Arc::clone(&secure_storage)));\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(SecureJoinRequestStore::new(Arc::clone(&secure_storage)));\n        let signature_service: Arc<dyn SignatureService> = Arc::new(DefaultSignatureService::new());\n        let default_event_distributor = Arc::new(DefaultEventDistributor::new());\r\n        let event_distributor: Arc<dyn EventDistributor> =\r\n            default_event_distributor.clone() as Arc<dyn EventDistributor>;\r\n\r\n        // P2Pサービスの初期化\r\n        let (p2p_event_tx, _initial_rx) = broadcast::channel(512);\r\n        let p2p_stack = bootstrapper.build_stack(p2p_event_tx.clone()).await?;\r\n\r\n        let network_service: Arc<dyn NetworkService> = Arc::clone(&p2p_stack.network_service);\n        let gossip_service: Arc<dyn GossipService> = Arc::clone(&p2p_stack.gossip_service);\n        let p2p_service = Arc::clone(&p2p_stack.p2p_service);\n\n        let access_control_service = Arc::new(AccessControlService::new(\n            Arc::clone(&key_manager),\n            Arc::clone(&group_key_store),\n            Arc::clone(&join_request_store),\n            Arc::clone(&repository) as Arc<dyn UserRepository>,\n            Arc::clone(&signature_service),\n            Arc::clone(&gossip_service),\n        ));\n\r\n        default_event_distributor\r\n            .set_gossip_service(Arc::clone(&gossip_service))\r\n            .await;\r\n        default_event_distributor\r\n            .set_network_service(Arc::clone(&network_service))\r\n            .await;\r\n        // EventManagerへGossipServiceを接続（P2P配信経路の直結）\r\n        event_manager\r\n            .set_gossip_service(Arc::clone(&gossip_service))\r\n            .await;\r\n        // EventManagerへEventRepositoryを接続（参照トピック解決用）\r\n        event_manager\r\n            .set_event_topic_store(Arc::clone(&event_topic_store))\r\n            .await;\r\n\r\n        // UserServiceを先に初期化（他のサービスの依存）\r\n        let user_service = Arc::new(UserService::new(\r\n            Arc::clone(&repository) as Arc<dyn UserRepository>\r\n        ));\r\n        let user_search_service = Arc::new(UserSearchService::new(\r\n            Arc::clone(&repository) as Arc<dyn UserRepository>\r\n        ));\r\n\r\n        // TopicServiceを初期化（AuthServiceの依存）\r\n        let topic_service = Arc::new(TopicService::new(\r\n            Arc::clone(&repository) as Arc<dyn TopicRepository>,\r\n            Arc::clone(&repository) as Arc<dyn PendingTopicRepository>,\r\n            Arc::clone(&topic_metrics_repository),\r\n            metrics_config.enabled,\r\n            Arc::clone(&p2p_service),\r\n            Arc::clone(&offline_service) as Arc<dyn OfflineServiceTrait>,\r\n        ));\r\n        // 既定トピック（public）を保証し、EventManagerの既定配信先に設定\n        topic_service\n            .ensure_public_topic()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to ensure public topic: {}\", e))?;\n        event_manager\n            .set_default_p2p_topic_id(DEFAULT_PUBLIC_TOPIC_ID)\n            .await;\n        let distributor_default_topics = event_manager.list_default_p2p_topics().await;\r\n        default_event_distributor\r\n            .set_default_topics(distributor_default_topics)\r\n            .await;\r\n\r\n        if metrics_config.enabled {\r\n            let score_weights = ScoreWeights {\r\n                posts: metrics_config.score_weights.posts,\r\n                unique_authors: metrics_config.score_weights.unique_authors,\r\n                boosts: metrics_config.score_weights.boosts,\r\n            };\r\n\r\n            let metrics_recorder = TrendingMetricsRecorder::new(metrics_config.emit_histogram)\r\n                .map(Arc::new)\r\n                .map_err(|err| anyhow::anyhow!(\"Failed to initialize metrics recorder: {err}\"))?;\r\n\r\n            if let Some(port) = metrics_config.prometheus_port {\r\n                spawn_prometheus_exporter(port, Arc::clone(&metrics_recorder));\r\n            }\r\n\r\n            let job = Arc::new(TrendingMetricsJob::new(\r\n                Arc::clone(&topic_metrics_repository),\r\n                Some(score_weights),\r\n                metrics_config.ttl_hours,\r\n                Some(Arc::clone(&metrics_recorder)),\r\n            ));\r\n            spawn_trending_metrics_job(\r\n                job,\r\n                Duration::from_secs(metrics_config.interval_minutes.max(1) * 60),\r\n            );\r\n        }\r\n\r\n        // AuthServiceの初期化（UserServiceとTopicServiceが必要）\r\n        let lifecycle_port: Arc<dyn AuthLifecyclePort> = Arc::new(DefaultAuthLifecycle::new(\r\n            Arc::clone(&user_service),\r\n            Arc::clone(&topic_service),\r\n        ));\r\n\r\n        let auth_service = Arc::new(AuthService::new(\r\n            Arc::clone(&key_manager),\r\n            Arc::clone(&secure_storage),\r\n            lifecycle_port,\r\n        ));\r\n\r\n        let subscription_state = Arc::new(SubscriptionStateMachine::new(Arc::clone(\r\n            &subscription_repository,\r\n        )));\r\n\r\n        // EventServiceの初期化\r\n        let legacy_event_gateway =\r\n            Arc::new(LegacyEventManagerGateway::new(Arc::clone(&event_manager)));\r\n        let event_gateway: Arc<dyn crate::application::ports::event_gateway::EventGateway> =\r\n            legacy_event_gateway.clone();\r\n        let mut event_service_inner = EventService::new(\r\n            Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n            Arc::clone(&signature_service),\r\n            Arc::clone(&event_distributor),\r\n            event_gateway,\r\n            Arc::clone(&subscription_state)\r\n                as Arc<dyn crate::application::services::SubscriptionStateStore>,\r\n        );\r\n        event_service_inner.set_subscription_invoker(Arc::new(\r\n            EventManagerSubscriptionInvoker::new(Arc::clone(&event_manager)),\r\n        ));\r\n        legacy_event_gateway\r\n            .set_app_handle(app_handle.clone())\r\n            .await;\r\n        let event_service = Arc::new(event_service_inner);\r\n\r\n        let messaging_gateway: Arc<dyn MessagingGateway> = Arc::new(NostrMessagingGateway::new(\r\n            Arc::clone(&key_manager),\r\n            Arc::clone(&event_manager),\r\n        ));\r\n\r\n        let direct_message_service = Arc::new(DirectMessageService::new(\r\n            Arc::clone(&repository) as Arc<dyn DirectMessageRepository>,\r\n            Arc::clone(&messaging_gateway),\r\n            Some(Arc::new(IpcDirectMessageNotifier::new(app_handle))),\r\n        ));\r\n\r\n        {\r\n            let event_manager_for_dm = Arc::clone(&event_manager);\r\n            let key_manager_for_dm = Arc::clone(&key_manager);\r\n            let direct_message_service_for_dm = Arc::clone(&direct_message_service);\r\n\r\n            event_manager_for_dm\r\n                .register_event_callback(Arc::new(move |event: NostrEvent| {\r\n                    if event.kind != Kind::EncryptedDirectMessage {\r\n                        return;\r\n                    }\r\n\r\n                    let recipient_pubkey =\r\n                        event\r\n                            .tags\r\n                            .iter()\r\n                            .find_map(|tag| match tag.as_standardized() {\r\n                                Some(TagStandard::PublicKey { public_key, .. }) => Some(public_key),\r\n                                _ => None,\r\n                            });\r\n\r\n                    let Some(recipient_pubkey) = recipient_pubkey else {\r\n                        return;\r\n                    };\r\n\r\n                    let recipient_hex = recipient_pubkey.to_string();\r\n                    let key_manager = Arc::clone(&key_manager_for_dm);\r\n                    let dm_service = Arc::clone(&direct_message_service_for_dm);\r\n                    let event_clone = event.clone();\r\n\r\n                    async_runtime::spawn(async move {\r\n                        let keypair = match key_manager.current_keypair().await {\r\n                            Ok(pair) => pair,\r\n                            Err(err) => {\r\n                                tracing::error!(\r\n                                    error = %err,\r\n                                    \"Failed to load current keypair for direct message ingestion\"\r\n                                );\r\n                                return;\r\n                            }\r\n                        };\r\n\r\n                        if keypair.public_key != recipient_hex {\r\n                            return;\r\n                        }\r\n\r\n                        let sender_npub = match event_clone.pubkey.to_bech32() {\r\n                            Ok(value) => value,\r\n                            Err(err) => {\r\n                                tracing::error!(\r\n                                    error = %err,\r\n                                    \"Failed to convert sender pubkey to npub for direct message\"\r\n                                );\r\n                                return;\r\n                            }\r\n                        };\r\n\r\n                        let created_at_millis =\n                            (event_clone.created_at.as_secs() as i64).saturating_mul(1000);\n                        if let Err(err) = dm_service\r\n                            .ingest_incoming_message(\r\n                                &keypair.npub,\r\n                                &sender_npub,\r\n                                &event_clone.content,\r\n                                Some(event_clone.id.to_string()),\r\n                                created_at_millis,\r\n                            )\r\n                            .await\r\n                        {\r\n                            tracing::error!(\r\n                                error = %err,\r\n                                sender = sender_npub,\r\n                                owner = keypair.npub,\r\n                                \"Failed to ingest incoming direct message\"\r\n                            );\r\n                        }\r\n                    });\r\n                }))\r\n                .await;\r\n        }\r\n\r\n        let post_cache: Arc<dyn PostCache> = Arc::new(PostCacheService::new());\r\n        // PostServiceの初期化\r\n        let post_service = Arc::new(PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            Arc::clone(&event_service) as Arc<dyn EventServiceTrait>,\n            Arc::clone(&post_cache),\n            Arc::clone(&group_key_store),\n        ));\n\r\n        let post_sync_participant: Arc<dyn SyncParticipant> = post_service.clone();\r\n        let event_sync_participant: Arc<dyn SyncParticipant> = event_service.clone();\r\n\r\n        let sync_service: Arc<dyn SyncServiceTrait> = Arc::new(SyncService::new(\r\n            Arc::clone(&network_service),\r\n            post_sync_participant,\r\n            event_sync_participant,\r\n        ));\r\n\r\n        let profile_avatar_service = Arc::new(\r\n            ProfileAvatarService::new(profile_avatar_dir.clone())\r\n                .await\r\n                .map_err(|e| anyhow::anyhow!(\"Failed to initialize profile avatar service: {e}\"))?,\r\n        );\r\n\r\n        // プレゼンテーション層のハンドラーを初期化\r\n        let secure_storage_handler = Arc::new(SecureStorageHandler::new(\n            Arc::clone(&auth_service),\r\n            Arc::clone(&secure_account_store),\r\n        ));\r\n        let event_handler = Arc::new(EventHandler::new(\n            Arc::clone(&event_service)\n                as Arc<dyn crate::application::services::event_service::EventServiceTrait>,\n            Arc::clone(&key_manager),\n            Arc::clone(&event_manager),\n        ));\n        let p2p_handler = Arc::new(P2PHandler::new(Arc::clone(&p2p_service)));\n        let offline_handler = Arc::new(OfflineHandler::new(Arc::clone(&offline_service)\n            as Arc<dyn crate::application::services::offline_service::OfflineServiceTrait>));\n        let community_node_handler = Arc::new(CommunityNodeHandler::new(\n            Arc::clone(&key_manager),\n            Arc::clone(&secure_storage),\n            Arc::clone(&group_key_store),\n        ));\n\r\n        // P2P接続イベントを監視し、再接続時に再索引ジョブをトリガー\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let job = Arc::clone(&offline_reindex_job);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    if matches!(event, P2PEvent::NetworkConnected { .. }) {\r\n                        job.trigger();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let event_service_clone = Arc::clone(&event_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    match event {\r\n                        P2PEvent::NetworkDisconnected { .. } => {\r\n                            if let Err(e) = event_service_clone.handle_network_disconnected().await\r\n                            {\r\n                                tracing::warn!(\"Failed to mark subscriptions for resync: {}\", e);\r\n                            }\r\n                        }\r\n                        P2PEvent::NetworkConnected { .. } => {\r\n                            if let Err(e) = event_service_clone.handle_network_connected().await {\r\n                                tracing::warn!(\r\n                                    \"Failed to restore subscriptions after reconnect: {}\",\r\n                                    e\r\n                                );\r\n                            }\r\n                        }\r\n                        _ => {}\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // UI向けイベント購読を確保\r\n        let p2p_event_rx = p2p_event_tx.subscribe();\r\n\r\n        // P2P状態の初期化\r\n        let p2p_state = Arc::new(RwLock::new(P2PState {\r\n            event_rx: Arc::new(RwLock::new(Some(p2p_event_rx))),\r\n            gossip_service: Arc::clone(&gossip_service),\r\n            ui_subscribed_topics: Arc::new(RwLock::new(Default::default())),\r\n            seen_event_ids: Arc::new(RwLock::new(Default::default())),\r\n            seen_event_order: Arc::new(RwLock::new(Default::default())),\r\n        }));\r\n\r\n        // 既定トピック`public`に対するUI購読を張る（冪等）\r\n        // TopicService.ensure_public_topic でjoinは保証済\r\n        let this_handle = app_handle.clone();\r\n        let this = Self {\r\n            app_handle: this_handle,\r\n            key_manager,\r\n            event_manager,\r\n            p2p_state,\r\n            offline_reindex_job,\r\n            auth_service,\r\n            post_service,\r\n            topic_service,\r\n            user_service,\r\n            user_search_service,\r\n            event_service,\r\n            direct_message_service,\n            sync_service,\n            p2p_service,\n            offline_service,\n            profile_avatar_service,\n            group_key_store,\n            access_control_service,\n            secure_storage_handler,\n            event_handler,\n            p2p_handler,\n            offline_handler,\n            community_node_handler,\n        };\n\r\n        // SyncService の定期実行と P2P 接続状態フックをセットアップ\r\n        {\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                if let Err(err) = sync_service.start_sync().await {\r\n                    tracing::warn!(error = %err, \"initial sync run failed\");\r\n                }\r\n            });\r\n        }\r\n\r\n        {\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                sync_service.schedule_sync(DEFAULT_SYNC_INTERVAL_SECS).await;\r\n            });\r\n        }\r\n\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    match event {\r\n                        P2PEvent::NetworkConnected { .. } => {\r\n                            if let Err(err) = sync_service.start_sync().await {\r\n                                tracing::warn!(\r\n                                    error = %err,\r\n                                    \"failed to trigger sync after network connect\"\r\n                                );\r\n                            }\r\n                        }\r\n                        P2PEvent::NetworkDisconnected { .. } => {\r\n                            if let Err(err) = sync_service.stop_sync().await {\r\n                                tracing::warn!(\r\n                                    error = %err,\r\n                                    \"failed to stop sync after network disconnect\"\r\n                                );\r\n                            }\r\n                        }\r\n                        _ => {}\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // 起動時に既定＋ユーザー固有トピックの購読を確立\r\n        {\r\n            let this_clone = this.clone();\r\n            tauri::async_runtime::spawn(async move {\r\n                if let Err(e) = this_clone.ensure_default_and_user_subscriptions().await {\r\n                    tracing::warn!(\"Failed to ensure default/user subscriptions: {}\", e);\r\n                }\r\n            });\r\n        }\r\n\r\n        Ok(this)\r\n    }\r\n\r\n    /// P2P機能を初期化\r\n    pub async fn initialize_p2p(&self) -> anyhow::Result<()> {\r\n        // 旧GossipManager経路は無効化。IrohGossipService経由で運用。\r\n        // 互換のため成功扱いで何もしない。\r\n        Ok(())\r\n    }\r\n\r\n    // Event loop for P2P messages is now handled via UI emitter in lib.rs using event_rx\r\n\r\n    /// UI向けに指定トピックの購読を確立（冪等）\r\n    pub async fn ensure_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\r\n        // 重複購読チェック\r\n        {\r\n            let p2p_state = self.p2p_state.read().await;\r\n            let subs = p2p_state.ui_subscribed_topics.read().await;\r\n            if subs.contains(topic_id) {\r\n                return Ok(());\r\n            }\r\n        }\r\n\r\n        // 購読開始（joinはTopicService側で行われるが、冪等joinは吸収される）\r\n        let (\n            gossip,\n            event_manager,\n            access_control,\n            community_node_handler,\n            p2p_state_arc,\n            app_handle,\n            topic,\n        ) = {\n            let p2p_state = self.p2p_state.read().await;\n            (\n                Arc::clone(&p2p_state.gossip_service),\n                Arc::clone(&self.event_manager),\n                Arc::clone(&self.access_control_service),\n                Arc::clone(&self.community_node_handler),\n                Arc::clone(&self.p2p_state),\n                self.app_handle.clone(),\n                topic_id.to_string(),\n            )\n        };\n\r\n        // 先にフラグを立てる（競合回避）\r\n        {\r\n            let ui_arc = {\r\n                let p2p = p2p_state_arc.read().await;\r\n                Arc::clone(&p2p.ui_subscribed_topics)\r\n            };\r\n            let mut subs = ui_arc.write().await;\r\n            subs.insert(topic.clone());\r\n        }\r\n\r\n        tauri::async_runtime::spawn(async move {\r\n            match gossip.subscribe(&topic).await {\r\n                Ok(mut rx) => {\r\n                    tracing::info!(\"UI subscribed to topic {}\", topic);\r\n                    while let Some(evt) = rx.recv().await {\r\n                        // 重複排除（イベントID）\r\n                        let evt_id = evt.id.clone();\r\n                        let (set_arc, order_arc) = {\r\n                            let p2p = p2p_state_arc.read().await;\r\n                            (\r\n                                Arc::clone(&p2p.seen_event_ids),\r\n                                Arc::clone(&p2p.seen_event_order),\r\n                            )\r\n                        };\r\n                        {\r\n                            let mut set = set_arc.write().await;\r\n                            if set.contains(&evt_id) {\r\n                                continue;\r\n                            }\r\n                            set.insert(evt_id.clone());\r\n                        }\r\n                        {\r\n                            let mut order = order_arc.write().await;\r\n                            order.push_back(evt_id.clone());\r\n                            if order.len() > P2P_DEDUP_MAX {\r\n                                if let Some(old_id) = order.pop_front() {\r\n                                    let mut set = set_arc.write().await;\r\n                                    set.remove(&old_id);\r\n                                }\r\n                            }\r\n                        }\r\n                        // 受信: domain::entities::Event\r\n                        // UIへemit（p2p://message）\r\n                        #[derive(serde::Serialize, Clone)]\r\n                        struct UiMsg {\r\n                            id: String,\r\n                            author: String,\r\n                            content: String,\r\n                            timestamp: i64,\r\n                            signature: String,\r\n                        }\r\n                        #[derive(serde::Serialize, Clone)]\r\n                        struct UiP2PMessageEvent {\r\n                            topic_id: String,\r\n                            message: UiMsg,\r\n                        }\r\n\r\n                        let payload = UiP2PMessageEvent {\r\n                            topic_id: topic.clone(),\r\n                            message: UiMsg {\r\n                                id: evt.id.clone(),\r\n                                author: evt.pubkey.clone(),\r\n                                content: evt.content.clone(),\r\n                                timestamp: evt.created_at.timestamp_millis(),\r\n                                signature: evt.sig.clone(),\r\n                            },\r\n                        };\r\n                        if let Err(e) = app_handle.emit(\"p2p://message\", payload) {\n                            tracing::error!(\"Failed to emit UI P2P message: {}\", e);\n                        }\n\n                        if matches!(evt.kind, 39020 | 39022) {\n                            let access_control = Arc::clone(&access_control);\n                            let event_clone = evt.clone();\n                            tauri::async_runtime::spawn(async move {\n                                if let Err(err) =\n                                    access_control.handle_incoming_event(&event_clone).await\n                                {\n                                    tracing::warn!(\n                                        error = %err,\n                                        kind = event_clone.kind,\n                                        \"access control event handling failed\"\n                                    );\n                                }\n                            });\n                        }\n\n                        if matches!(evt.kind, 39000 | 39001) {\n                            let handler = Arc::clone(&community_node_handler);\n                            let event_clone = evt.clone();\n                            tauri::async_runtime::spawn(async move {\n                                if let Err(err) = handler.ingest_bootstrap_event(&event_clone).await\n                                {\n                                    tracing::warn!(\n                                        error = %err,\n                                        kind = event_clone.kind,\n                                        \"bootstrap gossip event ingestion failed\"\n                                    );\n                                }\n                            });\n                        }\n\n                        // 既存Nostr系導線へも流す（必要に応じて）\n                        // domain::Event -> NostrEventPayload 相当はEventManager内にあるが、\n                        // ここではDB保存・加工は後段で検討するためスキップ\n                        let _ = event_manager; // 未来の拡張用プレースホルダ\n                    }\r\n                    // チャネルクローズ時、購読フラグを解除\r\n                    let ui_arc = {\r\n                        let p2p = p2p_state_arc.read().await;\r\n                        Arc::clone(&p2p.ui_subscribed_topics)\r\n                    };\r\n                    let mut subs = ui_arc.write().await;\r\n                    subs.remove(&topic);\r\n                    tracing::info!(\"UI subscription ended for topic {}\", topic);\r\n                }\r\n                Err(e) => {\r\n                    tracing::error!(\"Failed to subscribe to topic {}: {}\", topic, e);\r\n                    let ui_arc = {\r\n                        let p2p = p2p_state_arc.read().await;\r\n                        Arc::clone(&p2p.ui_subscribed_topics)\r\n                    };\r\n                    let mut subs = ui_arc.write().await;\r\n                    subs.remove(&topic);\r\n                }\r\n            }\r\n        });\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 既定トピックとユーザー固有トピックの購読を確立（冪等）\r\n    pub async fn ensure_default_and_user_subscriptions(&self) -> anyhow::Result<()> {\n        let mut topics = self.event_manager.list_default_p2p_topics().await;\n        if let Ok(keypair) = self.key_manager.current_keypair().await {\n            topics.push(crate::domain::p2p::user_topic_id(&keypair.public_key));\n        }\n        for t in topics {\n            if let Err(e) = self.ensure_ui_subscription(&t).await {\n                tracing::warn!(\"Failed to ensure subscription for {}: {}\", t, e);\n            }\n        }\n        Ok(())\r\n    }\r\n\r\n    /// UI向け購読を停止（存在しなければ何もしない）\r\n    pub async fn stop_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\r\n        // フラグのみ除去（購読タスクはチャネルクローズにより自然終了）\r\n        let ui_subs_arc = {\r\n            let p2p_state = self.p2p_state.read().await;\r\n            Arc::clone(&p2p_state.ui_subscribed_topics)\r\n        };\r\n        let mut subs = ui_subs_arc.write().await;\r\n        subs.remove(topic_id);\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn spawn_trending_metrics_job(job: Arc<TrendingMetricsJob>, interval: Duration) {\r\n    tracing::info!(\r\n        target: \"metrics::trending\",\r\n        interval_seconds = interval.as_secs(),\r\n        \"starting trending metrics job loop\"\r\n    );\r\n    async_runtime::spawn(async move {\r\n        loop {\r\n            if let Err(err) = job.run_once().await {\r\n                tracing::error!(\r\n                    target: \"metrics::trending\",\r\n                    error = %err,\r\n                    \"trending metrics job run failed\"\r\n                );\r\n            }\r\n            sleep(interval).await;\r\n        }\r\n    });\r\n}\r\n","traces":[{"line":123,"address":[89554522,89556890,89555338,89556074,89557003,89554659,89555396,89556199,89557701,89557764],"length":1,"stats":{"Line":0}},{"line":124,"address":[19970967,19964752,19965933,19964784,19964760,19965596,19966077,19964871],"length":1,"stats":{"Line":0}},{"line":125,"address":[19769940],"length":1,"stats":{"Line":0}},{"line":126,"address":[19870060,19870184],"length":1,"stats":{"Line":0}},{"line":127,"address":[19760354],"length":1,"stats":{"Line":0}},{"line":128,"address":[14008056,14007951],"length":1,"stats":{"Line":0}},{"line":131,"address":[89837415,89839783,89839187,89836843,89837580,89837567,89839174,89839935,89839022,89838370,89839948,89838218,89836830,89838383,89836678],"length":1,"stats":{"Line":0}},{"line":134,"address":[19828527,19987033,19829133,19987167,19828613],"length":1,"stats":{"Line":0}},{"line":137,"address":[13004135,13002208,13000865,13001998],"length":1,"stats":{"Line":0}},{"line":139,"address":[19906624,19874120,19906628],"length":1,"stats":{"Line":0}},{"line":145,"address":[20126143,20126009],"length":1,"stats":{"Line":0}},{"line":148,"address":[19868502,19868581],"length":1,"stats":{"Line":0}},{"line":151,"address":[19872624,19872710,20030073,19873230,20030207],"length":1,"stats":{"Line":0}},{"line":154,"address":[12008750],"length":1,"stats":{"Line":0}},{"line":155,"address":[19765032,19765209],"length":1,"stats":{"Line":0}},{"line":156,"address":[19758512,19758605],"length":1,"stats":{"Line":0}},{"line":158,"address":[13005019],"length":1,"stats":{"Line":0}},{"line":159,"address":[19876922],"length":1,"stats":{"Line":0}},{"line":162,"address":[89841246,89841702,89841774,89840718,89840118,89841174,89840190,89840646],"length":1,"stats":{"Line":0}},{"line":166,"address":[14006900,14013575,14013309,14013402,14013902,14017116],"length":1,"stats":{"Line":0}},{"line":168,"address":[19972763,19972636],"length":1,"stats":{"Line":0}},{"line":171,"address":[89558567,89559095,89560104,89559576,89560151,89558520,89559623,89559048],"length":1,"stats":{"Line":0}},{"line":173,"address":[19876593,19876683],"length":1,"stats":{"Line":0}},{"line":175,"address":[19876863,19876770],"length":1,"stats":{"Line":0}},{"line":176,"address":[19767036,19769523],"length":1,"stats":{"Line":0}},{"line":178,"address":[19835149],"length":1,"stats":{"Line":0}},{"line":179,"address":[19767512,19767415],"length":1,"stats":{"Line":0}},{"line":182,"address":[19879134,19879193],"length":1,"stats":{"Line":0}},{"line":183,"address":[19842578,19842485],"length":1,"stats":{"Line":0}},{"line":184,"address":[14015515,14015406],"length":1,"stats":{"Line":0}},{"line":185,"address":[14015391],"length":1,"stats":{"Line":0}},{"line":187,"address":[19974471,19974381],"length":1,"stats":{"Line":0}},{"line":188,"address":[13007645,13007560],"length":1,"stats":{"Line":0}},{"line":189,"address":[19879838,19879962],"length":1,"stats":{"Line":0}},{"line":191,"address":[14016198,14016092],"length":1,"stats":{"Line":0}},{"line":193,"address":[19880281,19880343],"length":1,"stats":{"Line":0}},{"line":194,"address":[19768895,19768965],"length":1,"stats":{"Line":0}},{"line":195,"address":[19762249,19762342],"length":1,"stats":{"Line":0}},{"line":199,"address":[19975443,19975525],"length":1,"stats":{"Line":0}},{"line":200,"address":[11539286],"length":1,"stats":{"Line":0}},{"line":202,"address":[19881519,19881673],"length":1,"stats":{"Line":0}},{"line":203,"address":[19770300,19770191],"length":1,"stats":{"Line":0}},{"line":204,"address":[19777298,19777447],"length":1,"stats":{"Line":0}},{"line":206,"address":[19778421,19778549,19778212],"length":1,"stats":{"Line":0}},{"line":207,"address":[19838394,19838301],"length":1,"stats":{"Line":0}},{"line":208,"address":[19845456,19845346],"length":1,"stats":{"Line":0}},{"line":209,"address":[13009928,13010030],"length":1,"stats":{"Line":0}},{"line":210,"address":[19977260,19977166],"length":1,"stats":{"Line":0}},{"line":211,"address":[13010171,13010273],"length":1,"stats":{"Line":0}},{"line":212,"address":[19838945],"length":1,"stats":{"Line":0}},{"line":215,"address":[19778567,19778761,19778715],"length":1,"stats":{"Line":0}},{"line":216,"address":[19877593],"length":1,"stats":{"Line":0}},{"line":217,"address":[19877738,19878208,19877678,19865342],"length":1,"stats":{"Line":0}},{"line":218,"address":[19840297,19840397,19840443],"length":1,"stats":{"Line":0}},{"line":219,"address":[19765739],"length":1,"stats":{"Line":0}},{"line":220,"address":[19865363,19878588,19878528],"length":1,"stats":{"Line":0}},{"line":222,"address":[13011939,13012162,13012079],"length":1,"stats":{"Line":0}},{"line":223,"address":[19878897],"length":1,"stats":{"Line":0}},{"line":224,"address":[14020676,14006984,14020611],"length":1,"stats":{"Line":0}},{"line":226,"address":[19766755,19766838,19766607],"length":1,"stats":{"Line":0}},{"line":227,"address":[19841273],"length":1,"stats":{"Line":0}},{"line":228,"address":[12008906],"length":1,"stats":{"Line":0}},{"line":231,"address":[19841771],"length":1,"stats":{"Line":0}},{"line":232,"address":[19841687],"length":1,"stats":{"Line":0}},{"line":234,"address":[19781169],"length":1,"stats":{"Line":0}},{"line":235,"address":[14021608],"length":1,"stats":{"Line":0}},{"line":239,"address":[19884738],"length":1,"stats":{"Line":0}},{"line":240,"address":[19842110,19842215],"length":1,"stats":{"Line":0}},{"line":241,"address":[13013422,13013500],"length":1,"stats":{"Line":0}},{"line":242,"address":[19781617,19781515],"length":1,"stats":{"Line":0}},{"line":243,"address":[19884513],"length":1,"stats":{"Line":0}},{"line":244,"address":[13013654,13013740],"length":1,"stats":{"Line":0}},{"line":245,"address":[13013756],"length":1,"stats":{"Line":0}},{"line":248,"address":[19776012,19775089,19775529,19775816,19775179,19775225,19775659],"length":1,"stats":{"Line":0}},{"line":250,"address":[12107876],"length":1,"stats":{"Line":0}},{"line":251,"address":[19802175,19782776,19802160],"length":1,"stats":{"Line":0}},{"line":252,"address":[13014745,13014840,13014650],"length":1,"stats":{"Line":0}},{"line":254,"address":[19770174],"length":1,"stats":{"Line":0}},{"line":255,"address":[11539452],"length":1,"stats":{"Line":0}},{"line":256,"address":[13015621,13015770,13015800],"length":1,"stats":{"Line":0}},{"line":257,"address":[19844663],"length":1,"stats":{"Line":0}},{"line":258,"address":[14007089,14024509,14024449],"length":1,"stats":{"Line":0}},{"line":260,"address":[19883144],"length":1,"stats":{"Line":0}},{"line":262,"address":[19883198],"length":1,"stats":{"Line":0}},{"line":263,"address":[19852030],"length":1,"stats":{"Line":0}},{"line":264,"address":[19845110],"length":1,"stats":{"Line":0}},{"line":267,"address":[19777337,19777585,19780939],"length":1,"stats":{"Line":0}},{"line":269,"address":[19863231,19863216,19845377],"length":1,"stats":{"Line":0}},{"line":271,"address":[19883466,19883534],"length":1,"stats":{"Line":0}},{"line":272,"address":[19777645,19777774],"length":1,"stats":{"Line":0}},{"line":275,"address":[19984309,19984376],"length":1,"stats":{"Line":0}},{"line":276,"address":[19845480,19845646],"length":1,"stats":{"Line":0}},{"line":277,"address":[19845670],"length":1,"stats":{"Line":0}},{"line":278,"address":[19777906],"length":1,"stats":{"Line":0}},{"line":279,"address":[19852749,19852665],"length":1,"stats":{"Line":0}},{"line":282,"address":[117244341,117248046],"length":1,"stats":{"Line":0}},{"line":283,"address":[19884067,19884155],"length":1,"stats":{"Line":0}},{"line":288,"address":[19890024,19890067,19890144],"length":1,"stats":{"Line":0}},{"line":289,"address":[19777241,19778421],"length":1,"stats":{"Line":0}},{"line":290,"address":[19889941],"length":1,"stats":{"Line":0}},{"line":293,"address":[19885030,19884902,19884845],"length":1,"stats":{"Line":0}},{"line":294,"address":[19778678,19778771],"length":1,"stats":{"Line":0}},{"line":295,"address":[19846603],"length":1,"stats":{"Line":0}},{"line":296,"address":[76113603,76117194,76117264],"length":1,"stats":{"Line":0}},{"line":299,"address":[19885154,19885063],"length":1,"stats":{"Line":0}},{"line":300,"address":[13017868],"length":1,"stats":{"Line":0}},{"line":304,"address":[19985625,19985734],"length":1,"stats":{"Line":0}},{"line":306,"address":[19779641,19779533],"length":1,"stats":{"Line":0}},{"line":309,"address":[116500940,116497248],"length":1,"stats":{"Line":0}},{"line":310,"address":[19773125,19773023],"length":1,"stats":{"Line":0}},{"line":311,"address":[116493098,116496772],"length":1,"stats":{"Line":0}},{"line":312,"address":[119649793,119653467],"length":1,"stats":{"Line":0}},{"line":313,"address":[19891594],"length":1,"stats":{"Line":0}},{"line":314,"address":[119653513,119649839],"length":1,"stats":{"Line":0}},{"line":316,"address":[19986764,19986598],"length":1,"stats":{"Line":0}},{"line":317,"address":[19886255,19886353],"length":1,"stats":{"Line":0}},{"line":319,"address":[19986893,19986947,19986817],"length":1,"stats":{"Line":0}},{"line":320,"address":[19886483],"length":1,"stats":{"Line":0}},{"line":321,"address":[19773848,19773908,19774177,19752806],"length":1,"stats":{"Line":0}},{"line":322,"address":[19891238,19891018],"length":1,"stats":{"Line":0}},{"line":324,"address":[19887587,19887670,19887536],"length":1,"stats":{"Line":0}},{"line":325,"address":[19887413,19887320],"length":1,"stats":{"Line":0}},{"line":326,"address":[19887437],"length":1,"stats":{"Line":0}},{"line":329,"address":[19856887,19856992,19857123],"length":1,"stats":{"Line":0}},{"line":330,"address":[19988067,19988144],"length":1,"stats":{"Line":0}},{"line":331,"address":[19891850,19891743],"length":1,"stats":{"Line":0}},{"line":332,"address":[14029613,14029538],"length":1,"stats":{"Line":0}},{"line":336,"address":[19988693,19988824],"length":1,"stats":{"Line":0}},{"line":337,"address":[117050025,117046103,117046289,117049842],"length":1,"stats":{"Line":0}},{"line":338,"address":[19988986,19989091],"length":1,"stats":{"Line":0}},{"line":340,"address":[19893026,19892682,19892933],"length":1,"stats":{"Line":0}},{"line":341,"address":[19906392,19892804,19906464,19905472],"length":1,"stats":{"Line":0}},{"line":342,"address":[116669862,116673598],"length":1,"stats":{"Line":0}},{"line":347,"address":[19802782,19802739],"length":1,"stats":{"Line":0}},{"line":350,"address":[19789840,19789867],"length":1,"stats":{"Line":0}},{"line":351,"address":[19796738],"length":1,"stats":{"Line":0}},{"line":352,"address":[19803703],"length":1,"stats":{"Line":0}},{"line":355,"address":[20002135],"length":1,"stats":{"Line":0}},{"line":359,"address":[20002174],"length":1,"stats":{"Line":0}},{"line":360,"address":[19789131,19789208],"length":1,"stats":{"Line":0}},{"line":361,"address":[19796016,19796084],"length":1,"stats":{"Line":0}},{"line":362,"address":[116497958,116494208],"length":1,"stats":{"Line":0}},{"line":364,"address":[19789663,19790000,19789369,19793852,19790150,19793942,19790046,19790417],"length":1,"stats":{"Line":0}},{"line":365,"address":[19902982,19902884,19903153,19902815],"length":1,"stats":{"Line":0}},{"line":366,"address":[19909059],"length":1,"stats":{"Line":0}},{"line":367,"address":[14045308],"length":1,"stats":{"Line":0}},{"line":368,"address":[14168367,14168233,14046290,14045356,14046791],"length":1,"stats":{"Line":0}},{"line":376,"address":[117111190,117107440],"length":1,"stats":{"Line":0}},{"line":380,"address":[14045451],"length":1,"stats":{"Line":0}},{"line":381,"address":[119649703,119653403,119653283,119654560,119654710,119650283,119649874,119650960,119653903,119654801,119649746,119653548,119650827,119649660,119654005,119653205,119651028,119650198,119649614,119653343],"length":1,"stats":{"Line":0}},{"line":383,"address":[13336015,13335881],"length":1,"stats":{"Line":0}},{"line":391,"address":[117105789,117111051,117109494,117111126,117109610,117107312,117105913],"length":1,"stats":{"Line":0}},{"line":392,"address":[19805131,19805037],"length":1,"stats":{"Line":0}},{"line":393,"address":[19910127,19910055,19912514,19909690,19914725,19912412],"length":1,"stats":{"Line":0}},{"line":394,"address":[76120584],"length":1,"stats":{"Line":0}},{"line":395,"address":[19872953],"length":1,"stats":{"Line":0}},{"line":396,"address":[14045807],"length":1,"stats":{"Line":0}},{"line":397,"address":[19866165],"length":1,"stats":{"Line":0}},{"line":398,"address":[19798424],"length":1,"stats":{"Line":0}},{"line":401,"address":[11580429],"length":1,"stats":{"Line":0}},{"line":403,"address":[19907013,19907114,19907615,20027625,20027759],"length":1,"stats":{"Line":0}},{"line":412,"address":[19776343,19776408,19752827,19776531],"length":1,"stats":{"Line":0}},{"line":415,"address":[19889492],"length":1,"stats":{"Line":0}},{"line":417,"address":[19791391,19791222,19791522],"length":1,"stats":{"Line":0}},{"line":418,"address":[13022148,13022221],"length":1,"stats":{"Line":0}},{"line":419,"address":[19783857,19783763],"length":1,"stats":{"Line":0}},{"line":420,"address":[76121264,76120752],"length":1,"stats":{"Line":0}},{"line":421,"address":[13022486,13022588],"length":1,"stats":{"Line":0}},{"line":422,"address":[19895651],"length":1,"stats":{"Line":0}},{"line":425,"address":[117053014,117052502],"length":1,"stats":{"Line":0}},{"line":426,"address":[19890732,19890627],"length":1,"stats":{"Line":0}},{"line":428,"address":[117053044,117052532],"length":1,"stats":{"Line":0}},{"line":429,"address":[117251838,117252350],"length":1,"stats":{"Line":0}},{"line":430,"address":[19991259],"length":1,"stats":{"Line":0}},{"line":431,"address":[116500178,116500690],"length":1,"stats":{"Line":0}},{"line":435,"address":[14032657,14033329,14033413,14032797,14033583,14032743],"length":1,"stats":{"Line":0}},{"line":436,"address":[12208400],"length":1,"stats":{"Line":0}},{"line":437,"address":[19796783,19779263,19796768],"length":1,"stats":{"Line":0}},{"line":441,"address":[117157310,117157822],"length":1,"stats":{"Line":0}},{"line":442,"address":[119657093,119657605],"length":1,"stats":{"Line":0}},{"line":443,"address":[116500944,116500432],"length":1,"stats":{"Line":0}},{"line":445,"address":[117252133,117252645],"length":1,"stats":{"Line":0}},{"line":446,"address":[19861264,19861187],"length":1,"stats":{"Line":0}},{"line":447,"address":[116504433,116504945],"length":1,"stats":{"Line":0}},{"line":448,"address":[19793535,19793645],"length":1,"stats":{"Line":0}},{"line":449,"address":[19854501],"length":1,"stats":{"Line":0}},{"line":451,"address":[116505032,116505368],"length":1,"stats":{"Line":0}},{"line":452,"address":[19787174,19787265],"length":1,"stats":{"Line":0}},{"line":453,"address":[117158089,117158425],"length":1,"stats":{"Line":0}},{"line":454,"address":[116395648,116395312,116395352,116395688],"length":1,"stats":{"Line":0}},{"line":455,"address":[116505162,116505498],"length":1,"stats":{"Line":0}},{"line":456,"address":[14034995,14035105],"length":1,"stats":{"Line":0}},{"line":457,"address":[19787609],"length":1,"stats":{"Line":0}},{"line":462,"address":[19897753,19897846],"length":1,"stats":{"Line":0}},{"line":463,"address":[19788014,19788094],"length":1,"stats":{"Line":0}},{"line":464,"address":[20010183,20010048,20010718,20010864,20010073,20010125,19994390],"length":1,"stats":{"Line":0}},{"line":465,"address":[11498190],"length":1,"stats":{"Line":0}},{"line":466,"address":[19879096,19879011],"length":1,"stats":{"Line":0}},{"line":467,"address":[117115402,117115034,117115074,117115442],"length":1,"stats":{"Line":0}},{"line":474,"address":[119659115,119658747],"length":1,"stats":{"Line":0}},{"line":475,"address":[19795401,19795321],"length":1,"stats":{"Line":0}},{"line":476,"address":[19872511,19856241,19872681,19872480,19872578,19874908,19877774],"length":1,"stats":{"Line":0}},{"line":477,"address":[19872576,19874961,19872651,19872602,19872713],"length":1,"stats":{"Line":0}},{"line":478,"address":[19807572],"length":1,"stats":{"Line":0}},{"line":480,"address":[13045096,13042284,13045223,13042403],"length":1,"stats":{"Line":0}},{"line":482,"address":[19914234,19914335,19914836,20028121,20028255],"length":1,"stats":{"Line":0}},{"line":486,"address":[19880073,19882423,19882493,19879566,19879715],"length":1,"stats":{"Line":0}},{"line":487,"address":[19990505,19990639,19873218,19873319,19873820],"length":1,"stats":{"Line":0}},{"line":500,"address":[19898415,19898514],"length":1,"stats":{"Line":0}},{"line":503,"address":[19895257],"length":1,"stats":{"Line":0}},{"line":504,"address":[19898623,19898530],"length":1,"stats":{"Line":0}},{"line":505,"address":[13027039,13027130],"length":1,"stats":{"Line":0}},{"line":506,"address":[19894908,19894848],"length":1,"stats":{"Line":0}},{"line":507,"address":[19782281,19782344],"length":1,"stats":{"Line":0}},{"line":508,"address":[19796181,19796244],"length":1,"stats":{"Line":0}},{"line":513,"address":[19895430],"length":1,"stats":{"Line":0}},{"line":542,"address":[19997051,19996964],"length":1,"stats":{"Line":0}},{"line":543,"address":[19902283,19921712,19921584,19924008,19921945,19924019,19921615],"length":1,"stats":{"Line":0}},{"line":544,"address":[117115961],"length":1,"stats":{"Line":0}},{"line":545,"address":[19998063,19885647,19885546,19997929,19886148],"length":1,"stats":{"Line":0}},{"line":551,"address":[19900721],"length":1,"stats":{"Line":0}},{"line":552,"address":[116502985],"length":1,"stats":{"Line":0}},{"line":553,"address":[20018965,20019018,20019073,20019207],"length":1,"stats":{"Line":0}},{"line":558,"address":[19797994,19798081],"length":1,"stats":{"Line":0}},{"line":559,"address":[19865865,19865942],"length":1,"stats":{"Line":0}},{"line":560,"address":[19798198,19825700,19820226,19820329,19820128,19822666,19820159],"length":1,"stats":{"Line":0}},{"line":561,"address":[19919168,19919194,19919243,19919305,19921663],"length":1,"stats":{"Line":0}},{"line":562,"address":[19890898],"length":1,"stats":{"Line":0}},{"line":563,"address":[116503141],"length":1,"stats":{"Line":0}},{"line":564,"address":[11423797],"length":1,"stats":{"Line":0}},{"line":565,"address":[76123855],"length":1,"stats":{"Line":0}},{"line":567,"address":[117055574],"length":1,"stats":{"Line":0}},{"line":571,"address":[116679259],"length":1,"stats":{"Line":0}},{"line":572,"address":[11630110],"length":1,"stats":{"Line":0}},{"line":573,"address":[19919911,19920412,20030239,19919810,20030105],"length":1,"stats":{"Line":0}},{"line":574,"address":[117160178],"length":1,"stats":{"Line":0}},{"line":587,"address":[19859174],"length":1,"stats":{"Line":0}},{"line":588,"address":[19930885,19928704,19928827,19929005,19930896,19928735,19901262],"length":1,"stats":{"Line":0}},{"line":589,"address":[11530257],"length":1,"stats":{"Line":0}},{"line":590,"address":[19925373,20030735,20030601,19925975,19925474],"length":1,"stats":{"Line":0}},{"line":595,"address":[19903016],"length":1,"stats":{"Line":0}},{"line":599,"address":[19927064,19927086,19927056,19927072,19927165],"length":1,"stats":{"Line":0}},{"line":602,"address":[19895929],"length":1,"stats":{"Line":0}},{"line":608,"address":[19828256,19828304,19828274,19829445,19828890,19828592,19828719,19828335],"length":1,"stats":{"Line":0}},{"line":611,"address":[19933450,19933076,19933305,19933150],"length":1,"stats":{"Line":0}},{"line":612,"address":[11475240],"length":1,"stats":{"Line":0}},{"line":613,"address":[19816053,19815974],"length":1,"stats":{"Line":0}},{"line":614,"address":[19816125],"length":1,"stats":{"Line":0}},{"line":620,"address":[14071929],"length":1,"stats":{"Line":0}},{"line":621,"address":[19935966],"length":1,"stats":{"Line":0}},{"line":622,"address":[19934356],"length":1,"stats":{"Line":0}},{"line":623,"address":[19817754],"length":1,"stats":{"Line":0}},{"line":624,"address":[19824576],"length":1,"stats":{"Line":0}},{"line":625,"address":[19936118],"length":1,"stats":{"Line":0}},{"line":626,"address":[13061540],"length":1,"stats":{"Line":0}},{"line":628,"address":[11400529],"length":1,"stats":{"Line":0}},{"line":630,"address":[19933442,19933363],"length":1,"stats":{"Line":0}},{"line":631,"address":[19933505,19933614],"length":1,"stats":{"Line":0}},{"line":632,"address":[19898510,19898603],"length":1,"stats":{"Line":0}},{"line":633,"address":[19830935,19830851],"length":1,"stats":{"Line":0}},{"line":634,"address":[19891859,19891775],"length":1,"stats":{"Line":0}},{"line":635,"address":[19824059],"length":1,"stats":{"Line":0}},{"line":636,"address":[19817350],"length":1,"stats":{"Line":0}},{"line":643,"address":[11393770],"length":1,"stats":{"Line":0}},{"line":644,"address":[20031532,20031459],"length":1,"stats":{"Line":0}},{"line":646,"address":[19936819,19936906,19933234],"length":1,"stats":{"Line":0}},{"line":647,"address":[13062578,13062630],"length":1,"stats":{"Line":0}},{"line":650,"address":[19826768,19827476,19826826,19831470,19842668,19826952,19825936],"length":1,"stats":{"Line":0}},{"line":651,"address":[14074502,14074411,14074787,14075028],"length":1,"stats":{"Line":0}},{"line":652,"address":[19827818],"length":1,"stats":{"Line":0}},{"line":653,"address":[14172697,14075360,14172831,14076046,14075530],"length":1,"stats":{"Line":0}},{"line":654,"address":[11534115],"length":1,"stats":{"Line":0}},{"line":656,"address":[19843087],"length":1,"stats":{"Line":0}},{"line":657,"address":[14084362],"length":1,"stats":{"Line":0}},{"line":658,"address":[11541117],"length":1,"stats":{"Line":0}},{"line":660,"address":[19942491,19942570],"length":1,"stats":{"Line":0}},{"line":661,"address":[19836689,19836768],"length":1,"stats":{"Line":0}},{"line":665,"address":[19302359],"length":1,"stats":{"Line":0}},{"line":666,"address":[19911979,19912058],"length":1,"stats":{"Line":0}},{"line":669,"address":[19912104,19912153],"length":1,"stats":{"Line":0}},{"line":672,"address":[11527409],"length":1,"stats":{"Line":0}},{"line":673,"address":[19912610],"length":1,"stats":{"Line":0}},{"line":674,"address":[19831192],"length":1,"stats":{"Line":0}},{"line":675,"address":[14085577],"length":1,"stats":{"Line":0}},{"line":676,"address":[10899379],"length":1,"stats":{"Line":0}},{"line":677,"address":[13068689,13068629],"length":1,"stats":{"Line":0}},{"line":683,"address":[19993463,19995498,19993424,19994972,19995360,19995432,19995570,19994944],"length":1,"stats":{"Line":0}},{"line":685,"address":[20002318],"length":1,"stats":{"Line":0}},{"line":686,"address":[20039115],"length":1,"stats":{"Line":0}},{"line":687,"address":[20133958],"length":1,"stats":{"Line":0}},{"line":688,"address":[20039237],"length":1,"stats":{"Line":0}},{"line":689,"address":[13342398],"length":1,"stats":{"Line":0}},{"line":691,"address":[20039472,20040337,20039505,20040272],"length":1,"stats":{"Line":0}},{"line":693,"address":[19935774],"length":1,"stats":{"Line":0}},{"line":694,"address":[19928817],"length":1,"stats":{"Line":0}},{"line":697,"address":[13069384],"length":1,"stats":{"Line":0}},{"line":698,"address":[19839205],"length":1,"stats":{"Line":0}},{"line":699,"address":[19907344],"length":1,"stats":{"Line":0}},{"line":700,"address":[19825479],"length":1,"stats":{"Line":0}},{"line":701,"address":[19900149],"length":1,"stats":{"Line":0}},{"line":702,"address":[19942272],"length":1,"stats":{"Line":0}},{"line":703,"address":[20038779],"length":1,"stats":{"Line":0}},{"line":704,"address":[20038854],"length":1,"stats":{"Line":0}},{"line":707,"address":[19907624],"length":1,"stats":{"Line":0}},{"line":708,"address":[19944623,20040655,20040521,19945124,19944522],"length":1,"stats":{"Line":0}},{"line":711,"address":[20041355,20040967],"length":1,"stats":{"Line":0}},{"line":712,"address":[19946270,19946347],"length":1,"stats":{"Line":0}},{"line":713,"address":[20041147],"length":1,"stats":{"Line":0}},{"line":714,"address":[20049215,20049537,20041215,20051817,20049184,20049314,20051746],"length":1,"stats":{"Line":0}},{"line":715,"address":[19911381,19913275],"length":1,"stats":{"Line":0}},{"line":716,"address":[11654104],"length":1,"stats":{"Line":0}},{"line":718,"address":[19843627,19844229,19843728,19929513,19929647],"length":1,"stats":{"Line":0}},{"line":727,"address":[19827949,19828288,19828646],"length":1,"stats":{"Line":0}},{"line":728,"address":[19828345,19828422],"length":1,"stats":{"Line":0}},{"line":729,"address":[19946726],"length":1,"stats":{"Line":0}},{"line":730,"address":[19841497,19841426,19838895,19828506,19839217,19838864,19838994],"length":1,"stats":{"Line":0}},{"line":731,"address":[11096788],"length":1,"stats":{"Line":0}},{"line":733,"address":[20004745,20004879,19921216,19921115,19921717],"length":1,"stats":{"Line":0}},{"line":749,"address":[11534245],"length":1,"stats":{"Line":0}},{"line":750,"address":[14086453,14086532],"length":1,"stats":{"Line":0}},{"line":752,"address":[19302463],"length":1,"stats":{"Line":0}},{"line":753,"address":[19951129,19951050],"length":1,"stats":{"Line":0}},{"line":754,"address":[14087171,14087707,14178025,14178159],"length":1,"stats":{"Line":0}},{"line":756,"address":[19902607],"length":1,"stats":{"Line":0}},{"line":757,"address":[19936093,20037055,20036921,19933841,19935577],"length":1,"stats":{"Line":0}},{"line":759,"address":[19820366,19834515,19823345,19824570],"length":1,"stats":{"Line":0}},{"line":760,"address":[14089076,14089149],"length":1,"stats":{"Line":0}},{"line":762,"address":[19953204,19953291,19938675],"length":1,"stats":{"Line":0}},{"line":763,"address":[19953716,19953643],"length":1,"stats":{"Line":0}},{"line":768,"address":[19937741],"length":1,"stats":{"Line":0}},{"line":772,"address":[20054985,20054688,20054696,20054720,20055178,20054751,20055711,20054888],"length":1,"stats":{"Line":0}},{"line":773,"address":[11551039],"length":1,"stats":{"Line":0}},{"line":774,"address":[11551058],"length":1,"stats":{"Line":0}},{"line":775,"address":[20056240,20056370],"length":1,"stats":{"Line":0}},{"line":777,"address":[19956175,19956287,19958486,19958548],"length":1,"stats":{"Line":0}},{"line":778,"address":[14097976,14100172,14100312,14096192,14098284],"length":1,"stats":{"Line":0}},{"line":779,"address":[19918617,19918718,19919219,19999305,19999439],"length":1,"stats":{"Line":0}},{"line":782,"address":[13088593],"length":1,"stats":{"Line":0}},{"line":786,"address":[19920793,19920720,19921690,19921108,19920961,19920738,19920768,19920903],"length":1,"stats":{"Line":0}},{"line":789,"address":[14100592,14100852,14100722,14100642],"length":1,"stats":{"Line":0}},{"line":790,"address":[19853643,19853570],"length":1,"stats":{"Line":0}},{"line":792,"address":[12263378],"length":1,"stats":{"Line":0}},{"line":793,"address":[19854117,19854190],"length":1,"stats":{"Line":0}},{"line":794,"address":[13090014],"length":1,"stats":{"Line":0}},{"line":798,"address":[19922128,19922592,19923943,19923911],"length":1,"stats":{"Line":0}},{"line":799,"address":[19922158,19922250,19922800,19999801,19922594,19923692,19999935,19923405],"length":1,"stats":{"Line":0}},{"line":804,"address":[19858799,19856239,19856144,19856317,19856175,19858728,19856068,19854900],"length":1,"stats":{"Line":0}},{"line":805,"address":[20062525],"length":1,"stats":{"Line":0}},{"line":806,"address":[19930991,19931069,19931019,19931352],"length":1,"stats":{"Line":0}},{"line":807,"address":[19924926,20000431,19924825,20000297,19925427],"length":1,"stats":{"Line":0}},{"line":813,"address":[19856367,19858688,19856273,19858737],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":351},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","fixtures","mod.rs"],"content":"use serde_json::json;\n\npub fn create_test_user(npub: &str) -> serde_json::Value {\n    json!({\n        \"npub\": npub,\n        \"pubkey\": format!(\"pubkey_{}\", npub),\n        \"name\": format!(\"Test User {}\", npub),\n        \"display_name\": format!(\"Test {}\", npub),\n        \"about\": \"Test user for unit tests\",\n        \"picture\": \"https://example.com/avatar.jpg\",\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890\n    })\n}\n\npub fn create_test_post(id: &str, author_npub: &str, topic_id: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"content\": format!(\"Test post content {}\", id),\n        \"author\": create_test_user(author_npub),\n        \"topic_id\": topic_id,\n        \"created_at\": 1234567890,\n        \"tags\": [\"test\", \"fixture\"],\n        \"likes\": 0,\n        \"boosts\": 0,\n        \"replies\": [],\n        \"is_synced\": false,\n        \"is_boosted\": false,\n        \"is_bookmarked\": false,\n        \"local_id\": id,\n        \"event_id\": null\n    })\n}\n\npub fn create_test_topic(id: &str, name: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"name\": name,\n        \"description\": format!(\"Test topic {}\", name),\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890,\n        \"is_joined\": false,\n        \"member_count\": 0,\n        \"post_count\": 0,\n        \"visibility\": \"public\",\n        \"owner\": null\n    })\n}\n\npub fn create_test_event(id: &str, kind: u32, content: &str, pubkey: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"pubkey\": pubkey,\n        \"created_at\": 1234567890,\n        \"kind\": kind,\n        \"tags\": [],\n        \"content\": content,\n        \"sig\": format!(\"signature_{}\", id)\n    })\n}\n\npub fn create_test_keypair() -> (String, String, String, String) {\n    let id = uuid::Uuid::new_v4().to_string();\n    let npub = format!(\"npub1{}\", &id[..59]);\n    let nsec = format!(\"nsec1{}\", &id[..59]);\n    let pubkey = format!(\"pubkey_{}\", id);\n    let privkey = format!(\"privkey_{}\", id);\n    \n    (npub, nsec, pubkey, privkey)\n}\n\npub fn create_test_database_url() -> String {\n    \":memory:\".to_string()\n}\n\npub fn create_test_config() -> serde_json::Value {\n    json!({\n        \"database\": {\n            \"url\": \":memory:\",\n            \"max_connections\": 5,\n            \"connection_timeout\": 30\n        },\n        \"network\": {\n            \"bootstrap_peers\": [],\n            \"max_peers\": 50,\n            \"connection_timeout\": 30,\n            \"retry_interval\": 60\n        },\n        \"sync\": {\n            \"auto_sync\": true,\n            \"sync_interval\": 300,\n            \"max_retry\": 3,\n            \"batch_size\": 100\n        },\n        \"storage\": {\n            \"data_dir\": \"./test_data\",\n            \"cache_size\": 100000000,\n            \"cache_ttl\": 3600\n        }\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_gateway.rs"],"content":"﻿use async_trait::async_trait;\nuse mockall::mock;\n\nuse kukuri_lib::application::ports::event_gateway::EventGateway;\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\nuse kukuri_lib::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\nuse kukuri_lib::domain::value_objects::{EventId, TopicId};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventGatewayPort {}\n\n    #[async_trait]\n    impl EventGateway for EventGatewayPort {\n        async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\n        async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n        async fn publish_topic_post(\n            &self,\n            topic_id: &TopicId,\n            content: &TopicContent,\n            reply_to: Option<&EventId>,\n            scope: Option<&str>,\n            epoch: Option<i64>,\n        ) -> Result<EventId, AppError>;\n        async fn send_reaction(\n            &self,\n            target: &EventId,\n            reaction: &ReactionValue,\n        ) -> Result<EventId, AppError>;\n        async fn update_profile_metadata(\n            &self,\n            metadata: &ProfileMetadata,\n        ) -> Result<EventId, AppError>;\n        async fn delete_events(\n            &self,\n            targets: &[EventId],\n            reason: Option<&str>,\n        ) -> Result<EventId, AppError>;\n        async fn disconnect(&self) -> Result<(), AppError>;\n        async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\n        async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\n        async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\n    }\n}\n\npub type MockEventGateway = MockEventGatewayPort;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_service.rs"],"content":"use async_trait::async_trait;\nuse mockall::mock;\nuse nostr_sdk::prelude::Timestamp;\n\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse kukuri_lib::domain::entities::Event;\nuse kukuri_lib::infrastructure::crypto::SignatureService;\nuse kukuri_lib::infrastructure::database::EventRepository;\nuse kukuri_lib::infrastructure::p2p::{event_distributor::DistributionStrategy, EventDistributor};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventRepo {}\n\n    #[async_trait]\n    impl EventRepository for EventRepo {\n        async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n        async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n        async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn get_events_by_author(&self, pubkey: &str, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n        async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n        async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n        async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError>;\n        async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError>;\n    }\n}\n\nmock! {\n    pub SignatureServ {}\n\n    #[async_trait]\n    impl SignatureService for SignatureServ {\n        async fn sign_event(&self, event: &mut Event, private_key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_event(&self, event: &Event) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n        async fn sign_message(&self, message: &str, private_key: &str) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_message(&self, message: &str, signature: &str, public_key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub EventDist {}\n\n    #[async_trait]\n    impl EventDistributor for EventDist {\n        async fn distribute(&self, event: &Event, strategy: DistributionStrategy) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn set_strategy(&self, strategy: DistributionStrategy);\n        async fn get_pending_events(&self) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub SubscriptionStateMock {}\n\n    #[async_trait]\n    impl SubscriptionStateStore for SubscriptionStateMock {\n        async fn record_request(&self, target: SubscriptionTarget) -> Result<SubscriptionRecord, AppError>;\n        async fn mark_subscribed(&self, target: &SubscriptionTarget, synced_at: i64) -> Result<(), AppError>;\n        async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n        async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n        async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n        async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n    }\n}\n\nmock! {\n    pub SubscriptionInvokerMock {}\n\n    #[async_trait]\n    impl SubscriptionInvoker for SubscriptionInvokerMock {\n        async fn subscribe_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n        async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_crypto.rs"],"content":"use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockKeyManager {\n    keypairs: Arc<RwLock<HashMap<String, MockKeyPair>>>,\n}\n\n#[derive(Debug, Clone)]\npub struct MockKeyPair {\n    pub npub: String,\n    pub nsec: String,\n    pub public_key: String,\n    pub private_key: String,\n}\n\nimpl MockKeyManager {\n    pub fn new() -> Self {\n        Self {\n            keypairs: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn generate_keypair(&self) -> MockKeyPair {\n        let id = uuid::Uuid::new_v4().to_string();\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", &id[..59]),\n            nsec: format!(\"nsec1{}\", &id[..59]),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        keypair\n    }\n\n    pub async fn import_private_key(&self, nsec: &str) -> Result<MockKeyPair, String> {\n        if !nsec.starts_with(\"nsec1\") {\n            return Err(\"Invalid nsec format\".to_string());\n        }\n        \n        let id = &nsec[5..];\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", id),\n            nsec: nsec.to_string(),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        Ok(keypair)\n    }\n\n    pub async fn get_keypair(&self, npub: &str) -> Option<MockKeyPair> {\n        self.keypairs.read().await.get(npub).cloned()\n    }\n\n    pub async fn list_npubs(&self) -> Vec<String> {\n        self.keypairs.read().await.keys().cloned().collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSignatureService;\n\nimpl MockSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn sign_event(&self, event_id: &str, _private_key: &str) -> String {\n        format!(\"signature_for_{}\", event_id)\n    }\n\n    pub async fn verify_event(&self, _event_id: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n\n    pub async fn sign_message(&self, message: &str, _private_key: &str) -> String {\n        format!(\"sig_{}\", &message[..message.len().min(10)])\n    }\n\n    pub async fn verify_message(&self, _message: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEncryptionService;\n\nimpl MockEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn encrypt(&self, data: &[u8], _recipient_pubkey: &str) -> Vec<u8> {\n        // Simple mock: just reverse the bytes\n        data.iter().rev().cloned().collect()\n    }\n\n    pub async fn decrypt(&self, encrypted_data: &[u8], _sender_pubkey: &str) -> Vec<u8> {\n        // Simple mock: reverse back\n        encrypted_data.iter().rev().cloned().collect()\n    }\n\n    pub async fn encrypt_symmetric(&self, data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR with password hash\n        let key = password.bytes().cycle();\n        data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n\n    pub async fn decrypt_symmetric(&self, encrypted_data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR back with password hash\n        let key = password.bytes().cycle();\n        encrypted_data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSecureStorage {\n    storage: Arc<RwLock<HashMap<String, String>>>,\n}\n\nimpl MockSecureStorage {\n    pub fn new() -> Self {\n        Self {\n            storage: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn store(&self, key: &str, value: &str) -> Result<(), String> {\n        self.storage.write().await.insert(key.to_string(), value.to_string());\n        Ok(())\n    }\n\n    pub async fn retrieve(&self, key: &str) -> Result<Option<String>, String> {\n        Ok(self.storage.read().await.get(key).cloned())\n    }\n\n    pub async fn delete(&self, key: &str) -> Result<(), String> {\n        self.storage.write().await.remove(key);\n        Ok(())\n    }\n\n    pub async fn exists(&self, key: &str) -> bool {\n        self.storage.read().await.contains_key(key)\n    }\n\n    pub async fn list_keys(&self) -> Vec<String> {\n        self.storage.read().await.keys().cloned().collect()\n    }\n\n    pub async fn clear(&self) -> Result<(), String> {\n        self.storage.write().await.clear();\n        Ok(())\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_network.rs"],"content":"use async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockNetworkService {\n    is_connected: Arc<RwLock<bool>>,\n    peers: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockNetworkService {\n    pub fn new() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(false)),\n            peers: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn connected() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(true)),\n            peers: Arc::new(RwLock::new(vec![\"peer1\".to_string(), \"peer2\".to_string()])),\n        }\n    }\n\n    pub async fn set_connected(&self, connected: bool) {\n        *self.is_connected.write().await = connected;\n    }\n\n    pub async fn add_peer(&self, peer: String) {\n        self.peers.write().await.push(peer);\n    }\n\n    pub async fn is_connected(&self) -> bool {\n        *self.is_connected.read().await\n    }\n\n    pub async fn get_peers(&self) -> Vec<String> {\n        self.peers.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockGossipService {\n    topics: Arc<RwLock<Vec<String>>>,\n    messages: Arc<RwLock<Vec<(String, String)>>>, // (topic, message)\n}\n\nimpl MockGossipService {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(Vec::new())),\n            messages: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn join_topic(&self, topic: String) {\n        self.topics.write().await.push(topic);\n    }\n\n    pub async fn leave_topic(&self, topic: &str) {\n        self.topics.write().await.retain(|t| t != topic);\n    }\n\n    pub async fn broadcast(&self, topic: String, message: String) {\n        self.messages.write().await.push((topic, message));\n    }\n\n    pub async fn get_joined_topics(&self) -> Vec<String> {\n        self.topics.read().await.clone()\n    }\n\n    pub async fn get_messages(&self) -> Vec<(String, String)> {\n        self.messages.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEventDistributor {\n    distributed_events: Arc<RwLock<Vec<String>>>,\n    pending_events: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn with_pending(events: Vec<String>) -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(events)),\n        }\n    }\n\n    pub async fn distribute(&self, event_id: String) {\n        self.distributed_events.write().await.push(event_id.clone());\n        self.pending_events.write().await.retain(|e| e != &event_id);\n    }\n\n    pub async fn get_distributed_events(&self) -> Vec<String> {\n        self.distributed_events.read().await.clone()\n    }\n\n    pub async fn get_pending_events(&self) -> Vec<String> {\n        self.pending_events.read().await.clone()\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_repository.rs"],"content":"use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n// Note: These types would need to be imported from the actual application\n// For now, we'll use placeholder types\ntype Post = serde_json::Value;\ntype Topic = serde_json::Value;\ntype User = serde_json::Value;\ntype Event = serde_json::Value;\n\npub struct MockPostRepository {\n    posts: Arc<RwLock<HashMap<String, Post>>>,\n}\n\nimpl MockPostRepository {\n    pub fn new() -> Self {\n        Self {\n            posts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_posts(posts: Vec<Post>) -> Self {\n        let mut map = HashMap::new();\n        for post in posts {\n            if let Some(id) = post.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), post);\n            }\n        }\n        Self {\n            posts: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockTopicRepository {\n    topics: Arc<RwLock<HashMap<String, Topic>>>,\n}\n\nimpl MockTopicRepository {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_topics(topics: Vec<Topic>) -> Self {\n        let mut map = HashMap::new();\n        for topic in topics {\n            if let Some(id) = topic.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), topic);\n            }\n        }\n        Self {\n            topics: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockUserRepository {\n    users: Arc<RwLock<HashMap<String, User>>>,\n}\n\nimpl MockUserRepository {\n    pub fn new() -> Self {\n        Self {\n            users: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_users(users: Vec<User>) -> Self {\n        let mut map = HashMap::new();\n        for user in users {\n            if let Some(npub) = user.get(\"npub\").and_then(|v| v.as_str()) {\n                map.insert(npub.to_string(), user);\n            }\n        }\n        Self {\n            users: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockEventRepository {\n    events: Arc<RwLock<HashMap<String, Event>>>,\n}\n\nimpl MockEventRepository {\n    pub fn new() -> Self {\n        Self {\n            events: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_events(events: Vec<Event>) -> Self {\n        let mut map = HashMap::new();\n        for event in events {\n            if let Some(id) = event.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), event);\n            }\n        }\n        Self {\n            events: Arc::new(RwLock::new(map)),\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mod.rs"],"content":"pub mod event_gateway;\npub mod event_service;\npub mod mock_repository;\npub mod mock_network;\npub mod mock_crypto;\n\npub use event_gateway::*;\npub use event_service::*;\npub use mock_repository::*;\npub use mock_network::*;\npub use mock_crypto::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mod.rs"],"content":"pub mod mocks;\npub mod fixtures;\npub mod performance;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","offline_support.rs"],"content":"use std::sync::Arc;\r\n\r\nuse chrono::Utc;\r\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\r\nuse kukuri_lib::test_support::application::services::offline_service::{\r\n    OfflineService, SaveOfflineActionParams,\r\n};\r\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\r\nuse kukuri_lib::test_support::domain::value_objects::offline::{\r\n    EntityId, EntityType, OfflineActionType, OfflinePayload,\r\n};\r\nuse kukuri_lib::test_support::infrastructure::offline::SqliteOfflinePersistence;\r\nuse serde_json::json;\r\nuse sqlx::{Executor, Pool, Sqlite, sqlite::SqlitePoolOptions};\r\n\r\npub const TEST_PUBKEY_HEX: &str =\r\n    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\r\n\r\npub struct OfflineTestContext {\r\n    pub service: OfflineService,\r\n    pub pool: Pool<Sqlite>,\r\n}\r\n\r\npub async fn setup_offline_service() -> OfflineTestContext {\r\n    let pool = SqlitePoolOptions::new()\r\n        .max_connections(1)\r\n        .connect(\"sqlite::memory:?cache=shared\")\r\n        .await\r\n        .expect(\"in-memory sqlite\");\r\n\r\n    initialize_schema(&pool).await;\r\n\r\n    let persistence: Arc<dyn OfflinePersistence> =\r\n        Arc::new(SqliteOfflinePersistence::new(pool.clone()));\r\n\r\n    OfflineTestContext {\r\n        service: OfflineService::new(persistence),\r\n        pool,\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\npub fn sample_save_params() -> SaveOfflineActionParams {\n    SaveOfflineActionParams {\r\n        user_pubkey: PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"),\r\n        action_type: OfflineActionType::new(\"create_post\".into()).expect(\"action type\"),\r\n        entity_type: EntityType::new(\"post\".into()).expect(\"entity type\"),\r\n        entity_id: EntityId::new(\"post123\".into()).expect(\"entity id\"),\r\n        payload: OfflinePayload::from_json_str(r#\"{\"content\":\"Hello\"}\"#).expect(\"payload\"),\r\n    }\r\n}\r\n\r\npub fn build_params_for_index(index: usize) -> SaveOfflineActionParams {\r\n    let payload = json!({\r\n        \"content\": format!(\"Post {index}\"),\r\n        \"topicId\": format!(\"topic-{}\", index % 8),\r\n        \"created_at\": Utc::now().timestamp()\r\n    });\r\n\r\n    SaveOfflineActionParams {\r\n        user_pubkey: PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"),\r\n        action_type: OfflineActionType::new(\"create_post\".into()).expect(\"action type\"),\r\n        entity_type: EntityType::new(\"post\".into()).expect(\"entity type\"),\r\n        entity_id: EntityId::new(format!(\"post_{index:04}\").into()).expect(\"entity id\"),\r\n        payload: OfflinePayload::from_json_str(&payload.to_string()).expect(\"payload\"),\r\n    }\r\n}\r\n\r\nasync fn initialize_schema(pool: &Pool<Sqlite>) {\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS offline_actions (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            user_pubkey TEXT NOT NULL,\r\n            action_type TEXT NOT NULL,\r\n            target_id TEXT,\r\n            action_data TEXT NOT NULL,\r\n            local_id TEXT NOT NULL,\r\n            remote_id TEXT,\r\n            is_synced INTEGER DEFAULT 0,\r\n            created_at INTEGER NOT NULL,\r\n            synced_at INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"offline_actions table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS sync_queue (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            action_type TEXT NOT NULL,\r\n            payload TEXT NOT NULL,\r\n            status TEXT NOT NULL,\r\n            retry_count INTEGER DEFAULT 0,\r\n            max_retries INTEGER DEFAULT 3,\r\n            created_at INTEGER NOT NULL,\r\n            updated_at INTEGER NOT NULL,\r\n            synced_at INTEGER,\r\n            error_message TEXT\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"sync_queue table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS cache_metadata (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            cache_key TEXT NOT NULL UNIQUE,\r\n            cache_type TEXT NOT NULL,\r\n            last_synced_at INTEGER,\r\n            last_accessed_at INTEGER,\r\n            data_version INTEGER DEFAULT 1,\r\n            is_stale INTEGER DEFAULT 0,\r\n            expiry_time INTEGER,\r\n            metadata TEXT,\r\n            doc_version INTEGER,\r\n            blob_hash TEXT,\r\n            payload_bytes INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE INDEX IF NOT EXISTS idx_cache_metadata_doc_version ON cache_metadata(doc_version);\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata doc_version index\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE INDEX IF NOT EXISTS idx_cache_metadata_blob_hash ON cache_metadata(blob_hash);\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata blob_hash index\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS optimistic_updates (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            update_id TEXT NOT NULL UNIQUE,\r\n            entity_type TEXT NOT NULL,\r\n            entity_id TEXT NOT NULL,\r\n            original_data TEXT,\r\n            updated_data TEXT NOT NULL,\r\n            is_confirmed INTEGER DEFAULT 0,\r\n            created_at INTEGER NOT NULL,\r\n            confirmed_at INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"optimistic_updates table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS sync_status (\r\n            entity_type TEXT NOT NULL,\r\n            entity_id TEXT NOT NULL,\r\n            local_version INTEGER NOT NULL,\r\n            last_local_update INTEGER NOT NULL,\r\n            sync_status TEXT NOT NULL,\r\n            conflict_data TEXT,\r\n            PRIMARY KEY (entity_type, entity_id)\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"sync_status table\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","mod.rs"],"content":"pub mod offline_seed;\n#[path = \"../offline_support.rs\"]\npub mod offline_support;\npub mod recorder;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","offline_seed.rs"],"content":"use anyhow::{Result, anyhow};\r\nuse chrono::{Duration, Utc};\r\nuse kukuri_lib::test_support::application::services::offline_service::{\r\n    OfflineService, OfflineServiceTrait,\r\n};\r\nuse kukuri_lib::test_support::domain::entities::offline::CacheMetadataUpdate;\r\nuse kukuri_lib::test_support::domain::value_objects::offline::{CacheKey, CacheType};\r\nuse serde_json::json;\r\n\r\nuse super::offline_support::build_params_for_index;\r\n\r\npub async fn seed_offline_actions(service: &OfflineService, count: usize) -> Result<()> {\r\n    for i in 0..count {\r\n        service\r\n            .save_action(build_params_for_index(i))\r\n            .await\r\n            .map_err(|err| anyhow!(\"{err}\"))?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub async fn seed_cache_metadata(service: &OfflineService, count: usize) -> Result<()> {\r\n    for i in 0..count {\r\n        let update = CacheMetadataUpdate {\r\n            cache_key: CacheKey::new(format!(\"cache:test:{i}\").into()).expect(\"cache key\"),\r\n            cache_type: CacheType::new(\"posts\".into()).expect(\"cache type\"),\r\n            metadata: Some(json!({ \"version\": i })),\r\n            expiry: Some(Utc::now() + Duration::seconds((i as i64 % 3) + 1)),\r\n            is_stale: Some(false),\r\n            doc_version: None,\r\n            blob_hash: None,\r\n            payload_bytes: None,\r\n        };\r\n        service\r\n            .upsert_cache_metadata(update)\r\n            .await\r\n            .map_err(|err| anyhow!(\"{err}\"))?;\r\n    }\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","recorder.rs"],"content":"use std::{\n    collections::BTreeMap,\n    env,\n    fs::{self, File},\n    path::PathBuf,\n};\n\nuse anyhow::{Context, Result};\nuse chrono::{Timelike, Utc};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct PerformanceReport<'a> {\n    scenario: &'a str,\n    timestamp: String,\n    iterations: u64,\n    metrics: &'a BTreeMap<String, f64>,\n    notes: &'a BTreeMap<String, String>,\n}\n\n#[derive(Default)]\npub struct PerformanceRecorder {\n    scenario: String,\n    iterations: u64,\n    metrics: BTreeMap<String, f64>,\n    notes: BTreeMap<String, String>,\n}\n\nimpl PerformanceRecorder {\n    pub fn new<S: Into<String>>(scenario: S) -> Self {\n        Self {\n            scenario: scenario.into(),\n            iterations: 0,\n            metrics: BTreeMap::new(),\n            notes: BTreeMap::new(),\n        }\n    }\n\n    pub fn iterations(mut self, value: u64) -> Self {\n        self.iterations = value;\n        self\n    }\n\n    pub fn metric(mut self, key: &str, value: f64) -> Self {\n        self.metrics.insert(key.to_string(), value);\n        self\n    }\n\n    pub fn note(mut self, key: &str, value: impl Into<String>) -> Self {\n        self.notes.insert(key.to_string(), value.into());\n        self\n    }\n\n    pub fn write(self) -> Result<PathBuf> {\n        let output_dir = resolve_output_dir();\n        fs::create_dir_all(&output_dir).context(\"create performance output directory\")?;\n\n        let timestamp = Utc::now();\n        let filename = format!(\n            \"{}-{}.json\",\n            timestamp.format(\"%Y%m%d%H%M%S\"),\n            sanitize_filename(&self.scenario)\n        );\n        let path = output_dir.join(filename);\n\n        let report = PerformanceReport {\n            scenario: &self.scenario,\n            timestamp: timestamp\n                .with_nanosecond(0)\n                .unwrap_or(timestamp)\n                .to_rfc3339(),\n            iterations: self.iterations,\n            metrics: &self.metrics,\n            notes: &self.notes,\n        };\n\n        let file = File::create(&path).context(\"create performance report file\")?;\n        serde_json::to_writer_pretty(file, &report).context(\"write performance report\")?;\n        Ok(path)\n    }\n}\n\nfn resolve_output_dir() -> PathBuf {\n    env::var(\"KUKURI_PERFORMANCE_OUTPUT\")\n        .map(PathBuf::from)\n        .unwrap_or_else(|_| PathBuf::from(\"test-results/performance\"))\n}\n\nfn sanitize_filename(source: &str) -> String {\n    let mut sanitized: String = source\n        .chars()\n        .map(|c| match c {\n            'a'..='z' | '0'..='9' => c,\n            'A'..='Z' => c.to_ascii_lowercase(),\n            '_' | '-' => c,\n            _ if c.is_whitespace() => '_',\n            _ => '-',\n        })\n        .collect();\n\n    if sanitized.is_empty() {\n        sanitized.push_str(\"scenario\");\n    }\n\n    while sanitized.starts_with(['-', '_']) {\n        sanitized.remove(0);\n    }\n\n    if sanitized.is_empty() {\n        sanitized.push_str(\"scenario\");\n    }\n\n    sanitized\n}\n\npub fn duration_secs(duration: std::time::Duration) -> f64 {\n    let secs = duration.as_secs_f64();\n    if secs <= f64::EPSILON {\n        f64::EPSILON\n    } else {\n        secs\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract","direct_messages.rs"],"content":"use chrono::{TimeZone, Utc};\nuse kukuri_lib::test_support::application::ports::repositories::DirectMessageRepository;\nuse kukuri_lib::test_support::domain::entities::{MessageDirection, NewDirectMessage};\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::repository::Repository;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\n\nconst OWNER_NPUB: &str =\n    \"npub1contractowner00000000000000000000000000000000000000000000000000000000\";\nconst FRIEND_NPUB: &str =\n    \"npub1contractfriend0000000000000000000000000000000000000000000000000000000\";\n\n#[tokio::test]\nasync fn direct_message_read_receipts_sync_across_devices() {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"create pool\");\n    let repository = SqliteRepository::new(pool);\n    repository.initialize().await.expect(\"initialize schema\");\n\n    let base_timestamp = 1_700_000_000_000i64;\n    for (index, content) in [\"first\", \"second\", \"third\"].iter().enumerate() {\n        let created_at = Utc\n            .timestamp_millis_opt(base_timestamp + (index as i64 * 1_000))\n            .single()\n            .expect(\"valid timestamp\");\n        let new_message = NewDirectMessage {\n            owner_npub: OWNER_NPUB.to_string(),\n            conversation_npub: FRIEND_NPUB.to_string(),\n            sender_npub: FRIEND_NPUB.to_string(),\n            recipient_npub: OWNER_NPUB.to_string(),\n            event_id: Some(format!(\"evt-{index}\")),\n            client_message_id: Some(format!(\"client-{index}\")),\n            payload_cipher_base64: format!(\"cipher-{content}\"),\n            created_at,\n            delivered: true,\n            direction: MessageDirection::Inbound,\n        };\n        let stored = repository\n            .insert_direct_message(&new_message)\n            .await\n            .expect(\"insert direct message\");\n        repository\n            .upsert_conversation_metadata(\n                OWNER_NPUB,\n                FRIEND_NPUB,\n                stored.id,\n                stored.created_at.timestamp_millis(),\n            )\n            .await\n            .expect(\"upsert metadata\");\n    }\n\n    let initial = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list conversations\");\n    assert_eq!(initial.items.len(), 1);\n    assert_eq!(\n        initial.items[0].unread_count, 3,\n        \"all inbound messages start unread\"\n    );\n    assert_eq!(\n        initial.items[0].last_read_at, 0,\n        \"last_read_at defaults to zero before any device reads\"\n    );\n\n    let second_message_timestamp = base_timestamp + 1_000;\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, second_message_timestamp)\n        .await\n        .expect(\"mark read up to second message\");\n    let after_second = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after read\");\n    assert_eq!(\n        after_second.items[0].last_read_at, second_message_timestamp,\n        \"read receipt should store the latest acknowledged timestamp\"\n    );\n    assert_eq!(\n        after_second.items[0].unread_count, 1,\n        \"only the newest inbound message remains unread\"\n    );\n\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, base_timestamp + 500)\n        .await\n        .expect(\"stale read marker should be ignored\");\n    let after_stale = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after stale mark\");\n    assert_eq!(\n        after_stale.items[0].last_read_at, second_message_timestamp,\n        \"stale timestamps must not overwrite newer read positions\"\n    );\n    assert_eq!(after_stale.items[0].unread_count, 1);\n\n    let final_timestamp = base_timestamp + 2_000;\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, final_timestamp)\n        .await\n        .expect(\"mark all messages read\");\n    let final_state = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after all read\");\n    assert_eq!(final_state.items[0].unread_count, 0);\n    assert_eq!(final_state.items[0].last_read_at, final_timestamp);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract","nip10.rs"],"content":"use kukuri_lib::contract_testing::validate_nip10_tags;\r\nuse serde::Deserialize;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Nip10Case {\n    name: String,\n    #[serde(rename = \"description\")]\n    _description: Option<String>,\n    tags: Vec<Vec<String>>,\n    expected: bool,\n}\n\r\n#[test]\r\nfn nip10_contract_cases_align_with_rust_validation() {\r\n    let data = include_str!(concat!(\r\n        env!(\"CARGO_MANIFEST_DIR\"),\r\n        \"/../testdata/nip10_contract_cases.json\"\r\n    ));\r\n    let cases: Vec<Nip10Case> =\r\n        serde_json::from_str(data).expect(\"nip10 contract cases json should parse\");\r\n\r\n    for case in cases {\r\n        let result = validate_nip10_tags(case.tags.clone());\r\n        if case.expected {\r\n            assert!(\r\n                result.is_ok(),\r\n                \"case '{}' expected success but got error: {:?}\",\r\n                case.name,\r\n                result.err()\r\n            );\r\n        } else {\r\n            assert!(\r\n                result.is_err(),\r\n                \"case '{}' expected failure but succeeded\",\r\n                case.name\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract.rs"],"content":"#[path = \"contract/direct_messages.rs\"]\nmod direct_messages;\n#[path = \"contract/nip10.rs\"]\nmod nip10;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","event_manager_integration.rs"],"content":"#[path = \"integration/event/manager/mod.rs\"]\nmod manager;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","access_control_p2p_invite.rs"],"content":"use async_trait::async_trait;\nuse kukuri_lib::test_support::application::ports::cache::PostCache;\nuse kukuri_lib::test_support::application::ports::group_key_store::{\n    GroupKeyEntry, GroupKeyRecord, GroupKeyStore,\n};\nuse kukuri_lib::test_support::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse kukuri_lib::test_support::application::ports::key_manager::{KeyManager, KeyPair};\nuse kukuri_lib::test_support::application::ports::repositories::{\n    BookmarkRepository, FollowListSort, PostRepository, UserCursorPage, UserRepository,\n};\nuse kukuri_lib::test_support::application::services::event_service::EventServiceTrait;\nuse kukuri_lib::test_support::application::services::{AccessControlService, JoinRequestInput, PostService};\nuse kukuri_lib::test_support::domain::entities::{Event, Post, User};\nuse kukuri_lib::test_support::domain::p2p::user_topic_id;\nuse kukuri_lib::test_support::domain::value_objects::{EncryptedPostPayload, EventId};\nuse kukuri_lib::test_support::infrastructure::crypto::DefaultSignatureService;\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::test_support::shared::error::AppError;\nuse nostr_sdk::prelude::{Keys, ToBech32};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse tokio::sync::{Mutex, RwLock};\n\n#[derive(Clone)]\nstruct TestKeyManager {\n    keypair: KeyPair,\n}\n\nimpl TestKeyManager {\n    fn new(keypair: KeyPair) -> Self {\n        Self { keypair }\n    }\n}\n\n#[async_trait]\nimpl KeyManager for TestKeyManager {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n        Err(AppError::NotImplemented(\"generate_keypair\".into()))\n    }\n\n    async fn import_private_key(&self, _nsec: &str) -> Result<KeyPair, AppError> {\n        Err(AppError::NotImplemented(\"import_private_key\".into()))\n    }\n\n    async fn export_private_key(&self, _npub: &str) -> Result<String, AppError> {\n        Err(AppError::NotImplemented(\"export_private_key\".into()))\n    }\n\n    async fn get_public_key(&self, _npub: &str) -> Result<String, AppError> {\n        Err(AppError::NotImplemented(\"get_public_key\".into()))\n    }\n\n    async fn store_keypair(&self, _keypair: &KeyPair) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"store_keypair\".into()))\n    }\n\n    async fn delete_keypair(&self, _npub: &str) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"delete_keypair\".into()))\n    }\n\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n        Ok(vec![self.keypair.npub.clone()])\n    }\n\n    async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        Ok(self.keypair.clone())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestGroupKeyStore {\n    records: Arc<RwLock<Vec<GroupKeyRecord>>>,\n}\n\n#[async_trait]\nimpl GroupKeyStore for TestGroupKeyStore {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        records.retain(|entry| {\n            !(entry.topic_id == record.topic_id\n                && entry.scope == record.scope\n                && entry.epoch == record.epoch)\n        });\n        records.push(record);\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .find(|entry| {\n                entry.topic_id == topic_id && entry.scope == scope && entry.epoch == epoch\n            })\n            .cloned())\n    }\n\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .filter(|entry| entry.topic_id == topic_id && entry.scope == scope)\n            .max_by_key(|entry| entry.epoch)\n            .cloned())\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .map(|entry| GroupKeyEntry {\n                topic_id: entry.topic_id.clone(),\n                scope: entry.scope.clone(),\n                epoch: entry.epoch,\n                stored_at: entry.stored_at,\n            })\n            .collect())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestJoinRequestStore {\n    records: Arc<RwLock<HashMap<String, HashMap<String, JoinRequestRecord>>>>,\n    invite_usage: Arc<RwLock<HashMap<String, HashMap<String, InviteUsageRecord>>>>,\n}\n\n#[async_trait]\nimpl JoinRequestStore for TestJoinRequestStore {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        let owner = records.entry(owner_pubkey.to_string()).or_default();\n        owner.insert(record.event.id.clone(), record);\n        Ok(())\n    }\n\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .map(|owner| owner.values().cloned().collect())\n            .unwrap_or_default())\n    }\n\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .and_then(|owner| owner.get(event_id).cloned()))\n    }\n\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        if let Some(owner) = records.get_mut(owner_pubkey) {\n            owner.remove(event_id);\n        }\n        Ok(())\n    }\n\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError> {\n        let records = self.invite_usage.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .and_then(|owner| owner.get(invite_event_id).cloned()))\n    }\n\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError> {\n        let mut records = self.invite_usage.write().await;\n        let owner = records.entry(owner_pubkey.to_string()).or_default();\n        owner.insert(record.invite_event_id.clone(), record);\n        Ok(())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestUserRepository {\n    follows: Arc<RwLock<HashSet<(String, String)>>>,\n}\n\nimpl TestUserRepository {\n    async fn seed_follow(&self, follower: &str, followed: &str) {\n        let mut follows = self.follows.write().await;\n        follows.insert((follower.to_string(), followed.to_string()));\n    }\n}\n\n#[async_trait]\nimpl UserRepository for TestUserRepository {\n    async fn create_user(&self, _user: &User) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"create_user\".into()))\n    }\n\n    async fn get_user(&self, _npub: &str) -> Result<Option<User>, AppError> {\n        Err(AppError::NotImplemented(\"get_user\".into()))\n    }\n\n    async fn get_user_by_pubkey(&self, _pubkey: &str) -> Result<Option<User>, AppError> {\n        Err(AppError::NotImplemented(\"get_user_by_pubkey\".into()))\n    }\n\n    async fn search_users(&self, _query: &str, _limit: usize) -> Result<Vec<User>, AppError> {\n        Err(AppError::NotImplemented(\"search_users\".into()))\n    }\n\n    async fn update_user(&self, _user: &User) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"update_user\".into()))\n    }\n\n    async fn delete_user(&self, _npub: &str) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"delete_user\".into()))\n    }\n\n    async fn get_followers_paginated(\n        &self,\n        _npub: &str,\n        _cursor: Option<&str>,\n        _limit: usize,\n        _sort: FollowListSort,\n        _search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        Err(AppError::NotImplemented(\"get_followers_paginated\".into()))\n    }\n\n    async fn get_following_paginated(\n        &self,\n        _npub: &str,\n        _cursor: Option<&str>,\n        _limit: usize,\n        _sort: FollowListSort,\n        _search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        Err(AppError::NotImplemented(\"get_following_paginated\".into()))\n    }\n\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let mut follows = self.follows.write().await;\n        Ok(follows.insert((\n            follower_pubkey.to_string(),\n            followed_pubkey.to_string(),\n        )))\n    }\n\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let mut follows = self.follows.write().await;\n        Ok(follows.remove(&(\n            follower_pubkey.to_string(),\n            followed_pubkey.to_string(),\n        )))\n    }\n\n    async fn list_following_pubkeys(\n        &self,\n        follower_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let follows = self.follows.read().await;\n        Ok(follows\n            .iter()\n            .filter_map(|(follower, followed)| {\n                if follower == follower_pubkey {\n                    Some(followed.clone())\n                } else {\n                    None\n                }\n            })\n            .collect())\n    }\n\n    async fn list_follower_pubkeys(\n        &self,\n        followed_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let follows = self.follows.read().await;\n        Ok(follows\n            .iter()\n            .filter_map(|(follower, followed)| {\n                if followed == followed_pubkey {\n                    Some(follower.clone())\n                } else {\n                    None\n                }\n            })\n            .collect())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestGossipService {\n    joined: Arc<RwLock<HashSet<String>>>,\n    broadcasts: Arc<RwLock<Vec<(String, Event)>>>,\n}\n\nimpl TestGossipService {\n    async fn broadcasts(&self) -> Vec<(String, Event)> {\n        self.broadcasts.read().await.clone()\n    }\n}\n\n#[async_trait]\nimpl kukuri_lib::test_support::infrastructure::p2p::GossipService for TestGossipService {\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.joined.write().await.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.joined.write().await.remove(topic);\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        self.broadcasts\n            .write()\n            .await\n            .push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError> {\n        Err(AppError::NotImplemented(\"subscribe\".into()))\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(self.joined.read().await.iter().cloned().collect())\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Err(AppError::NotImplemented(\"get_topic_peers\".into()))\n    }\n\n    async fn get_topic_stats(\n        &self,\n        _topic: &str,\n    ) -> Result<Option<kukuri_lib::test_support::domain::p2p::TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct TestPostCache {\n    posts: Mutex<HashMap<String, Post>>,\n}\n\n#[async_trait]\nimpl PostCache for TestPostCache {\n    async fn add(&self, post: Post) {\n        self.posts.lock().await.insert(post.id.clone(), post);\n    }\n\n    async fn get(&self, id: &str) -> Option<Post> {\n        self.posts.lock().await.get(id).cloned()\n    }\n\n    async fn remove(&self, id: &str) -> Option<Post> {\n        self.posts.lock().await.remove(id)\n    }\n\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        let posts = self.posts.lock().await;\n        let mut filtered: Vec<Post> = posts\n            .values()\n            .filter(|post| post.topic_id == topic_id)\n            .cloned()\n            .collect();\n        filtered.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n        if limit == usize::MAX {\n            return filtered;\n        }\n        filtered.into_iter().take(limit).collect()\n    }\n\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        let mut guard = self.posts.lock().await;\n        guard.retain(|_, post| post.topic_id != topic_id);\n        for post in posts {\n            guard.insert(post.id.clone(), post);\n        }\n    }\n\n    async fn invalidate_topic(&self, topic_id: &str) {\n        let mut guard = self.posts.lock().await;\n        guard.retain(|_, post| post.topic_id != topic_id);\n    }\n}\n\n#[derive(Default)]\nstruct TestEventService;\n\n#[async_trait]\nimpl EventServiceTrait for TestEventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, _content: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn publish_topic_post(\n        &self,\n        _topic_id: &str,\n        _content: &str,\n        _reply_to: Option<&str>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn send_reaction(&self, _event_id: &str, _reaction: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn update_metadata(\n        &self,\n        _metadata: kukuri_lib::test_support::presentation::dto::event::NostrMetadataDto,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn subscribe_to_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn subscribe_to_user(&self, _pubkey: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        Ok(None)\n    }\n\n    async fn boost_post(&self, _event_id: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn delete_events(\n        &self,\n        _event_ids: Vec<String>,\n        _reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn set_default_p2p_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn list_subscriptions(\n        &self,\n    ) -> Result<Vec<kukuri_lib::test_support::application::services::SubscriptionRecord>, AppError>\n    {\n        Ok(vec![])\n    }\n}\n\nfn make_keypair() -> KeyPair {\n    let keys = Keys::generate();\n    let public_key = keys.public_key().to_string();\n    let private_key = keys.secret_key().display_secret().to_string();\n    let npub = keys\n        .public_key()\n        .to_bech32()\n        .unwrap_or_else(|_| public_key.clone());\n    let nsec = format!(\"nsec1{private_key}\");\n    KeyPair {\n        public_key,\n        private_key,\n        npub,\n        nsec,\n    }\n}\n\nasync fn setup_post_service_with_group_store(\n    group_key_store: Arc<dyn GroupKeyStore>,\n    event_service: Arc<dyn EventServiceTrait>,\n) -> (PostService, Arc<SqliteRepository>) {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"failed to create pool\");\n\n    sqlx::query(\n        r#\"\n        CREATE TABLE IF NOT EXISTS bookmarks (\n            id TEXT PRIMARY KEY,\n            user_pubkey TEXT NOT NULL,\n            post_id TEXT NOT NULL,\n            created_at INTEGER NOT NULL,\n            UNIQUE(user_pubkey, post_id)\n        )\n        \"#,\n    )\n    .execute(pool.get_pool())\n    .await\n    .expect(\"failed to create bookmarks table\");\n\n    let repository = Arc::new(SqliteRepository::new(pool));\n    repository\n        .initialize()\n        .await\n        .expect(\"failed to initialize repository schema\");\n\n    let cache: Arc<dyn PostCache> = Arc::new(TestPostCache::default());\n\n    let service = PostService::new(\n        Arc::clone(&repository) as Arc<dyn PostRepository>,\n        Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n        event_service,\n        cache,\n        group_key_store,\n    );\n\n    (service, repository)\n}\n\n#[tokio::test]\nasync fn p2p_only_invite_join_key_envelope_encrypted_post_flow() {\n    let inviter_keypair = make_keypair();\n    let requester_keypair = make_keypair();\n\n    let inviter_key_manager = Arc::new(TestKeyManager::new(inviter_keypair.clone()));\n    let requester_key_manager = Arc::new(TestKeyManager::new(requester_keypair.clone()));\n\n    let inviter_group_keys = Arc::new(TestGroupKeyStore::default());\n    let requester_group_keys = Arc::new(TestGroupKeyStore::default());\n    let inviter_join_requests = Arc::new(TestJoinRequestStore::default());\n    let requester_join_requests = Arc::new(TestJoinRequestStore::default());\n    let user_repository = Arc::new(TestUserRepository::default());\n\n    let signature_service = Arc::new(DefaultSignatureService::new());\n    let inviter_gossip = Arc::new(TestGossipService::default());\n    let requester_gossip = Arc::new(TestGossipService::default());\n\n    let inviter_service = AccessControlService::new(\n        inviter_key_manager,\n        Arc::clone(&inviter_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&inviter_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        inviter_gossip.clone(),\n    );\n    let requester_service = AccessControlService::new(\n        requester_key_manager,\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&requester_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        requester_gossip.clone(),\n    );\n\n    let topic_id = \"kukuri:topic-invite\";\n    let invite_json = inviter_service\n        .issue_invite(topic_id, Some(900), Some(1), Some(\"p2p-e2e\".into()))\n        .await\n        .expect(\"issue invite\");\n\n    let join_result = requester_service\n        .request_join(JoinRequestInput {\n            topic_id: None,\n            scope: None,\n            invite_event_json: Some(invite_json.clone()),\n            target_pubkey: None,\n            broadcast_to_topic: false,\n        })\n        .await\n        .expect(\"request join\");\n\n    let inviter_topic = user_topic_id(&inviter_keypair.public_key);\n    assert!(\n        join_result.sent_topics.contains(&inviter_topic),\n        \"join request should target inviter topic\"\n    );\n\n    let requester_broadcasts = requester_gossip.broadcasts().await;\n    let join_event = requester_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39022)\n        .map(|(_, event)| event.clone())\n        .expect(\"join request event broadcasted\");\n\n    inviter_service\n        .handle_incoming_event(&join_event)\n        .await\n        .expect(\"inviter handles join request\");\n\n    let pending = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending join requests\");\n    assert_eq!(pending.len(), 1);\n\n    inviter_service\n        .approve_join_request(&join_event.id)\n        .await\n        .expect(\"approve join request\");\n    let pending_after = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending cleared\");\n    assert!(pending_after.is_empty());\n\n    let inviter_broadcasts = inviter_gossip.broadcasts().await;\n    let key_envelope_event = inviter_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39020)\n        .map(|(_, event)| event.clone())\n        .expect(\"key envelope broadcasted\");\n\n    requester_service\n        .handle_incoming_event(&key_envelope_event)\n        .await\n        .expect(\"requester stores key envelope\");\n\n    let stored_key = requester_group_keys\n        .get_latest_key(topic_id, \"invite\")\n        .await\n        .expect(\"load key\")\n        .expect(\"invite key stored\");\n    assert_eq!(stored_key.scope, \"invite\");\n\n    let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n    let (post_service, repository) = setup_post_service_with_group_store(\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        event_service,\n    )\n    .await;\n\n    let author = User::new(requester_keypair.npub.clone(), requester_keypair.public_key.clone());\n    let created = post_service\n        .create_post(\n            \"p2p invite encrypted post\".into(),\n            author,\n            topic_id.to_string(),\n            Some(\"invite\".into()),\n        )\n        .await\n        .expect(\"create encrypted post\");\n\n    assert!(created.is_encrypted);\n    assert_eq!(created.scope.as_deref(), Some(\"invite\"));\n    assert_eq!(created.epoch, Some(stored_key.epoch));\n    assert_eq!(created.content, \"p2p invite encrypted post\");\n\n    let stored = repository\n        .get_post(&created.id)\n        .await\n        .expect(\"fetch stored post\")\n        .expect(\"stored post exists\");\n    assert_ne!(stored.content, \"p2p invite encrypted post\");\n    let payload =\n        EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n    assert_eq!(payload.scope, \"invite\");\n    assert_eq!(payload.epoch, stored_key.epoch);\n}\n\n#[tokio::test]\nasync fn p2p_only_friend_plus_join_key_envelope_encrypted_post_flow() {\n    let inviter_keypair = make_keypair();\n    let requester_keypair = make_keypair();\n    let friend_keypair = make_keypair();\n\n    let inviter_key_manager = Arc::new(TestKeyManager::new(inviter_keypair.clone()));\n    let requester_key_manager = Arc::new(TestKeyManager::new(requester_keypair.clone()));\n\n    let inviter_group_keys = Arc::new(TestGroupKeyStore::default());\n    let requester_group_keys = Arc::new(TestGroupKeyStore::default());\n    let inviter_join_requests = Arc::new(TestJoinRequestStore::default());\n    let requester_join_requests = Arc::new(TestJoinRequestStore::default());\n    let user_repository = Arc::new(TestUserRepository::default());\n\n    user_repository\n        .seed_follow(&inviter_keypair.public_key, &friend_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&friend_keypair.public_key, &inviter_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&friend_keypair.public_key, &requester_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&requester_keypair.public_key, &friend_keypair.public_key)\n        .await;\n\n    let signature_service = Arc::new(DefaultSignatureService::new());\n    let inviter_gossip = Arc::new(TestGossipService::default());\n    let requester_gossip = Arc::new(TestGossipService::default());\n\n    let inviter_service = AccessControlService::new(\n        inviter_key_manager,\n        Arc::clone(&inviter_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&inviter_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        inviter_gossip.clone(),\n    );\n    let requester_service = AccessControlService::new(\n        requester_key_manager,\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&requester_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        requester_gossip.clone(),\n    );\n\n    let topic_id = \"kukuri:topic-friend-plus\";\n\n    let join_result = requester_service\n        .request_join(JoinRequestInput {\n            topic_id: Some(topic_id.to_string()),\n            scope: Some(\"friend_plus\".into()),\n            invite_event_json: None,\n            target_pubkey: Some(inviter_keypair.public_key.clone()),\n            broadcast_to_topic: false,\n        })\n        .await\n        .expect(\"request join\");\n\n    let inviter_topic = user_topic_id(&inviter_keypair.public_key);\n    assert!(\n        join_result.sent_topics.contains(&inviter_topic),\n        \"join request should target inviter topic\"\n    );\n\n    let requester_broadcasts = requester_gossip.broadcasts().await;\n    let join_event = requester_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39022)\n        .map(|(_, event)| event.clone())\n        .expect(\"join request event broadcasted\");\n\n    inviter_service\n        .handle_incoming_event(&join_event)\n        .await\n        .expect(\"inviter handles join request\");\n\n    let pending = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending join requests\");\n    assert_eq!(pending.len(), 1);\n    assert_eq!(pending[0].scope, \"friend_plus\");\n\n    inviter_service\n        .approve_join_request(&join_event.id)\n        .await\n        .expect(\"approve join request\");\n\n    let inviter_broadcasts = inviter_gossip.broadcasts().await;\n    let key_envelope_event = inviter_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39020)\n        .map(|(_, event)| event.clone())\n        .expect(\"key envelope broadcasted\");\n\n    requester_service\n        .handle_incoming_event(&key_envelope_event)\n        .await\n        .expect(\"requester stores key envelope\");\n\n    let stored_key = requester_group_keys\n        .get_latest_key(topic_id, \"friend_plus\")\n        .await\n        .expect(\"load key\")\n        .expect(\"friend_plus key stored\");\n    assert_eq!(stored_key.scope, \"friend_plus\");\n\n    let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n    let (post_service, repository) = setup_post_service_with_group_store(\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        event_service,\n    )\n    .await;\n\n    let author = User::new(requester_keypair.npub.clone(), requester_keypair.public_key.clone());\n    let created = post_service\n        .create_post(\n            \"p2p friend_plus encrypted post\".into(),\n            author,\n            topic_id.to_string(),\n            Some(\"friend_plus\".into()),\n        )\n        .await\n        .expect(\"create encrypted post\");\n\n    assert!(created.is_encrypted);\n    assert_eq!(created.scope.as_deref(), Some(\"friend_plus\"));\n    assert_eq!(created.epoch, Some(stored_key.epoch));\n    assert_eq!(created.content, \"p2p friend_plus encrypted post\");\n\n    let stored = repository\n        .get_post(&created.id)\n        .await\n        .expect(\"fetch stored post\")\n        .expect(\"stored post exists\");\n    assert_ne!(stored.content, \"p2p friend_plus encrypted post\");\n    let payload =\n        EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n    assert_eq!(payload.scope, \"friend_plus\");\n    assert_eq!(payload.epoch, stored_key.epoch);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","event","manager","mod.rs"],"content":"use std::path::Path;\nuse std::sync::Arc;\n\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse kukuri_lib::test_support::application::ports::event_topic_store::EventTopicStore;\nuse kukuri_lib::test_support::application::ports::key_manager::KeyManager;\nuse kukuri_lib::test_support::domain::entities::Event as DomainEvent;\nuse kukuri_lib::test_support::infrastructure::crypto::DefaultKeyManager;\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::repository::Repository;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::test_support::infrastructure::event::{\n    EventManagerHandle, LegacyEventManagerHandle, RepositoryEventTopicStore,\n};\nuse kukuri_lib::test_support::infrastructure::p2p::GossipService;\nuse kukuri_lib::test_support::shared::error::AppError;\nuse nostr_sdk::prelude::*;\nuse sqlx::Row;\nuse tempfile::TempDir;\nuse tokio::sync::Mutex;\n\n#[tokio::test]\nasync fn handle_p2p_event_persists_rows() -> Result<()> {\n    let ctx = TestContext::setup().await?;\n\n    let keys = Keys::generate();\n    let event = EventBuilder::text_note(\"phase5-incoming-event\")\n        .tag(Tag::hashtag(DEFAULT_PUBLIC_TOPIC_ID))\n        .sign_with_keys(&keys)?;\n\n    ctx.manager.handle_p2p_event(event.clone()).await?;\n\n    let stored = sqlx::query(\"SELECT content FROM events WHERE event_id = ?1\")\n        .bind(event.id.to_hex())\n        .fetch_optional(ctx.pool.get_pool())\n        .await?;\n    let row = stored.expect(\"event row should exist after handler\");\n    let stored_content: String = row.try_get(\"content\")?;\n    assert_eq!(stored_content, \"phase5-incoming-event\");\n\n    let topics = sqlx::query(\"SELECT topic_id FROM event_topics WHERE event_id = ?1\")\n        .bind(event.id.to_hex())\n        .fetch_all(ctx.pool.get_pool())\n        .await?;\n    let topic_ids: Vec<String> = topics\n        .iter()\n        .map(|row| {\n            row.try_get::<String, _>(\"topic_id\")\n                .expect(\"topic id column\")\n        })\n        .collect();\n    assert!(\n        topic_ids\n            .iter()\n            .any(|topic| topic == DEFAULT_PUBLIC_TOPIC_ID),\n        \"expected hashtag mapping for public\"\n    );\n\n    ctx.pool.close().await;\n    Ok(())\n}\n\n#[tokio::test]\nasync fn publish_topic_post_broadcasts_and_links_topics() -> Result<()> {\n    let ctx = TestContext::setup().await?;\n    let manager: Arc<dyn EventManagerHandle> = ctx.manager.clone();\n\n    manager\n        .set_default_p2p_topics(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])\n        .await;\n\n    unsafe {\n        std::env::set_var(\"KUKURI_ALLOW_NO_RELAY\", \"1\");\n    }\n    let _event_id = manager\n        .publish_topic_post(\n            DEFAULT_PUBLIC_TOPIC_ID,\n            \"phase5-topic-body\",\n            None,\n            None,\n            None,\n        )\n        .await?;\n\n    let joined = ctx.gossip.joined_topics().await;\n    assert!(joined.iter().any(|topic| topic == DEFAULT_PUBLIC_TOPIC_ID));\n\n    unsafe {\n        std::env::remove_var(\"KUKURI_ALLOW_NO_RELAY\");\n    }\n    ctx.pool.close().await;\n    Ok(())\n}\n\nstruct TestContext {\n    _temp_dir: TempDir,\n    pool: ConnectionPool,\n    _repository: Arc<SqliteRepository>,\n    manager: Arc<LegacyEventManagerHandle>,\n    gossip: Arc<RecordingGossipService>,\n}\n\nimpl TestContext {\n    async fn setup() -> Result<Self> {\n        let temp_dir = tempfile::tempdir()?;\n        let db_path = temp_dir.path().join(\"event_manager.db\");\n        let db_url = format_sqlite_url(&db_path);\n        let pool = ConnectionPool::new(&db_url).await?;\n\n        let repository = Arc::new(SqliteRepository::new(pool.clone()));\n        repository.initialize().await?;\n\n        let manager = Arc::new(LegacyEventManagerHandle::new_with_connection_pool(\n            pool.clone(),\n        ));\n        let event_manager = manager.as_event_manager();\n\n        let key_manager = DefaultKeyManager::new();\n        key_manager.generate_keypair().await?;\n        event_manager\n            .initialize_with_key_manager(&key_manager)\n            .await?;\n\n        let gossip = Arc::new(RecordingGossipService::default());\n        let gossip_trait: Arc<dyn GossipService> = gossip.clone();\n        manager.set_gossip_service(gossip_trait).await;\n\n        let topic_store: Arc<dyn EventTopicStore> =\n            Arc::new(RepositoryEventTopicStore::new(repository.clone()));\n        manager.set_event_topic_store(topic_store).await;\n\n        Ok(Self {\n            _temp_dir: temp_dir,\n            pool,\n            _repository: repository,\n            manager,\n            gossip,\n        })\n    }\n}\n\n#[derive(Default)]\nstruct RecordingGossipService {\n    joined_topics: Mutex<Vec<String>>,\n    broadcasts: Mutex<Vec<(String, DomainEvent)>>,\n    messages: Mutex<Vec<(String, Vec<u8>)>>,\n}\n\nimpl RecordingGossipService {\n    async fn joined_topics(&self) -> Vec<String> {\n        self.joined_topics.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl GossipService for RecordingGossipService {\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.joined_topics.lock().await.push(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &DomainEvent) -> Result<(), AppError> {\n        self.broadcasts\n            .lock()\n            .await\n            .push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<DomainEvent>, AppError> {\n        let (_tx, rx) = tokio::sync::mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(self.joined_topics().await)\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_stats(\n        &self,\n        _topic: &str,\n    ) -> Result<Option<kukuri_lib::test_support::domain::p2p::TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError> {\n        self.messages\n            .lock()\n            .await\n            .push((topic.to_string(), message.to_vec()));\n        Ok(())\n    }\n}\n\nfn format_sqlite_url(path: &Path) -> String {\n    let mut value = path.to_string_lossy().to_string();\n    if cfg!(windows) {\n        value = value.replace('\\\\', \"/\");\n    }\n    format!(\"sqlite://{}?mode=rwc\", value)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","offline","mod.rs"],"content":"#[path = \"../../common/offline_support.rs\"]\nmod offline_support;\n\nuse chrono::{Duration, Utc};\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait,\n};\nuse kukuri_lib::test_support::domain::entities::offline::{CacheMetadataUpdate, SyncStatusUpdate};\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::test_support::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflinePayload, SyncStatus,\n};\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\nuse offline_support::{\n    OfflineTestContext, TEST_PUBKEY_HEX, sample_save_params, setup_offline_service,\n};\nuse serde_json::Value;\nuse std::sync::Arc;\n\n#[tokio::test]\nasync fn save_action_persists_record() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let saved = service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save action\");\n\n    assert_eq!(saved.action.user_pubkey.as_hex(), TEST_PUBKEY_HEX);\n    assert_eq!(\n        saved\n            .action\n            .target_id\n            .as_ref()\n            .map(ToString::to_string)\n            .as_deref(),\n        Some(\"post123\")\n    );\n    assert_eq!(saved.action.action_type.as_str(), \"create_post\");\n\n    let (count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM offline_actions\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"offline_actions count\");\n    assert_eq!(count, 1);\n}\n\n#[tokio::test]\nasync fn list_actions_applies_sync_filter() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let mut second_params = sample_save_params();\n    second_params.entity_id = EntityId::new(\"post124\".into()).expect(\"entity id\");\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save first\");\n    let second = service\n        .save_action(second_params)\n        .await\n        .expect(\"save second\");\n\n    sqlx::query(\"UPDATE offline_actions SET is_synced = 1 WHERE local_id = ?\")\n        .bind(second.local_id.as_str())\n        .execute(&pool)\n        .await\n        .expect(\"mark synced\");\n\n    let synced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(true),\n            limit: None,\n        })\n        .await\n        .expect(\"list synced\");\n    assert_eq!(synced.len(), 1);\n\n    let unsynced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .expect(\"list unsynced\");\n    assert_eq!(unsynced.len(), 1);\n}\n\n#[tokio::test]\nasync fn sync_actions_marks_records_and_enqueues() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save action\");\n\n    let result = service\n        .sync_actions(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"))\n        .await\n        .expect(\"sync actions\");\n    assert_eq!(result.synced_count, 1);\n    assert_eq!(result.failed_count, 0);\n\n    let (is_synced,): (i64,) = sqlx::query_as(\"SELECT is_synced FROM offline_actions LIMIT 1\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"synced flag\");\n    assert_eq!(is_synced, 1);\n\n    let (queue_count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM sync_queue\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"queue count\");\n    assert_eq!(queue_count, 1);\n}\n\n#[tokio::test]\nasync fn cache_metadata_upsert_and_cleanup() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"cache:topics\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"topics\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\"version\": 1})),\n        expiry: Some(Utc::now() + Duration::seconds(1)),\n        is_stale: Some(false),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n\n    service\n        .upsert_cache_metadata(update)\n        .await\n        .expect(\"upsert cache\");\n\n    sqlx::query(\n        r#\"\n        UPDATE cache_metadata\n        SET expiry_time = expiry_time - 10\n        WHERE cache_key = ?1\n        \"#,\n    )\n    .bind(\"cache:topics\")\n    .execute(&pool)\n    .await\n    .expect(\"force expiry for cleanup test\");\n\n    let removed = service.cleanup_expired_cache().await.expect(\"cleanup\");\n    assert_eq!(removed, 1);\n\n    let (remaining,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM cache_metadata\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"remaining cache rows\");\n    assert_eq!(remaining, 0);\n}\n\n#[tokio::test]\nasync fn cache_status_returns_metadata_summary() {\n    let OfflineTestContext { service, .. } = setup_offline_service().await;\n\n    let first_update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"sync_queue::offline_actions\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"sync_queue\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\n            \"cacheType\": \"offline_actions\",\n            \"requestedAt\": \"2025-11-09T00:00:00Z\",\n            \"requestedBy\": \"npub1first\"\n        })),\n        expiry: None,\n        is_stale: Some(true),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n    service\n        .upsert_cache_metadata(first_update)\n        .await\n        .expect(\"upsert first metadata\");\n\n    tokio::time::sleep(std::time::Duration::from_millis(5)).await;\n\n    let second_update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"sync_queue::trending\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"sync_queue\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\n            \"cacheType\": \"trending\",\n            \"requestedAt\": \"2025-11-09T00:00:01Z\",\n            \"requestedBy\": \"npub1latest\",\n            \"queueItemId\": 42\n        })),\n        expiry: None,\n        is_stale: Some(true),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n    service\n        .upsert_cache_metadata(second_update)\n        .await\n        .expect(\"upsert second metadata\");\n\n    let snapshot = service.cache_status().await.expect(\"cache status\");\n    let queue_summary = snapshot\n        .cache_types\n        .into_iter()\n        .find(|status| status.cache_type.as_str() == \"sync_queue\")\n        .expect(\"sync_queue summary\");\n\n    assert_eq!(queue_summary.item_count, 2);\n    assert!(queue_summary.is_stale);\n    let metadata = queue_summary.metadata.expect(\"metadata present\");\n    assert_eq!(\n        metadata.get(\"requestedBy\").and_then(|value| value.as_str()),\n        Some(\"npub1latest\")\n    );\n    assert_eq!(\n        metadata.get(\"queueItemId\").and_then(|value| value.as_i64()),\n        Some(42)\n    );\n}\n\n#[tokio::test]\nasync fn update_sync_status_performs_upsert() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let pending = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"pending\"),\n        Some(OfflinePayload::new(Value::String(\"conflict\".into())).expect(\"payload\")),\n        Utc::now(),\n    );\n    service\n        .update_sync_status(pending)\n        .await\n        .expect(\"initial update\");\n\n    let resolved = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"resolved\"),\n        None,\n        Utc::now(),\n    );\n    service\n        .update_sync_status(resolved)\n        .await\n        .expect(\"second update\");\n\n    let (local_version, sync_status, conflict_data): (i64, String, Option<String>) =\n        sqlx::query_as(\n            r#\"\n            SELECT local_version, sync_status, conflict_data\n            FROM sync_status\n            WHERE entity_type = 'post' AND entity_id = 'p1'\n            \"#,\n        )\n        .fetch_one(&pool)\n        .await\n        .expect(\"sync_status row\");\n\n    assert_eq!(local_version, 2);\n    assert_eq!(sync_status, \"resolved\");\n    assert!(conflict_data.is_none());\n}\n\n#[tokio::test]\nasync fn cache_status_reports_per_type() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .upsert_cache_metadata(CacheMetadataUpdate {\n            cache_key: CacheKey::new(\"cache:posts:1\".into()).expect(\"cache key\"),\n            cache_type: CacheType::new(\"posts\".into()).expect(\"cache type\"),\n            metadata: Some(serde_json::json!({\"version\": 1})),\n            expiry: None,\n            is_stale: Some(false),\n            doc_version: None,\n            blob_hash: None,\n            payload_bytes: None,\n        })\n        .await\n        .expect(\"upsert posts\");\n\n    service\n        .upsert_cache_metadata(CacheMetadataUpdate {\n            cache_key: CacheKey::new(\"cache:topics:1\".into()).expect(\"cache key\"),\n            cache_type: CacheType::new(\"topics\".into()).expect(\"cache type\"),\n            metadata: None,\n            expiry: Some(Utc::now() + Duration::seconds(60)),\n            is_stale: Some(false),\n            doc_version: None,\n            blob_hash: None,\n            payload_bytes: None,\n        })\n        .await\n        .expect(\"upsert topics\");\n\n    sqlx::query(\"UPDATE cache_metadata SET is_stale = 1 WHERE cache_type = ?\")\n        .bind(\"posts\")\n        .execute(&pool)\n        .await\n        .expect(\"mark posts stale\");\n\n    let status = service.cache_status().await.expect(\"cache status\");\n    assert_eq!(status.total_items, 2);\n    assert_eq!(status.stale_items, 1);\n\n    let mut posts_entry = None;\n    let mut topics_entry = None;\n    for entry in status.cache_types {\n        match entry.cache_type.as_str() {\n            \"posts\" => posts_entry = Some(entry),\n            \"topics\" => topics_entry = Some(entry),\n            _ => {}\n        }\n    }\n\n    let posts = posts_entry.expect(\"posts entry\");\n    assert!(posts.is_stale);\n    let topics = topics_entry.expect(\"topics entry\");\n    assert!(!topics.is_stale);\n}\n\n#[tokio::test]\nasync fn sync_actions_after_reindex_clears_pending() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save first\");\n\n    let mut second = sample_save_params();\n    second.entity_id = EntityId::new(\"post124\".into()).expect(\"entity id\");\n    service.save_action(second).await.expect(\"save second\");\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence.clone());\n    let report = job.reindex_once().await.expect(\"reindex report\");\n    assert_eq!(report.queued_action_count, 2);\n\n    let result = service\n        .sync_actions(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"))\n        .await\n        .expect(\"sync actions\");\n\n    assert_eq!(result.synced_count, 2);\n    assert_eq!(result.pending_count, 0);\n\n    let (unsynced,): (i64,) =\n        sqlx::query_as(\"SELECT COUNT(*) FROM offline_actions WHERE is_synced = 0\")\n            .fetch_one(&pool)\n            .await\n            .expect(\"unsynced count\");\n    assert_eq!(unsynced, 0);\n}\n\nmod recovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","offline","recovery.rs"],"content":"use super::offline_support::{\n    OfflineTestContext, build_params_for_index, sample_save_params, setup_offline_service,\n};\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\n\nuse std::sync::Arc;\n\n#[tokio::test]\nasync fn reindex_job_populates_pending_queue_and_reports() {\n    let OfflineTestContext {\n        service: offline_service,\n        pool,\n    } = setup_offline_service().await;\n\n    let params: SaveOfflineActionParams = sample_save_params();\n    let saved = offline_service.save_action(params).await.unwrap();\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let persistence_trait: Arc<dyn OfflinePersistence> = persistence.clone();\n\n    let job = OfflineReindexJob::with_emitter(None, persistence_trait.clone());\n    let report = job.reindex_once().await.unwrap();\n\n    assert_eq!(report.offline_action_count, 1);\n    assert_eq!(report.queued_action_count, 1);\n    assert_eq!(report.pending_queue_count, 1);\n    assert_eq!(\n        report.queued_offline_action_ids,\n        vec![saved.action.action_id.to_string()]\n    );\n\n    let pending_queue = persistence.list_pending_sync_queue().await.unwrap();\n    assert_eq!(pending_queue.len(), 1);\n\n    let unsynced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .unwrap();\n    assert_eq!(unsynced.len(), 1);\n}\n\n#[tokio::test]\nasync fn reindex_job_ignores_already_synced_actions() {\n    let OfflineTestContext {\n        service: offline_service,\n        pool,\n    } = setup_offline_service().await;\n\n    let first = offline_service\n        .save_action(build_params_for_index(0))\n        .await\n        .expect(\"save first action\");\n    let second = offline_service\n        .save_action(build_params_for_index(1))\n        .await\n        .expect(\"save second action\");\n\n    sqlx::query(\"UPDATE offline_actions SET is_synced = 1 WHERE local_id = ?\")\n        .bind(second.local_id.as_str())\n        .execute(&pool)\n        .await\n        .expect(\"mark second as synced\");\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence.clone());\n\n    let report = job.reindex_once().await.expect(\"reindex report\");\n\n    assert_eq!(report.offline_action_count, 1);\n    assert_eq!(report.queued_action_count, 1);\n    assert_eq!(report.pending_queue_count, 1);\n    assert_eq!(\n        report.queued_offline_action_ids,\n        vec![first.action.action_id.to_string()]\n    );\n\n    let pending_queue = persistence.list_pending_sync_queue().await.unwrap();\n    assert_eq!(pending_queue.len(), 1);\n    assert_eq!(pending_queue[0].status.as_str(), \"pending\");\n\n    let synced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(true),\n            limit: None,\n        })\n        .await\n        .expect(\"list synced\")\n        .len();\n    assert_eq!(synced, 1);\n\n    let unsynced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .expect(\"list unsynced\")\n        .len();\n    assert_eq!(unsynced, 1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","post_delete_flow.rs"],"content":"use async_trait::async_trait;\nuse kukuri_lib::application::ports::cache::PostCache;\nuse kukuri_lib::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord, GroupKeyStore};\nuse kukuri_lib::application::ports::repositories::{\n    BookmarkRepository, PostRepository, UserRepository,\n};\nuse kukuri_lib::application::services::event_service::EventServiceTrait;\nuse kukuri_lib::application::services::post_service::PostService;\nuse kukuri_lib::application::services::user_service::UserService;\nuse kukuri_lib::application::services::SubscriptionRecord;\nuse kukuri_lib::domain::value_objects::EventId;\nuse kukuri_lib::infrastructure::cache::PostCacheService;\nuse kukuri_lib::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::presentation::dto::event::NostrMetadataDto;\nuse kukuri_lib::shared::error::AppError;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[derive(Default)]\nstruct DummyGroupKeyStore;\n\n#[async_trait]\nimpl GroupKeyStore for DummyGroupKeyStore {\n    async fn store_key(&self, _record: GroupKeyRecord) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        _topic_id: &str,\n        _scope: &str,\n        _epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        Ok(None)\n    }\n\n    async fn get_latest_key(\n        &self,\n        _topic_id: &str,\n        _scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        Ok(None)\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        Ok(Vec::new())\n    }\n}\n\n#[derive(Default)]\nstruct RecordingEventService {\n    deleted_event_ids: Mutex<Vec<String>>,\n}\n\nimpl RecordingEventService {\n    async fn collected_ids(&self) -> Vec<String> {\n        self.deleted_event_ids.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl EventServiceTrait for RecordingEventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, _content: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn publish_topic_post(\n        &self,\n        _topic_id: &str,\n        _content: &str,\n        _reply_to: Option<&str>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn send_reaction(&self, _event_id: &str, _reaction: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn update_metadata(&self, _metadata: NostrMetadataDto) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn subscribe_to_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn subscribe_to_user(&self, _pubkey: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        Ok(None)\n    }\n\n    async fn boost_post(&self, _event_id: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        _reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        let mut guard = self.deleted_event_ids.lock().await;\n        guard.extend(event_ids);\n        Ok(EventId::generate())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn set_default_p2p_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        Ok(vec![])\n    }\n}\n\nconst FOLLOWER_NPUB: &str =\n    \"npub1postdeleteflowfollower00000000000000000000000000000000000000000000000000000\";\nconst FOLLOWER_PUBKEY: &str = \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\nconst AUTHOR_NPUB: &str =\n    \"npub1postdeleteflowauthor0000000000000000000000000000000000000000000000000000000\";\nconst AUTHOR_PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n#[tokio::test]\nasync fn delete_post_is_removed_from_following_and_topic_feeds() {\n    let (post_service, cache, event_service, repository) = setup_post_service().await;\n\n    let user_service = UserService::new(Arc::clone(&repository) as Arc<dyn UserRepository>);\n\n    let follower = user_service\n        .create_user(FOLLOWER_NPUB.to_string(), FOLLOWER_PUBKEY.to_string())\n        .await\n        .expect(\"create follower\");\n    let author = user_service\n        .create_user(AUTHOR_NPUB.to_string(), AUTHOR_PUBKEY.to_string())\n        .await\n        .expect(\"create author\");\n\n    user_service\n        .follow_user(&follower.npub, &author.npub)\n        .await\n        .expect(\"establish follow relationship\");\n\n    let topic_id = \"post-delete-flow-topic\";\n    let first_post = post_service\n        .create_post(\n            \"first post\".into(),\n            author.clone(),\n            topic_id.to_string(),\n            None,\n        )\n        .await\n        .expect(\"create first post\");\n    let second_post = post_service\n        .create_post(\n            \"second post\".into(),\n            author.clone(),\n            topic_id.to_string(),\n            None,\n        )\n        .await\n        .expect(\"create second post\");\n\n    let initial_feed = post_service\n        .list_following_feed(&follower.pubkey, None, 10)\n        .await\n        .expect(\"initial feed\");\n    assert_eq!(initial_feed.items.len(), 2);\n    assert_eq!(initial_feed.items[0].id, second_post.id);\n    assert_eq!(initial_feed.items[1].id, first_post.id);\n\n    let topic_posts = post_service\n        .get_posts_by_topic(topic_id, 10)\n        .await\n        .expect(\"topic posts before deletion\");\n    assert_eq!(topic_posts.len(), 2);\n\n    post_service\n        .delete_post(&first_post.id)\n        .await\n        .expect(\"delete post\");\n\n    let updated_feed = post_service\n        .list_following_feed(&follower.pubkey, None, 10)\n        .await\n        .expect(\"feed after delete\");\n    assert_eq!(updated_feed.items.len(), 1);\n    assert_eq!(updated_feed.items[0].id, second_post.id);\n    assert!(\n        updated_feed\n            .items\n            .iter()\n            .all(|post| post.id != first_post.id),\n        \"deleted post should not appear in following feed\"\n    );\n\n    let refreshed_topic_posts = post_service\n        .get_posts_by_topic(topic_id, 10)\n        .await\n        .expect(\"topic posts after deletion\");\n    assert_eq!(refreshed_topic_posts.len(), 1);\n    assert_eq!(refreshed_topic_posts[0].id, second_post.id);\n\n    assert!(\n        cache.get(&first_post.id).await.is_none(),\n        \"cache entry should be cleared when the post is deleted\"\n    );\n\n    let deleted_ids = event_service.collected_ids().await;\n    assert!(\n        deleted_ids.contains(&first_post.id),\n        \"delete_post should call EventService::delete_events with the removed post id\"\n    );\n}\n\nasync fn setup_post_service(\n) -> (\n    Arc<PostService>,\n    Arc<PostCacheService>,\n    Arc<RecordingEventService>,\n    Arc<SqliteRepository>,\n) {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"create pool\");\n\n    sqlx::query(\n        r#\"\n        CREATE TABLE IF NOT EXISTS bookmarks (\n            id TEXT PRIMARY KEY,\n            user_pubkey TEXT NOT NULL,\n            post_id TEXT NOT NULL,\n            created_at INTEGER NOT NULL,\n            UNIQUE(user_pubkey, post_id)\n        )\n        \"#,\n    )\n    .execute(pool.get_pool())\n    .await\n    .expect(\"create bookmarks table\");\n\n    let repository = Arc::new(SqliteRepository::new(pool));\n    repository\n        .initialize()\n        .await\n        .expect(\"initialize schema\");\n\n    let cache = Arc::new(PostCacheService::new());\n    let event_service = Arc::new(RecordingEventService::default());\n    let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(DummyGroupKeyStore::default());\n\n    let post_service = Arc::new(PostService::new(\n        Arc::clone(&repository) as Arc<dyn PostRepository>,\n        Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n        Arc::clone(&event_service) as Arc<dyn EventServiceTrait>,\n        Arc::clone(&cache) as Arc<dyn PostCache>,\n        group_key_store,\n    ));\n\n    (post_service, cache, event_service, repository)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_auth.rs"],"content":"// Example integration test for authentication\nuse crate::common::fixtures;\nuse crate::common::mocks::{MockKeyManager, MockSecureStorage};\n\n#[tokio::test]\nasync fn test_create_account() {\n    let key_manager = MockKeyManager::new();\n    let secure_storage = MockSecureStorage::new();\n    \n    // Generate keypair\n    let keypair = key_manager.generate_keypair().await;\n    \n    // Store in secure storage\n    secure_storage\n        .store(\"current_npub\", &keypair.npub)\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify storage\n    let stored_npub = secure_storage\n        .retrieve(\"current_npub\")\n        .await\n        .expect(\"Failed to retrieve npub\");\n    \n    assert_eq!(stored_npub, Some(keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_login_with_nsec() {\n    let key_manager = MockKeyManager::new();\n    let nsec = \"nsec1test1234567890abcdefghijklmnopqrstuvwxyz1234567890abcdef\";\n    \n    // Import private key\n    let result = key_manager.import_private_key(nsec).await;\n    \n    assert!(result.is_ok());\n    let keypair = result.unwrap();\n    assert_eq!(keypair.nsec, nsec);\n    \n    // Verify it was stored\n    let npubs = key_manager.list_npubs().await;\n    assert!(npubs.contains(&keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_logout() {\n    let secure_storage = MockSecureStorage::new();\n    \n    // Store npub\n    secure_storage\n        .store(\"current_npub\", \"npub1test\")\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify it exists\n    assert!(secure_storage.exists(\"current_npub\").await);\n    \n    // Logout (delete)\n    secure_storage\n        .delete(\"current_npub\")\n        .await\n        .expect(\"Failed to delete npub\");\n    \n    // Verify it's gone\n    assert!(!secure_storage.exists(\"current_npub\").await);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_gateway.rs"],"content":"use chrono::Utc;\r\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, EventTag};\r\nuse kukuri_lib::domain::entities::EventKind;\r\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\r\nuse kukuri_lib::domain::value_objects::event_gateway::PublicKey;\r\nuse kukuri_lib::domain::value_objects::EventId;\r\nuse kukuri_lib::infrastructure::database::{\r\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository, EventRepository,\r\n};\r\nuse kukuri_lib::infrastructure::event::{\r\n    EventManagerHandle, LegacyEventManagerGateway, LegacyEventManagerHandle,\r\n};\r\nuse sqlx::Row;\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\nuse tempfile::tempdir;\r\n\r\n#[tokio::test]\r\nasync fn gateway_persists_p2p_events_via_event_manager() -> anyhow::Result<()> {\r\n    let temp_dir = tempdir()?;\r\n    let db_path = temp_dir.path().join(\"event_gateway.db\");\r\n    let db_url = format_sqlite_url(&db_path);\r\n    let pool = ConnectionPool::new(&db_url).await?;\r\n\r\n    let repository = Arc::new(SqliteRepository::new(pool.clone()));\r\n    repository.initialize().await?;\r\n\r\n    let event_manager: Arc<dyn EventManagerHandle> =\r\n        Arc::new(LegacyEventManagerHandle::new_with_connection_pool(pool.clone()));\r\n    event_manager\r\n        .set_event_repository(Arc::clone(&repository) as Arc<dyn EventRepository>)\r\n        .await;\r\n\r\n    let gateway = LegacyEventManagerGateway::new(Arc::clone(&event_manager));\r\n\r\n    let event_id =\r\n        EventId::from_hex(&\"a\".repeat(64)).expect(\"64 hex characters produce a valid event id\");\r\n    let public_key =\r\n        PublicKey::from_hex_str(&\"b\".repeat(64)).expect(\"64 hex characters produce a public key\");\r\n    let topic_tag = EventTag::new(\"t\", vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()]).expect(\"tag construction\");\r\n    let signature = \"c\".repeat(128);\r\n    let payload = DomainEvent::new(\r\n        event_id.clone(),\r\n        public_key.clone(),\r\n        EventKind::TextNote,\r\n        Utc::now(),\r\n        \"hello-mainline-gateway\".to_string(),\r\n        vec![topic_tag],\r\n        signature,\r\n    )\r\n    .expect(\"domain event creation\");\r\n\r\n    gateway\r\n        .handle_incoming_event(payload)\r\n        .await\r\n        .expect(\"gateway should accept domain events\");\r\n\r\n    let stored = sqlx::query(\"SELECT event_id, content FROM events WHERE event_id = ?1\")\r\n        .bind(event_id.to_hex())\r\n        .fetch_optional(pool.get_pool())\r\n        .await?;\r\n    assert!(stored.is_some(), \"event record should exist after gateway call\");\r\n    let row = stored.unwrap();\r\n    let stored_id: String = row.try_get(\"event_id\")?;\r\n    let stored_content: String = row.try_get(\"content\")?;\r\n    assert_eq!(stored_id, event_id.to_hex());\r\n    assert_eq!(stored_content, \"hello-mainline-gateway\");\r\n\r\n    let topics = sqlx::query(\"SELECT topic_id FROM event_topics WHERE event_id = ?1\")\r\n        .bind(event_id.to_hex())\r\n        .fetch_all(pool.get_pool())\r\n        .await?;\r\n    assert_eq!(\r\n        topics.len(),\r\n        1,\r\n        \"event_topics should receive a single hashtag mapping\"\r\n    );\r\n    assert_eq!(topics[0].try_get::<String, _>(\"topic_id\")?, DEFAULT_PUBLIC_TOPIC_ID);\r\n\r\n    pool.close().await;\r\n    Ok(())\r\n}\r\n\r\nfn format_sqlite_url(path: &Path) -> String {\r\n    let mut value = path.to_string_lossy().to_string();\r\n    if cfg!(windows) {\r\n        value = value.replace('\\\\', \"/\");\r\n    }\r\n    format!(\"sqlite://{}?mode=rwc\", value)\r\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_service_gateway.rs"],"content":"use async_trait::async_trait;\r\nuse kukuri_lib::application::ports::key_manager::KeyPair;\r\nuse kukuri_lib::application::services::event_service::EventService;\r\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\r\nuse kukuri_lib::domain::value_objects::subscription::{\r\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\r\n};\r\nuse kukuri_lib::domain::entities::Event;\r\nuse kukuri_lib::domain::value_objects::EventId;\r\nuse kukuri_lib::infrastructure::crypto::SignatureService;\r\nuse kukuri_lib::infrastructure::database::EventRepository;\r\nuse kukuri_lib::infrastructure::event::{\r\n    EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\r\n};\r\nuse kukuri_lib::infrastructure::p2p::GossipService;\r\nuse kukuri_lib::infrastructure::p2p::event_distributor::{\r\n    DistributionStrategy, EventDistributor,\r\n};\r\nuse kukuri_lib::presentation::dto::event::NostrMetadataDto;\r\nuse kukuri_lib::shared::error::AppError;\r\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\r\nuse nostr_sdk::prelude::{EventId as NostrEventId, Keys, Metadata, PublicKey};\r\nuse nostr_sdk::Timestamp;\r\nuse serde_json::Value;\r\nuse std::sync::atomic::{AtomicU32, Ordering};\r\nuse std::sync::Arc;\r\nuse tokio::sync::Mutex;\r\n\r\nfn repeating_hex(ch: char) -> String {\r\n    std::iter::repeat(ch).take(64).collect()\r\n}\r\n\r\nfn to_event_id(hex: &str) -> EventId {\r\n    EventId::from_hex(hex).expect(\"valid hex event id\")\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publish_text_note_routes_through_gateway() {\r\n    let (service, manager, _) = build_service().await;\r\n    let event_id = service\r\n        .publish_text_note(\"phase5-text-note\")\r\n        .await\r\n        .expect(\"publish text note\");\r\n\r\n    assert_eq!(\r\n        event_id.to_hex(),\r\n        manager.last_event_id().await.expect(\"event id recorded\")\r\n    );\r\n    let notes = manager.text_notes().await;\r\n    assert_eq!(notes, vec![\"phase5-text-note\".to_string()]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publish_topic_post_converts_topic_and_reply() {\r\n    let (service, manager, _) = build_service().await;\r\n    let reply_id = repeating_hex('b');\r\n    service\n        .publish_topic_post(\n            DEFAULT_PUBLIC_TOPIC_ID,\n            \"phase5 topic body\",\n            Some(&reply_id),\n            None,\n            None,\n        )\n        .await\n        .expect(\"publish topic post\");\n\r\n    let posts = manager.topic_posts().await;\r\n    assert_eq!(posts.len(), 1);\r\n    let post = &posts[0];\r\n    assert_eq!(post.topic_id, DEFAULT_PUBLIC_TOPIC_ID);\r\n    assert_eq!(post.content, \"phase5 topic body\");\r\n    assert_eq!(post.reply_to_hex.as_deref(), Some(&reply_id));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn send_reaction_uses_gateway_and_passes_parameters() {\r\n    let (service, manager, _) = build_service().await;\r\n    let target = repeating_hex('c');\r\n    service\r\n        .send_reaction(&target, \":+1:\")\r\n        .await\r\n        .expect(\"send reaction\");\r\n\r\n    let reactions = manager.reactions().await;\r\n    assert_eq!(reactions, vec![(target, \":+1:\".to_string())]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn update_metadata_flows_through_conversion() {\r\n    let (service, manager, _) = build_service().await;\r\n    let dto = NostrMetadataDto {\r\n        name: Some(\"Alice\".into()),\r\n        display_name: Some(\"Alice / Phase5\".into()),\r\n        about: Some(\"updating metadata\".into()),\r\n        picture: Some(\"https://example.com/p.png\".into()),\r\n        banner: None,\r\n        nip05: None,\r\n        lud16: Some(\"alice@getalby.com\".into()),\r\n        website: Some(\"https://kukuri.app\".into()),\r\n    };\r\n\r\n    service\r\n        .update_metadata(dto.clone())\r\n        .await\r\n        .expect(\"update metadata succeeds\");\r\n\r\n    let metadata = manager.metadata().await;\r\n    assert_eq!(metadata.len(), 1);\r\n    let serialized: Value =\r\n        serde_json::to_value(&metadata[0]).expect(\"metadata serializable to json\");\r\n    assert_eq!(serialized[\"name\"], dto.name.unwrap().into());\r\n    assert_eq!(serialized[\"display_name\"], dto.display_name.unwrap().into());\r\n    assert_eq!(serialized[\"about\"], dto.about.unwrap().into());\r\n    assert_eq!(serialized[\"picture\"], dto.picture.unwrap().into());\r\n    assert_eq!(serialized[\"lud16\"], dto.lud16.unwrap().into());\r\n    assert_eq!(serialized[\"website\"], dto.website.unwrap().into());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn delete_events_invokes_gateway_and_repository_cleanup() {\r\n    let (service, manager, repo) = build_service().await;\r\n    let targets = vec![repeating_hex('d'), repeating_hex('e')];\r\n    service\r\n        .delete_events(targets.clone(), Some(\"cleanup\".into()))\r\n        .await\r\n        .expect(\"delete events\");\r\n\r\n    let deletions = manager.deletions().await;\r\n    assert_eq!(deletions.len(), 1);\r\n    assert_eq!(deletions[0].targets, targets);\r\n    assert_eq!(deletions[0].reason.as_deref(), Some(\"cleanup\"));\r\n\r\n    let deleted_ids = repo.deleted_ids().await;\r\n    assert_eq!(deleted_ids, targets);\r\n}\r\n\r\nasync fn build_service(\r\n) -> (\r\n    EventService,\r\n    Arc<RecordingEventManager>,\r\n    Arc<RecordingEventRepository>,\r\n) {\r\n    let manager = Arc::new(RecordingEventManager::new());\r\n    let repository = Arc::new(RecordingEventRepository::default());\r\n    let manager_trait: Arc<dyn EventManagerHandle> = Arc::clone(&manager);\r\n    let event_gateway = Arc::new(LegacyEventManagerGateway::new(Arc::clone(&manager_trait)));\r\n\r\n    let mut service = EventService::new(\r\n        Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n        Arc::new(NoopSignatureService),\r\n        Arc::new(NoopEventDistributor),\r\n        event_gateway,\r\n        Arc::new(NoopSubscriptionStateStore),\r\n    );\r\n    service.set_subscription_invoker(Arc::new(EventManagerSubscriptionInvoker::new(\r\n        Arc::clone(&manager_trait),\r\n    )));\r\n\r\n    (service, manager, repository)\r\n}\r\n\r\n#[derive(Clone)]\r\nstruct RecordingEventManager {\r\n    text_notes: Arc<Mutex<Vec<String>>>,\r\n    topic_posts: Arc<Mutex<Vec<TopicPostRecord>>>,\r\n    reactions: Arc<Mutex<Vec<(String, String)>>>,\r\n    metadata: Arc<Mutex<Vec<Metadata>>>,\r\n    deletions: Arc<Mutex<Vec<DeletionRecord>>>,\r\n    default_topics: Arc<Mutex<Vec<String>>>,\r\n    public_key: PublicKey,\r\n    counter: Arc<AtomicU32>,\r\n    last_event_hex: Arc<Mutex<Option<String>>>,\r\n}\r\n\r\nimpl RecordingEventManager {\r\n    fn new() -> Self {\r\n        let keys = Keys::generate();\r\n        Self {\r\n            text_notes: Arc::new(Mutex::new(Vec::new())),\r\n            topic_posts: Arc::new(Mutex::new(Vec::new())),\r\n            reactions: Arc::new(Mutex::new(Vec::new())),\r\n            metadata: Arc::new(Mutex::new(Vec::new())),\r\n            deletions: Arc::new(Mutex::new(Vec::new())),\r\n            default_topics: Arc::new(Mutex::new(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])),\r\n            public_key: keys.public_key(),\r\n            counter: Arc::new(AtomicU32::new(1)),\r\n            last_event_hex: Arc::new(Mutex::new(None)),\r\n        }\r\n    }\r\n\r\n    async fn record_event_id(&self, id: &NostrEventId) {\r\n        let mut guard = self.last_event_hex.lock().await;\r\n        *guard = Some(id.to_hex());\r\n    }\r\n\r\n    async fn last_event_id(&self) -> Option<String> {\r\n        self.last_event_hex.lock().await.clone()\r\n    }\r\n\r\n    async fn text_notes(&self) -> Vec<String> {\r\n        self.text_notes.lock().await.clone()\r\n    }\r\n\r\n    async fn topic_posts(&self) -> Vec<TopicPostRecord> {\r\n        self.topic_posts.lock().await.clone()\r\n    }\r\n\r\n    async fn reactions(&self) -> Vec<(String, String)> {\r\n        self.reactions.lock().await.clone()\r\n    }\r\n\r\n    async fn metadata(&self) -> Vec<Metadata> {\r\n        self.metadata.lock().await.clone()\r\n    }\r\n\r\n    async fn deletions(&self) -> Vec<DeletionRecord> {\r\n        self.deletions.lock().await.clone()\r\n    }\r\n\r\n    fn next_event_id(&self) -> NostrEventId {\r\n        let next = self.counter.fetch_add(1, Ordering::Relaxed);\r\n        let mut bytes = [0u8; 32];\r\n        bytes[..4].copy_from_slice(&next.to_be_bytes());\r\n        NostrEventId::from_slice(&bytes).expect(\"event id from counter\")\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\nstruct TopicPostRecord {\r\n    topic_id: String,\r\n    content: String,\r\n    reply_to_hex: Option<String>,\r\n}\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\nstruct DeletionRecord {\r\n    targets: Vec<String>,\r\n    reason: Option<String>,\r\n}\r\n\r\n#[async_trait]\r\nimpl EventManagerHandle for RecordingEventManager {\r\n    async fn set_gossip_service(&self, _gossip: Arc<dyn GossipService>) {}\r\n\r\n    async fn set_event_repository(&self, _repo: Arc<dyn EventRepository>) {}\r\n\r\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\r\n        let mut guard = self.default_topics.lock().await;\r\n        guard.clear();\r\n        guard.push(topic_id.to_string());\r\n    }\r\n\r\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\r\n        let mut guard = self.default_topics.lock().await;\r\n        *guard = topics;\r\n    }\r\n\r\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\r\n        self.default_topics.lock().await.clone()\r\n    }\r\n\r\n    async fn handle_p2p_event(&self, _event: nostr_sdk::Event) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn publish_text_note(&self, content: &str) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.text_notes.lock().await.push(content.to_string());\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.topic_posts.lock().await.push(TopicPostRecord {\r\n            topic_id: topic_id.to_string(),\r\n            content: content.to_string(),\r\n            reply_to_hex: reply_to.map(|id| id.to_hex()),\r\n        });\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &NostrEventId,\r\n        reaction: &str,\r\n    ) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.reactions\r\n            .lock()\r\n            .await\r\n            .push((target.to_hex(), reaction.to_string()));\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn update_metadata(&self, metadata: Metadata) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.metadata.lock().await.push(metadata);\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn delete_events(\r\n        &self,\r\n        target_ids: Vec<NostrEventId>,\r\n        reason: Option<String>,\r\n    ) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.deletions.lock().await.push(DeletionRecord {\r\n            targets: target_ids.into_iter().map(|id| id.to_hex()).collect(),\r\n            reason,\r\n        });\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn disconnect(&self) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_public_key(&self) -> Option<PublicKey> {\r\n        Some(self.public_key)\r\n    }\r\n\r\n    async fn subscribe_to_topic(\r\n        &self,\r\n        _topic_id: &str,\r\n        _since: Option<Timestamp>,\r\n    ) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn subscribe_to_user(\r\n        &self,\r\n        _pubkey: PublicKey,\r\n        _since: Option<Timestamp>,\r\n    ) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn initialize_with_keypair(&self, _keypair: KeyPair) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Default)]\r\nstruct RecordingEventRepository {\r\n    deleted: Mutex<Vec<String>>,\r\n}\r\n\r\nimpl RecordingEventRepository {\r\n    async fn deleted_ids(&self) -> Vec<String> {\r\n        self.deleted.lock().await.clone()\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl EventRepository for RecordingEventRepository {\r\n    async fn create_event(&self, _event: &Event) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_event(&self, _id: &str) -> Result<Option<Event>, AppError> {\r\n        Ok(None)\r\n    }\r\n\r\n    async fn get_events_by_kind(\r\n        &self,\r\n        _kind: u32,\r\n        _limit: usize,\r\n    ) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn get_events_by_author(\r\n        &self,\r\n        _pubkey: &str,\r\n        _limit: usize,\r\n    ) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\r\n        self.deleted.lock().await.push(id.to_string());\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn mark_event_synced(&self, _id: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\nstruct NoopSignatureService;\r\n\r\n#[async_trait]\r\nimpl SignatureService for NoopSignatureService {\r\n    async fn sign_event(\r\n        &self,\r\n        _event: &mut Event,\r\n        _private_key: &str,\r\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn verify_event(\r\n        &self,\r\n        _event: &Event,\r\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(true)\r\n    }\r\n\r\n    async fn sign_message(\r\n        &self,\r\n        message: &str,\r\n        _private_key: &str,\r\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(message.to_string())\r\n    }\r\n\r\n    async fn verify_message(\r\n        &self,\r\n        _message: &str,\r\n        _signature: &str,\r\n        _public_key: &str,\r\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(true)\r\n    }\r\n}\r\n\r\nstruct NoopEventDistributor;\r\n\r\n#[async_trait]\r\nimpl EventDistributor for NoopEventDistributor {\r\n    async fn distribute(\r\n        &self,\r\n        _event: &Event,\r\n        _strategy: DistributionStrategy,\r\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(None)\r\n    }\r\n\r\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {}\r\n\r\n    async fn get_pending_events(\r\n        &self,\r\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(0)\r\n    }\r\n}\r\n\r\nstruct NoopSubscriptionStateStore;\r\n\r\n#[async_trait]\r\nimpl SubscriptionStateStore for NoopSubscriptionStateStore {\r\n    async fn record_request(\r\n        &self,\r\n        target: SubscriptionTarget,\r\n    ) -> Result<SubscriptionRecord, AppError> {\r\n        Ok(SubscriptionRecord {\r\n            target,\r\n            status: SubscriptionStatus::Pending,\r\n            last_synced_at: None,\r\n            last_attempt_at: None,\r\n            failure_count: 0,\r\n            error_message: None,\r\n        })\r\n    }\r\n\r\n    async fn mark_subscribed(\r\n        &self,\r\n        _target: &SubscriptionTarget,\r\n        _synced_at: i64,\r\n    ) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn mark_failure(&self, _target: &SubscriptionTarget, _error: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_p2p_mainline.rs"],"content":"use iroh::SecretKey;\nuse kukuri_lib::application::services::p2p_service::P2PService;\nuse kukuri_lib::infrastructure::p2p::DiscoveryOptions;\nuse kukuri_lib::shared::config::NetworkConfig as AppNetworkConfig;\n\nfn mainline_ready_config() -> AppNetworkConfig {\n    AppNetworkConfig {\n        bootstrap_peers: vec![\"peer1.example:1337\".into()],\n        max_peers: 24,\n        connection_timeout: 30,\n        retry_interval: 10,\n        enable_dht: true,\n        enable_dns: false,\n        enable_local: true,\n    }\n}\n\n#[test]\nfn builder_enables_mainline_when_configured() {\n    let config = mainline_ready_config();\n    let secret = SecretKey::from_bytes(&[1u8; 32]);\n\n    let builder = P2PService::builder(secret, config.clone());\n    let options = builder.discovery_options();\n\n    assert!(options.enable_mainline(), \"mainline should be enabled\");\n    assert!(!options.enable_dns, \"DNS discovery stays disabled\");\n    assert!(options.enable_local, \"local discovery remains enabled\");\n}\n\n#[test]\nfn builder_can_disable_mainline_via_toggle() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    let secret = SecretKey::from_bytes(&[2u8; 32]);\n\n    let builder = P2PService::builder(secret, config).enable_mainline(false);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options,\n        DiscoveryOptions::new(false, false, true),\n        \"explicit toggle should override configuration flags\"\n    );\n}\n\n#[test]\nfn builder_honors_custom_discovery_overrides() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    config.enable_dns = true;\n    config.enable_local = false;\n    let secret = SecretKey::from_bytes(&[3u8; 32]);\n\n    let custom = DiscoveryOptions::new(true, true, false);\n    let builder = P2PService::builder(secret, config).with_discovery_options(custom);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options, custom,\n        \"custom discovery options should take precedence over network config\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","topic_create_join.rs"],"content":"use async_trait::async_trait;\r\nuse kukuri_lib::application::services::offline_service::{OfflineService, OfflineServiceTrait};\r\nuse kukuri_lib::application::services::topic_service::{PendingTopicStatus, TopicService};\r\nuse kukuri_lib::domain::entities::Topic;\r\nuse kukuri_lib::infrastructure::database::{\r\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\r\n};\r\nuse kukuri_lib::infrastructure::offline::SqliteOfflinePersistence;\r\nuse kukuri_lib::shared::{error::AppError, config::BootstrapSource};\r\nuse kukuri_lib::application::services::p2p_service::{P2PServiceTrait, P2PStatus};\r\nuse std::sync::Arc;\r\nuse tokio::sync::Mutex;\r\n\r\n#[derive(Default)]\r\nstruct TestP2PService {\r\n    joins: Mutex<Vec<String>>,\r\n}\r\n\r\n#[async_trait]\r\nimpl P2PServiceTrait for TestP2PService {\r\n    async fn initialize(&self) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn join_topic(\r\n        &self,\r\n        topic_id: &str,\r\n        _initial_peers: Vec<String>,\r\n    ) -> Result<(), AppError> {\r\n        self.joins.lock().await.push(topic_id.to_string());\r\n        Ok(())\r\n    }\r\n\r\n    async fn leave_topic(&self, _topic_id: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn broadcast_message(&self, _topic_id: &str, _content: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_status(&self) -> Result<P2PStatus, AppError> {\r\n        Ok(P2PStatus {\r\n            is_connected: true,\r\n            connected_peers: vec![],\r\n            gossip_topics: vec![],\r\n            node_addresses: vec![],\r\n            bootstrap_source: BootstrapSource::Bundle,\r\n        })\r\n    }\r\n\r\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    fn generate_topic_id(&self, topic_name: &str) -> String {\r\n        topic_name.to_string()\r\n    }\r\n\r\n    async fn apply_bootstrap_nodes(\r\n        &self,\r\n        _nodes: Vec<String>,\r\n        _source: BootstrapSource,\r\n    ) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn test_pubkey() -> String {\r\n    std::iter::repeat('a').take(64).collect()\r\n}\r\n\r\n#[tokio::test]\r\nasync fn enqueue_create_and_sync_pending_topic() {\r\n    let connection_pool = ConnectionPool::from_memory()\r\n        .await\r\n        .expect(\"create memory pool\");\r\n    let repository = Arc::new(SqliteRepository::new(connection_pool.clone()));\r\n    repository.initialize().await.expect(\"run migrations\");\r\n\r\n    let topic_repo: Arc<dyn kukuri_lib::application::ports::repositories::TopicRepository> =\r\n        Arc::clone(&repository);\r\n    let pending_repo: Arc<dyn kukuri_lib::application::ports::repositories::PendingTopicRepository> =\r\n        Arc::clone(&repository);\r\n    let metrics_repo: Arc<dyn kukuri_lib::application::ports::repositories::TopicMetricsRepository> =\r\n        Arc::clone(&repository);\r\n\r\n    let offline_persistence =\r\n        Arc::new(SqliteOfflinePersistence::new(connection_pool.get_pool().clone()));\r\n    let offline_service: Arc<dyn OfflineServiceTrait> =\r\n        Arc::new(OfflineService::new(offline_persistence));\r\n\r\n    let p2p_service = Arc::new(TestP2PService::default());\r\n\r\n    let topic_service = TopicService::new(\r\n        topic_repo,\r\n        pending_repo,\r\n        metrics_repo,\r\n        false,\r\n        Arc::clone(&p2p_service) as Arc<dyn P2PServiceTrait>,\r\n        offline_service,\r\n    );\r\n    topic_service\r\n        .ensure_public_topic()\r\n        .await\r\n        .expect(\"ensure public topic\");\r\n\r\n    let user_pubkey = test_pubkey();\r\n    let enqueue = topic_service\r\n        .enqueue_topic_creation(&user_pubkey, \"offline.topic\".into(), Some(\"desc\".into()))\r\n        .await\r\n        .expect(\"enqueue topic creation\");\r\n    assert_eq!(enqueue.pending_topic.status, PendingTopicStatus::Queued);\r\n\r\n    let created = topic_service\r\n        .create_topic(\"offline.topic\".into(), Some(\"desc\".into()), TopicVisibility::Public, &user_pubkey)\r\n        .await\r\n        .expect(\"create topic\");\r\n\r\n    topic_service\r\n        .mark_pending_topic_synced(&enqueue.pending_topic.pending_id, &created.id)\r\n        .await\r\n        .expect(\"mark pending synced\");\r\n\r\n    let synced = topic_service\r\n        .get_pending_topic(&enqueue.pending_topic.pending_id)\r\n        .await\r\n        .expect(\"get pending topic\")\r\n        .expect(\"pending entry exists\");\r\n    assert_eq!(synced.status, PendingTopicStatus::Synced);\r\n    assert_eq!(synced.synced_topic_id.as_deref(), Some(created.id.as_str()));\r\n\r\n    let joined = repository\r\n        .get_joined_topics(&user_pubkey)\r\n        .await\r\n        .expect(\"joined topics\");\r\n    assert!(\r\n        joined.iter().any(|topic: &Topic| topic.id == created.id),\r\n        \"user should be joined to newly created topic\"\r\n    );\r\n\r\n    {\r\n        let joins = p2p_service.joins.lock().await;\r\n        assert!(\r\n            joins.contains(&created.id),\r\n            \"p2p service should receive join request\"\r\n        );\r\n    }\r\n\r\n    let failed = topic_service\r\n        .enqueue_topic_creation(&user_pubkey, \"offline.fail\".into(), None)\r\n        .await\r\n        .expect(\"enqueue second topic\");\r\n    topic_service\r\n        .mark_pending_topic_failed(&failed.pending_topic.pending_id, Some(\"network error\".into()))\r\n        .await\r\n        .expect(\"mark pending failed\");\r\n\r\n    let failed_entry = topic_service\r\n        .get_pending_topic(&failed.pending_topic.pending_id)\r\n        .await\r\n        .expect(\"get failed pending\")\r\n        .expect(\"failed entry exists\");\r\n    assert_eq!(failed_entry.status, PendingTopicStatus::Failed);\r\n    assert_eq!(\r\n        failed_entry.error_message.as_deref(),\r\n        Some(\"network error\")\r\n    );\r\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","key_management.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse async_trait::async_trait;\nuse kukuri_lib::test_support::{\n    application::{\n        ports::{\n            auth_lifecycle::{AuthLifecycleEvent, AuthLifecyclePort},\n            key_manager::KeyManager,\n        },\n        services::AuthService,\n    },\n    domain::entities::User,\n    infrastructure::{crypto::DefaultKeyManager, storage::secure_storage::SecureStorage},\n    shared::error::AppError,\n};\nuse tokio::sync::Mutex;\n\n#[derive(Default)]\nstruct InMemorySecureStorage {\n    entries: Mutex<HashMap<String, String>>,\n}\n\n#[async_trait]\nimpl SecureStorage for InMemorySecureStorage {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries\n            .lock()\n            .await\n            .insert(key.to_string(), value.to_string());\n        Ok(())\n    }\n\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.get(key).cloned())\n    }\n\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries.lock().await.remove(key);\n        Ok(())\n    }\n\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.contains_key(key))\n    }\n\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.keys().cloned().collect())\n    }\n\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries.lock().await.clear();\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct TestAuthLifecycle {\n    users: Mutex<HashMap<String, User>>,\n}\n\n#[async_trait]\nimpl AuthLifecyclePort for TestAuthLifecycle {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError> {\n        let account = event.account;\n        let user = User::new(account.npub.clone(), account.public_key.clone());\n        self.users\n            .lock()\n            .await\n            .insert(account.npub.clone(), user.clone());\n        Ok(user)\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        Ok(self.users.lock().await.get(npub).cloned())\n    }\n}\n\n#[tokio::test]\nasync fn export_private_key_roundtrip() {\n    let key_manager = Arc::new(DefaultKeyManager::new()) as Arc<dyn KeyManager>;\n    let secure_storage = Arc::new(InMemorySecureStorage::default());\n    let lifecycle = Arc::new(TestAuthLifecycle::default());\n\n    let service = AuthService::new(\n        key_manager,\n        secure_storage.clone() as Arc<dyn SecureStorage>,\n        lifecycle as Arc<dyn AuthLifecyclePort>,\n    );\n\n    let created_user = service.create_account().await.expect(\"create account\");\n    let exported = service\n        .export_private_key(&created_user.npub)\n        .await\n        .expect(\"export key\");\n    assert!(exported.starts_with(\"nsec1\"));\n\n    service.logout().await.expect(\"logout\");\n    let imported_user = service\n        .login_with_nsec(&exported)\n        .await\n        .expect(\"login with exported key\");\n\n    assert_eq!(imported_user.npub, created_user.npub);\n\n    let stored_npub = secure_storage\n        .retrieve(\"current_npub\")\n        .await\n        .expect(\"current_npub entry\");\n    assert_eq!(stored_npub, Some(created_user.npub));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","offline_integration.rs"],"content":"﻿#[path = \"integration/offline/mod.rs\"]\nmod offline;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_gossip_smoke.rs"],"content":"use kukuri_lib::test_support::application::shared::tests::p2p::bootstrap::{\n    DEFAULT_EVENT_TIMEOUT, DEFAULT_JOIN_TIMEOUT, build_peer_hints, create_service,\n    wait_for_peer_join_event, wait_for_topic_membership,\n};\nuse kukuri_lib::test_support::application::shared::tests::p2p::config::load_bootstrap_context;\nuse kukuri_lib::test_support::application::shared::tests::p2p::fixtures::nostr_to_domain;\nuse kukuri_lib::test_support::application::shared::tests::p2p::logging::init_tracing;\nuse kukuri_lib::test_support::domain::p2p::generate_topic_id;\nuse kukuri_lib::test_support::infrastructure::p2p::gossip_service::GossipService;\nuse nostr_sdk::prelude::*;\nuse tokio::sync::broadcast;\nuse tokio::time::{Duration, sleep, timeout};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    };\n}\n\n/// subscribe → join の最小シナリオで接続確認を行う\n#[tokio::test]\nasync fn test_two_nodes_connect_and_join() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_connect_and_join\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_connect_and_join start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-two-nodes\");\n    log_step!(\"joining topic {} on both services\", topic);\n\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined topic {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined topic {}\", topic);\n\n    let _rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"both services joined topic {}\", topic);\n\n    let joined_a = svc_a.get_joined_topics().await.unwrap();\n    let joined_b = svc_b.get_joined_topics().await.unwrap();\n    assert!(joined_a.contains(&topic));\n    assert!(joined_b.contains(&topic));\n    log_step!(\"--- test_two_nodes_connect_and_join end ---\");\n}\n\n/// 双方向にメッセージをやり取りし、近接で安定して届くことを検証する\n#[tokio::test]\nasync fn test_peer_connection_stability_bidirectional() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_peer_connection_stability_bidirectional\") else {\n        return;\n    };\n    log_step!(\"--- test_peer_connection_stability_bidirectional start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-stability\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for stability test, continuing optimistically\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting ping sequence on topic {}\", topic);\n\n    for i in 0..5u32 {\n        let keys = Keys::generate();\n        let ne = EventBuilder::text_note(format!(\"ping-{i}\"))\n            .sign_with_keys(&keys)\n            .unwrap();\n        let ev = nostr_to_domain(&ne);\n        if i % 2 == 0 {\n            svc_a.broadcast(&topic, &ev).await.unwrap();\n        } else {\n            svc_b.broadcast(&topic, &ev).await.unwrap();\n        }\n    }\n\n    let mut count_a = 0;\n    let mut count_b = 0;\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < Duration::from_secs(12) && (count_a < 3 || count_b < 3) {\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_a.recv().await }).await\n        {\n            count_a += 1;\n        }\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_b.recv().await }).await\n        {\n            count_b += 1;\n        }\n    }\n\n    assert!(\n        count_a >= 3 || count_b >= 3,\n        \"insufficient messages received: a={count_a}, b={count_b}\"\n    );\n    log_step!(\n        \"--- test_peer_connection_stability_bidirectional end (counts a={}, b={}) ---\",\n        count_a,\n        count_b\n    );\n}\n\n/// 二ノード間でのブロードキャスト配送を検証する\n#[tokio::test]\nasync fn test_two_nodes_broadcast_and_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_broadcast_and_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_broadcast_and_receive start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let (tx_a, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a.subscribe();\n    let (tx_b, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b.subscribe();\n    svc_a.set_event_sender(tx_a);\n    svc_b.set_event_sender(tx_b);\n\n    let topic = generate_topic_id(\"iroh-int-recv\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let _rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"services joined topic {}, waiting for peer events\", topic);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed, continuing after grace period\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"sending broadcast message on topic {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-int\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"receive timeout\");\n    assert!(r.is_some());\n    assert_eq!(r.unwrap().content, \"hello-int\");\n    log_step!(\"--- test_two_nodes_broadcast_and_receive end ---\");\n}\n\n/// 複数購読者が同一トピックのイベントを受け取れることを検証\n#[tokio::test]\nasync fn test_multiple_subscribers_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multiple_subscribers_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_multiple_subscribers_receive start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-subs\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx1 = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx2 = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting multi-subscriber event on {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-multi\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r1 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx1.recv().await })\n        .await\n        .expect(\"rx1 timeout\");\n    let r2 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx2.recv().await })\n        .await\n        .expect(\"rx2 timeout\");\n\n    assert!(r1.is_some() && r2.is_some());\n    assert_eq!(r1.unwrap().content, \"hello-multi\");\n    assert_eq!(r2.unwrap().content, \"hello-multi\");\n    log_step!(\"--- test_multiple_subscribers_receive end ---\");\n}\n\n/// P2P経路のみで返信イベントが伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_reply_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_reply_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_reply_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-reply-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for reply flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"reply-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let root_id = base_event.id.clone();\n    let root_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending reply\");\n\n    let reply_event_tag = Tag::from_standardized(TagStandard::Event {\n        event_id: base_note.id,\n        relay_url: None,\n        marker: Some(Marker::Reply),\n        public_key: None,\n        uppercase: false,\n    });\n    let reply_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let reply_keys = Keys::generate();\n    let reply_note = EventBuilder::text_note(\"reply-post\")\n        .tags([reply_event_tag, reply_pubkey_tag])\n        .sign_with_keys(&reply_keys)\n        .unwrap();\n\n    let reply_event = nostr_to_domain(&reply_note);\n    svc_b.broadcast(&topic, &reply_event).await.unwrap();\n\n    let received_reply = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"reply receive timeout\")\n        .expect(\"reply channel closed\");\n    assert_eq!(received_reply.content, \"reply-post\");\n\n    let e_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"e\"))\n        .expect(\"reply event missing e tag\");\n    assert_eq!(e_tag.get(1).map(|s| s.as_str()), Some(root_id.as_str()));\n    assert_eq!(e_tag.get(3).map(|s| s.as_str()), Some(\"reply\"));\n\n    let p_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"reply event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(root_pubkey.as_str()));\n    log_step!(\"--- test_p2p_reply_flow end ---\");\n}\n\n/// P2P経路のみで引用イベント（mention）が伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_quote_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_quote_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_quote_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-quote-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for quote flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"quote-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let base_id = base_event.id.clone();\n    let base_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending quote\");\n\n    let quote_tag = Tag::from_standardized(TagStandard::Quote {\n        event_id: base_note.id,\n        relay_url: None,\n        public_key: None,\n    });\n    let quote_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let quote_keys = Keys::generate();\n    let quote_note = EventBuilder::text_note(\"quote-post\")\n        .tags([quote_tag, quote_pubkey_tag])\n        .sign_with_keys(&quote_keys)\n        .unwrap();\n    let quote_event = nostr_to_domain(&quote_note);\n    svc_b.broadcast(&topic, &quote_event).await.unwrap();\n\n    let received_quote = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"quote receive timeout\")\n        .expect(\"quote channel closed\");\n    assert_eq!(received_quote.content, \"quote-post\");\n\n    let q_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"q\"))\n        .expect(\"quote event missing q tag\");\n    assert_eq!(q_tag.get(1).map(|s| s.as_str()), Some(base_id.as_str()));\n\n    let p_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"quote event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(base_pubkey.as_str()));\n    log_step!(\"--- test_p2p_quote_flow end ---\");\n}\n\n/// 3ノード構成でA->(B,C)へブロードキャストが届くことを検証\n#[tokio::test]\nasync fn test_multi_node_broadcast_three_nodes() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multi_node_broadcast_three_nodes\") else {\n        return;\n    };\n    log_step!(\"--- test_multi_node_broadcast_three_nodes start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n    let svc_c = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-node\");\n    let local_hints = vec![\n        svc_a.local_peer_hint(),\n        svc_b.local_peer_hint(),\n        svc_c.local_peer_hint(),\n    ];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n    let hints_c = build_peer_hints(&ctx.hints, &local_hints, 2);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n    svc_c.join_topic(&topic, hints_c).await.unwrap();\n    log_step!(\"svc_c joined {}\", topic);\n\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx_c = svc_c.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_c, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_c failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    log_step!(\"all nodes joined topic {}\", topic);\n\n    sleep(Duration::from_secs(1)).await;\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-3nodes\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r_b = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"B receive timeout\");\n    let r_c = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_c.recv().await })\n        .await\n        .expect(\"C receive timeout\");\n\n    assert!(r_b.is_some() && r_c.is_some());\n    assert_eq!(r_b.unwrap().content, \"hello-3nodes\");\n    assert_eq!(r_c.unwrap().content, \"hello-3nodes\");\n    log_step!(\"--- test_multi_node_broadcast_three_nodes end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_mainline_smoke.rs"],"content":"use chrono::Utc;\nuse iroh::SecretKey;\nuse kukuri_lib::test_support::application::services::p2p_service::P2PService;\nuse kukuri_lib::test_support::infrastructure::p2p::{\n    DiscoveryOptions, NetworkService, gossip_service::GossipService,\n};\nuse kukuri_lib::test_support::shared::config::{AppConfig, NetworkConfig as AppNetworkConfig};\nuse rand::{RngCore, SeedableRng, rngs::StdRng};\nuse std::sync::Arc;\nuse tokio::time::{Duration, Instant, sleep};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        eprintln!(\"[p2p_mainline_smoke] {}\", format!($($arg)*));\n    }};\n}\n\nstruct MainlineContext {\n    hints: Vec<String>,\n    network_config: AppNetworkConfig,\n}\n\nfn prepare_context(test_name: &str) -> Option<MainlineContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\n        return None;\n    }\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    let hints: Vec<String> = raw\n        .split(',')\n        .map(|s| s.trim().to_string())\n        .filter(|s| !s.is_empty())\n        .collect();\n    if hints.is_empty() {\n        eprintln!(\"skipping {test_name} (KUKURI_BOOTSTRAP_PEERS not set)\");\n        return None;\n    }\n\n    let app_cfg = AppConfig::from_env();\n    let mut network_config = app_cfg.network.clone();\n    if network_config.bootstrap_peers.is_empty() {\n        network_config.bootstrap_peers = hints.clone();\n    }\n    network_config.enable_dht = true;\n    network_config.enable_dns = false;\n    network_config.enable_local = true;\n\n    Some(MainlineContext {\n        hints,\n        network_config,\n    })\n}\n\nfn random_secret(rng: &mut StdRng) -> SecretKey {\n    let mut bytes = [0u8; 32];\n    rng.fill_bytes(&mut bytes);\n    SecretKey::from_bytes(&bytes)\n}\n\nasync fn wait_for_bootstrap_peer(\n    service: &Arc<dyn NetworkService>,\n    min_peers: usize,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Ok(peers) = service.get_peers().await {\n            if peers.len() >= min_peers {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\nasync fn wait_for_local_peer_hint(\n    service: &Arc<dyn GossipService>,\n    deadline: Duration,\n) -> Option<String> {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Some(hint) = service.local_peer_hint() {\n            return Some(hint);\n        }\n        sleep(Duration::from_millis(150)).await;\n    }\n    None\n}\n\nasync fn wait_for_topic_membership(\n    service: &Arc<dyn GossipService>,\n    topic: &str,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        match service.get_joined_topics().await {\n            Ok(joined) if joined.iter().any(|t| t == topic) => return true,\n            Ok(_) => {}\n            Err(err) => {\n                log_step!(\"get_joined_topics error for {}: {:?}\", topic, err);\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\n#[tokio::test]\nasync fn test_mainline_dht_handshake_and_routing() {\n    let Some(ctx) = prepare_context(\"test_mainline_dht_handshake_and_routing\") else {\n        return;\n    };\n    log_step!(\"--- mainline handshake start ---\");\n\n    let discovery = DiscoveryOptions::new(false, true, true);\n\n    let mut thread_rng = rand::rng();\n    let mut rng = StdRng::from_rng(&mut thread_rng);\n    let secret_a = random_secret(&mut rng);\n    let secret_b = random_secret(&mut rng);\n\n    let stack_a = P2PService::builder(secret_a, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack A\");\n    let stack_b = P2PService::builder(secret_b, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack B\");\n\n    stack_a\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network A\");\n    stack_b\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network B\");\n\n    assert!(\n        wait_for_bootstrap_peer(&stack_a.network_service, 1, Duration::from_secs(20)).await,\n        \"A failed to discover bootstrap peer via mainline DHT\"\n    );\n    assert!(\n        wait_for_bootstrap_peer(&stack_b.network_service, 1, Duration::from_secs(20)).await,\n        \"B failed to discover bootstrap peer via mainline DHT\"\n    );\n\n    let hint_a = wait_for_local_peer_hint(&stack_a.gossip_service, Duration::from_secs(5)).await;\n    let hint_b = wait_for_local_peer_hint(&stack_b.gossip_service, Duration::from_secs(5)).await;\n\n    let mut hints_for_a = ctx.hints.clone();\n    let mut hints_for_b = ctx.hints.clone();\n    if let Some(h) = &hint_b {\n        hints_for_a.push(h.clone());\n    }\n    if let Some(h) = &hint_a {\n        hints_for_b.push(h.clone());\n    }\n    hints_for_a.sort();\n    hints_for_a.dedup();\n    hints_for_b.sort();\n    hints_for_b.dedup();\n\n    let topic_seed = format!(\n        \"mainline-handshake-routing-{}\",\n        Utc::now().timestamp_nanos_opt().unwrap_or_default()\n    );\n    let topic_id = stack_a.p2p_service.generate_topic_id(&topic_seed);\n\n    stack_a\n        .p2p_service\n        .join_topic(&topic_id, hints_for_a.clone())\n        .await\n        .expect(\"join topic on A\");\n    stack_b\n        .p2p_service\n        .join_topic(&topic_id, hints_for_b.clone())\n        .await\n        .expect(\"join topic on B\");\n\n    assert!(\n        wait_for_topic_membership(&stack_a.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"A did not observe topic membership via DHT routing\"\n    );\n    assert!(\n        wait_for_topic_membership(&stack_b.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"B did not observe topic membership via DHT routing\"\n    );\n\n    let stats_a = stack_a\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from A\");\n    assert!(\n        stats_a.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    let stats_b = stack_b\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from B\");\n    assert!(\n        stats_b.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    stack_a\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic A\");\n    stack_b\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic B\");\n\n    log_step!(\"--- mainline handshake end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance","cache.rs"],"content":"use std::time::Instant;\n\nuse super::performance_common::{\n    offline_seed::seed_cache_metadata,\n    offline_support::{\n        OfflineTestContext, TEST_PUBKEY_HEX, build_params_for_index, setup_offline_service,\n    },\n    recorder::{PerformanceRecorder, duration_secs},\n};\nuse anyhow::{Result, anyhow};\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait,\n};\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse tokio::time::{Duration, sleep};\n\n#[tokio::test]\n#[ignore]\nasync fn offline_action_save_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 200;\n    let OfflineTestContext { service, pool: _ } = setup_offline_service().await;\n\n    let save_started = Instant::now();\n    for index in 0..ACTION_COUNT {\n        service.save_action(build_params_for_index(index)).await?;\n    }\n    let save_elapsed = save_started.elapsed();\n    let user_pubkey = PublicKey::from_hex_str(TEST_PUBKEY_HEX).map_err(|err| anyhow!(err))?;\n    let list_started = Instant::now();\n    let records = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(user_pubkey),\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await?;\n    let list_elapsed = list_started.elapsed();\n\n    let save_secs = duration_secs(save_elapsed);\n    let list_secs = duration_secs(list_elapsed);\n\n    PerformanceRecorder::new(\"offline_action_save_throughput\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"save_total_ms\", save_secs * 1_000.0)\n        .metric(\"save_throughput_per_sec\", ACTION_COUNT as f64 / save_secs)\n        .metric(\"list_total_ms\", list_secs * 1_000.0)\n        .metric(\"list_throughput_per_sec\", records.len() as f64 / list_secs)\n        .note(\n            \"description\",\n            \"OfflineService::save_action and list_actions against in-memory SQLite\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(records.len(), ACTION_COUNT);\n    Ok(())\n}\n\n#[tokio::test]\n#[ignore]\nasync fn cache_cleanup_latency() -> Result<()> {\n    const CACHE_ENTRIES: usize = 50;\n    let OfflineTestContext { service, .. } = setup_offline_service().await;\n    seed_cache_metadata(&service, CACHE_ENTRIES).await?;\n\n    // expiry values are 1-3 seconds; wait long enough for at least two buckets.\n    sleep(Duration::from_secs(4)).await;\n\n    let cleanup_started = Instant::now();\n    let removed = service.cleanup_expired_cache().await?;\n    let cleanup_elapsed = cleanup_started.elapsed();\n    let cleanup_secs = duration_secs(cleanup_elapsed);\n\n    PerformanceRecorder::new(\"offline_cache_cleanup_latency\")\n        .iterations(CACHE_ENTRIES as u64)\n        .metric(\"removed_entries\", removed as f64)\n        .metric(\"cleanup_total_ms\", cleanup_secs * 1_000.0)\n        .metric(\"cleanup_throughput_per_sec\", removed as f64 / cleanup_secs)\n        .note(\n            \"description\",\n            \"OfflineService::cleanup_expired_cache after staged expiry seeding\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance","sync.rs"],"content":"use std::{sync::Arc, time::Instant};\n\nuse super::performance_common::{\n    offline_seed::seed_offline_actions,\n    offline_support::{OfflineTestContext, TEST_PUBKEY_HEX, setup_offline_service},\n    recorder::{PerformanceRecorder, duration_secs},\n};\nuse anyhow::{Result, anyhow};\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\nuse kukuri_lib::test_support::application::services::offline_service::OfflineServiceTrait;\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\nuse sqlx::Row;\n\n#[tokio::test]\n#[ignore]\nasync fn offline_reindex_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 120;\n\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n    seed_offline_actions(&service, ACTION_COUNT).await?;\n\n    let persistence: Arc<dyn OfflinePersistence> =\n        Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence);\n\n    let started = Instant::now();\n    let report = job.reindex_once().await?;\n    let elapsed = started.elapsed();\n    let secs = duration_secs(elapsed);\n\n    PerformanceRecorder::new(\"offline_reindex_once\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"duration_ms\", secs * 1_000.0)\n        .metric(\"actions_per_sec\", report.offline_action_count as f64 / secs)\n        .metric(\"queued_actions\", report.queued_action_count as f64)\n        .metric(\"pending_queue\", report.pending_queue_count as f64)\n        .note(\n            \"description\",\n            \"OfflineReindexJob::reindex_once after seeding offline actions\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(report.offline_action_count as usize, ACTION_COUNT);\n    Ok(())\n}\n\n#[tokio::test]\n#[ignore]\nasync fn offline_sync_actions_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 120;\n\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n    seed_offline_actions(&service, ACTION_COUNT).await?;\n\n    let user_pubkey = PublicKey::from_hex_str(TEST_PUBKEY_HEX).map_err(|err| anyhow!(err))?;\n    let started = Instant::now();\n    let result = service.sync_actions(user_pubkey).await?;\n    let elapsed = started.elapsed();\n    let secs = duration_secs(elapsed);\n\n    PerformanceRecorder::new(\"offline_sync_actions\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"duration_ms\", secs * 1_000.0)\n        .metric(\"synced_count\", result.synced_count as f64)\n        .metric(\"failed_count\", result.failed_count as f64)\n        .metric(\"throughput_per_sec\", result.synced_count as f64 / secs)\n        .note(\n            \"description\",\n            \"OfflineService::sync_actions with seeded offline queue entries\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(result.synced_count as usize, ACTION_COUNT);\n    assert_eq!(result.failed_count, 0);\n\n    let queue_count: i64 = sqlx::query(\"SELECT COUNT(*) FROM sync_queue\")\n        .fetch_one(&pool)\n        .await?\n        .get(0);\n    assert_eq!(queue_count as usize, ACTION_COUNT);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance.rs"],"content":"#[path = \"common/performance/mod.rs\"]\nmod performance_common;\n\n#[path = \"performance/cache.rs\"]\nmod cache;\n#[path = \"performance/sync.rs\"]\nmod sync;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","profile_avatar_sync.rs"],"content":"use kukuri_lib::test_support::application::services::{\n    ProfileAvatarService, UploadProfileAvatarInput,\n};\nuse kukuri_lib::test_support::domain::entities::ProfileAvatarAccessLevel;\n\n#[tokio::test]\nasync fn profile_avatar_sync_between_nodes() {\n    let node1_dir = tempfile::tempdir().expect(\"node1 dir\");\n    let node2_dir = tempfile::tempdir().expect(\"node2 dir\");\n\n    let service_a = ProfileAvatarService::new(node1_dir.path().to_path_buf())\n        .await\n        .expect(\"service a\");\n    let service_b = ProfileAvatarService::new(node2_dir.path().to_path_buf())\n        .await\n        .expect(\"service b\");\n\n    let npub = \"npub1syncavatar\".to_string();\n    let avatar_bytes: Vec<u8> = (0..128).collect();\n\n    let upload_entry = service_a\n        .upload_avatar(UploadProfileAvatarInput {\n            npub: npub.clone(),\n            bytes: avatar_bytes.clone(),\n            format: \"image/png\".to_string(),\n            access_level: ProfileAvatarAccessLevel::ContactsOnly,\n        })\n        .await\n        .expect(\"upload\");\n\n    let package = service_a\n        .export_sync_package(&npub)\n        .await\n        .expect(\"export\")\n        .expect(\"package\");\n\n    let imported_entry = service_b\n        .import_sync_package(package)\n        .await\n        .expect(\"import\");\n\n    assert_eq!(upload_entry.blob_hash, imported_entry.blob_hash);\n    assert_eq!(upload_entry.version, imported_entry.version);\n    assert_eq!(upload_entry.share_ticket, imported_entry.share_ticket);\n\n    let fetched = service_b.fetch_avatar(&npub).await.expect(\"fetch on node2\");\n\n    assert_eq!(fetched.bytes, avatar_bytes);\n    assert_eq!(fetched.metadata.blob_hash, upload_entry.blob_hash);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","event_service","mod.rs"],"content":"﻿#[path = \"../../../common/mod.rs\"]\r\nmod common;\r\n\r\nuse std::sync::Arc;\r\n\r\nuse common::mocks::{\r\n    MockEventDist, MockEventGateway, MockEventRepo, MockSignatureServ, MockSubscriptionInvokerMock,\r\n    MockSubscriptionStateMock,\r\n};\r\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::event_service::EventService;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse kukuri_lib::domain::entities::Event;\r\nuse kukuri_lib::infrastructure::crypto::SignatureService;\r\nuse kukuri_lib::infrastructure::database::EventRepository;\r\nuse kukuri_lib::infrastructure::p2p::EventDistributor;\r\nuse kukuri_lib::shared::error::AppError;\r\nuse mockall::predicate::*;\r\n\r\nfn create_test_event() -> Event {\r\n    Event::new(1, \"Test content\".into(), \"test_pubkey\".into())\r\n}\r\n\r\nfn service_with_state(\r\n    repo: MockEventRepo,\r\n    signature: MockSignatureServ,\r\n    distributor: MockEventDist,\r\n    state: MockSubscriptionStateMock,\r\n    gateway: MockEventGateway,\r\n) -> EventService {\r\n    EventService::new(\r\n        Arc::new(repo) as Arc<dyn EventRepository>,\r\n        Arc::new(signature) as Arc<dyn SignatureService>,\r\n        Arc::new(distributor) as Arc<dyn EventDistributor>,\r\n        Arc::new(gateway)\r\n            as Arc<dyn kukuri_lib::application::ports::event_gateway::EventGateway>,\r\n        Arc::new(state) as Arc<dyn SubscriptionStateStore>,\r\n    )\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_event_success() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let event = service\r\n        .create_event(\r\n            1,\r\n            \"Test content\".to_string(),\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"create_event should succeed\");\r\n\r\n    assert_eq!(event.content, \"Test content\");\r\n    assert_eq!(event.pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_valid_signature() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(true));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_handle_incoming_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_invalid_signature() {\r\n    let mock_repo = MockEventRepo::new();\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(false));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_err());\r\n    assert!(\r\n        result\r\n            .unwrap_err()\r\n            .to_string()\r\n            .contains(\"Invalid event signature\")\r\n    );\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_requires_ids() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(Vec::new(), None)\r\n        .await\r\n        .expect_err(\"empty ids should result in validation error\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError { .. }));\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_with_invalid_id() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(vec![\"invalid\".to_string()], None)\r\n        .await\r\n        .expect_err(\"invalid id should fail\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError { .. }));\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_gateway_failure_maps_to_nostr_error() {\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_delete_events()\r\n        .times(1)\r\n        .returning(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let valid_id = format!(\"{:064x}\", 1);\r\n    let err = service\r\n        .delete_events(vec![valid_id], Some(\"cleanup\".to_string()))\r\n        .await\r\n        .expect_err(\"gateway failure should map to nostr error\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let event = create_test_event();\r\n    let cloned = event.clone();\r\n\r\n    mock_repo\r\n        .expect_get_event()\r\n        .with(eq(\"test_id\"))\r\n        .times(1)\r\n        .returning(move |_| Ok(Some(cloned.clone())));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_event(\"test_id\")\r\n        .await\r\n        .expect(\"get_event should succeed\");\r\n\r\n    assert!(fetched.is_some());\r\n    assert_eq!(fetched.unwrap().content, \"Test content\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_kind() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_kind()\r\n        .with(eq(1u32), eq(10usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_kind(1, 10)\r\n        .await\r\n        .expect(\"get_events_by_kind should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_author() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_author()\r\n        .with(eq(\"test_pubkey\"), eq(5usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_author(\"test_pubkey\", 5)\r\n        .await\r\n        .expect(\"get_events_by_author should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 1);\r\n    assert_eq!(fetched[0].pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n    mock_repo\r\n        .expect_delete_event()\r\n        .with(eq(\"event_to_delete\"))\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    service\r\n        .delete_event(\r\n            \"event_to_delete\",\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"delete_event should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_sync_pending_events() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_unsync_events()\r\n        .times(1)\r\n        .returning(move || Ok(cloned.clone()));\r\n\r\n    mock_repo\r\n        .expect_mark_event_synced()\r\n        .times(events.len())\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(events.len())\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let synced = service\r\n        .sync_pending_events()\r\n        .await\r\n        .expect(\"sync_pending_events should succeed\");\r\n\r\n    assert_eq!(synced, 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_uses_state_machine_and_invoker() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .withf(|target| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(1)\r\n        .withf(|target, _| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect(\"subscribe_to_topic should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_failure_marks_state() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_failure()\r\n        .times(1)\r\n        .withf(|target, message| {\r\n            matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\")\r\n                && message.contains(\"failed\")\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .return_once(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    let err = service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect_err(\"subscription failure should bubble up\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_handle_network_connected_restores_subscriptions() {\r\n    let topic_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::NeedsResync,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n    let user_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::User(\"user\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: Some(3600),\r\n        last_attempt_at: None,\r\n        failure_count: 1,\r\n        error_message: Some(\"previous failure\".into()),\r\n    };\r\n    let list_topic = topic_record.clone();\r\n    let list_user = user_record.clone();\r\n    let predicate_user = user_record.clone();\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_list_for_restore()\r\n        .times(1)\r\n        .return_once(move || Ok(vec![list_topic, list_user]));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(2)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n    mock_invoker\r\n        .expect_subscribe_user()\r\n        .times(1)\r\n        .withf(move |pubkey, since| {\r\n            pubkey == \"user\"\r\n                && since.map(|ts| ts.as_secs())\n                    == predicate_user\r\n                        .last_synced_at\r\n                        .map(|value| (value - 300) as u64)\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .handle_network_connected()\r\n        .await\r\n        .expect(\"handle_network_connected should succeed\");\r\n}\r\n\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","mod.rs"],"content":"mod event_service;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","mod.rs"],"content":"mod application;\n","traces":[],"covered":0,"coverable":0}],"coverage":40.937370385732066,"covered":4935,"coverable":12055}