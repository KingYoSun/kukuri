{"files":[{"path":["/","app","kukuri-tauri","src-tauri","benches","command_optimization.rs"],"content":"use criterion::{BenchmarkId, Criterion, black_box, criterion_group, criterion_main};\r\nuse tokio::runtime::Runtime;\r\n\r\nfn benchmark_single_vs_batch_posts(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"post_retrieval\");\r\n\r\n    // 10, 50, 100個の投稿IDでテスト\r\n    for size in [10, 50, 100].iter() {\r\n        let post_ids: Vec<String> = (0..*size).map(|i| format!(\"post_{}\", i)).collect();\r\n\r\n        group.bench_with_input(BenchmarkId::new(\"individual\", size), size, |b, _| {\r\n            b.to_async(&rt).iter(|| async {\r\n                // 個別取得のシミュレーション\r\n                for id in &post_ids {\r\n                    // DBアクセスのシミュレーション\r\n                    tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\r\n                }\r\n            });\r\n        });\r\n\r\n        group.bench_with_input(BenchmarkId::new(\"batch\", size), size, |b, _| {\r\n            b.to_async(&rt).iter(|| async {\r\n                // バッチ取得のシミュレーション\r\n                tokio::time::sleep(tokio::time::Duration::from_micros(200)).await;\r\n            });\r\n        });\r\n    }\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_cache_vs_no_cache(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"cache_performance\");\r\n\r\n    group.bench_function(\"without_cache\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // DBアクセスのシミュレーション\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await;\r\n            black_box(\"post_content\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"with_cache_miss\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // キャッシュチェック + DBアクセス\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await; // キャッシュチェック\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await; // DBアクセス\r\n            black_box(\"post_content\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"with_cache_hit\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // キャッシュヒット（DBアクセスなし）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await;\r\n            black_box(\"cached_post_content\");\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_parallel_npub_conversion(c: &mut Criterion) {\r\n    use nostr_sdk::prelude::*;\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"npub_conversion\");\r\n\r\n    let pubkeys: Vec<String> = (0..100)\r\n        .map(|i| {\r\n            format!(\r\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa{:03}\",\r\n                i\r\n            )\r\n        })\r\n        .collect();\r\n\r\n    group.bench_function(\"serial\", |b| {\r\n        b.iter(|| {\r\n            for pubkey in &pubkeys {\r\n                let _ = PublicKey::from_hex(pubkey)\r\n                    .ok()\r\n                    .and_then(|pk| pk.to_bech32().ok())\r\n                    .unwrap_or_else(|| pubkey.clone());\r\n            }\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"parallel\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            use futures::future::join_all;\r\n\r\n            let futures = pubkeys.iter().map(|pubkey| {\r\n                let pk = pubkey.clone();\r\n                async move {\r\n                    tokio::task::spawn_blocking(move || {\r\n                        PublicKey::from_hex(&pk)\r\n                            .ok()\r\n                            .and_then(|pk| pk.to_bech32().ok())\r\n                            .unwrap_or(pk)\r\n                    })\r\n                    .await\r\n                    .unwrap_or_else(|_| pubkey.clone())\r\n                }\r\n            });\r\n\r\n            let _ = join_all(futures).await;\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\nfn benchmark_handler_reuse(c: &mut Criterion) {\r\n    let rt = Runtime::new().unwrap();\r\n\r\n    let mut group = c.benchmark_group(\"handler_initialization\");\r\n\r\n    group.bench_function(\"new_handler_each_time\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // ハンドラーを毎回生成（最適化前）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(50)).await;\r\n            black_box(\"handler_created\");\r\n        });\r\n    });\r\n\r\n    group.bench_function(\"reused_handler\", |b| {\r\n        b.to_async(&rt).iter(|| async {\r\n            // ハンドラーを再利用（最適化後）\r\n            tokio::time::sleep(tokio::time::Duration::from_micros(1)).await;\r\n            black_box(\"handler_reused\");\r\n        });\r\n    });\r\n\r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    benchmark_single_vs_batch_posts,\r\n    benchmark_cache_vs_no_cache,\r\n    benchmark_parallel_npub_conversion,\r\n    benchmark_handler_reuse\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","build.rs"],"content":"fn main() {\n    tauri_build::build();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","mod.rs"],"content":"pub mod ports;\npub mod services;\npub mod shared;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","auth_lifecycle.rs"],"content":"use crate::application::ports::key_manager::KeyPair;\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\npub struct AuthAccountContext {\n    pub npub: String,\n    pub public_key: String,\n}\n\nimpl AuthAccountContext {\n    pub fn new(npub: impl Into<String>, public_key: impl Into<String>) -> Self {\n        Self {\n            npub: npub.into(),\n            public_key: public_key.into(),\n        }\n    }\n}\n\nimpl From<&KeyPair> for AuthAccountContext {\n    fn from(keypair: &KeyPair) -> Self {\n        Self {\n            npub: keypair.npub.clone(),\n            public_key: keypair.public_key.clone(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AuthLifecycleStage {\n    AccountCreated,\n    Login,\n}\n\n#[derive(Debug, Clone)]\npub struct AuthLifecycleEvent {\n    pub stage: AuthLifecycleStage,\n    pub account: AuthAccountContext,\n}\n\nimpl AuthLifecycleEvent {\n    pub fn new(stage: AuthLifecycleStage, account: AuthAccountContext) -> Self {\n        Self { stage, account }\n    }\n\n    pub fn account_created(account: AuthAccountContext) -> Self {\n        Self::new(AuthLifecycleStage::AccountCreated, account)\n    }\n\n    pub fn login(account: AuthAccountContext) -> Self {\n        Self::new(AuthLifecycleStage::Login, account)\n    }\n}\n\n#[async_trait]\npub trait AuthLifecyclePort: Send + Sync {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n}\n","traces":[{"line":13,"address":[15114011,15113760],"length":1,"stats":{"Line":1}},{"line":15,"address":[15216662],"length":1,"stats":{"Line":1}},{"line":16,"address":[15181615],"length":1,"stats":{"Line":1}},{"line":22,"address":[15313524,15313360],"length":1,"stats":{"Line":2}},{"line":24,"address":[15216951],"length":1,"stats":{"Line":2}},{"line":25,"address":[15216989],"length":1,"stats":{"Line":2}},{"line":43,"address":[15213184],"length":1,"stats":{"Line":2}},{"line":47,"address":[12950512],"length":1,"stats":{"Line":2}},{"line":48,"address":[15107343],"length":1,"stats":{"Line":2}},{"line":51,"address":[15175184],"length":1,"stats":{"Line":2}},{"line":52,"address":[15217247],"length":1,"stats":{"Line":2}}],"covered":11,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","cache.rs"],"content":"use crate::domain::entities::Post;\nuse async_trait::async_trait;\n\n/// 投稿エンティティ用のキャッシュポート\n#[async_trait]\npub trait PostCache: Send + Sync {\n    /// 投稿をキャッシュに追加\n    async fn add(&self, post: Post);\n\n    /// ID でキャッシュを検索\n    async fn get(&self, id: &str) -> Option<Post>;\n\n    /// キャッシュから投稿を削除\n    async fn remove(&self, id: &str) -> Option<Post>;\n\n    /// トピック単位で投稿を取得（新しい順）\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post>;\n\n    /// トピックの投稿キャッシュを丸ごと差し替え\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>);\n\n    /// トピックに紐づく投稿キャッシュを無効化\n    async fn invalidate_topic(&self, topic_id: &str);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","direct_message_notifier.rs"],"content":"use crate::domain::entities::DirectMessage;\nuse crate::shared::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait DirectMessageNotifier: Send + Sync {\n    async fn notify(&self, owner_npub: &str, message: &DirectMessage) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","event_gateway.rs"],"content":"use crate::domain::entities::{DomainEvent, ProfileMetadata};\r\nuse crate::domain::value_objects::{EventId, PublicKey, ReactionValue, TopicContent, TopicId};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\n\r\n/// EventManager 縺ｪ縺ｩ縺ｮ蜈ｷ菴灘ｮ溯｣・↓萓晏ｭ倥○縺壹、pplication 螻､縺九ｉ繧､繝吶Φ繝磯・菫｡繧呈桶縺・◆繧√・繝昴・繝医・///\r\n/// 險ｭ險医ラ繧ｭ繝･繝｡繝ｳ繝・ `docs/01_project/activeContext/artefacts/phase5_event_gateway_design.md`\r\n#[async_trait]\r\npub trait EventGateway: Send + Sync {\r\n    /// P2P 繧・Gossip 縺ｪ縺ｩ螟夜Κ繧ｽ繝ｼ繧ｹ縺九ｉ蜿嶺ｿ｡縺励◆繧､繝吶Φ繝医ｒ蜃ｦ逅・☆繧九・\r\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\r\n\r\n    /// 閾ｪ霄ｫ縺ｮ繝弱・繝峨→縺励※繝・く繧ｹ繝医ヮ繝ｼ繝医ｒ逋ｺ陦後☆繧九・\r\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\r\n\r\n    /// 繝医ヴ繝・け縺ｫ邏舌▼縺乗兜遞ｿ繧貞・髢九☆繧九Ａreply_to` 縺ｫ繧医ｊ繧ｹ繝ｬ繝・ラ霑比ｿ｡繧呈欠遉ｺ縺ｧ縺阪ｋ縲・\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError>;\n\r\n    /// 莉ｻ諢上う繝吶Φ繝医∈繝ｪ繧｢繧ｯ繧ｷ繝ｧ繝ｳ繧帝∽ｿ｡縺吶ｋ縲・\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &EventId,\r\n        reaction: &ReactionValue,\r\n    ) -> Result<EventId, AppError>;\r\n\r\n    /// 繝励Ο繝輔ぅ繝ｼ繝ｫ繝｡繧ｿ繝・・繧ｿ繧呈峩譁ｰ縺励∵眠縺励＞繧､繝吶Φ繝・ID 繧定ｿ泌唆縺吶ｋ縲・\r\n    async fn update_profile_metadata(\r\n        &self,\r\n        metadata: &ProfileMetadata,\r\n    ) -> Result<EventId, AppError>;\r\n\r\n    /// 謖・ｮ壹＆繧後◆繧､繝吶Φ繝育ｾ､繧貞炎髯､縺励∝炎髯､繧､繝吶Φ繝医・ ID 繧定ｿ泌唆縺吶ｋ縲・\r\n    async fn delete_events(\r\n        &self,\r\n        targets: &[EventId],\r\n        reason: Option<&str>,\r\n    ) -> Result<EventId, AppError>;\r\n    async fn publish_repost(&self, target: &EventId) -> Result<EventId, AppError>;\r\n\r\n    /// 繝阪ャ繝医Ρ繝ｼ繧ｯ謗･邯壹ｒ蛻・妙縺吶ｋ縲・\r\n    async fn disconnect(&self) -> Result<(), AppError>;\r\n\r\n    /// 繝弱・繝峨′蛻ｩ逕ｨ縺吶ｋ蜈ｬ髢矩嵯繧貞叙蠕励☆繧九・\r\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\r\n\r\n    /// 譌｢螳壹・雉ｼ隱ｭ繝医ヴ繝・け繧呈峩譁ｰ縺吶ｋ縲・\r\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\r\n\r\n    /// 譌｢螳壹・雉ｼ隱ｭ繝医ヴ繝・け繧剃ｸ隕ｧ縺吶ｋ縲・\r\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","event_topic_store.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n/// EventManager が参照するイベントとトピックの対応情報を\n/// アプリケーション層に閉じ込めるためのポート。\n#[async_trait]\npub trait EventTopicStore: Send + Sync {\n    /// イベントとトピックの関連を保存する（冪等）\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError>;\n\n    /// イベントが属するトピック一覧を取得する\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","group_key_store.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct GroupKeyEntry {\n    pub topic_id: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub stored_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct GroupKeyRecord {\n    pub topic_id: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub key_b64: String,\n    pub stored_at: i64,\n}\n\n#[async_trait]\npub trait GroupKeyStore: Send + Sync {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError>;\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError>;\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError>;\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","join_request_store.rs"],"content":"use crate::domain::entities::Event;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestRecord {\n    pub event: Event,\n    pub topic_id: String,\n    pub scope: String,\n    pub requester_pubkey: String,\n    pub target_pubkey: Option<String>,\n    pub requested_at: Option<i64>,\n    pub received_at: i64,\n    pub invite_event_json: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InviteUsageRecord {\n    pub invite_event_id: String,\n    pub max_uses: i64,\n    pub used_count: i64,\n    pub last_used_at: i64,\n}\n\n#[async_trait]\npub trait JoinRequestStore: Send + Sync {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError>;\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError>;\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError>;\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError>;\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError>;\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","key_manager.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyPair {\n    pub public_key: String,\n    pub private_key: String,\n    pub npub: String,\n    pub nsec: String,\n}\n\n#[async_trait]\npub trait KeyManager: Send + Sync {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError>;\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError>;\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError>;\n    async fn current_keypair(&self) -> Result<KeyPair, AppError>;\n}\n\n#[async_trait]\npub trait KeyMaterialStore: Send + Sync {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError>;\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError>;\n    async fn set_current(&self, npub: &str) -> Result<(), AppError>;\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","messaging_gateway.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\npub struct MessagingSendResult {\n    pub event_id: Option<String>,\n    pub ciphertext: String,\n    pub created_at_millis: i64,\n    pub delivered: bool,\n}\n\n#[async_trait]\npub trait MessagingGateway: Send + Sync {\n    async fn encrypt_and_send(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<MessagingSendResult, AppError>;\n\n    async fn encrypt_only(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<String, AppError>;\n\n    async fn decrypt_with_counterparty(\n        &self,\n        owner_npub: &str,\n        counterparty_npub: &str,\n        ciphertext: &str,\n    ) -> Result<String, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","mod.rs"],"content":"pub mod auth_lifecycle;\npub mod cache;\npub mod direct_message_notifier;\npub mod event_gateway;\npub mod event_topic_store;\npub mod group_key_store;\npub mod join_request_store;\npub mod key_manager;\npub mod messaging_gateway;\npub mod offline_store;\npub mod repositories;\npub mod secure_storage;\npub mod subscription_invoker;\npub mod subscription_state_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","offline_store.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft,\n    OfflineActionFilter, OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord,\n    SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusRecord,\n    SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait OfflinePersistence: Send + Sync {\n    async fn save_action(&self, draft: OfflineActionDraft) -> Result<SavedOfflineAction, AppError>;\n\n    async fn list_actions(\n        &self,\n        filter: OfflineActionFilter,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n\n    async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError>;\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError>;\n\n    async fn pending_sync_items(&self) -> Result<Vec<SyncQueueItem>, AppError>;\n\n    async fn stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError>;\n\n    async fn unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError>;\n\n    async fn sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","repositories.rs"],"content":"use crate::domain::entities::{\n    Bookmark, DirectMessage, Event, MetricsWindow, NewDirectMessage, PendingTopic,\n    PendingTopicStatus, Post, Topic, TopicActivityRow, TopicMetricsSnapshot, TopicMetricsUpsert,\n    User,\n};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};\nuse std::fmt;\n\n#[derive(Debug, Clone)]\npub struct UserCursorPage {\n    pub users: Vec<User>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum FollowListSort {\n    Recent,\n    Oldest,\n    NameAsc,\n    NameDesc,\n}\n\nimpl FollowListSort {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            Self::Recent => \"recent\",\n            Self::Oldest => \"oldest\",\n            Self::NameAsc => \"name_asc\",\n            Self::NameDesc => \"name_desc\",\n        }\n    }\n}\n\nimpl TryFrom<&str> for FollowListSort {\n    type Error = ();\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        match value {\n            \"recent\" => Ok(Self::Recent),\n            \"oldest\" => Ok(Self::Oldest),\n            \"name_asc\" => Ok(Self::NameAsc),\n            \"name_desc\" => Ok(Self::NameDesc),\n            _ => Err(()),\n        }\n    }\n}\n\n#[async_trait]\npub trait PostRepository: Send + Sync {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError>;\n    async fn get_posts_by_topic(&self, topic_id: &str, limit: usize)\n    -> Result<Vec<Post>, AppError>;\n    async fn update_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn delete_post(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError>;\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError>;\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError>;\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError>;\n    async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<PostFeedCursor>,\n        limit: usize,\n    ) -> Result<PostFeedPage, AppError>;\n}\n\n#[derive(Debug, Clone)]\npub struct PostFeedCursor {\n    pub created_at: i64,\n    pub event_id: String,\n}\n\nimpl PostFeedCursor {\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(2, ':');\n        let created_at = parts.next()?.parse().ok()?;\n        let event_id = parts.next()?.to_string();\n        if event_id.is_empty() {\n            return None;\n        }\n        Some(Self {\n            created_at,\n            event_id,\n        })\n    }\n}\n\nimpl fmt::Display for PostFeedCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}:{}\", self.created_at, self.event_id)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PostFeedPage {\n    pub items: Vec<Post>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[async_trait]\npub trait TopicRepository: Send + Sync {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn update_topic_stats(\n        &self,\n        topic_id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait PendingTopicRepository: Send + Sync {\n    async fn insert_pending_topic(&self, topic: &PendingTopic) -> Result<(), AppError>;\n    async fn list_pending_topics(&self, user_pubkey: &str) -> Result<Vec<PendingTopic>, AppError>;\n    async fn get_pending_topic(&self, pending_id: &str) -> Result<Option<PendingTopic>, AppError>;\n    async fn update_pending_topic_status(\n        &self,\n        pending_id: &str,\n        status: PendingTopicStatus,\n        synced_topic_id: Option<&str>,\n        error_message: Option<&str>,\n    ) -> Result<(), AppError>;\n    async fn delete_pending_topic(&self, pending_id: &str) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait TopicMetricsRepository: Send + Sync {\n    async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError>;\n    async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError>;\n    async fn collect_activity(\n        &self,\n        window: MetricsWindow,\n    ) -> Result<Vec<TopicActivityRow>, AppError>;\n    async fn latest_window_end(&self) -> Result<Option<i64>, AppError>;\n    async fn list_recent_metrics(\n        &self,\n        limit: usize,\n    ) -> Result<Option<TopicMetricsSnapshot>, AppError>;\n}\n\n#[async_trait]\npub trait UserRepository: Send + Sync {\n    async fn create_user(&self, user: &User) -> Result<(), AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError>;\n    async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError>;\n    async fn update_user(&self, user: &User) -> Result<(), AppError>;\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_followers_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError>;\n    async fn get_following_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError>;\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError>;\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError>;\n    async fn list_following_pubkeys(&self, follower_pubkey: &str) -> Result<Vec<String>, AppError>;\n    async fn list_follower_pubkeys(&self, followed_pubkey: &str) -> Result<Vec<String>, AppError>;\n}\n\n#[async_trait]\npub trait EventRepository: Send + Sync {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError>;\n    async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n\n    /// イベントとトピックのマッピングを登録（冪等）\n    async fn add_event_topic(&self, _event_id: &str, _topic_id: &str) -> Result<(), AppError> {\n        // 既定実装: 実装なし\n        Ok(())\n    }\n\n    /// イベントが属するトピックID一覧を取得\n    async fn get_event_topics(&self, _event_id: &str) -> Result<Vec<String>, AppError> {\n        // 既定実装: 空\n        Ok(vec![])\n    }\n}\n\n#[async_trait]\npub trait BookmarkRepository: Send + Sync {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError>;\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError>;\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError>;\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageCursor {\n    pub created_at: i64,\n    pub event_id: Option<String>,\n}\n\nimpl DirectMessageCursor {\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(2, ':');\n        let created_at = parts.next()?.parse().ok()?;\n        let event_id = parts\n            .next()\n            .filter(|s| !s.is_empty())\n            .map(|s| s.to_string());\n        Some(Self {\n            created_at,\n            event_id,\n        })\n    }\n}\n\nimpl fmt::Display for DirectMessageCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let event_part = self.event_id.as_deref().unwrap_or_default();\n        write!(f, \"{}:{}\", self.created_at, event_part)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationCursor {\n    pub last_message_created_at: Option<i64>,\n    pub conversation_npub: String,\n}\n\nimpl DirectMessageConversationCursor {\n    pub fn new(last_message_created_at: Option<i64>, conversation_npub: String) -> Self {\n        Self {\n            last_message_created_at,\n            conversation_npub,\n        }\n    }\n\n    pub fn parse(cursor: &str) -> Option<Self> {\n        let mut parts = cursor.splitn(3, ':');\n        let bucket = parts.next()?.parse::<i64>().ok()?;\n        if bucket != 0 && bucket != 1 {\n            return None;\n        }\n        let timestamp = parts.next()?.parse::<i64>().ok()?;\n        let encoded_npub = parts.next()?;\n        let npub_bytes = URL_SAFE_NO_PAD.decode(encoded_npub).ok()?;\n        let conversation_npub = String::from_utf8(npub_bytes).ok()?;\n        let last_message_created_at = if bucket == 0 { Some(timestamp) } else { None };\n        Some(Self {\n            last_message_created_at,\n            conversation_npub,\n        })\n    }\n\n    pub fn bucket(&self) -> i64 {\n        if self.last_message_created_at.is_some() {\n            0\n        } else {\n            1\n        }\n    }\n}\n\nimpl fmt::Display for DirectMessageConversationCursor {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let encoded_npub = URL_SAFE_NO_PAD.encode(self.conversation_npub.as_bytes());\n        let timestamp = self.last_message_created_at.unwrap_or(0);\n        write!(f, \"{}:{}:{}\", self.bucket(), timestamp, encoded_npub)\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum DirectMessageListDirection {\n    Backward,\n    Forward,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessagePageRaw {\n    pub items: Vec<DirectMessage>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationRecord {\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub last_message: Option<DirectMessage>,\n    pub last_message_created_at: Option<i64>,\n    pub last_read_at: i64,\n    pub unread_count: i64,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessageConversationPageRaw {\n    pub items: Vec<DirectMessageConversationRecord>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[async_trait]\npub trait DirectMessageRepository: Send + Sync {\n    async fn insert_direct_message(\n        &self,\n        message: &NewDirectMessage,\n    ) -> Result<DirectMessage, AppError>;\n\n    async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<DirectMessageCursor>,\n        limit: usize,\n        direction: DirectMessageListDirection,\n    ) -> Result<DirectMessagePageRaw, AppError>;\n\n    async fn mark_delivered_by_client_id(\n        &self,\n        owner_npub: &str,\n        client_message_id: &str,\n        event_id: Option<String>,\n        delivered: bool,\n    ) -> Result<(), AppError>;\n\n    async fn upsert_conversation_metadata(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        last_message_id: i64,\n        last_message_created_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<DirectMessageConversationCursor>,\n        limit: usize,\n    ) -> Result<DirectMessageConversationPageRaw, AppError>;\n}\n","traces":[{"line":29,"address":[23722928],"length":1,"stats":{"Line":0}},{"line":30,"address":[23761045],"length":1,"stats":{"Line":0}},{"line":31,"address":[23655156],"length":1,"stats":{"Line":0}},{"line":32,"address":[23761099],"length":1,"stats":{"Line":0}},{"line":33,"address":[23729938],"length":1,"stats":{"Line":0}},{"line":34,"address":[23729961],"length":1,"stats":{"Line":0}},{"line":42,"address":[23662240],"length":1,"stats":{"Line":0}},{"line":44,"address":[23662316,23662263],"length":1,"stats":{"Line":0}},{"line":45,"address":[23655317,23655387],"length":1,"stats":{"Line":0}},{"line":46,"address":[23861652,23861722],"length":1,"stats":{"Line":0}},{"line":47,"address":[23662432,23662387],"length":1,"stats":{"Line":0}},{"line":48,"address":[23861737],"length":1,"stats":{"Line":0}},{"line":84,"address":[23730915,23730224],"length":1,"stats":{"Line":1}},{"line":85,"address":[23655521],"length":1,"stats":{"Line":1}},{"line":86,"address":[14312151,14312425],"length":1,"stats":{"Line":1}},{"line":87,"address":[23767406,23767247,23767333],"length":1,"stats":{"Line":2}},{"line":88,"address":[14312492,14312566],"length":1,"stats":{"Line":2}},{"line":89,"address":[23862427],"length":1,"stats":{"Line":0}},{"line":91,"address":[23761949],"length":1,"stats":{"Line":1}},{"line":93,"address":[23730717],"length":1,"stats":{"Line":1}},{"line":99,"address":[23656208],"length":1,"stats":{"Line":1}},{"line":100,"address":[23724055],"length":1,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[23762304],"length":1,"stats":{"Line":0}},{"line":249,"address":[23731153],"length":1,"stats":{"Line":0}},{"line":250,"address":[23762359,23762716],"length":1,"stats":{"Line":0}},{"line":251,"address":[23862924],"length":1,"stats":{"Line":0}},{"line":253,"address":[23731564,23731552],"length":1,"stats":{"Line":0}},{"line":254,"address":[14313472,14313494],"length":1,"stats":{"Line":0}},{"line":255,"address":[17904206],"length":1,"stats":{"Line":0}},{"line":263,"address":[23724720],"length":1,"stats":{"Line":0}},{"line":264,"address":[23724753],"length":1,"stats":{"Line":0}},{"line":265,"address":[23731714],"length":1,"stats":{"Line":0}},{"line":276,"address":[23657120],"length":1,"stats":{"Line":1}},{"line":283,"address":[23767024,23768352,23768320],"length":1,"stats":{"Line":0}},{"line":284,"address":[23664177],"length":1,"stats":{"Line":0}},{"line":285,"address":[23664207,23664414],"length":1,"stats":{"Line":0}},{"line":286,"address":[23650743,23650641],"length":1,"stats":{"Line":0}},{"line":287,"address":[23763458],"length":1,"stats":{"Line":0}},{"line":289,"address":[23768953,23769269,23769054],"length":1,"stats":{"Line":0}},{"line":290,"address":[23664663,23664894,23664752],"length":1,"stats":{"Line":0}},{"line":291,"address":[14314531,14314412,14314671],"length":1,"stats":{"Line":0}},{"line":292,"address":[23658121,23658001,23658452,23658276],"length":1,"stats":{"Line":0}},{"line":293,"address":[23768119,23768150],"length":1,"stats":{"Line":0}},{"line":294,"address":[23768205],"length":1,"stats":{"Line":0}},{"line":295,"address":[14314930],"length":1,"stats":{"Line":0}},{"line":300,"address":[23864800],"length":1,"stats":{"Line":1}},{"line":301,"address":[23733276,23733257],"length":1,"stats":{"Line":1}},{"line":302,"address":[23665518],"length":1,"stats":{"Line":1}},{"line":304,"address":[23770035],"length":1,"stats":{"Line":0}},{"line":310,"address":[23726384,23726777],"length":1,"stats":{"Line":1}},{"line":311,"address":[23764529],"length":1,"stats":{"Line":1}},{"line":312,"address":[23865023,23864945],"length":1,"stats":{"Line":2}},{"line":313,"address":[23764660],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","secure_storage.rs"],"content":"use crate::domain::entities::{AccountMetadata, AccountRegistration, CurrentAccountSecret};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SecureAccountStore: Send + Sync {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError>;\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError>;\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError>;\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError>;\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError>;\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_invoker.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\n\n/// 購読復元や加入リクエストを実行するためのポート。\n///\n/// EventService など Application 層はこの trait を通じて購読処理を発行し、\n/// 具体的な実装（EventManager など）は Infrastructure 層に閉じ込める。\n#[async_trait]\npub trait SubscriptionInvoker: Send + Sync {\n    /// 指定トピックに対する購読を開始する。\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError>;\n\n    /// 指定ユーザー（公開鍵）に対する購読を開始する。\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_state_repository.rs"],"content":"use crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SubscriptionStateRepository: Send + Sync {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError>;\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError>;\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","access_control_service.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyRecord, GroupKeyStore};\nuse crate::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::application::ports::repositories::UserRepository;\nuse crate::application::shared::nostr::to_nostr_event;\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::crypto::SignatureService;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::{AppError, RateLimiter, ValidationFailureKind};\nuse base64::Engine;\nuse base64::engine::general_purpose::STANDARD as BASE64_STANDARD;\nuse chrono::Utc;\nuse nostr_sdk::prelude::{PublicKey, SecretKey, nip44};\nuse rand::rngs::OsRng;\nuse rand_core::TryRngCore;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse uuid::Uuid;\n\nconst KIP_NAMESPACE: &str = \"kukuri\";\nconst KIP_VERSION: &str = \"1\";\nconst KIND_KEY_ENVELOPE: u32 = 39020;\nconst KIND_INVITE_CAPABILITY: u32 = 39021;\nconst KIND_JOIN_REQUEST: u32 = 39022;\nconst JOIN_REQUEST_RATE_LIMIT_MAX: usize = 3;\nconst JOIN_REQUEST_RATE_LIMIT_WINDOW: Duration = Duration::from_secs(60);\n\n#[derive(Debug, Clone)]\npub struct JoinRequestInput {\n    pub topic_id: Option<String>,\n    pub scope: Option<String>,\n    pub invite_event_json: Option<serde_json::Value>,\n    pub target_pubkey: Option<String>,\n    pub broadcast_to_topic: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestResult {\n    pub event_id: String,\n    pub sent_topics: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinRequestApprovalResult {\n    pub event_id: String,\n    pub key_envelope_event_id: String,\n    pub recipient_pubkey: String,\n    pub topic_id: String,\n    pub scope: String,\n}\n\npub struct AccessControlService {\n    key_manager: Arc<dyn KeyManager>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n    join_request_store: Arc<dyn JoinRequestStore>,\n    user_repository: Arc<dyn UserRepository>,\n    signature_service: Arc<dyn SignatureService>,\n    gossip_service: Arc<dyn GossipService>,\n    join_request_rate_limiter: RateLimiter,\n}\n\nimpl AccessControlService {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n        join_request_store: Arc<dyn JoinRequestStore>,\n        user_repository: Arc<dyn UserRepository>,\n        signature_service: Arc<dyn SignatureService>,\n        gossip_service: Arc<dyn GossipService>,\n    ) -> Self {\n        Self {\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository,\n            signature_service,\n            gossip_service,\n            join_request_rate_limiter: RateLimiter::new(\n                JOIN_REQUEST_RATE_LIMIT_MAX,\n                JOIN_REQUEST_RATE_LIMIT_WINDOW,\n            ),\n        }\n    }\n\n    pub async fn issue_invite(\n        &self,\n        topic_id: &str,\n        expires_in: Option<i64>,\n        max_uses: Option<i64>,\n        nonce: Option<String>,\n    ) -> Result<serde_json::Value, AppError> {\n        if topic_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Topic ID is required\",\n            ));\n        }\n\n        let keypair = self.current_keypair().await?;\n        let now = Utc::now().timestamp();\n        let expires_in = expires_in.unwrap_or(86_400).max(60);\n        let expires_at = now.saturating_add(expires_in);\n        let max_uses = max_uses.unwrap_or(1).max(1);\n        let nonce = nonce.unwrap_or_else(|| Uuid::new_v4().to_string());\n\n        let _ = self.ensure_group_key(topic_id, \"invite\").await?;\n\n        let content = json!({\n            \"schema\": \"kukuri-invite-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"invite\",\n            \"expires\": expires_at,\n            \"max_uses\": max_uses,\n            \"nonce\": nonce,\n            \"issuer\": format!(\"pubkey:{}\", keypair.public_key),\n        })\n        .to_string();\n\n        let tags = vec![\n            vec![\"t\".to_string(), topic_id.to_string()],\n            vec![\"scope\".to_string(), \"invite\".to_string()],\n            vec![\"d\".to_string(), format!(\"invite:{nonce}\")],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n            vec![\"exp\".to_string(), expires_at.to_string()],\n        ];\n\n        let event = self\n            .build_signed_event(KIND_INVITE_CAPABILITY, content, tags)\n            .await?;\n        let nostr_event = to_nostr_event(&event)?;\n        serde_json::to_value(nostr_event)\n            .map_err(|err| AppError::SerializationError(err.to_string()))\n    }\n\n    pub async fn request_join(\n        &self,\n        input: JoinRequestInput,\n    ) -> Result<JoinRequestResult, AppError> {\n        let keypair = self.current_keypair().await?;\n        let requester_pubkey = keypair.public_key.clone();\n        let now = Utc::now().timestamp();\n        let broadcast_to_topic = input.broadcast_to_topic;\n\n        let (topic_id, scope, invite_event_json, issuer_pubkey) =\n            self.resolve_join_request_input(&input)?;\n        if let Some(issuer) = issuer_pubkey.as_ref() {\n            PublicKey::from_hex(issuer).map_err(|err| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid target pubkey: {err}\"),\n                )\n            })?;\n        }\n\n        let mut tags = vec![\n            vec![\"t\".to_string(), topic_id.clone()],\n            vec![\"scope\".to_string(), scope.clone()],\n            vec![\n                \"d\".to_string(),\n                format!(\"join:{topic_id}:{}:{requester_pubkey}\", Uuid::new_v4()),\n            ],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n        ];\n\n        if let Some(invite_event) = invite_event_json.as_ref() {\n            if let Some(invite_id) = invite_event.get(\"id\").and_then(|v| v.as_str()) {\n                tags.push(vec![\"e\".to_string(), invite_id.to_string()]);\n            }\n        }\n        if let Some(issuer) = issuer_pubkey.as_ref() {\n            tags.push(vec![\"p\".to_string(), issuer.to_string()]);\n        }\n\n        let mut content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": scope,\n            \"requester\": format!(\"pubkey:{requester_pubkey}\"),\n            \"requested_at\": now,\n        });\n        if let Some(invite_event) = invite_event_json {\n            content[\"invite_event_json\"] = invite_event;\n        }\n\n        let event = self\n            .build_signed_event(KIND_JOIN_REQUEST, content.to_string(), tags)\n            .await?;\n\n        let mut topics = HashSet::new();\n        if let Some(issuer) = issuer_pubkey {\n            topics.insert(user_topic_id(&issuer));\n        }\n        if broadcast_to_topic {\n            topics.insert(topic_id.clone());\n        }\n\n        if topics.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request target is missing\",\n            ));\n        }\n\n        let sent_topics: Vec<String> = topics.into_iter().collect();\n        self.broadcast_event(&event, &sent_topics).await?;\n\n        Ok(JoinRequestResult {\n            event_id: event.id.clone(),\n            sent_topics,\n        })\n    }\n\n    pub async fn list_pending_join_requests(&self) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let keypair = self.current_keypair().await?;\n        self.join_request_store\n            .list_requests(&keypair.public_key)\n            .await\n    }\n\n    pub async fn approve_join_request(\n        &self,\n        event_id: &str,\n    ) -> Result<JoinRequestApprovalResult, AppError> {\n        let keypair = self.current_keypair().await?;\n        if event_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request event_id is required\",\n            ));\n        }\n\n        let Some(record) = self\n            .join_request_store\n            .get_request(&keypair.public_key, event_id)\n            .await?\n        else {\n            return Err(AppError::NotFound(\"Join request not found\".to_string()));\n        };\n\n        let Some(context) = self\n            .validate_join_request_event(&record.event, &keypair.public_key)\n            .await?\n        else {\n            return Err(AppError::NotFound(\n                \"Join request is not available\".to_string(),\n            ));\n        };\n\n        let group_key = self\n            .ensure_group_key(&context.topic_id, &context.scope)\n            .await?;\n        let envelope_event = self\n            .build_key_envelope_event(&context.requester_pubkey, &group_key)\n            .await?;\n        let topics = vec![user_topic_id(&context.requester_pubkey)];\n        self.broadcast_event(&envelope_event, &topics).await?;\n\n        self.join_request_store\n            .delete_request(&keypair.public_key, event_id)\n            .await?;\n\n        Ok(JoinRequestApprovalResult {\n            event_id: record.event.id,\n            key_envelope_event_id: envelope_event.id,\n            recipient_pubkey: context.requester_pubkey,\n            topic_id: context.topic_id,\n            scope: context.scope,\n        })\n    }\n\n    pub async fn reject_join_request(&self, event_id: &str) -> Result<(), AppError> {\n        let keypair = self.current_keypair().await?;\n        if event_id.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Join request event_id is required\",\n            ));\n        }\n        self.join_request_store\n            .delete_request(&keypair.public_key, event_id)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn handle_incoming_event(&self, event: &Event) -> Result<(), AppError> {\n        match event.kind {\n            KIND_JOIN_REQUEST => self.handle_join_request(event).await?,\n            KIND_KEY_ENVELOPE => self.handle_key_envelope(event).await?,\n            _ => {}\n        }\n        Ok(())\n    }\n\n    async fn handle_join_request(&self, event: &Event) -> Result<(), AppError> {\n        let keypair = match self.key_manager.current_keypair().await {\n            Ok(pair) => pair,\n            Err(_) => return Ok(()),\n        };\n        let Some(context) = self\n            .validate_join_request_event(event, &keypair.public_key)\n            .await?\n        else {\n            return Ok(());\n        };\n\n        if self\n            .join_request_store\n            .get_request(&keypair.public_key, &event.id)\n            .await?\n            .is_some()\n        {\n            return Ok(());\n        }\n\n        let rate_key = format!(\n            \"join:{}:{}:{}\",\n            context.topic_id, context.scope, context.requester_pubkey\n        );\n        self.join_request_rate_limiter\n            .check_and_record(\n                &rate_key,\n                \"join.request の受信が多すぎます。しばらく待ってください\",\n            )\n            .await?;\n\n        if context.scope == \"invite\" {\n            let invite_event_id = context.invite_event_id.as_deref().ok_or_else(|| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invite event_id is missing\")\n            })?;\n            let max_uses = context.invite_max_uses.unwrap_or(1);\n            self.consume_invite_usage(&keypair.public_key, invite_event_id, max_uses)\n                .await?;\n        }\n\n        let record = JoinRequestRecord {\n            event: event.clone(),\n            topic_id: context.topic_id,\n            scope: context.scope,\n            requester_pubkey: context.requester_pubkey,\n            target_pubkey: context.target_pubkey,\n            requested_at: context.requested_at,\n            received_at: Utc::now().timestamp(),\n            invite_event_json: context.invite_event_json,\n        };\n\n        self.join_request_store\n            .upsert_request(&keypair.public_key, record)\n            .await?;\n        Ok(())\n    }\n\n    async fn validate_join_request_event(\n        &self,\n        event: &Event,\n        current_pubkey: &str,\n    ) -> Result<Option<JoinRequestContext>, AppError> {\n        if event.pubkey == current_pubkey {\n            return Ok(None);\n        }\n        if let Ok(nostr_event) = to_nostr_event(event) {\n            if nostr_event.verify().is_err() {\n                return Ok(None);\n            }\n        }\n\n        let tags = event.tags.clone();\n        let topic_id = require_tag_value(&tags, \"t\")?;\n        let scope = require_tag_value(&tags, \"scope\")?;\n        let _ = require_tag_value(&tags, \"d\")?;\n        validate_kip_tags(&tags)?;\n        match scope.as_str() {\n            \"invite\" | \"friend\" => {}\n            \"friend_plus\" => {}\n            _ => {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid join scope: {scope}\"),\n                ));\n            }\n        }\n        let target_pubkey = tag_value(&tags, \"p\");\n        if let Some(target) = target_pubkey.as_ref() {\n            if target != current_pubkey {\n                return Ok(None);\n            }\n        }\n\n        let content: JoinRequestPayload = serde_json::from_str(&event.content)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        if content.schema != \"kukuri-join-request-v1\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid join.request schema\",\n            ));\n        }\n        if let Some(topic) = content.topic.as_ref() {\n            if topic != &topic_id {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request topic mismatch\",\n                ));\n            }\n        }\n        if let Some(scope_value) = content.scope.as_ref() {\n            if scope_value != &scope {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request scope mismatch\",\n                ));\n            }\n        }\n        if let Some(requester) = content.requester.as_ref() {\n            if let Some(hex) = requester.strip_prefix(\"pubkey:\") {\n                if hex != event.pubkey {\n                    return Err(AppError::validation(\n                        ValidationFailureKind::Generic,\n                        \"Join.request requester mismatch\",\n                    ));\n                }\n            }\n        }\n        if let Some(requested_at) = content.requested_at {\n            if requested_at < 0 {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Join.request requested_at is invalid\",\n                ));\n            }\n        }\n\n        let mut invite_event_id = None;\n        let mut invite_max_uses = None;\n        if scope == \"invite\" {\n            let invite_json = content.invite_event_json.clone().ok_or_else(|| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invite payload is missing\")\n            })?;\n            let invite = validate_invite_event(&invite_json, Some(&topic_id))?;\n            invite_event_id = Some(invite.event_id.clone());\n            invite_max_uses = Some(invite.max_uses);\n            if let Some(target) = target_pubkey.as_ref() {\n                if invite.issuer_pubkey != *target {\n                    return Ok(None);\n                }\n            }\n        }\n        if scope == \"friend_plus\" {\n            let is_fof = self\n                .is_friend_of_friend(current_pubkey, &event.pubkey)\n                .await?;\n            if !is_fof {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"friend_plus join.request requires FoF\",\n                ));\n            }\n        }\n\n        Ok(Some(JoinRequestContext {\n            topic_id,\n            scope,\n            target_pubkey,\n            requester_pubkey: event.pubkey.clone(),\n            invite_event_json: content.invite_event_json,\n            invite_event_id,\n            invite_max_uses,\n            requested_at: content.requested_at,\n        }))\n    }\n\n    async fn handle_key_envelope(&self, event: &Event) -> Result<(), AppError> {\n        let keypair = match self.key_manager.current_keypair().await {\n            Ok(pair) => pair,\n            Err(_) => return Ok(()),\n        };\n        if let Ok(nostr_event) = to_nostr_event(event) {\n            if nostr_event.verify().is_err() {\n                return Ok(());\n            }\n        }\n\n        let tags = event.tags.clone();\n        validate_kip_tags(&tags)?;\n        let recipient = require_tag_value(&tags, \"p\")?;\n        if recipient != keypair.public_key {\n            return Ok(());\n        }\n        let topic_tag = require_tag_value(&tags, \"t\")?;\n        let scope_tag = require_tag_value(&tags, \"scope\")?;\n        let epoch_tag = require_tag_value(&tags, \"epoch\")?\n            .parse::<i64>()\n            .map_err(|_| {\n                AppError::validation(ValidationFailureKind::Generic, \"Invalid epoch tag\")\n            })?;\n        if epoch_tag <= 0 {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid epoch tag\",\n            ));\n        }\n\n        let secret_key = SecretKey::from_hex(&keypair.private_key)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid private key: {err}\")))?;\n        let sender_pubkey = PublicKey::from_hex(&event.pubkey)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid sender pubkey: {err}\")))?;\n        let decrypted = nip44::decrypt(&secret_key, &sender_pubkey, event.content.clone())\n            .map_err(|err| AppError::Crypto(format!(\"NIP-44 decrypt failed: {err}\")))?;\n        let payload: KeyEnvelopePayload = serde_json::from_str(&decrypted)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n        if payload.schema != \"kukuri-key-envelope-v1\" && payload.schema != \"kukuri-keyenv-v1\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invalid key envelope schema\",\n            ));\n        }\n        if payload.topic != topic_tag || payload.scope != scope_tag || payload.epoch != epoch_tag {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Key envelope payload mismatch\",\n            ));\n        }\n\n        let stored_at = payload.issued_at.unwrap_or_else(|| Utc::now().timestamp());\n        let record = GroupKeyRecord {\n            topic_id: payload.topic,\n            scope: payload.scope,\n            epoch: payload.epoch,\n            key_b64: payload.key_b64,\n            stored_at,\n        };\n        self.group_key_store.store_key(record).await?;\n        Ok(())\n    }\n\n    async fn ensure_group_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<GroupKeyRecord, AppError> {\n        if let Some(record) = self.group_key_store.get_latest_key(topic_id, scope).await? {\n            return Ok(record);\n        }\n\n        let mut key_bytes = [0u8; 32];\n        OsRng\n            .try_fill_bytes(&mut key_bytes)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to generate group key: {err}\")))?;\n        let key_b64 = BASE64_STANDARD.encode(key_bytes);\n        let record = GroupKeyRecord {\n            topic_id: topic_id.to_string(),\n            scope: scope.to_string(),\n            epoch: 1,\n            key_b64,\n            stored_at: Utc::now().timestamp(),\n        };\n        self.group_key_store.store_key(record.clone()).await?;\n        Ok(record)\n    }\n\n    async fn build_key_envelope_event(\n        &self,\n        recipient_pubkey: &str,\n        record: &GroupKeyRecord,\n    ) -> Result<Event, AppError> {\n        let keypair = self.current_keypair().await?;\n        let secret_key = SecretKey::from_hex(&keypair.private_key)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid private key: {err}\")))?;\n        let recipient = PublicKey::from_hex(recipient_pubkey)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid recipient pubkey: {err}\")))?;\n\n        let payload = json!({\n            \"schema\": \"kukuri-key-envelope-v1\",\n            \"topic\": record.topic_id.clone(),\n            \"scope\": record.scope.clone(),\n            \"epoch\": record.epoch,\n            \"key_b64\": record.key_b64.clone(),\n            \"issued_at\": Utc::now().timestamp()\n        });\n        let encrypted = nip44::encrypt(\n            &secret_key,\n            &recipient,\n            payload.to_string(),\n            nip44::Version::V2,\n        )\n        .map_err(|err| AppError::Crypto(format!(\"NIP-44 encrypt failed: {err}\")))?;\n\n        let d_tag = format!(\n            \"keyenv:{}:{}:{}:{}\",\n            record.topic_id.as_str(),\n            record.scope.as_str(),\n            record.epoch,\n            recipient_pubkey\n        );\n        let tags = vec![\n            vec![\"p\".to_string(), recipient_pubkey.to_string()],\n            vec![\"t\".to_string(), record.topic_id.clone()],\n            vec![\"scope\".to_string(), record.scope.clone()],\n            vec![\"epoch\".to_string(), record.epoch.to_string()],\n            vec![\"k\".to_string(), KIP_NAMESPACE.to_string()],\n            vec![\"ver\".to_string(), KIP_VERSION.to_string()],\n            vec![\"d\".to_string(), d_tag],\n        ];\n\n        self.build_signed_event(KIND_KEY_ENVELOPE, encrypted, tags)\n            .await\n    }\n\n    async fn build_signed_event(\n        &self,\n        kind: u32,\n        content: String,\n        tags: Vec<Vec<String>>,\n    ) -> Result<Event, AppError> {\n        let keypair = self.current_keypair().await?;\n        let mut event = Event::new(kind, content, keypair.public_key.clone()).with_tags(tags);\n        self.signature_service\n            .sign_event(&mut event, &keypair.private_key)\n            .await\n            .map_err(|err| AppError::Crypto(err.to_string()))?;\n        Ok(event)\n    }\n\n    async fn broadcast_event(&self, event: &Event, topics: &[String]) -> Result<(), AppError> {\n        let mut uniq: HashSet<String> = HashSet::new();\n        for topic in topics {\n            let trimmed = topic.trim();\n            if !trimmed.is_empty() {\n                uniq.insert(trimmed.to_string());\n            }\n        }\n\n        for topic in uniq {\n            self.gossip_service.join_topic(&topic, Vec::new()).await?;\n            self.gossip_service.broadcast(&topic, event).await?;\n        }\n        Ok(())\n    }\n\n    async fn collect_mutual_follow_pubkeys(\n        &self,\n        pubkey: &str,\n    ) -> Result<HashSet<String>, AppError> {\n        let following = self.user_repository.list_following_pubkeys(pubkey).await?;\n        let followers = self.user_repository.list_follower_pubkeys(pubkey).await?;\n        let following_set: HashSet<String> = following.into_iter().collect();\n        let mut mutual = HashSet::new();\n        for follower in followers {\n            if following_set.contains(&follower) {\n                mutual.insert(follower);\n            }\n        }\n        Ok(mutual)\n    }\n\n    async fn is_friend_of_friend(\n        &self,\n        current_pubkey: &str,\n        requester_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        if current_pubkey == requester_pubkey {\n            return Ok(false);\n        }\n        let current_friends = self.collect_mutual_follow_pubkeys(current_pubkey).await?;\n        if current_friends.is_empty() {\n            return Ok(false);\n        }\n        let requester_friends = self\n            .collect_mutual_follow_pubkeys(requester_pubkey)\n            .await?;\n        if requester_friends.is_empty() {\n            return Ok(false);\n        }\n        Ok(current_friends\n            .intersection(&requester_friends)\n            .next()\n            .is_some())\n    }\n\n    async fn consume_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n        max_uses: i64,\n    ) -> Result<(), AppError> {\n        let now = Utc::now().timestamp();\n        let incoming_max = max_uses.max(1);\n        let mut record = match self\n            .join_request_store\n            .get_invite_usage(owner_pubkey, invite_event_id)\n            .await?\n        {\n            Some(record) => record,\n            None => InviteUsageRecord {\n                invite_event_id: invite_event_id.to_string(),\n                max_uses: incoming_max,\n                used_count: 0,\n                last_used_at: now,\n            },\n        };\n\n        let existing_max = record.max_uses.max(1);\n        let effective_max = existing_max.min(incoming_max);\n        if record.used_count >= effective_max {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite max_uses exceeded\",\n            ));\n        }\n\n        record.used_count += 1;\n        record.max_uses = effective_max;\n        record.last_used_at = now;\n        self.join_request_store\n            .upsert_invite_usage(owner_pubkey, record)\n            .await?;\n        Ok(())\n    }\n\n    fn resolve_join_request_input(\n        &self,\n        input: &JoinRequestInput,\n    ) -> Result<(String, String, Option<serde_json::Value>, Option<String>), AppError> {\n        if let Some(invite_json) = input.invite_event_json.as_ref() {\n            let invite = validate_invite_event(invite_json, None)?;\n            let topic_id = invite.topic_id;\n            let scope = \"invite\".to_string();\n            let issuer_pubkey = Some(invite.issuer_pubkey);\n            return Ok((topic_id, scope, Some(invite_json.clone()), issuer_pubkey));\n        }\n\n        let topic_id = input.topic_id.clone().ok_or_else(|| {\n            AppError::validation(ValidationFailureKind::Generic, \"Topic ID is required\")\n        })?;\n        let scope = input.scope.clone().unwrap_or_else(|| \"friend\".to_string());\n        if scope == \"invite\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite JSON is required for invite scope\",\n            ));\n        }\n        if scope != \"friend\" && scope != \"friend_plus\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unsupported join scope: {scope}\"),\n            ));\n        }\n\n        let issuer_pubkey = input\n            .target_pubkey\n            .as_ref()\n            .map(|value| value.trim().to_string())\n            .filter(|value| !value.is_empty());\n        if issuer_pubkey.is_none() && !input.broadcast_to_topic {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Target pubkey or broadcast_to_topic is required\",\n            ));\n        }\n\n        Ok((topic_id, scope, None, issuer_pubkey))\n    }\n\n    async fn current_keypair(\n        &self,\n    ) -> Result<crate::application::ports::key_manager::KeyPair, AppError> {\n        self.key_manager.current_keypair().await\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct JoinRequestContext {\n    topic_id: String,\n    scope: String,\n    target_pubkey: Option<String>,\n    requester_pubkey: String,\n    invite_event_json: Option<serde_json::Value>,\n    invite_event_id: Option<String>,\n    invite_max_uses: Option<i64>,\n    requested_at: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct JoinRequestPayload {\n    schema: String,\n    topic: Option<String>,\n    scope: Option<String>,\n    invite_event_json: Option<serde_json::Value>,\n    requester: Option<String>,\n    requested_at: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct KeyEnvelopePayload {\n    schema: String,\n    topic: String,\n    scope: String,\n    epoch: i64,\n    key_b64: String,\n    issued_at: Option<i64>,\n}\n\nstruct InviteValidation {\n    topic_id: String,\n    issuer_pubkey: String,\n    event_id: String,\n    max_uses: i64,\n}\n\nfn validate_invite_event(\n    value: &serde_json::Value,\n    expected_topic: Option<&str>,\n) -> Result<InviteValidation, AppError> {\n    let event: nostr_sdk::Event = serde_json::from_value(value.clone())\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n    if event.kind.as_u16() as u32 != KIND_INVITE_CAPABILITY {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid invite event kind\",\n        ));\n    }\n    let tags = event\n        .tags\n        .iter()\n        .map(|tag| tag.clone().to_vec())\n        .collect::<Vec<_>>();\n    validate_kip_tags(&tags)?;\n    let topic_id = require_tag_value(&tags, \"t\")?;\n    if let Some(expected) = expected_topic {\n        if expected != topic_id {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite topic mismatch\",\n            ));\n        }\n    }\n    let scope = require_tag_value(&tags, \"scope\")?;\n    if scope != \"invite\" {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite scope must be invite\",\n        ));\n    }\n    let invite_d = require_tag_value(&tags, \"d\")?;\n    if !invite_d.starts_with(\"invite:\") {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite d tag is invalid\",\n        ));\n    }\n    if event.verify().is_err() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite signature is invalid\",\n        ));\n    }\n\n    let payload: InvitePayload = serde_json::from_str(&event.content)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    if payload.schema != \"kukuri-invite-v1\" {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid invite schema\",\n        ));\n    }\n    if let Some(topic) = payload.topic.as_ref() {\n        if topic != &topic_id {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite topic mismatch\",\n            ));\n        }\n    }\n    if let Some(scope) = payload.scope.as_ref() {\n        if scope != \"invite\" {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite scope mismatch\",\n            ));\n        }\n    }\n    if let Some(expires) = payload.expires {\n        if expires <= Utc::now().timestamp() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite has expired\",\n            ));\n        }\n    }\n    let max_uses = payload.max_uses.unwrap_or(1);\n    if max_uses <= 0 {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invite max_uses must be positive\",\n        ));\n    }\n    if let Some(nonce) = payload.nonce.as_ref() {\n        if nonce.trim().is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite nonce is empty\",\n            ));\n        }\n        let expected = format!(\"invite:{nonce}\");\n        if invite_d != expected {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Invite nonce mismatch\",\n            ));\n        }\n    }\n\n    if let Some(issuer) = payload.issuer.as_ref() {\n        if let Some(hex) = issuer.strip_prefix(\"pubkey:\") {\n            if hex != event.pubkey.to_string() {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Invite issuer mismatch\",\n                ));\n            }\n        }\n    }\n\n    Ok(InviteValidation {\n        topic_id,\n        issuer_pubkey: event.pubkey.to_string(),\n        event_id: event.id.to_string(),\n        max_uses,\n    })\n}\n\n#[derive(Debug, Deserialize)]\nstruct InvitePayload {\n    schema: String,\n    topic: Option<String>,\n    scope: Option<String>,\n    expires: Option<i64>,\n    max_uses: Option<i64>,\n    nonce: Option<String>,\n    issuer: Option<String>,\n}\n\nfn validate_kip_tags(tags: &[Vec<String>]) -> Result<(), AppError> {\n    let namespace = require_tag_value(tags, \"k\")?;\n    if namespace != KIP_NAMESPACE {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid k tag\",\n        ));\n    }\n    let ver = require_tag_value(tags, \"ver\")?;\n    if ver != KIP_VERSION {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Invalid ver tag\",\n        ));\n    }\n    Ok(())\n}\n\nfn tag_value(tags: &[Vec<String>], name: &str) -> Option<String> {\n    tags.iter()\n        .find(|tag| tag.first().map(|v| v.as_str()) == Some(name))\n        .and_then(|tag| tag.get(1))\n        .cloned()\n}\n\nfn require_tag_value(tags: &[Vec<String>], name: &str) -> Result<String, AppError> {\n    tag_value(tags, name).ok_or_else(|| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Missing {name} tag\"),\n        )\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::group_key_store::GroupKeyEntry;\n    use crate::application::ports::join_request_store::{InviteUsageRecord, JoinRequestStore};\n    use crate::application::ports::key_manager::KeyPair;\n    use crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\n    use crate::domain::entities::User;\n    use crate::infrastructure::crypto::DefaultSignatureService;\n    use async_trait::async_trait;\n    use chrono::{TimeZone, Utc};\n    use nostr_sdk::ToBech32;\n    use nostr_sdk::prelude::{EventBuilder, Keys, Kind, Tag};\n    use std::collections::{HashMap, HashSet};\n    use tokio::sync::RwLock;\n\n    #[derive(Clone)]\n    struct TestKeyManager {\n        keypair: KeyPair,\n    }\n\n    impl TestKeyManager {\n        fn new(keypair: KeyPair) -> Self {\n            Self { keypair }\n        }\n    }\n\n    #[async_trait]\n    impl KeyManager for TestKeyManager {\n        async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n            Err(AppError::NotImplemented(\"generate_keypair\".into()))\n        }\n\n        async fn import_private_key(&self, _nsec: &str) -> Result<KeyPair, AppError> {\n            Err(AppError::NotImplemented(\"import_private_key\".into()))\n        }\n\n        async fn export_private_key(&self, _npub: &str) -> Result<String, AppError> {\n            Err(AppError::NotImplemented(\"export_private_key\".into()))\n        }\n\n        async fn get_public_key(&self, _npub: &str) -> Result<String, AppError> {\n            Err(AppError::NotImplemented(\"get_public_key\".into()))\n        }\n\n        async fn store_keypair(&self, _keypair: &KeyPair) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"store_keypair\".into()))\n        }\n\n        async fn delete_keypair(&self, _npub: &str) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"delete_keypair\".into()))\n        }\n\n        async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n            Ok(vec![self.keypair.npub.clone()])\n        }\n\n        async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n            Ok(self.keypair.clone())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestGroupKeyStore {\n        records: Arc<RwLock<Vec<GroupKeyRecord>>>,\n    }\n\n    impl TestGroupKeyStore {\n        async fn latest_key(&self, topic_id: &str, scope: &str) -> Option<GroupKeyRecord> {\n            let records = self.records.read().await;\n            records\n                .iter()\n                .filter(|record| record.topic_id == topic_id && record.scope == scope)\n                .max_by_key(|record| record.epoch)\n                .cloned()\n        }\n    }\n\n    #[async_trait]\n    impl GroupKeyStore for TestGroupKeyStore {\n        async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            records.retain(|existing| {\n                !(existing.topic_id == record.topic_id\n                    && existing.scope == record.scope\n                    && existing.epoch == record.epoch)\n            });\n            records.push(record);\n            Ok(())\n        }\n\n        async fn get_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n            epoch: i64,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .iter()\n                .find(|record| {\n                    record.topic_id == topic_id && record.scope == scope && record.epoch == epoch\n                })\n                .cloned())\n        }\n\n        async fn get_latest_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            Ok(self.latest_key(topic_id, scope).await)\n        }\n\n        async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .iter()\n                .map(|record| GroupKeyEntry {\n                    topic_id: record.topic_id.clone(),\n                    scope: record.scope.clone(),\n                    epoch: record.epoch,\n                    stored_at: record.stored_at,\n                })\n                .collect())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestJoinRequestStore {\n        records: Arc<RwLock<HashMap<String, HashMap<String, JoinRequestRecord>>>>,\n        invite_usage: Arc<RwLock<HashMap<String, HashMap<String, InviteUsageRecord>>>>,\n    }\n\n    #[async_trait]\n    impl JoinRequestStore for TestJoinRequestStore {\n        async fn upsert_request(\n            &self,\n            owner_pubkey: &str,\n            record: JoinRequestRecord,\n        ) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            let owner = records.entry(owner_pubkey.to_string()).or_default();\n            owner.insert(record.event.id.clone(), record);\n            Ok(())\n        }\n\n        async fn list_requests(\n            &self,\n            owner_pubkey: &str,\n        ) -> Result<Vec<JoinRequestRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .map(|owner| owner.values().cloned().collect())\n                .unwrap_or_default())\n        }\n\n        async fn get_request(\n            &self,\n            owner_pubkey: &str,\n            event_id: &str,\n        ) -> Result<Option<JoinRequestRecord>, AppError> {\n            let records = self.records.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .and_then(|owner| owner.get(event_id).cloned()))\n        }\n\n        async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n            let mut records = self.records.write().await;\n            if let Some(owner) = records.get_mut(owner_pubkey) {\n                owner.remove(event_id);\n            }\n            Ok(())\n        }\n\n        async fn get_invite_usage(\n            &self,\n            owner_pubkey: &str,\n            invite_event_id: &str,\n        ) -> Result<Option<InviteUsageRecord>, AppError> {\n            let records = self.invite_usage.read().await;\n            Ok(records\n                .get(owner_pubkey)\n                .and_then(|owner| owner.get(invite_event_id).cloned()))\n        }\n\n        async fn upsert_invite_usage(\n            &self,\n            owner_pubkey: &str,\n            record: InviteUsageRecord,\n        ) -> Result<(), AppError> {\n            let mut records = self.invite_usage.write().await;\n            let owner = records.entry(owner_pubkey.to_string()).or_default();\n            owner.insert(record.invite_event_id.clone(), record);\n            Ok(())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestUserRepository {\n        follows: Arc<RwLock<HashSet<(String, String)>>>,\n    }\n\n    impl TestUserRepository {\n        async fn seed_follow(&self, follower: &str, followed: &str) {\n            let mut follows = self.follows.write().await;\n            follows.insert((follower.to_string(), followed.to_string()));\n        }\n    }\n\n    #[async_trait]\n    impl UserRepository for TestUserRepository {\n        async fn create_user(&self, _user: &User) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"create_user\".into()))\n        }\n\n        async fn get_user(&self, _npub: &str) -> Result<Option<User>, AppError> {\n            Err(AppError::NotImplemented(\"get_user\".into()))\n        }\n\n        async fn get_user_by_pubkey(&self, _pubkey: &str) -> Result<Option<User>, AppError> {\n            Err(AppError::NotImplemented(\"get_user_by_pubkey\".into()))\n        }\n\n        async fn search_users(&self, _query: &str, _limit: usize) -> Result<Vec<User>, AppError> {\n            Err(AppError::NotImplemented(\"search_users\".into()))\n        }\n\n        async fn update_user(&self, _user: &User) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"update_user\".into()))\n        }\n\n        async fn delete_user(&self, _npub: &str) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"delete_user\".into()))\n        }\n\n        async fn get_followers_paginated(\n            &self,\n            _npub: &str,\n            _cursor: Option<&str>,\n            _limit: usize,\n            _sort: FollowListSort,\n            _search: Option<&str>,\n        ) -> Result<UserCursorPage, AppError> {\n            Err(AppError::NotImplemented(\"get_followers_paginated\".into()))\n        }\n\n        async fn get_following_paginated(\n            &self,\n            _npub: &str,\n            _cursor: Option<&str>,\n            _limit: usize,\n            _sort: FollowListSort,\n            _search: Option<&str>,\n        ) -> Result<UserCursorPage, AppError> {\n            Err(AppError::NotImplemented(\"get_following_paginated\".into()))\n        }\n\n        async fn add_follow_relation(\n            &self,\n            follower_pubkey: &str,\n            followed_pubkey: &str,\n        ) -> Result<bool, AppError> {\n            let mut follows = self.follows.write().await;\n            Ok(follows.insert((\n                follower_pubkey.to_string(),\n                followed_pubkey.to_string(),\n            )))\n        }\n\n        async fn remove_follow_relation(\n            &self,\n            follower_pubkey: &str,\n            followed_pubkey: &str,\n        ) -> Result<bool, AppError> {\n            let mut follows = self.follows.write().await;\n            Ok(follows.remove(&(\n                follower_pubkey.to_string(),\n                followed_pubkey.to_string(),\n            )))\n        }\n\n        async fn list_following_pubkeys(\n            &self,\n            follower_pubkey: &str,\n        ) -> Result<Vec<String>, AppError> {\n            let follows = self.follows.read().await;\n            Ok(follows\n                .iter()\n                .filter_map(|(follower, followed)| {\n                    if follower == follower_pubkey {\n                        Some(followed.clone())\n                    } else {\n                        None\n                    }\n                })\n                .collect())\n        }\n\n        async fn list_follower_pubkeys(\n            &self,\n            followed_pubkey: &str,\n        ) -> Result<Vec<String>, AppError> {\n            let follows = self.follows.read().await;\n            Ok(follows\n                .iter()\n                .filter_map(|(follower, followed)| {\n                    if followed == followed_pubkey {\n                        Some(follower.clone())\n                    } else {\n                        None\n                    }\n                })\n                .collect())\n        }\n    }\n\n    #[derive(Clone, Default)]\n    struct TestGossipService {\n        joined: Arc<RwLock<HashSet<String>>>,\n        broadcasts: Arc<RwLock<Vec<(String, Event)>>>,\n    }\n\n    impl TestGossipService {\n        async fn broadcasts(&self) -> Vec<(String, Event)> {\n            self.broadcasts.read().await.clone()\n        }\n    }\n\n    #[async_trait]\n    impl GossipService for TestGossipService {\n        async fn join_topic(\n            &self,\n            topic: &str,\n            _initial_peers: Vec<String>,\n        ) -> Result<(), AppError> {\n            self.joined.write().await.insert(topic.to_string());\n            Ok(())\n        }\n\n        async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n            self.joined.write().await.remove(topic);\n            Ok(())\n        }\n\n        async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n            self.broadcasts\n                .write()\n                .await\n                .push((topic.to_string(), event.clone()));\n            Ok(())\n        }\n\n        async fn subscribe(\n            &self,\n            _topic: &str,\n        ) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError> {\n            Err(AppError::NotImplemented(\"subscribe\".into()))\n        }\n\n        async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n            Ok(self.joined.read().await.iter().cloned().collect())\n        }\n\n        async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n            Err(AppError::NotImplemented(\"get_topic_peers\".into()))\n        }\n\n        async fn get_topic_stats(\n            &self,\n            _topic: &str,\n        ) -> Result<Option<crate::domain::p2p::TopicStats>, AppError> {\n            Err(AppError::NotImplemented(\"get_topic_stats\".into()))\n        }\n\n        async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n            Err(AppError::NotImplemented(\"broadcast_message\".into()))\n        }\n    }\n\n    fn make_keypair() -> (Keys, KeyPair) {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_string();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let npub = keys\n            .public_key()\n            .to_bech32()\n            .unwrap_or_else(|_| public_key.clone());\n        let nsec = format!(\"nsec1{private_key}\");\n        let keypair = KeyPair {\n            public_key,\n            private_key,\n            npub,\n            nsec,\n        };\n        (keys, keypair)\n    }\n\n    fn domain_event_from_nostr(event: &nostr_sdk::Event) -> Event {\n        let created_at = Utc\n            .timestamp_opt(event.created_at.as_secs() as i64, 0)\n            .single()\n            .expect(\"timestamp\");\n        Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn issue_invite_creates_event_and_group_key() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let invite_json = service\n            .issue_invite(\"kukuri:topic1\", Some(600), Some(2), Some(\"nonce-1\".into()))\n            .await\n            .expect(\"invite\");\n\n        let event: nostr_sdk::Event = serde_json::from_value(invite_json).expect(\"nostr event\");\n        assert_eq!(event.kind.as_u16() as u32, KIND_INVITE_CAPABILITY);\n\n        let tags = event\n            .tags\n            .iter()\n            .map(|tag| tag.clone().to_vec())\n            .collect::<Vec<_>>();\n        assert_eq!(tag_value(&tags, \"t\"), Some(\"kukuri:topic1\".to_string()));\n        assert_eq!(tag_value(&tags, \"scope\"), Some(\"invite\".to_string()));\n        assert_eq!(tag_value(&tags, \"k\"), Some(KIP_NAMESPACE.to_string()));\n        assert_eq!(tag_value(&tags, \"ver\"), Some(KIP_VERSION.to_string()));\n        assert_eq!(tag_value(&tags, \"d\"), Some(\"invite:nonce-1\".to_string()));\n\n        let stored = group_key_store\n            .get_latest_key(\"kukuri:topic1\", \"invite\")\n            .await\n            .expect(\"store\")\n            .expect(\"group key\");\n        assert_eq!(stored.scope, \"invite\");\n    }\n\n    #[tokio::test]\n    async fn request_join_with_invite_broadcasts_to_issuer_topic() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let invite_json = service\n            .issue_invite(\"kukuri:topic1\", Some(600), Some(1), Some(\"nonce-2\".into()))\n            .await\n            .expect(\"invite\");\n        let invite_event: nostr_sdk::Event =\n            serde_json::from_value(invite_json.clone()).expect(\"nostr event\");\n\n        let result = service\n            .request_join(JoinRequestInput {\n                topic_id: None,\n                scope: None,\n                invite_event_json: Some(invite_json),\n                target_pubkey: None,\n                broadcast_to_topic: false,\n            })\n            .await\n            .expect(\"join request\");\n\n        let issuer_topic = user_topic_id(&invite_event.pubkey.to_string());\n        assert!(result.sent_topics.contains(&issuer_topic));\n\n        let broadcasts = gossip_service.broadcasts().await;\n        assert_eq!(broadcasts.len(), 1);\n        let (topic, event) = &broadcasts[0];\n        assert_eq!(topic, &issuer_topic);\n        assert_eq!(event.kind, KIND_JOIN_REQUEST);\n\n        let tags = event.tags.clone();\n        assert_eq!(tag_value(&tags, \"e\"), Some(invite_event.id.to_string()));\n        assert_eq!(tag_value(&tags, \"p\"), Some(invite_event.pubkey.to_string()));\n    }\n\n    #[tokio::test]\n    async fn validate_invite_event_rejects_nonce_mismatch() {\n        let (keys, keypair) = make_keypair();\n        let topic_id = \"kukuri:topic1\";\n\n        let content = json!({\n            \"schema\": \"kukuri-invite-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"invite\",\n            \"expires\": Utc::now().timestamp() + 600,\n            \"max_uses\": 1,\n            \"nonce\": \"nonce-1\",\n            \"issuer\": format!(\"pubkey:{}\", keypair.public_key),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"invite\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"invite:nonce-2\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_INVITE_CAPABILITY as u16), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"signed\");\n\n        let value = serde_json::to_value(nostr_event).expect(\"value\");\n        let err = match validate_invite_event(&value, Some(topic_id)) {\n            Ok(_) => panic!(\"should fail\"),\n            Err(err) => err,\n        };\n        assert_eq!(err.validation_message(), Some(\"Invite nonce mismatch\"));\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_stores_pending_request() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let topic_id = \"kukuri:topic1\";\n        group_key_store\n            .store_key(GroupKeyRecord {\n                topic_id: topic_id.to_string(),\n                scope: \"friend\".to_string(),\n                epoch: 1,\n                key_b64: \"aGVsbG8=\".to_string(),\n                stored_at: Utc::now().timestamp(),\n            })\n            .await\n            .expect(\"store\");\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": Utc::now().timestamp(),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        service.handle_incoming_event(&event).await.expect(\"handle\");\n\n        let broadcasts = gossip_service.broadcasts().await;\n        assert!(\n            broadcasts\n                .iter()\n                .all(|(_, event)| event.kind != KIND_KEY_ENVELOPE)\n        );\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert_eq!(pending.len(), 1);\n        assert_eq!(pending[0].requester_pubkey, requester_keypair.public_key);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_detects_two_hop_mutual_follow() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let friend_pubkey = \"friend_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        user_repository\n            .seed_follow(owner_pubkey, friend_pubkey)\n            .await;\n        user_repository\n            .seed_follow(friend_pubkey, owner_pubkey)\n            .await;\n        user_repository\n            .seed_follow(friend_pubkey, requester_pubkey)\n            .await;\n        user_repository\n            .seed_follow(requester_pubkey, friend_pubkey)\n            .await;\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(is_fof);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_rejects_direct_mutual_follow_only() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        user_repository\n            .seed_follow(owner_pubkey, requester_pubkey)\n            .await;\n        user_repository\n            .seed_follow(requester_pubkey, owner_pubkey)\n            .await;\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(!is_fof);\n    }\n\n    #[tokio::test]\n    async fn friend_plus_rejects_when_no_mutual_friend_exists() {\n        let (_keys, keypair) = make_keypair();\n        let key_manager = Arc::new(TestKeyManager::new(keypair));\n        let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(TestGroupKeyStore::default());\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(TestJoinRequestStore::default());\n        let user_repository = Arc::new(TestUserRepository::default());\n        let user_repository_trait: Arc<dyn UserRepository> = user_repository.clone();\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service: Arc<dyn GossipService> = Arc::new(TestGossipService::default());\n\n        let owner_pubkey = \"owner_pubkey\";\n        let requester_pubkey = \"requester_pubkey\";\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store,\n            join_request_store,\n            user_repository_trait,\n            signature_service,\n            gossip_service,\n        );\n\n        let is_fof = service\n            .is_friend_of_friend(owner_pubkey, requester_pubkey)\n            .await\n            .expect(\"fof check\");\n        assert!(!is_fof);\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_rejects_invite_reuse() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n        let (requester_keys_2, requester_keypair_2) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let topic_id = \"kukuri:topic1\";\n        let invite_json = service\n            .issue_invite(topic_id, Some(600), Some(1), Some(\"nonce-reuse\".into()))\n            .await\n            .expect(\"invite\");\n        let invite_event: nostr_sdk::Event =\n            serde_json::from_value(invite_json.clone()).expect(\"nostr event\");\n        let invite_id = invite_event.id.to_string();\n        let issuer_pubkey = invite_event.pubkey.to_string();\n\n        let build_join_request = |keys: &Keys, requester_pubkey: &str, nonce: &str| {\n            let content = json!({\n                \"schema\": \"kukuri-join-request-v1\",\n                \"topic\": topic_id,\n                \"scope\": \"invite\",\n                \"requester\": format!(\"pubkey:{requester_pubkey}\"),\n                \"requested_at\": Utc::now().timestamp(),\n                \"invite_event_json\": invite_json.clone(),\n            })\n            .to_string();\n\n            let d_tag = format!(\"join:{topic_id}:{nonce}:{requester_pubkey}\");\n            let tags = vec![\n                Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n                Tag::parse([\"scope\", \"invite\"]).expect(\"tag\"),\n                Tag::parse([\"d\", d_tag.as_str()]).expect(\"tag\"),\n                Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n                Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n                Tag::parse([\"e\", invite_id.as_str()]).expect(\"tag\"),\n                Tag::parse([\"p\", issuer_pubkey.as_str()]).expect(\"tag\"),\n            ];\n\n            EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n                .tags(tags)\n                .sign_with_keys(keys)\n                .expect(\"signed\")\n        };\n\n        let event_first = domain_event_from_nostr(&build_join_request(\n            &requester_keys,\n            &requester_keypair.public_key,\n            \"nonce-1\",\n        ));\n        service\n            .handle_incoming_event(&event_first)\n            .await\n            .expect(\"first join\");\n\n        let event_second = domain_event_from_nostr(&build_join_request(\n            &requester_keys_2,\n            &requester_keypair_2.public_key,\n            \"nonce-2\",\n        ));\n        let err = service\n            .handle_incoming_event(&event_second)\n            .await\n            .expect_err(\"should reject reuse\");\n        assert_eq!(err.validation_message(), Some(\"Invite max_uses exceeded\"));\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert_eq!(pending.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn approve_join_request_sends_key_envelope_and_clears_pending() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let topic_id = \"kukuri:topic1\";\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": topic_id,\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": Utc::now().timestamp(),\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", topic_id]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        service.handle_incoming_event(&event).await.expect(\"handle\");\n\n        let approval = service\n            .approve_join_request(&event.id)\n            .await\n            .expect(\"approve\");\n        assert_eq!(approval.event_id, event.id);\n\n        let broadcasts = gossip_service.broadcasts().await;\n        let expected_topic = user_topic_id(&requester_keypair.public_key);\n        assert!(\n            broadcasts\n                .iter()\n                .any(|(topic, event)| *topic == expected_topic && event.kind == KIND_KEY_ENVELOPE)\n        );\n\n        let pending = join_request_store\n            .list_requests(&member_keypair.public_key)\n            .await\n            .expect(\"list\");\n        assert!(pending.is_empty());\n    }\n\n    #[tokio::test]\n    async fn handle_join_request_rejects_negative_requested_at() {\n        let (_member_keys, member_keypair) = make_keypair();\n        let (requester_keys, requester_keypair) = make_keypair();\n\n        let key_manager = Arc::new(TestKeyManager::new(member_keypair.clone()));\n        let group_key_store = Arc::new(TestGroupKeyStore::default());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n        let join_request_store = Arc::new(TestJoinRequestStore::default());\n        let join_request_store_trait: Arc<dyn JoinRequestStore> = join_request_store.clone();\n        let user_repository = Arc::new(TestUserRepository::default());\n        let signature_service = Arc::new(DefaultSignatureService::new());\n        let gossip_service = Arc::new(TestGossipService::default());\n        let gossip_service_trait: Arc<dyn GossipService> = gossip_service.clone();\n\n        let service = AccessControlService::new(\n            key_manager,\n            group_key_store_trait,\n            join_request_store_trait,\n            Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n            signature_service,\n            gossip_service_trait,\n        );\n\n        let content = json!({\n            \"schema\": \"kukuri-join-request-v1\",\n            \"topic\": \"kukuri:topic1\",\n            \"scope\": \"friend\",\n            \"requester\": format!(\"pubkey:{}\", requester_keypair.public_key),\n            \"requested_at\": -1,\n        })\n        .to_string();\n\n        let tags = vec![\n            Tag::parse([\"t\", \"kukuri:topic1\"]).expect(\"tag\"),\n            Tag::parse([\"scope\", \"friend\"]).expect(\"tag\"),\n            Tag::parse([\"d\", \"join:kukuri:topic1:nonce:requester\"]).expect(\"tag\"),\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"tag\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"tag\"),\n        ];\n\n        let nostr_event = EventBuilder::new(Kind::from(KIND_JOIN_REQUEST as u16), content)\n            .tags(tags)\n            .sign_with_keys(&requester_keys)\n            .expect(\"signed\");\n\n        let event = domain_event_from_nostr(&nostr_event);\n        let err = service\n            .handle_incoming_event(&event)\n            .await\n            .expect_err(\"should fail\");\n        assert_eq!(\n            err.validation_message(),\n            Some(\"Join.request requested_at is invalid\")\n        );\n    }\n}\n","traces":[{"line":69,"address":[22149792,22150257,22150346],"length":1,"stats":{"Line":2}},{"line":84,"address":[16287704],"length":1,"stats":{"Line":2}},{"line":91,"address":[22115248],"length":1,"stats":{"Line":1}},{"line":98,"address":[22152500,22152691],"length":1,"stats":{"Line":2}},{"line":99,"address":[22152931,22152757],"length":1,"stats":{"Line":0}},{"line":100,"address":[22048221],"length":1,"stats":{"Line":0}},{"line":105,"address":[11695939],"length":1,"stats":{"Line":2}},{"line":106,"address":[22110022,22109864],"length":1,"stats":{"Line":2}},{"line":107,"address":[22248545],"length":1,"stats":{"Line":1}},{"line":108,"address":[22049329],"length":1,"stats":{"Line":1}},{"line":109,"address":[22148329],"length":1,"stats":{"Line":1}},{"line":110,"address":[22110333,22119136,22119149],"length":1,"stats":{"Line":1}},{"line":112,"address":[22247377,22249118,22249010,22248907,22256276],"length":1,"stats":{"Line":2}},{"line":114,"address":[22151307,22149405,22151163,22155711,22149454],"length":1,"stats":{"Line":3}},{"line":121,"address":[22052263,22052185],"length":1,"stats":{"Line":2}},{"line":125,"address":[22117097,22116091,22114647,22113725,22114119,22115650,22116973,22117517,22117589,22113669,22116466,22114188,22115137,22117450,22115206,22115584,22117302,22116025,22114578],"length":1,"stats":{"Line":1}},{"line":126,"address":[22252190,22252257,22256064],"length":1,"stats":{"Line":2}},{"line":127,"address":[22252653,22252717,22255973],"length":1,"stats":{"Line":2}},{"line":128,"address":[22152744,22155557,22152808],"length":1,"stats":{"Line":2}},{"line":129,"address":[22042686,22040663,22040599],"length":1,"stats":{"Line":2}},{"line":130,"address":[22157686,22157744,22159121],"length":1,"stats":{"Line":2}},{"line":131,"address":[22116968,22116079,22116137],"length":1,"stats":{"Line":2}},{"line":134,"address":[22156155,22156367,22157053,22154895,22154946,22155013,22156085],"length":1,"stats":{"Line":5}},{"line":135,"address":[16296507],"length":1,"stats":{"Line":1}},{"line":136,"address":[11699924],"length":1,"stats":{"Line":3}},{"line":137,"address":[22156456,22156665,22156297],"length":1,"stats":{"Line":2}},{"line":138,"address":[22160554,22160727],"length":1,"stats":{"Line":3}},{"line":139,"address":[22044608,22044626],"length":1,"stats":{"Line":0}},{"line":142,"address":[22126288],"length":1,"stats":{"Line":1}},{"line":146,"address":[11696511],"length":1,"stats":{"Line":2}},{"line":147,"address":[22164362],"length":1,"stats":{"Line":1}},{"line":148,"address":[22259388,22259321],"length":1,"stats":{"Line":2}},{"line":149,"address":[22127904],"length":1,"stats":{"Line":1}},{"line":151,"address":[22259692],"length":1,"stats":{"Line":1}},{"line":153,"address":[22163442,22163645,22163927],"length":1,"stats":{"Line":3}},{"line":154,"address":[22128578,22128645,22139536,22128860],"length":1,"stats":{"Line":2}},{"line":155,"address":[16312450],"length":1,"stats":{"Line":0}},{"line":156,"address":[22271105],"length":1,"stats":{"Line":0}},{"line":157,"address":[22174678],"length":1,"stats":{"Line":0}},{"line":162,"address":[16308944,16308719,16302207,16308867,16304297,16303379,16302666,16308915,16301781,16308514,16303907,16302276,16303448,16301814,16302735,16303838,16301395],"length":1,"stats":{"Line":2}},{"line":163,"address":[22122154,22122087,22129227],"length":1,"stats":{"Line":2}},{"line":164,"address":[22122549,22122613,22129198],"length":1,"stats":{"Line":2}},{"line":165,"address":[16302886,16303196,16308862,16302784,16302823,16302720],"length":1,"stats":{"Line":3}},{"line":166,"address":[22062248],"length":1,"stats":{"Line":1}},{"line":167,"address":[15094007,15093947],"length":1,"stats":{"Line":2}},{"line":169,"address":[22130713,22130649,22135911],"length":1,"stats":{"Line":2}},{"line":170,"address":[22167940,22172474,22167876],"length":1,"stats":{"Line":2}},{"line":173,"address":[22057101,22057191],"length":1,"stats":{"Line":2}},{"line":174,"address":[22050460,22058176,22050536,22058185],"length":1,"stats":{"Line":4}},{"line":175,"address":[22125713,22125268],"length":1,"stats":{"Line":1}},{"line":178,"address":[16304795,16305438],"length":1,"stats":{"Line":2}},{"line":179,"address":[22057979,22058052],"length":1,"stats":{"Line":2}},{"line":182,"address":[16307028,16306884,16305950,16308347,16305554],"length":1,"stats":{"Line":3}},{"line":186,"address":[15097980,15097902],"length":1,"stats":{"Line":2}},{"line":189,"address":[22170406,22169972],"length":1,"stats":{"Line":2}},{"line":190,"address":[15099115,15098769,15098901],"length":1,"stats":{"Line":1}},{"line":193,"address":[22136455,22136671,22135496,22135429,22137727,22135031,22136375],"length":1,"stats":{"Line":5}},{"line":194,"address":[22172144,22171816],"length":1,"stats":{"Line":2}},{"line":195,"address":[22167413,22167807,22166713,22157980,22166653,22167561],"length":1,"stats":{"Line":3}},{"line":197,"address":[22068834],"length":1,"stats":{"Line":1}},{"line":198,"address":[22268326],"length":1,"stats":{"Line":1}},{"line":199,"address":[16309668,16309789],"length":1,"stats":{"Line":2}},{"line":201,"address":[15100688],"length":1,"stats":{"Line":1}},{"line":202,"address":[22268700],"length":1,"stats":{"Line":0}},{"line":205,"address":[22268778,22268670],"length":1,"stats":{"Line":2}},{"line":206,"address":[22269205,22268887],"length":1,"stats":{"Line":0}},{"line":207,"address":[22174095],"length":1,"stats":{"Line":0}},{"line":212,"address":[22062641,22062496],"length":1,"stats":{"Line":2}},{"line":213,"address":[11700496],"length":1,"stats":{"Line":2}},{"line":215,"address":[16310984],"length":1,"stats":{"Line":1}},{"line":216,"address":[16310827],"length":1,"stats":{"Line":1}},{"line":217,"address":[22131234],"length":1,"stats":{"Line":1}},{"line":221,"address":[22134111,22133017,22132808,22132816,22132854,22133175,22132959,22132800],"length":1,"stats":{"Line":0}},{"line":222,"address":[22139856,22140684,22140989,22140135,22139914,22139992],"length":1,"stats":{"Line":0}},{"line":223,"address":[15104296,15104578,15104523,15104774],"length":1,"stats":{"Line":0}},{"line":224,"address":[22073077],"length":1,"stats":{"Line":0}},{"line":225,"address":[22272513,22272600,22272801,22272466,22271484],"length":1,"stats":{"Line":0}},{"line":228,"address":[22134416],"length":1,"stats":{"Line":1}},{"line":232,"address":[11741202],"length":1,"stats":{"Line":2}},{"line":233,"address":[22068077,22067884],"length":1,"stats":{"Line":2}},{"line":234,"address":[22179662,22180005],"length":1,"stats":{"Line":0}},{"line":235,"address":[22075126],"length":1,"stats":{"Line":0}},{"line":240,"address":[22274392,22275328,22275144,22275872,22274730,22275064,22274647],"length":1,"stats":{"Line":5}},{"line":242,"address":[22075250],"length":1,"stats":{"Line":1}},{"line":243,"address":[22174384,22174912,22174319,22174698,22172939,22174556],"length":1,"stats":{"Line":3}},{"line":245,"address":[22137252],"length":1,"stats":{"Line":0}},{"line":248,"address":[22063042,22063948,22062529,22063226,22062575,22062962,22062342],"length":1,"stats":{"Line":5}},{"line":249,"address":[22175069],"length":1,"stats":{"Line":1}},{"line":250,"address":[11638372],"length":1,"stats":{"Line":3}},{"line":252,"address":[22276890],"length":1,"stats":{"Line":0}},{"line":253,"address":[22182027],"length":1,"stats":{"Line":0}},{"line":257,"address":[16319215,16317882,16317649,16317928,16318422,16318596,16318960],"length":1,"stats":{"Line":5}},{"line":258,"address":[22145020,22144888],"length":1,"stats":{"Line":2}},{"line":259,"address":[16318301,16318912,16318518,16314581,16317961,16317901],"length":1,"stats":{"Line":3}},{"line":260,"address":[22066055,22065423,22065171,22064844,22064798,22065091,22064552],"length":1,"stats":{"Line":5}},{"line":261,"address":[22181215,22181423],"length":1,"stats":{"Line":2}},{"line":262,"address":[22278447,22273370,22278165,22277889,22278014,22277949],"length":1,"stats":{"Line":3}},{"line":263,"address":[22140108,22139949,22140642],"length":1,"stats":{"Line":2}},{"line":264,"address":[16320111,16320244,16320405,16320731,16321014,16314623],"length":1,"stats":{"Line":2}},{"line":266,"address":[22147907,22148119,22148494,22149174,22148368,22150383,22148178],"length":1,"stats":{"Line":5}},{"line":267,"address":[22073316],"length":1,"stats":{"Line":1}},{"line":268,"address":[22179445,22179331,22179384,22173044,22180310,22179600],"length":1,"stats":{"Line":3}},{"line":270,"address":[22185580],"length":1,"stats":{"Line":1}},{"line":271,"address":[22148550],"length":1,"stats":{"Line":1}},{"line":272,"address":[15111937],"length":1,"stats":{"Line":1}},{"line":273,"address":[22280205],"length":1,"stats":{"Line":1}},{"line":274,"address":[22080946],"length":1,"stats":{"Line":1}},{"line":275,"address":[22074023],"length":1,"stats":{"Line":1}},{"line":279,"address":[22187700,22186146,22186565,22186407,22186176,22186220,22186349,22186128],"length":1,"stats":{"Line":0}},{"line":280,"address":[11037553],"length":1,"stats":{"Line":0}},{"line":281,"address":[22183182,22183361],"length":1,"stats":{"Line":0}},{"line":282,"address":[22070955,22070723],"length":1,"stats":{"Line":0}},{"line":283,"address":[22145307],"length":1,"stats":{"Line":0}},{"line":287,"address":[15115651,15115954,15115706,15115487,15116076,15116186],"length":1,"stats":{"Line":0}},{"line":288,"address":[22183489],"length":1,"stats":{"Line":0}},{"line":289,"address":[11833349],"length":1,"stats":{"Line":0}},{"line":290,"address":[22152855],"length":1,"stats":{"Line":0}},{"line":293,"address":[22184352,22184682,22184173,22184160,22184227,22184481,22185085,22184192],"length":1,"stats":{"Line":4}},{"line":294,"address":[22284688],"length":1,"stats":{"Line":1}},{"line":295,"address":[22184714,22184379,22184525,22184433],"length":1,"stats":{"Line":2}},{"line":296,"address":[19404949],"length":1,"stats":{"Line":0}},{"line":299,"address":[15116474],"length":1,"stats":{"Line":2}},{"line":302,"address":[16327088,16327738,16328775,16327533,16327040,16327385,16327053,16327150],"length":1,"stats":{"Line":5}},{"line":303,"address":[16327599,16327770,16327415,16327343],"length":1,"stats":{"Line":3}},{"line":304,"address":[22148478],"length":1,"stats":{"Line":1}},{"line":305,"address":[22073975],"length":1,"stats":{"Line":0}},{"line":307,"address":[15119350,15119514,15120174,15118707,15118959,15118989,15119268],"length":1,"stats":{"Line":12}},{"line":308,"address":[16328351],"length":1,"stats":{"Line":1}},{"line":309,"address":[22185836,22187002,22187326,22187530,22187184,22187062],"length":1,"stats":{"Line":8}},{"line":311,"address":[22075528],"length":1,"stats":{"Line":0}},{"line":314,"address":[15121303,15120746,15119939,15120385,15120467,15119656,15120666,15120018],"length":1,"stats":{"Line":12}},{"line":316,"address":[22149757],"length":1,"stats":{"Line":1}},{"line":317,"address":[11831108],"length":1,"stats":{"Line":6}},{"line":320,"address":[22151296],"length":1,"stats":{"Line":0}},{"line":323,"address":[16330512],"length":1,"stats":{"Line":2}},{"line":327,"address":[22090863,22091502,22090209,22090397,22090338,22090611,22090727],"length":1,"stats":{"Line":10}},{"line":329,"address":[22151065],"length":1,"stats":{"Line":2}},{"line":332,"address":[16331203,16330914,16331359,16327478,16330974,16331044],"length":1,"stats":{"Line":6}},{"line":334,"address":[22152615,22151611,22151739],"length":1,"stats":{"Line":5}},{"line":335,"address":[16331487,16332015,16334896,16331752],"length":1,"stats":{"Line":1}},{"line":336,"address":[15125052],"length":1,"stats":{"Line":0}},{"line":338,"address":[22194133,22194000],"length":1,"stats":{"Line":2}},{"line":339,"address":[22091615,22091404,22092948,22091261,22091731,22091836],"length":1,"stats":{"Line":6}},{"line":340,"address":[11618086],"length":1,"stats":{"Line":4}},{"line":344,"address":[22193793],"length":1,"stats":{"Line":2}},{"line":345,"address":[22196443],"length":1,"stats":{"Line":2}},{"line":346,"address":[22291280],"length":1,"stats":{"Line":2}},{"line":347,"address":[15122762],"length":1,"stats":{"Line":2}},{"line":348,"address":[22291386],"length":1,"stats":{"Line":2}},{"line":349,"address":[16332671],"length":1,"stats":{"Line":2}},{"line":350,"address":[22196690,22196753],"length":1,"stats":{"Line":4}},{"line":351,"address":[22153081],"length":1,"stats":{"Line":2}},{"line":354,"address":[22191757,22191493,22192005,22192121,22191698,22192270],"length":1,"stats":{"Line":10}},{"line":355,"address":[15123391],"length":1,"stats":{"Line":2}},{"line":356,"address":[22079193,22079518,22079022,22079349,22079075,22073216],"length":1,"stats":{"Line":6}},{"line":357,"address":[22160989],"length":1,"stats":{"Line":2}},{"line":360,"address":[15125104],"length":1,"stats":{"Line":3}},{"line":365,"address":[22162627,22162494],"length":1,"stats":{"Line":6}},{"line":366,"address":[22294219],"length":1,"stats":{"Line":0}},{"line":368,"address":[15125561,15125634],"length":1,"stats":{"Line":6}},{"line":369,"address":[22088063,22088136],"length":1,"stats":{"Line":6}},{"line":370,"address":[22156251],"length":1,"stats":{"Line":0}},{"line":374,"address":[22081593],"length":1,"stats":{"Line":3}},{"line":375,"address":[22094431,22088988,22088770,22088646],"length":1,"stats":{"Line":6}},{"line":376,"address":[15126756,15126555,15126958,15131820],"length":1,"stats":{"Line":6}},{"line":377,"address":[22205887,22200829,22201023],"length":1,"stats":{"Line":6}},{"line":378,"address":[22083154,22087594,22082987],"length":1,"stats":{"Line":3}},{"line":379,"address":[22296188,22296327],"length":1,"stats":{"Line":6}},{"line":380,"address":[22201565,22201698],"length":1,"stats":{"Line":6}},{"line":381,"address":[22090216],"length":1,"stats":{"Line":0}},{"line":383,"address":[22158205],"length":1,"stats":{"Line":0}},{"line":384,"address":[22164991],"length":1,"stats":{"Line":0}},{"line":385,"address":[22201767],"length":1,"stats":{"Line":0}},{"line":389,"address":[22083777,22083358],"length":1,"stats":{"Line":6}},{"line":390,"address":[15128249,15128159],"length":1,"stats":{"Line":6}},{"line":391,"address":[22097817,22097734],"length":1,"stats":{"Line":2}},{"line":392,"address":[22084063],"length":1,"stats":{"Line":0}},{"line":396,"address":[22197129,22200293,22196712,22196850],"length":1,"stats":{"Line":6}},{"line":397,"address":[15133330,15133312,15128686],"length":1,"stats":{"Line":0}},{"line":398,"address":[22158933,22159109],"length":1,"stats":{"Line":6}},{"line":399,"address":[22159154,22162134],"length":1,"stats":{"Line":0}},{"line":400,"address":[22201194],"length":1,"stats":{"Line":0}},{"line":404,"address":[15128909,15128824],"length":1,"stats":{"Line":6}},{"line":405,"address":[22098425,22098522],"length":1,"stats":{"Line":6}},{"line":406,"address":[22091560],"length":1,"stats":{"Line":0}},{"line":407,"address":[22297840],"length":1,"stats":{"Line":0}},{"line":412,"address":[22091675,22091505],"length":1,"stats":{"Line":6}},{"line":413,"address":[15129230,15129324],"length":1,"stats":{"Line":5}},{"line":414,"address":[15129338],"length":1,"stats":{"Line":0}},{"line":415,"address":[16339348],"length":1,"stats":{"Line":0}},{"line":420,"address":[22159738,22159592],"length":1,"stats":{"Line":3}},{"line":421,"address":[22201896,22201839],"length":1,"stats":{"Line":3}},{"line":422,"address":[22166896],"length":1,"stats":{"Line":1}},{"line":423,"address":[22092219],"length":1,"stats":{"Line":0}},{"line":424,"address":[22085427],"length":1,"stats":{"Line":0}},{"line":430,"address":[22085521,22085219],"length":1,"stats":{"Line":3}},{"line":431,"address":[22085541],"length":1,"stats":{"Line":2}},{"line":432,"address":[16339939],"length":1,"stats":{"Line":1}},{"line":433,"address":[22167147],"length":1,"stats":{"Line":1}},{"line":439,"address":[22085547],"length":1,"stats":{"Line":2}},{"line":440,"address":[22202212],"length":1,"stats":{"Line":2}},{"line":441,"address":[22202231,22202416],"length":1,"stats":{"Line":4}},{"line":442,"address":[22204180,22202715,22202458,22205920],"length":1,"stats":{"Line":1}},{"line":443,"address":[22163884],"length":1,"stats":{"Line":0}},{"line":445,"address":[16340296,16340470,16341810,16340785],"length":1,"stats":{"Line":2}},{"line":446,"address":[22093394,22093243],"length":1,"stats":{"Line":2}},{"line":447,"address":[22168306],"length":1,"stats":{"Line":1}},{"line":448,"address":[22203492],"length":1,"stats":{"Line":1}},{"line":449,"address":[22300059,22300013],"length":1,"stats":{"Line":2}},{"line":450,"address":[22100753],"length":1,"stats":{"Line":0}},{"line":454,"address":[22198486,22199806],"length":1,"stats":{"Line":4}},{"line":455,"address":[22300905,22300465,22301025,22301154,22302072,22300511],"length":1,"stats":{"Line":0}},{"line":456,"address":[22087312],"length":1,"stats":{"Line":0}},{"line":457,"address":[22162626,22162473,22162004,22162317,22155629,22162064],"length":1,"stats":{"Line":0}},{"line":458,"address":[22301096],"length":1,"stats":{"Line":0}},{"line":459,"address":[22088127],"length":1,"stats":{"Line":0}},{"line":460,"address":[22169639],"length":1,"stats":{"Line":0}},{"line":466,"address":[16342667],"length":1,"stats":{"Line":1}},{"line":467,"address":[22199816],"length":1,"stats":{"Line":2}},{"line":468,"address":[22203805],"length":1,"stats":{"Line":2}},{"line":469,"address":[22094002],"length":1,"stats":{"Line":2}},{"line":470,"address":[15131499],"length":1,"stats":{"Line":2}},{"line":471,"address":[22088257],"length":1,"stats":{"Line":2}},{"line":472,"address":[22204935],"length":1,"stats":{"Line":2}},{"line":473,"address":[16342637],"length":1,"stats":{"Line":2}},{"line":474,"address":[22169875],"length":1,"stats":{"Line":2}},{"line":478,"address":[22096386,22096141,22096128,22096207,22096160,22097908,22096643,22096450],"length":1,"stats":{"Line":0}},{"line":479,"address":[11732033],"length":1,"stats":{"Line":0}},{"line":480,"address":[22206942],"length":1,"stats":{"Line":0}},{"line":481,"address":[22171918],"length":1,"stats":{"Line":0}},{"line":483,"address":[22303522,22303623],"length":1,"stats":{"Line":0}},{"line":484,"address":[22104400,22104473],"length":1,"stats":{"Line":0}},{"line":485,"address":[22165606],"length":1,"stats":{"Line":0}},{"line":489,"address":[22104714],"length":1,"stats":{"Line":0}},{"line":490,"address":[16345672,16345459,16345562,16350447],"length":1,"stats":{"Line":0}},{"line":491,"address":[22091469,22091329,22096115,22091660],"length":1,"stats":{"Line":0}},{"line":492,"address":[22209905,22210088],"length":1,"stats":{"Line":0}},{"line":493,"address":[22098629],"length":1,"stats":{"Line":0}},{"line":495,"address":[16346368,16346110,16350394,16346178],"length":1,"stats":{"Line":0}},{"line":496,"address":[22305094,22305285,22305478,22309137],"length":1,"stats":{"Line":0}},{"line":497,"address":[22106831,22106315,22106124,22109823,22106642],"length":1,"stats":{"Line":0}},{"line":499,"address":[22178880],"length":1,"stats":{"Line":0}},{"line":500,"address":[22104163],"length":1,"stats":{"Line":0}},{"line":502,"address":[22093116],"length":1,"stats":{"Line":0}},{"line":503,"address":[22211456,22214304],"length":1,"stats":{"Line":0}},{"line":504,"address":[22167752],"length":1,"stats":{"Line":0}},{"line":509,"address":[22106882,22106994,22109751,22107240],"length":1,"stats":{"Line":0}},{"line":510,"address":[22310496,22306504,22310512],"length":1,"stats":{"Line":0}},{"line":511,"address":[22095989,22093584,22093390,22093869],"length":1,"stats":{"Line":0}},{"line":512,"address":[16348125,16351888,16351904],"length":1,"stats":{"Line":0}},{"line":513,"address":[22095961,22094175,22093756,22093916],"length":1,"stats":{"Line":0}},{"line":514,"address":[22175647,22179264,22179286],"length":1,"stats":{"Line":0}},{"line":515,"address":[22108553,22107852,22108069,22109657],"length":1,"stats":{"Line":0}},{"line":516,"address":[15138714,15141922,15141904],"length":1,"stats":{"Line":0}},{"line":518,"address":[22101669,22101712,22101493],"length":1,"stats":{"Line":0}},{"line":519,"address":[22108739,22109629],"length":1,"stats":{"Line":0}},{"line":520,"address":[22176491],"length":1,"stats":{"Line":0}},{"line":524,"address":[22108882,22108651,22108785],"length":1,"stats":{"Line":0}},{"line":525,"address":[22169668,22170406],"length":1,"stats":{"Line":0}},{"line":526,"address":[22095068],"length":1,"stats":{"Line":0}},{"line":531,"address":[22104944,22104948,22101937],"length":1,"stats":{"Line":0}},{"line":533,"address":[22211851],"length":1,"stats":{"Line":0}},{"line":534,"address":[22176781],"length":1,"stats":{"Line":0}},{"line":535,"address":[22095311],"length":1,"stats":{"Line":0}},{"line":536,"address":[15139279],"length":1,"stats":{"Line":0}},{"line":539,"address":[11700869],"length":1,"stats":{"Line":0}},{"line":540,"address":[22110251],"length":1,"stats":{"Line":0}},{"line":543,"address":[22311264],"length":1,"stats":{"Line":1}},{"line":548,"address":[11609201],"length":1,"stats":{"Line":2}},{"line":549,"address":[22212032],"length":1,"stats":{"Line":0}},{"line":552,"address":[22106213],"length":1,"stats":{"Line":1}},{"line":553,"address":[22113448,22114248,22113242],"length":1,"stats":{"Line":1}},{"line":554,"address":[22099454],"length":1,"stats":{"Line":1}},{"line":555,"address":[22182549,22182528,22181160],"length":1,"stats":{"Line":0}},{"line":556,"address":[22312640,22312836],"length":1,"stats":{"Line":2}},{"line":558,"address":[22099776],"length":1,"stats":{"Line":1}},{"line":559,"address":[22099852],"length":1,"stats":{"Line":1}},{"line":562,"address":[22181492,22181555],"length":1,"stats":{"Line":2}},{"line":564,"address":[11715141],"length":1,"stats":{"Line":2}},{"line":565,"address":[22217421],"length":1,"stats":{"Line":1}},{"line":568,"address":[15145008],"length":1,"stats":{"Line":1}},{"line":573,"address":[19416623],"length":1,"stats":{"Line":2}},{"line":574,"address":[22109318,22109117,22109559,22117683],"length":1,"stats":{"Line":2}},{"line":575,"address":[22125136,22116487,22125152],"length":1,"stats":{"Line":0}},{"line":576,"address":[22109859,22109647,22117652,22109474],"length":1,"stats":{"Line":2}},{"line":577,"address":[22193072,22184547,22193056],"length":1,"stats":{"Line":0}},{"line":579,"address":[22118724,22124407,22118808,22117680,22116780,22118341,22117281,22116872],"length":1,"stats":{"Line":3}},{"line":581,"address":[22220130],"length":1,"stats":{"Line":1}},{"line":582,"address":[22110669],"length":1,"stats":{"Line":1}},{"line":584,"address":[22179138],"length":1,"stats":{"Line":1}},{"line":585,"address":[22318017,22318077],"length":1,"stats":{"Line":2}},{"line":588,"address":[22223548],"length":1,"stats":{"Line":1}},{"line":589,"address":[22179877],"length":1,"stats":{"Line":1}},{"line":590,"address":[22318374],"length":1,"stats":{"Line":1}},{"line":591,"address":[22218111],"length":1,"stats":{"Line":1}},{"line":593,"address":[22228336,22228358,22222284],"length":1,"stats":{"Line":0}},{"line":595,"address":[22218522,22218620],"length":1,"stats":{"Line":2}},{"line":597,"address":[15149322,15149514],"length":1,"stats":{"Line":2}},{"line":598,"address":[22222485],"length":1,"stats":{"Line":1}},{"line":602,"address":[16361042,16364845,16361495,16363261,16361429,16361937,16364797,16360479,16364158,16362313,16361871,16364301,16362820,16362754,16360973,16360580,16362379,16363195,16364544,16363621,16364730,16360547,16364874],"length":1,"stats":{"Line":2}},{"line":603,"address":[15150036,15149973,15154221],"length":1,"stats":{"Line":2}},{"line":604,"address":[22106723,22106787,22110536],"length":1,"stats":{"Line":2}},{"line":605,"address":[22185080,22181771,22181829],"length":1,"stats":{"Line":2}},{"line":606,"address":[22117205,22114405,22114463],"length":1,"stats":{"Line":2}},{"line":607,"address":[22222920,22220825,22220767],"length":1,"stats":{"Line":2}},{"line":608,"address":[22321576,22321634,22323045],"length":1,"stats":{"Line":2}},{"line":609,"address":[22109849,22108945,22109003],"length":1,"stats":{"Line":2}},{"line":612,"address":[22324187,22322851,22322736],"length":1,"stats":{"Line":3}},{"line":613,"address":[11754370],"length":1,"stats":{"Line":3}},{"line":616,"address":[22125712],"length":1,"stats":{"Line":1}},{"line":622,"address":[22120043,22119395,22119152,22119234,22119091,22120702],"length":1,"stats":{"Line":2}},{"line":623,"address":[22127637,22126914,22127104],"length":1,"stats":{"Line":1}},{"line":624,"address":[22226290,22226469,22227091,22226744,22226528,22226874],"length":1,"stats":{"Line":5}},{"line":625,"address":[22127457],"length":1,"stats":{"Line":1}},{"line":626,"address":[15157646,15157373,15156017,15157518,15157422],"length":1,"stats":{"Line":3}},{"line":627,"address":[22114848,22114872,22114339],"length":1,"stats":{"Line":0}},{"line":628,"address":[22121025],"length":1,"stats":{"Line":1}},{"line":631,"address":[22227712,22227735,22227776,22228754,22230406,22227823,22228100,22228021],"length":1,"stats":{"Line":4}},{"line":632,"address":[22115291],"length":1,"stats":{"Line":1}},{"line":633,"address":[22115568,22115742,22115462],"length":1,"stats":{"Line":3}},{"line":634,"address":[22115855,22115758],"length":1,"stats":{"Line":2}},{"line":635,"address":[22115932],"length":1,"stats":{"Line":1}},{"line":636,"address":[22232619],"length":1,"stats":{"Line":1}},{"line":640,"address":[22198222,22197301,22198161,22197176],"length":1,"stats":{"Line":4}},{"line":641,"address":[15160882,15161130,15160384,15158883,15159610,15160230],"length":1,"stats":{"Line":3}},{"line":642,"address":[11714107],"length":1,"stats":{"Line":4}},{"line":644,"address":[22198304],"length":1,"stats":{"Line":1}},{"line":647,"address":[22124576],"length":1,"stats":{"Line":3}},{"line":651,"address":[11098559],"length":1,"stats":{"Line":6}},{"line":652,"address":[11771970],"length":1,"stats":{"Line":6}},{"line":653,"address":[22237640,22237837],"length":1,"stats":{"Line":3}},{"line":654,"address":[22119576],"length":1,"stats":{"Line":1}},{"line":655,"address":[22194336,22194471,22194228,22194525,22194947],"length":1,"stats":{"Line":13}},{"line":656,"address":[22238261,22238548],"length":1,"stats":{"Line":4}},{"line":657,"address":[15163646],"length":1,"stats":{"Line":2}},{"line":660,"address":[22133767],"length":1,"stats":{"Line":1}},{"line":663,"address":[22127312],"length":1,"stats":{"Line":3}},{"line":668,"address":[15164091,15164228],"length":1,"stats":{"Line":6}},{"line":669,"address":[16375214],"length":1,"stats":{"Line":0}},{"line":671,"address":[11633791],"length":1,"stats":{"Line":6}},{"line":672,"address":[15164735,15164886],"length":1,"stats":{"Line":2}},{"line":673,"address":[22121600],"length":1,"stats":{"Line":1}},{"line":675,"address":[22121645,22121831,22121581,22121564,22121932,22122158,22122446],"length":1,"stats":{"Line":10}},{"line":676,"address":[22128357],"length":1,"stats":{"Line":2}},{"line":677,"address":[22335182,22334812,22334951,22334690,22333879,22334747],"length":1,"stats":{"Line":6}},{"line":678,"address":[22203604,22203763],"length":1,"stats":{"Line":4}},{"line":679,"address":[22238925],"length":1,"stats":{"Line":0}},{"line":681,"address":[22136009,22136083],"length":1,"stats":{"Line":4}},{"line":687,"address":[22239104],"length":1,"stats":{"Line":1}},{"line":693,"address":[22239412,22239542],"length":1,"stats":{"Line":2}},{"line":694,"address":[22241264],"length":1,"stats":{"Line":1}},{"line":695,"address":[22239800,22240050,22240160,22240333,22241135,22239859,22239679],"length":1,"stats":{"Line":5}},{"line":697,"address":[16377441],"length":1,"stats":{"Line":1}},{"line":698,"address":[11706961],"length":1,"stats":{"Line":3}},{"line":700,"address":[22242053],"length":1,"stats":{"Line":1}},{"line":702,"address":[22205250],"length":1,"stats":{"Line":1}},{"line":709,"address":[22240583,22240662],"length":1,"stats":{"Line":2}},{"line":710,"address":[22124030],"length":1,"stats":{"Line":1}},{"line":711,"address":[22130855],"length":1,"stats":{"Line":1}},{"line":712,"address":[22240756,22241089],"length":1,"stats":{"Line":2}},{"line":713,"address":[22236812],"length":1,"stats":{"Line":1}},{"line":718,"address":[22242456,22242369,22242529],"length":1,"stats":{"Line":2}},{"line":719,"address":[22337248],"length":1,"stats":{"Line":1}},{"line":720,"address":[22337256],"length":1,"stats":{"Line":1}},{"line":721,"address":[22138708,22137964,22138098,22138165,22138388,22138498,22138620],"length":1,"stats":{"Line":5}},{"line":722,"address":[16378575],"length":1,"stats":{"Line":1}},{"line":723,"address":[16378980,16379116,16377146,16378827,16378678,16378725],"length":1,"stats":{"Line":3}},{"line":724,"address":[22199382],"length":1,"stats":{"Line":1}},{"line":727,"address":[16379312,16380570,16380711],"length":1,"stats":{"Line":1}},{"line":731,"address":[22125054],"length":1,"stats":{"Line":1}},{"line":732,"address":[22199729,22199930,22200167],"length":1,"stats":{"Line":2}},{"line":733,"address":[22125502],"length":1,"stats":{"Line":1}},{"line":734,"address":[15168740],"length":1,"stats":{"Line":1}},{"line":735,"address":[22338754],"length":1,"stats":{"Line":1}},{"line":736,"address":[22338820,22339347],"length":1,"stats":{"Line":1}},{"line":739,"address":[22241886,22244496,22243078,22243196],"length":1,"stats":{"Line":0}},{"line":740,"address":[22127868],"length":1,"stats":{"Line":0}},{"line":742,"address":[22127932,22126502,22126626,22127920],"length":1,"stats":{"Line":0}},{"line":743,"address":[16380964,16381035],"length":1,"stats":{"Line":0}},{"line":744,"address":[22246077,22245059],"length":1,"stats":{"Line":0}},{"line":745,"address":[22239467],"length":1,"stats":{"Line":0}},{"line":749,"address":[22243377,22243457,22243488],"length":1,"stats":{"Line":0}},{"line":750,"address":[22244339],"length":1,"stats":{"Line":0}},{"line":751,"address":[15170070],"length":1,"stats":{"Line":0}},{"line":752,"address":[22140652,22141359],"length":1,"stats":{"Line":0}},{"line":756,"address":[22243567,22243468],"length":1,"stats":{"Line":0}},{"line":759,"address":[22141728,22141758],"length":1,"stats":{"Line":0}},{"line":760,"address":[15171225,15171216],"length":1,"stats":{"Line":0}},{"line":761,"address":[22201636,22201565,22202039],"length":1,"stats":{"Line":0}},{"line":762,"address":[22134249],"length":1,"stats":{"Line":0}},{"line":763,"address":[15170635],"length":1,"stats":{"Line":0}},{"line":768,"address":[22201651],"length":1,"stats":{"Line":0}},{"line":771,"address":[22209600],"length":1,"stats":{"Line":1}},{"line":774,"address":[11679364],"length":1,"stats":{"Line":2}},{"line":817,"address":[16383056,16388898,16387471],"length":1,"stats":{"Line":1}},{"line":821,"address":[22341886,22342157],"length":1,"stats":{"Line":1}},{"line":822,"address":[22216128,22210567,22216146],"length":1,"stats":{"Line":0}},{"line":824,"address":[22245664,22245803],"length":1,"stats":{"Line":2}},{"line":825,"address":[22247500,22252837],"length":1,"stats":{"Line":0}},{"line":826,"address":[22129204],"length":1,"stats":{"Line":0}},{"line":830,"address":[22245910,22245821],"length":1,"stats":{"Line":2}},{"line":833,"address":[15177790,15177744],"length":1,"stats":{"Line":2}},{"line":835,"address":[15172477,15172568,15172662,15177485],"length":1,"stats":{"Line":2}},{"line":836,"address":[22252787,22247786,22247922,22248156],"length":1,"stats":{"Line":2}},{"line":837,"address":[22211465,22211346],"length":1,"stats":{"Line":2}},{"line":838,"address":[22242697,22242797],"length":1,"stats":{"Line":2}},{"line":839,"address":[22343179],"length":1,"stats":{"Line":0}},{"line":840,"address":[22248387],"length":1,"stats":{"Line":0}},{"line":845,"address":[15177427,15173509,15173332,15173120],"length":1,"stats":{"Line":2}},{"line":846,"address":[22343455,22343623],"length":1,"stats":{"Line":2}},{"line":847,"address":[22205192,22209009],"length":1,"stats":{"Line":0}},{"line":848,"address":[22343664],"length":1,"stats":{"Line":0}},{"line":852,"address":[22205250,22205440,22205149,22208999],"length":1,"stats":{"Line":3}},{"line":853,"address":[22247625,22247454],"length":1,"stats":{"Line":3}},{"line":854,"address":[22344178,22344108],"length":1,"stats":{"Line":0}},{"line":855,"address":[22243732],"length":1,"stats":{"Line":0}},{"line":859,"address":[15174146,15174234],"length":1,"stats":{"Line":2}},{"line":860,"address":[22148050],"length":1,"stats":{"Line":0}},{"line":861,"address":[22252570],"length":1,"stats":{"Line":0}},{"line":866,"address":[22344367,22347349,22344689],"length":1,"stats":{"Line":1}},{"line":867,"address":[22145329,22148624,22148642],"length":1,"stats":{"Line":0}},{"line":868,"address":[22344601,22344769],"length":1,"stats":{"Line":2}},{"line":869,"address":[22347301,22344810],"length":1,"stats":{"Line":0}},{"line":870,"address":[22138514],"length":1,"stats":{"Line":0}},{"line":874,"address":[22344775,22344860],"length":1,"stats":{"Line":2}},{"line":875,"address":[22248568,22248489],"length":1,"stats":{"Line":2}},{"line":876,"address":[22244646],"length":1,"stats":{"Line":0}},{"line":877,"address":[22213454],"length":1,"stats":{"Line":0}},{"line":882,"address":[16386195,16386366],"length":1,"stats":{"Line":2}},{"line":883,"address":[16386419,16386469],"length":1,"stats":{"Line":2}},{"line":884,"address":[22132179],"length":1,"stats":{"Line":0}},{"line":885,"address":[22138955],"length":1,"stats":{"Line":0}},{"line":890,"address":[22248914,22248785],"length":1,"stats":{"Line":2}},{"line":891,"address":[22345426,22345367],"length":1,"stats":{"Line":2}},{"line":892,"address":[16386705],"length":1,"stats":{"Line":0}},{"line":893,"address":[22249033],"length":1,"stats":{"Line":0}},{"line":898,"address":[22146074,22146261],"length":1,"stats":{"Line":2}},{"line":899,"address":[22146269],"length":1,"stats":{"Line":1}},{"line":900,"address":[22246877,22245251],"length":1,"stats":{"Line":0}},{"line":901,"address":[22207131],"length":1,"stats":{"Line":0}},{"line":905,"address":[22132515,22132594],"length":1,"stats":{"Line":2}},{"line":906,"address":[22345781,22345719],"length":1,"stats":{"Line":3}},{"line":907,"address":[22245496,22245888],"length":1,"stats":{"Line":0}},{"line":908,"address":[16387088],"length":1,"stats":{"Line":0}},{"line":912,"address":[22146594,22146517],"length":1,"stats":{"Line":4}},{"line":913,"address":[22346006,22346085],"length":1,"stats":{"Line":4}},{"line":914,"address":[22214569],"length":1,"stats":{"Line":1}},{"line":915,"address":[22214561],"length":1,"stats":{"Line":1}},{"line":921,"address":[22251525,22250960],"length":1,"stats":{"Line":4}},{"line":922,"address":[22250027,22249930],"length":1,"stats":{"Line":4}},{"line":923,"address":[22346583],"length":1,"stats":{"Line":2}},{"line":924,"address":[22133668],"length":1,"stats":{"Line":0}},{"line":925,"address":[22251948],"length":1,"stats":{"Line":0}},{"line":932,"address":[22252176],"length":1,"stats":{"Line":2}},{"line":933,"address":[22147067],"length":1,"stats":{"Line":2}},{"line":934,"address":[22140131],"length":1,"stats":{"Line":2}},{"line":935,"address":[22208399],"length":1,"stats":{"Line":2}},{"line":951,"address":[22209616,22210441,22210477],"length":1,"stats":{"Line":3}},{"line":952,"address":[22141851,22141988],"length":1,"stats":{"Line":3}},{"line":953,"address":[22142087,22141965],"length":1,"stats":{"Line":6}},{"line":954,"address":[22254153,22253647],"length":1,"stats":{"Line":0}},{"line":955,"address":[22209943],"length":1,"stats":{"Line":0}},{"line":959,"address":[22254146,22253836,22253689,22253607],"length":1,"stats":{"Line":6}},{"line":960,"address":[22248221,22248377],"length":1,"stats":{"Line":6}},{"line":961,"address":[22210306,22210374],"length":1,"stats":{"Line":0}},{"line":962,"address":[16390010],"length":1,"stats":{"Line":0}},{"line":966,"address":[22149444],"length":1,"stats":{"Line":3}},{"line":969,"address":[16390208],"length":1,"stats":{"Line":3}},{"line":970,"address":[22254262],"length":1,"stats":{"Line":3}},{"line":971,"address":[22248880,22248786,22248889,22248768],"length":1,"stats":{"Line":12}},{"line":972,"address":[22149977,22149968],"length":1,"stats":{"Line":6}},{"line":976,"address":[22254544],"length":1,"stats":{"Line":3}},{"line":977,"address":[22210881,22210944],"length":1,"stats":{"Line":3}},{"line":978,"address":[22143276],"length":1,"stats":{"Line":0}},{"line":979,"address":[15179318],"length":1,"stats":{"Line":0}},{"line":980,"address":[22143163],"length":1,"stats":{"Line":0}}],"covered":320,"coverable":476},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","auth_lifecycle.rs"],"content":"use super::{TopicService, UserService};\nuse crate::application::ports::auth_lifecycle::{\n    AuthAccountContext, AuthLifecycleEvent, AuthLifecyclePort, AuthLifecycleStage,\n};\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse tracing::debug;\n\npub struct DefaultAuthLifecycle {\n    user_service: Arc<UserService>,\n    topic_service: Arc<TopicService>,\n    default_topics: Vec<String>,\n}\n\nimpl DefaultAuthLifecycle {\n    pub fn new(user_service: Arc<UserService>, topic_service: Arc<TopicService>) -> Self {\n        Self {\n            user_service,\n            topic_service,\n            default_topics: vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()],\n        }\n    }\n\n    pub fn with_default_topics(mut self, topics: Vec<String>) -> Self {\n        if topics.is_empty() {\n            return self;\n        }\n        self.default_topics = topics;\n        self\n    }\n\n    async fn ensure_topics_ready(&self) -> Result<(), AppError> {\n        self.topic_service.ensure_public_topic().await\n    }\n\n    async fn join_default_topics(&self, user_pubkey: &str) {\n        for topic in &self.default_topics {\n            if let Err(err) = self.topic_service.join_topic(topic, user_pubkey).await {\n                debug!(\n                    topic = %topic,\n                    pubkey = %user_pubkey,\n                    error = %err,\n                    \"failed to join default topic (ignored)\"\n                );\n            }\n        }\n    }\n\n    async fn provision_account(&self, account: AuthAccountContext) -> Result<User, AppError> {\n        self.ensure_topics_ready().await?;\n        let user = self\n            .user_service\n            .create_user(account.npub.clone(), account.public_key.clone())\n            .await?;\n        self.join_default_topics(&account.public_key).await;\n        Ok(user)\n    }\n\n    async fn handle_login(&self, account: AuthAccountContext) -> Result<User, AppError> {\n        self.ensure_topics_ready().await?;\n        let user = match self.user_service.get_user(&account.npub).await? {\n            Some(existing) => existing,\n            None => {\n                self.user_service\n                    .create_user(account.npub.clone(), account.public_key.clone())\n                    .await?\n            }\n        };\n        self.join_default_topics(&account.public_key).await;\n        Ok(user)\n    }\n}\n\n#[async_trait]\nimpl AuthLifecyclePort for DefaultAuthLifecycle {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError> {\n        match event.stage {\n            AuthLifecycleStage::AccountCreated => self.provision_account(event.account).await,\n            AuthLifecycleStage::Login => self.handle_login(event.account).await,\n        }\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        self.user_service.get_user(npub).await\n    }\n}\n","traces":[{"line":19,"address":[13893227,13893257,13892864],"length":1,"stats":{"Line":0}},{"line":23,"address":[19852004,19851679,19851734],"length":1,"stats":{"Line":0}},{"line":27,"address":[19757264,19757653,19757720],"length":1,"stats":{"Line":0}},{"line":28,"address":[19652849,19652768],"length":1,"stats":{"Line":0}},{"line":29,"address":[19645937],"length":1,"stats":{"Line":0}},{"line":31,"address":[19751809,19751905],"length":1,"stats":{"Line":0}},{"line":32,"address":[19639294],"length":1,"stats":{"Line":0}},{"line":35,"address":[19714131,19714072,19714400,19714220,19714064,19714257,19714682,19714096],"length":1,"stats":{"Line":0}},{"line":36,"address":[19752544,19752421,19752359,19752312],"length":1,"stats":{"Line":0}},{"line":39,"address":[13894681,13894495,13894797,13894416,13894464,13897333,13894638,13894434],"length":1,"stats":{"Line":0}},{"line":40,"address":[23899643,23899495,23902275,23902198],"length":1,"stats":{"Line":0}},{"line":41,"address":[11696759],"length":1,"stats":{"Line":0}},{"line":42,"address":[19640997,19852239,19641498,19852105,19640896],"length":1,"stats":{"Line":0}},{"line":52,"address":[19761651,19761616,19762826,19761740,19761696,19761885,19762094,19763523],"length":1,"stats":{"Line":0}},{"line":53,"address":[11688892],"length":1,"stats":{"Line":0}},{"line":54,"address":[19763006,19762403,19763080,19763518,19763308,19762668,19762746],"length":1,"stats":{"Line":0}},{"line":56,"address":[19761063,19760872,19761156],"length":1,"stats":{"Line":0}},{"line":57,"address":[11687264],"length":1,"stats":{"Line":0}},{"line":58,"address":[11584407],"length":1,"stats":{"Line":0}},{"line":59,"address":[19659275],"length":1,"stats":{"Line":0}},{"line":62,"address":[19659392,19659915,19659472,19659682,19660532,19659427,19659531,19662116],"length":1,"stats":{"Line":0}},{"line":63,"address":[11561452],"length":1,"stats":{"Line":0}},{"line":64,"address":[19764255,19764761,19764878,19765069,19766018],"length":1,"stats":{"Line":0}},{"line":65,"address":[19728829],"length":1,"stats":{"Line":0}},{"line":67,"address":[19722553,19722727,19722943,19721869,19722117,19722473,19722195],"length":1,"stats":{"Line":0}},{"line":68,"address":[23906599,23906321,23906508],"length":1,"stats":{"Line":0}},{"line":69,"address":[19654519,19654360,19654667,19654866,19652769,19654420],"length":1,"stats":{"Line":0}},{"line":72,"address":[19646003,19647689,19648463,19648238],"length":1,"stats":{"Line":0}},{"line":73,"address":[19761355],"length":1,"stats":{"Line":0}},{"line":79,"address":[19866453,19866400,19866716,19867303,19866319,19866588,19866757,19867612,19867878],"length":1,"stats":{"Line":0}},{"line":80,"address":[23967301],"length":1,"stats":{"Line":0}},{"line":81,"address":[19866615,19866980,19867335,19867127],"length":1,"stats":{"Line":0}},{"line":82,"address":[11267524],"length":1,"stats":{"Line":0}},{"line":86,"address":[14108547,14109254,14108467,14108994,14108758,14108735,14108512,14108646],"length":1,"stats":{"Line":0}},{"line":87,"address":[11904180],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","auth_service.rs"],"content":"use crate::application::ports::auth_lifecycle::{\r\n    AuthAccountContext, AuthLifecycleEvent, AuthLifecyclePort,\r\n};\r\nuse crate::application::ports::key_manager::{KeyManager, KeyPair};\nuse crate::domain::entities::User;\r\nuse crate::infrastructure::storage::SecureStorage;\r\nuse crate::shared::error::AppError;\r\nuse std::sync::Arc;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct AuthStatus {\r\n    pub is_authenticated: bool,\r\n    pub current_user: Option<User>,\r\n    pub npub: Option<String>,\r\n}\r\n\r\npub struct AuthService {\r\n    key_manager: Arc<dyn KeyManager>,\r\n    secure_storage: Arc<dyn SecureStorage>,\r\n    lifecycle_port: Arc<dyn AuthLifecyclePort>,\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::auth_lifecycle::AuthLifecycleStage;\r\n    use async_trait::async_trait;\r\n    use mockall::{mock, predicate::*};\r\n\r\n    mock! {\r\n        pub KeyManager {}\r\n\r\n        #[async_trait]\r\n        impl KeyManager for KeyManager {\r\n            async fn generate_keypair(&self) -> Result<KeyPair, AppError>;\r\n            async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError>;\r\n            async fn export_private_key(&self, npub: &str) -> Result<String, AppError>;\r\n            async fn get_public_key(&self, npub: &str) -> Result<String, AppError>;\r\n            async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\r\n            async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\r\n            async fn list_npubs(&self) -> Result<Vec<String>, AppError>;\r\n            async fn current_keypair(&self) -> Result<KeyPair, AppError>;\r\n        }\r\n    }\r\n\r\n    mock! {\r\n        pub SecureStorage {}\r\n\r\n        #[async_trait]\r\n        impl SecureStorage for SecureStorage {\r\n            async fn store(&self, key: &str, value: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn retrieve(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;\r\n            async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\r\n        }\r\n    }\r\n\r\n    mock! {\r\n        pub Lifecycle {}\r\n\r\n        #[async_trait]\r\n        impl AuthLifecyclePort for Lifecycle {\r\n            async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError>;\r\n            async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\r\n        }\r\n    }\r\n\r\n    use crate::application::ports::key_manager::KeyPair;\r\n\r\n    fn sample_keypair() -> KeyPair {\r\n        KeyPair {\r\n            public_key: \"pub\".into(),\r\n            private_key: \"priv\".into(),\r\n            npub: \"npub1\".into(),\r\n            nsec: \"nsec1\".into(),\r\n        }\r\n    }\r\n\r\n    fn sample_user() -> User {\r\n        User::new(\"npub1\".into(), \"pub\".into())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn create_account_dispatches_lifecycle_event() {\r\n        let mut key_manager = MockKeyManager::new();\r\n        key_manager\r\n            .expect_generate_keypair()\r\n            .times(1)\r\n            .returning(|| Ok(sample_keypair()));\r\n        key_manager\r\n            .expect_store_keypair()\r\n            .times(1)\r\n            .returning(|_| Ok(()));\r\n        let mut storage = MockSecureStorage::new();\r\n        storage\r\n            .expect_store()\r\n            .with(eq(\"current_npub\"), eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_, _| Ok(()));\r\n\r\n        let mut lifecycle = MockLifecycle::new();\r\n        lifecycle\r\n            .expect_handle()\r\n            .times(1)\r\n            .withf(|event| event.stage == AuthLifecycleStage::AccountCreated)\r\n            .returning(|_| Ok(sample_user()));\r\n\r\n        let service = AuthService::new(\r\n            Arc::new(key_manager),\r\n            Arc::new(storage),\r\n            Arc::new(lifecycle),\r\n        );\r\n\r\n        let user = service.create_account().await.expect(\"create account\");\r\n        assert_eq!(user.npub, \"npub1\");\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn login_with_npub_uses_lifecycle_login() {\r\n        let mut key_manager = MockKeyManager::new();\r\n        key_manager\r\n            .expect_export_private_key()\r\n            .with(eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_| Ok(\"nsec\".into()));\r\n        key_manager\r\n            .expect_get_public_key()\r\n            .with(eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_| Ok(\"pub\".into()));\r\n        let mut storage = MockSecureStorage::new();\r\n        storage\r\n            .expect_store()\r\n            .with(eq(\"current_npub\"), eq(\"npub1\"))\r\n            .times(1)\r\n            .returning(|_, _| Ok(()));\r\n        let mut lifecycle = MockLifecycle::new();\r\n        lifecycle\r\n            .expect_handle()\r\n            .times(1)\r\n            .withf(|event| event.stage == AuthLifecycleStage::Login)\r\n            .returning(|_| Ok(sample_user()));\r\n\r\n        let service = AuthService::new(\r\n            Arc::new(key_manager),\r\n            Arc::new(storage),\r\n            Arc::new(lifecycle),\r\n        );\r\n\r\n        let user = service\r\n            .login_with_npub(\"npub1\")\r\n            .await\r\n            .expect(\"login success\");\r\n        assert_eq!(user.pubkey, \"pub\");\r\n    }\r\n}\r\n\r\nimpl AuthService {\r\n    pub fn new(\r\n        key_manager: Arc<dyn KeyManager>,\r\n        secure_storage: Arc<dyn SecureStorage>,\r\n        lifecycle_port: Arc<dyn AuthLifecyclePort>,\r\n    ) -> Self {\r\n        Self {\r\n            key_manager,\r\n            secure_storage,\r\n            lifecycle_port,\r\n        }\r\n    }\r\n\r\n    pub async fn create_account_with_keys(&self) -> Result<(User, KeyPair), AppError> {\n        let keypair = self.key_manager.generate_keypair().await?;\n\n        self.key_manager.store_keypair(&keypair).await?;\n        self.secure_storage\n            .store(\"current_npub\", &keypair.npub)\n            .await?;\n\n        let context = AuthAccountContext::from(&keypair);\n        let user = self\n            .lifecycle_port\n            .handle(AuthLifecycleEvent::account_created(context))\n            .await?;\n\n        Ok((user, keypair))\n    }\n\n    pub async fn create_account(&self) -> Result<User, AppError> {\n        let (user, _) = self.create_account_with_keys().await?;\n        Ok(user)\n    }\n\r\n    pub async fn login_with_nsec(&self, nsec: &str) -> Result<User, AppError> {\r\n        // Import private key\r\n        let keypair = self.key_manager.import_private_key(nsec).await?;\r\n\r\n        // Store securely\r\n        self.key_manager.store_keypair(&keypair).await?;\r\n        self.secure_storage\r\n            .store(\"current_npub\", &keypair.npub)\r\n            .await?;\r\n\r\n        let context = AuthAccountContext::from(&keypair);\r\n        self.lifecycle_port\r\n            .handle(AuthLifecycleEvent::login(context))\r\n            .await\r\n    }\r\n\r\n    pub async fn login_with_npub(&self, npub: &str) -> Result<User, AppError> {\r\n        // Check if we have the private key stored\r\n        let _private_key = self.key_manager.export_private_key(npub).await?;\r\n\r\n        let public_key = self.key_manager.get_public_key(npub).await?;\r\n        let context = AuthAccountContext::new(npub.to_string(), public_key);\r\n        let user = self\r\n            .lifecycle_port\r\n            .handle(AuthLifecycleEvent::login(context))\r\n            .await?;\r\n\r\n        self.secure_storage.store(\"current_npub\", npub).await?;\r\n\r\n        Ok(user)\r\n    }\r\n\r\n    pub async fn logout(&self) -> Result<(), AppError> {\r\n        self.secure_storage.delete(\"current_npub\").await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn get_current_user(&self) -> Result<Option<User>, AppError> {\r\n        if let Some(npub) = self.secure_storage.retrieve(\"current_npub\").await? {\r\n            self.lifecycle_port.get_user(&npub).await\r\n        } else {\r\n            Ok(None)\r\n        }\r\n    }\r\n\r\n    pub async fn is_authenticated(&self) -> bool {\r\n        self.secure_storage\r\n            .retrieve(\"current_npub\")\r\n            .await\r\n            .unwrap_or(None)\r\n            .is_some()\r\n    }\r\n\r\n    pub async fn get_auth_status(&self) -> Result<AuthStatus, AppError> {\n        let current_user = self.get_current_user().await?;\n        let npub = self.secure_storage.retrieve(\"current_npub\").await?;\n\n        Ok(AuthStatus {\n            is_authenticated: current_user.is_some(),\r\n            current_user,\n            npub,\n        })\n    }\n\n    pub async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        self.key_manager.current_keypair().await\n    }\n\n    pub async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_manager.export_private_key(npub).await\n    }\n\r\n    pub async fn list_accounts(&self) -> Result<Vec<String>, AppError> {\r\n        self.key_manager.list_npubs().await\r\n    }\r\n\r\n    pub async fn switch_account(&self, npub: &str) -> Result<User, AppError> {\r\n        self.login_with_npub(npub).await\r\n    }\r\n}\r\n","traces":[{"line":161,"address":[24672128],"length":1,"stats":{"Line":2}},{"line":173,"address":[17149096,17149120,17149299,17149601,17149405,17149088,17149167,17150544],"length":1,"stats":{"Line":8}},{"line":174,"address":[17149257,17149468,17150488,17149329,17149633,17150202],"length":1,"stats":{"Line":4}},{"line":176,"address":[17150160,17150553,17150347,17150876,17151196,17149350],"length":1,"stats":{"Line":4}},{"line":177,"address":[23013485,23013169,23013906,23014296,23013647,23013396,23013771],"length":1,"stats":{"Line":10}},{"line":178,"address":[23109761],"length":1,"stats":{"Line":2}},{"line":179,"address":[22908827,22910994,22910624,22910568,22910809,22910676],"length":1,"stats":{"Line":6}},{"line":181,"address":[23009911,23010038],"length":1,"stats":{"Line":4}},{"line":182,"address":[22897804,22898146,22897542,22897878,22897346,22897609],"length":1,"stats":{"Line":10}},{"line":184,"address":[23014085],"length":1,"stats":{"Line":2}},{"line":185,"address":[11765440],"length":1,"stats":{"Line":6}},{"line":187,"address":[23016258],"length":1,"stats":{"Line":2}},{"line":190,"address":[24675528,24675826,24676434,24675671,24675708,24675520,24675552,24675587],"length":1,"stats":{"Line":8}},{"line":191,"address":[22905247,22905144,22905190,22905971,22905358],"length":1,"stats":{"Line":4}},{"line":192,"address":[22905865],"length":1,"stats":{"Line":2}},{"line":195,"address":[23112880,23112553,23112367,23113841,23112290,23112272,23112320,23112659],"length":1,"stats":{"Line":4}},{"line":197,"address":[10877316],"length":1,"stats":{"Line":2}},{"line":200,"address":[11525307],"length":1,"stats":{"Line":2}},{"line":201,"address":[22915591,22915999,22915149,22915326,22914827,22915456,22915054],"length":1,"stats":{"Line":5}},{"line":202,"address":[22901227],"length":1,"stats":{"Line":1}},{"line":203,"address":[17156103,17155912,17155715,17155650,17153857,17155773],"length":1,"stats":{"Line":3}},{"line":205,"address":[24678921,24679043],"length":1,"stats":{"Line":2}},{"line":206,"address":[22908903,22908701,22909188,22908970],"length":1,"stats":{"Line":4}},{"line":207,"address":[22908803],"length":1,"stats":{"Line":1}},{"line":208,"address":[22902155,22899574,22902208,22902244,22902430],"length":1,"stats":{"Line":3}},{"line":211,"address":[23115910,23116224,23115648,23115696,23115743,23116016,23117004,23115666],"length":1,"stats":{"Line":4}},{"line":213,"address":[22916556,22916767,22916628,22917330,22917636,22916944],"length":1,"stats":{"Line":2}},{"line":215,"address":[23116600,23116803,23117013,23115961,23117406,23118000],"length":1,"stats":{"Line":2}},{"line":216,"address":[22918057,22918236],"length":1,"stats":{"Line":2}},{"line":217,"address":[22979382,22979159,22979473,22979780,22980010,22980241,22979706],"length":1,"stats":{"Line":5}},{"line":219,"address":[22911471],"length":1,"stats":{"Line":1}},{"line":220,"address":[19286137],"length":1,"stats":{"Line":3}},{"line":222,"address":[11623888],"length":1,"stats":{"Line":2}},{"line":224,"address":[22905959],"length":1,"stats":{"Line":1}},{"line":227,"address":[22981179,22980816,22980824,22980870,22980967,22981604,22980832,22981007],"length":1,"stats":{"Line":4}},{"line":228,"address":[11556614],"length":1,"stats":{"Line":2}},{"line":229,"address":[22913678],"length":1,"stats":{"Line":1}},{"line":232,"address":[23023664,23023911,23024113,23023680,23023847,23025038,23023672,23023727],"length":1,"stats":{"Line":0}},{"line":233,"address":[19292319],"length":1,"stats":{"Line":0}},{"line":234,"address":[22914927,22915191,22914796,22914042],"length":1,"stats":{"Line":0}},{"line":236,"address":[22982890],"length":1,"stats":{"Line":0}},{"line":240,"address":[22915529,22916194,22915488,22915504,22915660,22915823,22915620,22915496],"length":1,"stats":{"Line":0}},{"line":241,"address":[23021881,23021634,23021974,23021705,23021515],"length":1,"stats":{"Line":0}},{"line":243,"address":[22990591,22990383,22990726,22990534,22990490],"length":1,"stats":{"Line":0}},{"line":244,"address":[23122334],"length":1,"stats":{"Line":0}},{"line":248,"address":[24686264,24687278,24686590,24686411,24686310,24686256,24686272,24686466],"length":1,"stats":{"Line":0}},{"line":249,"address":[22923445,22923562,22923312,22923370,22923949,22924207],"length":1,"stats":{"Line":0}},{"line":250,"address":[22917290,22916409,22917116,22917656,22916933],"length":1,"stats":{"Line":0}},{"line":252,"address":[23124131],"length":1,"stats":{"Line":0}},{"line":253,"address":[23123917],"length":1,"stats":{"Line":0}},{"line":254,"address":[22910977],"length":1,"stats":{"Line":0}},{"line":255,"address":[22917795],"length":1,"stats":{"Line":0}},{"line":259,"address":[23124597,23124280,23124323,23124447,23124288,23124272,23124410,23124929],"length":1,"stats":{"Line":0}},{"line":260,"address":[22918101,22918341,22918213,22918149],"length":1,"stats":{"Line":0}},{"line":263,"address":[23028721,23028761,23028560,23028922,23028595,23028530,23029190,23028512],"length":1,"stats":{"Line":4}},{"line":264,"address":[19298484],"length":1,"stats":{"Line":2}},{"line":267,"address":[22919482,22919519,22919935,22919360,22919344,22919352,22919395,22919670],"length":1,"stats":{"Line":0}},{"line":268,"address":[22912789,22912725,22912677,22912918],"length":1,"stats":{"Line":0}},{"line":271,"address":[22927165,22926928,22926976,22927284,22926946,22927011,22927128,22927568],"length":1,"stats":{"Line":0}},{"line":272,"address":[23026260,23026099,23026156,23026053],"length":1,"stats":{"Line":0}}],"covered":39,"coverable":60},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","direct_message_service","tests.rs"],"content":"use super::*;\nuse crate::application::ports::{\n    direct_message_notifier::DirectMessageNotifier,\n    repositories::{\n        DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n        DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n        DirectMessagePageRaw,\n    },\n};\nuse async_trait::async_trait;\nuse mockall::mock;\nuse std::sync::Arc;\n\nmock! {\n    pub Repo {}\n\n    #[async_trait]\n    impl DirectMessageRepository for Repo {\n        async fn insert_direct_message(\n            &self,\n            message: &NewDirectMessage,\n        ) -> Result<DirectMessage, AppError>;\n\n        async fn list_direct_messages(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            cursor: Option<DirectMessageCursor>,\n            limit: usize,\n            direction: DirectMessageListDirection,\n        ) -> Result<DirectMessagePageRaw, AppError>;\n\n        async fn mark_delivered_by_client_id(\n            &self,\n            owner_npub: &str,\n            client_message_id: &str,\n            event_id: Option<String>,\n            delivered: bool,\n        ) -> Result<(), AppError>;\n\n        async fn upsert_conversation_metadata(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            last_message_id: i64,\n            last_message_created_at: i64,\n        ) -> Result<(), AppError>;\n\n        async fn mark_conversation_as_read(\n            &self,\n            owner_npub: &str,\n            conversation_npub: &str,\n            read_at: i64,\n        ) -> Result<(), AppError>;\n\n        async fn list_direct_message_conversations(\n            &self,\n            owner_npub: &str,\n            cursor: Option<DirectMessageConversationCursor>,\n            limit: usize,\n        ) -> Result<DirectMessageConversationPageRaw, AppError>;\n    }\n}\n\nmock! {\n    pub Gateway {}\n\n    #[async_trait]\n    impl MessagingGateway for Gateway {\n        async fn encrypt_and_send(\n            &self,\n            owner_npub: &str,\n            recipient_npub: &str,\n            plaintext: &str,\n        ) -> Result<MessagingSendResult, AppError>;\n\n        async fn encrypt_only(\n            &self,\n            owner_npub: &str,\n            recipient_npub: &str,\n            plaintext: &str,\n        ) -> Result<String, AppError>;\n\n        async fn decrypt_with_counterparty(\n            &self,\n            owner_npub: &str,\n            counterparty_npub: &str,\n            ciphertext: &str,\n        ) -> Result<String, AppError>;\n    }\n}\n\nmock! {\n    pub Notifier {}\n\n    #[async_trait]\n    impl DirectMessageNotifier for Notifier {\n        async fn notify(\n            &self,\n            owner_npub: &str,\n            message: &DirectMessage,\n        ) -> Result<(), AppError>;\n    }\n}\n\n#[tokio::test]\nasync fn send_direct_message_success() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .withf(|message| {\n            message.owner_npub == \"npub_sender\"\n                && message.recipient_npub == \"npub_recipient\"\n                && message.payload_cipher_base64 == \"cipher\"\n        })\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .withf(|owner, conv, _, _| owner == \"npub_sender\" && conv == \"npub_recipient\")\n        .returning(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .returning(|_, _, _| {\n            Ok(MessagingSendResult {\n                event_id: Some(\"event1\".to_string()),\n                ciphertext: \"cipher\".to_string(),\n                created_at_millis: 1000,\n                delivered: true,\n            })\n        });\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .send_direct_message(\n            \"npub_sender\",\n            \"npub_recipient\",\n            \" hello world \",\n            Some(\"client-1\".to_string()),\n        )\n        .await\n        .expect(\"success\");\n\n    assert_eq!(result.event_id.as_deref(), Some(\"event1\"));\n    assert!(!result.queued);\n    assert_eq!(result.message.decrypted_content.unwrap(), \"hello world\");\n}\n\n#[tokio::test]\nasync fn send_direct_message_propagates_gateway_errors() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message().never();\n    repo.expect_upsert_conversation_metadata().never();\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .return_once(|_, _, _| Err(AppError::Crypto(\"failed to encrypt\".into())));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let err = service\n        .send_direct_message(\"npub_sender\", \"npub_recipient\", \"hello\", None)\n        .await\n        .expect_err(\"gateway error should bubble\");\n    assert!(matches!(err, AppError::Crypto(_)));\n}\n\n#[tokio::test]\nasync fn send_direct_message_marks_queued_when_delivery_pending() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .return_once(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_encrypt_and_send()\n        .times(1)\n        .returning(|_, _, _| {\n            Ok(MessagingSendResult {\n                event_id: None,\n                ciphertext: \"cipher\".to_string(),\n                created_at_millis: 2000,\n                delivered: false,\n            })\n        });\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .send_direct_message(\"npub_sender\", \"npub_recipient\", \"hi\", None)\n        .await\n        .expect(\"queued ok\");\n    assert!(result.queued);\n    assert_eq!(result.message.decrypted_content.as_deref(), Some(\"hi\"));\n}\n\n#[tokio::test]\nasync fn list_direct_messages_decrypts_payloads() {\n    let mut repo = MockRepo::new();\n    let page_raw = DirectMessagePageRaw {\n        items: vec![DirectMessage::new(\n            1,\n            \"npub_owner\".to_string(),\n            \"npub_partner\".to_string(),\n            \"npub_owner\".to_string(),\n            \"npub_partner\".to_string(),\n            Some(\"event1\".to_string()),\n            Some(\"client-1\".to_string()),\n            \"cipher\".to_string(),\n            1000,\n            true,\n            MessageDirection::Outbound,\n        )],\n        next_cursor: Some(\"1000:event1\".to_string()),\n        has_more: false,\n    };\n\n    repo.expect_list_direct_messages()\n        .times(1)\n        .returning(move |_, _, _, _, _| Ok(page_raw.clone()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"decrypted\".to_string()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let page = service\n        .list_direct_messages(\n            \"npub_owner\",\n            \"npub_partner\",\n            None,\n            Some(20),\n            MessagePageDirection::Backward,\n        )\n        .await\n        .expect(\"list succeeds\");\n\n    assert_eq!(page.items.len(), 1);\n    assert_eq!(\n        page.items[0].decrypted_content.as_deref(),\n        Some(\"decrypted\")\n    );\n    assert_eq!(page.next_cursor.as_deref(), Some(\"1000:event1\"));\n    assert!(!page.has_more);\n}\n\n#[tokio::test]\nasync fn send_direct_message_rejects_empty_content() {\n    let repo = MockRepo::new();\n    let gateway = MockGateway::new();\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let error = service\n        .send_direct_message(\"npub_owner\", \"npub_partner\", \"   \", None)\n        .await\n        .expect_err(\"validation error\");\n\n    assert_eq!(\n        error.validation_kind(),\n        Some(ValidationFailureKind::Generic)\n    );\n}\n\n#[tokio::test]\nasync fn ingest_incoming_message_stores_and_notifies() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message()\n        .times(1)\n        .withf(|message| {\n            message.owner_npub == \"npub_owner\"\n                && message.conversation_npub == \"npub_sender\"\n                && message.direction == MessageDirection::Inbound\n                && message.delivered\n        })\n        .returning(|message| {\n            Ok(DirectMessage::new(\n                1,\n                message.owner_npub.clone(),\n                message.conversation_npub.clone(),\n                message.sender_npub.clone(),\n                message.recipient_npub.clone(),\n                message.event_id.clone(),\n                message.client_message_id.clone(),\n                message.payload_cipher_base64.clone(),\n                message.created_at.timestamp_millis(),\n                message.delivered,\n                message.direction,\n            ))\n        });\n\n    repo.expect_upsert_conversation_metadata()\n        .times(1)\n        .withf(|owner, conv, _, _| owner == \"npub_owner\" && conv == \"npub_sender\")\n        .returning(|_, _, _, _| Ok(()));\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"hello inbound\".to_string()));\n\n    let mut notifier = MockNotifier::new();\n    notifier\n        .expect_notify()\n        .times(1)\n        .withf(|owner, message| {\n            owner == \"npub_owner\"\n                && message.conversation_npub == \"npub_sender\"\n                && message.direction == MessageDirection::Inbound\n        })\n        .return_once(|_, _| Ok(()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let notifier: Arc<dyn DirectMessageNotifier> = Arc::new(notifier);\n    let service = DirectMessageService::new(repo, gateway, Some(notifier));\n\n    let stored = service\n        .ingest_incoming_message(\n            \"npub_owner\",\n            \"npub_sender\",\n            \"ciphertext\",\n            Some(\"event1\".to_string()),\n            1_730_000_000_000,\n        )\n        .await\n        .expect(\"ingest succeeds\");\n\n    let message = stored.expect(\"message stored\");\n    assert_eq!(message.decrypted_content.as_deref(), Some(\"hello inbound\"));\n    assert_eq!(message.direction, MessageDirection::Inbound);\n}\n\n#[tokio::test]\nasync fn ingest_incoming_message_ignores_duplicates() {\n    let mut repo = MockRepo::new();\n    repo.expect_insert_direct_message().times(1).returning(|_| {\n        Err(AppError::Database(\n            \"UNIQUE constraint failed: direct_messages.owner_npub, event_id\".to_string(),\n        ))\n    });\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"ignored\".to_string()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let result = service\n        .ingest_incoming_message(\n            \"npub_owner\",\n            \"npub_sender\",\n            \"cipher\",\n            Some(\"evt\".into()),\n            10,\n        )\n        .await\n        .expect(\"duplicate ignored\");\n\n    assert!(result.is_none());\n}\n\n#[tokio::test]\nasync fn list_direct_message_conversations_returns_decrypted_last_message() {\n    let mut repo = MockRepo::new();\n    repo.expect_list_direct_message_conversations()\n        .times(1)\n        .withf(|owner, cursor, limit| owner == \"npub_owner\" && cursor.is_none() && *limit == 20)\n        .returning(|_, _, _| {\n            Ok(DirectMessageConversationPageRaw {\n                items: vec![DirectMessageConversationRecord {\n                    owner_npub: \"npub_owner\".into(),\n                    conversation_npub: \"npub_friend\".into(),\n                    last_message: Some(DirectMessage::new(\n                        42,\n                        \"npub_owner\".into(),\n                        \"npub_friend\".into(),\n                        \"npub_owner\".into(),\n                        \"npub_friend\".into(),\n                        Some(\"evt\".into()),\n                        Some(\"client\".into()),\n                        \"cipher\".into(),\n                        1_700_000_000_000,\n                        true,\n                        MessageDirection::Outbound,\n                    )),\n                    last_message_created_at: Some(1_700_000_000_000),\n                    last_read_at: 0,\n                    unread_count: 3,\n                }],\n                next_cursor: Some(\n                    DirectMessageConversationCursor::new(\n                        Some(1_700_000_000_000),\n                        \"npub_friend\".into(),\n                    )\n                    .to_string(),\n                ),\n                has_more: true,\n            })\n        });\n\n    let mut gateway = MockGateway::new();\n    gateway\n        .expect_decrypt_with_counterparty()\n        .times(1)\n        .returning(|_, _, _| Ok(\"hello friend\".into()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    let page = service\n        .list_direct_message_conversations(\"npub_owner\", None, Some(20))\n        .await\n        .expect(\"list succeeds\");\n\n    assert_eq!(page.items.len(), 1);\n    assert_eq!(page.items[0].conversation_npub, \"npub_friend\");\n    assert_eq!(page.items[0].unread_count, 3);\n    assert_eq!(\n        page.items[0]\n            .last_message\n            .as_ref()\n            .and_then(|message| message.decrypted_content.clone()),\n        Some(\"hello friend\".into())\n    );\n    assert!(page.has_more);\n    assert!(page.next_cursor.is_some());\n}\n\n#[tokio::test]\nasync fn mark_conversation_as_read_clamps_negative_timestamps() {\n    let mut repo = MockRepo::new();\n    repo.expect_mark_conversation_as_read()\n        .times(1)\n        .withf(|_, _, read_at| *read_at == 0)\n        .returning(|_, _, _| Ok(()));\n\n    let repo: Arc<dyn DirectMessageRepository> = Arc::new(repo);\n    let gateway = MockGateway::new();\n    let gateway: Arc<dyn MessagingGateway> = Arc::new(gateway);\n    let service = DirectMessageService::new(repo, gateway, None);\n\n    service\n        .mark_conversation_as_read(\"npub_owner\", \"npub_friend\", -100)\n        .await\n        .expect(\"mark succeeds\");\n}\n","traces":[{"line":14,"address":[23111008,23102624,23110000,23105336,23103451,23109331,23104455,23104869,23109779,23110149,23102081,23105615,23102486,23102896,23105232,23104812,23110773,23108581,23107226,23103856,23104844,23102015,23101953,23110194,23109504,23104905,23102292,23110309,23102608,23102906,23104723,23106160,23107360,23109693,23106286,23101632,23102912,23110610,23105167,23108349,23103344,23103555,23108006,23109141,23102928,23110046,23108245,23105033,23109524,23106067,23109076,23101789,23109952,23110653,23105567,23109056,23103576,23108435,23110269,23111017,23103873,23105152,23105024,23104969,23110144,23106555,23108693,23105600,23101841,23103934,23110288,23102320,23109245,23104432,23110880,23108883,23109029,23107456,23107431,23110064,23106671,23102915,23110958,23104688,23105872,23110224,23101912,23110481,23104864,23109970,23105784,23104896,23105134,23110176,23110912,23105120,23109589,23109477,23104624,23110256,23108608,23110112,23110005,23105424,23108160,23110078,23103220,23108628,23110515,23110736,23110438,23104285,23107184,23102648,23105680,23110704,23102961,23106180,23110906,23110376,23103600,23103838,23102611,23108180,23103630,23104960,23109925,23107632,23110464,23110032,23110237,23104637,23107480,23106015,23101675,23110496,23108797,23110640,23106048,23103370,23103697,23107654,23102206,23110120,23110712],"length":1,"stats":{"Line":444}},{"line":17,"address":[24843776,24842976,24845610,24843193,24844531,24845520,24843939,24842695,24842432,24844777,24845109,24845284,24842503,24845987,24843066,24843485,24842559,24844207,24843843,24844480,24844581,24845059,24845731,24845008],"length":1,"stats":{"Line":15}},{"line":19,"address":[24842368,24842334,24842398,24842481,24842552,24842571,24842721],"length":1,"stats":{"Line":5}},{"line":20,"address":[24842655],"length":1,"stats":{"Line":1}},{"line":21,"address":[23110909],"length":1,"stats":{"Line":2}},{"line":24,"address":[24842942,24843511,24842912,24842827,24843176,24843044,24843200],"length":1,"stats":{"Line":4}},{"line":25,"address":[24843327],"length":1,"stats":{"Line":1}},{"line":26,"address":[24831246,24843423],"length":1,"stats":{"Line":2}},{"line":27,"address":[24831253,24843436],"length":1,"stats":{"Line":2}},{"line":28,"address":[24831061,24843344,24821574,24820749,24821239,24822180,24827851],"length":1,"stats":{"Line":4}},{"line":29,"address":[24843380],"length":1,"stats":{"Line":1}},{"line":30,"address":[24843397,24843407],"length":1,"stats":{"Line":2}},{"line":33,"address":[24843626,24844233,24843821,24843918,24843742,24843712,24843946],"length":1,"stats":{"Line":0}},{"line":34,"address":[24844073],"length":1,"stats":{"Line":0}},{"line":35,"address":[19386126],"length":1,"stats":{"Line":0}},{"line":36,"address":[24844164],"length":1,"stats":{"Line":0}},{"line":37,"address":[24844090],"length":1,"stats":{"Line":0}},{"line":38,"address":[24844126,24844135],"length":1,"stats":{"Line":0}},{"line":41,"address":[24844803,24844346,24844446,24844416,24844509,24844574,24844593],"length":1,"stats":{"Line":5}},{"line":42,"address":[24844677],"length":1,"stats":{"Line":1}},{"line":43,"address":[15452526],"length":1,"stats":{"Line":2}},{"line":44,"address":[15452533],"length":1,"stats":{"Line":2}},{"line":45,"address":[24844693],"length":1,"stats":{"Line":1}},{"line":46,"address":[24844710],"length":1,"stats":{"Line":1}},{"line":49,"address":[24845121,24845310,24845037,24844974,24845102,24844882,24844944],"length":1,"stats":{"Line":5}},{"line":50,"address":[24845205],"length":1,"stats":{"Line":1}},{"line":51,"address":[24841021,24845242],"length":1,"stats":{"Line":2}},{"line":52,"address":[24845255,24841028],"length":1,"stats":{"Line":2}},{"line":53,"address":[24845221],"length":1,"stats":{"Line":1}},{"line":56,"address":[24845738,24845714,24846013,24845456,24845384,24845486,24845588],"length":1,"stats":{"Line":4}},{"line":57,"address":[24845865],"length":1,"stats":{"Line":1}},{"line":58,"address":[24845951],"length":1,"stats":{"Line":2}},{"line":59,"address":[24845882],"length":1,"stats":{"Line":4}},{"line":60,"address":[24845930],"length":1,"stats":{"Line":1}},{"line":65,"address":[23984736,23984288,23980016,23984894,23984936,23980272,23985899,23984709,23980736,23985040,23977279,23985598,23984992,23984115,23982305,23983412,23981387,23984373,23985456,23980864,23976183,23980617,23980846,23985061,23982478,23985975,23980576,23980992,23976588,23985010,23975904,23980208,23979440,23984880,23979123,23979019,23979869,23984928,23986027,23984477,23983840,23985128,23984860,23977090,23978321,23985392,23983581,23980832,23978272,23980745,23985488,23976547,23978266,23982126,23985216,23976044,23978275,23985405,23984261,23976976,23979518,23982886,23980039,23976346,23983667,23980878,23983477,23979193,23981118,23978912,23978256,23979144,23980581,23984784,23984789,23985872,23977523,23976741,23976650,23979423,23977520,23984816,23983925,23985925,23986016,23978938,23981503,23977642,23985233,23983392,23982418,23979260,23977062,23980608,23980221,23983860,23980391,23980681,23979168,23980511,23985267,23985362,23978582,23978288,23982448,23980672,23983813,23984308,23984960,23982016,23977536,23983238,23980552,23984029,23985248,23985190,23984965,23984754,23982864,23979457,23981012,23984563,23985464],"length":1,"stats":{"Line":192}},{"line":68,"address":[24847792,24847893,24847843,24847381,24846873,24848063,24846752,24846823,24847039,24847331,24847280,24847551],"length":1,"stats":{"Line":6}},{"line":70,"address":[24846801,24846885,24846688,24846718,24846866,24847065,24846623],"length":1,"stats":{"Line":5}},{"line":71,"address":[24846969],"length":1,"stats":{"Line":1}},{"line":72,"address":[24846985],"length":1,"stats":{"Line":2}},{"line":73,"address":[24846998],"length":1,"stats":{"Line":2}},{"line":74,"address":[24847006],"length":1,"stats":{"Line":2}},{"line":77,"address":[24847216,24847309,24847393,24847577,24847374,24847151,24847246],"length":1,"stats":{"Line":0}},{"line":78,"address":[24847477],"length":1,"stats":{"Line":0}},{"line":79,"address":[19395294],"length":1,"stats":{"Line":0}},{"line":80,"address":[19395301],"length":1,"stats":{"Line":0}},{"line":81,"address":[19395309],"length":1,"stats":{"Line":0}},{"line":84,"address":[24847905,24847886,24847821,24847728,24847758,24848089,24847663],"length":1,"stats":{"Line":5}},{"line":85,"address":[24847989],"length":1,"stats":{"Line":1}},{"line":86,"address":[16476430],"length":1,"stats":{"Line":2}},{"line":87,"address":[16476437],"length":1,"stats":{"Line":2}},{"line":88,"address":[16476445],"length":1,"stats":{"Line":2}},{"line":93,"address":[24848268,24848141,24848320,24848192,24848304,24848352,24848747,24848205,24848128,24848309,24848368,24848256,24848328,24848357],"length":1,"stats":{"Line":83}},{"line":96,"address":[24848512,24848563,24848613,24848754],"length":1,"stats":{"Line":3}},{"line":98,"address":[24848606,24848448,24848625,24848392,24848478,24848541,24848777],"length":1,"stats":{"Line":5}},{"line":99,"address":[24848709],"length":1,"stats":{"Line":1}},{"line":100,"address":[24848725],"length":1,"stats":{"Line":2}},{"line":101,"address":[24848738],"length":1,"stats":{"Line":2}}],"covered":46,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","direct_message_service.rs"],"content":"#[cfg(test)]\nuse crate::application::ports::messaging_gateway::MessagingSendResult;\nuse crate::application::ports::repositories::{\n    DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n    DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n    DirectMessagePageRaw, DirectMessageRepository,\n};\nuse crate::application::ports::{\n    direct_message_notifier::DirectMessageNotifier, messaging_gateway::MessagingGateway,\n};\nuse crate::domain::entities::{DirectMessage, MessageDirection, NewDirectMessage};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, TimeZone, Utc};\nuse nostr_sdk::prelude::nip04;\nuse nostr_sdk::prelude::{FromBech32, Keys, PublicKey, SecretKey, ToBech32};\nuse std::sync::Arc;\nuse tracing::{debug, error};\n\npub struct DirectMessageService {\n    repository: Arc<dyn DirectMessageRepository>,\n    messaging_gateway: Arc<dyn MessagingGateway>,\n    notifier: Option<Arc<dyn DirectMessageNotifier>>,\n}\n\n#[derive(Debug)]\npub struct SendDirectMessageResult {\n    pub event_id: Option<String>,\n    pub queued: bool,\n    pub message: DirectMessage,\n}\n\n#[derive(Debug)]\npub struct DirectMessagePageResult {\n    pub items: Vec<DirectMessage>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug)]\npub struct DirectMessageConversationSummary {\n    pub conversation_npub: String,\n    pub unread_count: u64,\n    pub last_read_at: i64,\n    pub last_message: Option<DirectMessage>,\n}\n\n#[derive(Debug)]\npub struct DirectMessageConversationPageResult {\n    pub items: Vec<DirectMessageConversationSummary>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]\npub enum MessagePageDirection {\n    #[default]\n    Backward,\n    Forward,\n}\n\nimpl From<MessagePageDirection> for DirectMessageListDirection {\n    fn from(value: MessagePageDirection) -> Self {\n        match value {\n            MessagePageDirection::Backward => DirectMessageListDirection::Backward,\n            MessagePageDirection::Forward => DirectMessageListDirection::Forward,\n        }\n    }\n}\n\nimpl DirectMessageService {\n    pub fn new(\n        repository: Arc<dyn DirectMessageRepository>,\n        messaging_gateway: Arc<dyn MessagingGateway>,\n        notifier: Option<Arc<dyn DirectMessageNotifier>>,\n    ) -> Self {\n        Self {\n            repository,\n            messaging_gateway,\n            notifier,\n        }\n    }\n\n    pub async fn send_direct_message(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        content: &str,\n        client_message_id: Option<String>,\n    ) -> Result<SendDirectMessageResult, AppError> {\n        let trimmed = content.trim();\n        if trimmed.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Direct message content must not be empty\",\n            ));\n        }\n\n        let messaging_result = self\n            .messaging_gateway\n            .encrypt_and_send(owner_npub, recipient_npub, trimmed)\n            .await?;\n\n        let created_at =\n            millis_to_datetime(messaging_result.created_at_millis).unwrap_or_else(Utc::now);\n\n        let generated_client_id = client_message_id\n            .filter(|id| !id.trim().is_empty())\n            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());\n\n        let new_message = NewDirectMessage {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: recipient_npub.to_string(),\n            sender_npub: owner_npub.to_string(),\n            recipient_npub: recipient_npub.to_string(),\n            event_id: messaging_result.event_id.clone(),\n            client_message_id: Some(generated_client_id.clone()),\n            payload_cipher_base64: messaging_result.ciphertext.clone(),\n            created_at,\n            delivered: messaging_result.delivered,\n            direction: MessageDirection::Outbound,\n        };\n\n        let stored = self\n            .repository\n            .insert_direct_message(&new_message)\n            .await?\n            .with_decrypted_content(trimmed.to_string());\n\n        self.persist_conversation_snapshot(owner_npub, &stored)\n            .await?;\n        self.dispatch_notification(owner_npub, &stored).await;\n\n        Ok(SendDirectMessageResult {\n            event_id: messaging_result.event_id,\n            queued: !messaging_result.delivered,\n            message: stored,\n        })\n    }\n\n    pub async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<&str>,\n        limit: Option<usize>,\n        direction: MessagePageDirection,\n    ) -> Result<DirectMessagePageResult, AppError> {\n        let limit = limit.unwrap_or(50).clamp(1, 200);\n        let parsed_cursor = parse_cursor(cursor)?;\n\n        let raw_page: DirectMessagePageRaw = self\n            .repository\n            .list_direct_messages(\n                owner_npub,\n                conversation_npub,\n                parsed_cursor,\n                limit,\n                direction.into(),\n            )\n            .await?;\n\n        let mut items = Vec::with_capacity(raw_page.items.len());\n        for message in raw_page.items {\n            let plaintext = self\n                .messaging_gateway\n                .decrypt_with_counterparty(\n                    owner_npub,\n                    message.counterparty_npub(),\n                    &message.payload_cipher_base64,\n                )\n                .await?;\n            items.push(message.with_decrypted_content(plaintext));\n        }\n\n        Ok(DirectMessagePageResult {\n            items,\n            next_cursor: raw_page.next_cursor,\n            has_more: raw_page.has_more,\n        })\n    }\n\n    pub async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<&str>,\n        limit: Option<usize>,\n    ) -> Result<DirectMessageConversationPageResult, AppError> {\n        let limit = limit.unwrap_or(50).clamp(1, 200);\n        let parsed_cursor = parse_conversation_cursor(cursor)?;\n        let page: DirectMessageConversationPageRaw = self\n            .repository\n            .list_direct_message_conversations(owner_npub, parsed_cursor, limit)\n            .await?;\n\n        let mut summaries = Vec::with_capacity(page.items.len());\n        for record in page.items {\n            let DirectMessageConversationRecord {\n                conversation_npub,\n                last_message,\n                last_read_at,\n                unread_count,\n                ..\n            } = record;\n\n            let decrypted = if let Some(message) = last_message {\n                let plaintext = self\n                    .messaging_gateway\n                    .decrypt_with_counterparty(\n                        owner_npub,\n                        message.counterparty_npub(),\n                        &message.payload_cipher_base64,\n                    )\n                    .await?;\n                Some(message.with_decrypted_content(plaintext))\n            } else {\n                None\n            };\n\n            summaries.push(DirectMessageConversationSummary {\n                conversation_npub,\n                unread_count: unread_count.max(0) as u64,\n                last_read_at,\n                last_message: decrypted,\n            });\n        }\n\n        Ok(DirectMessageConversationPageResult {\n            items: summaries,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n        })\n    }\n\n    pub async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at_millis: i64,\n    ) -> Result<(), AppError> {\n        let normalized = read_at_millis.max(0);\n        self.repository\n            .mark_conversation_as_read(owner_npub, conversation_npub, normalized)\n            .await\n    }\n\n    pub async fn ingest_incoming_message(\n        &self,\n        owner_npub: &str,\n        sender_npub: &str,\n        ciphertext: &str,\n        event_id: Option<String>,\n        created_at_millis: i64,\n    ) -> Result<Option<DirectMessage>, AppError> {\n        let plaintext = self\n            .messaging_gateway\n            .decrypt_with_counterparty(owner_npub, sender_npub, ciphertext)\n            .await?;\n\n        let created_at = millis_to_datetime(created_at_millis).unwrap_or_else(chrono::Utc::now);\n\n        let new_message = NewDirectMessage {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: sender_npub.to_string(),\n            sender_npub: sender_npub.to_string(),\n            recipient_npub: owner_npub.to_string(),\n            event_id: event_id.clone(),\n            client_message_id: None,\n            payload_cipher_base64: ciphertext.to_string(),\n            created_at,\n            delivered: true,\n            direction: MessageDirection::Inbound,\n        };\n\n        match self.repository.insert_direct_message(&new_message).await {\n            Ok(record) => {\n                let stored = record.with_decrypted_content(plaintext);\n                self.persist_conversation_snapshot(owner_npub, &stored)\n                    .await?;\n                self.dispatch_notification(owner_npub, &stored).await;\n                Ok(Some(stored))\n            }\n            Err(err) => {\n                if is_unique_violation(&err) {\n                    debug!(\n                        event_id = event_id.as_deref().unwrap_or(\"\"),\n                        owner_npub, \"Duplicate direct message detected; skipping insertion\"\n                    );\n                    Ok(None)\n                } else {\n                    Err(err)\n                }\n            }\n        }\n    }\n\n    pub async fn seed_incoming_message_for_e2e(\n        &self,\n        owner_npub: &str,\n        content: &str,\n        created_at_millis: Option<i64>,\n        owner_nsec: Option<&str>,\n    ) -> Result<DirectMessage, AppError> {\n        let owner_keys = if let Some(nsec) = owner_nsec {\n            let secret_key =\n                SecretKey::from_bech32(nsec).map_err(|err| AppError::ValidationError {\n                    kind: ValidationFailureKind::Generic,\n                    message: format!(\"Invalid owner nsec for seeded direct message: {err}\"),\n                })?;\n            Some(Keys::new(secret_key))\n        } else {\n            None\n        };\n\n        let owner_pk = match &owner_keys {\n            Some(keys) => keys.public_key(),\n            None => {\n                PublicKey::from_bech32(owner_npub).map_err(|err| AppError::ValidationError {\n                    kind: ValidationFailureKind::Generic,\n                    message: format!(\"Invalid owner npub {owner_npub}: {err}\"),\n                })?\n            }\n        };\n\n        let sender_keys = Keys::generate();\n        let sender_pk = sender_keys.public_key();\n        let ciphertext =\n            nip04::encrypt(sender_keys.secret_key(), &owner_pk, content).map_err(|err| {\n                AppError::Crypto(format!(\"Failed to encrypt seeded direct message: {err}\"))\n            })?;\n        let sender_npub = sender_pk\n            .to_bech32()\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encode seeded npub: {err}\")))?;\n        let created_at = created_at_millis.unwrap_or_else(|| Utc::now().timestamp_millis());\n\n        if let Some(keys) = owner_keys {\n            let plaintext =\n                nip04::decrypt(keys.secret_key(), &sender_pk, &ciphertext).map_err(|err| {\n                    AppError::Crypto(format!(\n                        \"Failed to decrypt seeded direct message with provided nsec: {err}\"\n                    ))\n                })?;\n\n            let new_message = NewDirectMessage {\n                owner_npub: owner_npub.to_string(),\n                conversation_npub: sender_npub.clone(),\n                sender_npub: sender_npub.clone(),\n                recipient_npub: owner_npub.to_string(),\n                event_id: None,\n                client_message_id: None,\n                payload_cipher_base64: ciphertext.clone(),\n                created_at: millis_to_datetime(created_at).unwrap_or_else(chrono::Utc::now),\n                delivered: true,\n                direction: MessageDirection::Inbound,\n            };\n\n            match self.repository.insert_direct_message(&new_message).await {\n                Ok(record) => {\n                    let stored = record.with_decrypted_content(plaintext);\n                    self.persist_conversation_snapshot(owner_npub, &stored)\n                        .await?;\n                    self.dispatch_notification(owner_npub, &stored).await;\n                    Ok(stored)\n                }\n                Err(err) => {\n                    if is_unique_violation(&err) {\n                        debug!(\n                            owner_npub,\n                            conversation = sender_npub,\n                            \"Duplicate seeded direct message detected; skipping insertion\"\n                        );\n                        Err(AppError::Internal(\n                            \"Failed to persist seeded direct message conversation\".into(),\n                        ))\n                    } else {\n                        Err(err)\n                    }\n                }\n            }\n        } else {\n            self.ingest_incoming_message(owner_npub, &sender_npub, &ciphertext, None, created_at)\n                .await?\n                .ok_or_else(|| {\n                    AppError::Internal(\n                        \"Failed to persist seeded direct message conversation\".into(),\n                    )\n                })\n        }\n    }\n\n    async fn dispatch_notification(&self, owner_npub: &str, message: &DirectMessage) {\n        if let Some(notifier) = &self.notifier {\n            if let Err(err) = notifier.notify(owner_npub, message).await {\n                error!(\n                    error = %err,\n                    owner_npub,\n                    conversation = message.conversation_npub,\n                    \"Failed to emit direct message notification\"\n                );\n            }\n        }\n    }\n\n    async fn persist_conversation_snapshot(\n        &self,\n        owner_npub: &str,\n        message: &DirectMessage,\n    ) -> Result<(), AppError> {\n        self.repository\n            .upsert_conversation_metadata(\n                owner_npub,\n                &message.conversation_npub,\n                message.id,\n                message.created_at_millis(),\n            )\n            .await\n    }\n}\n\nfn parse_cursor(cursor: Option<&str>) -> Result<Option<DirectMessageCursor>, AppError> {\n    match cursor {\n        None => Ok(None),\n        Some(raw) => DirectMessageCursor::parse(raw)\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid cursor format: {raw}\"),\n                )\n            })\n            .map(Some),\n    }\n}\n\nfn parse_conversation_cursor(\n    cursor: Option<&str>,\n) -> Result<Option<DirectMessageConversationCursor>, AppError> {\n    match cursor {\n        None => Ok(None),\n        Some(raw) => DirectMessageConversationCursor::parse(raw)\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Invalid conversation cursor format: {raw}\"),\n                )\n            })\n            .map(Some),\n    }\n}\n\nfn millis_to_datetime(millis: i64) -> Option<DateTime<Utc>> {\n    Utc.timestamp_millis_opt(millis).single()\n}\n\nfn is_unique_violation(error: &AppError) -> bool {\n    match error {\n        AppError::Database(message) => {\n            message.contains(\"UNIQUE constraint failed: direct_messages.owner_npub, event_id\")\n                || message.contains(\n                    \"UNIQUE constraint failed: direct_messages.owner_npub, client_message_id\",\n                )\n        }\n        _ => false,\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":62,"address":[23726800],"length":1,"stats":{"Line":1}},{"line":63,"address":[23768857],"length":1,"stats":{"Line":1}},{"line":64,"address":[23659016],"length":1,"stats":{"Line":1}},{"line":65,"address":[23764943],"length":1,"stats":{"Line":0}},{"line":71,"address":[23733776],"length":1,"stats":{"Line":1}},{"line":83,"address":[23733872],"length":1,"stats":{"Line":1}},{"line":90,"address":[23666754,23666530],"length":1,"stats":{"Line":2}},{"line":91,"address":[23653001],"length":1,"stats":{"Line":1}},{"line":92,"address":[23769738,23770021],"length":1,"stats":{"Line":2}},{"line":93,"address":[23769730],"length":1,"stats":{"Line":1}},{"line":98,"address":[26449786,26450060,26449095,26449273,26451433,26449632,26449358],"length":1,"stats":{"Line":7}},{"line":100,"address":[23659982],"length":1,"stats":{"Line":1}},{"line":101,"address":[11634252],"length":1,"stats":{"Line":4}},{"line":103,"address":[23728725,23728555],"length":1,"stats":{"Line":2}},{"line":106,"address":[23770807],"length":1,"stats":{"Line":1}},{"line":107,"address":[23870848,23870857],"length":1,"stats":{"Line":2}},{"line":108,"address":[23776112,23776125],"length":1,"stats":{"Line":2}},{"line":111,"address":[23766992],"length":1,"stats":{"Line":1}},{"line":112,"address":[23867446],"length":1,"stats":{"Line":1}},{"line":113,"address":[23654450],"length":1,"stats":{"Line":1}},{"line":114,"address":[23668286],"length":1,"stats":{"Line":1}},{"line":115,"address":[23668362],"length":1,"stats":{"Line":1}},{"line":116,"address":[23654752,23654677],"length":1,"stats":{"Line":2}},{"line":117,"address":[23867856],"length":1,"stats":{"Line":1}},{"line":119,"address":[23736379],"length":1,"stats":{"Line":1}},{"line":123,"address":[23773448,23773909,23774024,23773650,23774250,23774328,23773553],"length":1,"stats":{"Line":6}},{"line":125,"address":[26451242],"length":1,"stats":{"Line":1}},{"line":126,"address":[23662698,23662259,23659651,23662115,23662168,23662407],"length":1,"stats":{"Line":3}},{"line":127,"address":[11737334],"length":1,"stats":{"Line":2}},{"line":129,"address":[23656614,23656760,23656222,23656488,23656098],"length":1,"stats":{"Line":4}},{"line":130,"address":[23663164,23663496,23663039,23659672,23663320,23662979],"length":1,"stats":{"Line":3}},{"line":131,"address":[11037832],"length":1,"stats":{"Line":2}},{"line":133,"address":[23770190],"length":1,"stats":{"Line":1}},{"line":134,"address":[23738870],"length":1,"stats":{"Line":1}},{"line":135,"address":[23774043],"length":1,"stats":{"Line":1}},{"line":136,"address":[23775711],"length":1,"stats":{"Line":1}},{"line":140,"address":[26453760],"length":1,"stats":{"Line":1}},{"line":148,"address":[23771107,23771250],"length":1,"stats":{"Line":2}},{"line":149,"address":[23740185,23740964,23740355,23740127],"length":1,"stats":{"Line":2}},{"line":151,"address":[23740748,23740313,23741133,23741269,23741555,23740873,23741907],"length":1,"stats":{"Line":5}},{"line":154,"address":[17913320],"length":1,"stats":{"Line":1}},{"line":156,"address":[17913352],"length":1,"stats":{"Line":1}},{"line":158,"address":[23775732],"length":1,"stats":{"Line":1}},{"line":160,"address":[23658457,23659369,23659987,23659677,23659495,23659310],"length":1,"stats":{"Line":3}},{"line":162,"address":[26455777,26455938],"length":1,"stats":{"Line":2}},{"line":163,"address":[17915489,17914584,17914462,17915545,17915613],"length":1,"stats":{"Line":5}},{"line":164,"address":[26456336,26457656,26456524,26456826,26457717,26457117],"length":1,"stats":{"Line":5}},{"line":167,"address":[23661761],"length":1,"stats":{"Line":1}},{"line":168,"address":[23743307],"length":1,"stats":{"Line":1}},{"line":169,"address":[26457584],"length":1,"stats":{"Line":1}},{"line":171,"address":[11743954],"length":1,"stats":{"Line":4}},{"line":172,"address":[23667639,23667923],"length":1,"stats":{"Line":2}},{"line":175,"address":[23778166],"length":1,"stats":{"Line":1}},{"line":176,"address":[17915710],"length":1,"stats":{"Line":1}},{"line":177,"address":[23675219],"length":1,"stats":{"Line":1}},{"line":178,"address":[17915816],"length":1,"stats":{"Line":1}},{"line":182,"address":[23662288],"length":1,"stats":{"Line":1}},{"line":188,"address":[23737280,23737423],"length":1,"stats":{"Line":2}},{"line":189,"address":[23776218,23775654,23775846,23775596],"length":1,"stats":{"Line":2}},{"line":190,"address":[23677862,23677227,23677579,23676860,23677136,23677443,23678214],"length":1,"stats":{"Line":5}},{"line":192,"address":[23670092],"length":1,"stats":{"Line":1}},{"line":193,"address":[23775446,23776269,23776187,23776128,23776758,23776451],"length":1,"stats":{"Line":3}},{"line":195,"address":[23780660,23780832],"length":1,"stats":{"Line":2}},{"line":196,"address":[23747422,23747484,23745867,23745745],"length":1,"stats":{"Line":4}},{"line":198,"address":[17920308],"length":1,"stats":{"Line":1}},{"line":199,"address":[23784362],"length":1,"stats":{"Line":1}},{"line":200,"address":[23778834],"length":1,"stats":{"Line":1}},{"line":201,"address":[23782800],"length":1,"stats":{"Line":1}},{"line":205,"address":[26461807,26462181,26462306],"length":1,"stats":{"Line":2}},{"line":206,"address":[17921236,17919107,17921171,17919415,17920931,17918931],"length":1,"stats":{"Line":5}},{"line":209,"address":[23673505],"length":1,"stats":{"Line":1}},{"line":210,"address":[23779451],"length":1,"stats":{"Line":1}},{"line":211,"address":[23879867],"length":1,"stats":{"Line":1}},{"line":213,"address":[11114510],"length":1,"stats":{"Line":4}},{"line":214,"address":[26460572,26460822],"length":1,"stats":{"Line":2}},{"line":216,"address":[23680427],"length":1,"stats":{"Line":0}},{"line":219,"address":[23672302,23672027],"length":1,"stats":{"Line":2}},{"line":220,"address":[23665269],"length":1,"stats":{"Line":1}},{"line":221,"address":[17919615],"length":1,"stats":{"Line":1}},{"line":222,"address":[23665393],"length":1,"stats":{"Line":1}},{"line":223,"address":[23746936],"length":1,"stats":{"Line":1}},{"line":227,"address":[26461972],"length":1,"stats":{"Line":1}},{"line":228,"address":[23879313],"length":1,"stats":{"Line":1}},{"line":229,"address":[23879366],"length":1,"stats":{"Line":1}},{"line":230,"address":[23666341],"length":1,"stats":{"Line":1}},{"line":234,"address":[26463120],"length":1,"stats":{"Line":1}},{"line":240,"address":[23667876,23667993],"length":1,"stats":{"Line":2}},{"line":241,"address":[26463676,26463569,26463845],"length":1,"stats":{"Line":3}},{"line":243,"address":[11761972],"length":1,"stats":{"Line":3}},{"line":246,"address":[26464016],"length":1,"stats":{"Line":1}},{"line":254,"address":[23787733,23787445,23788081,23787534,23787173,23787859,23789223],"length":1,"stats":{"Line":5}},{"line":256,"address":[23785759],"length":1,"stats":{"Line":1}},{"line":257,"address":[23781665,23781972,23782038,23781907,23782197,23782449],"length":1,"stats":{"Line":3}},{"line":259,"address":[23669708,23669878],"length":1,"stats":{"Line":2}},{"line":262,"address":[23882984],"length":1,"stats":{"Line":1}},{"line":263,"address":[23683707],"length":1,"stats":{"Line":1}},{"line":264,"address":[23676810],"length":1,"stats":{"Line":1}},{"line":265,"address":[17924406],"length":1,"stats":{"Line":1}},{"line":266,"address":[23676962],"length":1,"stats":{"Line":1}},{"line":268,"address":[23883343],"length":1,"stats":{"Line":1}},{"line":274,"address":[17925051,17924945,17923286,17925285],"length":1,"stats":{"Line":2}},{"line":275,"address":[23752841],"length":1,"stats":{"Line":1}},{"line":276,"address":[23784078],"length":1,"stats":{"Line":1}},{"line":277,"address":[23680961,23678459,23678335,23681107,23680835],"length":1,"stats":{"Line":4}},{"line":278,"address":[11848971],"length":1,"stats":{"Line":3}},{"line":279,"address":[23781728,23787061,23786933,23787317],"length":1,"stats":{"Line":2}},{"line":280,"address":[23787505],"length":1,"stats":{"Line":1}},{"line":282,"address":[23784165],"length":1,"stats":{"Line":1}},{"line":283,"address":[23746476,23746388,23746114,23747048],"length":1,"stats":{"Line":3}},{"line":284,"address":[23933183,23791473,23790756,23791895,23790174,23933049,23790228],"length":1,"stats":{"Line":4}},{"line":288,"address":[23785116],"length":1,"stats":{"Line":1}},{"line":290,"address":[23678586],"length":1,"stats":{"Line":0}},{"line":296,"address":[23688768],"length":1,"stats":{"Line":0}},{"line":303,"address":[23757028,23757168,23757249],"length":1,"stats":{"Line":0}},{"line":304,"address":[26480887,26480656,26480831,26471995,26471648,26471753],"length":1,"stats":{"Line":0}},{"line":306,"address":[23698133],"length":1,"stats":{"Line":0}},{"line":307,"address":[23765898,23765957],"length":1,"stats":{"Line":0}},{"line":309,"address":[23757633,23757444],"length":1,"stats":{"Line":0}},{"line":311,"address":[23675699],"length":1,"stats":{"Line":0}},{"line":314,"address":[23750785],"length":1,"stats":{"Line":0}},{"line":315,"address":[23757895,23758341],"length":1,"stats":{"Line":0}},{"line":317,"address":[23751052,23751329,23750924,23751385,23759216,23759504,23759448],"length":1,"stats":{"Line":0}},{"line":318,"address":[23802939],"length":1,"stats":{"Line":0}},{"line":319,"address":[17938960,17939030],"length":1,"stats":{"Line":0}},{"line":324,"address":[26472715],"length":1,"stats":{"Line":0}},{"line":325,"address":[23795111],"length":1,"stats":{"Line":0}},{"line":326,"address":[23690988,23693442,23698704,23690666],"length":1,"stats":{"Line":0}},{"line":328,"address":[23684960],"length":1,"stats":{"Line":0}},{"line":330,"address":[17931447,17931620,17931862,17933958],"length":1,"stats":{"Line":0}},{"line":332,"address":[23803409,23803392,23795798],"length":1,"stats":{"Line":0}},{"line":333,"address":[23759876,23752246,23752073,23759872],"length":1,"stats":{"Line":0}},{"line":335,"address":[23684446],"length":1,"stats":{"Line":0}},{"line":336,"address":[23685312,23677914,23677730,23678208,23679314],"length":1,"stats":{"Line":0}},{"line":338,"address":[26481616],"length":1,"stats":{"Line":0}},{"line":344,"address":[23790826],"length":1,"stats":{"Line":0}},{"line":345,"address":[23759813],"length":1,"stats":{"Line":0}},{"line":346,"address":[23791072],"length":1,"stats":{"Line":0}},{"line":347,"address":[23759963],"length":1,"stats":{"Line":0}},{"line":350,"address":[23791249],"length":1,"stats":{"Line":0}},{"line":351,"address":[23753223,23753283],"length":1,"stats":{"Line":0}},{"line":356,"address":[23753708,23753602,23750164,23754337],"length":1,"stats":{"Line":0}},{"line":357,"address":[23761605],"length":1,"stats":{"Line":0}},{"line":358,"address":[23893210],"length":1,"stats":{"Line":0}},{"line":359,"address":[23893511,23895916,23895790,23893387,23896062],"length":1,"stats":{"Line":0}},{"line":360,"address":[23689726,23682377,23689391,23687256,23689550,23687196],"length":1,"stats":{"Line":0}},{"line":361,"address":[23696656,23689374,23696784,23696962],"length":1,"stats":{"Line":0}},{"line":362,"address":[23801678],"length":1,"stats":{"Line":0}},{"line":364,"address":[17934529],"length":1,"stats":{"Line":0}},{"line":365,"address":[23755240,23755152,23754878,23757101],"length":1,"stats":{"Line":0}},{"line":366,"address":[23694464,23829017,23694410,23829151,23694984],"length":1,"stats":{"Line":0}},{"line":371,"address":[23763925],"length":1,"stats":{"Line":0}},{"line":372,"address":[23681176],"length":1,"stats":{"Line":0}},{"line":375,"address":[23793270],"length":1,"stats":{"Line":0}},{"line":380,"address":[23765514,23759283,23761104,23760912,23765265,23765345,23765764],"length":1,"stats":{"Line":0}},{"line":381,"address":[11868810],"length":1,"stats":{"Line":0}},{"line":382,"address":[23803760],"length":1,"stats":{"Line":0}},{"line":383,"address":[23803814],"length":1,"stats":{"Line":0}},{"line":384,"address":[23760078],"length":1,"stats":{"Line":0}},{"line":390,"address":[23692375,23692352,23692400,23692951,23695263,23692610,23692431,23692701],"length":1,"stats":{"Line":4}},{"line":391,"address":[17940088,17940216,17940181],"length":1,"stats":{"Line":3}},{"line":392,"address":[11748388],"length":1,"stats":{"Line":3}},{"line":393,"address":[23934175,23934041,23804925,23805426,23804824],"length":1,"stats":{"Line":0}},{"line":403,"address":[23702256],"length":1,"stats":{"Line":1}},{"line":408,"address":[23689016,23688745,23689262,23689081],"length":1,"stats":{"Line":4}},{"line":411,"address":[23695680],"length":1,"stats":{"Line":1}},{"line":412,"address":[23807233],"length":1,"stats":{"Line":1}},{"line":413,"address":[23770477],"length":1,"stats":{"Line":1}},{"line":415,"address":[11868612],"length":1,"stats":{"Line":3}},{"line":419,"address":[23807728],"length":1,"stats":{"Line":1}},{"line":420,"address":[23770986],"length":1,"stats":{"Line":1}},{"line":421,"address":[23771016],"length":1,"stats":{"Line":1}},{"line":422,"address":[23696336],"length":1,"stats":{"Line":0}},{"line":423,"address":[23802352],"length":1,"stats":{"Line":0}},{"line":424,"address":[23808076],"length":1,"stats":{"Line":0}},{"line":425,"address":[23807958],"length":1,"stats":{"Line":0}},{"line":426,"address":[17943979],"length":1,"stats":{"Line":0}},{"line":433,"address":[23808112],"length":1,"stats":{"Line":1}},{"line":436,"address":[23689851],"length":1,"stats":{"Line":1}},{"line":437,"address":[23808170],"length":1,"stats":{"Line":1}},{"line":438,"address":[23696708],"length":1,"stats":{"Line":0}},{"line":439,"address":[23806672],"length":1,"stats":{"Line":0}},{"line":440,"address":[23696956],"length":1,"stats":{"Line":0}},{"line":441,"address":[23764646],"length":1,"stats":{"Line":0}},{"line":442,"address":[23771579],"length":1,"stats":{"Line":0}},{"line":449,"address":[23903280],"length":1,"stats":{"Line":1}},{"line":450,"address":[23808517],"length":1,"stats":{"Line":1}},{"line":453,"address":[17944576],"length":1,"stats":{"Line":1}},{"line":454,"address":[23697070],"length":1,"stats":{"Line":1}},{"line":455,"address":[23808588],"length":1,"stats":{"Line":1}},{"line":456,"address":[17944617,17944700],"length":1,"stats":{"Line":2}},{"line":457,"address":[23697143],"length":1,"stats":{"Line":0}},{"line":461,"address":[23903420],"length":1,"stats":{"Line":0}}],"covered":130,"coverable":192},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","core.rs"],"content":"use super::distribution::distribute_hybrid;\nuse super::factory::build_deletion_event;\nuse crate::application::ports::event_gateway::EventGateway;\nuse crate::application::ports::repositories::EventRepository;\nuse crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::application::services::{SubscriptionRecord, SubscriptionStateStore};\nuse crate::application::shared::mappers::{\n    domain_event_from_event, dto_to_profile_metadata, parse_event_id, parse_event_ids,\n    parse_optional_event_id,\n};\nuse crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::event_gateway::{ReactionValue, TopicContent};\nuse crate::domain::value_objects::{EventId, TopicId};\nuse crate::infrastructure::crypto::SignatureService;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::presentation::dto::event::NostrMetadataDto;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\npub struct EventService {\n    pub(crate) repository: Arc<dyn EventRepository>,\n    pub(crate) signature_service: Arc<dyn SignatureService>,\n    pub(crate) distributor: Arc<dyn EventDistributor>,\n    pub(crate) event_gateway: Arc<dyn EventGateway>,\n    pub(crate) subscription_state: Arc<dyn SubscriptionStateStore>,\n    pub(crate) subscription_invoker: Option<Arc<dyn SubscriptionInvoker>>,\n}\n\nimpl EventService {\n    pub fn new(\n        repository: Arc<dyn EventRepository>,\n        signature_service: Arc<dyn SignatureService>,\n        distributor: Arc<dyn EventDistributor>,\n        event_gateway: Arc<dyn EventGateway>,\n        subscription_state: Arc<dyn SubscriptionStateStore>,\n    ) -> Self {\n        Self {\n            repository,\n            signature_service,\n            distributor,\n            event_gateway,\n            subscription_state,\n            subscription_invoker: None,\n        }\n    }\n\n    /// Attach the subscription invoker used to execute subscriptions.\n    pub fn set_subscription_invoker(&mut self, invoker: Arc<dyn SubscriptionInvoker>) {\n        self.subscription_invoker = Some(invoker);\n    }\n\n    pub(crate) fn subscription_invoker(&self) -> Result<&Arc<dyn SubscriptionInvoker>, AppError> {\n        self.subscription_invoker\n            .as_ref()\n            .ok_or_else(|| AppError::ConfigurationError(\"Subscription invoker not set\".to_string()))\n    }\n\n    pub async fn create_event(\n        &self,\n        kind: u32,\n        content: String,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<Event, AppError> {\n        let mut event = Event::new(kind, content, pubkey);\n\n        self.signature_service\n            .sign_event(&mut event, private_key)\n            .await?;\n\n        self.repository.create_event(&event).await?;\n        distribute_hybrid(&self.distributor, &event).await?;\n\n        Ok(event)\n    }\n\n    pub async fn process_received_event(&self, event: Event) -> Result<(), AppError> {\n        if !self.signature_service.verify_event(&event).await? {\n            return Err(\"Invalid event signature\".into());\n        }\n\n        self.repository.create_event(&event).await?;\n\n        if matches!(\n            EventKind::from_u32(event.kind),\n            Some(EventKind::TextNote)\n                | Some(EventKind::Metadata)\n                | Some(EventKind::Reaction)\n                | Some(EventKind::Repost)\n        ) {\n            let domain_event = domain_event_from_event(&event)?;\n            self.event_gateway\n                .handle_incoming_event(domain_event)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        self.repository.get_event(id).await\n    }\n\n    pub async fn get_events_by_kind(\n        &self,\n        kind: u32,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_kind(kind, limit).await\n    }\n\n    pub async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_author(pubkey, limit).await\n    }\n\n    pub async fn delete_event(\n        &self,\n        id: &str,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<(), AppError> {\n        let mut deletion_event = build_deletion_event(id, pubkey);\n\n        self.signature_service\n            .sign_event(&mut deletion_event, private_key)\n            .await?;\n        self.repository.create_event(&deletion_event).await?;\n        distribute_hybrid(&self.distributor, &deletion_event).await?;\n\n        self.repository.delete_event(id).await\n    }\n\n    pub async fn sync_pending_events(&self) -> Result<u32, AppError> {\n        let unsync_events = self.repository.get_unsync_events().await?;\n        let mut synced_count = 0;\n\n        for event in unsync_events {\n            distribute_hybrid(&self.distributor, &event).await?;\n            self.repository.mark_event_synced(&event.id).await?;\n            synced_count += 1;\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[async_trait]\npub trait EventServiceTrait: Send + Sync {\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError>;\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError>;\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError>;\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError>;\n    async fn get_public_key(&self) -> Result<Option<String>, AppError>;\n    async fn boost_post(&self, event_id: &str) -> Result<EventId, AppError>;\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[async_trait]\nimpl EventServiceTrait for EventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\n        self.event_gateway.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        let topic = TopicId::new(topic_id.to_string()).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic ID: {err}\"),\n            )\n        })?;\n        let topic_content = TopicContent::parse(content).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic content: {err}\"),\n            )\n        })?;\n        let reply_to_id = parse_optional_event_id(reply_to)?;\n        self.event_gateway\n            .publish_topic_post(&topic, &topic_content, reply_to_id.as_ref(), scope, epoch)\n            .await\n    }\n\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError> {\n        let event_id = parse_event_id(event_id)?;\n        let reaction_value = ReactionValue::parse(reaction).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid reaction value: {err}\"),\n            )\n        })?;\n        self.event_gateway\n            .send_reaction(&event_id, &reaction_value)\n            .await\n    }\n\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError> {\n        let profile = dto_to_profile_metadata(metadata)?;\n        self.event_gateway.update_profile_metadata(&profile).await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_topic_internal(self, topic_id).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_user_internal(self, pubkey).await\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        self.event_gateway\n            .get_public_key()\n            .await\n            .map(|key| key.map(|pk| pk.as_hex().to_string()))\n    }\n\n    async fn boost_post(&self, event_id: &str) -> Result<EventId, AppError> {\n        let target_id = parse_event_id(event_id)?;\n        self.event_gateway.publish_repost(&target_id).await\n    }\n\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        if event_ids.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"No event IDs provided\",\n            ));\n        }\n\n        let parsed_ids = parse_event_ids(&event_ids)?;\n        let deletion_event_id = self\n            .event_gateway\n            .delete_events(&parsed_ids, reason.as_deref())\n            .await?;\n\n        for event_id in event_ids {\n            self.repository.delete_event(&event_id).await?;\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        self.event_gateway.disconnect().await\n    }\n\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        if topic_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Topic ID is required\",\n            ));\n        }\n        let topic = TopicId::new(topic_id.to_string()).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid topic ID: {err}\"),\n            )\n        })?;\n        self.event_gateway\n            .set_default_topics(std::slice::from_ref(&topic))\n            .await?;\n        Ok(())\n    }\n\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        super::subscription::list_subscriptions_internal(self).await\n    }\n}\n\n#[async_trait]\nimpl super::super::sync_service::SyncParticipant for EventService {\n    async fn sync_pending(&self) -> Result<u32, AppError> {\n        self.sync_pending_events().await\n    }\n}\n","traces":[{"line":31,"address":[12569296],"length":1,"stats":{"Line":0}},{"line":49,"address":[12637304,12637232],"length":1,"stats":{"Line":0}},{"line":50,"address":[12672455,12672376],"length":1,"stats":{"Line":0}},{"line":53,"address":[12555840],"length":1,"stats":{"Line":0}},{"line":54,"address":[12674160],"length":1,"stats":{"Line":0}},{"line":56,"address":[12637454,12637440],"length":1,"stats":{"Line":0}},{"line":59,"address":[12562800],"length":1,"stats":{"Line":0}},{"line":66,"address":[12563188],"length":1,"stats":{"Line":0}},{"line":68,"address":[26488333,26488687,26488824,26488972,26488209,26488561,26488394],"length":1,"stats":{"Line":0}},{"line":69,"address":[12563485],"length":1,"stats":{"Line":0}},{"line":70,"address":[12669900,12669567,12669504,12669703,12669180,12669451],"length":1,"stats":{"Line":0}},{"line":72,"address":[12631755,12632020,12631089,12632345,12632517,12631859],"length":1,"stats":{"Line":0}},{"line":73,"address":[26489937,26488146,26489275,26489404,26489475,26489802],"length":1,"stats":{"Line":0}},{"line":75,"address":[12674855],"length":1,"stats":{"Line":0}},{"line":78,"address":[12559704,12558432,12558467,12558559,12559048,12558742,12558512,12561236],"length":1,"stats":{"Line":0}},{"line":79,"address":[12633285,12633486,12633672,12634291,12633364],"length":1,"stats":{"Line":0}},{"line":80,"address":[26490887,26490959],"length":1,"stats":{"Line":0}},{"line":83,"address":[12573201,12573782,12573314,12573473,12574613,12572553],"length":1,"stats":{"Line":0}},{"line":85,"address":[12677789,12676805,12676788],"length":1,"stats":{"Line":0}},{"line":86,"address":[12773061,12773226,12773187],"length":1,"stats":{"Line":0}},{"line":92,"address":[12773323,12773399,12773903,12773593],"length":1,"stats":{"Line":0}},{"line":93,"address":[12679254,12679066,12678766,12679007,12679490,12679631,12679370],"length":1,"stats":{"Line":0}},{"line":94,"address":[12677294],"length":1,"stats":{"Line":0}},{"line":95,"address":[12574618,12574560,12574774,12574914,12574507,12572574],"length":1,"stats":{"Line":0}},{"line":98,"address":[12566998],"length":1,"stats":{"Line":0}},{"line":101,"address":[12679682,12679712,12680073,12679913,12679664,12680342,12679747,12679873],"length":1,"stats":{"Line":0}},{"line":102,"address":[12568348,12568601,12568473,12568396],"length":1,"stats":{"Line":0}},{"line":105,"address":[12678704],"length":1,"stats":{"Line":0}},{"line":110,"address":[12643758,12643882,12643806,12644011],"length":1,"stats":{"Line":0}},{"line":113,"address":[12569520],"length":1,"stats":{"Line":0}},{"line":118,"address":[12569778,12569988,12569860,12569730],"length":1,"stats":{"Line":0}},{"line":121,"address":[12638048],"length":1,"stats":{"Line":0}},{"line":127,"address":[12680439],"length":1,"stats":{"Line":0}},{"line":129,"address":[12578442,12578157,12578605,12578289,12577757,12577889,12577972],"length":1,"stats":{"Line":0}},{"line":130,"address":[12645637],"length":1,"stats":{"Line":0}},{"line":131,"address":[26495546,26495745,26495608,26495195,26495942,26495485],"length":1,"stats":{"Line":0}},{"line":132,"address":[12564721,12563892,12564617,12564882,12565197,12565370],"length":1,"stats":{"Line":0}},{"line":133,"address":[12572159,12570697,12572468,12572691,12571942,12572063],"length":1,"stats":{"Line":0}},{"line":135,"address":[12682222,12684067,12683939,12684257],"length":1,"stats":{"Line":0}},{"line":138,"address":[12566280,12566788,12566351,12566272,12566304,12566492,12566592,12567513],"length":1,"stats":{"Line":0}},{"line":139,"address":[12683460,12683162,12683914,12683298,12684131,12683090],"length":1,"stats":{"Line":0}},{"line":140,"address":[12683819],"length":1,"stats":{"Line":0}},{"line":142,"address":[12685485,12686432,12685695,12686490],"length":1,"stats":{"Line":0}},{"line":143,"address":[11685771],"length":1,"stats":{"Line":0}},{"line":144,"address":[12684588,12685362,12685666,12684502,12685500,12683204,12684196],"length":1,"stats":{"Line":0}},{"line":145,"address":[12686368,12686202,12686325],"length":1,"stats":{"Line":0}},{"line":148,"address":[20343256],"length":1,"stats":{"Line":0}},{"line":182,"address":[26673713,26673585,26673438,26673566,26673408,26673369,26673501],"length":1,"stats":{"Line":0}},{"line":183,"address":[12798745],"length":1,"stats":{"Line":0}},{"line":186,"address":[12908691,12908850,12908939,12908736,12908771,12909207,12909465,12908962],"length":1,"stats":{"Line":0}},{"line":187,"address":[11822772],"length":1,"stats":{"Line":0}},{"line":190,"address":[26676859,26674932,26674688,26674832,26676528,26674784,26675052],"length":1,"stats":{"Line":0}},{"line":198,"address":[12800703,12801700,12802080,12802299,12800412],"length":1,"stats":{"Line":0}},{"line":199,"address":[12809231],"length":1,"stats":{"Line":0}},{"line":200,"address":[12913605],"length":1,"stats":{"Line":0}},{"line":201,"address":[26676906,26676965],"length":1,"stats":{"Line":0}},{"line":204,"address":[12801698,12802555,12802336,12801016,12800617,12800788],"length":1,"stats":{"Line":0}},{"line":205,"address":[20570703],"length":1,"stats":{"Line":0}},{"line":206,"address":[20570549],"length":1,"stats":{"Line":0}},{"line":207,"address":[26677146,26677205],"length":1,"stats":{"Line":0}},{"line":210,"address":[12910814,12910957,12911112],"length":1,"stats":{"Line":0}},{"line":211,"address":[12869036,12869332,12869653,12869401],"length":1,"stats":{"Line":0}},{"line":212,"address":[12869220],"length":1,"stats":{"Line":0}},{"line":213,"address":[11936103],"length":1,"stats":{"Line":0}},{"line":216,"address":[12802633,12802704,12802739,12802818,12803795,12804093,12802930],"length":1,"stats":{"Line":0}},{"line":217,"address":[12913067,12912891,12913646],"length":1,"stats":{"Line":0}},{"line":218,"address":[13009629,13009850,13010400,13009464,13010619],"length":1,"stats":{"Line":0}},{"line":219,"address":[20572479],"length":1,"stats":{"Line":0}},{"line":220,"address":[12913989],"length":1,"stats":{"Line":0}},{"line":221,"address":[12804138,12804197],"length":1,"stats":{"Line":0}},{"line":224,"address":[13010217,13009958,13009774,13010017],"length":1,"stats":{"Line":0}},{"line":225,"address":[13009942],"length":1,"stats":{"Line":0}},{"line":226,"address":[12915331,12915481,12914349,12915202,12915246],"length":1,"stats":{"Line":0}},{"line":229,"address":[12804464,12804383,12805789,12804502,12804742,12804629,12805372],"length":1,"stats":{"Line":0}},{"line":230,"address":[12873170,12872715,12872894],"length":1,"stats":{"Line":0}},{"line":231,"address":[12872464,12872866,12873327,12873040],"length":1,"stats":{"Line":0}},{"line":234,"address":[12873928,12874425,12873763,12873845,12874164,12873951,12873728,12873679],"length":1,"stats":{"Line":0}},{"line":235,"address":[11901271],"length":1,"stats":{"Line":0}},{"line":238,"address":[12918341,12918660,12918921,12918447,12918424,12918259,12918175,12918224],"length":1,"stats":{"Line":0}},{"line":239,"address":[20575056,20575241,20575380],"length":1,"stats":{"Line":0}},{"line":242,"address":[12800739,12800818,12800930,12801445,12800704,12800665,12800907,12801161],"length":1,"stats":{"Line":0}},{"line":243,"address":[12801294,12801124,12801392,12801030],"length":1,"stats":{"Line":0}},{"line":245,"address":[11921492],"length":1,"stats":{"Line":0}},{"line":246,"address":[12918144,12918124,12918171,12918112],"length":1,"stats":{"Line":0}},{"line":249,"address":[12919418,12918498,12918610,12918323,12918419,12919140,12918384],"length":1,"stats":{"Line":0}},{"line":250,"address":[12808859,12809033,12809279],"length":1,"stats":{"Line":0}},{"line":251,"address":[12914589,12915236,12915093,12914925],"length":1,"stats":{"Line":0}},{"line":254,"address":[11813676,11813882],"length":1,"stats":{"Line":0}},{"line":259,"address":[12920077,12920162],"length":1,"stats":{"Line":0}},{"line":260,"address":[12885095,12885805],"length":1,"stats":{"Line":0}},{"line":261,"address":[12921855],"length":1,"stats":{"Line":0}},{"line":266,"address":[13017329,13016600,13016885,13016713],"length":1,"stats":{"Line":0}},{"line":267,"address":[12810920,12811604,12811353,12810551,12810985,12811237,12811799],"length":1,"stats":{"Line":0}},{"line":269,"address":[12878570],"length":1,"stats":{"Line":0}},{"line":270,"address":[11923039],"length":1,"stats":{"Line":0}},{"line":272,"address":[12812427,12811479,12811692,12812359],"length":1,"stats":{"Line":0}},{"line":273,"address":[26687112,26686772,26686169,26686475,26686536,26684353],"length":1,"stats":{"Line":0}},{"line":276,"address":[13018787],"length":1,"stats":{"Line":0}},{"line":279,"address":[12919337,12919376,12919411,12919490,12919602,12919834,12920092,12919579],"length":1,"stats":{"Line":0}},{"line":280,"address":[12806813,12806998,12807162],"length":1,"stats":{"Line":0}},{"line":283,"address":[12807427,12807526,12807738,12807488,12807620,12808521,12808952,12808983],"length":1,"stats":{"Line":0}},{"line":284,"address":[13020924],"length":1,"stats":{"Line":0}},{"line":285,"address":[26689467,26688952],"length":1,"stats":{"Line":0}},{"line":286,"address":[12924564],"length":1,"stats":{"Line":0}},{"line":290,"address":[13021046,13021297,13021557,13022064,13022283,13020961],"length":1,"stats":{"Line":0}},{"line":291,"address":[26690127],"length":1,"stats":{"Line":0}},{"line":292,"address":[12927301],"length":1,"stats":{"Line":0}},{"line":293,"address":[12925658,12925717],"length":1,"stats":{"Line":0}},{"line":296,"address":[12921596,12920853,12921146,12921361,12921465,12921087],"length":1,"stats":{"Line":0}},{"line":297,"address":[12921034],"length":1,"stats":{"Line":0}},{"line":298,"address":[11901910],"length":1,"stats":{"Line":0}},{"line":299,"address":[20583789],"length":1,"stats":{"Line":0}},{"line":302,"address":[20584492,20584307,20584272,20584712,20584233,20584469,20584970,20584386],"length":1,"stats":{"Line":0}},{"line":303,"address":[12816221,12816408,12816552],"length":1,"stats":{"Line":0}},{"line":309,"address":[12824063,12824528,12823957,12824267,12823791,12823840,12824040,12823875],"length":1,"stats":{"Line":0}},{"line":310,"address":[11902647],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":116},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","distribution.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::p2p::DistributionStrategy;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub(crate) async fn distribute_hybrid(\n    distributor: &Arc<dyn EventDistributor>,\n    event: &Event,\n) -> Result<(), AppError> {\n    distributor\n        .distribute(event, DistributionStrategy::Hybrid)\n        .await?;\n    Ok(())\n}\n","traces":[{"line":7,"address":[13592976],"length":1,"stats":{"Line":0}},{"line":11,"address":[13592101,13592175,13591709,13591501,13591875,13591642,13591983],"length":1,"stats":{"Line":0}},{"line":12,"address":[13556514],"length":1,"stats":{"Line":0}},{"line":13,"address":[11605174],"length":1,"stats":{"Line":0}},{"line":14,"address":[13489179],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","factory.rs"],"content":"pub(crate) use crate::application::shared::nostr::build_deletion_event;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","mod.rs"],"content":"pub mod core;\npub mod distribution;\npub mod factory;\npub mod subscription;\n\npub use core::{EventService, EventServiceTrait};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","subscription.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::Utc;\nuse tracing::warn;\n\nuse super::EventService;\n\nimpl EventService {\n    pub async fn handle_network_disconnected(&self) -> Result<(), AppError> {\n        self.subscription_state.mark_all_need_resync().await\n    }\n\n    pub async fn handle_network_connected(&self) -> Result<(), AppError> {\n        self.restore_subscriptions().await\n    }\n\n    async fn restore_subscriptions(&self) -> Result<(), AppError> {\n        let invoker = self.subscription_invoker()?;\n\n        let records = self.subscription_state.list_for_restore().await?;\n        let mut failure_message: Option<String> = None;\n\n        for record in records {\n            let target = record.target.clone();\n            let since = record.since_timestamp();\n            let target_label = match &target {\n                SubscriptionTarget::Topic(t) => format!(\"topic:{t}\"),\n                SubscriptionTarget::User(u) => format!(\"user:{u}\"),\n            };\n\n            let result = match &target {\n                SubscriptionTarget::Topic(topic_id) => {\n                    invoker.subscribe_topic(topic_id, since).await\n                }\n                SubscriptionTarget::User(pubkey) => invoker.subscribe_user(pubkey, since).await,\n            };\n\n            match result {\n                Ok(_) => {\n                    self.subscription_state\n                        .mark_subscribed(&target, Utc::now().timestamp())\n                        .await?;\n                }\n                Err(err) => {\n                    let err_message = err.to_string();\n                    if let Err(store_err) = self\n                        .subscription_state\n                        .mark_failure(&target, &err_message)\n                        .await\n                    {\n                        warn!(\n                            \"Failed to record subscription failure for {}: {}\",\n                            target_label, store_err\n                        );\n                    }\n                    warn!(\n                        \"Failed to restore subscription for {}: {}\",\n                        target_label, err_message\n                    );\n                    failure_message = Some(err_message);\n                }\n            }\n        }\n\n        if let Some(message) = failure_message {\n            Err(AppError::NostrError(message))\n        } else {\n            Ok(())\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_topic_internal(\n    service: &EventService,\n    topic_id: &str,\n) -> Result<(), AppError> {\n    if topic_id.is_empty() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Topic ID is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::Topic(topic_id.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_topic(topic_id, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for topic {}: {}\",\n                    topic_id, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_user_internal(\n    service: &EventService,\n    pubkey: &str,\n) -> Result<(), AppError> {\n    if pubkey.is_empty() {\n        return Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"Public key is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::User(pubkey.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_user(pubkey, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for user {}: {}\",\n                    pubkey, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn list_subscriptions_internal(\n    service: &EventService,\n) -> Result<Vec<SubscriptionRecord>, AppError> {\n    service.subscription_state.list_all().await\n}\n","traces":[{"line":9,"address":[12685728,12685712,12685720,12686042,12685854,12685891,12686307,12685763],"length":1,"stats":{"Line":0}},{"line":10,"address":[12681945,12681893,12682009,12682138],"length":1,"stats":{"Line":0}},{"line":13,"address":[12570275,12569688,12569747,12569835,12569680,12569872,12569712,12569992],"length":1,"stats":{"Line":0}},{"line":14,"address":[20344895,20345000,20344838,20344792],"length":1,"stats":{"Line":0}},{"line":17,"address":[12571174,12570530,12570288,12570296,12570367,12571921,12570320,12570657],"length":1,"stats":{"Line":0}},{"line":18,"address":[12577899,12577491,12577280,12577614],"length":1,"stats":{"Line":0}},{"line":20,"address":[12584547,12585659,12584966,12584733,12585442,12584320],"length":1,"stats":{"Line":0}},{"line":21,"address":[12585328],"length":1,"stats":{"Line":0}},{"line":23,"address":[12646407,12646197,12651210,12651158],"length":1,"stats":{"Line":0}},{"line":24,"address":[12576726],"length":1,"stats":{"Line":0}},{"line":25,"address":[12695417],"length":1,"stats":{"Line":0}},{"line":26,"address":[12695491],"length":1,"stats":{"Line":0}},{"line":27,"address":[20352217,20352306],"length":1,"stats":{"Line":0}},{"line":28,"address":[12584258,12584072],"length":1,"stats":{"Line":0}},{"line":31,"address":[12690143],"length":1,"stats":{"Line":0}},{"line":32,"address":[12577594],"length":1,"stats":{"Line":0}},{"line":33,"address":[11805736],"length":1,"stats":{"Line":0}},{"line":35,"address":[11812737],"length":1,"stats":{"Line":0}},{"line":38,"address":[12591984],"length":1,"stats":{"Line":0}},{"line":40,"address":[12697061,12697385,12697523,12697639,12697744,12697326],"length":1,"stats":{"Line":0}},{"line":41,"address":[12585721],"length":1,"stats":{"Line":0}},{"line":42,"address":[11805786],"length":1,"stats":{"Line":0}},{"line":44,"address":[12697104],"length":1,"stats":{"Line":0}},{"line":45,"address":[12586477,12585650],"length":1,"stats":{"Line":0}},{"line":46,"address":[12593594,12586158,12585946,12593468,12593651],"length":1,"stats":{"Line":0}},{"line":48,"address":[12692469],"length":1,"stats":{"Line":0}},{"line":49,"address":[12645236,12646633,12646874,12654454,12654505],"length":1,"stats":{"Line":0}},{"line":51,"address":[20461175,20461268,20461765,20598239,20598105],"length":1,"stats":{"Line":0}},{"line":56,"address":[20349256,20349504,20350476,20349659,20350162,20586461,20586327,20349907],"length":1,"stats":{"Line":0}},{"line":60,"address":[12574813,12576129],"length":1,"stats":{"Line":0}},{"line":65,"address":[12658278,12658462],"length":1,"stats":{"Line":0}},{"line":66,"address":[12576860],"length":1,"stats":{"Line":0}},{"line":68,"address":[12790016],"length":1,"stats":{"Line":0}},{"line":73,"address":[12793056],"length":1,"stats":{"Line":0}},{"line":77,"address":[20355374,20355178],"length":1,"stats":{"Line":0}},{"line":78,"address":[12655675],"length":1,"stats":{"Line":0}},{"line":79,"address":[12580435],"length":1,"stats":{"Line":0}},{"line":80,"address":[20355419],"length":1,"stats":{"Line":0}},{"line":84,"address":[20356000,20355453,20355380,20355568],"length":1,"stats":{"Line":0}},{"line":86,"address":[12580557,12580677],"length":1,"stats":{"Line":0}},{"line":87,"address":[20469878,20470214,20469686,20470559,20469286,20469136,20469373],"length":1,"stats":{"Line":0}},{"line":89,"address":[12699123],"length":1,"stats":{"Line":0}},{"line":90,"address":[11582290],"length":1,"stats":{"Line":0}},{"line":91,"address":[12588531,12588722],"length":1,"stats":{"Line":0}},{"line":93,"address":[11688232],"length":1,"stats":{"Line":0}},{"line":95,"address":[12582826,12583704,12583478,12583594,12582547,12582909],"length":1,"stats":{"Line":0}},{"line":97,"address":[20357702],"length":1,"stats":{"Line":0}},{"line":98,"address":[12796003,12793379,12795938,12796598,12796439,12796728],"length":1,"stats":{"Line":0}},{"line":99,"address":[20471943],"length":1,"stats":{"Line":0}},{"line":101,"address":[12700878],"length":1,"stats":{"Line":0}},{"line":102,"address":[12657247],"length":1,"stats":{"Line":0}},{"line":103,"address":[12695929,12695720,12696605,12696769,12696012],"length":1,"stats":{"Line":0}},{"line":105,"address":[12699779],"length":1,"stats":{"Line":0}},{"line":106,"address":[19350551],"length":1,"stats":{"Line":0}},{"line":108,"address":[12924567,12697156,12697955,12696943,12924701,12696842,12697698,12697470,12697311],"length":1,"stats":{"Line":0}},{"line":113,"address":[12585837],"length":1,"stats":{"Line":0}},{"line":118,"address":[20361056],"length":1,"stats":{"Line":0}},{"line":122,"address":[12699002,12699198],"length":1,"stats":{"Line":0}},{"line":123,"address":[12587179],"length":1,"stats":{"Line":0}},{"line":124,"address":[12661123],"length":1,"stats":{"Line":0}},{"line":125,"address":[12586539],"length":1,"stats":{"Line":0}},{"line":129,"address":[12704861,12704788,12705408,12704976],"length":1,"stats":{"Line":0}},{"line":131,"address":[12704941,12705061],"length":1,"stats":{"Line":0}},{"line":132,"address":[20475542,20475229,20476070,20476415,20474992,20475142,20475734],"length":1,"stats":{"Line":0}},{"line":134,"address":[12800003],"length":1,"stats":{"Line":0}},{"line":135,"address":[11584722],"length":1,"stats":{"Line":0}},{"line":136,"address":[12706322,12706131],"length":1,"stats":{"Line":0}},{"line":138,"address":[11687624],"length":1,"stats":{"Line":0}},{"line":140,"address":[12603560,12602682,12602403,12602765,12603334,12603450],"length":1,"stats":{"Line":0}},{"line":142,"address":[12701526],"length":1,"stats":{"Line":0}},{"line":143,"address":[12670482,12667923,12670983,12671142,12671272,12670547],"length":1,"stats":{"Line":0}},{"line":144,"address":[12603502],"length":1,"stats":{"Line":0}},{"line":146,"address":[12670206],"length":1,"stats":{"Line":0}},{"line":147,"address":[20476848],"length":1,"stats":{"Line":0}},{"line":148,"address":[12671681,12670632,12670841,12671517,12670924],"length":1,"stats":{"Line":0}},{"line":150,"address":[20477316],"length":1,"stats":{"Line":0}},{"line":151,"address":[10963051],"length":1,"stats":{"Line":0}},{"line":153,"address":[12709635,12708522,12930663,12709378,12709150,12708836,12930797,12708623,12708991],"length":1,"stats":{"Line":0}},{"line":158,"address":[12708573],"length":1,"stats":{"Line":0}},{"line":163,"address":[12710464],"length":1,"stats":{"Line":0}},{"line":166,"address":[12708933,12709049,12708985,12709178],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","mod.rs"],"content":"pub mod access_control_service;\npub mod auth_lifecycle;\npub mod auth_service;\npub mod direct_message_service;\npub mod event_service;\npub mod offline_service;\npub mod p2p_service;\npub mod post_service;\npub mod profile_avatar_service;\nmod subscription_state;\npub mod sync_service;\npub mod topic_service;\npub mod user_search_service;\npub mod user_service;\n\npub use crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use access_control_service::{\n    AccessControlService, JoinRequestApprovalResult, JoinRequestInput, JoinRequestResult,\n};\npub use auth_lifecycle::DefaultAuthLifecycle;\npub use auth_service::AuthService;\npub use direct_message_service::{\n    DirectMessageConversationPageResult, DirectMessagePageResult, DirectMessageService,\n    MessagePageDirection as DirectMessageServiceDirection, SendDirectMessageResult,\n};\npub use event_service::EventService;\npub use offline_service::OfflineService;\npub use p2p_service::P2PService;\npub use post_service::PostService;\npub use profile_avatar_service::{\n    ProfileAvatarFetchResult, ProfileAvatarService, UploadProfileAvatarInput,\n};\npub use subscription_state::{SubscriptionStateMachine, SubscriptionStateStore};\npub use sync_service::{SyncService, SyncServiceTrait};\npub use topic_service::TopicService;\npub use user_search_service::UserSearchService;\npub use user_service::UserService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","offline_service.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft, OfflineActionFilter,\n    OfflineActionRecord, OptimisticUpdateDraft, SavedOfflineAction, SyncQueueItem,\n    SyncQueueItemDraft, SyncResult, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, OptimisticUpdateId, SyncQueueId,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct SaveOfflineActionParams {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub payload: OfflinePayload,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct OfflineActionsQuery {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\n#[async_trait]\npub trait OfflineServiceTrait: Send + Sync {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError>;\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError>;\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n}\n\npub struct OfflineService {\n    persistence: Arc<dyn OfflinePersistence>,\n}\n\nimpl OfflineService {\n    pub fn new(persistence: Arc<dyn OfflinePersistence>) -> Self {\n        Self { persistence }\n    }\n\n    fn build_action_draft(\n        params: &SaveOfflineActionParams,\n    ) -> Result<OfflineActionDraft, AppError> {\n        let payload_value = params.payload.clone().into_inner();\n        let mut map = match payload_value {\n            Value::Object(map) => map,\n            _ => {\n                return Err(AppError::validation(\n                    ValidationFailureKind::Generic,\n                    \"Offline action payload must be a JSON object\",\n                ));\n            }\n        };\n\n        map.insert(\n            \"entityType\".to_string(),\n            Value::String(params.entity_type.to_string()),\n        );\n        map.insert(\n            \"entityId\".to_string(),\n            Value::String(params.entity_id.to_string()),\n        );\n\n        let enriched_payload = OfflinePayload::new(Value::Object(map))\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err.to_string()))?;\n\n        Ok(OfflineActionDraft::new(\n            params.user_pubkey.clone(),\n            params.action_type.clone(),\n            Some(params.entity_id.clone()),\n            enriched_payload,\n        ))\n    }\n\n    fn filter_from_query(query: &OfflineActionsQuery) -> OfflineActionFilter {\n        OfflineActionFilter::new(query.user_pubkey.clone(), query.include_synced, query.limit)\n    }\n}\n\n#[async_trait]\nimpl OfflineServiceTrait for OfflineService {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError> {\n        let draft = Self::build_action_draft(&params)?;\n        self.persistence.save_action(draft).await\n    }\n\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError> {\n        let filter = Self::filter_from_query(&query);\n        self.persistence.list_actions(filter).await\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        self.persistence.sync_actions(user_pubkey).await\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        self.persistence.cache_status().await\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        self.persistence.enqueue_sync(draft).await\n    }\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError> {\n        self.persistence.recent_sync_queue_items(limit).await\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        self.persistence.upsert_cache_metadata(update).await\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        self.persistence.save_optimistic_update(draft).await\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        self.persistence.confirm_optimistic_update(update_id).await\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        self.persistence.rollback_optimistic_update(update_id).await\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        self.persistence.cleanup_expired_cache().await\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        self.persistence.update_sync_status(update).await\n    }\n}\n","traces":[{"line":71,"address":[18798944],"length":1,"stats":{"Line":5}},{"line":75,"address":[18918791,18919113,18917264],"length":1,"stats":{"Line":1}},{"line":78,"address":[19012078],"length":1,"stats":{"Line":1}},{"line":79,"address":[18799100],"length":1,"stats":{"Line":1}},{"line":80,"address":[18880631],"length":1,"stats":{"Line":1}},{"line":82,"address":[18875291,18873810],"length":1,"stats":{"Line":0}},{"line":83,"address":[26500489],"length":1,"stats":{"Line":0}},{"line":89,"address":[18799415],"length":1,"stats":{"Line":1}},{"line":90,"address":[18912010,18911883],"length":1,"stats":{"Line":2}},{"line":91,"address":[18813135,18813074],"length":1,"stats":{"Line":2}},{"line":93,"address":[13053938],"length":1,"stats":{"Line":1}},{"line":94,"address":[18881006],"length":1,"stats":{"Line":1}},{"line":95,"address":[18881114,18881050],"length":1,"stats":{"Line":2}},{"line":98,"address":[19012777,19013102],"length":1,"stats":{"Line":1}},{"line":99,"address":[13054286,13055168,13055187],"length":1,"stats":{"Line":0}},{"line":101,"address":[18916952,18917040],"length":1,"stats":{"Line":2}},{"line":102,"address":[18874562,18874697],"length":1,"stats":{"Line":2}},{"line":103,"address":[18813935,18813873],"length":1,"stats":{"Line":2}},{"line":104,"address":[18912944,18912887],"length":1,"stats":{"Line":2}},{"line":105,"address":[18874864],"length":1,"stats":{"Line":1}},{"line":109,"address":[18807792],"length":1,"stats":{"Line":1}},{"line":110,"address":[19014103],"length":1,"stats":{"Line":1}},{"line":116,"address":[11906090,11906045],"length":1,"stats":{"Line":5}},{"line":120,"address":[19125317,19124899,19124986],"length":1,"stats":{"Line":2}},{"line":121,"address":[12006353],"length":1,"stats":{"Line":3}},{"line":124,"address":[11288076,11288111],"length":1,"stats":{"Line":4}},{"line":128,"address":[18913696,18913779],"length":1,"stats":{"Line":2}},{"line":129,"address":[11802414],"length":1,"stats":{"Line":3}},{"line":132,"address":[26696243,26697153,26696352,26696717,26696509,26696153,26696907,26696208,26696482],"length":1,"stats":{"Line":4}},{"line":133,"address":[18921805,18921732,18921403,18921983],"length":1,"stats":{"Line":3}},{"line":136,"address":[18990179,18990864,18990263,18990105,18990352,18990602,18990144,18990375],"length":1,"stats":{"Line":10}},{"line":137,"address":[18997218,18997403,18997562],"length":1,"stats":{"Line":4}},{"line":140,"address":[18916512,18917401,18916642,18916297,18916677,18916368,18916403,18916913,18917143],"length":1,"stats":{"Line":4}},{"line":141,"address":[19035463,19035180,19034827,19035253],"length":1,"stats":{"Line":3}},{"line":144,"address":[19031007,19030750,19030209,19030459,19030256,19030370,19030291,19030482],"length":1,"stats":{"Line":5}},{"line":148,"address":[18918078,18917693,18917911],"length":1,"stats":{"Line":2}},{"line":151,"address":[19031276,19032163,19031155,19031409,19031039,19031896,19031444,19031683,19031120],"length":1,"stats":{"Line":12}},{"line":152,"address":[11897857],"length":1,"stats":{"Line":8}},{"line":155,"address":[13174019,13174270,13175140,13174305,13174879,13173871,13173984,13174140,13174592],"length":1,"stats":{"Line":0}},{"line":159,"address":[11826657],"length":1,"stats":{"Line":0}},{"line":162,"address":[18935729,18934697,18934752,18934896,18935273,18935026,18935061,18934787,18935471],"length":1,"stats":{"Line":0}},{"line":166,"address":[11827502],"length":1,"stats":{"Line":0}},{"line":169,"address":[19039061,19038752,19039026,19039471,19038697,19039273,19039729,19038787,19038896],"length":1,"stats":{"Line":0}},{"line":173,"address":[11910974],"length":1,"stats":{"Line":0}},{"line":176,"address":[19040310,19039856,19039970,19040082,19039891,19039817,19040568,19040059],"length":1,"stats":{"Line":5}},{"line":177,"address":[19591188],"length":1,"stats":{"Line":2}},{"line":180,"address":[19137152,19137473,19137039,19137187,19137438,19137777,19138342,19137308,19138082],"length":1,"stats":{"Line":4}},{"line":181,"address":[11927201],"length":1,"stats":{"Line":3}}],"covered":39,"coverable":48},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","bootstrap.rs"],"content":"use super::core::{P2PService, P2PServiceTrait};\nuse crate::domain::p2p::events::P2PEvent;\nuse crate::infrastructure::p2p::{\n    DiscoveryOptions, GossipService, NetworkService, iroh_gossip_service::IrohGossipService,\n    iroh_network_service::IrohNetworkService,\n};\nuse crate::shared::config::NetworkConfig as AppNetworkConfig;\nuse crate::shared::error::AppError;\nuse iroh::SecretKey;\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\n\npub struct P2PStack {\n    pub network_service: Arc<dyn NetworkService>,\n    pub gossip_service: Arc<dyn GossipService>,\n    pub p2p_service: Arc<dyn P2PServiceTrait>,\n}\n\npub struct P2PServiceBuilder {\n    secret_key: SecretKey,\n    network_config: AppNetworkConfig,\n    discovery_options: DiscoveryOptions,\n    event_sender: Option<broadcast::Sender<P2PEvent>>,\n}\n\nimpl P2PServiceBuilder {\n    pub(crate) fn new(\n        secret_key: SecretKey,\n        network_config: AppNetworkConfig,\n        discovery_options: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender: None,\n        }\n    }\n\n    pub fn with_discovery_options(mut self, options: DiscoveryOptions) -> Self {\n        self.discovery_options = options;\n        self\n    }\n\n    pub fn enable_mainline(mut self, enabled: bool) -> Self {\n        self.discovery_options = self.discovery_options.with_mainline(enabled);\n        self\n    }\n\n    pub fn with_event_sender(mut self, sender: broadcast::Sender<P2PEvent>) -> Self {\n        self.event_sender = Some(sender);\n        self\n    }\n\n    pub fn discovery_options(&self) -> DiscoveryOptions {\n        self.discovery_options\n    }\n\n    pub async fn build(self) -> Result<P2PStack, AppError> {\n        let P2PServiceBuilder {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender,\n        } = self;\n\n        let (network_event_sender, gossip_event_sender) = match event_sender {\n            Some(sender) => (Some(sender.clone()), Some(sender)),\n            None => (None, None),\n        };\n\n        let iroh_network = Arc::new(\n            IrohNetworkService::new(\n                secret_key,\n                network_config,\n                discovery_options,\n                network_event_sender,\n            )\n            .await?,\n        );\n        let endpoint_arc = iroh_network.endpoint().clone();\n        let static_discovery = iroh_network.static_discovery();\n        let mut gossip_inner = IrohGossipService::new(endpoint_arc, static_discovery)?;\n        if let Some(tx) = gossip_event_sender {\n            gossip_inner.set_event_sender(tx);\n        }\n        let iroh_gossip = Arc::new(gossip_inner);\n\n        let network_service_dyn: Arc<dyn NetworkService> = iroh_network.clone();\n        let gossip_service_dyn: Arc<dyn GossipService> = iroh_gossip.clone();\n        let p2p_service: Arc<dyn P2PServiceTrait> = Arc::new(P2PService::with_discovery(\n            Arc::clone(&network_service_dyn),\n            Arc::clone(&gossip_service_dyn),\n            discovery_options,\n        ));\n\n        Ok(P2PStack {\n            network_service: network_service_dyn,\n            gossip_service: gossip_service_dyn,\n            p2p_service,\n        })\n    }\n}\n","traces":[{"line":27,"address":[13592192],"length":1,"stats":{"Line":0}},{"line":40,"address":[13592352],"length":1,"stats":{"Line":0}},{"line":41,"address":[13489519],"length":1,"stats":{"Line":0}},{"line":42,"address":[13482565],"length":1,"stats":{"Line":0}},{"line":45,"address":[13594096,13594323],"length":1,"stats":{"Line":0}},{"line":46,"address":[21250936,21250814],"length":1,"stats":{"Line":0}},{"line":47,"address":[13476015],"length":1,"stats":{"Line":0}},{"line":50,"address":[13594352,13594489],"length":1,"stats":{"Line":0}},{"line":51,"address":[13489854,13489929],"length":1,"stats":{"Line":0}},{"line":52,"address":[13557701],"length":1,"stats":{"Line":0}},{"line":55,"address":[13550816],"length":1,"stats":{"Line":0}},{"line":56,"address":[13557749],"length":1,"stats":{"Line":0}},{"line":59,"address":[20481488,20481580,20481424,20482676,20485294,20481441,20481938,20482711],"length":1,"stats":{"Line":0}},{"line":61,"address":[13689675],"length":1,"stats":{"Line":0}},{"line":62,"address":[20481800],"length":1,"stats":{"Line":0}},{"line":63,"address":[21251665],"length":1,"stats":{"Line":0}},{"line":64,"address":[20481877],"length":1,"stats":{"Line":0}},{"line":67,"address":[13558268,13558460],"length":1,"stats":{"Line":0}},{"line":68,"address":[21252249,21251863],"length":1,"stats":{"Line":0}},{"line":69,"address":[13476829],"length":1,"stats":{"Line":0}},{"line":73,"address":[13483976,13484879,13484264,13486868,13484487,13484655],"length":1,"stats":{"Line":0}},{"line":74,"address":[13593649],"length":1,"stats":{"Line":0}},{"line":75,"address":[13593710],"length":1,"stats":{"Line":0}},{"line":76,"address":[13558653],"length":1,"stats":{"Line":0}},{"line":77,"address":[13477169],"length":1,"stats":{"Line":0}},{"line":79,"address":[11547489],"length":1,"stats":{"Line":0}},{"line":81,"address":[13478145,13478226],"length":1,"stats":{"Line":0}},{"line":82,"address":[20483444,20483386],"length":1,"stats":{"Line":0}},{"line":83,"address":[13591311,13591087,13591154],"length":1,"stats":{"Line":0}},{"line":84,"address":[20483644,20483766],"length":1,"stats":{"Line":0}},{"line":85,"address":[13553462,13553322],"length":1,"stats":{"Line":0}},{"line":87,"address":[13560269,13560397],"length":1,"stats":{"Line":0}},{"line":89,"address":[13478955,13478885],"length":1,"stats":{"Line":0}},{"line":90,"address":[13595618,13595688],"length":1,"stats":{"Line":0}},{"line":91,"address":[21254365,21254261,21254438],"length":1,"stats":{"Line":0}},{"line":92,"address":[21254047,21254121],"length":1,"stats":{"Line":0}},{"line":93,"address":[13692241],"length":1,"stats":{"Line":0}},{"line":94,"address":[13692321],"length":1,"stats":{"Line":0}},{"line":97,"address":[21254493],"length":1,"stats":{"Line":0}},{"line":98,"address":[13592189],"length":1,"stats":{"Line":0}},{"line":99,"address":[13597789],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","core.rs"],"content":"use super::bootstrap::P2PServiceBuilder;\nuse super::metrics::GossipMetricsSummary;\nuse super::status::{ConnectionStatus, P2PStatus, PeerStatus, TopicInfo};\nuse crate::infrastructure::p2p::{DiscoveryOptions, GossipService, NetworkService, metrics};\nuse crate::shared::config::{BootstrapSource, NetworkConfig as AppNetworkConfig};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse iroh::SecretKey;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct P2PService {\n    network_service: Arc<dyn NetworkService>,\n    gossip_service: Arc<dyn GossipService>,\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\n}\n\n#[async_trait]\npub trait P2PServiceTrait: Send + Sync {\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError>;\n    async fn get_status(&self) -> Result<P2PStatus, AppError>;\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError>;\n    fn generate_topic_id(&self, topic_name: &str) -> String;\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError>;\n}\n\nimpl P2PService {\n    pub fn new(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n    ) -> Self {\n        Self::with_discovery(network_service, gossip_service, DiscoveryOptions::default())\n    }\n\n    pub fn with_discovery(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n        discovery: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            network_service,\n            gossip_service,\n            discovery_options: Arc::new(RwLock::new(discovery)),\n        }\n    }\n\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\n        *self.discovery_options.read().await\n    }\n\n    pub async fn set_mainline_enabled(&self, enabled: bool) {\n        let mut options = self.discovery_options.write().await;\n        *options = options.with_mainline(enabled);\n    }\n\n    async fn mainline_enabled(&self) -> bool {\n        self.discovery_options.read().await.enable_mainline()\n    }\n\n    async fn ensure_topic_joined(&self, topic_id: &str) -> Result<(), AppError> {\n        let joined_topics = self\n            .gossip_service\n            .get_joined_topics()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if !joined_topics.iter().any(|topic| topic == topic_id) {\n            self.gossip_service\n                .join_topic(topic_id, Vec::new())\n                .await\n                .map_err(|e| AppError::P2PError(e.to_string()))?;\n        }\n\n        if self.mainline_enabled().await {\n            self.network_service.join_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    pub fn builder(secret_key: SecretKey, network_config: AppNetworkConfig) -> P2PServiceBuilder {\n        let discovery_options = DiscoveryOptions::from(&network_config);\n        P2PServiceBuilder::new(secret_key, network_config, discovery_options)\n    }\n}\n\n#[async_trait]\nimpl P2PServiceTrait for P2PService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.gossip_service\n            .join_topic(topic_id, initial_peers)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service.join_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        self.gossip_service\n            .leave_topic(topic_id)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service.leave_dht_topic(topic_id).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError> {\n        self.ensure_topic_joined(topic_id).await?;\n\n        self.gossip_service\n            .broadcast_message(topic_id, content.as_bytes())\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        if self.mainline_enabled().await {\n            self.network_service\n                .broadcast_dht(topic_id, content.as_bytes().to_vec())\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn get_status(&self) -> Result<P2PStatus, AppError> {\n        let endpoint_id = self\n            .network_service\n            .get_node_id()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let joined_topics = self\n            .gossip_service\n            .get_joined_topics()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let mut active_topics = Vec::new();\n        let mut total_peer_count = 0;\n\n        for topic_id in joined_topics {\n            let stats = self\n                .gossip_service\n                .get_topic_stats(&topic_id)\n                .await\n                .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n            let (peer_count, message_count, last_activity) = if let Some(stats) = stats {\n                (stats.peer_count, stats.message_count, stats.last_activity)\n            } else {\n                let peers = self\n                    .gossip_service\n                    .get_topic_peers(&topic_id)\n                    .await\n                    .map_err(|e| AppError::P2PError(e.to_string()))?;\n                (peers.len(), 0, chrono::Utc::now().timestamp())\n            };\n\n            total_peer_count += peer_count;\n\n            active_topics.push(TopicInfo {\n                id: topic_id,\n                peer_count,\n                message_count,\n                last_activity,\n            });\n        }\n\n        let peers = self\n            .network_service\n            .get_peers()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let network_connected = self.network_service.is_connected().await && !peers.is_empty();\n\n        let peer_status: Vec<PeerStatus> = peers\n            .into_iter()\n            .map(|peer| PeerStatus {\n                node_id: peer.id,\n                address: peer.address,\n                connected_at: peer.connected_at,\n                last_seen: peer.last_seen,\n            })\n            .collect();\n\n        let metrics_summary = GossipMetricsSummary::from_snapshot(&metrics::snapshot());\n\n        Ok(P2PStatus {\n            connected: network_connected,\n            connection_status: if network_connected {\n                ConnectionStatus::Connected\n            } else {\n                ConnectionStatus::Disconnected\n            },\n            endpoint_id,\n            active_topics,\n            peer_count: total_peer_count,\n            peers: peer_status,\n            metrics_summary,\n        })\n    }\n\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError> {\n        self.network_service\n            .get_addresses()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    fn generate_topic_id(&self, topic_name: &str) -> String {\n        crate::domain::p2p::generate_topic_id(topic_name)\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        self.network_service\n            .apply_bootstrap_nodes(nodes, source)\n            .await\n    }\n}\n","traces":[{"line":35,"address":[13554960,13555242],"length":1,"stats":{"Line":1}},{"line":39,"address":[13598689,13598957,13598913],"length":1,"stats":{"Line":1}},{"line":42,"address":[14316242,14315936,14316263],"length":1,"stats":{"Line":1}},{"line":50,"address":[13593493,13593629],"length":1,"stats":{"Line":2}},{"line":54,"address":[13593887,13593768,13594064,13593776,13593801,13594489,13593924,13593760],"length":1,"stats":{"Line":0}},{"line":55,"address":[13481163,13481392,13481210,13481269],"length":1,"stats":{"Line":0}},{"line":58,"address":[13563328,13563502,13563539,13564219,13563671,13563347,13563401,13563376],"length":1,"stats":{"Line":0}},{"line":59,"address":[13600471,13600297,13600250,13600356],"length":1,"stats":{"Line":0}},{"line":60,"address":[13595158,13595091],"length":1,"stats":{"Line":0}},{"line":63,"address":[13557999,13557328,13557320,13557476,13557353,13557616,13557312,13557439],"length":1,"stats":{"Line":4}},{"line":64,"address":[13599467,13599573,13599514,13599696],"length":1,"stats":{"Line":2}},{"line":67,"address":[13490256,13490208,13490748,13490556,13490303,13490226,13491788,13490450],"length":1,"stats":{"Line":8}},{"line":68,"address":[14319982,14319295,14318998,14318708,14319173,14319504,14318919],"length":1,"stats":{"Line":10}},{"line":71,"address":[13602163,13602222,13601984,13602284,13602440],"length":1,"stats":{"Line":6}},{"line":72,"address":[14321255,14321232,14319456],"length":1,"stats":{"Line":0}},{"line":74,"address":[13699502,13697429,13697620,13699488,13698379],"length":1,"stats":{"Line":7}},{"line":75,"address":[21260336,21260454,21259881,21259814,21260204,21259634,21260094],"length":1,"stats":{"Line":5}},{"line":76,"address":[13603049],"length":1,"stats":{"Line":1}},{"line":77,"address":[11666629],"length":1,"stats":{"Line":3}},{"line":78,"address":[14321447,14320326,14321424],"length":1,"stats":{"Line":0}},{"line":81,"address":[11665001],"length":1,"stats":{"Line":4}},{"line":82,"address":[13698976,13696831,13698816,13699247],"length":1,"stats":{"Line":2}},{"line":85,"address":[13698782],"length":1,"stats":{"Line":2}},{"line":88,"address":[13599708,13599312],"length":1,"stats":{"Line":0}},{"line":89,"address":[13500403,13500500],"length":1,"stats":{"Line":0}},{"line":90,"address":[13568305],"length":1,"stats":{"Line":0}},{"line":96,"address":[13703173,13703045,13702864,13702825,13702894,13702957,13703022],"length":1,"stats":{"Line":5}},{"line":97,"address":[13704793],"length":1,"stats":{"Line":1}},{"line":100,"address":[14456943,14458363,14457408,14458872,14457621,14458923,14457079,14457233,14456831,14456896,14458111],"length":1,"stats":{"Line":7}},{"line":101,"address":[13661744,13661894,13662527,13661961,13662141,13662251,13662409],"length":1,"stats":{"Line":10}},{"line":102,"address":[13705538],"length":1,"stats":{"Line":1}},{"line":103,"address":[13594381,13594228,13594169,13593669,13594122],"length":1,"stats":{"Line":6}},{"line":104,"address":[13704409,13705586,13705568],"length":1,"stats":{"Line":3}},{"line":106,"address":[13602406,13601498,13601611,13601723,13600666],"length":1,"stats":{"Line":3}},{"line":107,"address":[11901940],"length":1,"stats":{"Line":1}},{"line":110,"address":[13594951],"length":1,"stats":{"Line":1}},{"line":113,"address":[21364079,21364720,21364441,21365495,21364175,21365248,21364128,21364275],"length":1,"stats":{"Line":7}},{"line":114,"address":[13603641,13604027,13603333,13603751,13603402,13603909,13603461],"length":1,"stats":{"Line":12}},{"line":115,"address":[13706266],"length":1,"stats":{"Line":2}},{"line":116,"address":[13705969,13706310,13706357,13706569,13706416],"length":1,"stats":{"Line":6}},{"line":117,"address":[21366032,21366050,21365077],"length":1,"stats":{"Line":3}},{"line":119,"address":[11786149],"length":1,"stats":{"Line":3}},{"line":120,"address":[14459499,14460996,14460590],"length":1,"stats":{"Line":1}},{"line":123,"address":[13597269],"length":1,"stats":{"Line":1}},{"line":126,"address":[13591359,13593329,13591646,13591312,13592583,13591459,13591876,13591247],"length":1,"stats":{"Line":7}},{"line":127,"address":[13709218,13708548,13708861,13708129,13708394],"length":1,"stats":{"Line":1}},{"line":129,"address":[14462934,14462682,14462804,14463041,14462525,14462446,14462183],"length":1,"stats":{"Line":10}},{"line":130,"address":[21367314],"length":1,"stats":{"Line":2}},{"line":131,"address":[11879413],"length":1,"stats":{"Line":6}},{"line":132,"address":[13711208,13712274,13712256],"length":1,"stats":{"Line":0}},{"line":134,"address":[13666123,13667683,13668456,13667481,13667594],"length":1,"stats":{"Line":6}},{"line":135,"address":[21368893,21368678,21368310,21368463,21368788,21368530],"length":1,"stats":{"Line":10}},{"line":136,"address":[13593387],"length":1,"stats":{"Line":2}},{"line":137,"address":[13675117,13673072,13675043,13675270,13675090,13675389],"length":1,"stats":{"Line":6}},{"line":140,"address":[13806367],"length":1,"stats":{"Line":2}},{"line":143,"address":[13601007,13600960,13601408,13601179,13601718,13600911,13607760,13602482],"length":1,"stats":{"Line":9}},{"line":144,"address":[13712080,13711717,13711382,13711520,13711843,13712333],"length":1,"stats":{"Line":8}},{"line":147,"address":[13594902,13594425,13594837,13595125,13594966],"length":1,"stats":{"Line":6}},{"line":148,"address":[13712032,13717680,13717698],"length":1,"stats":{"Line":0}},{"line":150,"address":[14465666,14465497,14465216,14465418,14465804,14466008,14466307],"length":1,"stats":{"Line":10}},{"line":153,"address":[13670188,13670253,13670458,13669038,13670299],"length":1,"stats":{"Line":6}},{"line":154,"address":[13602912,13607968,13607986],"length":1,"stats":{"Line":0}},{"line":156,"address":[13609862],"length":1,"stats":{"Line":2}},{"line":157,"address":[13714549],"length":1,"stats":{"Line":2}},{"line":159,"address":[21371253,21372693,21372586,21372635,21371375],"length":1,"stats":{"Line":6}},{"line":160,"address":[13673080,13673287,13673629,13672954,13672351,13672733,13672816],"length":1,"stats":{"Line":5}},{"line":162,"address":[13714714],"length":1,"stats":{"Line":1}},{"line":163,"address":[11895556],"length":1,"stats":{"Line":4}},{"line":164,"address":[13682866,13680167,13682848],"length":1,"stats":{"Line":0}},{"line":166,"address":[21373708,21373607,21372265,21373804],"length":1,"stats":{"Line":4}},{"line":167,"address":[21373756],"length":1,"stats":{"Line":1}},{"line":169,"address":[13596878,13597099,13598833,13596704,13598951,13599010,13599062],"length":1,"stats":{"Line":5}},{"line":171,"address":[13598902],"length":1,"stats":{"Line":1}},{"line":172,"address":[14464392,14468722,14468771,14466383,14466564],"length":1,"stats":{"Line":4}},{"line":173,"address":[13715339,13719760,13719778],"length":1,"stats":{"Line":0}},{"line":174,"address":[14466821,14466973],"length":1,"stats":{"Line":2}},{"line":177,"address":[13810647,13810433],"length":1,"stats":{"Line":1}},{"line":179,"address":[21372412,21372469],"length":1,"stats":{"Line":2}},{"line":180,"address":[13714091],"length":1,"stats":{"Line":1}},{"line":187,"address":[13679422,13680820,13681194,13680946,13679325,13679505],"length":1,"stats":{"Line":5}},{"line":190,"address":[11796662],"length":1,"stats":{"Line":3}},{"line":191,"address":[13714320,13714338,13712330],"length":1,"stats":{"Line":0}},{"line":193,"address":[13716409,13716230,13711170,13716886,13716539],"length":1,"stats":{"Line":3}},{"line":195,"address":[13718450,13718547],"length":1,"stats":{"Line":2}},{"line":197,"address":[14471408,14471480],"length":1,"stats":{"Line":2}},{"line":198,"address":[13718411],"length":1,"stats":{"Line":1}},{"line":199,"address":[21376773],"length":1,"stats":{"Line":1}},{"line":200,"address":[14471472],"length":1,"stats":{"Line":1}},{"line":201,"address":[13718468],"length":1,"stats":{"Line":1}},{"line":205,"address":[13600376,13600313],"length":1,"stats":{"Line":3}},{"line":207,"address":[13607438],"length":1,"stats":{"Line":2}},{"line":208,"address":[13614223],"length":1,"stats":{"Line":2}},{"line":209,"address":[13614234,13614252],"length":1,"stats":{"Line":3}},{"line":210,"address":[14470147],"length":1,"stats":{"Line":1}},{"line":212,"address":[13713188],"length":1,"stats":{"Line":1}},{"line":214,"address":[13813578],"length":1,"stats":{"Line":1}},{"line":215,"address":[13713254],"length":1,"stats":{"Line":2}},{"line":216,"address":[13718882],"length":1,"stats":{"Line":2}},{"line":217,"address":[13607390],"length":1,"stats":{"Line":2}},{"line":222,"address":[13676505,13676658,13676544,13676770,13676579,13676747,13677280,13676996],"length":1,"stats":{"Line":5}},{"line":223,"address":[13718918,13719275,13719008,13719177],"length":1,"stats":{"Line":4}},{"line":225,"address":[21377412,21377069,21377313,21377357,21377561],"length":1,"stats":{"Line":3}},{"line":226,"address":[13715408,13715426],"length":1,"stats":{"Line":0}},{"line":229,"address":[13616608],"length":1,"stats":{"Line":1}},{"line":230,"address":[13719541],"length":1,"stats":{"Line":1}},{"line":233,"address":[13610795,13610101,13610066,13609727,13609792,13609827,13610332,13609936,13610538],"length":1,"stats":{"Line":4}},{"line":238,"address":[13678310,13678237,13678119,13678479],"length":1,"stats":{"Line":4}},{"line":239,"address":[13720244],"length":1,"stats":{"Line":1}},{"line":240,"address":[11920110],"length":1,"stats":{"Line":3}}],"covered":92,"coverable":109},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","metrics.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::infrastructure::p2p::metrics::GossipMetricsSnapshot;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummary {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n\nimpl GossipMetricsSummary {\n    pub fn from_snapshot(snapshot: &GossipMetricsSnapshot) -> Self {\n        Self {\n            joins: snapshot.joins,\n            leaves: snapshot.leaves,\n            broadcasts_sent: snapshot.broadcasts_sent,\n            messages_received: snapshot.messages_received,\n        }\n    }\n}\n","traces":[{"line":14,"address":[13055392],"length":1,"stats":{"Line":2}},{"line":16,"address":[18919387],"length":1,"stats":{"Line":2}},{"line":17,"address":[18814866],"length":1,"stats":{"Line":2}},{"line":18,"address":[18882633],"length":1,"stats":{"Line":2}},{"line":19,"address":[18875712],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","mod.rs"],"content":"mod bootstrap;\nmod core;\nmod metrics;\nmod status;\n\npub use bootstrap::{P2PServiceBuilder, P2PStack};\npub use core::{P2PService, P2PServiceTrait};\npub use metrics::GossipMetricsSummary;\npub use status::{ConnectionStatus, P2PStatus, PeerStatus, TopicInfo};\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","status.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse super::metrics::GossipMetricsSummary;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ConnectionStatus {\n    Connected,\n    Connecting,\n    #[default]\n    Disconnected,\n    Error,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerStatus {\n    pub node_id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatus {\n    pub connected: bool,\n    pub connection_status: ConnectionStatus,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicInfo>,\n    pub peer_count: usize,\n    pub peers: Vec<PeerStatus>,\n    pub metrics_summary: GossipMetricsSummary,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicInfo {\n    pub id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service","tests.rs"],"content":"use super::core::{P2PService, P2PServiceTrait};\nuse crate::application::services::p2p_service::status::ConnectionStatus;\nuse crate::domain::constants::TOPIC_NAMESPACE;\nuse crate::domain::p2p::TopicStats;\nuse crate::infrastructure::p2p::network_service::Peer;\nuse crate::infrastructure::p2p::{GossipService, NetworkService, metrics};\nuse crate::shared::{AppError, config::BootstrapSource};\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse mockall::{mock, predicate::*};\nuse std::sync::{Arc, Mutex};\n\npub struct MockNetworkServ {\n    node_id: Mutex<Option<String>>,\n    addresses: Mutex<Option<Vec<String>>>,\n    join_dht: Mutex<Vec<String>>,\n    leave_dht: Mutex<Vec<String>>,\n    broadcast_dht: Mutex<Vec<(String, Vec<u8>)>>,\n    connected: Mutex<bool>,\n    peers: Mutex<Vec<Peer>>,\n    applied_bootstrap_nodes: Mutex<Vec<String>>,\n    applied_bootstrap_source: Mutex<Option<BootstrapSource>>,\n}\n\nimpl MockNetworkServ {\n    pub fn new() -> Self {\n        Self {\n            node_id: Mutex::new(None),\n            addresses: Mutex::new(None),\n            join_dht: Mutex::new(Vec::new()),\n            leave_dht: Mutex::new(Vec::new()),\n            broadcast_dht: Mutex::new(Vec::new()),\n            connected: Mutex::new(true),\n            peers: Mutex::new(Vec::new()),\n            applied_bootstrap_nodes: Mutex::new(Vec::new()),\n            applied_bootstrap_source: Mutex::new(None),\n        }\n    }\n\n    pub fn expect_get_node_id(&mut self) -> &mut Self {\n        self\n    }\n\n    pub fn returning<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce() -> Result<String, AppError> + 'static,\n    {\n        if let Ok(value) = f() {\n            *self.node_id.lock().unwrap() = Some(value);\n        }\n        self\n    }\n\n    pub fn expect_get_addresses(&mut self) -> &mut Self {\n        self\n    }\n\n    pub fn returning_addresses<F>(&mut self, f: F) -> &mut Self\n    where\n        F: FnOnce() -> Result<Vec<String>, AppError> + 'static,\n    {\n        if let Ok(value) = f() {\n            *self.addresses.lock().unwrap() = Some(value);\n        }\n        self\n    }\n\n    pub fn join_dht_calls(&self) -> Vec<String> {\n        self.join_dht.lock().unwrap().clone()\n    }\n\n    pub fn leave_dht_calls(&self) -> Vec<String> {\n        self.leave_dht.lock().unwrap().clone()\n    }\n\n    pub fn broadcast_dht_calls(&self) -> Vec<(String, Vec<u8>)> {\n        self.broadcast_dht.lock().unwrap().clone()\n    }\n\n    pub fn set_connected(&self, connected: bool) {\n        *self.connected.lock().unwrap() = connected;\n    }\n\n    pub fn set_peers(&self, peers: Vec<Peer>) {\n        *self.peers.lock().unwrap() = peers;\n    }\n\n    pub fn applied_bootstrap_nodes(&self) -> Vec<String> {\n        self.applied_bootstrap_nodes.lock().unwrap().clone()\n    }\n\n    pub fn applied_bootstrap_source(&self) -> Option<BootstrapSource> {\n        *self.applied_bootstrap_source.lock().unwrap()\n    }\n}\n\n#[async_trait]\nimpl NetworkService for MockNetworkServ {\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n\n    async fn connect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_peers(\n        &self,\n    ) -> Result<Vec<crate::infrastructure::p2p::network_service::Peer>, AppError> {\n        Ok(self.peers.lock().unwrap().clone())\n    }\n\n    async fn add_peer(&self, _address: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn remove_peer(&self, _peer_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_stats(\n        &self,\n    ) -> Result<crate::infrastructure::p2p::network_service::NetworkStats, AppError> {\n        Ok(crate::infrastructure::p2p::network_service::NetworkStats {\n            connected_peers: 0,\n            total_messages_sent: 0,\n            total_messages_received: 0,\n            bandwidth_up: 0,\n            bandwidth_down: 0,\n        })\n    }\n\n    async fn is_connected(&self) -> bool {\n        *self.connected.lock().unwrap()\n    }\n\n    async fn get_node_id(&self) -> Result<String, AppError> {\n        let node_id = self.node_id.lock().unwrap();\n        Ok(node_id\n            .clone()\n            .unwrap_or_else(|| \"default_node_id\".to_string()))\n    }\n\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\n        let addresses = self.addresses.lock().unwrap();\n        Ok(addresses.clone().unwrap_or_else(std::vec::Vec::new))\n    }\n\n    async fn join_dht_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.join_dht.lock().unwrap().push(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_dht_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.leave_dht.lock().unwrap().push(topic.to_string());\n        Ok(())\n    }\n\n    async fn broadcast_dht(&self, topic: &str, message: Vec<u8>) -> Result<(), AppError> {\n        self.broadcast_dht\n            .lock()\n            .unwrap()\n            .push((topic.to_string(), message));\n        Ok(())\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        *self.applied_bootstrap_nodes.lock().unwrap() = nodes;\n        *self.applied_bootstrap_source.lock().unwrap() = Some(source);\n        Ok(())\n    }\n}\n\nmock! {\n    pub GossipServ {}\n\n    #[async_trait]\n    impl GossipService for GossipServ {\n        fn local_peer_hint(&self) -> Option<String>;\n        async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n        async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\n        async fn broadcast(&self, topic: &str, event: &crate::domain::entities::Event) -> Result<(), AppError>;\n        async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<crate::domain::entities::Event>, AppError>;\n        async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n        async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n        async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n        async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n    }\n}\n\n#[tokio::test]\nasync fn test_initialize() {\n    let network = Arc::new(MockNetworkServ::new());\n    let gossip = Arc::new(MockGossipServ::new());\n\n    let service = P2PService::new(network, gossip);\n\n    let result = service.initialize().await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_apply_bootstrap_nodes_forwards_to_network() {\n    let network = Arc::new(MockNetworkServ::new());\n    let gossip = Arc::new(MockGossipServ::new());\n    let service = P2PService::new(\n        Arc::clone(&network) as Arc<dyn NetworkService>,\n        gossip as Arc<dyn GossipService>,\n    );\n\n    let nodes = vec![\n        \"node1@127.0.0.1:44001\".to_string(),\n        \"node2@127.0.0.1:44002\".to_string(),\n    ];\n\n    service\n        .apply_bootstrap_nodes(nodes.clone(), BootstrapSource::User)\n        .await\n        .expect(\"apply bootstrap nodes\");\n\n    assert_eq!(network.applied_bootstrap_nodes(), nodes);\n    assert_eq!(\n        network.applied_bootstrap_source(),\n        Some(BootstrapSource::User)\n    );\n}\n\n#[tokio::test]\nasync fn test_join_topic_success() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_join_topic()\n        .with(\n            eq(\"test_topic\"),\n            eq(vec![\"peer1\".to_string(), \"peer2\".to_string()]),\n        )\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service\n        .join_topic(\"test_topic\", vec![\"peer1\".to_string(), \"peer2\".to_string()])\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(network.join_dht_calls(), vec![\"test_topic\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_join_topic_failure() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_join_topic()\n        .with(eq(\"fail_topic\"), eq(Vec::<String>::new()))\n        .times(1)\n        .returning(|_, _| Err(AppError::P2PError(\"join failed\".into())));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.join_topic(\"fail_topic\", Vec::new()).await;\n    assert!(result.is_err());\n    assert!(network.join_dht_calls().is_empty());\n}\n\n#[tokio::test]\nasync fn test_leave_topic_success() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_leave_topic()\n        .with(eq(\"test_topic\"))\n        .times(1)\n        .returning(|_| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.leave_topic(\"test_topic\").await;\n    assert!(result.is_ok());\n    assert_eq!(network.leave_dht_calls(), vec![\"test_topic\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_leave_topic_failure() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_leave_topic()\n        .with(eq(\"fail_topic\"))\n        .times(1)\n        .returning(|_| Err(AppError::P2PError(\"leave failed\".into())));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.leave_topic(\"fail_topic\").await;\n    assert!(result.is_err());\n    assert!(network.leave_dht_calls().is_empty());\n}\n\n#[tokio::test]\nasync fn test_broadcast_message() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"test_topic\".to_string()]));\n\n    let test_content = \"Test message\";\n    mock_gossip\n        .expect_broadcast_message()\n        .with(eq(\"test_topic\"), eq(test_content.as_bytes()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n\n    let result = service.broadcast_message(\"test_topic\", test_content).await;\n    assert!(result.is_ok());\n    assert_eq!(network.join_dht_calls(), vec![\"test_topic\".to_string()]);\n    let broadcast_calls = network.broadcast_dht_calls();\n    assert_eq!(broadcast_calls.len(), 1);\n    assert_eq!(broadcast_calls[0].0, \"test_topic\".to_string());\n    assert_eq!(String::from_utf8_lossy(&broadcast_calls[0].1), test_content);\n}\n\n#[tokio::test]\nasync fn test_broadcast_message_auto_join_when_not_joined() {\n    let network = Arc::new(MockNetworkServ::new());\n    let mut mock_gossip = MockGossipServ::new();\n\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![]));\n\n    mock_gossip\n        .expect_join_topic()\n        .with(eq(\"auto_topic\"), eq(Vec::<String>::new()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    mock_gossip\n        .expect_broadcast_message()\n        .with(eq(\"auto_topic\"), eq(\"auto payload\".as_bytes()))\n        .times(1)\n        .returning(|_, _| Ok(()));\n\n    let service = P2PService::new(network.clone(), Arc::new(mock_gossip));\n    let result = service\n        .broadcast_message(\"auto_topic\", \"auto payload\")\n        .await;\n    assert!(result.is_ok());\n\n    assert_eq!(network.join_dht_calls(), vec![\"auto_topic\".to_string()]);\n    let broadcast_calls = network.broadcast_dht_calls();\n    assert_eq!(broadcast_calls.len(), 1);\n    assert_eq!(broadcast_calls[0].0, \"auto_topic\".to_string());\n    assert_eq!(\n        String::from_utf8_lossy(&broadcast_calls[0].1),\n        \"auto payload\"\n    );\n}\n\n#[tokio::test]\nasync fn test_get_status() {\n    metrics::reset_all();\n    let mut mock_network = MockNetworkServ::new();\n    mock_network\n        .expect_get_node_id()\n        .returning(|| Ok(\"node123\".to_string()));\n    let network = Arc::new(mock_network);\n    network.set_connected(false);\n    network.set_peers(Vec::new());\n    assert!(!network.is_connected().await);\n\n    network.set_connected(true);\n    let now = Utc::now().timestamp();\n    network.set_peers(vec![\n        Peer {\n            id: \"peer-1\".to_string(),\n            address: \"/ip4/127.0.0.1/tcp/4001\".to_string(),\n            connected_at: now,\n            last_seen: now,\n        },\n        Peer {\n            id: \"peer-2\".to_string(),\n            address: \"/ip4/127.0.0.1/tcp/4002\".to_string(),\n            connected_at: now,\n            last_seen: now,\n        },\n    ]);\n\n    let mut mock_gossip = MockGossipServ::new();\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"topic1\".to_string(), \"topic2\".to_string()]));\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| {\n            Ok(Some(TopicStats {\n                peer_count: 5,\n                message_count: 12,\n                last_activity: 1_700_000_000,\n            }))\n        });\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic2\"))\n        .times(1)\n        .returning(|_| {\n            Ok(Some(TopicStats {\n                peer_count: 3,\n                message_count: 4,\n                last_activity: 1_700_000_100,\n            }))\n        });\n\n    let service = P2PService::new(network, Arc::new(mock_gossip));\n\n    let result = service.get_status().await;\n    assert!(result.is_ok());\n\n    let status = result.unwrap();\n    assert_eq!(status.endpoint_id, \"node123\");\n    assert!(status.connected);\n    assert_eq!(status.connection_status, ConnectionStatus::Connected);\n    assert_eq!(status.active_topics.len(), 2);\n    assert_eq!(status.peer_count, 8);\n    assert_eq!(status.metrics_summary.joins, 0);\n    assert_eq!(status.metrics_summary.leaves, 0);\n    assert_eq!(status.metrics_summary.broadcasts_sent, 0);\n    assert_eq!(status.metrics_summary.messages_received, 0);\n    assert_eq!(status.active_topics[0].message_count, 12);\n    assert_eq!(status.active_topics[0].last_activity, 1_700_000_000);\n    assert_eq!(status.active_topics[1].message_count, 4);\n    assert_eq!(status.active_topics[1].last_activity, 1_700_000_100);\n    assert_eq!(status.peers.len(), 2);\n    assert_eq!(status.peers[0].node_id, \"peer-1\");\n}\n\n#[tokio::test]\nasync fn test_get_status_fallback_to_peers_when_stats_missing() {\n    metrics::reset_all();\n    let mut mock_network = MockNetworkServ::new();\n    mock_network\n        .expect_get_node_id()\n        .returning(|| Ok(\"node123\".to_string()));\n    let network = Arc::new(mock_network);\n\n    let mut mock_gossip = MockGossipServ::new();\n    mock_gossip\n        .expect_get_joined_topics()\n        .times(1)\n        .returning(|| Ok(vec![\"topic1\".to_string()]));\n\n    mock_gossip\n        .expect_get_topic_stats()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| Ok(None));\n\n    mock_gossip\n        .expect_get_topic_peers()\n        .with(eq(\"topic1\"))\n        .times(1)\n        .returning(|_| Ok(vec![\"peer1\".to_string(), \"peer2\".to_string()]));\n\n    let service = P2PService::new(network, Arc::new(mock_gossip));\n\n    let before = Utc::now().timestamp();\n    let status = service.get_status().await.unwrap();\n    let after = Utc::now().timestamp();\n\n    assert_eq!(status.active_topics.len(), 1);\n    let topic = &status.active_topics[0];\n    assert_eq!(topic.peer_count, 2);\n    assert_eq!(topic.message_count, 0);\n    assert!(topic.last_activity >= before);\n    assert!(topic.last_activity <= after);\n    assert_eq!(status.connection_status, ConnectionStatus::Disconnected);\n}\n\n#[tokio::test]\nasync fn test_get_node_addresses() {\n    let mut mock_network = MockNetworkServ::new();\n    mock_network.expect_get_addresses().returning_addresses(|| {\n        Ok(vec![\n            \"/ip4/127.0.0.1/tcp/4001\".to_string(),\n            \"/ip4/192.168.1.10/tcp/4001\".to_string(),\n        ])\n    });\n\n    let mock_gossip = MockGossipServ::new();\n\n    let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n    let result = service.get_node_addresses().await;\n    assert!(result.is_ok());\n\n    let addresses = result.unwrap();\n    assert_eq!(addresses.len(), 2);\n    assert!(addresses.contains(&\"/ip4/127.0.0.1/tcp/4001\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_generate_topic_id() {\n    let mock_network = MockNetworkServ::new();\n    let mock_gossip = MockGossipServ::new();\n\n    let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n    let topic_id1 = service.generate_topic_id(\"test_topic\");\n    let topic_id2 = service.generate_topic_id(\"test_topic\");\n    let topic_id3 = service.generate_topic_id(\"different_topic\");\n\n    assert_eq!(topic_id1, topic_id2);\n    assert_ne!(topic_id1, topic_id3);\n    assert!(topic_id1.starts_with(TOPIC_NAMESPACE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","post_service.rs"],"content":"use crate::application::ports::cache::PostCache;\nuse crate::application::ports::group_key_store::GroupKeyStore;\nuse crate::application::ports::repositories::{BookmarkRepository, PostFeedCursor, PostRepository};\nuse crate::application::services::event_service::EventServiceTrait;\nuse crate::domain::entities::{Post, User};\nuse crate::domain::value_objects::{EncryptedPostPayload, EventId, PublicKey};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::STANDARD};\nuse chrono::Utc;\nuse nostr_sdk::prelude::nip44;\nuse nostr_sdk::prelude::nip44::v2::ConversationKey;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse tracing::warn;\n\nconst ENCRYPTED_PLACEHOLDER: &str = \"[Encrypted post]\";\nconst PRIVATE_SCOPES: [&str; 3] = [\"friend\", \"friend_plus\", \"invite\"];\n\npub struct PostService {\n    repository: Arc<dyn PostRepository>,\n    bookmark_repository: Arc<dyn BookmarkRepository>,\n    event_service: Arc<dyn EventServiceTrait>,\n    cache: Arc<dyn PostCache>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n}\n\n#[derive(Debug, Clone)]\npub struct FollowingFeedPage {\n    pub items: Vec<Post>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub server_time: i64,\n}\n\nimpl PostService {\n    fn normalize_scope(scope: Option<String>) -> Result<Option<String>, AppError> {\n        let scope = scope\n            .map(|value| value.trim().to_string())\n            .filter(|value| !value.is_empty());\n        let Some(value) = scope.as_deref() else {\n            return Ok(None);\n        };\n        if value == \"public\" {\n            return Ok(None);\n        }\n        if PRIVATE_SCOPES.contains(&value) {\n            return Ok(Some(value.to_string()));\n        }\n        Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid scope: {value}\"),\n        ))\n    }\n\n    fn conversation_key_from_b64(key_b64: &str) -> Result<ConversationKey, AppError> {\n        let bytes = STANDARD\n            .decode(key_b64)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid group key: {err}\")))?;\n        ConversationKey::from_slice(&bytes)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid group key: {err}\")))\n    }\n\n    fn encrypt_with_group_key(key_b64: &str, plaintext: &str) -> Result<String, AppError> {\n        let conversation_key = Self::conversation_key_from_b64(key_b64)?;\n        let payload = nip44::v2::encrypt_to_bytes(&conversation_key, plaintext.as_bytes())\n            .map_err(|err| AppError::Crypto(format!(\"Encrypt failed: {err}\")))?;\n        Ok(STANDARD.encode(payload))\n    }\n\n    fn decrypt_with_group_key(key_b64: &str, payload_b64: &str) -> Result<String, AppError> {\n        let conversation_key = Self::conversation_key_from_b64(key_b64)?;\n        let payload = STANDARD\n            .decode(payload_b64)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid payload: {err}\")))?;\n        let decrypted = nip44::v2::decrypt_to_bytes(&conversation_key, &payload)\n            .map_err(|err| AppError::Crypto(format!(\"Decrypt failed: {err}\")))?;\n        String::from_utf8(decrypted)\n            .map_err(|err| AppError::Crypto(format!(\"Decrypt failed: {err}\")))\n    }\n\n    async fn encrypt_post_content(\n        &self,\n        content: &str,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<(String, i64), AppError> {\n        let record = self\n            .group_key_store\n            .get_latest_key(topic_id, scope)\n            .await?\n            .ok_or_else(|| {\n                AppError::validation(\n                    ValidationFailureKind::Generic,\n                    format!(\"Group key not found for {topic_id}:{scope}\"),\n                )\n            })?;\n        let payload_b64 = Self::encrypt_with_group_key(&record.key_b64, content)?;\n        let payload = EncryptedPostPayload::new(\n            topic_id.to_string(),\n            scope.to_string(),\n            record.epoch,\n            payload_b64,\n        );\n        let json = serde_json::to_string(&payload)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        Ok((json, record.epoch))\n    }\n\n    async fn prepare_post(&self, mut post: Post) -> Result<Post, AppError> {\n        let Some(payload) = EncryptedPostPayload::try_parse(&post.content) else {\n            return Ok(post);\n        };\n        post.is_encrypted = true;\n        if post.scope.is_none() {\n            post.scope = Some(payload.scope.clone());\n        }\n        if post.epoch.is_none() {\n            post.epoch = Some(payload.epoch);\n        }\n\n        let record = self\n            .group_key_store\n            .get_key(&payload.topic, &payload.scope, payload.epoch)\n            .await?;\n        let Some(record) = record else {\n            post.content = ENCRYPTED_PLACEHOLDER.to_string();\n            return Ok(post);\n        };\n\n        match Self::decrypt_with_group_key(&record.key_b64, &payload.payload_b64) {\n            Ok(content) => {\n                post.content = content;\n            }\n            Err(_) => {\n                post.content = ENCRYPTED_PLACEHOLDER.to_string();\n            }\n        }\n\n        Ok(post)\n    }\n\n    async fn prepare_posts(&self, posts: Vec<Post>) -> Result<Vec<Post>, AppError> {\n        let mut prepared = Vec::with_capacity(posts.len());\n        for post in posts {\n            prepared.push(self.prepare_post(post).await?);\n        }\n        Ok(prepared)\n    }\n\n    pub fn new(\n        repository: Arc<dyn PostRepository>,\n        bookmark_repository: Arc<dyn BookmarkRepository>,\n        event_service: Arc<dyn EventServiceTrait>,\n        cache: Arc<dyn PostCache>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n    ) -> Self {\n        Self {\n            repository,\n            bookmark_repository,\n            event_service,\n            cache,\n            group_key_store,\n        }\n    }\n\n    pub async fn create_post(\n        &self,\n        content: String,\n        author: User,\n        topic_id: String,\n        scope: Option<String>,\n    ) -> Result<Post, AppError> {\n        let scope = Self::normalize_scope(scope)?;\n        let mut post = Post::new(content.clone(), author, topic_id.clone());\n\n        if let Some(ref scope_value) = scope {\n            let (encrypted_content, epoch) = self\n                .encrypt_post_content(&content, &topic_id, scope_value)\n                .await?;\n            post.content = encrypted_content;\n            post.scope = Some(scope_value.clone());\n            post.epoch = Some(epoch);\n            post.is_encrypted = true;\n        }\n\n        self.repository.create_post(&post).await?;\n\n        match self\n            .event_service\n            .publish_topic_post(\n                &topic_id,\n                &post.content,\n                None,\n                post.scope.as_deref(),\n                post.epoch,\n            )\n            .await\n        {\n            Ok(event_id) => {\n                let event_hex = event_id.to_string();\n                post.mark_as_synced(event_hex.clone());\n                self.repository\n                    .mark_post_synced(&post.id, &event_hex)\n                    .await?;\n            }\n            Err(err) => {\n                self.cache.add(post.clone()).await;\n                return Err(err);\n            }\n        }\n\n        let prepared = self.prepare_post(post.clone()).await?;\n        self.cache.add(prepared.clone()).await;\n        Ok(prepared)\n    }\n\n    pub async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        // キャッシュから取得を試みる\n        if let Some(post) = self.cache.get(id).await {\n            return Ok(Some(self.prepare_post(post).await?));\n        }\n\n        // キャッシュにない場合はDBから取得\n        let post = self.repository.get_post(id).await?;\n\n        // キャッシュに保存\n        if let Some(post) = post {\n            let prepared = self.prepare_post(post).await?;\n            self.cache.add(prepared.clone()).await;\n            return Ok(Some(prepared));\n        }\n\n        Ok(None)\n    }\n\n    pub async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        if limit == 0 {\n            return Ok(Vec::new());\n        }\n\n        let cached_all = self.cache.get_by_topic(topic_id, usize::MAX).await;\n        if cached_all.len() >= limit {\n            return Ok(cached_all.into_iter().take(limit).collect());\n        }\n\n        let mut posts = self.repository.get_posts_by_topic(topic_id, limit).await?;\n\n        if !cached_all.is_empty() {\n            let mut seen: HashSet<String> = posts.iter().map(|post| post.id.clone()).collect();\n            for cached in cached_all {\n                if seen.insert(cached.id.clone()) {\n                    posts.push(cached);\n                }\n            }\n        }\n\n        posts.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n\n        let prepared = self.prepare_posts(posts).await?;\n\n        // キャッシュにも最新の取得結果を反映\n        self.cache.set_topic_posts(topic_id, prepared.clone()).await;\n\n        Ok(prepared.into_iter().take(limit).collect())\n    }\n\n    pub async fn like_post(&self, post_id: &str) -> Result<(), AppError> {\n        self.react_to_post(post_id, \"+\").await\n    }\n\n    pub async fn boost_post(&self, post_id: &str) -> Result<(), AppError> {\n        self.event_service.boost_post(post_id).await?;\n\n        if let Some(mut post) = self.repository.get_post(post_id).await? {\n            post.increment_boosts();\n            self.repository.update_post(&post).await?;\n            self.cache.remove(post_id).await;\n        }\n\n        Ok(())\n    }\n\n    pub async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        self.event_service\n            .delete_events(vec![id.to_string()], Some(\"Post deleted\".to_string()))\n            .await?;\n        self.repository.delete_post(id).await?;\n        self.cache.remove(id).await;\n        Ok(())\n    }\n\n    pub async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let posts = self\n            .repository\n            .get_posts_by_author(author_pubkey, limit)\n            .await?;\n        self.prepare_posts(posts).await\n    }\n\n    pub async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        let posts = self.repository.get_recent_posts(limit).await?;\n        self.prepare_posts(posts).await\n    }\n\n    pub async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<&str>,\n        limit: usize,\n    ) -> Result<FollowingFeedPage, AppError> {\n        let limit = limit.clamp(1, 100);\n        let parsed_cursor = cursor.and_then(PostFeedCursor::parse);\n        let page = self\n            .repository\n            .list_following_feed(follower_pubkey, parsed_cursor, limit)\n            .await?;\n        let items = self.prepare_posts(page.items).await?;\n\n        Ok(FollowingFeedPage {\n            items,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            server_time: Utc::now().timestamp_millis(),\n        })\n    }\n\n    pub async fn react_to_post(&self, post_id: &str, reaction: &str) -> Result<(), AppError> {\n        self.event_service.send_reaction(post_id, reaction).await?;\n\n        if reaction == \"+\" {\n            if let Some(mut post) = self.repository.get_post(post_id).await? {\n                post.increment_likes();\n                self.repository.update_post(&post).await?;\n                self.cache.remove(post_id).await;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub async fn bookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        self.bookmark_repository\n            .create_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn unbookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        self.bookmark_repository\n            .delete_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn get_bookmarked_post_ids(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let public_key = PublicKey::from_hex_str(user_pubkey)\n            .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))?;\n\n        let bookmarks = self.bookmark_repository.list_bookmarks(&public_key).await?;\n\n        Ok(bookmarks\n            .into_iter()\n            .map(|bookmark| bookmark.post_id().as_str().to_string())\n            .collect())\n    }\n\n    pub async fn sync_pending_posts(&self) -> Result<u32, AppError> {\n        let unsynced_posts = self.repository.get_unsync_posts().await?;\n        let mut synced_count = 0;\n\n        for mut post in unsynced_posts {\n            match self\n                .event_service\n                .publish_topic_post(\n                    &post.topic_id,\n                    &post.content,\n                    None,\n                    post.scope.as_deref(),\n                    post.epoch,\n                )\n                .await\n            {\n                Ok(event_id) => {\n                    let event_hex = event_id.to_string();\n                    post.mark_as_synced(event_hex.clone());\n                    self.repository\n                        .mark_post_synced(&post.id, &event_hex)\n                        .await?;\n                    synced_count += 1;\n                }\n                Err(err) => {\n                    warn!(\"failed to sync post {post_id}: {err}\", post_id = post.id);\n                }\n            }\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[async_trait]\nimpl super::sync_service::SyncParticipant for PostService {\n    async fn sync_pending(&self) -> Result<u32, AppError> {\n        self.sync_pending_posts().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::cache::PostCache;\n    use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord};\n    use crate::application::ports::repositories::{\n        BookmarkRepository, PostRepository, UserRepository,\n    };\n    use crate::application::services::SubscriptionRecord;\n    use crate::infrastructure::cache::PostCacheService;\n    use crate::infrastructure::database::Repository;\n    use crate::infrastructure::database::{\n        connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\n    };\n    use crate::presentation::dto::event::NostrMetadataDto;\n    use chrono::{TimeZone, Utc};\n    use std::sync::Arc;\n    use std::time::Duration;\n    use tokio::sync::Mutex;\n    use tokio::time::sleep;\n\n    struct TestGroupKeyStore {\n        records: Mutex<Vec<GroupKeyRecord>>,\n    }\n\n    impl TestGroupKeyStore {\n        fn new() -> Self {\n            Self {\n                records: Mutex::new(Vec::new()),\n            }\n        }\n    }\n\n    #[async_trait]\n    impl GroupKeyStore for TestGroupKeyStore {\n        async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n            let mut guard = self.records.lock().await;\n            if let Some(existing) = guard.iter_mut().find(|entry| {\n                entry.topic_id == record.topic_id\n                    && entry.scope == record.scope\n                    && entry.epoch == record.epoch\n            }) {\n                *existing = record;\n            } else {\n                guard.push(record);\n            }\n            Ok(())\n        }\n\n        async fn get_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n            epoch: i64,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .find(|entry| {\n                    entry.topic_id == topic_id && entry.scope == scope && entry.epoch == epoch\n                })\n                .cloned())\n        }\n\n        async fn get_latest_key(\n            &self,\n            topic_id: &str,\n            scope: &str,\n        ) -> Result<Option<GroupKeyRecord>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .filter(|entry| entry.topic_id == topic_id && entry.scope == scope)\n                .max_by_key(|entry| entry.epoch)\n                .cloned())\n        }\n\n        async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n            let guard = self.records.lock().await;\n            Ok(guard\n                .iter()\n                .map(|entry| GroupKeyEntry {\n                    topic_id: entry.topic_id.clone(),\n                    scope: entry.scope.clone(),\n                    epoch: entry.epoch,\n                    stored_at: entry.stored_at,\n                })\n                .collect())\n        }\n    }\n\n    struct TestEventService {\n        publish_topic_post_result: Mutex<Option<Result<EventId, AppError>>>,\n    }\n\n    impl TestEventService {\n        fn new() -> Self {\n            Self {\n                publish_topic_post_result: Mutex::new(None),\n            }\n        }\n\n        fn with_publish_result(result: Result<EventId, AppError>) -> Self {\n            Self {\n                publish_topic_post_result: Mutex::new(Some(result)),\n            }\n        }\n\n        async fn next_publish_result(&self) -> Result<EventId, AppError> {\n            let mut guard = self.publish_topic_post_result.lock().await;\n            guard.take().unwrap_or_else(|| Ok(EventId::generate()))\n        }\n    }\n\n    impl Default for TestEventService {\n        fn default() -> Self {\n            Self::new()\n        }\n    }\n\n    #[async_trait]\n    impl EventServiceTrait for TestEventService {\n        async fn initialize(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn publish_text_note(&self, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn publish_topic_post(\n            &self,\n            _: &str,\n            _: &str,\n            _: Option<&str>,\n            _: Option<&str>,\n            _: Option<i64>,\n        ) -> Result<EventId, AppError> {\n            self.next_publish_result().await\n        }\n        async fn send_reaction(&self, _: &str, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn update_metadata(&self, _: NostrMetadataDto) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn subscribe_to_topic(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn subscribe_to_user(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n            Ok(None)\n        }\n        async fn boost_post(&self, _: &str) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn delete_events(\n            &self,\n            _: Vec<String>,\n            _: Option<String>,\n        ) -> Result<EventId, AppError> {\n            Ok(EventId::generate())\n        }\n        async fn disconnect(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn set_default_p2p_topic(&self, _: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n        async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n            Ok(vec![])\n        }\n    }\n\n    async fn setup_post_service_with_deps(\n        event_service: Arc<dyn EventServiceTrait>,\n    ) -> (PostService, Arc<SqliteRepository>, Arc<PostCacheService>) {\n        let (service, repository, cache, _group_key_store) =\n            setup_post_service_with_group_store(event_service).await;\n\n        (service, repository, cache)\n    }\n\n    async fn setup_post_service_with_group_store(\n        event_service: Arc<dyn EventServiceTrait>,\n    ) -> (\n        PostService,\n        Arc<SqliteRepository>,\n        Arc<PostCacheService>,\n        Arc<TestGroupKeyStore>,\n    ) {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            )\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create bookmarks table\");\n\n        let repository = Arc::new(SqliteRepository::new(pool));\n        repository\n            .initialize()\n            .await\n            .expect(\"failed to initialize repository schema\");\n        let cache = Arc::new(PostCacheService::new());\n        let group_key_store = Arc::new(TestGroupKeyStore::new());\n        let group_key_store_trait: Arc<dyn GroupKeyStore> = group_key_store.clone();\n\n        let service = PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            event_service,\n            Arc::clone(&cache) as Arc<dyn PostCache>,\n            group_key_store_trait,\n        );\n\n        (service, repository, cache, group_key_store)\n    }\n\n    async fn setup_post_service() -> PostService {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        setup_post_service_with_deps(event_service).await.0\n    }\n\n    fn sample_user() -> User {\n        User {\n            npub: \"npub1test\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: \"Test User\".to_string(),\n                bio: \"Test bio\".to_string(),\n                avatar_url: None,\n            },\n            name: Some(\"Test User\".to_string()),\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        }\n    }\n\n    const SAMPLE_PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    #[tokio::test]\n    async fn bookmark_flow_roundtrip() {\n        let service = setup_post_service().await;\n        let event_id = EventId::generate();\n        let event_hex = event_id.to_hex();\n\n        service\n            .bookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"bookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks\");\n        assert_eq!(bookmarked, vec![event_hex.clone()]);\n\n        service\n            .unbookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"unbookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks after removal\");\n        assert!(bookmarked.is_empty());\n    }\n\n    #[tokio::test]\n    async fn create_post_marks_synced_after_publish() {\n        let expected_event = EventId::generate();\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(\n            TestEventService::with_publish_result(Ok(expected_event.clone())),\n        );\n\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let expected_event_hex = expected_event.to_string();\n\n        let post = service\n            .create_post(\n                \"hello world\".into(),\n                sample_user(),\n                \"topic-sync\".into(),\n                None,\n            )\n            .await\n            .expect(\"post creation succeeds\");\n\n        assert!(post.is_synced);\n        assert_eq!(post.event_id.as_deref(), Some(expected_event_hex.as_str()));\n\n        let stored = repository\n            .get_post(&post.id)\n            .await\n            .expect(\"db query succeeds\")\n            .expect(\"post present in db\");\n        assert_eq!(stored.id, post.id);\n\n        let unsynced = repository\n            .get_unsync_posts()\n            .await\n            .expect(\"unsynced query succeeds\");\n        assert!(unsynced.is_empty(), \"all posts should be marked synced\");\n\n        let cached = cache\n            .get(&post.id)\n            .await\n            .expect(\"post cached after creation\");\n        assert_eq!(cached.event_id.as_deref(), post.event_id.as_deref());\n    }\n\n    #[tokio::test]\n    async fn create_private_post_encrypts_and_decrypts() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, _cache, group_key_store) =\n            setup_post_service_with_group_store(event_service).await;\n\n        let key_b64 = STANDARD.encode([7u8; 32]);\n        let record = GroupKeyRecord {\n            topic_id: \"topic-private\".to_string(),\n            scope: \"friend\".to_string(),\n            epoch: 2,\n            key_b64,\n            stored_at: Utc::now().timestamp(),\n        };\n        group_key_store\n            .store_key(record.clone())\n            .await\n            .expect(\"store group key\");\n\n        let post = service\n            .create_post(\n                \"secret message\".into(),\n                sample_user(),\n                \"topic-private\".into(),\n                Some(\"friend\".into()),\n            )\n            .await\n            .expect(\"create private post\");\n\n        assert_eq!(post.content, \"secret message\");\n        assert!(post.is_encrypted);\n        assert_eq!(post.scope.as_deref(), Some(\"friend\"));\n        assert_eq!(post.epoch, Some(record.epoch));\n\n        let stored = repository\n            .get_post(&post.id)\n            .await\n            .expect(\"db fetch\")\n            .expect(\"stored post\");\n        assert_ne!(stored.content, \"secret message\");\n        let payload =\n            EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n        assert_eq!(payload.scope, \"friend\");\n        assert_eq!(payload.epoch, record.epoch);\n    }\n\n    #[tokio::test]\n    async fn create_post_caches_on_publish_failure() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(\n            TestEventService::with_publish_result(Err(AppError::NostrError(\"failed\".into()))),\n        );\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n\n        let err = service\n            .create_post(\n                \"offline\".into(),\n                sample_user(),\n                \"topic-offline\".into(),\n                None,\n            )\n            .await\n            .expect_err(\"publish failure propagates\");\n        assert!(matches!(err, AppError::NostrError(_)));\n\n        let stored = repository\n            .get_posts_by_topic(\"topic-offline\", 10)\n            .await\n            .expect(\"query succeeds\");\n        assert_eq!(stored.len(), 1);\n        let stored_post = &stored[0];\n        assert!(!stored_post.is_synced);\n        assert!(stored_post.event_id.is_none());\n\n        let unsynced = repository\n            .get_unsync_posts()\n            .await\n            .expect(\"unsynced query succeeds\");\n        assert_eq!(\n            unsynced.len(),\n            1,\n            \"failed publish should remain in unsynced queue\"\n        );\n\n        let cached = cache\n            .get(&stored_post.id)\n            .await\n            .expect(\"unsynced post cached for retry\");\n        assert_eq!(cached.id, stored_post.id);\n        assert!(!cached.is_synced);\n    }\n\n    #[tokio::test]\n    async fn list_following_feed_returns_posts_in_desc_order() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, _cache) = setup_post_service_with_deps(event_service).await;\n\n        let follower_pubkey = \"followerpub\";\n        let followed_pubkey = \"followedpub\";\n\n        repository\n            .add_follow_relation(follower_pubkey, followed_pubkey)\n            .await\n            .expect(\"follow relation\");\n\n        let mut author = sample_user();\n        author.pubkey = followed_pubkey.to_string();\n        author.npub = format!(\"npub_{followed_pubkey}\");\n\n        let first_post = service\n            .create_post(\"first\".into(), author.clone(), \"trend\".into(), None)\n            .await\n            .expect(\"create first post\");\n        sleep(Duration::from_millis(5)).await;\n        let second_post = service\n            .create_post(\"second\".into(), author.clone(), \"trend\".into(), None)\n            .await\n            .expect(\"create second post\");\n\n        assert_ne!(first_post.id, second_post.id);\n\n        let raw_page = repository\n            .list_following_feed(follower_pubkey, None, 5)\n            .await\n            .expect(\"raw page\");\n        assert_eq!(raw_page.items.len(), 2);\n\n        let page_one = service\n            .list_following_feed(follower_pubkey, None, 1)\n            .await\n            .expect(\"page one\");\n        assert_eq!(page_one.items.len(), 1);\n        let newest_id = page_one.items[0].id.clone();\n        assert_eq!(newest_id, second_post.id);\n        assert!(page_one.has_more);\n        let next_cursor = page_one.next_cursor.clone();\n\n        let page_two = service\n            .list_following_feed(follower_pubkey, next_cursor.as_deref(), 1)\n            .await\n            .expect(\"page two\");\n        assert_eq!(page_two.items.len(), 1);\n        assert_eq!(page_two.items[0].id, first_post.id);\n        assert!(!page_two.has_more);\n    }\n\n    #[tokio::test]\n    async fn get_posts_by_topic_prefers_cache_when_available() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let topic_id = \"topic-cache\";\n\n        let mut posts = Vec::new();\n        for (idx, ts) in [10_i64, 20, 30].into_iter().enumerate() {\n            let mut post = Post::new(format!(\"post-{idx}\"), sample_user(), topic_id.to_string());\n            post.created_at = Utc.timestamp_opt(ts, 0).unwrap();\n            post.is_synced = true;\n            posts.push(post);\n        }\n\n        for post in &posts {\n            repository.create_post(post).await.expect(\"seed repository\");\n        }\n\n        let initial = service\n            .get_posts_by_topic(topic_id, 3)\n            .await\n            .expect(\"initial fetch\");\n        assert_eq!(initial.len(), 3);\n\n        // DBから削除してもキャッシュから取得できることを確認\n        for post in &initial {\n            repository\n                .delete_post(&post.id)\n                .await\n                .expect(\"delete seeded post\");\n        }\n\n        let cached = service\n            .get_posts_by_topic(topic_id, 2)\n            .await\n            .expect(\"fetch from cache\");\n        assert_eq!(cached.len(), 2);\n        assert_eq!(cached[0].id, initial[0].id);\n        assert_eq!(cached[1].id, initial[1].id);\n\n        let cached_full = cache.get_by_topic(topic_id, 5).await;\n        assert_eq!(cached_full.len(), 3);\n    }\n\n    #[tokio::test]\n    async fn get_posts_by_topic_merges_cached_entries_not_in_db() {\n        let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n        let (service, repository, cache) = setup_post_service_with_deps(event_service).await;\n        let topic_id = \"topic-cache-merge\";\n\n        let mut db_post = Post::new(\"db-post\".into(), sample_user(), topic_id.to_string());\n        db_post.created_at = Utc.timestamp_opt(50, 0).unwrap();\n        db_post.is_synced = true;\n        repository\n            .create_post(&db_post)\n            .await\n            .expect(\"seed repository with db post\");\n\n        let mut cached_only = Post::new(\"cached-only\".into(), sample_user(), topic_id.to_string());\n        cached_only.created_at = Utc.timestamp_opt(200, 0).unwrap();\n        cache.add(cached_only.clone()).await;\n\n        let result = service\n            .get_posts_by_topic(topic_id, 2)\n            .await\n            .expect(\"fetch posts should include cached-only entry\");\n\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0].content, \"cached-only\");\n        assert_eq!(result[1].content, \"db-post\");\n\n        let cached_snapshot = cache.get_by_topic(topic_id, 5).await;\n        assert!(\n            cached_snapshot.iter().any(|post| post.id == cached_only.id),\n            \"cached-only post should remain cached after merge\"\n        );\n    }\n\n    #[tokio::test]\n    async fn delete_post_removes_from_cache() {\n        let (service, _repository, cache) =\n            setup_post_service_with_deps(Arc::new(TestEventService::default())).await;\n\n        let post = service\n            .create_post(\"to delete\".into(), sample_user(), \"topic-del\".into(), None)\n            .await\n            .expect(\"post creation succeeds\");\n\n        assert!(\n            cache.get(&post.id).await.is_some(),\n            \"post should be present in cache after creation\"\n        );\n\n        service\n            .delete_post(&post.id)\n            .await\n            .expect(\"delete_post should succeed\");\n\n        assert!(\n            cache.get(&post.id).await.is_none(),\n            \"post should be evicted from cache after deletion\"\n        );\n    }\n}\n","traces":[{"line":37,"address":[18875744,18876528],"length":1,"stats":{"Line":3}},{"line":38,"address":[18919457],"length":1,"stats":{"Line":3}},{"line":39,"address":[18918608,18918635],"length":1,"stats":{"Line":2}},{"line":40,"address":[19015216,19015225],"length":1,"stats":{"Line":2}},{"line":41,"address":[18917857,18917929],"length":1,"stats":{"Line":4}},{"line":42,"address":[18882921],"length":1,"stats":{"Line":2}},{"line":44,"address":[18801458,18801366],"length":1,"stats":{"Line":2}},{"line":45,"address":[18914208],"length":1,"stats":{"Line":0}},{"line":47,"address":[18801464,18801570],"length":1,"stats":{"Line":2}},{"line":48,"address":[13055915,13056140],"length":1,"stats":{"Line":2}},{"line":50,"address":[13056053],"length":1,"stats":{"Line":0}},{"line":51,"address":[18876168],"length":1,"stats":{"Line":0}},{"line":52,"address":[19014656,19014721],"length":1,"stats":{"Line":0}},{"line":56,"address":[18883696,18884051],"length":1,"stats":{"Line":1}},{"line":57,"address":[18802398,18802215],"length":1,"stats":{"Line":1}},{"line":59,"address":[18915280,18915074,18915264],"length":1,"stats":{"Line":0}},{"line":60,"address":[18919116,18918985],"length":1,"stats":{"Line":2}},{"line":61,"address":[13057046,13057024],"length":1,"stats":{"Line":0}},{"line":64,"address":[18885198,18885230,18884496],"length":1,"stats":{"Line":1}},{"line":65,"address":[18877909,18877627],"length":1,"stats":{"Line":1}},{"line":66,"address":[18885068,18884891,18884729],"length":1,"stats":{"Line":2}},{"line":67,"address":[19016800,19016589,19016822],"length":1,"stats":{"Line":0}},{"line":68,"address":[18920083,18920258],"length":1,"stats":{"Line":2}},{"line":71,"address":[18917752,18917719,18916688],"length":1,"stats":{"Line":1}},{"line":72,"address":[18920683,18920958],"length":1,"stats":{"Line":1}},{"line":73,"address":[18804223,18804372,18804496],"length":1,"stats":{"Line":2}},{"line":75,"address":[18805088,18804465,18805072],"length":1,"stats":{"Line":0}},{"line":76,"address":[19017648,19017943,19017508],"length":1,"stats":{"Line":2}},{"line":77,"address":[19018304,19017895,19018326],"length":1,"stats":{"Line":0}},{"line":78,"address":[18923043,18923227],"length":1,"stats":{"Line":2}},{"line":79,"address":[18918214,18918192],"length":1,"stats":{"Line":0}},{"line":82,"address":[14326544],"length":1,"stats":{"Line":1}},{"line":88,"address":[18919429,18918923,18919251,18919504,18918724,18919105,18919871,18921042,18918864],"length":1,"stats":{"Line":6}},{"line":90,"address":[18806139],"length":1,"stats":{"Line":1}},{"line":91,"address":[11611092],"length":1,"stats":{"Line":3}},{"line":92,"address":[18820469,18822112],"length":1,"stats":{"Line":1}},{"line":93,"address":[18808546],"length":1,"stats":{"Line":0}},{"line":94,"address":[14329082],"length":1,"stats":{"Line":0}},{"line":95,"address":[18882975],"length":1,"stats":{"Line":0}},{"line":98,"address":[19020334,19020522,19021408,19020172],"length":1,"stats":{"Line":2}},{"line":100,"address":[19020490,19020642],"length":1,"stats":{"Line":2}},{"line":101,"address":[18924218],"length":1,"stats":{"Line":1}},{"line":102,"address":[19020720],"length":1,"stats":{"Line":1}},{"line":103,"address":[18925944],"length":1,"stats":{"Line":1}},{"line":105,"address":[18814539,18814610,18814880],"length":1,"stats":{"Line":2}},{"line":106,"address":[13062880,13062898,13062352],"length":1,"stats":{"Line":0}},{"line":107,"address":[19021013],"length":1,"stats":{"Line":1}},{"line":110,"address":[18822623,18827279,18826022,18824211,18822496,18822887,18822531,18822576],"length":1,"stats":{"Line":4}},{"line":111,"address":[14329793,14329946],"length":1,"stats":{"Line":2}},{"line":112,"address":[18884913],"length":1,"stats":{"Line":1}},{"line":114,"address":[13063709],"length":1,"stats":{"Line":1}},{"line":115,"address":[18823590,18823180,18823293],"length":1,"stats":{"Line":2}},{"line":116,"address":[18926215],"length":1,"stats":{"Line":0}},{"line":118,"address":[14330530,14330231,14330644],"length":1,"stats":{"Line":2}},{"line":119,"address":[18928175],"length":1,"stats":{"Line":0}},{"line":122,"address":[18892499,18894177,18891376,18891720,18891785,18892289,18892121],"length":1,"stats":{"Line":5}},{"line":124,"address":[18926669],"length":1,"stats":{"Line":1}},{"line":125,"address":[11608545],"length":1,"stats":{"Line":3}},{"line":126,"address":[18885483,18885608],"length":1,"stats":{"Line":2}},{"line":127,"address":[18924975,18923849],"length":1,"stats":{"Line":0}},{"line":128,"address":[18812445],"length":1,"stats":{"Line":0}},{"line":131,"address":[18811128,18811243],"length":1,"stats":{"Line":2}},{"line":132,"address":[13065643],"length":1,"stats":{"Line":1}},{"line":133,"address":[19024503,19024443],"length":1,"stats":{"Line":1}},{"line":135,"address":[19024942],"length":1,"stats":{"Line":0}},{"line":136,"address":[18886273,18885989],"length":1,"stats":{"Line":0}},{"line":140,"address":[18811875],"length":1,"stats":{"Line":1}},{"line":143,"address":[18930856,18931081,18932297,18931373,18930848,18930896,18930946,18932318],"length":1,"stats":{"Line":4}},{"line":144,"address":[19027488,19027603],"length":1,"stats":{"Line":2}},{"line":145,"address":[18927994,18927262,18927947,18927366],"length":1,"stats":{"Line":4}},{"line":146,"address":[19027837,19028102,19027540,19028403,19028610],"length":1,"stats":{"Line":4}},{"line":148,"address":[18932021],"length":1,"stats":{"Line":1}},{"line":151,"address":[18822512],"length":1,"stats":{"Line":4}},{"line":167,"address":[14336384],"length":1,"stats":{"Line":2}},{"line":174,"address":[18817810,18816426,18816676,18816832],"length":1,"stats":{"Line":4}},{"line":175,"address":[18817759,18817708,18816798,18816917],"length":1,"stats":{"Line":2}},{"line":177,"address":[13071474,13073191],"length":1,"stats":{"Line":2}},{"line":178,"address":[14338587,14339538,14338836,14338070,14337733,14338118,14338448],"length":1,"stats":{"Line":5}},{"line":179,"address":[18935706,18935548],"length":1,"stats":{"Line":2}},{"line":180,"address":[11572879],"length":1,"stats":{"Line":3}},{"line":181,"address":[19031489,19031335],"length":1,"stats":{"Line":1}},{"line":182,"address":[18893199,18893124],"length":1,"stats":{"Line":2}},{"line":183,"address":[18937094],"length":1,"stats":{"Line":1}},{"line":184,"address":[18825648],"length":1,"stats":{"Line":1}},{"line":187,"address":[13073212,13071594,13073429,13074339,13070811,13073765],"length":1,"stats":{"Line":6}},{"line":189,"address":[18937703,18938267,18938439,18938146,18938619],"length":1,"stats":{"Line":8}},{"line":192,"address":[13073882],"length":1,"stats":{"Line":2}},{"line":193,"address":[18833408],"length":1,"stats":{"Line":2}},{"line":194,"address":[18894310],"length":1,"stats":{"Line":2}},{"line":195,"address":[18819730],"length":1,"stats":{"Line":2}},{"line":196,"address":[18932540],"length":1,"stats":{"Line":2}},{"line":198,"address":[18936576,18936641,18936680,18936892,18933168],"length":1,"stats":{"Line":5}},{"line":200,"address":[18933067],"length":1,"stats":{"Line":1}},{"line":201,"address":[18937039],"length":1,"stats":{"Line":1}},{"line":202,"address":[18820695,18820588],"length":1,"stats":{"Line":2}},{"line":203,"address":[13076033,13075018,13075248,13075331,13075780,13075907],"length":1,"stats":{"Line":5}},{"line":204,"address":[18834548],"length":1,"stats":{"Line":1}},{"line":205,"address":[19029621,19034437,19034596,19034121,19034056,19034753],"length":1,"stats":{"Line":4}},{"line":207,"address":[18937078],"length":1,"stats":{"Line":1}},{"line":208,"address":[14342348,14340880,14341533,14337078],"length":1,"stats":{"Line":2}},{"line":209,"address":[18835982],"length":1,"stats":{"Line":1}},{"line":213,"address":[11573004],"length":1,"stats":{"Line":1}},{"line":214,"address":[11537909],"length":1,"stats":{"Line":2}},{"line":215,"address":[14343897],"length":1,"stats":{"Line":1}},{"line":218,"address":[13078579,13078452,13078799,13079589,13078192,13078144,13078162,13078284],"length":1,"stats":{"Line":0}},{"line":220,"address":[18905698,18905861,18905622,18906047],"length":1,"stats":{"Line":0}},{"line":221,"address":[18824199,18824937,18825294,18824883,18825780],"length":1,"stats":{"Line":0}},{"line":225,"address":[18938486,18939289,18937835,18937738,18936924,18938862],"length":1,"stats":{"Line":0}},{"line":228,"address":[18942883,18942760],"length":1,"stats":{"Line":0}},{"line":229,"address":[18942529,18944895,18945276,18945592,18944593,18944762],"length":1,"stats":{"Line":0}},{"line":230,"address":[18908468,18905782,18908829,18908664],"length":1,"stats":{"Line":0}},{"line":231,"address":[18945779],"length":1,"stats":{"Line":0}},{"line":234,"address":[18944627],"length":1,"stats":{"Line":0}},{"line":237,"address":[13081936],"length":1,"stats":{"Line":1}},{"line":242,"address":[18841687],"length":1,"stats":{"Line":1}},{"line":243,"address":[18828050,18828162],"length":1,"stats":{"Line":0}},{"line":246,"address":[18902566,18902919,18903106,18902661],"length":1,"stats":{"Line":2}},{"line":247,"address":[18945410,18945494],"length":1,"stats":{"Line":2}},{"line":248,"address":[18941895,18941611],"length":1,"stats":{"Line":2}},{"line":251,"address":[11636357],"length":1,"stats":{"Line":3}},{"line":253,"address":[18843451,18843621],"length":1,"stats":{"Line":3}},{"line":254,"address":[14352259,14349928,14350017,14352224],"length":1,"stats":{"Line":4}},{"line":255,"address":[18948357,18948472,18948652,18948607,18948937],"length":1,"stats":{"Line":5}},{"line":256,"address":[18830402,18830492],"length":1,"stats":{"Line":2}},{"line":257,"address":[13084855],"length":1,"stats":{"Line":1}},{"line":262,"address":[18949031,18950640,18948194,18950672],"length":1,"stats":{"Line":4}},{"line":264,"address":[11636377],"length":1,"stats":{"Line":2}},{"line":267,"address":[11523696],"length":1,"stats":{"Line":2}},{"line":269,"address":[18845695],"length":1,"stats":{"Line":1}},{"line":272,"address":[19045701,19045536,19045488,19046141,19045858,19045571,19045506,19045738],"length":1,"stats":{"Line":0}},{"line":273,"address":[19045785,19045890,19045728,19045669],"length":1,"stats":{"Line":0}},{"line":276,"address":[18846866,18847199,18847420,18846943,18846896,18848168,18846848,18847093],"length":1,"stats":{"Line":0}},{"line":277,"address":[18950145,18949927,18950989,18950003,18950332],"length":1,"stats":{"Line":0}},{"line":279,"address":[18848177,18847899,18847144,18848970],"length":1,"stats":{"Line":0}},{"line":280,"address":[18848678],"length":1,"stats":{"Line":0}},{"line":281,"address":[18910120,18909613,18909807,18907997],"length":1,"stats":{"Line":0}},{"line":282,"address":[13089795,13087730,13090084,13089927],"length":1,"stats":{"Line":0}},{"line":285,"address":[13089501],"length":1,"stats":{"Line":0}},{"line":288,"address":[14356889,14355858,14355888,14355840,14356171,14356875,14356086,14355935],"length":1,"stats":{"Line":4}},{"line":289,"address":[18911640,18911983,18910876,18912166,18912377,18911525,18911873],"length":1,"stats":{"Line":5}},{"line":290,"address":[18843879,18843920,18843288,18843781],"length":1,"stats":{"Line":2}},{"line":291,"address":[18917880,18918849,18918525,18918584,18919027,18918693],"length":1,"stats":{"Line":4}},{"line":292,"address":[18837841,18837611,18838359,18838145,18836381],"length":1,"stats":{"Line":2}},{"line":293,"address":[13092412,13092544,13092668,13090706],"length":1,"stats":{"Line":2}},{"line":294,"address":[18845405],"length":1,"stats":{"Line":1}},{"line":297,"address":[18852400],"length":1,"stats":{"Line":0}},{"line":302,"address":[18957368,18957309,18957540,18957638,18957887,18957143],"length":1,"stats":{"Line":0}},{"line":305,"address":[18845934,18846084,18846335,18845877,18845696,18845833],"length":1,"stats":{"Line":0}},{"line":306,"address":[18846459,18845714,18846600,18846263],"length":1,"stats":{"Line":0}},{"line":309,"address":[18915800,18914961,18914704,18914717,18914736,18914771,18915117,18914894],"length":1,"stats":{"Line":0}},{"line":310,"address":[18854317,18854032,18854089,18854188,18854712],"length":1,"stats":{"Line":0}},{"line":311,"address":[19053419,19053955,19054148,19054289],"length":1,"stats":{"Line":0}},{"line":314,"address":[18958144],"length":1,"stats":{"Line":1}},{"line":320,"address":[18923407,18923559],"length":1,"stats":{"Line":2}},{"line":321,"address":[14361634,14361591],"length":1,"stats":{"Line":2}},{"line":322,"address":[18849971,18848898,18849133,18849066,18849460,18849324,18849796],"length":1,"stats":{"Line":5}},{"line":324,"address":[18960526],"length":1,"stats":{"Line":1}},{"line":325,"address":[11743951],"length":1,"stats":{"Line":4}},{"line":326,"address":[18962001,18961390,18961527,18960252,18961174],"length":1,"stats":{"Line":2}},{"line":328,"address":[13098179],"length":1,"stats":{"Line":1}},{"line":329,"address":[18850376],"length":1,"stats":{"Line":1}},{"line":330,"address":[18925152],"length":1,"stats":{"Line":1}},{"line":331,"address":[18857436],"length":1,"stats":{"Line":1}},{"line":332,"address":[18956395,18956546],"length":1,"stats":{"Line":2}},{"line":336,"address":[14363855,14364025,14365127,14363772,14364131,14364352,14363744,14363808],"length":1,"stats":{"Line":0}},{"line":337,"address":[18963244,18963964,18962907,18963049,18962831],"length":1,"stats":{"Line":0}},{"line":339,"address":[13099707],"length":1,"stats":{"Line":0}},{"line":340,"address":[11715528],"length":1,"stats":{"Line":0}},{"line":341,"address":[18927765],"length":1,"stats":{"Line":0}},{"line":342,"address":[18853632,18853132,18851445,18853319],"length":1,"stats":{"Line":0}},{"line":343,"address":[11502503],"length":1,"stats":{"Line":0}},{"line":347,"address":[18962093],"length":1,"stats":{"Line":0}},{"line":350,"address":[14368709,14366799,14366979,14366752,14366688,14366716,14367887,14367043],"length":1,"stats":{"Line":4}},{"line":351,"address":[18861803,18861574,18862373,18861428],"length":1,"stats":{"Line":2}},{"line":352,"address":[13104175,13102299,13104160],"length":1,"stats":{"Line":0}},{"line":353,"address":[13102277,13102666,13102432,13102892],"length":1,"stats":{"Line":2}},{"line":354,"address":[18966544,18966559,18964954],"length":1,"stats":{"Line":0}},{"line":356,"address":[18848974,18849299,18848816,18848271,18848479,18848538],"length":1,"stats":{"Line":5}},{"line":357,"address":[13102764],"length":1,"stats":{"Line":1}},{"line":358,"address":[18855341,18855291,18855485,18855696,18854517,18856016],"length":1,"stats":{"Line":5}},{"line":360,"address":[11515554],"length":1,"stats":{"Line":1}},{"line":361,"address":[18968083],"length":1,"stats":{"Line":1}},{"line":364,"address":[18962656,18963917,18962767,18964496,18962951,18962684,18962720,18963015],"length":1,"stats":{"Line":4}},{"line":365,"address":[13104516,13104891,13104662,13105461],"length":1,"stats":{"Line":2}},{"line":366,"address":[14369672,14371152,14371167],"length":1,"stats":{"Line":0}},{"line":367,"address":[18925109,18925264,18925724,18925498],"length":1,"stats":{"Line":2}},{"line":368,"address":[18932378,18933696,18933711],"length":1,"stats":{"Line":0}},{"line":370,"address":[18864575,18865110,18864842,18865220,18865357,18864783],"length":1,"stats":{"Line":5}},{"line":371,"address":[14370106],"length":1,"stats":{"Line":1}},{"line":372,"address":[11624577],"length":1,"stats":{"Line":4}},{"line":374,"address":[18858428,18857082,18858585,18858296],"length":1,"stats":{"Line":2}},{"line":375,"address":[18926648],"length":1,"stats":{"Line":1}},{"line":378,"address":[18852224],"length":1,"stats":{"Line":1}},{"line":382,"address":[18852933,18852518,18852727,18852415],"length":1,"stats":{"Line":2}},{"line":383,"address":[19066800,19066815,19065754],"length":1,"stats":{"Line":0}},{"line":385,"address":[11562388],"length":1,"stats":{"Line":3}},{"line":387,"address":[18966044,18966237],"length":1,"stats":{"Line":2}},{"line":389,"address":[18867536,18867568],"length":1,"stats":{"Line":2}},{"line":393,"address":[18966688,18966983,18966883,18967923,18966656,18966742,18967188,18966664],"length":1,"stats":{"Line":0}},{"line":394,"address":[11598690],"length":1,"stats":{"Line":0}},{"line":395,"address":[19067957],"length":1,"stats":{"Line":0}},{"line":397,"address":[18972709,18972660,18971543,18971753],"length":1,"stats":{"Line":0}},{"line":398,"address":[18863352,18863611,18862889,18863473,18863787],"length":1,"stats":{"Line":0}},{"line":401,"address":[18930880],"length":1,"stats":{"Line":0}},{"line":402,"address":[18972998],"length":1,"stats":{"Line":0}},{"line":403,"address":[18870188],"length":1,"stats":{"Line":0}},{"line":404,"address":[13110744],"length":1,"stats":{"Line":0}},{"line":405,"address":[19069618],"length":1,"stats":{"Line":0}},{"line":407,"address":[19068300,19067302,19069783,19070000,19069718],"length":1,"stats":{"Line":0}},{"line":409,"address":[18975323],"length":1,"stats":{"Line":0}},{"line":410,"address":[14375887],"length":1,"stats":{"Line":0}},{"line":411,"address":[13111495],"length":1,"stats":{"Line":0}},{"line":412,"address":[18871029,18871256,18871339,18869170,18869481,18869344],"length":1,"stats":{"Line":0}},{"line":413,"address":[18931932],"length":1,"stats":{"Line":0}},{"line":414,"address":[14374537,14376401,14374330,14376340,14373175,14374149],"length":1,"stats":{"Line":0}},{"line":415,"address":[18968509,18968340,18968469],"length":1,"stats":{"Line":0}},{"line":417,"address":[18857107],"length":1,"stats":{"Line":0}},{"line":418,"address":[18974798,18973800,19042985,18974297,19043119],"length":1,"stats":{"Line":0}},{"line":423,"address":[13110452],"length":1,"stats":{"Line":0}},{"line":429,"address":[19043439,19043915,19043523,19043688,19043711,19044176,19043605,19043488],"length":1,"stats":{"Line":0}},{"line":430,"address":[11845799],"length":1,"stats":{"Line":0}}],"covered":139,"coverable":221},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","profile_avatar_service.rs"],"content":"use std::{path::PathBuf, str::FromStr};\n\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64_STANDARD};\nuse blake3::Hasher as Blake3;\nuse rand::TryRngCore;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\nuse crate::{\n    domain::entities::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry},\n    infrastructure::{\n        crypto::{CapabilityEncryptor, EncryptedSessionKey, StreamEncryptor},\n        storage::profile_avatar_store::{ProfileAvatarStore, ProfileAvatarSyncPackage},\n    },\n    shared::AppError,\n};\n\nconst MAX_AVATAR_BYTES: usize = 2 * 1024 * 1024;\nconst AES_KEY_SIZE: usize = 32;\nconst AES_NONCE_SIZE: usize = 12;\n\n#[derive(Debug)]\npub struct UploadProfileAvatarInput {\n    pub npub: String,\n    pub bytes: Vec<u8>,\n    pub format: String,\n    pub access_level: ProfileAvatarAccessLevel,\n}\n\n#[derive(Debug)]\npub struct ProfileAvatarFetchResult {\n    pub bytes: Vec<u8>,\n    pub metadata: ProfileAvatarDocEntry,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct ShareTicketPayload {\n    version: u8,\n    access_level: String,\n    capability_secret: String,\n}\n\npub struct ProfileAvatarService {\n    store: ProfileAvatarStore,\n}\n\nimpl ProfileAvatarService {\n    pub async fn new(root_dir: PathBuf) -> Result<Self, AppError> {\n        let store = ProfileAvatarStore::new(root_dir).await?;\n        Ok(Self { store })\n    }\n\n    pub async fn upload_avatar(\n        &self,\n        input: UploadProfileAvatarInput,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        validate_format(&input.format)?;\n        validate_size(input.bytes.len())?;\n\n        let encrypted = StreamEncryptor::encrypt(&input.bytes)?;\n        let blob_hash = compute_blob_hash(&encrypted.ciphertext);\n        let content_sha256 = compute_content_sha256(&input.bytes);\n\n        self.store\n            .write_encrypted_blob(&blob_hash, &encrypted.ciphertext)\n            .await?;\n\n        let mut capability_secret = [0u8; AES_KEY_SIZE];\n        rand::rngs::OsRng\n            .try_fill_bytes(&mut capability_secret)\n            .map_err(|err| {\n                AppError::Crypto(format!(\"Failed to generate capability secret: {err}\"))\n            })?;\n\n        let encrypted_session_key =\n            CapabilityEncryptor::encrypt_session_key(&encrypted.session_key, &capability_secret)?;\n\n        let share_ticket = encode_share_ticket(input.access_level, &capability_secret)?;\n        let key_nonce_b64 = BASE64_STANDARD.encode(encrypted_session_key.nonce);\n        let encrypted_key_b64 = BASE64_STANDARD.encode(encrypted_session_key.ciphertext);\n        let encryption_nonce_b64 = BASE64_STANDARD.encode(encrypted.nonce);\n\n        let entry = ProfileAvatarDocEntry {\n            npub: input.npub,\n            blob_hash,\n            format: input.format,\n            size_bytes: input.bytes.len() as u64,\n            access_level: input.access_level,\n            share_ticket,\n            encrypted_key: encrypted_key_b64,\n            key_nonce: key_nonce_b64,\n            encryption_nonce: encryption_nonce_b64,\n            content_sha256,\n            updated_at: chrono::Utc::now(),\n            version: 0,\n        };\n\n        self.store.upsert_entry(entry).await\n    }\n\n    pub async fn fetch_avatar(&self, npub: &str) -> Result<ProfileAvatarFetchResult, AppError> {\n        let metadata =\n            self.store.get_entry(npub).await?.ok_or_else(|| {\n                AppError::NotFound(format!(\"Profile avatar not found for {npub}\"))\n            })?;\n\n        let ticket = decode_share_ticket(&metadata.share_ticket)?;\n        if ticket.access_level != metadata.access_level {\n            return Err(AppError::validation(\n                crate::shared::validation::ValidationFailureKind::Generic,\n                format!(\n                    \"share ticket access level mismatch (ticket={}, metadata={})\",\n                    ticket.access_level.as_str(),\n                    metadata.access_level.as_str()\n                ),\n            ));\n        }\n        let capability_secret = ticket.capability_secret;\n        let encrypted_key = BASE64_STANDARD\n            .decode(metadata.encrypted_key.as_bytes())\n            .map_err(|err| {\n                AppError::DeserializationError(format!(\"Invalid encrypted key: {err}\"))\n            })?;\n        let mut key_nonce = [0u8; AES_NONCE_SIZE];\n        let decoded_key_nonce = BASE64_STANDARD\n            .decode(metadata.key_nonce.as_bytes())\n            .map_err(|err| AppError::DeserializationError(format!(\"Invalid key nonce: {err}\")))?;\n        if decoded_key_nonce.len() != AES_NONCE_SIZE {\n            return Err(AppError::DeserializationError(\n                \"Key nonce has invalid length\".to_string(),\n            ));\n        }\n        key_nonce.copy_from_slice(&decoded_key_nonce);\n\n        let encrypted_session_key = EncryptedSessionKey {\n            ciphertext: encrypted_key,\n            nonce: key_nonce,\n        };\n        let session_key =\n            CapabilityEncryptor::decrypt_session_key(&encrypted_session_key, &capability_secret)?;\n\n        let mut encryption_nonce = [0u8; AES_NONCE_SIZE];\n        let decoded_encryption_nonce = BASE64_STANDARD\n            .decode(metadata.encryption_nonce.as_bytes())\n            .map_err(|err| {\n                AppError::DeserializationError(format!(\"Invalid encryption nonce: {err}\"))\n            })?;\n        if decoded_encryption_nonce.len() != AES_NONCE_SIZE {\n            return Err(AppError::DeserializationError(\n                \"Encryption nonce has invalid length\".to_string(),\n            ));\n        }\n        encryption_nonce.copy_from_slice(&decoded_encryption_nonce);\n\n        let encrypted_blob = self.store.read_encrypted_blob(&metadata.blob_hash).await?;\n        let plaintext = StreamEncryptor::decrypt(&encrypted_blob, &session_key, &encryption_nonce)?;\n\n        Ok(ProfileAvatarFetchResult {\n            bytes: plaintext,\n            metadata,\n        })\n    }\n\n    pub async fn export_sync_package(\n        &self,\n        npub: &str,\n    ) -> Result<Option<ProfileAvatarSyncPackage>, AppError> {\n        self.store.export_sync_package(npub).await\n    }\n\n    pub async fn import_sync_package(\n        &self,\n        package: ProfileAvatarSyncPackage,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        self.store.import_sync_package(package).await\n    }\n\n    pub async fn entries_snapshot(&self) -> Vec<ProfileAvatarDocEntry> {\n        self.store.entries_snapshot().await\n    }\n}\n\nfn validate_format(format: &str) -> Result<(), AppError> {\n    if !format.starts_with(\"image/\") {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::Generic,\n            \"Profile avatar must be an image format\",\n        ));\n    }\n    Ok(())\n}\n\nfn validate_size(size: usize) -> Result<(), AppError> {\n    if size == 0 {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::Generic,\n            \"Profile avatar file is empty\",\n        ));\n    }\n    if size > MAX_AVATAR_BYTES {\n        return Err(AppError::validation(\n            crate::shared::validation::ValidationFailureKind::ContentTooLarge,\n            format!(\"Profile avatar size exceeds limit ({size} bytes > {MAX_AVATAR_BYTES} bytes)\"),\n        ));\n    }\n    Ok(())\n}\n\nfn compute_blob_hash(data: &[u8]) -> String {\n    let mut hasher = Blake3::new();\n    hasher.update(data);\n    hasher.finalize().to_hex().to_string()\n}\n\nfn compute_content_sha256(data: &[u8]) -> String {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hex::encode(hasher.finalize())\n}\n\nfn encode_share_ticket(\n    access_level: ProfileAvatarAccessLevel,\n    capability_secret: &[u8; AES_KEY_SIZE],\n) -> Result<String, AppError> {\n    let payload = ShareTicketPayload {\n        version: 1,\n        access_level: access_level.as_str().to_string(),\n        capability_secret: BASE64_STANDARD.encode(capability_secret),\n    };\n    let json = serde_json::to_string(&payload).map_err(|err| {\n        AppError::SerializationError(format!(\"Failed to encode share ticket: {err}\"))\n    })?;\n    Ok(BASE64_STANDARD.encode(json))\n}\n\nstruct DecodedShareTicket {\n    pub access_level: ProfileAvatarAccessLevel,\n    pub capability_secret: [u8; AES_KEY_SIZE],\n}\n\nfn decode_share_ticket(ticket: &str) -> Result<DecodedShareTicket, AppError> {\n    let json_bytes = BASE64_STANDARD\n        .decode(ticket.as_bytes())\n        .map_err(|err| AppError::DeserializationError(format!(\"Invalid share ticket: {err}\")))?;\n    let payload: ShareTicketPayload = serde_json::from_slice(&json_bytes).map_err(|err| {\n        AppError::DeserializationError(format!(\"Failed to parse share ticket payload: {err}\"))\n    })?;\n    let access_level = ProfileAvatarAccessLevel::from_str(&payload.access_level).map_err(|_| {\n        AppError::DeserializationError(\"Unknown access level in share ticket\".to_string())\n    })?;\n    let secret_bytes = BASE64_STANDARD\n        .decode(payload.capability_secret.as_bytes())\n        .map_err(|err| {\n            AppError::DeserializationError(format!(\"Invalid capability secret: {err}\"))\n        })?;\n    if secret_bytes.len() != AES_KEY_SIZE {\n        return Err(AppError::DeserializationError(\n            \"Capability secret has invalid length\".to_string(),\n        ));\n    }\n    let mut capability_secret = [0u8; AES_KEY_SIZE];\n    capability_secret.copy_from_slice(&secret_bytes);\n    Ok(DecodedShareTicket {\n        access_level,\n        capability_secret,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::tempdir;\n\n    #[tokio::test]\n    async fn upload_and_fetch_roundtrip() {\n        let temp = tempdir().unwrap();\n        let service = ProfileAvatarService::new(temp.path().to_path_buf())\n            .await\n            .expect(\"service init\");\n        let npub = \"npub1avataruser\";\n        let bytes = vec![1, 2, 3, 4, 5, 6, 7, 8];\n\n        let entry = service\n            .upload_avatar(UploadProfileAvatarInput {\n                npub: npub.to_string(),\n                bytes: bytes.clone(),\n                format: \"image/png\".to_string(),\n                access_level: ProfileAvatarAccessLevel::Public,\n            })\n            .await\n            .expect(\"upload\");\n\n        assert_eq!(entry.npub, npub);\n        assert_eq!(entry.size_bytes, bytes.len() as u64);\n\n        let fetched = service.fetch_avatar(npub).await.expect(\"fetch\");\n        assert_eq!(fetched.metadata.blob_hash, entry.blob_hash);\n        assert_eq!(fetched.bytes, bytes);\n    }\n}\n","traces":[{"line":48,"address":[12705488,12706324,12705491,12705536,12705707,12705571,12705832,12705670],"length":1,"stats":{"Line":8}},{"line":49,"address":[12710258,12709633,12710137,12709800,12709690,12709582],"length":1,"stats":{"Line":6}},{"line":50,"address":[12600227],"length":1,"stats":{"Line":2}},{"line":53,"address":[12668224],"length":1,"stats":{"Line":2}},{"line":57,"address":[12710992,12710890,12712260,12710724],"length":1,"stats":{"Line":4}},{"line":58,"address":[12712843,12713906,12712609,12712733],"length":1,"stats":{"Line":4}},{"line":60,"address":[12807728,12808021,12807588,12808662],"length":1,"stats":{"Line":4}},{"line":61,"address":[12807976,12808188],"length":1,"stats":{"Line":4}},{"line":62,"address":[20370133,20370245],"length":1,"stats":{"Line":4}},{"line":64,"address":[12712711,12712166,12711950,12712402,12712120,12712528,12715353],"length":1,"stats":{"Line":10}},{"line":65,"address":[12609087,12609179],"length":1,"stats":{"Line":4}},{"line":66,"address":[11596207,11596282],"length":1,"stats":{"Line":10}},{"line":68,"address":[12670700],"length":1,"stats":{"Line":2}},{"line":69,"address":[12811783,12809233,12809411],"length":1,"stats":{"Line":2}},{"line":70,"address":[12670725],"length":1,"stats":{"Line":2}},{"line":71,"address":[12674288],"length":1,"stats":{"Line":0}},{"line":72,"address":[20374693],"length":1,"stats":{"Line":0}},{"line":75,"address":[20371223,20371598,20373659,20371394],"length":1,"stats":{"Line":4}},{"line":78,"address":[12671570,12671362,12671168],"length":1,"stats":{"Line":4}},{"line":79,"address":[12715414,12715193],"length":1,"stats":{"Line":4}},{"line":80,"address":[16421801,16421951],"length":1,"stats":{"Line":4}},{"line":81,"address":[20372415,20372282],"length":1,"stats":{"Line":4}},{"line":84,"address":[12714094],"length":1,"stats":{"Line":2}},{"line":86,"address":[16422210],"length":1,"stats":{"Line":2}},{"line":87,"address":[12679127],"length":1,"stats":{"Line":2}},{"line":88,"address":[12597679],"length":1,"stats":{"Line":2}},{"line":94,"address":[16422586],"length":1,"stats":{"Line":2}},{"line":98,"address":[12612075,12612727,12607933,12612162],"length":1,"stats":{"Line":6}},{"line":101,"address":[12604447,12599906,12600161,12599936,12600237,12599888,12599998,12600372],"length":1,"stats":{"Line":8}},{"line":102,"address":[12606975,12611210,12607068,12611229,12612400,12607188,12607890,12606907],"length":1,"stats":{"Line":4}},{"line":104,"address":[12818709],"length":1,"stats":{"Line":0}},{"line":107,"address":[12714111,12713721,12713908,12717128],"length":1,"stats":{"Line":4}},{"line":108,"address":[12719655,12719787],"length":1,"stats":{"Line":4}},{"line":109,"address":[12604315],"length":1,"stats":{"Line":0}},{"line":110,"address":[20376549],"length":1,"stats":{"Line":0}},{"line":111,"address":[12617843,12617932],"length":1,"stats":{"Line":0}},{"line":113,"address":[12617827,12615341],"length":1,"stats":{"Line":0}},{"line":114,"address":[12617870],"length":1,"stats":{"Line":0}},{"line":118,"address":[12601505],"length":1,"stats":{"Line":2}},{"line":119,"address":[12685552,12683198,12683495],"length":1,"stats":{"Line":2}},{"line":120,"address":[12718175],"length":1,"stats":{"Line":2}},{"line":121,"address":[12680384],"length":1,"stats":{"Line":0}},{"line":122,"address":[12680400],"length":1,"stats":{"Line":0}},{"line":124,"address":[12718503],"length":1,"stats":{"Line":2}},{"line":125,"address":[16426607,16426849,16428480],"length":1,"stats":{"Line":2}},{"line":126,"address":[12683406],"length":1,"stats":{"Line":2}},{"line":127,"address":[12619712,12616039,12619728],"length":1,"stats":{"Line":0}},{"line":128,"address":[12609204,12609029],"length":1,"stats":{"Line":4}},{"line":129,"address":[16428353],"length":1,"stats":{"Line":0}},{"line":130,"address":[12720768],"length":1,"stats":{"Line":0}},{"line":133,"address":[20377514,20377402],"length":1,"stats":{"Line":4}},{"line":139,"address":[12716585,12715500,12715405,12715684],"length":1,"stats":{"Line":4}},{"line":142,"address":[12677514],"length":1,"stats":{"Line":2}},{"line":143,"address":[12816150,12816407,12816925],"length":1,"stats":{"Line":2}},{"line":144,"address":[16427451],"length":1,"stats":{"Line":2}},{"line":145,"address":[12606112],"length":1,"stats":{"Line":0}},{"line":146,"address":[12606128],"length":1,"stats":{"Line":0}},{"line":148,"address":[12719893,12720068],"length":1,"stats":{"Line":4}},{"line":149,"address":[12678315],"length":1,"stats":{"Line":0}},{"line":150,"address":[12610266],"length":1,"stats":{"Line":0}},{"line":153,"address":[12678026,12678123],"length":1,"stats":{"Line":4}},{"line":155,"address":[10986590],"length":1,"stats":{"Line":4}},{"line":156,"address":[20380245,20379950,20379779],"length":1,"stats":{"Line":4}},{"line":158,"address":[12818252],"length":1,"stats":{"Line":2}},{"line":160,"address":[12717807],"length":1,"stats":{"Line":2}},{"line":164,"address":[12606272],"length":1,"stats":{"Line":1}},{"line":168,"address":[12719260,12719157,12719203,12719364],"length":1,"stats":{"Line":2}},{"line":171,"address":[12681520],"length":1,"stats":{"Line":1}},{"line":175,"address":[12607160,12607263,12607206,12607380],"length":1,"stats":{"Line":3}},{"line":178,"address":[12682856,12682272,12682432,12682240,12682307,12682552,12682395,12682248],"length":1,"stats":{"Line":0}},{"line":179,"address":[16432176,16432280,16432210,16432364],"length":1,"stats":{"Line":0}},{"line":183,"address":[12720992],"length":1,"stats":{"Line":2}},{"line":184,"address":[12721042],"length":1,"stats":{"Line":2}},{"line":185,"address":[12821437],"length":1,"stats":{"Line":0}},{"line":186,"address":[12682952],"length":1,"stats":{"Line":0}},{"line":190,"address":[12689940],"length":1,"stats":{"Line":2}},{"line":193,"address":[12683040],"length":1,"stats":{"Line":2}},{"line":194,"address":[12608469],"length":1,"stats":{"Line":2}},{"line":195,"address":[12608482],"length":1,"stats":{"Line":0}},{"line":196,"address":[12608477],"length":1,"stats":{"Line":0}},{"line":200,"address":[12721235],"length":1,"stats":{"Line":2}},{"line":201,"address":[12725384],"length":1,"stats":{"Line":0}},{"line":202,"address":[12615350],"length":1,"stats":{"Line":0}},{"line":203,"address":[12690091],"length":1,"stats":{"Line":0}},{"line":206,"address":[12721265],"length":1,"stats":{"Line":2}},{"line":209,"address":[12725668,12725440],"length":1,"stats":{"Line":2}},{"line":210,"address":[12690363],"length":1,"stats":{"Line":2}},{"line":211,"address":[12690397],"length":1,"stats":{"Line":2}},{"line":212,"address":[12615713],"length":1,"stats":{"Line":2}},{"line":215,"address":[12609056],"length":1,"stats":{"Line":2}},{"line":216,"address":[12725739],"length":1,"stats":{"Line":2}},{"line":217,"address":[16433455],"length":1,"stats":{"Line":2}},{"line":218,"address":[12622891],"length":1,"stats":{"Line":2}},{"line":221,"address":[12684539,12684509,12683808],"length":1,"stats":{"Line":2}},{"line":227,"address":[12609260],"length":1,"stats":{"Line":2}},{"line":228,"address":[12623056],"length":1,"stats":{"Line":2}},{"line":230,"address":[12722672,12722112,12722903,12722177,12722458],"length":1,"stats":{"Line":4}},{"line":231,"address":[12823062,12823127],"length":1,"stats":{"Line":0}},{"line":233,"address":[16433940,16434132],"length":1,"stats":{"Line":4}},{"line":241,"address":[12618800,12618766,12617008],"length":1,"stats":{"Line":2}},{"line":242,"address":[12723219,12723005],"length":1,"stats":{"Line":2}},{"line":243,"address":[12610283],"length":1,"stats":{"Line":2}},{"line":244,"address":[12625808,12624244,12625792],"length":1,"stats":{"Line":0}},{"line":245,"address":[12825495,12823667,12825264,12823527,12823985,12825086],"length":1,"stats":{"Line":4}},{"line":246,"address":[12625974,12626039],"length":1,"stats":{"Line":0}},{"line":248,"address":[12728633,12727483,12727830,12727636,12729088],"length":1,"stats":{"Line":4}},{"line":249,"address":[12687064],"length":1,"stats":{"Line":0}},{"line":251,"address":[20386967,20386451,20386205],"length":1,"stats":{"Line":2}},{"line":252,"address":[12692632],"length":1,"stats":{"Line":2}},{"line":253,"address":[12687136],"length":1,"stats":{"Line":0}},{"line":254,"address":[12825632],"length":1,"stats":{"Line":0}},{"line":256,"address":[12824470,12824625],"length":1,"stats":{"Line":4}},{"line":257,"address":[16436113],"length":1,"stats":{"Line":0}},{"line":258,"address":[16435855],"length":1,"stats":{"Line":0}},{"line":261,"address":[12618343],"length":1,"stats":{"Line":2}},{"line":262,"address":[12625411,12625338],"length":1,"stats":{"Line":4}},{"line":263,"address":[12618507],"length":1,"stats":{"Line":2}},{"line":265,"address":[16435939],"length":1,"stats":{"Line":2}}],"covered":84,"coverable":118},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","subscription_state.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse std::sync::Arc;\n\n#[async_trait]\npub trait SubscriptionStateStore: Send + Sync {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError>;\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[derive(Clone)]\npub struct SubscriptionStateMachine {\n    repository: Arc<dyn SubscriptionStateRepository>,\n}\n\nimpl SubscriptionStateMachine {\n    pub fn new(repository: Arc<dyn SubscriptionStateRepository>) -> Self {\n        Self { repository }\n    }\n\n    async fn load_or_initialize(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        match self.repository.find(target).await? {\n            Some(record) => Ok(record),\n            None => Ok(SubscriptionRecord::new(target.clone())),\n        }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateStore for SubscriptionStateMachine {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self\n            .repository\n            .find(&target)\n            .await?\n            .unwrap_or_else(|| SubscriptionRecord::new(target.clone()));\n\n        record.mark_requested(now_secs);\n\n        self.repository.upsert(&record).await\n    }\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError> {\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_subscribed(synced_at);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_failure(now_secs, error);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\n        let now_ms = Utc::now().timestamp_millis();\n        self.repository.mark_all_need_resync(now_ms).await\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_for_restore().await\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_all().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::value_objects::subscription::SubscriptionStatus;\n    use crate::infrastructure::database::{\n        SqliteSubscriptionStateRepository, connection_pool::ConnectionPool,\n    };\n\n    async fn setup_state_machine() -> SubscriptionStateMachine {\n        let pool = ConnectionPool::from_memory().await.unwrap();\n        sqlx::migrate!(\"./migrations\")\n            .run(pool.get_pool())\n            .await\n            .unwrap();\n        let repository = Arc::new(SqliteSubscriptionStateRepository::new(pool));\n        SubscriptionStateMachine::new(repository)\n    }\n\n    #[tokio::test]\n    async fn record_request_inserts_and_updates() {\n        let machine = setup_state_machine().await;\n        let record = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record.failure_count, 0);\n        assert_eq!(record.status, SubscriptionStatus::Pending);\n\n        let record_again = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record_again.status, SubscriptionStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn mark_subscribed_updates_status() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 100).await.unwrap();\n        let all = machine.list_all().await.unwrap();\n        assert_eq!(all[0].status, SubscriptionStatus::Subscribed);\n        assert_eq!(all[0].last_synced_at, Some(100));\n    }\n\n    #[tokio::test]\n    async fn mark_failure_increments_counter() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"fail_topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_failure(&target, \"error\").await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(|record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"fail_topic\"))\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n        assert_eq!(record.failure_count, 1);\n        assert_eq!(record.error_message.as_deref(), Some(\"error\"));\n    }\n\n    #[tokio::test]\n    async fn mark_all_need_resync_updates_subscribed() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"resync\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 200).await.unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(\n                |record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"resync\"),\n            )\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n    }\n\n    #[tokio::test]\n    async fn list_for_restore_filters_status() {\n        let machine = setup_state_machine().await;\n        let pending_target = SubscriptionTarget::Topic(\"pending\".into());\n        machine.record_request(pending_target).await.unwrap();\n        let subscribed_target = SubscriptionTarget::User(\"user\".into());\n        machine\n            .record_request(subscribed_target.clone())\n            .await\n            .unwrap();\n        machine\n            .mark_subscribed(&subscribed_target, 100)\n            .await\n            .unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n\n        let restore = machine.list_for_restore().await.unwrap();\n        assert_eq!(restore.len(), 2);\n    }\n}\n","traces":[{"line":36,"address":[16537840],"length":1,"stats":{"Line":1}},{"line":40,"address":[16463136],"length":1,"stats":{"Line":2}},{"line":44,"address":[16670447,16669822,16669570,16669685,16669618],"length":1,"stats":{"Line":4}},{"line":45,"address":[16457223],"length":1,"stats":{"Line":1}},{"line":46,"address":[16538797,16538719],"length":1,"stats":{"Line":0}},{"line":53,"address":[15453183,15453830,15455213,15453136,15453309,15453087,15453442,15453580,15454653],"length":1,"stats":{"Line":4}},{"line":57,"address":[16718912,16718845],"length":1,"stats":{"Line":2}},{"line":58,"address":[16719272,16719027,16719634,16719712,16719450,16719086,16718972],"length":1,"stats":{"Line":9}},{"line":60,"address":[16717367],"length":1,"stats":{"Line":1}},{"line":61,"address":[11851929],"length":1,"stats":{"Line":6}},{"line":62,"address":[19613216],"length":1,"stats":{"Line":6}},{"line":64,"address":[16676053],"length":1,"stats":{"Line":2}},{"line":66,"address":[11919708],"length":1,"stats":{"Line":3}},{"line":69,"address":[16716544,16715444,16715151,16715200,16717263,16715314,16715235,16715660],"length":1,"stats":{"Line":5}},{"line":74,"address":[16816623,16816060,16815709,16815921,16816907],"length":1,"stats":{"Line":2}},{"line":75,"address":[16721809],"length":1,"stats":{"Line":1}},{"line":76,"address":[19614978,19615080,19615035],"length":1,"stats":{"Line":2}},{"line":77,"address":[16686025],"length":1,"stats":{"Line":1}},{"line":80,"address":[16618391,16618965,16618448,16619857,16620576,16618483,16618562,16618692],"length":1,"stats":{"Line":5}},{"line":81,"address":[16818100],"length":1,"stats":{"Line":1}},{"line":82,"address":[11339295],"length":1,"stats":{"Line":2}},{"line":83,"address":[16619530],"length":1,"stats":{"Line":1}},{"line":84,"address":[12049426,12049483,12049528],"length":1,"stats":{"Line":2}},{"line":85,"address":[16681354],"length":1,"stats":{"Line":1}},{"line":88,"address":[16723650,16724061,16723536,16724319,16723739,16723762,16723571,16723497],"length":1,"stats":{"Line":5}},{"line":89,"address":[16688747],"length":1,"stats":{"Line":1}},{"line":90,"address":[16719741,16720157,16719992],"length":1,"stats":{"Line":2}},{"line":93,"address":[16820851,16821042,16820777,16820930,16820816,16821270,16821528,16821019],"length":1,"stats":{"Line":5}},{"line":94,"address":[11848868],"length":1,"stats":{"Line":2}},{"line":97,"address":[16690162,16690274,16690760,16690502,16690048,16690009,16690251,16690083],"length":1,"stats":{"Line":7}},{"line":98,"address":[16727142,16727302,16726957],"length":1,"stats":{"Line":3}}],"covered":30,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","sync_service.rs"],"content":"use crate::infrastructure::p2p::NetworkService;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[async_trait]\npub trait SyncParticipant: Send + Sync {\n    async fn sync_pending(&self) -> Result<u32, AppError>;\n}\n\n#[async_trait]\npub trait SyncServiceTrait: Send + Sync {\n    async fn start_sync(&self) -> Result<(), AppError>;\n    async fn stop_sync(&self) -> Result<(), AppError>;\n    async fn get_status(&self) -> SyncStatus;\n    async fn reset_sync(&self) -> Result<(), AppError>;\n    async fn schedule_sync(&self, interval_secs: u64);\n}\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct SyncStatus {\n    pub is_syncing: bool,\n    pub pending_posts: u32,\n    pub pending_events: u32,\n    pub last_sync: Option<i64>,\n    pub sync_errors: u32,\n}\n\npub struct SyncService {\n    network: Arc<dyn NetworkService>,\n    post_participant: Arc<dyn SyncParticipant>,\n    event_participant: Arc<dyn SyncParticipant>,\n    status: Arc<RwLock<SyncStatus>>,\n}\n\nimpl SyncService {\n    pub fn new(\n        network: Arc<dyn NetworkService>,\n        post_participant: Arc<dyn SyncParticipant>,\n        event_participant: Arc<dyn SyncParticipant>,\n    ) -> Self {\n        Self {\n            network,\n            post_participant,\n            event_participant,\n            status: Arc::new(RwLock::new(SyncStatus {\n                is_syncing: false,\n                pending_posts: 0,\n                pending_events: 0,\n                last_sync: None,\n                sync_errors: 0,\n            })),\n        }\n    }\n\n    pub async fn start_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n\n        if status.is_syncing {\n            return Ok(());\n        }\n\n        status.is_syncing = true;\n        drop(status);\n\n        if !self.network.is_connected().await {\n            self.network.connect().await?;\n        }\n\n        let synced_posts = self.post_participant.sync_pending().await?;\n        let synced_events = self.event_participant.sync_pending().await?;\n\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        status.last_sync = Some(chrono::Utc::now().timestamp());\n        status.pending_posts = status.pending_posts.saturating_sub(synced_posts);\n        status.pending_events = status.pending_events.saturating_sub(synced_events);\n\n        Ok(())\n    }\n\n    pub async fn stop_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        Ok(())\n    }\n\n    pub async fn get_status(&self) -> SyncStatus {\n        self.status.read().await.clone()\n    }\n\n    pub async fn reset_sync(&self) -> Result<(), AppError> {\n        let mut status = self.status.write().await;\n        status.pending_posts = 0;\n        status.pending_events = 0;\n        status.sync_errors = 0;\n        Ok(())\n    }\n\n    pub async fn schedule_sync(&self, interval_secs: u64) {\n        let service = Arc::new(self.clone());\n        tokio::spawn(async move {\n            let mut interval =\n                tokio::time::interval(tokio::time::Duration::from_secs(interval_secs));\n\n            loop {\n                interval.tick().await;\n\n                if let Err(e) = service.start_sync().await {\n                    tracing::error!(\"Sync error: {}\", e);\n                    let mut status = service.status.write().await;\n                    status.sync_errors += 1;\n                }\n            }\n        });\n    }\n}\n\nimpl Clone for SyncService {\n    fn clone(&self) -> Self {\n        Self {\n            network: self.network.clone(),\n            post_participant: self.post_participant.clone(),\n            event_participant: self.event_participant.clone(),\n            status: self.status.clone(),\n        }\n    }\n}\n\n#[async_trait]\nimpl SyncServiceTrait for SyncService {\n    async fn start_sync(&self) -> Result<(), AppError> {\n        SyncService::start_sync(self).await\n    }\n\n    async fn stop_sync(&self) -> Result<(), AppError> {\n        SyncService::stop_sync(self).await\n    }\n\n    async fn get_status(&self) -> SyncStatus {\n        SyncService::get_status(self).await\n    }\n\n    async fn reset_sync(&self) -> Result<(), AppError> {\n        SyncService::reset_sync(self).await\n    }\n\n    async fn schedule_sync(&self, interval_secs: u64) {\n        SyncService::schedule_sync(self, interval_secs).await\n    }\n}\n","traces":[{"line":38,"address":[17944720,17945079,17945120],"length":1,"stats":{"Line":0}},{"line":47,"address":[14378259,14378398],"length":1,"stats":{"Line":0}},{"line":57,"address":[14378552,14379717,14379055,14378905,14378623,14378745,14378576,14378544],"length":1,"stats":{"Line":0}},{"line":58,"address":[11465617],"length":1,"stats":{"Line":0}},{"line":60,"address":[23810013,23809929],"length":1,"stats":{"Line":0}},{"line":61,"address":[23705522],"length":1,"stats":{"Line":0}},{"line":64,"address":[23691783,23691731],"length":1,"stats":{"Line":0}},{"line":65,"address":[23810075],"length":1,"stats":{"Line":0}},{"line":67,"address":[11465640],"length":1,"stats":{"Line":0}},{"line":68,"address":[11451903],"length":1,"stats":{"Line":0}},{"line":71,"address":[11570214],"length":1,"stats":{"Line":0}},{"line":72,"address":[11458733],"length":1,"stats":{"Line":0}},{"line":74,"address":[11533492],"length":1,"stats":{"Line":0}},{"line":75,"address":[14381944,14382001],"length":1,"stats":{"Line":0}},{"line":76,"address":[23708253],"length":1,"stats":{"Line":0}},{"line":77,"address":[23694613],"length":1,"stats":{"Line":0}},{"line":78,"address":[23694703],"length":1,"stats":{"Line":0}},{"line":80,"address":[17949095],"length":1,"stats":{"Line":0}},{"line":83,"address":[17949176,17949219,17949184,17949342,17949168,17949483,17949305,17949867],"length":1,"stats":{"Line":0}},{"line":84,"address":[11567444],"length":1,"stats":{"Line":0}},{"line":85,"address":[23813778,23813713],"length":1,"stats":{"Line":0}},{"line":86,"address":[14382946],"length":1,"stats":{"Line":0}},{"line":89,"address":[23812539,23812398,23812971,23812240,23812275,23812361,23812224,23812232],"length":1,"stats":{"Line":0}},{"line":90,"address":[23695748,23695807,23695701,23695931],"length":1,"stats":{"Line":0}},{"line":93,"address":[23814955,23814640,23814648,23814656,23814691,23814814,23814777,23815408],"length":1,"stats":{"Line":0}},{"line":94,"address":[11533252],"length":1,"stats":{"Line":0}},{"line":95,"address":[23910052,23909985],"length":1,"stats":{"Line":0}},{"line":96,"address":[23778507],"length":1,"stats":{"Line":0}},{"line":97,"address":[17951324],"length":1,"stats":{"Line":0}},{"line":98,"address":[23710811],"length":1,"stats":{"Line":0}},{"line":101,"address":[23711239,23710928,23710948,23710896,23711036,23710909],"length":1,"stats":{"Line":0}},{"line":102,"address":[23704044,23704126],"length":1,"stats":{"Line":0}},{"line":103,"address":[23814486,23814191,23814160,23814021,23814287,23817486],"length":1,"stats":{"Line":0}},{"line":105,"address":[23704564,23704397],"length":1,"stats":{"Line":0}},{"line":108,"address":[11636585],"length":1,"stats":{"Line":0}},{"line":110,"address":[23772279,23772488,23773351],"length":1,"stats":{"Line":0}},{"line":111,"address":[17953547,18071161,18071295,17953486,17954056],"length":1,"stats":{"Line":0}},{"line":112,"address":[11754914],"length":1,"stats":{"Line":0}},{"line":113,"address":[23911440,23911309,23911385],"length":1,"stats":{"Line":0}},{"line":121,"address":[14388449,14388112],"length":1,"stats":{"Line":0}},{"line":123,"address":[14388147],"length":1,"stats":{"Line":0}},{"line":124,"address":[23707723,23707801],"length":1,"stats":{"Line":0}},{"line":125,"address":[14388314,14388247],"length":1,"stats":{"Line":0}},{"line":126,"address":[23813816],"length":1,"stats":{"Line":0}},{"line":133,"address":[23892069,23891952,23892379,23891903,23892175,23892640,23892152,23891987],"length":1,"stats":{"Line":0}},{"line":134,"address":[11886727],"length":1,"stats":{"Line":0}},{"line":137,"address":[23825109,23824863,23824947,23825026,23825330,23825588,23825132,23824912],"length":1,"stats":{"Line":0}},{"line":138,"address":[23936866,23936557,23936736],"length":1,"stats":{"Line":0}},{"line":141,"address":[23901181,23900416,23900897,23900670,23900367,23900451,23900538,23900717],"length":1,"stats":{"Line":0}},{"line":142,"address":[11844452],"length":1,"stats":{"Line":0}},{"line":145,"address":[23901264,23901940,23901461,23901378,23901299,23901682,23901484,23901215],"length":1,"stats":{"Line":0}},{"line":146,"address":[23894656,23894786,23894477],"length":1,"stats":{"Line":0}},{"line":149,"address":[23937152,23937601,23937270,23937102,23937304,23937426,23937174],"length":1,"stats":{"Line":0}},{"line":150,"address":[11887142],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","topic_service.rs"],"content":"use super::offline_service::{OfflineServiceTrait, SaveOfflineActionParams};\nuse super::p2p_service::P2PServiceTrait;\nuse crate::application::ports::repositories::{\n    PendingTopicRepository, TopicMetricsRepository, TopicRepository,\n};\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::offline::OfflineActionRecord;\nuse crate::domain::entities::{\n    PendingTopic, PendingTopicStatus, Topic, TopicMetricsRecord, TopicVisibility,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload,\n};\nuse crate::shared::{ValidationFailureKind, error::AppError};\nuse chrono::Utc;\nuse serde_json::json;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse uuid::Uuid;\n\n#[derive(Debug, Clone)]\npub struct TopicTrendingEntry {\n    pub topic: Topic,\n    pub trending_score: f64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TrendingDataSource {\n    Metrics,\n    Legacy,\n}\n\npub struct TrendingTopicsResult {\n    pub generated_at: i64,\n    pub entries: Vec<TopicTrendingEntry>,\n    pub data_source: TrendingDataSource,\n}\n\npub struct EnqueuedTopicCreation {\n    pub pending_topic: PendingTopic,\n    pub offline_action: OfflineActionRecord,\n}\n\npub struct TopicService {\n    repository: Arc<dyn TopicRepository>,\n    pending_repository: Arc<dyn PendingTopicRepository>,\n    metrics_repository: Arc<dyn TopicMetricsRepository>,\n    metrics_enabled: bool,\n    p2p: Arc<dyn P2PServiceTrait>,\n    offline_service: Arc<dyn OfflineServiceTrait>,\n}\n\nimpl TopicService {\n    pub fn new(\n        repository: Arc<dyn TopicRepository>,\n        pending_repository: Arc<dyn PendingTopicRepository>,\n        metrics_repository: Arc<dyn TopicMetricsRepository>,\n        metrics_enabled: bool,\n        p2p: Arc<dyn P2PServiceTrait>,\n        offline_service: Arc<dyn OfflineServiceTrait>,\n    ) -> Self {\n        Self {\n            repository,\n            pending_repository,\n            metrics_repository,\n            metrics_enabled,\n            p2p,\n            offline_service,\n        }\n    }\n\n    pub async fn create_topic(\n        &self,\n        name: String,\n        description: Option<String>,\n        visibility: TopicVisibility,\n        creator_pubkey: &str,\n    ) -> Result<Topic, AppError> {\n        let mut topic = Topic::new(name, description);\n        topic.visibility = visibility;\n        self.repository.create_topic(&topic).await?;\n        self.join_topic(&topic.id, creator_pubkey).await?;\n\n        if let Some(mut stored) = self.get_topic(&topic.id).await? {\n            stored.is_joined = true;\n            return Ok(stored);\n        }\n\n        topic.is_joined = true;\n        topic.member_count = topic.member_count.saturating_add(1);\n        Ok(topic)\n    }\n\n    pub async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        self.repository.get_topic(id).await\n    }\n\n    pub async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_all_topics().await\n    }\n\n    pub async fn list_topics_with_membership(\n        &self,\n        user_pubkey: Option<&str>,\n    ) -> Result<Vec<Topic>, AppError> {\n        let mut topics = self.repository.get_all_topics().await?;\n\n        if let Some(pubkey) = user_pubkey {\n            let joined = self.repository.get_joined_topics(pubkey).await?;\n            let joined_ids: HashSet<String> = joined.into_iter().map(|topic| topic.id).collect();\n\n            for topic in topics.iter_mut() {\n                if joined_ids.contains(&topic.id) {\n                    topic.is_joined = true;\n                }\n            }\n        }\n\n        Ok(topics)\n    }\n\n    pub async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_joined_topics(user_pubkey).await\n    }\n\n    pub async fn join_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.join_topic(id, user_pubkey).await?;\n        self.p2p.join_topic(id, Vec::new()).await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.leave_topic(id, user_pubkey).await?;\n        self.p2p.leave_topic(id).await?;\n        Ok(())\n    }\n\n    pub async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        self.repository.update_topic(topic).await\n    }\n\n    pub async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        // Prevent deletion of public topic\n        if id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"Cannot delete public topic\".into());\n        }\n\n        self.p2p.leave_topic(id).await?;\n        self.repository.delete_topic(id).await\n    }\n\n    pub async fn get_topic_stats(&self, id: &str) -> Result<(u32, u32), AppError> {\n        if let Some(topic) = self.repository.get_topic(id).await? {\n            Ok((topic.member_count, topic.post_count))\n        } else {\n            Ok((0, 0))\n        }\n    }\n\n    pub async fn ensure_public_topic(&self) -> Result<(), AppError> {\n        if self\n            .repository\n            .get_topic(DEFAULT_PUBLIC_TOPIC_ID)\n            .await?\n            .is_none()\n        {\n            let public_topic = Topic::public_topic();\n            self.repository.create_topic(&public_topic).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn enqueue_topic_creation(\n        &self,\n        user_pubkey: &str,\n        name: String,\n        description: Option<String>,\n        visibility: TopicVisibility,\n    ) -> Result<EnqueuedTopicCreation, AppError> {\n        let public_key = PublicKey::from_hex_str(user_pubkey).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid pubkey: {err}\"),\n            )\n        })?;\n\n        let pending_id = Uuid::new_v4().to_string();\n        let payload = OfflinePayload::new(json!({\n            \"pendingId\": pending_id,\n            \"name\": name,\n            \"description\": description,\n            \"visibility\": visibility.as_str(),\n        }))\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let action_type = OfflineActionType::new(\"topic_create\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let entity_type = EntityType::new(\"topic\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let entity_id = EntityId::new(pending_id.clone())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n\n        let saved = self\n            .offline_service\n            .save_action(SaveOfflineActionParams {\n                user_pubkey: public_key.clone(),\n                action_type,\n                entity_type,\n                entity_id,\n                payload,\n            })\n            .await?;\n\n        let now = Utc::now();\n        let pending_topic = PendingTopic::new(\n            pending_id,\n            public_key.as_hex().to_string(),\n            name,\n            description,\n            PendingTopicStatus::Queued,\n            saved.local_id.to_string(),\n            None,\n            None,\n            now,\n            now,\n        );\n\n        self.pending_repository\n            .insert_pending_topic(&pending_topic)\n            .await?;\n\n        Ok(EnqueuedTopicCreation {\n            pending_topic,\n            offline_action: saved.action,\n        })\n    }\n\n    pub async fn list_pending_topics(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<PendingTopic>, AppError> {\n        self.pending_repository\n            .list_pending_topics(user_pubkey)\n            .await\n    }\n\n    pub async fn get_pending_topic(\n        &self,\n        pending_id: &str,\n    ) -> Result<Option<PendingTopic>, AppError> {\n        self.pending_repository.get_pending_topic(pending_id).await\n    }\n\n    pub async fn mark_pending_topic_synced(\n        &self,\n        pending_id: &str,\n        topic_id: &str,\n    ) -> Result<(), AppError> {\n        self.pending_repository\n            .update_pending_topic_status(\n                pending_id,\n                PendingTopicStatus::Synced,\n                Some(topic_id),\n                None,\n            )\n            .await\n    }\n\n    pub async fn mark_pending_topic_failed(\n        &self,\n        pending_id: &str,\n        error_message: Option<String>,\n    ) -> Result<(), AppError> {\n        self.pending_repository\n            .update_pending_topic_status(\n                pending_id,\n                PendingTopicStatus::Failed,\n                None,\n                error_message.as_deref(),\n            )\n            .await\n    }\n\n    pub async fn list_trending_topics(\n        &self,\n        limit: usize,\n    ) -> Result<TrendingTopicsResult, AppError> {\n        if limit == 0 {\n            return Ok(TrendingTopicsResult {\n                generated_at: Utc::now().timestamp_millis(),\n                entries: Vec::new(),\n                data_source: TrendingDataSource::Legacy,\n            });\n        }\n\n        if self.metrics_enabled {\n            if let Some(snapshot) = self.metrics_repository.list_recent_metrics(limit).await? {\n                let entries = self\n                    .build_entries_from_metrics(&snapshot.metrics, limit)\n                    .await?;\n\n                if !entries.is_empty() || !snapshot.metrics.is_empty() {\n                    return Ok(TrendingTopicsResult {\n                        generated_at: snapshot.window_end,\n                        entries,\n                        data_source: TrendingDataSource::Metrics,\n                    });\n                }\n            }\n        }\n\n        let mut entries: Vec<TopicTrendingEntry> = self\n            .repository\n            .get_all_topics()\n            .await?\n            .into_iter()\n            .map(|topic| TopicTrendingEntry {\n                trending_score: Self::calculate_trending_score(&topic),\n                topic,\n            })\n            .collect();\n\n        entries.sort_by(|a, b| {\n            b.trending_score\n                .partial_cmp(&a.trending_score)\n                .unwrap_or(std::cmp::Ordering::Equal)\n                .then_with(|| b.topic.updated_at.cmp(&a.topic.updated_at))\n                .then_with(|| a.topic.name.cmp(&b.topic.name))\n        });\n\n        entries.truncate(limit);\n        Ok(TrendingTopicsResult {\n            generated_at: Utc::now().timestamp_millis(),\n            entries,\n            data_source: TrendingDataSource::Legacy,\n        })\n    }\n\n    pub async fn latest_metrics_generated_at(&self) -> Result<Option<i64>, AppError> {\n        if !self.metrics_enabled {\n            return Ok(None);\n        }\n        self.metrics_repository.latest_window_end().await\n    }\n\n    async fn build_entries_from_metrics(\n        &self,\n        metrics: &[TopicMetricsRecord],\n        limit: usize,\n    ) -> Result<Vec<TopicTrendingEntry>, AppError> {\n        if limit == 0 {\n            return Ok(Vec::new());\n        }\n        let mut entries = Vec::new();\n        for record in metrics {\n            if entries.len() >= limit {\n                break;\n            }\n            if let Some(topic) = self.repository.get_topic(&record.topic_id).await? {\n                entries.push(TopicTrendingEntry {\n                    trending_score: record.score_24h,\n                    topic,\n                });\n            }\n        }\n        Ok(entries)\n    }\n\n    fn calculate_trending_score(topic: &Topic) -> f64 {\n        if topic.member_count == 0 && topic.post_count == 0 {\n            0.0\n        } else {\n            (topic.post_count as f64 * 0.6) + (topic.member_count as f64 * 0.4)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::repositories::{\n        PendingTopicRepository as PortPendingTopicRepository,\n        TopicMetricsRepository as PortTopicMetricsRepository,\n        TopicRepository as PortTopicRepository,\n    };\n    use crate::application::services::offline_service::{\n        OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n    };\n    use crate::application::services::p2p_service::{P2PServiceTrait, P2PStatus};\n    use crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\n    use crate::domain::entities::offline::{\n        CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateDraft,\n        SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusUpdate,\n    };\n    use crate::domain::entities::{\n        MetricsWindow, PendingTopic, TopicActivityRow, TopicMetricsSnapshot, TopicMetricsUpsert,\n        TopicVisibility,\n    };\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\n    use crate::shared::config::BootstrapSource;\n    use async_trait::async_trait;\n    use mockall::{mock, predicate::*};\n\n    mock! {\n        pub TopicRepo {}\n\n        #[async_trait]\n        impl PortTopicRepository for TopicRepo {\n            async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n            async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n            async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n            async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n            async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn update_topic_stats(\n                &self,\n                topic_id: &str,\n                member_count: u32,\n                post_count: u32,\n            ) -> Result<(), AppError>;\n        }\n    }\n\n    mock! {\n        pub P2P {}\n\n        #[async_trait]\n        impl P2PServiceTrait for P2P {\n            async fn initialize(&self) -> Result<(), AppError>;\n            async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError>;\n            async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError>;\n            async fn get_status(&self) -> Result<P2PStatus, AppError>;\n            async fn get_node_addresses(&self) -> Result<Vec<String>, AppError>;\n            fn generate_topic_id(&self, topic_name: &str) -> String;\n            async fn apply_bootstrap_nodes(\n                &self,\n                nodes: Vec<String>,\n                source: BootstrapSource,\n            ) -> Result<(), AppError>;\n        }\n    }\n\n    mock! {\n        pub TopicMetricsRepo {}\n\n        #[async_trait]\n        impl PortTopicMetricsRepository for TopicMetricsRepo {\n            async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError>;\n            async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError>;\n            async fn collect_activity(\n                &self,\n                window: MetricsWindow,\n            ) -> Result<Vec<TopicActivityRow>, AppError>;\n            async fn latest_window_end(&self) -> Result<Option<i64>, AppError>;\n            async fn list_recent_metrics(\n                &self,\n                limit: usize,\n            ) -> Result<Option<TopicMetricsSnapshot>, AppError>;\n        }\n    }\n\n    #[derive(Clone)]\n    struct NoopPendingRepo;\n\n    #[async_trait]\n    impl PortPendingTopicRepository for NoopPendingRepo {\n        async fn insert_pending_topic(&self, _topic: &PendingTopic) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn list_pending_topics(\n            &self,\n            _user_pubkey: &str,\n        ) -> Result<Vec<PendingTopic>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn get_pending_topic(\n            &self,\n            _pending_id: &str,\n        ) -> Result<Option<PendingTopic>, AppError> {\n            Ok(None)\n        }\n\n        async fn update_pending_topic_status(\n            &self,\n            _pending_id: &str,\n            _status: PendingTopicStatus,\n            _synced_topic_id: Option<&str>,\n            _error_message: Option<&str>,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn delete_pending_topic(&self, _pending_id: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n    }\n\n    #[derive(Clone)]\n    struct StubOfflineService;\n\n    #[async_trait]\n    impl OfflineServiceTrait for StubOfflineService {\n        async fn save_action(\n            &self,\n            _params: SaveOfflineActionParams,\n        ) -> Result<SavedOfflineAction, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn list_actions(\n            &self,\n            _query: OfflineActionsQuery,\n        ) -> Result<Vec<OfflineActionRecord>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn sync_actions(&self, _user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn enqueue_sync(&self, _draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn recent_sync_queue_items(\n            &self,\n            _limit: Option<u32>,\n        ) -> Result<Vec<SyncQueueItem>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn upsert_cache_metadata(\n            &self,\n            _update: CacheMetadataUpdate,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn save_optimistic_update(\n            &self,\n            _draft: OptimisticUpdateDraft,\n        ) -> Result<OptimisticUpdateId, AppError> {\n            Err(AppError::NotImplemented(\"stub offline service\".to_string()))\n        }\n\n        async fn confirm_optimistic_update(\n            &self,\n            _update_id: OptimisticUpdateId,\n        ) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn rollback_optimistic_update(\n            &self,\n            _update_id: OptimisticUpdateId,\n        ) -> Result<Option<OfflinePayload>, AppError> {\n            Ok(None)\n        }\n\n        async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n            Ok(0)\n        }\n\n        async fn update_sync_status(&self, _update: SyncStatusUpdate) -> Result<(), AppError> {\n            Ok(())\n        }\n    }\n\n    fn build_topic_service(\n        repo: Arc<dyn PortTopicRepository>,\n        metrics_repo: Arc<dyn PortTopicMetricsRepository>,\n        p2p: Arc<dyn P2PServiceTrait>,\n        metrics_enabled: bool,\n    ) -> TopicService {\n        let pending_repo: Arc<dyn PortPendingTopicRepository> = Arc::new(NoopPendingRepo);\n        let offline_service: Arc<dyn OfflineServiceTrait> = Arc::new(StubOfflineService);\n        TopicService::new(\n            repo,\n            pending_repo,\n            metrics_repo,\n            metrics_enabled,\n            p2p,\n            offline_service,\n        )\n    }\n\n    fn topic_with_counts(id: &str, name: &str, members: u32, posts: u32) -> Topic {\n        let mut topic = Topic::new(name.to_string(), Some(format!(\"{name} desc\")));\n        topic.id = id.to_string();\n        topic.member_count = members;\n        topic.post_count = posts;\n        topic\n    }\n\n    #[tokio::test]\n    async fn test_join_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_join_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut p2p = MockP2P::new();\n        p2p.expect_join_topic()\n            .with(eq(\"tech\"), eq(Vec::<String>::new()))\n            .times(1)\n            .returning(|_, _| Ok(()));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service.join_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_leave_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_leave_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut p2p = MockP2P::new();\n        p2p.expect_leave_topic()\n            .with(eq(\"tech\"))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service.leave_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn list_trending_topics_orders_by_score_without_metrics() {\n        let mut repo = MockTopicRepo::new();\n        let topic_alpha = topic_with_counts(\"alpha\", \"Alpha\", 5, 20);\n        let topic_beta = topic_with_counts(\"beta\", \"Beta\", 15, 10);\n        let topic_gamma = topic_with_counts(\"gamma\", \"Gamma\", 2, 5);\n\n        repo.expect_get_all_topics().times(1).returning(move || {\n            Ok(vec![\n                topic_alpha.clone(),\n                topic_beta.clone(),\n                topic_gamma.clone(),\n            ])\n        });\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let result = service\n            .list_trending_topics(3)\n            .await\n            .expect(\"trending topics\");\n\n        assert_eq!(result.entries.len(), 3);\n        assert_eq!(result.entries[0].topic.id, \"alpha\");\n        assert!(result.entries[0].trending_score >= result.entries[1].trending_score);\n        assert_eq!(result.data_source, TrendingDataSource::Legacy);\n    }\n\n    #[tokio::test]\n    async fn list_trending_topics_prefers_metrics_snapshot() {\n        let mut repo = MockTopicRepo::new();\n        let topic_a = topic_with_counts(\"alpha\", \"Alpha\", 5, 10);\n        let topic_b = topic_with_counts(\"beta\", \"Beta\", 3, 15);\n        repo.expect_get_topic()\n            .with(eq(\"alpha\"))\n            .return_once(move |_| Ok(Some(topic_a.clone())));\n        repo.expect_get_topic()\n            .with(eq(\"beta\"))\n            .return_once(move |_| Ok(Some(topic_b.clone())));\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n\n        let mut metrics_repo = MockTopicMetricsRepo::new();\n        metrics_repo\n            .expect_list_recent_metrics()\n            .with(eq(2))\n            .return_once(|_| {\n                Ok(Some(TopicMetricsSnapshot {\n                    window_start: 100,\n                    window_end: 200,\n                    metrics: vec![\n                        TopicMetricsRecord {\n                            topic_id: \"alpha\".into(),\n                            window_start: 100,\n                            window_end: 200,\n                            posts_24h: 10,\n                            posts_6h: 4,\n                            unique_authors: 3,\n                            boosts: 1,\n                            replies: 0,\n                            bookmarks: 0,\n                            participant_delta: 1,\n                            score_24h: 42.0,\n                            score_6h: 21.0,\n                            updated_at: 200,\n                        },\n                        TopicMetricsRecord {\n                            topic_id: \"beta\".into(),\n                            window_start: 100,\n                            window_end: 200,\n                            posts_24h: 5,\n                            posts_6h: 2,\n                            unique_authors: 2,\n                            boosts: 0,\n                            replies: 0,\n                            bookmarks: 0,\n                            participant_delta: 0,\n                            score_24h: 30.0,\n                            score_6h: 15.0,\n                            updated_at: 200,\n                        },\n                    ],\n                }))\n            });\n        metrics_repo\n            .expect_latest_window_end()\n            .returning(|| Ok(Some(200)));\n\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> = Arc::new(metrics_repo);\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, true);\n\n        let result = service\n            .list_trending_topics(2)\n            .await\n            .expect(\"trending topics\");\n\n        assert_eq!(result.generated_at, 200);\n        assert_eq!(result.data_source, TrendingDataSource::Metrics);\n        assert_eq!(result.entries.len(), 2);\n        assert_eq!(result.entries[0].topic.id, \"alpha\");\n        assert_eq!(result.entries[0].trending_score, 42.0);\n    }\n\n    #[tokio::test]\n    async fn list_topics_with_membership_marks_joined_flags() {\n        let mut repo = MockTopicRepo::new();\n        let public = topic_with_counts(DEFAULT_PUBLIC_TOPIC_ID, \"Public\", 0, 0);\n        let private = topic_with_counts(\"private\", \"Private\", 0, 0);\n\n        let public_for_all = public.clone();\n        let private_for_all = private.clone();\n        repo.expect_get_all_topics()\n            .times(1)\n            .returning(move || Ok(vec![public_for_all.clone(), private_for_all.clone()]));\n        let public_for_joined = public.clone();\n        repo.expect_get_joined_topics()\n            .with(eq(\"pubkey1\"))\n            .times(1)\n            .returning(move |_| Ok(vec![public_for_joined.clone()]));\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let topics = service\n            .list_topics_with_membership(Some(\"pubkey1\"))\n            .await\n            .expect(\"topics with membership\");\n\n        assert_eq!(topics.len(), 2);\n        assert!(\n            topics\n                .iter()\n                .any(|topic| topic.id == DEFAULT_PUBLIC_TOPIC_ID && topic.is_joined)\n        );\n        assert!(\n            topics\n                .iter()\n                .any(|topic| topic.id == \"private\" && !topic.is_joined)\n        );\n    }\n\n    #[tokio::test]\n    async fn test_get_joined_topics_passes_user_pubkey() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_get_joined_topics()\n            .with(eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_| Ok(vec![]));\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n        let result = service.get_joined_topics(\"pubkey1\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().len(), 0);\n    }\n\n    #[tokio::test]\n    async fn latest_metrics_generated_at_handles_disabled_metrics() {\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(MockTopicRepo::new());\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        assert!(\n            service\n                .latest_metrics_generated_at()\n                .await\n                .unwrap()\n                .is_none()\n        );\n    }\n\n    #[tokio::test]\n    async fn latest_metrics_generated_at_reads_from_repo() {\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(MockTopicRepo::new());\n        let mut metrics_repo = MockTopicMetricsRepo::new();\n        metrics_repo\n            .expect_latest_window_end()\n            .return_once(|| Ok(Some(999)));\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> = Arc::new(metrics_repo);\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(MockP2P::new());\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, true);\n\n        assert_eq!(\n            service.latest_metrics_generated_at().await.unwrap(),\n            Some(999)\n        );\n    }\n\n    #[tokio::test]\n    async fn create_topic_returns_joined_topic_with_repo_state() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_create_topic().times(1).returning(|_| Ok(()));\n        repo.expect_join_topic()\n            .times(1)\n            .withf(|topic_id, user| !topic_id.is_empty() && user == \"creator\")\n            .return_once(|_, _| Ok(()));\n        repo.expect_get_topic().times(1).returning(|id| {\n            let mut topic = Topic::new(\"My Topic\".to_string(), Some(\"desc\".to_string()));\n            topic.id = id.to_string();\n            topic.member_count = 1;\n            topic.visibility = TopicVisibility::Public;\n            Ok(Some(topic))\n        });\n\n        let repo_arc: Arc<dyn PortTopicRepository> = Arc::new(repo);\n        let metrics_arc: Arc<dyn PortTopicMetricsRepository> =\n            Arc::new(MockTopicMetricsRepo::new());\n        let mut p2p = MockP2P::new();\n        p2p.expect_join_topic()\n            .times(1)\n            .withf(|topic_id, peers| !topic_id.is_empty() && peers.is_empty())\n            .return_once(|_, _| Ok(()));\n        let p2p_arc: Arc<dyn P2PServiceTrait> = Arc::new(p2p);\n        let service = build_topic_service(repo_arc, metrics_arc, p2p_arc, false);\n\n        let topic = service\n            .create_topic(\n                \"My Topic\".to_string(),\n                Some(\"desc\".to_string()),\n                TopicVisibility::Public,\n                \"creator\",\n            )\n            .await\n            .expect(\"topic created\");\n\n        assert!(topic.is_joined);\n        assert!(topic.member_count >= 1);\n    }\n}\n","traces":[{"line":55,"address":[20485408],"length":1,"stats":{"Line":1}},{"line":73,"address":[24679968],"length":1,"stats":{"Line":1}},{"line":80,"address":[24612597],"length":1,"stats":{"Line":1}},{"line":81,"address":[24673613],"length":1,"stats":{"Line":1}},{"line":82,"address":[24613595,24612798,24613045,24612669,24613369,24612889],"length":1,"stats":{"Line":2}},{"line":83,"address":[19281877],"length":1,"stats":{"Line":2}},{"line":85,"address":[18853255,18854597,18854712,18854462,18855463],"length":1,"stats":{"Line":2}},{"line":86,"address":[24675491],"length":1,"stats":{"Line":1}},{"line":87,"address":[24600907],"length":1,"stats":{"Line":1}},{"line":90,"address":[18855287],"length":1,"stats":{"Line":0}},{"line":91,"address":[24607782],"length":1,"stats":{"Line":0}},{"line":92,"address":[20488097],"length":1,"stats":{"Line":0}},{"line":95,"address":[24675808,24676169,24675778,24676009,24675969,24675760,24676438,24675843],"length":1,"stats":{"Line":4}},{"line":96,"address":[24717996,24718121,24718044,24718249],"length":1,"stats":{"Line":2}},{"line":99,"address":[24714886,24714560,24714611,24714698,24714735,24715151,24714568,24714576],"length":1,"stats":{"Line":0}},{"line":100,"address":[18856518,18856277,18856389,18856325],"length":1,"stats":{"Line":0}},{"line":103,"address":[24815536],"length":1,"stats":{"Line":1}},{"line":107,"address":[24609780,24609618,24609452,24610184,24610643,24609521],"length":1,"stats":{"Line":2}},{"line":109,"address":[24679407,24677954,24678077],"length":1,"stats":{"Line":3}},{"line":110,"address":[18858060,18857062,18857831,18858638,18858228],"length":1,"stats":{"Line":2}},{"line":111,"address":[24720907,24721552,24721100,24721580],"length":1,"stats":{"Line":4}},{"line":113,"address":[24611298,24611548,24611385],"length":1,"stats":{"Line":3}},{"line":114,"address":[24618544,24618584,24618604],"length":1,"stats":{"Line":3}},{"line":115,"address":[24723125],"length":1,"stats":{"Line":1}},{"line":120,"address":[24685089],"length":1,"stats":{"Line":1}},{"line":123,"address":[20492269,20492718,20492462,20492064,20492082,20492147,20492309,20492112],"length":1,"stats":{"Line":4}},{"line":124,"address":[24718060,24718314,24718108,24718185],"length":1,"stats":{"Line":2}},{"line":127,"address":[24612640,24612668,24612704,24612939,24612751,24613880,24613003,24613207],"length":1,"stats":{"Line":4}},{"line":128,"address":[24620215,24620058,24619945,24619876,24620519,24620800],"length":1,"stats":{"Line":2}},{"line":129,"address":[24688905,24687726,24688242,24688625,24688384],"length":1,"stats":{"Line":2}},{"line":130,"address":[24621132],"length":1,"stats":{"Line":1}},{"line":133,"address":[24820572,24821693,24820834,24821087,24820544,24820608,24820655,24820898],"length":1,"stats":{"Line":4}},{"line":134,"address":[24720751,24721055,24720430,24720496,24721269,24720600],"length":1,"stats":{"Line":2}},{"line":135,"address":[10864817],"length":1,"stats":{"Line":2}},{"line":136,"address":[18863201],"length":1,"stats":{"Line":1}},{"line":139,"address":[24725680,24725715,24725648,24726019,24725864,24725661,24726283,24725824],"length":1,"stats":{"Line":0}},{"line":140,"address":[11521172],"length":1,"stats":{"Line":0}},{"line":143,"address":[24727952,24727970,24728182,24728593,24728246,24728047,24729144,24728000],"length":1,"stats":{"Line":0}},{"line":145,"address":[24722713,24722564],"length":1,"stats":{"Line":0}},{"line":146,"address":[24726692,24726865],"length":1,"stats":{"Line":0}},{"line":149,"address":[11619969],"length":1,"stats":{"Line":0}},{"line":150,"address":[24609945,24610732,24610865,24610604],"length":1,"stats":{"Line":0}},{"line":153,"address":[24824256,24824417,24824226,24824291,24824208,24825266,24824618,24824457],"length":1,"stats":{"Line":0}},{"line":154,"address":[24730478,24729737,24729660,24729866,24729612],"length":1,"stats":{"Line":0}},{"line":155,"address":[24728689],"length":1,"stats":{"Line":0}},{"line":157,"address":[24612160],"length":1,"stats":{"Line":0}},{"line":161,"address":[24825296,24825343,24825459,24826524,24825288,24825523,24825280,24825707],"length":1,"stats":{"Line":0}},{"line":162,"address":[18867114,18867765,18867471,18867386,18867178,18866895,18866652,18866818],"length":1,"stats":{"Line":0}},{"line":165,"address":[24825884,24825489,24825739,24826106,24825679,24825632],"length":1,"stats":{"Line":0}},{"line":168,"address":[24731512],"length":1,"stats":{"Line":0}},{"line":169,"address":[11622629],"length":1,"stats":{"Line":0}},{"line":171,"address":[24687803],"length":1,"stats":{"Line":0}},{"line":174,"address":[24726624],"length":1,"stats":{"Line":0}},{"line":181,"address":[24614890,24619295,24614540,24622491,24614671,24622272],"length":1,"stats":{"Line":0}},{"line":182,"address":[24739087],"length":1,"stats":{"Line":0}},{"line":183,"address":[24738933],"length":1,"stats":{"Line":0}},{"line":184,"address":[24636117,24636058],"length":1,"stats":{"Line":0}},{"line":188,"address":[24614820,24614990],"length":1,"stats":{"Line":0}},{"line":189,"address":[24734761,24734318,24735034,24734715,24737485,24733335,24734391,24734851,24737420,24733377],"length":1,"stats":{"Line":0}},{"line":193,"address":[24697508,24697607],"length":1,"stats":{"Line":0}},{"line":195,"address":[24693767,24691057,24689646,24691290,24690937],"length":1,"stats":{"Line":0}},{"line":196,"address":[24625854,24623762,24624035,24623451,24623602,24623716,24623852],"length":1,"stats":{"Line":0}},{"line":197,"address":[18871087,18873414,18871274,18871507,18871157],"length":1,"stats":{"Line":0}},{"line":198,"address":[20503632,20503943,20504199,20503885,20504013,20503795,20505408],"length":1,"stats":{"Line":0}},{"line":199,"address":[24619048,24617288,24617475,24617711,24617358],"length":1,"stats":{"Line":0}},{"line":200,"address":[24699465,24699197,24699511,24699601,24699351,24700457,24699799],"length":1,"stats":{"Line":0}},{"line":201,"address":[24624650,24624580,24625015,24625761,24624767],"length":1,"stats":{"Line":0}},{"line":203,"address":[24618185,24618878,24619787,24618787,24619495,24619569,24620914],"length":1,"stats":{"Line":0}},{"line":205,"address":[24736915],"length":1,"stats":{"Line":0}},{"line":206,"address":[24625180],"length":1,"stats":{"Line":0}},{"line":207,"address":[24731143],"length":1,"stats":{"Line":0}},{"line":208,"address":[24831558],"length":1,"stats":{"Line":0}},{"line":209,"address":[24831605],"length":1,"stats":{"Line":0}},{"line":210,"address":[24735220],"length":1,"stats":{"Line":0}},{"line":212,"address":[24628349,24633115,24633257,24633499,24632595,24632660],"length":1,"stats":{"Line":0}},{"line":214,"address":[20506089],"length":1,"stats":{"Line":0}},{"line":216,"address":[24694467],"length":1,"stats":{"Line":0}},{"line":217,"address":[24732744,24732640],"length":1,"stats":{"Line":0}},{"line":218,"address":[24701587],"length":1,"stats":{"Line":0}},{"line":219,"address":[24626906],"length":1,"stats":{"Line":0}},{"line":220,"address":[24694769],"length":1,"stats":{"Line":0}},{"line":221,"address":[24694777],"length":1,"stats":{"Line":0}},{"line":222,"address":[24634030],"length":1,"stats":{"Line":0}},{"line":223,"address":[24736918],"length":1,"stats":{"Line":0}},{"line":228,"address":[24737179,24737667,24737363,24737304,24738094,24737787],"length":1,"stats":{"Line":0}},{"line":229,"address":[24738937],"length":1,"stats":{"Line":0}},{"line":230,"address":[11665369],"length":1,"stats":{"Line":0}},{"line":232,"address":[18875619],"length":1,"stats":{"Line":0}},{"line":233,"address":[24739491],"length":1,"stats":{"Line":0}},{"line":234,"address":[24635020],"length":1,"stats":{"Line":0}},{"line":238,"address":[20508768],"length":1,"stats":{"Line":0}},{"line":242,"address":[24629500,24629688,24629629,24629854],"length":1,"stats":{"Line":0}},{"line":244,"address":[11754388],"length":1,"stats":{"Line":0}},{"line":247,"address":[24636992],"length":1,"stats":{"Line":0}},{"line":251,"address":[11643844],"length":1,"stats":{"Line":0}},{"line":254,"address":[24736640],"length":1,"stats":{"Line":0}},{"line":259,"address":[24742489,24742776,24742957,24742667],"length":1,"stats":{"Line":0}},{"line":262,"address":[24837415],"length":1,"stats":{"Line":0}},{"line":263,"address":[24737055],"length":1,"stats":{"Line":0}},{"line":264,"address":[24631151],"length":1,"stats":{"Line":0}},{"line":266,"address":[10958260],"length":1,"stats":{"Line":0}},{"line":269,"address":[24741472],"length":1,"stats":{"Line":0}},{"line":274,"address":[24706605,24707095,24706914,24706821],"length":1,"stats":{"Line":0}},{"line":277,"address":[24638978],"length":1,"stats":{"Line":0}},{"line":278,"address":[24632010],"length":1,"stats":{"Line":0}},{"line":279,"address":[20511394],"length":1,"stats":{"Line":0}},{"line":281,"address":[19342878],"length":1,"stats":{"Line":0}},{"line":284,"address":[24639584],"length":1,"stats":{"Line":1}},{"line":288,"address":[24707532],"length":1,"stats":{"Line":1}},{"line":289,"address":[24738973],"length":1,"stats":{"Line":0}},{"line":290,"address":[24639874,24639967],"length":1,"stats":{"Line":0}},{"line":291,"address":[24707754],"length":1,"stats":{"Line":0}},{"line":292,"address":[24744549],"length":1,"stats":{"Line":0}},{"line":296,"address":[24632917],"length":1,"stats":{"Line":1}},{"line":297,"address":[24744095,24743119,24742699,24743343],"length":1,"stats":{"Line":1}},{"line":298,"address":[24740582,24741091,24740278,24740392,24740055,24740101,24739912],"length":1,"stats":{"Line":5}},{"line":299,"address":[24740043,24739929],"length":1,"stats":{"Line":2}},{"line":300,"address":[24745757,24744368,24745715,24745910,24746118,24745658],"length":1,"stats":{"Line":3}},{"line":302,"address":[24746251,24746092,24746445],"length":1,"stats":{"Line":2}},{"line":303,"address":[20514090],"length":1,"stats":{"Line":1}},{"line":304,"address":[24740677],"length":1,"stats":{"Line":1}},{"line":305,"address":[24634769],"length":1,"stats":{"Line":1}},{"line":306,"address":[24744673],"length":1,"stats":{"Line":1}},{"line":312,"address":[24628284,24628343,24628611,24628770,24626437,24629209,24628497],"length":1,"stats":{"Line":5}},{"line":315,"address":[24635143,24635176,24635329,24635506,24635096,24632885],"length":1,"stats":{"Line":3}},{"line":317,"address":[24703969,24703922,24703808],"length":1,"stats":{"Line":2}},{"line":318,"address":[20515236],"length":1,"stats":{"Line":1}},{"line":319,"address":[24710830],"length":1,"stats":{"Line":1}},{"line":323,"address":[20514929,20515376,20514862],"length":1,"stats":{"Line":3}},{"line":324,"address":[18883776,18883752,18883766],"length":1,"stats":{"Line":3}},{"line":325,"address":[24746095],"length":1,"stats":{"Line":1}},{"line":326,"address":[24636251],"length":1,"stats":{"Line":1}},{"line":327,"address":[20515518,20515504],"length":1,"stats":{"Line":0}},{"line":328,"address":[24747888,24747902],"length":1,"stats":{"Line":0}},{"line":331,"address":[24635739],"length":1,"stats":{"Line":1}},{"line":332,"address":[24710610],"length":1,"stats":{"Line":1}},{"line":333,"address":[24745626],"length":1,"stats":{"Line":1}},{"line":334,"address":[18883338],"length":1,"stats":{"Line":1}},{"line":335,"address":[20515059],"length":1,"stats":{"Line":1}},{"line":339,"address":[20516028,20515616,20515886,20515651,20515600,20515730,20515608,20516289],"length":1,"stats":{"Line":4}},{"line":340,"address":[24742474],"length":1,"stats":{"Line":1}},{"line":341,"address":[24842890],"length":1,"stats":{"Line":1}},{"line":343,"address":[19351092],"length":1,"stats":{"Line":2}},{"line":346,"address":[24711904],"length":1,"stats":{"Line":1}},{"line":351,"address":[24712156],"length":1,"stats":{"Line":1}},{"line":352,"address":[24712216,24712308],"length":1,"stats":{"Line":0}},{"line":354,"address":[24747355],"length":1,"stats":{"Line":1}},{"line":355,"address":[24645521,24644765,24644674,24645663],"length":1,"stats":{"Line":4}},{"line":356,"address":[24844995],"length":1,"stats":{"Line":1}},{"line":359,"address":[11684276],"length":1,"stats":{"Line":2}},{"line":360,"address":[24750036,24749966,24749915],"length":1,"stats":{"Line":3}},{"line":361,"address":[24844719],"length":1,"stats":{"Line":1}},{"line":366,"address":[24748438],"length":1,"stats":{"Line":1}},{"line":369,"address":[24750480],"length":1,"stats":{"Line":1}},{"line":370,"address":[24845274,24845358],"length":1,"stats":{"Line":2}},{"line":371,"address":[20518144],"length":1,"stats":{"Line":0}},{"line":373,"address":[24750518],"length":1,"stats":{"Line":1}}],"covered":72,"coverable":157},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","user_search_service.rs"],"content":"use crate::application::ports::repositories::UserRepository;\r\nuse crate::domain::entities::User;\r\nuse crate::shared::{AppError, RateLimiter, ValidationFailureKind};\r\nuse chrono::Utc;\r\nuse std::cmp::Ordering;\r\nuse std::collections::HashSet;\nuse std::iter::FromIterator;\r\nuse std::sync::Arc;\r\nuse std::time::{Duration, Instant};\n\r\npub(crate) const DEFAULT_LIMIT: usize = 20;\r\npub(crate) const MAX_LIMIT: usize = 50;\r\npub(crate) const MAX_FETCH: usize = 250;\r\nconst RATE_LIMIT_MAX_REQUESTS: usize = 30;\r\nconst RATE_LIMIT_WINDOW: Duration = Duration::from_secs(10);\r\n\r\n#[derive(Clone, Copy)]\r\npub enum SearchSort {\r\n    Relevance,\r\n    Recency,\r\n}\r\n\r\nimpl SearchSort {\r\n    pub fn try_from_str(value: Option<&str>) -> Result<Self, AppError> {\r\n        match value.unwrap_or(\"relevance\").to_lowercase().as_str() {\r\n            \"relevance\" => Ok(SearchSort::Relevance),\r\n            \"recency\" => Ok(SearchSort::Recency),\r\n            other => Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Unsupported search sort: {other}\"),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\npub struct SearchUsersParams {\r\n    pub query: String,\r\n    pub cursor: Option<String>,\r\n    pub limit: usize,\r\n    pub sort: SearchSort,\r\n    pub allow_incomplete: bool,\r\n    pub viewer_pubkey: Option<String>,\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct SearchUsersResult {\r\n    pub users: Vec<User>,\r\n    pub next_cursor: Option<String>,\r\n    pub has_more: bool,\r\n    pub total_count: usize,\r\n    pub took_ms: u128,\r\n}\r\n\r\npub struct UserSearchService {\r\n    repository: Arc<dyn UserRepository>,\r\n    rate_limiter: RateLimiter,\r\n}\r\n\r\nimpl UserSearchService {\r\n    pub fn new(repository: Arc<dyn UserRepository>) -> Self {\r\n        Self {\r\n            repository,\r\n            rate_limiter: RateLimiter::new(RATE_LIMIT_MAX_REQUESTS, RATE_LIMIT_WINDOW),\r\n        }\r\n    }\r\n\r\n    pub async fn search(&self, params: SearchUsersParams) -> Result<SearchUsersResult, AppError> {\r\n        let normalized_query = params.query.trim();\r\n        if normalized_query.len() < 2 && !params.allow_incomplete {\r\n            return Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                \"検索キーワードは2文字以上で入力してください\",\r\n            ));\r\n        }\r\n\r\n        let rate_key = params\r\n            .viewer_pubkey\r\n            .clone()\r\n            .unwrap_or_else(|| format!(\"anon:{}\", normalized_query.to_lowercase()));\r\n        self.rate_limiter\r\n            .check_and_record(&rate_key, \"一定時間内に繰り返し検索が実行されています\")\r\n            .await?;\r\n\r\n        let start = Instant::now();\r\n        let fetch_limit = MAX_FETCH.min(params.limit + MAX_LIMIT);\r\n        let raw_users = self\r\n            .repository\r\n            .search_users(normalized_query, fetch_limit)\r\n            .await?;\r\n\r\n        let (following, followers) = if let Some(pubkey) = params.viewer_pubkey.as_ref() {\r\n            let following = self.repository.list_following_pubkeys(pubkey).await?;\r\n            let followers = self.repository.list_follower_pubkeys(pubkey).await?;\r\n            (\r\n                HashSet::from_iter(following.into_iter()),\r\n                HashSet::from_iter(followers.into_iter()),\r\n            )\r\n        } else {\r\n            (HashSet::new(), HashSet::new())\r\n        };\r\n\r\n        let query_lower = normalized_query.to_lowercase();\r\n        let mut ranked: Vec<RankedUser> = raw_users\r\n            .into_iter()\r\n            .map(|user| {\r\n                let rank = compute_rank(&user, &query_lower, &following, &followers);\r\n                RankedUser { user, rank }\r\n            })\r\n            .collect();\r\n\r\n        match params.sort {\r\n            SearchSort::Relevance => ranked.sort_by(|a, b| {\r\n                b.rank\r\n                    .partial_cmp(&a.rank)\r\n                    .unwrap_or(Ordering::Equal)\r\n                    .then_with(|| a.user.npub.cmp(&b.user.npub))\r\n            }),\r\n            SearchSort::Recency => ranked.sort_by(|a, b| {\r\n                b.user\r\n                    .updated_at\r\n                    .cmp(&a.user.updated_at)\r\n                    .then_with(|| a.user.npub.cmp(&b.user.npub))\r\n            }),\r\n        }\r\n\r\n        let total_count = ranked.len();\r\n        let start_index = cursor_start_index(&ranked, &params)?;\r\n        let end_index = (start_index + params.limit).min(total_count);\r\n        let has_more = end_index < total_count;\r\n\r\n        let users: Vec<User> = ranked[start_index..end_index]\r\n            .iter()\r\n            .map(|entry| entry.user.clone())\r\n            .collect();\r\n\r\n        let next_cursor = if has_more && !users.is_empty() {\r\n            Some(encode_cursor(params.sort, &ranked[end_index - 1]))\r\n        } else {\r\n            None\r\n        };\r\n\r\n        Ok(SearchUsersResult {\r\n            users,\r\n            next_cursor,\r\n            has_more,\r\n            total_count,\r\n            took_ms: start.elapsed().as_millis(),\r\n        })\r\n    }\r\n}\r\n\r\nstruct RankedUser {\r\n    user: User,\r\n    rank: f64,\r\n}\r\n\r\nfn cursor_start_index(\r\n    ranked: &[RankedUser],\r\n    params: &SearchUsersParams,\r\n) -> Result<usize, AppError> {\r\n    if let Some(cursor) = params.cursor.as_ref() {\r\n        match parse_cursor(cursor)? {\r\n            Cursor::Relevance { rank, npub } => {\r\n                if matches!(params.sort, SearchSort::Relevance) {\r\n                    if let Some(pos) = ranked.iter().position(|entry| {\r\n                        entry.user.npub == npub && (entry.rank - rank).abs() < f64::EPSILON\r\n                    }) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                    if let Some(pos) = ranked.iter().position(|entry| entry.user.npub == npub) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                }\r\n            }\r\n            Cursor::Recency { updated_at, npub } => {\r\n                if matches!(params.sort, SearchSort::Recency) {\r\n                    if let Some(pos) = ranked.iter().position(|entry| {\r\n                        entry.user.npub == npub\r\n                            && entry.user.updated_at.timestamp_millis() == updated_at\r\n                    }) {\r\n                        return Ok(pos + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Ok(0)\r\n}\r\n\r\nfn compute_rank(\r\n    user: &User,\r\n    query: &str,\r\n    following: &HashSet<String>,\r\n    followers: &HashSet<String>,\r\n) -> f64 {\r\n    let text_score = compute_text_score(user, query);\r\n    let mutual_score = compute_mutual_score(user, following, followers);\r\n    let recency_score = compute_recency_score(user);\r\n    text_score * 0.7 + mutual_score * 0.2 + recency_score * 0.1\r\n}\r\n\r\nfn compute_text_score(user: &User, query: &str) -> f64 {\r\n    let lowered = query.to_lowercase();\r\n    let mut score = 0.0;\r\n\r\n    let name = user.profile.display_name.to_lowercase();\r\n    if name.starts_with(&lowered) {\r\n        score += 4.0;\r\n    } else if name.contains(&lowered) {\r\n        score += 3.0;\r\n    }\r\n\r\n    if user.npub.to_lowercase().contains(&lowered) {\r\n        score += 2.0;\r\n    }\r\n\r\n    if user.profile.bio.to_lowercase().contains(&lowered) {\r\n        score += 1.0;\r\n    }\r\n\r\n    score\r\n}\r\n\r\nfn compute_mutual_score(\r\n    user: &User,\r\n    following: &HashSet<String>,\r\n    followers: &HashSet<String>,\r\n) -> f64 {\r\n    let mut score = 0.0;\r\n    if following.contains(user.pubkey()) {\r\n        score += 1.0;\r\n    }\r\n    if followers.contains(user.pubkey()) {\r\n        score += 1.0;\r\n    }\r\n    score\r\n}\r\n\r\nfn compute_recency_score(user: &User) -> f64 {\r\n    let now = Utc::now();\r\n    let elapsed = now\r\n        .signed_duration_since(user.updated_at)\r\n        .num_seconds()\r\n        .max(0) as f64;\r\n    let hours = elapsed / 3600.0;\r\n    1.0 / (1.0 + hours)\r\n}\r\n\r\nenum Cursor {\r\n    Relevance { rank: f64, npub: String },\r\n    Recency { updated_at: i64, npub: String },\r\n}\r\n\r\nfn encode_cursor(sort: SearchSort, entry: &RankedUser) -> String {\r\n    match sort {\r\n        SearchSort::Relevance => format!(\"rel:{:.5}:{}\", entry.rank, entry.user.npub),\r\n        SearchSort::Recency => format!(\r\n            \"rec:{}:{}\",\r\n            entry.user.updated_at.timestamp_millis(),\r\n            entry.user.npub\r\n        ),\r\n    }\r\n}\r\n\r\nfn parse_cursor(cursor: &str) -> Result<Cursor, AppError> {\r\n    let mut parts = cursor.splitn(3, ':');\r\n    match parts.next() {\r\n        Some(\"rel\") => {\r\n            let rank = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?\r\n                .parse::<f64>()\r\n                .map_err(|_| AppError::InvalidInput(\"Invalid cursor rank\".into()))?;\r\n            let npub = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?;\r\n            Ok(Cursor::Relevance {\r\n                rank,\r\n                npub: npub.to_string(),\r\n            })\r\n        }\r\n        Some(\"rec\") => {\r\n            let timestamp = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?\r\n                .parse::<i64>()\r\n                .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\r\n            let npub = parts\r\n                .next()\r\n                .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor\".into()))?;\r\n            Ok(Cursor::Recency {\r\n                updated_at: timestamp,\r\n                npub: npub.to_string(),\r\n            })\r\n        }\r\n        _ => Err(AppError::InvalidInput(\"Invalid cursor prefix\".into())),\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::repositories::UserRepository;\r\n    use crate::infrastructure::database::{\r\n        connection_pool::ConnectionPool, repository::Repository,\r\n        sqlite_repository::SqliteRepository,\r\n    };\r\n    use chrono::{Duration as ChronoDuration, Utc};\r\n\r\n    async fn setup_service() -> (UserSearchService, Arc<SqliteRepository>) {\r\n        let pool = ConnectionPool::from_memory().await.unwrap();\r\n        let repository = Arc::new(SqliteRepository::new(pool.clone()));\r\n        repository.initialize().await.unwrap();\r\n        let service = UserSearchService::new(Arc::clone(&repository) as Arc<dyn UserRepository>);\r\n        (service, repository)\r\n    }\r\n\r\n    async fn insert_user(\r\n        repository: &Arc<SqliteRepository>,\r\n        npub: &str,\r\n        display_name: &str,\r\n        bio: &str,\r\n        updated_offset_secs: i64,\r\n    ) -> User {\r\n        let pubkey = format!(\"pubkey_{npub}\");\r\n        let mut user = User::new(npub.to_string(), pubkey.clone());\r\n        user.profile.display_name = display_name.to_string();\r\n        user.profile.bio = bio.to_string();\r\n        user.updated_at = Utc::now() - ChronoDuration::seconds(updated_offset_secs);\r\n        repository.create_user(&user).await.unwrap();\r\n        user\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_returns_ranked_results_with_cursor() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 10).await;\r\n        insert_user(&repository, \"npub1alicia\", \"Alicia\", \"nostr dev\", 20).await;\r\n        insert_user(&repository, \"npub1bob\", \"Bob\", \"rustacean\", 5).await;\r\n\r\n        let first = service\r\n            .search(SearchUsersParams {\r\n                query: \"ali\".to_string(),\r\n                cursor: None,\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"first page\");\r\n\r\n        assert_eq!(first.users.len(), 1);\r\n        assert!(first.has_more);\r\n        let cursor = first.next_cursor.clone().expect(\"cursor present\");\r\n\r\n        let second = service\r\n            .search(SearchUsersParams {\r\n                query: \"ali\".to_string(),\r\n                cursor: Some(cursor),\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"second page\");\r\n\r\n        assert_eq!(second.users.len(), 1);\r\n        assert_ne!(first.users[0].npub, second.users[0].npub);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_prioritizes_follow_relationships() {\r\n        let (service, repository) = setup_service().await;\r\n        let viewer = insert_user(&repository, \"npub1viewer\", \"Viewer\", \"viewer\", 1).await;\r\n        let alice = insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 10).await;\r\n        let bob = insert_user(&repository, \"npub1bob\", \"Bob\", \"nostr dev\", 5).await;\r\n\r\n        repository\r\n            .add_follow_relation(viewer.pubkey(), alice.pubkey())\r\n            .await\r\n            .unwrap();\r\n        repository\r\n            .add_follow_relation(alice.pubkey(), viewer.pubkey())\r\n            .await\r\n            .unwrap();\r\n\r\n        let result = service\r\n            .search(SearchUsersParams {\r\n                query: \"nostr\".to_string(),\r\n                cursor: None,\r\n                limit: 5,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: Some(viewer.pubkey().to_string()),\r\n            })\r\n            .await\r\n            .expect(\"search\");\r\n\r\n        assert_eq!(result.users.first().unwrap().npub, alice.npub);\r\n        assert!(result.users.iter().any(|user| user.npub == bob.npub));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn rate_limiter_blocks_excess_requests() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 1).await;\r\n\r\n        for _ in 0..RATE_LIMIT_MAX_REQUESTS {\r\n            service\r\n                .search(SearchUsersParams {\r\n                    query: \"alice\".to_string(),\r\n                    cursor: None,\r\n                    limit: 1,\r\n                    sort: SearchSort::Relevance,\r\n                    allow_incomplete: false,\r\n                    viewer_pubkey: None,\r\n                })\r\n                .await\r\n                .expect(\"search within limit\");\r\n        }\r\n\r\n        let err = service\r\n            .search(SearchUsersParams {\r\n                query: \"alice\".to_string(),\r\n                cursor: None,\r\n                limit: 1,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: false,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect_err(\"rate limit triggered\");\r\n        assert!(matches!(err, AppError::RateLimited { .. }));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn allow_incomplete_accepts_short_queries() {\r\n        let (service, repository) = setup_service().await;\r\n        insert_user(&repository, \"npub1alice\", \"Alice\", \"nostr dev\", 1).await;\r\n\r\n        let result = service\r\n            .search(SearchUsersParams {\r\n                query: \"a\".to_string(),\r\n                cursor: None,\r\n                limit: 5,\r\n                sort: SearchSort::Relevance,\r\n                allow_incomplete: true,\r\n                viewer_pubkey: None,\r\n            })\r\n            .await\r\n            .expect(\"short query allowed\");\r\n\r\n        assert_eq!(result.total_count, 1);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[24690496,24691058],"length":1,"stats":{"Line":0}},{"line":25,"address":[15182335,15182219],"length":1,"stats":{"Line":0}},{"line":26,"address":[24690758,24690687],"length":1,"stats":{"Line":0}},{"line":27,"address":[15175521,15175593,15175466],"length":1,"stats":{"Line":0}},{"line":28,"address":[22876100,22875921],"length":1,"stats":{"Line":0}},{"line":29,"address":[22875937],"length":1,"stats":{"Line":0}},{"line":30,"address":[15182489,15182544],"length":1,"stats":{"Line":0}},{"line":60,"address":[15213936,15214099],"length":1,"stats":{"Line":2}},{"line":63,"address":[15108059],"length":1,"stats":{"Line":2}},{"line":67,"address":[15101459,15103454,15102573,15108299,15101504,15101551,15101791,15101424],"length":1,"stats":{"Line":5}},{"line":68,"address":[15101961,15101753],"length":1,"stats":{"Line":3}},{"line":69,"address":[22877013,22877101],"length":1,"stats":{"Line":2}},{"line":70,"address":[15108934],"length":1,"stats":{"Line":0}},{"line":71,"address":[22877118],"length":1,"stats":{"Line":0}},{"line":76,"address":[15176877,15176680],"length":1,"stats":{"Line":3}},{"line":79,"address":[22877239,22883707,22883680],"length":1,"stats":{"Line":4}},{"line":80,"address":[15221711,15220735,15220606,15221131,15221279,15220794,15221004],"length":1,"stats":{"Line":9}},{"line":81,"address":[24692182],"length":1,"stats":{"Line":2}},{"line":82,"address":[15315836,15315677,15315551,15314893,15316015,15315611],"length":1,"stats":{"Line":5}},{"line":84,"address":[15215755,15215599],"length":1,"stats":{"Line":3}},{"line":85,"address":[15103057],"length":1,"stats":{"Line":1}},{"line":86,"address":[15110358,15110485,15110151,15111466,15109941,15110068,15110707],"length":1,"stats":{"Line":11}},{"line":88,"address":[15215966],"length":1,"stats":{"Line":1}},{"line":89,"address":[15101842,15103389,15103463,15103324,15103622,15103875],"length":1,"stats":{"Line":9}},{"line":91,"address":[15317614,15316910,15319413,15317088],"length":1,"stats":{"Line":9}},{"line":92,"address":[10904767],"length":1,"stats":{"Line":3}},{"line":93,"address":[11647988],"length":1,"stats":{"Line":3}},{"line":95,"address":[15105891,15106097],"length":1,"stats":{"Line":2}},{"line":96,"address":[15187644,15187755],"length":1,"stats":{"Line":2}},{"line":99,"address":[15216819,15217127],"length":1,"stats":{"Line":4}},{"line":102,"address":[15118398],"length":1,"stats":{"Line":2}},{"line":103,"address":[15224850,15224678],"length":1,"stats":{"Line":4}},{"line":105,"address":[24696222,24698857,24698640],"length":1,"stats":{"Line":4}},{"line":106,"address":[15183667,15183748],"length":1,"stats":{"Line":3}},{"line":107,"address":[24698791],"length":1,"stats":{"Line":3}},{"line":111,"address":[15181216],"length":1,"stats":{"Line":3}},{"line":112,"address":[15322368,15319851,15319721],"length":1,"stats":{"Line":7}},{"line":113,"address":[15227624,15227638,15227648],"length":1,"stats":{"Line":3}},{"line":114,"address":[22884319],"length":1,"stats":{"Line":1}},{"line":115,"address":[15225995],"length":1,"stats":{"Line":1}},{"line":116,"address":[15322494,15322480],"length":1,"stats":{"Line":0}},{"line":118,"address":[15219388,15219539,15222160],"length":1,"stats":{"Line":0}},{"line":119,"address":[22884488,22884474],"length":1,"stats":{"Line":0}},{"line":121,"address":[15322577],"length":1,"stats":{"Line":0}},{"line":122,"address":[15116336,15116350],"length":1,"stats":{"Line":0}},{"line":126,"address":[15319928,15319864],"length":1,"stats":{"Line":4}},{"line":127,"address":[15107052,15106864],"length":1,"stats":{"Line":2}},{"line":128,"address":[15225310,15225441],"length":1,"stats":{"Line":6}},{"line":129,"address":[24696877],"length":1,"stats":{"Line":3}},{"line":131,"address":[15114030,15114111],"length":1,"stats":{"Line":6}},{"line":133,"address":[24699184,24699219],"length":1,"stats":{"Line":6}},{"line":136,"address":[15121202,15121275,15121180],"length":1,"stats":{"Line":6}},{"line":137,"address":[15220233],"length":1,"stats":{"Line":1}},{"line":139,"address":[15320496],"length":1,"stats":{"Line":2}},{"line":142,"address":[15224567],"length":1,"stats":{"Line":3}},{"line":143,"address":[24697328],"length":1,"stats":{"Line":2}},{"line":144,"address":[15320816],"length":1,"stats":{"Line":2}},{"line":147,"address":[15224416,15224504],"length":1,"stats":{"Line":5}},{"line":157,"address":[15322736,15323793],"length":1,"stats":{"Line":2}},{"line":161,"address":[15109746],"length":1,"stats":{"Line":2}},{"line":162,"address":[24699393,24699472],"length":1,"stats":{"Line":2}},{"line":163,"address":[15116791],"length":1,"stats":{"Line":1}},{"line":164,"address":[22885049],"length":1,"stats":{"Line":1}},{"line":165,"address":[15124057,15123963,15124816],"length":1,"stats":{"Line":3}},{"line":166,"address":[15124853],"length":1,"stats":{"Line":1}},{"line":168,"address":[15228765,15228699],"length":1,"stats":{"Line":0}},{"line":170,"address":[22885419,22885511,22886185,22886160],"length":1,"stats":{"Line":4}},{"line":171,"address":[15124405],"length":1,"stats":{"Line":1}},{"line":175,"address":[24699682],"length":1,"stats":{"Line":0}},{"line":176,"address":[15191684],"length":1,"stats":{"Line":0}},{"line":177,"address":[15227490,15227872,15227399],"length":1,"stats":{"Line":0}},{"line":178,"address":[15118053],"length":1,"stats":{"Line":0}},{"line":179,"address":[15118077],"length":1,"stats":{"Line":0}},{"line":181,"address":[15229256,15229309],"length":1,"stats":{"Line":0}},{"line":187,"address":[22884849],"length":1,"stats":{"Line":2}},{"line":190,"address":[15227984],"length":1,"stats":{"Line":2}},{"line":196,"address":[15185979],"length":1,"stats":{"Line":1}},{"line":197,"address":[15324490],"length":1,"stats":{"Line":2}},{"line":198,"address":[15118224],"length":1,"stats":{"Line":3}},{"line":199,"address":[15118250],"length":1,"stats":{"Line":3}},{"line":202,"address":[22886496,22887456],"length":1,"stats":{"Line":2}},{"line":203,"address":[15186151],"length":1,"stats":{"Line":1}},{"line":204,"address":[15228224],"length":1,"stats":{"Line":2}},{"line":206,"address":[15186188,15186275],"length":1,"stats":{"Line":3}},{"line":207,"address":[15186302,15186469,15186385],"length":1,"stats":{"Line":5}},{"line":208,"address":[15224555],"length":1,"stats":{"Line":1}},{"line":209,"address":[15224538,15224593,15224677],"length":1,"stats":{"Line":2}},{"line":210,"address":[15111947],"length":1,"stats":{"Line":0}},{"line":213,"address":[24701537,24701761,24701482],"length":1,"stats":{"Line":6}},{"line":214,"address":[15224887],"length":1,"stats":{"Line":1}},{"line":217,"address":[15228802,15228861,15229090],"length":1,"stats":{"Line":4}},{"line":218,"address":[15225128],"length":1,"stats":{"Line":1}},{"line":221,"address":[15119174],"length":1,"stats":{"Line":1}},{"line":224,"address":[15126272],"length":1,"stats":{"Line":1}},{"line":229,"address":[22887521],"length":1,"stats":{"Line":2}},{"line":230,"address":[15112554,15112628],"length":1,"stats":{"Line":2}},{"line":231,"address":[15187200],"length":1,"stats":{"Line":1}},{"line":233,"address":[15187174,15187253],"length":1,"stats":{"Line":4}},{"line":234,"address":[24702191],"length":1,"stats":{"Line":1}},{"line":236,"address":[15225334],"length":1,"stats":{"Line":3}},{"line":239,"address":[15225376],"length":1,"stats":{"Line":3}},{"line":240,"address":[15194206],"length":1,"stats":{"Line":3}},{"line":241,"address":[15229364],"length":1,"stats":{"Line":3}},{"line":242,"address":[15112702],"length":1,"stats":{"Line":3}},{"line":245,"address":[15231090],"length":1,"stats":{"Line":3}},{"line":246,"address":[15119604],"length":1,"stats":{"Line":3}},{"line":254,"address":[15194384],"length":1,"stats":{"Line":1}},{"line":255,"address":[15112903],"length":1,"stats":{"Line":1}},{"line":256,"address":[15126687],"length":1,"stats":{"Line":1}},{"line":257,"address":[15113443],"length":1,"stats":{"Line":0}},{"line":259,"address":[22888398],"length":1,"stats":{"Line":0}},{"line":265,"address":[15120416],"length":1,"stats":{"Line":1}},{"line":266,"address":[24703201],"length":1,"stats":{"Line":1}},{"line":267,"address":[15230327],"length":1,"stats":{"Line":1}},{"line":268,"address":[15230377],"length":1,"stats":{"Line":1}},{"line":269,"address":[22889798,22888928,22889647,22889959],"length":1,"stats":{"Line":2}},{"line":271,"address":[15114791,15115246,15115232],"length":1,"stats":{"Line":0}},{"line":273,"address":[15189920,15189943,15189544],"length":1,"stats":{"Line":0}},{"line":274,"address":[15233297,15233160,15233493],"length":1,"stats":{"Line":2}},{"line":276,"address":[15232094,15232080,15231814],"length":1,"stats":{"Line":0}},{"line":277,"address":[15196586],"length":1,"stats":{"Line":1}},{"line":279,"address":[15115041],"length":1,"stats":{"Line":1}},{"line":282,"address":[15195433],"length":1,"stats":{"Line":0}},{"line":283,"address":[15227124,15226740,15226966],"length":1,"stats":{"Line":0}},{"line":285,"address":[15327303,15328608,15328622],"length":1,"stats":{"Line":0}},{"line":287,"address":[15188981,15190224,15190245],"length":1,"stats":{"Line":0}},{"line":288,"address":[15230949,15231086,15231277],"length":1,"stats":{"Line":0}},{"line":290,"address":[15129488,15129502,15128366],"length":1,"stats":{"Line":0}},{"line":291,"address":[15227206],"length":1,"stats":{"Line":0}},{"line":293,"address":[15121262],"length":1,"stats":{"Line":0}},{"line":296,"address":[15127540],"length":1,"stats":{"Line":0}}],"covered":95,"coverable":131},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","user_service.rs"],"content":"use crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\r\nuse crate::domain::entities::{User, UserMetadata};\r\nuse crate::shared::{AppError, ValidationFailureKind};\r\nuse chrono::Utc;\r\nuse std::sync::Arc;\r\n\r\npub struct UserService {\r\n    repository: Arc<dyn UserRepository>,\r\n}\r\n\r\nimpl UserService {\r\n    pub fn new(repository: Arc<dyn UserRepository>) -> Self {\r\n        Self { repository }\r\n    }\r\n\r\n    pub async fn create_user(&self, npub: String, pubkey: String) -> Result<User, AppError> {\r\n        let user = User::new(npub, pubkey);\r\n        self.repository.create_user(&user).await?;\r\n        Ok(user)\r\n    }\r\n\r\n    pub async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\r\n        self.repository.get_user(npub).await\r\n    }\r\n\r\n    pub async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\r\n        self.repository.get_user_by_pubkey(pubkey).await\r\n    }\r\n\r\n    pub async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\r\n        if query.trim().is_empty() {\r\n            return Ok(vec![]);\r\n        }\r\n        self.repository.search_users(query, limit).await\r\n    }\r\n\r\n    pub async fn update_profile(&self, npub: &str, metadata: UserMetadata) -> Result<(), AppError> {\r\n        if let Some(mut user) = self.repository.get_user(npub).await? {\r\n            user.update_metadata(metadata);\r\n            self.repository.update_user(&user).await?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn update_privacy_settings(\r\n        &self,\r\n        npub: &str,\r\n        public_profile: bool,\r\n        show_online_status: bool,\r\n    ) -> Result<(), AppError> {\r\n        let mut user = self\r\n            .repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))?;\r\n\r\n        user.public_profile = public_profile;\r\n        user.show_online_status = show_online_status;\r\n        user.updated_at = Utc::now();\r\n\r\n        self.repository.update_user(&user).await\r\n    }\r\n\r\n    pub async fn update_user(&self, user: User) -> Result<(), AppError> {\r\n        self.repository.update_user(&user).await\r\n    }\r\n\r\n    pub async fn follow_user(\r\n        &self,\r\n        follower_npub: &str,\r\n        target_npub: &str,\r\n    ) -> Result<(), AppError> {\r\n        if follower_npub == target_npub {\r\n            return Err(AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                \"Cannot follow yourself\",\r\n            ));\r\n        }\r\n\r\n        let follower = self.resolve_user_by_npub(follower_npub).await?;\r\n        let target = self.resolve_user_by_npub(target_npub).await?;\r\n\r\n        self.repository\r\n            .add_follow_relation(follower.pubkey(), target.pubkey())\r\n            .await?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn unfollow_user(\r\n        &self,\r\n        follower_npub: &str,\r\n        target_npub: &str,\r\n    ) -> Result<(), AppError> {\r\n        let follower = self.resolve_user_by_npub(follower_npub).await?;\r\n        let target = self.resolve_user_by_npub(target_npub).await?;\r\n\r\n        let removed = self\r\n            .repository\r\n            .remove_follow_relation(follower.pubkey(), target.pubkey())\r\n            .await?;\r\n\r\n        if removed {\r\n            Ok(())\r\n        } else {\r\n            Err(AppError::NotFound(format!(\r\n                \"{follower_npub} is not following {target_npub}\"\r\n            )))\r\n        }\r\n    }\r\n\r\n    pub async fn get_followers_paginated(\r\n        &self,\r\n        npub: &str,\r\n        cursor: Option<&str>,\r\n        limit: usize,\r\n        sort: FollowListSort,\r\n        search: Option<&str>,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<UserCursorPage, AppError> {\r\n        self.ensure_profile_visibility(npub, viewer_npub).await?;\r\n        self.repository\r\n            .get_followers_paginated(npub, cursor, limit, sort, search)\r\n            .await\r\n    }\r\n\r\n    pub async fn get_following_paginated(\r\n        &self,\r\n        npub: &str,\r\n        cursor: Option<&str>,\r\n        limit: usize,\r\n        sort: FollowListSort,\r\n        search: Option<&str>,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<UserCursorPage, AppError> {\r\n        self.ensure_profile_visibility(npub, viewer_npub).await?;\r\n        self.repository\r\n            .get_following_paginated(npub, cursor, limit, sort, search)\r\n            .await\r\n    }\r\n\r\n    pub async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError> {\r\n        let mut all_users = Vec::new();\r\n        let mut cursor: Option<String> = None;\r\n\r\n        loop {\r\n            let UserCursorPage {\r\n                users,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: _,\r\n            } = self\r\n                .get_followers_paginated(\r\n                    npub,\r\n                    cursor.as_deref(),\r\n                    100,\r\n                    FollowListSort::Recent,\r\n                    None,\r\n                    Some(npub),\r\n                )\r\n                .await?;\r\n\r\n            all_users.extend(users.into_iter());\r\n\r\n            if !has_more || next_cursor.is_none() {\r\n                break;\r\n            }\r\n\r\n            cursor = next_cursor;\r\n        }\r\n\r\n        Ok(all_users)\r\n    }\r\n\r\n    pub async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError> {\r\n        let mut all_users = Vec::new();\r\n        let mut cursor: Option<String> = None;\r\n\r\n        loop {\r\n            let UserCursorPage {\r\n                users,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: _,\r\n            } = self\r\n                .get_following_paginated(\r\n                    npub,\r\n                    cursor.as_deref(),\r\n                    100,\r\n                    FollowListSort::Recent,\r\n                    None,\r\n                    Some(npub),\r\n                )\r\n                .await?;\r\n\r\n            all_users.extend(users.into_iter());\r\n\r\n            if !has_more || next_cursor.is_none() {\r\n                break;\r\n            }\r\n\r\n            cursor = next_cursor;\r\n        }\r\n\r\n        Ok(all_users)\r\n    }\r\n\r\n    pub async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\r\n        self.repository.delete_user(npub).await\r\n    }\r\n\r\n    async fn resolve_user_by_npub(&self, npub: &str) -> Result<User, AppError> {\r\n        self.repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))\r\n    }\r\n\r\n    async fn ensure_profile_visibility(\r\n        &self,\r\n        npub: &str,\r\n        viewer_npub: Option<&str>,\r\n    ) -> Result<(), AppError> {\r\n        let user = self\r\n            .repository\r\n            .get_user(npub)\r\n            .await?\r\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))?;\r\n\r\n        if !user.public_profile {\r\n            let viewer_matches = viewer_npub\r\n                .map(|viewer| viewer == user.npub)\r\n                .unwrap_or(false);\r\n            if !viewer_matches {\r\n                return Err(AppError::Unauthorized(format!(\"Profile {npub} is private\")));\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::repositories::UserRepository;\r\n    use async_trait::async_trait;\r\n    use std::collections::{HashMap, HashSet};\r\n    use std::sync::Arc;\r\n    use tokio::sync::RwLock;\r\n\r\n    const ALICE_NPUB: &str = \"npub1alice\";\r\n    const ALICE_PUB: &str = \"alice_pub\";\r\n    const BOB_NPUB: &str = \"npub1bob\";\r\n    const BOB_PUB: &str = \"bob_pub\";\r\n\r\n    fn parse_offset_cursor(cursor: &str) -> Result<usize, AppError> {\r\n        cursor\r\n            .strip_prefix(\"offset:\")\r\n            .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?\r\n            .parse::<usize>()\r\n            .map_err(|_| AppError::InvalidInput(\"Invalid cursor offset\".into()))\r\n    }\r\n\r\n    fn name_key(user: &User) -> String {\r\n        let display_name = user.profile.display_name.trim();\r\n        if display_name.is_empty() {\r\n            user.npub.to_lowercase()\r\n        } else {\r\n            display_name.to_lowercase()\r\n        }\r\n    }\r\n    #[derive(Default)]\r\n    struct InMemoryUserRepository {\r\n        users: RwLock<HashMap<String, User>>,\r\n        follows: RwLock<HashSet<(String, String)>>,\r\n    }\r\n\r\n    enum FollowRelationKind {\r\n        Followers,\r\n        Following,\r\n    }\r\n\r\n    impl InMemoryUserRepository {\r\n        async fn paginate_relation(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n            kind: FollowRelationKind,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            let users = self.users.read().await;\r\n            let target_pubkey = match users.get(npub) {\r\n                Some(user) => user.pubkey.clone(),\r\n                None => {\r\n                    return Ok(UserCursorPage {\r\n                        users: vec![],\r\n                        next_cursor: None,\r\n                        has_more: false,\r\n                        total_count: 0,\r\n                    });\r\n                }\r\n            };\r\n            let follows = self.follows.read().await;\r\n            let mut entries: Vec<User> = follows\r\n                .iter()\r\n                .filter_map(|(follower, followed)| match kind {\r\n                    FollowRelationKind::Followers if followed == &target_pubkey => {\r\n                        Some(follower.clone())\r\n                    }\r\n                    FollowRelationKind::Following if follower == &target_pubkey => {\r\n                        Some(followed.clone())\r\n                    }\r\n                    _ => None,\r\n                })\r\n                .filter_map(|pubkey| users.values().find(|u| u.pubkey == pubkey).cloned())\r\n                .collect();\r\n\r\n            let search_lower = search.map(|s| s.to_lowercase());\r\n            if let Some(search_value) = search_lower.as_ref() {\r\n                entries.retain(|user| {\r\n                    let display = user.profile.display_name.to_lowercase();\r\n                    let npub_value = user.npub.to_lowercase();\r\n                    let pubkey = user.pubkey.to_lowercase();\r\n                    display.contains(search_value)\r\n                        || npub_value.contains(search_value)\r\n                        || pubkey.contains(search_value)\r\n                });\r\n            }\r\n\r\n            match sort {\r\n                FollowListSort::Recent => {\r\n                    entries.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));\r\n                }\r\n                FollowListSort::Oldest => {\r\n                    entries.sort_by(|a, b| a.updated_at.cmp(&b.updated_at));\r\n                }\r\n                FollowListSort::NameAsc => {\r\n                    entries.sort_by(|a, b| name_key(a).cmp(&name_key(b)));\r\n                }\r\n                FollowListSort::NameDesc => {\r\n                    entries.sort_by(|a, b| name_key(b).cmp(&name_key(a)));\r\n                }\r\n            }\r\n\r\n            let total_entries = entries.len();\r\n            let mut offset = 0usize;\r\n            if let Some(cursor) = cursor {\r\n                offset = parse_offset_cursor(cursor)?;\r\n            }\r\n            offset = offset.min(total_entries);\r\n\r\n            let end = offset.saturating_add(limit);\r\n            let has_more = end < total_entries;\r\n            let next_cursor = if has_more {\r\n                Some(format!(\"offset:{}\", end))\r\n            } else {\r\n                None\r\n            };\r\n\r\n            let items: Vec<User> = entries.into_iter().skip(offset).take(limit).collect();\r\n\r\n            Ok(UserCursorPage {\r\n                users: items,\r\n                next_cursor,\r\n                has_more,\r\n                total_count: total_entries as u64,\r\n            })\r\n        }\r\n    }\r\n\r\n    #[async_trait]\r\n    impl UserRepository for InMemoryUserRepository {\r\n        async fn create_user(&self, user: &User) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            users.insert(user.npub.clone(), user.clone());\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\r\n            let users = self.users.read().await;\r\n            Ok(users.get(npub).cloned())\r\n        }\r\n\r\n        async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\r\n            let users = self.users.read().await;\r\n            Ok(users.values().find(|u| u.pubkey == pubkey).cloned())\r\n        }\r\n\r\n        async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\r\n            if query.trim().is_empty() {\r\n                return Ok(vec![]);\r\n            }\r\n\r\n            let query_lower = query.to_lowercase();\r\n            let users = self.users.read().await;\r\n            let mut results: Vec<User> = users\r\n                .values()\r\n                .filter(|user| {\r\n                    let display_name = user.profile.display_name.to_lowercase();\r\n                    let bio = user.profile.bio.to_lowercase();\r\n                    display_name.contains(&query_lower)\r\n                        || bio.contains(&query_lower)\r\n                        || user.npub.to_lowercase().contains(&query_lower)\r\n                        || user.pubkey.to_lowercase().contains(&query_lower)\r\n                })\r\n                .cloned()\r\n                .collect();\r\n\r\n            results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));\r\n            if results.len() > limit {\r\n                results.truncate(limit);\r\n            }\r\n\r\n            Ok(results)\r\n        }\r\n\r\n        async fn update_user(&self, user: &User) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            users.insert(user.npub.clone(), user.clone());\r\n            Ok(())\r\n        }\r\n\r\n        async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\r\n            let mut users = self.users.write().await;\r\n            if let Some(user) = users.remove(npub) {\r\n                let mut follows = self.follows.write().await;\r\n                follows.retain(|(follower, followed)| {\r\n                    follower != &user.pubkey && followed != &user.pubkey\r\n                });\r\n            }\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_followers_paginated(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            self.paginate_relation(\r\n                npub,\r\n                cursor,\r\n                limit,\r\n                sort,\r\n                search,\r\n                FollowRelationKind::Followers,\r\n            )\r\n            .await\r\n        }\r\n\r\n        async fn get_following_paginated(\r\n            &self,\r\n            npub: &str,\r\n            cursor: Option<&str>,\r\n            limit: usize,\r\n            sort: FollowListSort,\r\n            search: Option<&str>,\r\n        ) -> Result<UserCursorPage, AppError> {\r\n            self.paginate_relation(\r\n                npub,\r\n                cursor,\r\n                limit,\r\n                sort,\r\n                search,\r\n                FollowRelationKind::Following,\r\n            )\r\n            .await\r\n        }\r\n\r\n        async fn add_follow_relation(\r\n            &self,\r\n            follower_pubkey: &str,\r\n            followed_pubkey: &str,\r\n        ) -> Result<bool, AppError> {\r\n            let mut follows = self.follows.write().await;\r\n            Ok(follows.insert((follower_pubkey.to_string(), followed_pubkey.to_string())))\r\n        }\r\n\r\n        async fn remove_follow_relation(\r\n            &self,\r\n            follower_pubkey: &str,\r\n            followed_pubkey: &str,\r\n        ) -> Result<bool, AppError> {\r\n            let mut follows = self.follows.write().await;\r\n            Ok(follows.remove(&(follower_pubkey.to_string(), followed_pubkey.to_string())))\r\n        }\r\n\r\n        async fn list_following_pubkeys(\r\n            &self,\r\n            follower_pubkey: &str,\r\n        ) -> Result<Vec<String>, AppError> {\r\n            let follows = self.follows.read().await;\r\n            Ok(follows\r\n                .iter()\r\n                .filter(|(follower, _)| follower == follower_pubkey)\r\n                .map(|(_, followed)| followed.clone())\r\n                .collect())\r\n        }\r\n\r\n        async fn list_follower_pubkeys(\r\n            &self,\r\n            followed_pubkey: &str,\r\n        ) -> Result<Vec<String>, AppError> {\r\n            let follows = self.follows.read().await;\r\n            Ok(follows\r\n                .iter()\r\n                .filter(|(_, target)| target == followed_pubkey)\r\n                .map(|(follower, _)| follower.clone())\r\n                .collect())\r\n        }\r\n    }\r\n\r\n    async fn setup_service() -> UserService {\r\n        let repository: Arc<dyn UserRepository> = Arc::new(InMemoryUserRepository::default());\r\n        UserService::new(repository)\r\n    }\r\n\r\n    async fn seed_user(service: &UserService, npub: &str, pubkey: &str) {\r\n        service\r\n            .create_user(npub.to_string(), pubkey.to_string())\r\n            .await\r\n            .expect(\"create user\");\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_and_unfollow_flow() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .follow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect(\"follow\");\r\n\r\n        let following = service\r\n            .get_following(ALICE_NPUB)\r\n            .await\r\n            .expect(\"following list\");\r\n        assert_eq!(following.len(), 1);\r\n        assert_eq!(following[0].npub, BOB_NPUB);\r\n\r\n        let followers = service\r\n            .get_followers(BOB_NPUB)\r\n            .await\r\n            .expect(\"followers list\");\r\n        assert_eq!(followers.len(), 1);\r\n        assert_eq!(followers[0].npub, ALICE_NPUB);\r\n\r\n        service\r\n            .unfollow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect(\"unfollow\");\r\n\r\n        assert!(\r\n            service\r\n                .get_following(ALICE_NPUB)\r\n                .await\r\n                .expect(\"following after unfollow\")\r\n                .is_empty()\r\n        );\r\n        assert!(\r\n            service\r\n                .get_followers(BOB_NPUB)\r\n                .await\r\n                .expect(\"followers after unfollow\")\r\n                .is_empty()\r\n        );\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_user_validates_identity() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        let err = service\r\n            .follow_user(ALICE_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect_err(\"self follow should fail\");\r\n        assert!(matches!(err, AppError::ValidationError { .. }));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn follow_user_requires_existing_target() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        let err = service\r\n            .follow_user(ALICE_NPUB, BOB_NPUB)\r\n            .await\r\n            .expect_err(\"missing target\");\r\n        assert!(matches!(err, AppError::NotFound(_)));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn followers_paginated_respects_cursor_boundaries() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n        seed_user(&service, \"npub1carol\", \"carol_pub\").await;\r\n        seed_user(&service, \"npub1dave\", \"dave_pub\").await;\r\n\r\n        service\r\n            .follow_user(BOB_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect(\"bob follows\");\r\n        service\r\n            .follow_user(\"npub1carol\", ALICE_NPUB)\r\n            .await\r\n            .expect(\"carol follows\");\r\n        service\r\n            .follow_user(\"npub1dave\", ALICE_NPUB)\r\n            .await\r\n            .expect(\"dave follows\");\r\n\r\n        let page1 = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                2,\r\n                FollowListSort::NameAsc,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"page1\");\r\n        assert_eq!(page1.users.len(), 2);\r\n        assert_eq!(page1.total_count, 3);\r\n        assert!(page1.has_more);\r\n        let cursor = page1.next_cursor.as_deref().expect(\"cursor present\");\r\n\r\n        let page2 = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                Some(cursor),\r\n                2,\r\n                FollowListSort::NameAsc,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"page2\");\r\n        assert_eq!(page2.users.len(), 1);\r\n        assert_eq!(page2.total_count, 3);\r\n        assert!(!page2.has_more);\r\n        assert!(page2.next_cursor.is_none());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn followers_paginated_private_profile_requires_matching_viewer() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .follow_user(BOB_NPUB, ALICE_NPUB)\r\n            .await\r\n            .expect(\"bob follows\");\r\n\r\n        service\r\n            .update_privacy_settings(ALICE_NPUB, false, true)\r\n            .await\r\n            .expect(\"set private\");\r\n\r\n        let err = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                10,\r\n                FollowListSort::Recent,\r\n                None,\r\n                Some(BOB_NPUB),\r\n            )\r\n            .await\r\n            .expect_err(\"private profile should reject viewer\");\r\n        assert!(matches!(err, AppError::Unauthorized(_)));\r\n\r\n        let owner_view = service\r\n            .get_followers_paginated(\r\n                ALICE_NPUB,\r\n                None,\r\n                10,\r\n                FollowListSort::Recent,\r\n                None,\r\n                Some(ALICE_NPUB),\r\n            )\r\n            .await\r\n            .expect(\"owner can view\");\r\n        assert_eq!(owner_view.total_count, 1);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn search_users_returns_matching_records() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n        seed_user(&service, BOB_NPUB, BOB_PUB).await;\r\n\r\n        service\r\n            .update_profile(\r\n                ALICE_NPUB,\r\n                UserMetadata {\r\n                    name: Some(\"alice\".to_string()),\r\n                    display_name: Some(\"Alice Wonderland\".to_string()),\r\n                    about: Some(\"nostr developer\".to_string()),\r\n                    picture: None,\r\n                    banner: None,\r\n                    nip05: None,\r\n                    lud16: None,\r\n                    public_profile: None,\r\n                    show_online_status: None,\r\n                },\r\n            )\r\n            .await\r\n            .expect(\"update alice profile\");\r\n\r\n        service\r\n            .update_profile(\r\n                BOB_NPUB,\r\n                UserMetadata {\r\n                    name: Some(\"bob\".to_string()),\r\n                    display_name: Some(\"Bob Smith\".to_string()),\r\n                    about: Some(\"bitcoin enthusiast\".to_string()),\r\n                    picture: None,\r\n                    banner: None,\r\n                    nip05: None,\r\n                    lud16: None,\r\n                    public_profile: None,\r\n                    show_online_status: None,\r\n                },\r\n            )\r\n            .await\r\n            .expect(\"update bob profile\");\r\n\r\n        let results = service\r\n            .search_users(\"alice\", 10)\r\n            .await\r\n            .expect(\"search users\");\r\n        assert_eq!(results.len(), 1);\r\n        assert_eq!(results[0].npub, ALICE_NPUB);\r\n\r\n        let bio_match = service\r\n            .search_users(\"bitcoin\", 10)\r\n            .await\r\n            .expect(\"search by bio\");\r\n        assert_eq!(bio_match.len(), 1);\r\n        assert_eq!(bio_match[0].npub, BOB_NPUB);\r\n\r\n        let none = service\r\n            .search_users(\"charlie\", 10)\r\n            .await\r\n            .expect(\"empty search\");\r\n        assert!(none.is_empty());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn update_privacy_settings_persists_flags() {\r\n        let service = setup_service().await;\r\n        seed_user(&service, ALICE_NPUB, ALICE_PUB).await;\r\n\r\n        service\r\n            .update_privacy_settings(ALICE_NPUB, false, true)\r\n            .await\r\n            .expect(\"update privacy settings\");\r\n\r\n        let updated = service\r\n            .get_user(ALICE_NPUB)\r\n            .await\r\n            .expect(\"fetch user\")\r\n            .expect(\"user exists\");\r\n\r\n        assert!(!updated.public_profile);\r\n        assert!(updated.show_online_status);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn update_privacy_settings_missing_user_returns_error() {\r\n        let service = setup_service().await;\r\n\r\n        let err = service\r\n            .update_privacy_settings(\"npub1missing\", true, false)\r\n            .await\r\n            .expect_err(\"missing user should error\");\r\n\r\n        assert!(matches!(err, AppError::NotFound(_)));\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[16390832],"length":1,"stats":{"Line":1}},{"line":16,"address":[16391141,16391929,16391421,16390864,16390944,16391181,16390872,16390979],"length":1,"stats":{"Line":4}},{"line":17,"address":[22143588],"length":1,"stats":{"Line":1}},{"line":18,"address":[11471556],"length":1,"stats":{"Line":2}},{"line":19,"address":[15181368],"length":1,"stats":{"Line":1}},{"line":22,"address":[22151426,22151617,22151456,22152086,22151408,22151817,22151657,22151491],"length":1,"stats":{"Line":4}},{"line":23,"address":[19219620],"length":1,"stats":{"Line":2}},{"line":26,"address":[22251718,22251088,22251040,22251249,22251123,22251058,22251449,22251289],"length":1,"stats":{"Line":0}},{"line":27,"address":[22138524,22138777,22138572,22138649],"length":1,"stats":{"Line":0}},{"line":30,"address":[22139323,22139116,22139283,22139988,22139024,22139690,22139047,22139072],"length":1,"stats":{"Line":4}},{"line":31,"address":[15183170,15183284],"length":1,"stats":{"Line":2}},{"line":32,"address":[22139580,22139427],"length":1,"stats":{"Line":0}},{"line":34,"address":[22139406,22139722,22139310,22139474],"length":1,"stats":{"Line":2}},{"line":37,"address":[22353231,22353117,22353072,22353473,22353726,22354702,22355158,22353184],"length":1,"stats":{"Line":4}},{"line":38,"address":[22215023,22214951,22215134,22216194,22215278],"length":1,"stats":{"Line":2}},{"line":39,"address":[22354302],"length":1,"stats":{"Line":1}},{"line":40,"address":[15185739,15184320,15185224,15185455],"length":1,"stats":{"Line":1}},{"line":42,"address":[22354640],"length":1,"stats":{"Line":1}},{"line":45,"address":[22156064],"length":1,"stats":{"Line":1}},{"line":51,"address":[22218462,22217371,22218518,22217190,22218183,22217719,22217436,22217655,22217829,22217896],"length":1,"stats":{"Line":8}},{"line":53,"address":[22259404],"length":1,"stats":{"Line":1}},{"line":54,"address":[11630687],"length":1,"stats":{"Line":3}},{"line":55,"address":[11630721],"length":1,"stats":{"Line":4}},{"line":57,"address":[22218073],"length":1,"stats":{"Line":1}},{"line":58,"address":[22218093],"length":1,"stats":{"Line":1}},{"line":59,"address":[22143521,22143676],"length":1,"stats":{"Line":2}},{"line":61,"address":[11665826],"length":1,"stats":{"Line":1}},{"line":64,"address":[22226184,22226399,22226745,22226650,22225936,22225971,22226051,22226016],"length":1,"stats":{"Line":0}},{"line":65,"address":[22219354,22219235,22219283,22219503],"length":1,"stats":{"Line":0}},{"line":68,"address":[22226768],"length":1,"stats":{"Line":1}},{"line":73,"address":[16399791,16399973],"length":1,"stats":{"Line":2}},{"line":74,"address":[16400026,16400162],"length":1,"stats":{"Line":2}},{"line":75,"address":[16400018],"length":1,"stats":{"Line":1}},{"line":80,"address":[11574706],"length":1,"stats":{"Line":2}},{"line":81,"address":[11576376],"length":1,"stats":{"Line":8}},{"line":83,"address":[22221589,22222426,22221971,22222160,22221912,22222276],"length":1,"stats":{"Line":13}},{"line":84,"address":[22360273],"length":1,"stats":{"Line":3}},{"line":85,"address":[22220191,22222208,22221940,22222378,22221993,22222052],"length":1,"stats":{"Line":9}},{"line":87,"address":[22360824],"length":1,"stats":{"Line":3}},{"line":90,"address":[22361008],"length":1,"stats":{"Line":1}},{"line":95,"address":[22222767,22223489,22223716,22222839,22223070,22222944],"length":1,"stats":{"Line":2}},{"line":96,"address":[11716216],"length":1,"stats":{"Line":2}},{"line":98,"address":[15193761,15193357,15193302,15193656,15192999,15193528],"length":1,"stats":{"Line":5}},{"line":100,"address":[15193191],"length":1,"stats":{"Line":1}},{"line":101,"address":[11577758],"length":1,"stats":{"Line":3}},{"line":103,"address":[22150436,22150306],"length":1,"stats":{"Line":2}},{"line":104,"address":[22263132],"length":1,"stats":{"Line":1}},{"line":106,"address":[22150441,22150397],"length":1,"stats":{"Line":0}},{"line":112,"address":[22363824],"length":1,"stats":{"Line":1}},{"line":121,"address":[11562580],"length":1,"stats":{"Line":4}},{"line":122,"address":[22226589,22226829,22226337,22226509],"length":1,"stats":{"Line":4}},{"line":123,"address":[22270161],"length":1,"stats":{"Line":1}},{"line":124,"address":[11667131],"length":1,"stats":{"Line":3}},{"line":127,"address":[22159232],"length":1,"stats":{"Line":1}},{"line":136,"address":[22166714,22167506,22166918,22166795,22166648,22167234],"length":1,"stats":{"Line":2}},{"line":137,"address":[22160225,22160397,22160717,22160477],"length":1,"stats":{"Line":4}},{"line":138,"address":[22235089],"length":1,"stats":{"Line":1}},{"line":139,"address":[22159756,22160595,22160499,22160845,22160446],"length":1,"stats":{"Line":3}},{"line":142,"address":[16408496,16408701,16408466,16408448,16408543,16408756,16408905,16410541],"length":1,"stats":{"Line":4}},{"line":143,"address":[22228966],"length":1,"stats":{"Line":1}},{"line":144,"address":[22267206],"length":1,"stats":{"Line":1}},{"line":146,"address":[22162470],"length":1,"stats":{"Line":0}},{"line":147,"address":[22274170,22273606,22272827,22273244,22273064,22274055],"length":1,"stats":{"Line":5}},{"line":148,"address":[15198326],"length":1,"stats":{"Line":1}},{"line":149,"address":[22236646],"length":1,"stats":{"Line":1}},{"line":150,"address":[22168926],"length":1,"stats":{"Line":1}},{"line":154,"address":[22267260],"length":1,"stats":{"Line":1}},{"line":155,"address":[22168333],"length":1,"stats":{"Line":1}},{"line":157,"address":[22155716],"length":1,"stats":{"Line":1}},{"line":158,"address":[22155724],"length":1,"stats":{"Line":1}},{"line":159,"address":[22162520],"length":1,"stats":{"Line":1}},{"line":161,"address":[22229016,22229225,22230504,22229862,22229432,22230447],"length":1,"stats":{"Line":4}},{"line":163,"address":[15198633,15198426],"length":1,"stats":{"Line":2}},{"line":165,"address":[22169219,22169191],"length":1,"stats":{"Line":1}},{"line":169,"address":[22237012],"length":1,"stats":{"Line":0}},{"line":172,"address":[22162766],"length":1,"stats":{"Line":1}},{"line":175,"address":[22269183,22269106,22269088,22269396,22269136,22271181,22269545,22269341],"length":1,"stats":{"Line":4}},{"line":176,"address":[22238134],"length":1,"stats":{"Line":1}},{"line":177,"address":[22231334],"length":1,"stats":{"Line":1}},{"line":179,"address":[22270630],"length":1,"stats":{"Line":0}},{"line":180,"address":[22231788,22232150,22231371,22231608,22232599,22232714],"length":1,"stats":{"Line":5}},{"line":181,"address":[22275614],"length":1,"stats":{"Line":1}},{"line":182,"address":[22270070],"length":1,"stats":{"Line":1}},{"line":183,"address":[15200582],"length":1,"stats":{"Line":1}},{"line":187,"address":[15199992],"length":1,"stats":{"Line":1}},{"line":188,"address":[22156813],"length":1,"stats":{"Line":1}},{"line":190,"address":[22232548],"length":1,"stats":{"Line":1}},{"line":191,"address":[22157964],"length":1,"stats":{"Line":1}},{"line":192,"address":[22232568],"length":1,"stats":{"Line":1}},{"line":194,"address":[22163864,22164936,22164294,22163657,22164879,22163448],"length":1,"stats":{"Line":4}},{"line":196,"address":[22274066,22274281],"length":1,"stats":{"Line":2}},{"line":198,"address":[22370771,22370743],"length":1,"stats":{"Line":1}},{"line":202,"address":[22164516],"length":1,"stats":{"Line":0}},{"line":205,"address":[16412526],"length":1,"stats":{"Line":1}},{"line":208,"address":[22275282,22275312,22275513,22275347,22275473,22275264,22275674,22275942],"length":1,"stats":{"Line":0}},{"line":209,"address":[22271770,22271641,22271516,22271564],"length":1,"stats":{"Line":0}},{"line":212,"address":[22372615,22372402,22372384,22373262,22372432,22372779,22372467,22372575],"length":1,"stats":{"Line":4}},{"line":213,"address":[22373115,22373179,22373260,22372554,22372741,22373013,22372682,22372951],"length":1,"stats":{"Line":8}},{"line":214,"address":[22277885],"length":1,"stats":{"Line":1}},{"line":215,"address":[22276170,22276702,22276379,22276521,22276322,22276278],"length":1,"stats":{"Line":3}},{"line":216,"address":[22166818,22166992,22167013],"length":1,"stats":{"Line":5}},{"line":219,"address":[22174144],"length":1,"stats":{"Line":1}},{"line":224,"address":[22242560,22242738,22242298,22242946,22242239,22243414,22242111,22242508,22242671],"length":1,"stats":{"Line":6}},{"line":226,"address":[22174466],"length":1,"stats":{"Line":1}},{"line":227,"address":[22279278,22279458,22278927,22279079,22279136,22279035],"length":1,"stats":{"Line":3}},{"line":228,"address":[11673955,11673991],"length":1,"stats":{"Line":1}},{"line":230,"address":[16415670],"length":1,"stats":{"Line":1}},{"line":231,"address":[16415767,16415872],"length":1,"stats":{"Line":2}},{"line":232,"address":[22274802,22274784],"length":1,"stats":{"Line":2}},{"line":234,"address":[22243124],"length":1,"stats":{"Line":1}},{"line":235,"address":[22279896],"length":1,"stats":{"Line":1}},{"line":239,"address":[22279784],"length":1,"stats":{"Line":1}}],"covered":100,"coverable":112},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","default_topics.rs"],"content":"use std::collections::HashSet;\nuse tokio::sync::RwLock;\n\n/// 既定トピック集合を管理し、非同期アクセスを直列化するレジストリ。\npub struct DefaultTopicsRegistry {\n    topics: RwLock<HashSet<String>>,\n}\n\nimpl DefaultTopicsRegistry {\n    pub fn with_topics<I>(topics: I) -> Self\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut set = HashSet::new();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                set.insert(topic);\n            }\n        }\n        Self {\n            topics: RwLock::new(set),\n        }\n    }\n\n    pub async fn replace_with_single(&self, topic: String) {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        if !topic.trim().is_empty() {\n            guard.insert(topic);\n        }\n    }\n\n    pub async fn replace_all<I>(&self, topics: I)\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                guard.insert(topic);\n            }\n        }\n    }\n\n    pub async fn add(&self, topic: String) {\n        let normalized = topic.trim();\n        if normalized.is_empty() {\n            return;\n        }\n        let mut guard = self.topics.write().await;\n        guard.insert(normalized.to_string());\n    }\n\n    pub async fn remove(&self, topic: &str) {\n        let mut guard = self.topics.write().await;\n        guard.remove(topic);\n    }\n\n    pub async fn list(&self) -> Vec<String> {\n        let guard = self.topics.read().await;\n        guard.iter().cloned().collect()\n    }\n\n    pub async fn snapshot(&self) -> HashSet<String> {\n        let guard = self.topics.read().await;\n        guard.clone()\n    }\n}\n","traces":[{"line":10,"address":[16471152,16472026,16472054],"length":1,"stats":{"Line":5}},{"line":14,"address":[16574054],"length":1,"stats":{"Line":5}},{"line":15,"address":[16574340,16574148,16574394,16574249],"length":1,"stats":{"Line":20}},{"line":16,"address":[25701118,25701313],"length":1,"stats":{"Line":8}},{"line":17,"address":[16671127,16671183],"length":1,"stats":{"Line":8}},{"line":18,"address":[16570821,16570897],"length":1,"stats":{"Line":8}},{"line":22,"address":[16570518],"length":1,"stats":{"Line":5}},{"line":26,"address":[16540819,16539929,16540217,16539856,16539864,16539904,16540062],"length":1,"stats":{"Line":0}},{"line":27,"address":[16576811,16577017,16576912,16576857],"length":1,"stats":{"Line":0}},{"line":28,"address":[16571648,16571715],"length":1,"stats":{"Line":0}},{"line":29,"address":[16540646,16540542,16540712],"length":1,"stats":{"Line":0}},{"line":30,"address":[24234108,24234082],"length":1,"stats":{"Line":0}},{"line":34,"address":[16466160,16466286],"length":1,"stats":{"Line":4}},{"line":38,"address":[24234648,24234753,24234547,24234593],"length":1,"stats":{"Line":4}},{"line":39,"address":[16473752,16473819],"length":1,"stats":{"Line":4}},{"line":40,"address":[16534865,16534919,16534662],"length":1,"stats":{"Line":6}},{"line":41,"address":[16573209,16573071],"length":1,"stats":{"Line":4}},{"line":42,"address":[16578855,16578911],"length":1,"stats":{"Line":4}},{"line":43,"address":[25703877,25703904],"length":1,"stats":{"Line":4}},{"line":48,"address":[16475207,16474672,16474818,16474697,16475129,16474624,16474632,16475614],"length":1,"stats":{"Line":4}},{"line":49,"address":[16542552,16542673],"length":1,"stats":{"Line":2}},{"line":50,"address":[16474966],"length":1,"stats":{"Line":1}},{"line":53,"address":[16475239,16474845,16475047,16475005],"length":1,"stats":{"Line":2}},{"line":54,"address":[25704975,25704926],"length":1,"stats":{"Line":2}},{"line":57,"address":[16475971,16475680,16475632,16475814,16475650,16476354,16475705,16475851],"length":1,"stats":{"Line":4}},{"line":58,"address":[25705363,25705293,25705259,25705450],"length":1,"stats":{"Line":2}},{"line":59,"address":[25705658,25705710],"length":1,"stats":{"Line":2}},{"line":62,"address":[16544179,16544144,16544418,16544301,16544128,16544136,16544902,16544264],"length":1,"stats":{"Line":4}},{"line":63,"address":[11507524],"length":1,"stats":{"Line":2}},{"line":64,"address":[16476991,16476926],"length":1,"stats":{"Line":2}},{"line":67,"address":[16477203,16477288,16477168,16477325,16477152,16477442,16477160,16477851],"length":1,"stats":{"Line":0}},{"line":68,"address":[16676581,16676681,16676786,16676627],"length":1,"stats":{"Line":0}},{"line":69,"address":[16576715,16576648],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","event_id_mapper.rs"],"content":"use crate::domain::value_objects::EventId;\nuse crate::shared::{AppError, ValidationFailureKind};\n\npub(crate) fn parse_event_id(hex: &str) -> Result<EventId, AppError> {\n    EventId::from_hex(hex).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid event ID: {err}\"),\n        )\n    })\n}\n\npub(crate) fn parse_optional_event_id(hex: Option<&str>) -> Result<Option<EventId>, AppError> {\n    match hex {\n        Some(value) => parse_event_id(value).map(Some),\n        None => Ok(None),\n    }\n}\n\npub(crate) fn parse_event_ids(hexes: &[String]) -> Result<Vec<EventId>, AppError> {\n    hexes.iter().map(|value| parse_event_id(value)).collect()\n}\n","traces":[{"line":4,"address":[20714000],"length":1,"stats":{"Line":0}},{"line":5,"address":[20816904,20816944,20817163],"length":1,"stats":{"Line":0}},{"line":6,"address":[20781999],"length":1,"stats":{"Line":0}},{"line":7,"address":[20913397],"length":1,"stats":{"Line":0}},{"line":8,"address":[20816970,20817029],"length":1,"stats":{"Line":0}},{"line":13,"address":[20817200],"length":1,"stats":{"Line":0}},{"line":14,"address":[20813288],"length":1,"stats":{"Line":0}},{"line":15,"address":[23056486],"length":1,"stats":{"Line":0}},{"line":16,"address":[20707399],"length":1,"stats":{"Line":0}},{"line":20,"address":[20775312],"length":1,"stats":{"Line":0}},{"line":21,"address":[20817410,20817456,20817491],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","metadata_mapper.rs"],"content":"use crate::domain::entities::event_gateway::{PrivacyPreferences, ProfileMetadata, RelayEndpoint};\nuse crate::presentation::dto::event::{Nip65RelayDto, NostrMetadataDto};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse nostr_sdk::JsonUtil;\nuse nostr_sdk::prelude::{Metadata, Url};\nuse serde_json::{Map, Value};\n\npub(crate) fn dto_to_profile_metadata(dto: NostrMetadataDto) -> Result<ProfileMetadata, AppError> {\n    let relays = dto.relays.map(convert_relays).transpose()?;\n    let privacy = dto.privacy.map(|prefs| PrivacyPreferences {\n        public_profile: prefs.public_profile.unwrap_or(true),\n        show_online_status: prefs.show_online_status.unwrap_or(false),\n    });\n\n    ProfileMetadata::new(\n        dto.name,\n        dto.display_name,\n        dto.about,\n        dto.picture,\n        dto.banner,\n        dto.nip05,\n        dto.lud16,\n        dto.website,\n        relays,\n        privacy,\n    )\n    .map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid profile metadata: {err}\"),\n        )\n    })\n}\n\npub(crate) fn profile_metadata_to_nostr(metadata: &ProfileMetadata) -> Result<Metadata, AppError> {\n    if let Some(website) = metadata.website.as_ref() {\n        Url::parse(website).map_err(|_| {\n            AppError::validation(ValidationFailureKind::Generic, \"Invalid website URL\")\n        })?;\n    }\n\n    let mut map = Map::new();\n    if let Some(name) = metadata.name.as_ref() {\n        map.insert(\"name\".to_string(), Value::String(name.clone()));\n    }\n    if let Some(display_name) = metadata.display_name.as_ref() {\n        map.insert(\n            \"display_name\".to_string(),\n            Value::String(display_name.clone()),\n        );\n    }\n    if let Some(about) = metadata.about.as_ref() {\n        map.insert(\"about\".to_string(), Value::String(about.clone()));\n    }\n    if let Some(picture) = metadata.picture.as_ref() {\n        map.insert(\"picture\".to_string(), Value::String(picture.clone()));\n    }\n    if let Some(banner) = metadata.banner.as_ref() {\n        map.insert(\"banner\".to_string(), Value::String(banner.clone()));\n    }\n    if let Some(nip05) = metadata.nip05.as_ref() {\n        map.insert(\"nip05\".to_string(), Value::String(nip05.clone()));\n    }\n    if let Some(lud16) = metadata.lud16.as_ref() {\n        map.insert(\"lud16\".to_string(), Value::String(lud16.clone()));\n    }\n    if let Some(website) = metadata.website.as_ref() {\n        map.insert(\"website\".to_string(), Value::String(website.clone()));\n    }\n    if let Some(relays) = metadata.relays.as_ref() {\n        let relay_values = relays\n            .iter()\n            .map(|relay| {\n                let mut item = Map::new();\n                item.insert(\"url\".to_string(), Value::String(relay.url.clone()));\n                item.insert(\"read\".to_string(), Value::Bool(relay.read));\n                item.insert(\"write\".to_string(), Value::Bool(relay.write));\n                Value::Object(item)\n            })\n            .collect();\n        map.insert(\"relays\".to_string(), Value::Array(relay_values));\n    }\n    if let Some(privacy) = metadata.privacy.as_ref() {\n        let mut prefs = Map::new();\n        prefs.insert(\n            \"public_profile\".to_string(),\n            Value::Bool(privacy.public_profile),\n        );\n        prefs.insert(\n            \"show_online_status\".to_string(),\n            Value::Bool(privacy.show_online_status),\n        );\n        map.insert(\"kukuri_privacy\".to_string(), Value::Object(prefs));\n    }\n\n    Metadata::from_json(Value::Object(map).to_string())\n        .map_err(|err| AppError::NostrError(err.to_string()))\n}\n\nfn convert_relays(relays: Vec<Nip65RelayDto>) -> Result<Vec<RelayEndpoint>, AppError> {\n    relays\n        .into_iter()\n        .map(|relay| {\n            RelayEndpoint::new(relay.url, relay.read, relay.write)\n                .map_err(|err| AppError::validation(ValidationFailureKind::Generic, err))\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n\n    #[test]\n    fn dto_relays_are_converted_into_domain() {\n        let dto = NostrMetadataDto {\n            name: None,\n            display_name: None,\n            about: None,\n            picture: None,\n            banner: None,\n            nip05: None,\n            lud16: None,\n            website: None,\n            relays: Some(vec![Nip65RelayDto {\n                url: \"wss://relay.example\".to_string(),\n                read: true,\n                write: false,\n            }]),\n            privacy: None,\n        };\n\n        let metadata = dto_to_profile_metadata(dto).expect(\"metadata conversion\");\n        let relay = metadata\n            .relays\n            .and_then(|mut list| list.pop())\n            .expect(\"relay entry\");\n        assert_eq!(relay.url, \"wss://relay.example\");\n        assert!(relay.read);\n        assert!(!relay.write);\n    }\n\n    #[test]\n    fn profile_metadata_includes_relays_in_json() {\n        let relay = RelayEndpoint::new(\"wss://relay.example\".to_string(), true, false).unwrap();\n        let metadata = ProfileMetadata::new(\n            Some(\"name\".into()),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(vec![relay]),\n            None,\n        )\n        .expect(\"valid metadata\");\n\n        let nostr = profile_metadata_to_nostr(&metadata).expect(\"nostr metadata\");\n        let json_value: serde_json::Value =\n            serde_json::from_str(&nostr.as_json()).expect(\"valid json\");\n        let relays = json_value\n            .get(\"relays\")\n            .and_then(|value| value.as_array())\n            .expect(\"relays array\");\n        assert_eq!(relays.len(), 1);\n        let entry = relays[0].as_object().expect(\"relay object\");\n        assert_eq!(entry.get(\"url\").unwrap(), &json!(\"wss://relay.example\"));\n        assert_eq!(entry.get(\"read\").unwrap(), &json!(true));\n        assert_eq!(entry.get(\"write\").unwrap(), &json!(false));\n    }\n\n    #[test]\n    fn profile_metadata_includes_privacy_settings_in_json() {\n        let metadata = ProfileMetadata::new(\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(PrivacyPreferences {\n                public_profile: false,\n                show_online_status: true,\n            }),\n        )\n        .expect(\"valid metadata\");\n\n        let nostr = profile_metadata_to_nostr(&metadata).expect(\"nostr metadata\");\n        let json_value: serde_json::Value =\n            serde_json::from_str(&nostr.as_json()).expect(\"valid json\");\n        let privacy = json_value\n            .get(\"kukuri_privacy\")\n            .and_then(|value| value.as_object())\n            .expect(\"privacy object\");\n        assert_eq!(privacy.get(\"public_profile\").unwrap(), &json!(false));\n        assert_eq!(privacy.get(\"show_online_status\").unwrap(), &json!(true));\n    }\n}\n","traces":[{"line":8,"address":[13494902,13495381,13493840],"length":1,"stats":{"Line":1}},{"line":9,"address":[13600194,13599782,13600016],"length":1,"stats":{"Line":2}},{"line":10,"address":[23057243,23058480,23057089],"length":1,"stats":{"Line":2}},{"line":11,"address":[13570406],"length":1,"stats":{"Line":0}},{"line":12,"address":[13563515],"length":1,"stats":{"Line":0}},{"line":16,"address":[23057257],"length":1,"stats":{"Line":1}},{"line":17,"address":[23057288],"length":1,"stats":{"Line":1}},{"line":18,"address":[13600396],"length":1,"stats":{"Line":1}},{"line":19,"address":[13501484],"length":1,"stats":{"Line":1}},{"line":20,"address":[13494540],"length":1,"stats":{"Line":1}},{"line":21,"address":[13494572],"length":1,"stats":{"Line":1}},{"line":22,"address":[21262799],"length":1,"stats":{"Line":1}},{"line":23,"address":[13700933],"length":1,"stats":{"Line":1}},{"line":24,"address":[13569419],"length":1,"stats":{"Line":1}},{"line":27,"address":[13605584,13605803],"length":1,"stats":{"Line":0}},{"line":28,"address":[13495903],"length":1,"stats":{"Line":0}},{"line":29,"address":[13605605],"length":1,"stats":{"Line":0}},{"line":30,"address":[13502730,13502789],"length":1,"stats":{"Line":0}},{"line":35,"address":[23063332,23058800,23059687],"length":1,"stats":{"Line":1}},{"line":36,"address":[13496034],"length":1,"stats":{"Line":1}},{"line":37,"address":[13612096,13607951,13607692,13607845],"length":1,"stats":{"Line":0}},{"line":38,"address":[23063395],"length":1,"stats":{"Line":0}},{"line":42,"address":[13702578],"length":1,"stats":{"Line":1}},{"line":43,"address":[13571269,13571055],"length":1,"stats":{"Line":2}},{"line":44,"address":[13702882,13702955],"length":1,"stats":{"Line":2}},{"line":46,"address":[13489849,13490107],"length":1,"stats":{"Line":2}},{"line":47,"address":[13606989],"length":1,"stats":{"Line":0}},{"line":48,"address":[23059765,23059838],"length":1,"stats":{"Line":0}},{"line":49,"address":[13497093,13497033],"length":1,"stats":{"Line":0}},{"line":52,"address":[13565048,13564799],"length":1,"stats":{"Line":2}},{"line":53,"address":[13504277,13504350],"length":1,"stats":{"Line":0}},{"line":55,"address":[13497340,13497589],"length":1,"stats":{"Line":2}},{"line":56,"address":[21265842,21265915],"length":1,"stats":{"Line":0}},{"line":58,"address":[13704226,13703977],"length":1,"stats":{"Line":2}},{"line":59,"address":[13572735,13572805],"length":1,"stats":{"Line":0}},{"line":61,"address":[13603958,13604201],"length":1,"stats":{"Line":2}},{"line":62,"address":[13609913,13609843],"length":1,"stats":{"Line":0}},{"line":64,"address":[13505354,13505597],"length":1,"stats":{"Line":2}},{"line":65,"address":[13566487,13566557],"length":1,"stats":{"Line":0}},{"line":67,"address":[13505694,13505937],"length":1,"stats":{"Line":2}},{"line":68,"address":[13608875,13608945],"length":1,"stats":{"Line":0}},{"line":70,"address":[13605221,13605646,13604978],"length":1,"stats":{"Line":3}},{"line":71,"address":[13605274,13605339],"length":1,"stats":{"Line":2}},{"line":73,"address":[13612160,13612785],"length":1,"stats":{"Line":1}},{"line":74,"address":[13568502],"length":1,"stats":{"Line":1}},{"line":75,"address":[13493928,13494002,13494478],"length":1,"stats":{"Line":2}},{"line":76,"address":[13494160],"length":1,"stats":{"Line":1}},{"line":77,"address":[13610911],"length":1,"stats":{"Line":1}},{"line":78,"address":[13508152],"length":1,"stats":{"Line":1}},{"line":81,"address":[13499580,13499508],"length":1,"stats":{"Line":2}},{"line":83,"address":[21268586,21267950,21267575],"length":1,"stats":{"Line":3}},{"line":84,"address":[13611328],"length":1,"stats":{"Line":1}},{"line":85,"address":[23062730,23062866],"length":1,"stats":{"Line":2}},{"line":86,"address":[13605869],"length":1,"stats":{"Line":1}},{"line":87,"address":[13500026],"length":1,"stats":{"Line":1}},{"line":89,"address":[13567999],"length":1,"stats":{"Line":1}},{"line":90,"address":[13574839],"length":1,"stats":{"Line":1}},{"line":91,"address":[23062928],"length":1,"stats":{"Line":1}},{"line":93,"address":[13611721],"length":1,"stats":{"Line":1}},{"line":96,"address":[23063270,23062620],"length":1,"stats":{"Line":2}},{"line":97,"address":[23064114,23063300,23064096,23063210],"length":1,"stats":{"Line":1}},{"line":100,"address":[13576208],"length":1,"stats":{"Line":1}},{"line":101,"address":[13501486],"length":1,"stats":{"Line":1}},{"line":103,"address":[13494768],"length":1,"stats":{"Line":1}},{"line":104,"address":[23064339],"length":1,"stats":{"Line":1}},{"line":105,"address":[13569487,13569472],"length":1,"stats":{"Line":0}}],"covered":48,"coverable":66},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","mod.rs"],"content":"pub(crate) mod event_id_mapper;\npub(crate) mod metadata_mapper;\npub(crate) mod nostr_to_domain;\n\npub(crate) use event_id_mapper::{parse_event_id, parse_event_ids, parse_optional_event_id};\npub(crate) use metadata_mapper::{dto_to_profile_metadata, profile_metadata_to_nostr};\npub(crate) use nostr_to_domain::{\n    domain_event_from_event, domain_event_to_nostr_event, nostr_event_to_domain_event,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","nostr_to_domain.rs"],"content":"use crate::application::shared::nostr::to_nostr_event;\nuse crate::domain::entities::Event;\nuse crate::domain::entities::event_gateway::DomainEvent;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, Utc};\nuse nostr_sdk::prelude::Event as NostrEvent;\n\npub(crate) fn domain_event_from_event(event: &Event) -> Result<DomainEvent, AppError> {\n    DomainEvent::try_from(event).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid domain event: {err}\"),\n        )\n    })\n}\n\npub(crate) fn domain_event_to_nostr_event(\n    domain_event: &DomainEvent,\n) -> Result<nostr_sdk::Event, AppError> {\n    to_nostr_event(&domain_event.to_event())\n}\n\npub(crate) fn nostr_event_to_domain_event(event: &NostrEvent) -> Result<Event, AppError> {\n    let id = EventId::from_hex(&event.id.to_string()).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid event ID received from gateway: {err}\"),\n        )\n    })?;\n\n    let created_at = DateTime::<Utc>::from_timestamp(event.created_at.as_secs() as i64, 0)\n        .ok_or_else(|| {\n            AppError::validation(ValidationFailureKind::Generic, \"Invalid event timestamp\")\n        })?;\n\n    let tags = event.tags.iter().map(|tag| tag.clone().to_vec()).collect();\n\n    let event = Event::new_with_id(\n        id,\n        event.pubkey.to_string(),\n        event.content.clone(),\n        event.kind.as_u16() as u32,\n        tags,\n        created_at,\n        event.sig.to_string(),\n    );\n    event\n        .validate_for_gateway()\n        .map_err(|err| AppError::validation(err.kind, err.message))?;\n    Ok(event)\n}\n","traces":[{"line":9,"address":[19662512],"length":1,"stats":{"Line":0}},{"line":10,"address":[19655560,19655819,19655600],"length":1,"stats":{"Line":0}},{"line":11,"address":[25707455],"length":1,"stats":{"Line":0}},{"line":12,"address":[19730357],"length":1,"stats":{"Line":0}},{"line":13,"address":[19662602,19662661],"length":1,"stats":{"Line":0}},{"line":18,"address":[19862269,19862144],"length":1,"stats":{"Line":1}},{"line":21,"address":[19767384],"length":1,"stats":{"Line":1}},{"line":24,"address":[19725749,19723824,19725599],"length":1,"stats":{"Line":2}},{"line":25,"address":[19768075,19765902,19766052,19767856,19766291],"length":1,"stats":{"Line":4}},{"line":26,"address":[19665151],"length":1,"stats":{"Line":0}},{"line":27,"address":[25709589],"length":1,"stats":{"Line":0}},{"line":28,"address":[19864373,19864314],"length":1,"stats":{"Line":0}},{"line":32,"address":[19731246,19731471,19732646],"length":1,"stats":{"Line":2}},{"line":33,"address":[19732992],"length":1,"stats":{"Line":0}},{"line":34,"address":[19768124],"length":1,"stats":{"Line":0}},{"line":37,"address":[19651536,19649881,19649990,19651582],"length":1,"stats":{"Line":6}},{"line":40,"address":[13904357],"length":1,"stats":{"Line":2}},{"line":41,"address":[19724759,19724690],"length":1,"stats":{"Line":4}},{"line":42,"address":[19863313,19863247],"length":1,"stats":{"Line":4}},{"line":43,"address":[19664009,19664076],"length":1,"stats":{"Line":4}},{"line":44,"address":[25708715],"length":1,"stats":{"Line":2}},{"line":46,"address":[25708763],"length":1,"stats":{"Line":2}},{"line":48,"address":[19768902,19769172,19768973],"length":1,"stats":{"Line":4}},{"line":50,"address":[19733152,19733163,19732356],"length":1,"stats":{"Line":0}},{"line":51,"address":[13905068],"length":1,"stats":{"Line":2}}],"covered":14,"coverable":25},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","events.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_event_row(row: &SqliteRow) -> Result<Event, AppError> {\n    let event_id_hex: String = row.try_get(\"event_id\")?;\n    let event_id = EventId::from_hex(event_id_hex.as_str())?;\n    let kind = row.try_get::<i64, _>(\"kind\")? as u32;\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n    let tags = parse_event_tags(&tags_json);\n\n    Ok(Event::new_with_id(\n        event_id,\n        row.try_get(\"public_key\")?,\n        row.try_get(\"content\")?,\n        kind,\n        tags,\n        created_at,\n        row.try_get(\"sig\")?,\n    ))\n}\n\npub(crate) fn parse_event_tags(tags_json: &str) -> Vec<Vec<String>> {\n    serde_json::from_str(tags_json).unwrap_or_default()\n}\n","traces":[{"line":7,"address":[16677184,16679933,16680414],"length":1,"stats":{"Line":0}},{"line":8,"address":[16464142,16464344],"length":1,"stats":{"Line":0}},{"line":9,"address":[16541932,16539041,16538919,16539211],"length":1,"stats":{"Line":0}},{"line":10,"address":[16546241,16548793,16546371,16546103],"length":1,"stats":{"Line":0}},{"line":11,"address":[26506677,26504406,26504301],"length":1,"stats":{"Line":0}},{"line":13,"address":[16465142],"length":1,"stats":{"Line":0}},{"line":14,"address":[16678359,16678280],"length":1,"stats":{"Line":0}},{"line":16,"address":[16541088,16540769],"length":1,"stats":{"Line":0}},{"line":17,"address":[26504769],"length":1,"stats":{"Line":0}},{"line":18,"address":[16583643,16583718,16583893],"length":1,"stats":{"Line":0}},{"line":19,"address":[16678641,16679025,16678798],"length":1,"stats":{"Line":0}},{"line":21,"address":[16678941],"length":1,"stats":{"Line":0}},{"line":23,"address":[16465917,16466321,16466074],"length":1,"stats":{"Line":0}},{"line":27,"address":[16474144],"length":1,"stats":{"Line":0}},{"line":28,"address":[16580087],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","mod.rs"],"content":"pub(crate) mod event;\npub(crate) mod events;\npub(crate) mod posts;\npub(crate) mod topics;\npub(crate) mod users;\n\npub(crate) use event::{\n    domain_event_from_event, domain_event_to_nostr_event, dto_to_profile_metadata,\n    nostr_event_to_domain_event, parse_event_id, parse_event_ids, parse_optional_event_id,\n    profile_metadata_to_nostr,\n};\npub(crate) use events::map_event_row;\npub(crate) use posts::map_post_row;\npub(crate) use topics::{map_joined_topic_row, map_topic_row};\npub(crate) use users::map_user_row;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","posts.rs"],"content":"use crate::domain::entities::{Post, User};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_post_row(\n    row: &SqliteRow,\n    fallback_topic: Option<&str>,\n) -> Result<Post, AppError> {\n    let event_id: String = row.try_get(\"event_id\")?;\n    let public_key: String = row.try_get(\"public_key\")?;\n    let content: String = row.try_get(\"content\")?;\n    let created_at: i64 = row.try_get(\"created_at\")?;\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n\n    let topic_id = fallback_topic\n        .map(|id| id.to_string())\n        .or_else(|| extract_topic_from_tags(&tags_json))\n        .unwrap_or_default();\n\n    let user = User::from_pubkey(&public_key);\n    let created_at = DateTime::from_timestamp_millis(created_at).unwrap_or_else(Utc::now);\n\n    let scope = extract_scope_from_tags(&tags_json);\n    let epoch = extract_epoch_from_tags(&tags_json);\n\n    let mut post = Post::new_with_id(event_id, content, user, topic_id, created_at);\n    post.scope = scope;\n    post.epoch = epoch;\n    Ok(post)\n}\n\npub(crate) fn extract_topic_from_tags(tags_json: &str) -> Option<String> {\n    let tags = serde_json::from_str::<Vec<Vec<String>>>(tags_json).ok()?;\n    tags.into_iter().find_map(|tag| match tag.as_slice() {\n        [key, value, ..] if key == \"t\" => Some(value.clone()),\n        _ => None,\n    })\n}\n\nfn extract_tag_value(tags_json: &str, target: &str) -> Option<String> {\n    let tags = serde_json::from_str::<Vec<Vec<String>>>(tags_json).ok()?;\n    tags.into_iter().find_map(|tag| match tag.as_slice() {\n        [key, value, ..] if key == target => Some(value.clone()),\n        _ => None,\n    })\n}\n\nfn extract_scope_from_tags(tags_json: &str) -> Option<String> {\n    extract_tag_value(tags_json, \"scope\")\n}\n\nfn extract_epoch_from_tags(tags_json: &str) -> Option<i64> {\n    extract_tag_value(tags_json, \"epoch\").and_then(|value| value.parse::<i64>().ok())\n}\n","traces":[{"line":6,"address":[16469971,16467424,16469795],"length":1,"stats":{"Line":1}},{"line":10,"address":[25710329,25710100],"length":1,"stats":{"Line":1}},{"line":11,"address":[16580707,16582660,16580399,16580531],"length":1,"stats":{"Line":2}},{"line":12,"address":[16584945,16584764,16586578,16584601],"length":1,"stats":{"Line":2}},{"line":13,"address":[16468423,16468266,16468553],"length":1,"stats":{"Line":2}},{"line":14,"address":[16468514,16468630],"length":1,"stats":{"Line":2}},{"line":16,"address":[16482493,16482430],"length":1,"stats":{"Line":2}},{"line":17,"address":[16544630,16544608],"length":1,"stats":{"Line":2}},{"line":18,"address":[16544674,16544656],"length":1,"stats":{"Line":2}},{"line":21,"address":[16543403,16543471],"length":1,"stats":{"Line":2}},{"line":22,"address":[16475703,16475748],"length":1,"stats":{"Line":6}},{"line":24,"address":[16475790],"length":1,"stats":{"Line":3}},{"line":25,"address":[16587352,16587420],"length":1,"stats":{"Line":4}},{"line":27,"address":[16475975],"length":1,"stats":{"Line":1}},{"line":28,"address":[16550960,16551105],"length":1,"stats":{"Line":2}},{"line":29,"address":[16587905],"length":1,"stats":{"Line":2}},{"line":30,"address":[16582379],"length":1,"stats":{"Line":1}},{"line":33,"address":[16586768,16587166],"length":1,"stats":{"Line":1}},{"line":34,"address":[24245136,24245338],"length":1,"stats":{"Line":1}},{"line":35,"address":[25713104,25712975,25713139,25713378,25712838],"length":1,"stats":{"Line":8}},{"line":36,"address":[16587343,16587462,16587312],"length":1,"stats":{"Line":6}},{"line":37,"address":[16470683],"length":1,"stats":{"Line":0}},{"line":41,"address":[24245856,24246275],"length":1,"stats":{"Line":2}},{"line":42,"address":[25713655,25713450],"length":1,"stats":{"Line":1}},{"line":43,"address":[16545936,16545786,16546216,16545976,16545657],"length":1,"stats":{"Line":8}},{"line":44,"address":[24246457,24246572,24246421],"length":1,"stats":{"Line":7}},{"line":45,"address":[16588096],"length":1,"stats":{"Line":3}},{"line":49,"address":[16485408],"length":1,"stats":{"Line":3}},{"line":50,"address":[16471669],"length":1,"stats":{"Line":3}},{"line":53,"address":[16478480],"length":1,"stats":{"Line":1}},{"line":54,"address":[16588425,16588416,16588356],"length":1,"stats":{"Line":4}}],"covered":30,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","topics.rs"],"content":"use crate::domain::entities::{Topic, TopicVisibility};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    base_topic_from_row(row)\n}\n\npub(crate) fn map_joined_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let mut topic = base_topic_from_row(row)?;\n    topic.is_joined = true;\n    Ok(topic)\n}\n\nfn base_topic_from_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let description = row\n        .try_get::<Option<String>, _>(\"description\")?\n        .unwrap_or_default();\n    let mut topic = Topic::new_with_id(\n        row.try_get(\"topic_id\")?,\n        row.try_get(\"name\")?,\n        description,\n        created_at,\n    );\n    topic.updated_at =\n        DateTime::from_timestamp_millis(row.try_get(\"updated_at\")?).unwrap_or(created_at);\n    topic.member_count = row.try_get::<i64, _>(\"member_count\")? as u32;\n    topic.post_count = row.try_get::<i64, _>(\"post_count\")? as u32;\n    topic.visibility = match row.try_get::<String, _>(\"visibility\")?.as_str() {\n        \"private\" => TopicVisibility::Private,\n        _ => TopicVisibility::Public,\n    };\n    Ok(topic)\n}\n","traces":[{"line":6,"address":[14209840],"length":1,"stats":{"Line":0}},{"line":7,"address":[12962433],"length":1,"stats":{"Line":0}},{"line":10,"address":[14409184],"length":1,"stats":{"Line":0}},{"line":11,"address":[14277657,14277832],"length":1,"stats":{"Line":0}},{"line":12,"address":[21971232],"length":1,"stats":{"Line":0}},{"line":13,"address":[14308968],"length":1,"stats":{"Line":0}},{"line":16,"address":[14270976,14273504,14273366],"length":1,"stats":{"Line":0}},{"line":17,"address":[12962766,12962976],"length":1,"stats":{"Line":0}},{"line":19,"address":[14210590,14210316,14210458],"length":1,"stats":{"Line":0}},{"line":23,"address":[14313537,14313712,14313408],"length":1,"stats":{"Line":0}},{"line":24,"address":[12963511,12963733,12963362],"length":1,"stats":{"Line":0}},{"line":25,"address":[14410363],"length":1,"stats":{"Line":0}},{"line":28,"address":[14279384],"length":1,"stats":{"Line":0}},{"line":29,"address":[14211310,14212568,14211385],"length":1,"stats":{"Line":0}},{"line":30,"address":[14411878,14410966,14411123],"length":1,"stats":{"Line":0}},{"line":31,"address":[14272846,14272607,14273396,14272720],"length":1,"stats":{"Line":0}},{"line":32,"address":[14279851,14280189,14279738,14280303],"length":1,"stats":{"Line":0}},{"line":33,"address":[14315258,14315301],"length":1,"stats":{"Line":0}},{"line":34,"address":[14311355],"length":1,"stats":{"Line":0}},{"line":36,"address":[21973680],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","users.rs"],"content":"use crate::domain::entities::{User, UserProfile};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_user_row(row: &SqliteRow) -> Result<User, AppError> {\n    let profile = UserProfile {\n        display_name: row.try_get(\"display_name\").unwrap_or_default(),\n        bio: row.try_get(\"bio\").unwrap_or_default(),\n        avatar_url: row.try_get(\"avatar_url\").ok(),\n    };\n\n    let mut user = User::new_with_profile(row.try_get(\"npub\")?, profile);\n    user.pubkey = row.try_get(\"pubkey\")?;\n    user.public_profile = row.try_get::<i64, _>(\"is_profile_public\").unwrap_or(1) != 0;\n    user.show_online_status = row.try_get::<i64, _>(\"show_online_status\").unwrap_or(0) != 0;\n\n    if let Ok(created_at_ms) = row.try_get::<i64, _>(\"created_at\") {\n        if let Some(timestamp) = DateTime::<Utc>::from_timestamp_millis(created_at_ms) {\n            user.created_at = timestamp;\n        }\n    }\n    if let Ok(updated_at_ms) = row.try_get::<i64, _>(\"updated_at\") {\n        if let Some(timestamp) = DateTime::<Utc>::from_timestamp_millis(updated_at_ms) {\n            user.updated_at = timestamp;\n        }\n    }\n\n    Ok(user)\n}\n","traces":[{"line":6,"address":[17025584,17027203,17027574],"length":1,"stats":{"Line":1}},{"line":8,"address":[16812550],"length":1,"stats":{"Line":2}},{"line":9,"address":[16887281,16887213],"length":1,"stats":{"Line":3}},{"line":10,"address":[16894313,16894241],"length":1,"stats":{"Line":6}},{"line":13,"address":[23917390,23915976,23915908],"length":1,"stats":{"Line":6}},{"line":14,"address":[16813282,16813357],"length":1,"stats":{"Line":6}},{"line":15,"address":[17026739],"length":1,"stats":{"Line":3}},{"line":16,"address":[16888340],"length":1,"stats":{"Line":3}},{"line":18,"address":[23916777],"length":1,"stats":{"Line":3}},{"line":19,"address":[16932206,16932279],"length":1,"stats":{"Line":6}},{"line":20,"address":[17027118],"length":1,"stats":{"Line":3}},{"line":23,"address":[17027172,17027212],"length":1,"stats":{"Line":6}},{"line":24,"address":[16814272,16814199],"length":1,"stats":{"Line":6}},{"line":25,"address":[16821111],"length":1,"stats":{"Line":3}},{"line":29,"address":[16927080],"length":1,"stats":{"Line":3}}],"covered":15,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mod.rs"],"content":"pub mod default_topics;\npub mod mappers;\npub mod nostr;\n#[doc(hidden)]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","factory.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::shared::error::AppError;\nuse nostr_sdk::JsonUtil;\nuse serde_json::json;\n\npub fn build_deletion_event(id: &str, pubkey: String) -> Event {\n    let mut deletion_event = Event::new(EventKind::EventDeletion.as_u32(), String::new(), pubkey);\n    deletion_event.add_e_tag(id.to_string());\n    deletion_event\n}\n\npub fn to_nostr_event(event: &Event) -> Result<nostr_sdk::Event, AppError> {\n    let event_json = json!({\n        \"id\": event.id,\n        \"pubkey\": event.pubkey,\n        \"created_at\": event.created_at.timestamp(),\n        \"kind\": event.kind,\n        \"tags\": event.tags,\n        \"content\": event.content,\n        \"sig\": event.sig,\n    });\n\n    nostr_sdk::Event::from_json(event_json.to_string())\n        .map_err(|e| AppError::NostrError(format!(\"Failed to convert event: {e}\")))\n}\n","traces":[{"line":6,"address":[12825776,12826135],"length":1,"stats":{"Line":0}},{"line":7,"address":[12725456,12725561],"length":1,"stats":{"Line":0}},{"line":8,"address":[12626706,12626766],"length":1,"stats":{"Line":0}},{"line":9,"address":[12731323],"length":1,"stats":{"Line":0}},{"line":12,"address":[20389964,20388080],"length":1,"stats":{"Line":3}},{"line":13,"address":[12826810,12826863,12828082,12826206],"length":1,"stats":{"Line":6}},{"line":16,"address":[12826791,12826855],"length":1,"stats":{"Line":6}},{"line":23,"address":[12689505,12689443],"length":1,"stats":{"Line":6}},{"line":24,"address":[23919856,23919886],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","mod.rs"],"content":"pub mod factory;\npub mod publisher;\n\npub use factory::*;\npub use publisher::EventPublisher;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","publisher.rs"],"content":"use anyhow::Result;\r\nuse nostr_sdk::prelude::*;\r\nuse tracing::{debug, info};\r\n\r\n/// Nostr イベントの生成を担う共通パブリッシャー。\r\n#[derive(Default)]\r\npub struct EventPublisher {\r\n    keys: Option<Keys>,\r\n}\r\n\r\nimpl EventPublisher {\r\n    /// 新しい EventPublisher インスタンスを作成\r\n    pub fn new() -> Self {\r\n        Self::default()\r\n    }\r\n\r\n    /// 鍵を設定\r\n    pub fn set_keys(&mut self, keys: Keys) {\r\n        self.keys = Some(keys);\r\n    }\r\n\r\n    /// テキストノートイベントを作成\r\n    pub fn create_text_note(&self, content: &str, tags: Vec<Tag>) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::text_note(content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created text note event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// メタデータイベントを作成\r\n    pub fn create_metadata(&self, metadata: Metadata) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::metadata(&metadata).sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created metadata event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// リアクションイベントを作成\r\n    pub fn create_reaction(&self, event_id: &EventId, reaction: &str) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        // リアクションイベント用のタグを作成\r\n        let tags = vec![Tag::event(*event_id), Tag::public_key(keys.public_key())];\r\n\r\n        let event = EventBuilder::new(Kind::Reaction, reaction)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created reaction event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n    pub fn create_repost(&self, event_id: &EventId) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        let event = EventBuilder::new(Kind::Repost, \"\")\r\n            .tag(Tag::event(*event_id))\r\n            .sign_with_keys(keys)?;\r\n\r\n        info!(\"Created repost event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// 削除イベントを作成\r\n    pub fn create_deletion(&self, event_ids: Vec<EventId>, reason: Option<&str>) -> Result<Event> {\r\n        let keys = self\r\n            .keys\r\n            .as_ref()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\r\n\r\n        // 削除イベント用のタグを作成\r\n        let tags: Vec<Tag> = event_ids.iter().map(|id| Tag::event(*id)).collect();\r\n\r\n        let content = reason.unwrap_or(\"\");\r\n\r\n        let event = EventBuilder::new(Kind::EventDeletion, content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        debug!(\"Created deletion event: {}\", event.id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// トピック投稿イベントを作成（kukuri 独自実装）\r\n    pub fn create_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\r\n        let mut tags = vec![\r\n            Tag::hashtag(topic_id),\r\n            Tag::custom(TagKind::Custom(\"topic\".into()), vec![topic_id.to_string()]),\r\n        ];\r\n\r\n        if let Some(reply_id) = reply_to {\n            tags.push(Tag::event(reply_id));\n            tags.push(Tag::custom(\n                TagKind::Custom(\"reply\".into()),\n                vec![reply_id.to_string()],\n            ));\n        }\n\n        if let Some(scope) = scope {\n            tags.push(Tag::parse([\"scope\", scope])?);\n        }\n        if let Some(epoch) = epoch {\n            let epoch_value = epoch.to_string();\n            tags.push(Tag::parse([\"epoch\", epoch_value.as_str()])?);\n        }\n\r\n        let event = EventBuilder::text_note(content)\r\n            .tags(tags)\r\n            .sign_with_keys(keys)?;\r\n\r\n        info!(\"Created topic post for topic: {}\", topic_id);\r\n        Ok(event)\r\n    }\r\n\r\n    /// 公開鍵を取得\r\n    pub fn get_public_key(&self) -> Option<PublicKey> {\r\n        self.keys.as_ref().map(|k| k.public_key())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_event_publisher_creation() {\r\n        let publisher = EventPublisher::new();\r\n        assert!(publisher.keys.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_set_keys() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        let public_key = keys.public_key();\r\n\r\n        publisher.set_keys(keys);\r\n        assert_eq!(publisher.get_public_key(), Some(public_key));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_text_note() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event = publisher.create_text_note(\"Hello, Nostr!\", vec![]).unwrap();\r\n        assert_eq!(event.content, \"Hello, Nostr!\");\r\n        assert_eq!(event.kind, Kind::TextNote);\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_text_note_with_tags() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let tags = vec![Tag::hashtag(\"nostr\"), Tag::hashtag(\"test\")];\r\n\r\n        let event = publisher\r\n            .create_text_note(\"Hello with tags!\", tags.clone())\r\n            .unwrap();\r\n        assert_eq!(event.content, \"Hello with tags!\");\r\n\r\n        // タグが含まれていることを確認\r\n        let event_tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"nostr\")));\r\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"test\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_metadata() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let metadata = Metadata::new()\r\n            .name(\"Test User\")\r\n            .about(\"Test about\")\r\n            .picture(Url::parse(\"https://example.com/pic.jpg\").unwrap());\r\n\r\n        let event = publisher.create_metadata(metadata).unwrap();\r\n        assert_eq!(event.kind, Kind::Metadata);\r\n        assert!(event.content.contains(\"Test User\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_repost() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event_id = EventId::from_slice(&[4; 32]).unwrap();\r\n        let event = publisher.create_repost(&event_id).unwrap();\r\n        assert_eq!(event.kind, Kind::Repost);\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_reaction() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys.clone());\r\n\r\n        let event_id = EventId::from_slice(&[1; 32]).unwrap();\r\n        let event = publisher.create_reaction(&event_id, \"+\").unwrap();\r\n\r\n        assert_eq!(event.kind, Kind::Reaction);\r\n        assert_eq!(event.content, \"+\");\r\n\r\n        // タグにイベントIDが含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id: id, .. }) if id == &event_id)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_deletion() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event_ids = vec![\r\n            EventId::from_slice(&[1; 32]).unwrap(),\r\n            EventId::from_slice(&[2; 32]).unwrap(),\r\n        ];\r\n\r\n        let event = publisher\r\n            .create_deletion(event_ids.clone(), Some(\"Spam\"))\r\n            .unwrap();\r\n        assert_eq!(event.kind, Kind::EventDeletion);\r\n        assert_eq!(event.content, \"Spam\");\r\n\r\n        // 削除対象のイベントIDが含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        for id in &event_ids {\r\n            assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == id)));\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_topic_post() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let event = publisher\n            .create_topic_post(\"bitcoin\", \"Let's discuss Bitcoin!\", None, None, None)\n            .unwrap();\n        assert!(event.content.contains(\"Let's discuss Bitcoin!\"));\r\n\r\n        // タグを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"bitcoin\")));\r\n        assert!(\r\n            tags.iter()\r\n                .any(|t| t.kind().to_string() == \"topic\" && t.content().is_some())\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_create_topic_post_with_reply() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        let reply_to = EventId::from_slice(&[3; 32]).unwrap();\r\n        let event = publisher\n            .create_topic_post(\"nostr\", \"Reply to thread\", Some(reply_to), None, None)\n            .unwrap();\n\r\n        // タグにリプライ情報が含まれていることを確認\r\n        let tags: Vec<_> = event.tags.into_iter().collect();\r\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == &reply_to)));\r\n        assert!(\r\n            tags.iter()\r\n                .any(|t| t.kind().to_string() == \"reply\" && t.content().is_some())\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_no_keys_error() {\r\n        let publisher = EventPublisher::new();\r\n\r\n        // 鍵が設定されていない状態で各メソッドを呼び出すとエラーになることを確認\r\n        assert!(publisher.create_text_note(\"test\", vec![]).is_err());\r\n        assert!(publisher.create_metadata(Metadata::new()).is_err());\r\n        assert!(\r\n            publisher\r\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\r\n                .is_err()\r\n        );\r\n        assert!(publisher.create_deletion(vec![], None).is_err());\n        assert!(\n            publisher\n                .create_topic_post(\"topic\", \"content\", None, None, None)\n                .is_err()\n        );\n    }\r\n\r\n    #[test]\r\n    fn test_event_signature_verification() {\r\n        let mut publisher = EventPublisher::new();\r\n        let keys = Keys::generate();\r\n        publisher.set_keys(keys);\r\n\r\n        // 各種イベントを作成して署名が正しいことを確認\r\n        let events = vec![\r\n            publisher.create_text_note(\"test\", vec![]).unwrap(),\r\n            publisher\r\n                .create_metadata(Metadata::new().name(\"test\"))\r\n                .unwrap(),\r\n            publisher\r\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\r\n                .unwrap(),\r\n            publisher\n                .create_topic_post(\"test\", \"content\", None, None, None)\n                .unwrap(),\n        ];\r\n\r\n        for event in events {\r\n            assert!(\r\n                event.verify().is_ok(),\r\n                \"Event signature verification failed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[21973920],"length":1,"stats":{"Line":3}},{"line":14,"address":[21973928],"length":1,"stats":{"Line":3}},{"line":18,"address":[14212736,14212820],"length":1,"stats":{"Line":3}},{"line":19,"address":[14317283,14317387],"length":1,"stats":{"Line":6}},{"line":23,"address":[14282999,14283040,14280656],"length":1,"stats":{"Line":1}},{"line":24,"address":[14199226,14199506,14201502,14199310],"length":1,"stats":{"Line":4}},{"line":27,"address":[14213250,14215316,14215312],"length":1,"stats":{"Line":3}},{"line":29,"address":[21974439,21974542,21976464,21974845],"length":1,"stats":{"Line":2}},{"line":30,"address":[14412607],"length":1,"stats":{"Line":1}},{"line":31,"address":[14274413],"length":1,"stats":{"Line":0}},{"line":33,"address":[25715250,25715925,25850809,25850943,25715410],"length":1,"stats":{"Line":3}},{"line":34,"address":[14413479],"length":1,"stats":{"Line":1}},{"line":38,"address":[14285354,14283136,14285383],"length":1,"stats":{"Line":1}},{"line":39,"address":[21976905,21978837,21976650,21976721],"length":1,"stats":{"Line":4}},{"line":42,"address":[14215673,14217648,14217652],"length":1,"stats":{"Line":3}},{"line":44,"address":[21978819,21976874,21976950,21977146],"length":1,"stats":{"Line":2}},{"line":46,"address":[14276890,14277602,14329577,14329711,14276723,14277419],"length":1,"stats":{"Line":3}},{"line":47,"address":[14315460],"length":1,"stats":{"Line":1}},{"line":51,"address":[21981671,21981652,21978928],"length":1,"stats":{"Line":1}},{"line":52,"address":[14322338,14322528],"length":1,"stats":{"Line":2}},{"line":55,"address":[14213524,14211008,14213520],"length":1,"stats":{"Line":3}},{"line":58,"address":[25720030,25719630,25719519,25722059],"length":1,"stats":{"Line":1}},{"line":60,"address":[14317317,14317762,14317459],"length":1,"stats":{"Line":2}},{"line":61,"address":[14317419],"length":1,"stats":{"Line":1}},{"line":62,"address":[14418082],"length":1,"stats":{"Line":0}},{"line":64,"address":[21979947,22030489,21980826,21980114,22030623,21980637],"length":1,"stats":{"Line":3}},{"line":65,"address":[14418668],"length":1,"stats":{"Line":1}},{"line":67,"address":[14288320,14290568],"length":1,"stats":{"Line":1}},{"line":68,"address":[14281458,14281687],"length":1,"stats":{"Line":1}},{"line":71,"address":[14209104,14209108,14207079],"length":1,"stats":{"Line":0}},{"line":73,"address":[14325729,14325497,14325442,14325244],"length":1,"stats":{"Line":3}},{"line":74,"address":[25722350,25722437,25722525,25724360],"length":1,"stats":{"Line":2}},{"line":75,"address":[21982379],"length":1,"stats":{"Line":0}},{"line":77,"address":[14326321,14325663,14374329,14374463,14326510,14325806],"length":1,"stats":{"Line":3}},{"line":78,"address":[14221736],"length":1,"stats":{"Line":1}},{"line":82,"address":[14328466,14328523,14325808],"length":1,"stats":{"Line":1}},{"line":83,"address":[14424953,14422605,14422409,14422330],"length":1,"stats":{"Line":4}},{"line":86,"address":[21984493,21986880,21986884],"length":1,"stats":{"Line":3}},{"line":89,"address":[14225749,14225728,14223242,14223330],"length":1,"stats":{"Line":4}},{"line":91,"address":[14216574,14216483],"length":1,"stats":{"Line":2}},{"line":93,"address":[25725439,25725054,25725139],"length":1,"stats":{"Line":2}},{"line":94,"address":[14209851],"length":1,"stats":{"Line":1}},{"line":95,"address":[14423218],"length":1,"stats":{"Line":0}},{"line":97,"address":[14263353,14217784,14217058,14217595,14216891,14263487],"length":1,"stats":{"Line":3}},{"line":98,"address":[14210732],"length":1,"stats":{"Line":1}},{"line":102,"address":[14328688,14330517,14333380],"length":1,"stats":{"Line":2}},{"line":110,"address":[14293952,14293768],"length":1,"stats":{"Line":3}},{"line":113,"address":[14298340,14293936,14298336],"length":1,"stats":{"Line":3}},{"line":115,"address":[14294501,14293880,14293970,14294701,14298319,14294052],"length":1,"stats":{"Line":7}},{"line":116,"address":[14330661],"length":1,"stats":{"Line":3}},{"line":117,"address":[14325198,14325277,14329476],"length":1,"stats":{"Line":8}},{"line":120,"address":[14294725,14294686],"length":1,"stats":{"Line":5}},{"line":121,"address":[14213229,14213363],"length":1,"stats":{"Line":2}},{"line":122,"address":[14220622,14220571],"length":1,"stats":{"Line":2}},{"line":123,"address":[14220181],"length":1,"stats":{"Line":1}},{"line":124,"address":[14295406,14295005,14295069],"length":1,"stats":{"Line":2}},{"line":128,"address":[14287876,14288505],"length":1,"stats":{"Line":3}},{"line":129,"address":[25729239,25729137],"length":1,"stats":{"Line":0}},{"line":131,"address":[14214261,14214015],"length":1,"stats":{"Line":3}},{"line":132,"address":[21989253],"length":1,"stats":{"Line":0}},{"line":133,"address":[14214350,14214433],"length":1,"stats":{"Line":0}},{"line":136,"address":[25729508,25730251,25731841,25729951],"length":1,"stats":{"Line":6}},{"line":137,"address":[14331387],"length":1,"stats":{"Line":3}},{"line":138,"address":[21990018],"length":1,"stats":{"Line":0}},{"line":140,"address":[14331689,14289762,14290474,14331823,14289595,14290285],"length":1,"stats":{"Line":10}},{"line":141,"address":[14215628],"length":1,"stats":{"Line":4}},{"line":145,"address":[14335168],"length":1,"stats":{"Line":1}},{"line":146,"address":[14298432,14298464,14298480],"length":1,"stats":{"Line":3}}],"covered":59,"coverable":68},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","fixtures.rs"],"content":"use nostr_sdk::prelude::*;\n\npub fn sample_signed_event() -> Event {\n    let keys = Keys::generate();\n    EventBuilder::text_note(\"Test content\")\n        .tags(vec![Tag::hashtag(\"test\")])\n        .sign_with_keys(&keys)\n        .expect(\"sign text note\")\n}\n","traces":[{"line":3,"address":[15123199,15123163,15122608],"length":1,"stats":{"Line":0}},{"line":4,"address":[20947073],"length":1,"stats":{"Line":0}},{"line":5,"address":[15123089,15122643,15123017],"length":1,"stats":{"Line":0}},{"line":6,"address":[15234219,15234564,15234676],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","manager_tests.rs"],"content":"#![cfg(test)]\r\n\r\nuse super::mocks::TestGossipService;\r\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::crypto::DefaultKeyManager;\nuse crate::infrastructure::event::EventManager;\nuse crate::infrastructure::p2p::GossipService;\nuse nostr_sdk::prelude::*;\r\nuse std::sync::Arc;\r\n\r\n#[tokio::test]\r\nasync fn event_manager_initializes_with_key_manager() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .expect(\"initialization succeeds\");\r\n    assert!(manager.get_public_key().await.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn event_manager_initializes_with_keypair_directly() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    let keypair = key_manager\r\n        .generate_keypair()\r\n        .await\r\n        .expect(\"keypair generation\");\r\n\r\n    manager\r\n        .initialize_with_keypair(&keypair)\r\n        .await\r\n        .expect(\"initialization with keypair\");\r\n    assert!(manager.get_public_key().await.is_some());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn operations_fail_before_initialization() {\r\n    let manager = EventManager::new();\r\n\r\n    assert!(manager.publish_text_note(\"test\").await.is_err());\n    assert!(\n        manager\n            .publish_topic_post(\"topic\", \"content\", None, None, None)\n            .await\n            .is_err()\n    );\n    assert!(manager.subscribe_to_topic(\"topic\", None).await.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn initialize_and_disconnect_cycle() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    assert!(manager.ensure_initialized().await.is_ok());\r\n    manager.disconnect().await.unwrap();\r\n    assert!(manager.ensure_initialized().await.is_err());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn get_public_key_matches_key_manager() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    assert!(manager.get_public_key().await.is_none());\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    let public_key = manager.get_public_key().await.unwrap();\r\n    let current_pubkey = key_manager.current_keypair().await.unwrap().public_key;\r\n    let expected = PublicKey::from_hex(&current_pubkey).expect(\"valid pubkey hex\");\r\n    assert_eq!(public_key, expected);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn default_topics_api_behaves_idempotently() {\r\n    let manager = EventManager::new();\n\n    let mut topics = manager.list_default_p2p_topics().await;\n    topics.sort();\n    assert_eq!(topics, vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()]);\n\r\n    manager\r\n        .set_default_p2p_topics(vec![\"a\".into(), \"b\".into()])\r\n        .await;\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    topics.sort();\r\n    assert_eq!(topics, vec![\"a\".to_string(), \"b\".to_string()]);\r\n\r\n    manager.add_default_p2p_topic(\"c\").await;\r\n    manager.remove_default_p2p_topic(\"b\").await;\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    topics.sort();\r\n    assert_eq!(topics, vec![\"a\".to_string(), \"c\".to_string()]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn routing_non_topic_broadcasts_to_user_topic() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    manager\r\n        .set_default_p2p_topics(vec![\"t1\".into(), \"t2\".into()])\r\n        .await;\r\n\r\n    let gossip = Arc::new(TestGossipService::new());\r\n    manager.set_gossip_service(gossip.clone()).await;\r\n\r\n    let publisher = manager.event_publisher.read().await;\r\n    let nostr_event = publisher.create_text_note(\"hello\", vec![]).unwrap();\r\n    drop(publisher);\r\n\r\n    let mut topics = manager.list_default_p2p_topics().await;\r\n    if let Some(pk) = manager.get_public_key().await {\r\n        topics.push(user_topic_id(&pk.to_string()));\r\n    }\r\n    manager\r\n        .broadcast_to_topics(\r\n            &(gossip.clone() as Arc<dyn GossipService>),\r\n            &topics,\r\n            &nostr_event,\r\n        )\r\n        .await\r\n        .unwrap();\r\n\r\n    let joined = gossip.joined_topics().await;\r\n    let pubkey = manager.get_public_key().await.unwrap();\r\n    let user_topic = user_topic_id(&pubkey.to_string());\r\n    assert!(joined.contains(\"t1\"));\r\n    assert!(joined.contains(\"t2\"));\r\n    assert!(joined.contains(&user_topic));\r\n\r\n    let mut b = gossip.broadcasted_topics().await;\r\n    b.sort();\r\n    assert_eq!(b, {\r\n        let mut v = vec![\"t1\".to_string(), \"t2\".to_string(), user_topic];\r\n        v.sort();\r\n        v\r\n    });\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publisher_creates_expected_event_kinds() {\r\n    let manager = EventManager::new();\r\n    let key_manager = DefaultKeyManager::new();\r\n\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    let publisher = manager.event_publisher.read().await;\r\n\r\n    let text_event = publisher.create_text_note(\"Test note\", vec![]).unwrap();\r\n    assert_eq!(text_event.kind, Kind::TextNote);\r\n\r\n    let metadata = Metadata::new().name(\"Test User\");\r\n    let metadata_event = publisher.create_metadata(metadata).unwrap();\r\n    assert_eq!(metadata_event.kind, Kind::Metadata);\r\n\r\n    let event_id = EventId::from_slice(&[1; 32]).unwrap();\r\n    let reaction_event = publisher.create_reaction(&event_id, \"+\").unwrap();\r\n    assert_eq!(reaction_event.kind, Kind::Reaction);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn ensure_initialized_requires_keypair() {\r\n    let manager = EventManager::new();\r\n    assert!(manager.ensure_initialized().await.is_err());\r\n\r\n    let key_manager = DefaultKeyManager::new();\r\n    key_manager.generate_keypair().await.unwrap();\r\n    manager\r\n        .initialize_with_key_manager(&key_manager)\r\n        .await\r\n        .unwrap();\r\n\r\n    assert!(manager.ensure_initialized().await.is_ok());\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mocks.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse tokio::sync::RwLock;\n\nuse crate::domain::entities as domain;\nuse crate::domain::p2p::TopicStats;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\n\npub struct TestGossipService {\n    joined: Arc<RwLock<HashSet<String>>>,\n    broadcasts: Arc<RwLock<Vec<(String, domain::Event)>>>,\n}\n\nimpl TestGossipService {\n    pub fn new() -> Self {\n        Self {\n            joined: Arc::new(RwLock::new(HashSet::new())),\n            broadcasts: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn joined_topics(&self) -> HashSet<String> {\n        self.joined.read().await.clone()\n    }\n\n    pub async fn broadcasted_topics(&self) -> Vec<String> {\n        self.broadcasts\n            .read()\n            .await\n            .iter()\n            .map(|(t, _)| t.clone())\n            .collect()\n    }\n}\n\nimpl Default for TestGossipService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl GossipService for TestGossipService {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        let mut j = self.joined.write().await;\n        j.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &domain::Event) -> Result<(), AppError> {\n        let mut b = self.broadcasts.write().await;\n        b.push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<domain::Event>, AppError> {\n        let (_tx, rx) = tokio::sync::mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_stats(&self, _topic: &str) -> Result<Option<TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[14430048,14430260],"length":1,"stats":{"Line":1}},{"line":20,"address":[14335271],"length":1,"stats":{"Line":1}},{"line":21,"address":[14329759,14329816],"length":1,"stats":{"Line":2}},{"line":25,"address":[21992200,21992325,21992192,21992362,21992208,21992910,21992243,21992503],"length":1,"stats":{"Line":4}},{"line":26,"address":[14217435,14217376,14217559,14217333],"length":1,"stats":{"Line":2}},{"line":29,"address":[14218098,14218138,14218006,14218294,14217952,14217960,14218846,14217968],"length":1,"stats":{"Line":4}},{"line":30,"address":[14336524,14336751,14336938,14336366,14336865,14336478],"length":1,"stats":{"Line":6}},{"line":32,"address":[14334906,14334765,14334849,14334966,14335151],"length":1,"stats":{"Line":3}},{"line":34,"address":[14331568,14331601],"length":1,"stats":{"Line":2}},{"line":40,"address":[14432000],"length":1,"stats":{"Line":0}},{"line":41,"address":[14331633],"length":1,"stats":{"Line":0}},{"line":47,"address":[14339088],"length":1,"stats":{"Line":0}},{"line":48,"address":[14271336],"length":1,"stats":{"Line":0}},{"line":51,"address":[14258012,14257856,14257712,14257977,14258214,14258359,14258813,14257747,14257631],"length":1,"stats":{"Line":4}},{"line":52,"address":[14339718,14339911,14339781,14339403],"length":1,"stats":{"Line":2}},{"line":53,"address":[14265398,14265466],"length":1,"stats":{"Line":2}},{"line":54,"address":[22033714],"length":1,"stats":{"Line":1}},{"line":57,"address":[14377216,14377171,14377374,14377246,14377397,14377309,14377525],"length":1,"stats":{"Line":0}},{"line":58,"address":[14340729],"length":1,"stats":{"Line":0}},{"line":61,"address":[14372303,14372023,14372080,14372280,14373098,14372197,14372532,14372115],"length":1,"stats":{"Line":5}},{"line":62,"address":[11854839],"length":1,"stats":{"Line":1}},{"line":63,"address":[14372787,14372855],"length":1,"stats":{"Line":2}},{"line":64,"address":[14341861],"length":1,"stats":{"Line":1}},{"line":67,"address":[14260573,14260661,14260881,14260435,14260480,14260638,14260510],"length":1,"stats":{"Line":0}},{"line":71,"address":[14473833],"length":1,"stats":{"Line":0}},{"line":72,"address":[19417228],"length":1,"stats":{"Line":0}},{"line":75,"address":[19417337,19417405,19417376,19417468,19417551,19417533,19417743],"length":1,"stats":{"Line":0}},{"line":76,"address":[14373959],"length":1,"stats":{"Line":0}},{"line":79,"address":[14474685,14474528,14474707,14474557,14474620,14474483,14474899],"length":1,"stats":{"Line":0}},{"line":80,"address":[14374439],"length":1,"stats":{"Line":0}},{"line":83,"address":[14343614,14343411,14343456,14343637,14343841,14343486,14343549],"length":1,"stats":{"Line":0}},{"line":84,"address":[14262217],"length":1,"stats":{"Line":0}},{"line":87,"address":[19418958,19418977,19418800,19419105,19418893,19418830,19418765],"length":1,"stats":{"Line":0}},{"line":88,"address":[14475785],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":34},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mod.rs"],"content":"pub mod fixtures;\npub mod mocks;\n\n#[cfg(test)]\npub mod manager_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","mod.rs"],"content":"//! Shared test utilities.\n\npub mod event;\npub mod p2p;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","bootstrap.rs"],"content":"use crate::domain::p2p::P2PEvent;\nuse crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\nuse crate::infrastructure::p2p::{DiscoveryOptions, gossip_service::GossipService};\nuse iroh::{Endpoint, EndpointAddr, discovery::static_provider::StaticProvider};\nuse std::net::{Ipv4Addr, SocketAddrV4};\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\nuse tokio::time::{Duration, sleep, timeout};\n\nuse super::logging::log_step;\n\npub const DEFAULT_JOIN_TIMEOUT: Duration = Duration::from_secs(15);\npub const DEFAULT_EVENT_TIMEOUT: Duration = Duration::from_secs(15);\n\n#[derive(Clone, Debug)]\npub struct BootstrapContext {\n    pub hints: Vec<String>,\n    pub node_addrs: Vec<EndpointAddr>,\n}\n\npub async fn create_service(ctx: &BootstrapContext) -> IrohGossipService {\n    let bind_addr = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 0);\n    log_step!(\n        \"binding endpoint on {} and enabling DHT discovery (bootstrap hints: {})\",\n        bind_addr,\n        ctx.hints.join(\", \")\n    );\n    let static_discovery = Arc::new(StaticProvider::new());\n    let builder = DiscoveryOptions::default()\n        .apply_to_builder(Endpoint::builder())\n        .discovery(static_discovery.clone())\n        .bind_addr_v4(bind_addr);\n    let endpoint = Arc::new(builder.bind().await.expect(\"failed to bind iroh endpoint\"));\n    endpoint.online().await;\n    for addr in &ctx.node_addrs {\n        log_step!(\"adding bootstrap node addr {}\", addr.id);\n        static_discovery.add_endpoint_info(addr.clone());\n        match endpoint.connect(addr.clone(), iroh_gossip::ALPN).await {\n            Ok(_) => log_step!(\"connected to bootstrap {}\", addr.id),\n            Err(err) => log_step!(\"failed to connect to bootstrap {}: {:?}\", addr.id, err),\n        }\n    }\n    log_step!(\"endpoint ready, building gossip service\");\n    sleep(Duration::from_millis(200)).await;\n    IrohGossipService::new(endpoint, static_discovery).expect(\"failed to create gossip service\")\n}\n\npub fn build_peer_hints(\n    base: &[String],\n    local_hints: &[Option<String>],\n    self_idx: usize,\n) -> Vec<String> {\n    let mut result = base.to_vec();\n    for (idx, hint) in local_hints.iter().enumerate() {\n        if idx == self_idx {\n            continue;\n        }\n        if let Some(h) = hint {\n            if !result.contains(h) {\n                result.push(h.clone());\n            }\n        }\n    }\n    result\n}\n\npub async fn wait_for_topic_membership(\n    service: &IrohGossipService,\n    topic: &str,\n    timeout_duration: Duration,\n) -> bool {\n    let target = topic.to_string();\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < timeout_duration {\n        log_step!(\n            \"checking joined topics for {} (elapsed {:?}/{:?})\",\n            topic,\n            start.elapsed(),\n            timeout_duration\n        );\n        if let Ok(joined) = service.get_joined_topics().await {\n            log_step!(\"currently joined topics: {:?}\", joined);\n            if joined.iter().any(|t| t == &target) {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(100)).await;\n    }\n    false\n}\n\npub async fn wait_for_peer_join_event(\n    receivers: &mut [&mut broadcast::Receiver<P2PEvent>],\n    max_wait: Duration,\n) -> bool {\n    log_step!(\n        \"waiting up to {:?} for peer join events across {} receivers\",\n        max_wait,\n        receivers.len()\n    );\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < max_wait {\n        for rx in receivers.iter_mut() {\n            if let Ok(recv_result) =\n                timeout(Duration::from_millis(150), async { rx.recv().await }).await\n            {\n                match recv_result {\n                    Ok(P2PEvent::PeerJoined { .. }) => {\n                        log_step!(\"received PeerJoined event after {:?}\", start.elapsed());\n                        return true;\n                    }\n                    Ok(_) => {}\n                    Err(err) => {\n                        log_step!(\"peer join receiver error: {:?}\", err);\n                    }\n                }\n            }\n        }\n    }\n    log_step!(\n        \"timed out waiting for peer join events after {:?}\",\n        max_wait\n    );\n    false\n}\n","traces":[{"line":21,"address":[22921034,22920640,22920608,22920747,22923897,22920616,22920928],"length":1,"stats":{"Line":0}},{"line":22,"address":[17168376,17168617],"length":1,"stats":{"Line":0}},{"line":23,"address":[18021961,18022423],"length":1,"stats":{"Line":0}},{"line":28,"address":[22914887,22916411],"length":1,"stats":{"Line":0}},{"line":29,"address":[22923403,22923273,22923526,22923599,22923333],"length":1,"stats":{"Line":0}},{"line":30,"address":[17170904,17170958],"length":1,"stats":{"Line":0}},{"line":31,"address":[22916507,22917091,22916777,22916662],"length":1,"stats":{"Line":0}},{"line":32,"address":[23035073],"length":1,"stats":{"Line":0}},{"line":33,"address":[22930763,22930700,22930905,22927934],"length":1,"stats":{"Line":0}},{"line":34,"address":[22992153,22992237,22988787],"length":1,"stats":{"Line":0}},{"line":35,"address":[22996659,22996724,22992526],"length":1,"stats":{"Line":0}},{"line":37,"address":[17178621,17179639],"length":1,"stats":{"Line":0}},{"line":38,"address":[23030755,23038093,23026920],"length":1,"stats":{"Line":0}},{"line":40,"address":[23037495,23036947,23035150],"length":1,"stats":{"Line":0}},{"line":44,"address":[17176996,17178000,17168541,17179877],"length":1,"stats":{"Line":0}},{"line":45,"address":[23044037],"length":1,"stats":{"Line":0}},{"line":48,"address":[23039314,23038688],"length":1,"stats":{"Line":0}},{"line":53,"address":[22926056],"length":1,"stats":{"Line":0}},{"line":54,"address":[18032586,18032376,18032300],"length":1,"stats":{"Line":0}},{"line":55,"address":[22933203],"length":1,"stats":{"Line":0}},{"line":58,"address":[17180737],"length":1,"stats":{"Line":0}},{"line":59,"address":[23008000],"length":1,"stats":{"Line":0}},{"line":60,"address":[23044843],"length":1,"stats":{"Line":0}},{"line":64,"address":[23000932],"length":1,"stats":{"Line":0}},{"line":67,"address":[23044928],"length":1,"stats":{"Line":0}},{"line":72,"address":[22940618],"length":1,"stats":{"Line":0}},{"line":73,"address":[23008634,23008520],"length":1,"stats":{"Line":0}},{"line":74,"address":[23001712,23002042],"length":1,"stats":{"Line":0}},{"line":75,"address":[22929182,22928761],"length":1,"stats":{"Line":0}},{"line":81,"address":[22943330,22940953,22941882,22940679],"length":1,"stats":{"Line":0}},{"line":83,"address":[23144689,23145165,23143629,23145152],"length":1,"stats":{"Line":0}},{"line":84,"address":[23006320],"length":1,"stats":{"Line":0}},{"line":87,"address":[17181531,17186290,17181244,17186145],"length":1,"stats":{"Line":0}},{"line":89,"address":[23002108],"length":1,"stats":{"Line":0}},{"line":92,"address":[23044832],"length":1,"stats":{"Line":0}},{"line":96,"address":[23052214,23051888],"length":1,"stats":{"Line":0}},{"line":101,"address":[23045658,23046930],"length":1,"stats":{"Line":0}},{"line":102,"address":[23020088,23015752],"length":1,"stats":{"Line":0}},{"line":103,"address":[22952422,22952129,22952218,22953985],"length":1,"stats":{"Line":0}},{"line":104,"address":[23008897,23015008,23006979,23014890,23015043,23013120],"length":1,"stats":{"Line":0}},{"line":107,"address":[17188968,17189027],"length":1,"stats":{"Line":0}},{"line":109,"address":[17190396,17190723],"length":1,"stats":{"Line":0}},{"line":110,"address":[23052114],"length":1,"stats":{"Line":0}},{"line":113,"address":[17189073],"length":1,"stats":{"Line":0}},{"line":124,"address":[22952972],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","config.rs"],"content":"use crate::infrastructure::p2p::utils::parse_peer_hint;\n\nuse super::bootstrap::BootstrapContext;\nuse super::logging::log_step;\n\npub fn load_bootstrap_context(test_name: &str) -> Option<BootstrapContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        log_step!(\"skipping {} (ENABLE_P2P_INTEGRATION != 1)\", test_name);\n        return None;\n    }\n\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    if raw.trim().is_empty() {\n        log_step!(\"skipping {} (KUKURI_BOOTSTRAP_PEERS not set)\", test_name);\n        return None;\n    }\n\n    let mut hints = Vec::new();\n    let mut addrs = Vec::new();\n\n    for entry in raw.split(',') {\n        let trimmed = entry.trim();\n        if trimmed.is_empty() {\n            continue;\n        }\n        hints.push(trimmed.to_string());\n        match parse_peer_hint(trimmed) {\n            Ok(parsed) => {\n                if let Some(addr) = parsed.node_addr {\n                    addrs.push(addr);\n                } else {\n                    log_step!(\"bootstrap peer '{}' missing address; skipping\", trimmed);\n                }\n            }\n            Err(err) => {\n                log_step!(\"failed to parse bootstrap peer '{}': {:?}\", trimmed, err);\n                return None;\n            }\n        }\n    }\n\n    if addrs.is_empty() {\n        log_step!(\n            \"skipping {} (no usable bootstrap node addresses)\",\n            test_name\n        );\n        return None;\n    }\n\n    log_step!(\n        \"test {} using bootstrap peers: {}\",\n        test_name,\n        hints.join(\", \")\n    );\n\n    Some(BootstrapContext {\n        hints,\n        node_addrs: addrs,\n    })\n}\n","traces":[{"line":6,"address":[19661225,19658480,19668693],"length":1,"stats":{"Line":4}},{"line":7,"address":[19652032,19651750],"length":1,"stats":{"Line":8}},{"line":9,"address":[19775209],"length":1,"stats":{"Line":4}},{"line":12,"address":[23064715],"length":1,"stats":{"Line":0}},{"line":13,"address":[19768778,19768649],"length":1,"stats":{"Line":0}},{"line":15,"address":[23073619],"length":1,"stats":{"Line":0}},{"line":18,"address":[13906508],"length":1,"stats":{"Line":0}},{"line":19,"address":[19726846],"length":1,"stats":{"Line":0}},{"line":21,"address":[23065384,23065109,23065189,23071360],"length":1,"stats":{"Line":0}},{"line":22,"address":[13906940,13910814],"length":1,"stats":{"Line":0}},{"line":23,"address":[19773166],"length":1,"stats":{"Line":0}},{"line":26,"address":[19738093],"length":1,"stats":{"Line":0}},{"line":27,"address":[19869714],"length":1,"stats":{"Line":0}},{"line":28,"address":[19773343],"length":1,"stats":{"Line":0}},{"line":29,"address":[19663616,19663521],"length":1,"stats":{"Line":0}},{"line":30,"address":[19738528,19738424],"length":1,"stats":{"Line":0}},{"line":35,"address":[19769457],"length":1,"stats":{"Line":0}},{"line":37,"address":[19771877],"length":1,"stats":{"Line":0}},{"line":42,"address":[23065449,23065370],"length":1,"stats":{"Line":0}},{"line":47,"address":[23068164],"length":1,"stats":{"Line":0}},{"line":50,"address":[19728637,19729092],"length":1,"stats":{"Line":0}},{"line":56,"address":[19766011],"length":1,"stats":{"Line":0}},{"line":57,"address":[23065991],"length":1,"stats":{"Line":0}},{"line":58,"address":[19727851],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","fixtures.rs"],"content":"use crate::domain::entities::Event;\n\npub fn nostr_to_domain(ev: &nostr_sdk::Event) -> Event {\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(ev.created_at.as_secs() as i64, 0)\n            .expect(\"invalid timestamp in nostr event\");\n    Event {\n        id: ev.id.to_string(),\n        pubkey: ev.pubkey.to_string(),\n        created_at,\n        kind: ev.kind.as_u16() as u32,\n        tags: ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: ev.content.clone(),\n        sig: ev.sig.to_string(),\n    }\n}\n","traces":[{"line":3,"address":[23783502,23782784],"length":1,"stats":{"Line":0}},{"line":4,"address":[23708086],"length":1,"stats":{"Line":0}},{"line":8,"address":[23715137],"length":1,"stats":{"Line":0}},{"line":9,"address":[23775992],"length":1,"stats":{"Line":0}},{"line":11,"address":[20518357,20518427],"length":1,"stats":{"Line":0}},{"line":12,"address":[23702016,23701546,23702062],"length":1,"stats":{"Line":0}},{"line":13,"address":[23776218],"length":1,"stats":{"Line":0}},{"line":14,"address":[23914770],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","logging.rs"],"content":"use std::sync::Once;\nuse tracing_subscriber::EnvFilter;\n\nstatic INIT_TRACING: Once = Once::new();\n\npub fn init_tracing() {\n    INIT_TRACING.call_once(|| {\n        let env_filter = EnvFilter::try_from_default_env()\n            .unwrap_or_else(|_| EnvFilter::new(\"info,iroh_tests=info\"));\n        let subscriber = tracing_subscriber::fmt()\n            .with_env_filter(env_filter)\n            .with_target(true)\n            .compact()\n            .finish();\n        let _ = tracing::subscriber::set_global_default(subscriber);\n    });\n}\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    }};\n}\n\npub(crate) use log_step;\n","traces":[{"line":6,"address":[20707664],"length":1,"stats":{"Line":4}},{"line":7,"address":[20819169,20819200,20819598,20819569],"length":1,"stats":{"Line":5}},{"line":8,"address":[20819252],"length":1,"stats":{"Line":1}},{"line":9,"address":[20707804,20708128,20708112],"length":1,"stats":{"Line":1}},{"line":10,"address":[20813732,20813837],"length":1,"stats":{"Line":2}},{"line":11,"address":[14955392],"length":1,"stats":{"Line":1}},{"line":15,"address":[20782766],"length":1,"stats":{"Line":1}},{"line":21,"address":[23009067,23165801,23018007,23164902,23165430,23016321,23013977,23014530,23164745,22995875,23167913,23015466,23012122,23013849,23010770,23168070,23003624,23020752,23165958,23167542,23018827,23009691,23162633,23165273,23162790,23163318,23000126,23166857,23017053,22997574,23004244,23020154,23018320,23164374,22996436,23016497,23000760,23167014,23163689,23009145,23017680,23166329,23020235,23000221,23167385,22999999,22997112,23010349,23163161,23163846,23002404,23164217,23011580,23001878,23005340,23011479,23003672,23005878,23015140,23166486],"length":1,"stats":{"Line":12}}],"covered":8,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","mod.rs"],"content":"pub mod bootstrap;\npub mod config;\npub mod fixtures;\npub mod logging;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","bin","p2p_metrics_export.rs"],"content":"use anyhow::{Context, Result, bail};\nuse chrono::Utc;\nuse kukuri_lib::{\n    AppConfig, ConnectionPool, SqliteRepository, TopicMetricsRecord, TopicMetricsRepository,\n    TopicMetricsSnapshot, ops::p2p::metrics,\n};\nuse std::{\n    env, fs,\n    path::{Path, PathBuf},\n};\nuse tokio::runtime::Runtime;\n\nconst DEFAULT_LIMIT: usize = 25;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum JobKind {\n    P2P,\n    Trending,\n}\n\n#[derive(Debug, Clone)]\nstruct CliOptions {\n    output: Option<PathBuf>,\n    pretty: bool,\n    job: JobKind,\n    limit: usize,\n    database_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, serde::Serialize)]\nstruct ScoreWeightsSummary {\n    posts: f64,\n    unique_authors: f64,\n    boosts: f64,\n}\n\n#[derive(Debug, serde::Serialize)]\nstruct TrendingJobReport {\n    job: &'static str,\n    generated_at_ms: i64,\n    collected_at_ms: i64,\n    limit: usize,\n    metrics_count: usize,\n    score_weights: ScoreWeightsSummary,\n    window_start_ms: Option<i64>,\n    window_end_ms: Option<i64>,\n    window_duration_ms: Option<i64>,\n    lag_ms: Option<i64>,\n    topics: Vec<TopicMetricsRecord>,\n}\n\nfn usage() -> &'static str {\n    \"Usage: p2p_metrics_export [--job <p2p|trending>] [--output <path>] [--pretty] [--limit <n>] [--database-url <url>]\"\n}\n\nfn write_output(path: &Path, data: &str) -> Result<()> {\n    if let Some(parent) = path.parent() {\n        if !parent.as_os_str().is_empty() {\n            fs::create_dir_all(parent)\n                .with_context(|| format!(\"Failed to create {}\", parent.display()))?;\n        }\n    }\n    fs::write(path, data).with_context(|| format!(\"Failed to write {}\", path.display()))\n}\n\nfn emit_payload(target: Option<&Path>, payload: &str) -> Result<()> {\n    if let Some(path) = target {\n        write_output(path, payload)?;\n        println!(\"Metrics written to {}\", path.display());\n    } else {\n        println!(\"{payload}\");\n    }\n    Ok(())\n}\n\nfn main() -> Result<()> {\n    let args: Vec<String> = env::args().skip(1).collect();\n    let options = parse_args(args.into_iter())?;\n\n    match options.job {\n        JobKind::P2P => export_p2p(&options),\n        JobKind::Trending => export_trending(&options),\n    }\n}\n\nfn export_p2p(options: &CliOptions) -> Result<()> {\n    let snapshot = metrics::snapshot_full();\n    let payload = to_json(&snapshot, options.pretty)?;\n    emit_payload(options.output.as_deref(), &payload)\n}\n\nfn export_trending(options: &CliOptions) -> Result<()> {\n    let database_url = resolve_database_url(options);\n    let weights = current_score_weights();\n    let rt = Runtime::new().context(\"Failed to create Tokio runtime\")?;\n    let report = rt.block_on(async {\n        collect_trending_report(&database_url, options.limit, weights)\n            .await\n            .with_context(|| format!(\"Failed to collect trending metrics from {database_url}\"))\n    })?;\n\n    let payload = to_json(&report, options.pretty)?;\n    emit_payload(options.output.as_deref(), &payload)\n}\n\nfn to_json<T: serde::Serialize>(value: &T, pretty: bool) -> Result<String> {\n    if pretty {\n        Ok(serde_json::to_string_pretty(value)?)\n    } else {\n        Ok(serde_json::to_string(value)?)\n    }\n}\n\nfn parse_args<I>(args: I) -> Result<CliOptions>\nwhere\n    I: IntoIterator<Item = String>,\n{\n    let mut output: Option<PathBuf> = None;\n    let mut pretty = false;\n    let mut job = JobKind::P2P;\n    let mut limit = DEFAULT_LIMIT;\n    let mut database_url: Option<String> = None;\n\n    let mut iter = args.into_iter();\n    while let Some(arg) = iter.next() {\n        match arg.as_str() {\n            \"-o\" | \"--output\" => {\n                let path = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--output requires a path\\n{}\", usage()))?;\n                output = Some(PathBuf::from(path));\n            }\n            \"--pretty\" => {\n                pretty = true;\n            }\n            \"--job\" => {\n                let value = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--job requires a value\\n{}\", usage()))?;\n                job = parse_job(&value)?;\n            }\n            \"--limit\" => {\n                let value = iter\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"--limit requires a value\\n{}\", usage()))?;\n                limit = parse_limit(&value)?;\n            }\n            \"--database-url\" => {\n                let value = iter.next().ok_or_else(|| {\n                    anyhow::anyhow!(\"--database-url requires a value\\n{}\", usage())\n                })?;\n                database_url = Some(value);\n            }\n            \"-h\" | \"--help\" => {\n                println!(\"{}\", usage());\n                std::process::exit(0);\n            }\n            other => {\n                bail!(\"Unknown argument: {other}\\n{}\", usage());\n            }\n        }\n    }\n\n    Ok(CliOptions {\n        output,\n        pretty,\n        job,\n        limit,\n        database_url,\n    })\n}\n\nfn parse_job(value: &str) -> Result<JobKind> {\n    match value.to_ascii_lowercase().as_str() {\n        \"p2p\" => Ok(JobKind::P2P),\n        \"trending\" => Ok(JobKind::Trending),\n        other => bail!(\"Unknown job: {other}. Expected 'p2p' or 'trending'.\"),\n    }\n}\n\nfn parse_limit(value: &str) -> Result<usize> {\n    let parsed: usize = value\n        .parse()\n        .with_context(|| format!(\"Invalid limit '{value}'. Expected a positive integer.\"))?;\n    if parsed == 0 {\n        bail!(\"--limit must be greater than 0\");\n    }\n    Ok(parsed)\n}\n\nfn resolve_database_url(options: &CliOptions) -> String {\n    if let Some(url) = &options.database_url {\n        return url.clone();\n    }\n    if let Ok(env_url) = env::var(\"DATABASE_URL\") {\n        if !env_url.trim().is_empty() {\n            return env_url;\n        }\n    }\n    AppConfig::from_env().database.url\n}\n\nfn current_score_weights() -> ScoreWeightsSummary {\n    let cfg = AppConfig::from_env();\n    ScoreWeightsSummary {\n        posts: cfg.metrics.score_weights.posts,\n        unique_authors: cfg.metrics.score_weights.unique_authors,\n        boosts: cfg.metrics.score_weights.boosts,\n    }\n}\n\nasync fn collect_trending_report(\n    database_url: &str,\n    limit: usize,\n    weights: ScoreWeightsSummary,\n) -> Result<TrendingJobReport> {\n    let pool = ConnectionPool::new(database_url)\n        .await\n        .with_context(|| format!(\"Failed to connect to database at {database_url}\"))?;\n    let repository = SqliteRepository::new(pool);\n    let snapshot = repository\n        .list_recent_metrics(limit)\n        .await\n        .context(\"Failed to query topic metrics snapshot\")?;\n\n    Ok(build_report(snapshot, limit, weights))\n}\n\nfn build_report(\n    snapshot: Option<TopicMetricsSnapshot>,\n    limit: usize,\n    weights: ScoreWeightsSummary,\n) -> TrendingJobReport {\n    let now_ms = current_unix_ms();\n\n    if let Some(snapshot) = snapshot {\n        let duration = snapshot\n            .window_end\n            .saturating_sub(snapshot.window_start)\n            .max(0);\n        let lag = now_ms.saturating_sub(snapshot.window_end).max(0);\n        let metrics = snapshot.metrics;\n        TrendingJobReport {\n            job: \"trending_metrics\",\n            generated_at_ms: snapshot.window_end,\n            collected_at_ms: now_ms,\n            limit,\n            metrics_count: metrics.len(),\n            score_weights: weights,\n            window_start_ms: Some(snapshot.window_start),\n            window_end_ms: Some(snapshot.window_end),\n            window_duration_ms: Some(duration),\n            lag_ms: Some(lag),\n            topics: metrics,\n        }\n    } else {\n        TrendingJobReport {\n            job: \"trending_metrics\",\n            generated_at_ms: now_ms,\n            collected_at_ms: now_ms,\n            limit,\n            metrics_count: 0,\n            score_weights: weights,\n            window_start_ms: None,\n            window_end_ms: None,\n            window_duration_ms: None,\n            lag_ms: None,\n            topics: Vec::new(),\n        }\n    }\n}\n\nfn current_unix_ms() -> i64 {\n    Utc::now().timestamp_millis()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parses_defaults() {\n        let opts = parse_args(Vec::<String>::new()).expect(\"options\");\n        assert_eq!(opts.job, JobKind::P2P);\n        assert_eq!(opts.limit, DEFAULT_LIMIT);\n        assert!(opts.output.is_none());\n    }\n\n    #[test]\n    fn parses_trending_job_with_options() {\n        let opts = parse_args(\n            vec![\n                \"--job\".into(),\n                \"trending\".into(),\n                \"--limit\".into(),\n                \"10\".into(),\n                \"--database-url\".into(),\n                \"sqlite::memory:\".into(),\n                \"--output\".into(),\n                \"out.json\".into(),\n                \"--pretty\".into(),\n            ]\n            .into_iter(),\n        )\n        .expect(\"options\");\n\n        assert_eq!(opts.job, JobKind::Trending);\n        assert_eq!(opts.limit, 10);\n        assert_eq!(opts.database_url.as_deref(), Some(\"sqlite::memory:\"));\n        assert!(opts.pretty);\n        assert_eq!(opts.output.as_deref(), Some(Path::new(\"out.json\")));\n    }\n\n    #[test]\n    fn rejects_invalid_job() {\n        let err = parse_args(vec![\"--job\".into(), \"unknown\".into()].into_iter()).unwrap_err();\n        assert!(format!(\"{err}\").contains(\"Unknown job\"));\n    }\n\n    #[test]\n    fn reject_zero_limit() {\n        let err = parse_args(vec![\"--limit\".into(), \"0\".into()].into_iter()).unwrap_err();\n        assert!(format!(\"{err}\").contains(\"greater than 0\"));\n    }\n\n    #[test]\n    fn trending_report_uses_snapshot_window_end() {\n        let snapshot = TopicMetricsSnapshot {\n            window_start: 1_000,\n            window_end: 2_000,\n            metrics: Vec::new(),\n        };\n        let weights = ScoreWeightsSummary {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        };\n\n        let report = build_report(Some(snapshot), 25, weights);\n\n        assert_eq!(report.generated_at_ms, 2_000);\n        assert_eq!(report.window_start_ms, Some(1_000));\n        assert_eq!(report.window_end_ms, Some(2_000));\n        assert!(report.collected_at_ms >= report.generated_at_ms);\n        assert_eq!(report.score_weights.posts, 0.6);\n    }\n}\n","traces":[{"line":56,"address":[10986320],"length":1,"stats":{"Line":0}},{"line":57,"address":[10986367],"length":1,"stats":{"Line":0}},{"line":58,"address":[10986445],"length":1,"stats":{"Line":0}},{"line":59,"address":[10986527,10986603],"length":1,"stats":{"Line":0}},{"line":60,"address":[10986666,10986590,10986640],"length":1,"stats":{"Line":0}},{"line":63,"address":[10986816,10986487,10986842],"length":1,"stats":{"Line":0}},{"line":66,"address":[10986992],"length":1,"stats":{"Line":0}},{"line":67,"address":[10987019],"length":1,"stats":{"Line":0}},{"line":68,"address":[10987081,10987358],"length":1,"stats":{"Line":0}},{"line":69,"address":[10987250],"length":1,"stats":{"Line":0}},{"line":71,"address":[10987141],"length":1,"stats":{"Line":0}},{"line":73,"address":[10987391],"length":1,"stats":{"Line":0}},{"line":76,"address":[10987424,10987808],"length":1,"stats":{"Line":0}},{"line":77,"address":[10987431],"length":1,"stats":{"Line":0}},{"line":78,"address":[10987477,10987645],"length":1,"stats":{"Line":0}},{"line":80,"address":[10987625],"length":1,"stats":{"Line":0}},{"line":81,"address":[10987689,10987763],"length":1,"stats":{"Line":0}},{"line":82,"address":[10987709,10987788],"length":1,"stats":{"Line":0}},{"line":86,"address":[10987840,10988318,10988350],"length":1,"stats":{"Line":0}},{"line":87,"address":[10987860],"length":1,"stats":{"Line":0}},{"line":88,"address":[10987889,10987952,10988104,10988332],"length":1,"stats":{"Line":0}},{"line":89,"address":[10988083,10988218],"length":1,"stats":{"Line":0}},{"line":92,"address":[10988368,10989641,10989548],"length":1,"stats":{"Line":0}},{"line":93,"address":[10988399],"length":1,"stats":{"Line":0}},{"line":94,"address":[10988412],"length":1,"stats":{"Line":0}},{"line":95,"address":[10988821,10989634,10988463],"length":1,"stats":{"Line":0}},{"line":96,"address":[10989606,10989664,10989792,10989714,10990304,10989832,10988923,10989079,10988743,10990016],"length":1,"stats":{"Line":0}},{"line":97,"address":[10989972,10990170,10990249,10989889,10989767],"length":1,"stats":{"Line":0}},{"line":98,"address":[10989819,10989996,10989965,10990172,10990048],"length":1,"stats":{"Line":0}},{"line":99,"address":[10990225,10990320,10990342],"length":1,"stats":{"Line":0}},{"line":102,"address":[10989041,10989145,10989297,10989562],"length":1,"stats":{"Line":0}},{"line":103,"address":[10989276,10989411],"length":1,"stats":{"Line":0}},{"line":106,"address":[10990448,10990864],"length":1,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[10995136,10993205,10997061,10991280,10995104,10998960],"length":1,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[10995217,10991361],"length":1,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[10998225,10995659,10994137,10997993,10994369,10991803],"length":1,"stats":{"Line":2}},{"line":130,"address":[10999143,10998999,10998992,10999136,10994353,10998209],"length":1,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[10991919,10995775],"length":1,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":6}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[10997487,10993631,10997352,10993384,10993496,10997240],"length":1,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[10999856,10996843,10992121,10992987,10995977,10996580,11000000,10992724],"length":1,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[10996953,10993097,10996725,10992869,10993004,10996860],"length":1,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[10992194,10992581,10996437,10996050],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[10996090,10992234],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[11000144,11000584],"length":1,"stats":{"Line":2}},{"line":174,"address":[11000187,11000265],"length":1,"stats":{"Line":4}},{"line":175,"address":[11000352,11000281],"length":1,"stats":{"Line":2}},{"line":176,"address":[11000434,11000379,11000324],"length":1,"stats":{"Line":5}},{"line":177,"address":[11000454,11000395],"length":1,"stats":{"Line":2}},{"line":181,"address":[11000608],"length":1,"stats":{"Line":1}},{"line":182,"address":[11000729,11000625],"length":1,"stats":{"Line":1}},{"line":184,"address":[11000848,11000870,11000716],"length":1,"stats":{"Line":0}},{"line":185,"address":[11000708],"length":1,"stats":{"Line":1}},{"line":186,"address":[11000753],"length":1,"stats":{"Line":1}},{"line":188,"address":[11000810],"length":1,"stats":{"Line":1}},{"line":191,"address":[11000976,11001470],"length":1,"stats":{"Line":0}},{"line":192,"address":[11001001],"length":1,"stats":{"Line":0}},{"line":193,"address":[11001062],"length":1,"stats":{"Line":0}},{"line":195,"address":[11001070,11001116],"length":1,"stats":{"Line":0}},{"line":196,"address":[11001141,11001225],"length":1,"stats":{"Line":0}},{"line":197,"address":[11001278],"length":1,"stats":{"Line":0}},{"line":200,"address":[11001393,11001508],"length":1,"stats":{"Line":0}},{"line":203,"address":[11001584],"length":1,"stats":{"Line":0}},{"line":204,"address":[11001600],"length":1,"stats":{"Line":0}},{"line":206,"address":[11001615],"length":1,"stats":{"Line":0}},{"line":207,"address":[11001624],"length":1,"stats":{"Line":0}},{"line":208,"address":[11001633],"length":1,"stats":{"Line":0}},{"line":212,"address":[11001680],"length":1,"stats":{"Line":0}},{"line":217,"address":[11002632,11002322,11001939,11002117,11002446,11002896],"length":1,"stats":{"Line":0}},{"line":218,"address":[11002147,11002370,11002000,11002207,11002090],"length":1,"stats":{"Line":0}},{"line":219,"address":[11002430,11003744,11003766,11002616],"length":1,"stats":{"Line":0}},{"line":220,"address":[11002563,11002712],"length":1,"stats":{"Line":0}},{"line":221,"address":[11003138,11003478,11003030,11002734,11002852,11002715],"length":1,"stats":{"Line":0}},{"line":222,"address":[11002730],"length":1,"stats":{"Line":0}},{"line":223,"address":[11003078,11002018,11002868,11002821,11002924],"length":1,"stats":{"Line":0}},{"line":226,"address":[11003339,11003572],"length":1,"stats":{"Line":0}},{"line":229,"address":[11003872,11004892,11005196],"length":1,"stats":{"Line":1}},{"line":234,"address":[11003912,11004024],"length":1,"stats":{"Line":2}},{"line":236,"address":[11005145,11004032],"length":1,"stats":{"Line":1}},{"line":237,"address":[11004117,11004253],"length":1,"stats":{"Line":2}},{"line":239,"address":[11004112],"length":1,"stats":{"Line":1}},{"line":241,"address":[11004291],"length":1,"stats":{"Line":1}},{"line":242,"address":[11004349],"length":1,"stats":{"Line":1}},{"line":245,"address":[11004383],"length":1,"stats":{"Line":1}},{"line":248,"address":[11004403],"length":1,"stats":{"Line":1}},{"line":250,"address":[11004498],"length":1,"stats":{"Line":1}},{"line":251,"address":[11004523],"length":1,"stats":{"Line":1}},{"line":252,"address":[11004551],"length":1,"stats":{"Line":1}},{"line":253,"address":[11004571],"length":1,"stats":{"Line":1}},{"line":268,"address":[11004185],"length":1,"stats":{"Line":0}},{"line":273,"address":[11005232],"length":1,"stats":{"Line":1}},{"line":274,"address":[11005236],"length":1,"stats":{"Line":1}}],"covered":54,"coverable":122},{"path":["/","app","kukuri-tauri","src-tauri","src","contract_testing.rs"],"content":"use crate::domain::entities::event::Event;\n\npub fn validate_nip10_tags(tags: Vec<Vec<String>>) -> Result<(), String> {\n    let mut event = Event::new(1, String::new(), \"a\".repeat(64));\n    event.id = \"f\".repeat(64);\n    event.sig = \"f\".repeat(128);\n    event.created_at = chrono::Utc::now();\n    event.tags = tags;\n    event.validate_nip10_19().map_err(|err| err.message)\n}\n","traces":[{"line":3,"address":[22225856,22226695,22226726],"length":1,"stats":{"Line":1}},{"line":4,"address":[22300470,22300550,22301296],"length":1,"stats":{"Line":2}},{"line":5,"address":[16480466,16480393],"length":1,"stats":{"Line":2}},{"line":6,"address":[22307787],"length":1,"stats":{"Line":1}},{"line":7,"address":[22226425],"length":1,"stats":{"Line":1}},{"line":8,"address":[22307999],"length":1,"stats":{"Line":1}},{"line":9,"address":[22308138,22308288,22308291],"length":1,"stats":{"Line":3}}],"covered":7,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","constants.rs"],"content":"pub const TOPIC_NAMESPACE: &str = \"kukuri:tauri:\";\npub const DEFAULT_PUBLIC_TOPIC_ID: &str =\n    \"kukuri:tauri:731051a1c14a65ee3735ee4ab3b97198cae1633700f9b87fcde205e64c5a56b0\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","account","mod.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// SecureStorage に保存されるアカウント情報を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccountMetadata {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n    pub last_used: DateTime<Utc>,\n}\n\nimpl AccountMetadata {\n    pub fn mark_used(&mut self, timestamp: DateTime<Utc>) {\n        self.last_used = timestamp;\n    }\n}\n\n/// SecureStorage に保存されるアカウント一覧と現在アカウントのメタデータ。\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct AccountsMetadata {\n    pub accounts: HashMap<String, AccountMetadata>,\n    pub current_npub: Option<String>,\n}\n\n/// アカウント登録時に必要な情報。\n#[derive(Debug, Clone)]\npub struct AccountRegistration {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl AccountRegistration {\n    pub fn into_metadata(self) -> (AccountMetadata, String) {\n        let AccountRegistration {\n            npub,\n            nsec,\n            pubkey,\n            name,\n            display_name,\n            picture,\n        } = self;\n\n        let metadata = AccountMetadata {\n            npub: npub.clone(),\n            pubkey,\n            name,\n            display_name,\n            picture,\n            last_used: Utc::now(),\n        };\n\n        (metadata, nsec)\n    }\n}\n\n/// 現在のアカウントのメタデータと秘密鍵。\n#[derive(Debug, Clone)]\npub struct CurrentAccountSecret {\n    pub metadata: AccountMetadata,\n    pub nsec: String,\n}\n","traces":[{"line":17,"address":[21355056],"length":1,"stats":{"Line":0}},{"line":18,"address":[19288197],"length":1,"stats":{"Line":0}},{"line":41,"address":[21356022,21356251,21355088],"length":1,"stats":{"Line":0}},{"line":42,"address":[15609414],"length":1,"stats":{"Line":0}},{"line":43,"address":[21471782],"length":1,"stats":{"Line":0}},{"line":44,"address":[21429751],"length":1,"stats":{"Line":0}},{"line":45,"address":[21355177],"length":1,"stats":{"Line":0}},{"line":46,"address":[21436723],"length":1,"stats":{"Line":0}},{"line":47,"address":[19288371],"length":1,"stats":{"Line":0}},{"line":48,"address":[21467971],"length":1,"stats":{"Line":0}},{"line":52,"address":[21355302],"length":1,"stats":{"Line":0}},{"line":57,"address":[21473809],"length":1,"stats":{"Line":0}},{"line":60,"address":[21568931],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","bookmark.rs"],"content":"use crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// ユーザーが投稿をブックマークした履歴を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Bookmark {\n    id: BookmarkId,\n    user_pubkey: PublicKey,\n    post_id: EventId,\n    created_at: DateTime<Utc>,\n}\n\nimpl Bookmark {\n    /// 現在時刻で新しいブックマークを作成する。\n    pub fn new(user_pubkey: PublicKey, post_id: EventId) -> Self {\n        Self {\n            id: BookmarkId::random(),\n            user_pubkey,\n            post_id,\n            created_at: Utc::now(),\n        }\n    }\n\n    /// 既存レコードからブックマークを復元する。\n    pub fn from_parts(\n        id: BookmarkId,\n        user_pubkey: PublicKey,\n        post_id: EventId,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            user_pubkey,\n            post_id,\n            created_at,\n        }\n    }\n\n    pub fn id(&self) -> &BookmarkId {\n        &self.id\n    }\n\n    pub fn user_pubkey(&self) -> &PublicKey {\n        &self.user_pubkey\n    }\n\n    pub fn post_id(&self) -> &EventId {\n        &self.post_id\n    }\n\n    pub fn created_at(&self) -> DateTime<Utc> {\n        self.created_at\n    }\n}\n","traces":[{"line":16,"address":[13509110,13508688,13509038],"length":1,"stats":{"Line":1}},{"line":18,"address":[13611595],"length":1,"stats":{"Line":1}},{"line":21,"address":[13576624],"length":1,"stats":{"Line":1}},{"line":26,"address":[13708464],"length":1,"stats":{"Line":1}},{"line":40,"address":[13612128],"length":1,"stats":{"Line":1}},{"line":44,"address":[13612144],"length":1,"stats":{"Line":1}},{"line":45,"address":[13608216],"length":1,"stats":{"Line":1}},{"line":48,"address":[20519552],"length":1,"stats":{"Line":1}},{"line":49,"address":[13502312],"length":1,"stats":{"Line":1}},{"line":52,"address":[13570128],"length":1,"stats":{"Line":1}},{"line":53,"address":[13612184],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","direct_message.rs"],"content":"use chrono::{DateTime, TimeZone, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::str::FromStr;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum MessageDirection {\n    Outbound,\n    Inbound,\n}\n\nimpl MessageDirection {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            MessageDirection::Outbound => \"outbound\",\n            MessageDirection::Inbound => \"inbound\",\n        }\n    }\n}\n\nimpl FromStr for MessageDirection {\n    type Err = ();\n\n    fn from_str(value: &str) -> Result<Self, Self::Err> {\n        match value {\n            \"outbound\" => Ok(MessageDirection::Outbound),\n            \"inbound\" => Ok(MessageDirection::Inbound),\n            _ => Err(()),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct NewDirectMessage {\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub payload_cipher_base64: String,\n    pub created_at: DateTime<Utc>,\n    pub delivered: bool,\n    pub direction: MessageDirection,\n}\n\n#[derive(Debug, Clone)]\npub struct DirectMessage {\n    pub id: i64,\n    pub owner_npub: String,\n    pub conversation_npub: String,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub payload_cipher_base64: String,\n    pub created_at: DateTime<Utc>,\n    pub delivered: bool,\n    pub direction: MessageDirection,\n    pub decrypted_content: Option<String>,\n}\n\nimpl DirectMessage {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: i64,\n        owner_npub: String,\n        conversation_npub: String,\n        sender_npub: String,\n        recipient_npub: String,\n        event_id: Option<String>,\n        client_message_id: Option<String>,\n        payload_cipher_base64: String,\n        created_at_millis: i64,\n        delivered: bool,\n        direction: MessageDirection,\n    ) -> Self {\n        let created_at = match Utc.timestamp_millis_opt(created_at_millis) {\n            chrono::LocalResult::Single(ts) => ts,\n            _ => Utc\n                .timestamp_millis_opt(0)\n                .single()\n                .unwrap_or_else(Utc::now),\n        };\n\n        Self {\n            id,\n            owner_npub,\n            conversation_npub,\n            sender_npub,\n            recipient_npub,\n            event_id,\n            client_message_id,\n            payload_cipher_base64,\n            created_at,\n            delivered,\n            direction,\n            decrypted_content: None,\n        }\n    }\n\n    pub fn with_decrypted_content(mut self, content: String) -> Self {\n        self.decrypted_content = Some(content);\n        self\n    }\n\n    pub fn mark_delivered(mut self, delivered: bool) -> Self {\n        self.delivered = delivered;\n        self\n    }\n\n    pub fn cursor(&self) -> String {\n        let event_part = self.event_id.clone().unwrap_or_default();\n        format!(\"{}:{}\", self.created_at.timestamp_millis(), event_part)\n    }\n\n    pub fn created_at_millis(&self) -> i64 {\n        self.created_at.timestamp_millis()\n    }\n\n    pub fn counterparty_npub(&self) -> &str {\n        &self.conversation_npub\n    }\n}\n","traces":[{"line":13,"address":[16485696],"length":1,"stats":{"Line":1}},{"line":14,"address":[16478725],"length":1,"stats":{"Line":1}},{"line":15,"address":[20519618],"length":1,"stats":{"Line":0}},{"line":16,"address":[16553497],"length":1,"stats":{"Line":1}},{"line":24,"address":[16485776],"length":1,"stats":{"Line":1}},{"line":26,"address":[16685111,16685164],"length":1,"stats":{"Line":1}},{"line":27,"address":[16590357,16590404],"length":1,"stats":{"Line":2}},{"line":28,"address":[16546701],"length":1,"stats":{"Line":0}},{"line":65,"address":[16589976,16588784,16589872],"length":1,"stats":{"Line":2}},{"line":78,"address":[16486048,16486110],"length":1,"stats":{"Line":4}},{"line":79,"address":[20520024],"length":1,"stats":{"Line":2}},{"line":80,"address":[16686241,16685482],"length":1,"stats":{"Line":0}},{"line":102,"address":[16555064,16554880],"length":1,"stats":{"Line":1}},{"line":103,"address":[16554907,16555008],"length":1,"stats":{"Line":2}},{"line":104,"address":[16590164],"length":1,"stats":{"Line":1}},{"line":107,"address":[16473568],"length":1,"stats":{"Line":0}},{"line":108,"address":[24248567],"length":1,"stats":{"Line":0}},{"line":109,"address":[16548191],"length":1,"stats":{"Line":0}},{"line":112,"address":[16686704,16687032],"length":1,"stats":{"Line":0}},{"line":113,"address":[16487421],"length":1,"stats":{"Line":0}},{"line":114,"address":[20521425,20521356],"length":1,"stats":{"Line":0}},{"line":117,"address":[20521632],"length":1,"stats":{"Line":1}},{"line":118,"address":[16592277],"length":1,"stats":{"Line":1}},{"line":121,"address":[16555536],"length":1,"stats":{"Line":1}},{"line":122,"address":[24248997],"length":1,"stats":{"Line":1}}],"covered":16,"coverable":25},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","kind.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]\n#[repr(u32)]\npub enum EventKind {\n    Metadata = 0,\n    TextNote = 1,\n    RecommendRelay = 2,\n    Contacts = 3,\n    EncryptedDirectMessage = 4,\n    EventDeletion = 5,\n    Repost = 6,\n    Reaction = 7,\n    BadgeAward = 8,\n    ChannelCreation = 40,\n    ChannelMetadata = 41,\n    ChannelMessage = 42,\n    ChannelHideMessage = 43,\n    ChannelMuteUser = 44,\n    Custom(u32),\n}\n\nimpl From<u32> for EventKind {\n    fn from(value: u32) -> Self {\n        match value {\n            0 => EventKind::Metadata,\n            1 => EventKind::TextNote,\n            2 => EventKind::RecommendRelay,\n            3 => EventKind::Contacts,\n            4 => EventKind::EncryptedDirectMessage,\n            5 => EventKind::EventDeletion,\n            6 => EventKind::Repost,\n            7 => EventKind::Reaction,\n            8 => EventKind::BadgeAward,\n            40 => EventKind::ChannelCreation,\n            41 => EventKind::ChannelMetadata,\n            42 => EventKind::ChannelMessage,\n            43 => EventKind::ChannelHideMessage,\n            44 => EventKind::ChannelMuteUser,\n            v => EventKind::Custom(v),\n        }\n    }\n}\n\nimpl From<EventKind> for u32 {\n    fn from(value: EventKind) -> Self {\n        match value {\n            EventKind::Metadata => 0,\n            EventKind::TextNote => 1,\n            EventKind::RecommendRelay => 2,\n            EventKind::Contacts => 3,\n            EventKind::EncryptedDirectMessage => 4,\n            EventKind::EventDeletion => 5,\n            EventKind::Repost => 6,\n            EventKind::Reaction => 7,\n            EventKind::BadgeAward => 8,\n            EventKind::ChannelCreation => 40,\n            EventKind::ChannelMetadata => 41,\n            EventKind::ChannelMessage => 42,\n            EventKind::ChannelHideMessage => 43,\n            EventKind::ChannelMuteUser => 44,\n            EventKind::Custom(v) => v,\n        }\n    }\n}\n\nimpl EventKind {\n    pub fn from_u32(value: u32) -> Option<Self> {\n        Some(value.into())\n    }\n\n    pub fn as_u32(self) -> u32 {\n        self.into()\n    }\n}\n","traces":[{"line":24,"address":[15229136],"length":1,"stats":{"Line":0}},{"line":25,"address":[15233080],"length":1,"stats":{"Line":0}},{"line":26,"address":[15229198],"length":1,"stats":{"Line":0}},{"line":27,"address":[15198027],"length":1,"stats":{"Line":0}},{"line":28,"address":[15123301],"length":1,"stats":{"Line":0}},{"line":29,"address":[15116527],"length":1,"stats":{"Line":0}},{"line":30,"address":[15198057],"length":1,"stats":{"Line":0}},{"line":31,"address":[15229251],"length":1,"stats":{"Line":0}},{"line":32,"address":[15123341],"length":1,"stats":{"Line":0}},{"line":33,"address":[22891543],"length":1,"stats":{"Line":0}},{"line":34,"address":[15329649],"length":1,"stats":{"Line":0}},{"line":35,"address":[16437099],"length":1,"stats":{"Line":0}},{"line":36,"address":[15329669],"length":1,"stats":{"Line":0}},{"line":37,"address":[22891583],"length":1,"stats":{"Line":0}},{"line":38,"address":[16437129],"length":1,"stats":{"Line":0}},{"line":39,"address":[15229331],"length":1,"stats":{"Line":0}},{"line":40,"address":[15130237],"length":1,"stats":{"Line":0}},{"line":46,"address":[15130416],"length":1,"stats":{"Line":1}},{"line":47,"address":[22891640],"length":1,"stats":{"Line":1}},{"line":48,"address":[15234984],"length":1,"stats":{"Line":0}},{"line":49,"address":[15116709],"length":1,"stats":{"Line":1}},{"line":50,"address":[15130482],"length":1,"stats":{"Line":0}},{"line":51,"address":[15233372],"length":1,"stats":{"Line":0}},{"line":52,"address":[15329814],"length":1,"stats":{"Line":0}},{"line":53,"address":[15229456],"length":1,"stats":{"Line":0}},{"line":54,"address":[15123546],"length":1,"stats":{"Line":0}},{"line":55,"address":[15198292],"length":1,"stats":{"Line":0}},{"line":56,"address":[15116782],"length":1,"stats":{"Line":0}},{"line":57,"address":[15130552],"length":1,"stats":{"Line":0}},{"line":58,"address":[15235090],"length":1,"stats":{"Line":0}},{"line":59,"address":[15233452],"length":1,"stats":{"Line":0}},{"line":60,"address":[15123606],"length":1,"stats":{"Line":0}},{"line":61,"address":[22891808],"length":1,"stats":{"Line":0}},{"line":62,"address":[15198362],"length":1,"stats":{"Line":0}},{"line":68,"address":[15229568],"length":1,"stats":{"Line":0}},{"line":69,"address":[15116872],"length":1,"stats":{"Line":0}},{"line":72,"address":[16437424],"length":1,"stats":{"Line":0}},{"line":73,"address":[15191512],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","mod.rs"],"content":"mod kind;\nmod model;\npub mod validation;\n\npub use kind::EventKind;\npub use model::Event;\npub use validation::{\n    EventValidationError, KIND30078_KIND, KIND30078_MAX_ATTACHMENTS, ValidationResult,\n};\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","model.rs"],"content":"use crate::domain::value_objects::EventId;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Event {\n    pub id: String,\n    pub pubkey: String,\n    pub created_at: DateTime<Utc>,\n    pub kind: u32,\n    pub tags: Vec<Vec<String>>,\n    pub content: String,\n    pub sig: String,\n}\n\nimpl Event {\n    pub fn new(kind: u32, content: String, pubkey: String) -> Self {\n        Self {\n            id: String::new(),\n            pubkey,\n            created_at: Utc::now(),\n            kind,\n            tags: Vec::new(),\n            content,\n            sig: String::new(),\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<Vec<String>>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn add_tag(&mut self, tag: Vec<String>) {\n        self.tags.push(tag);\n    }\n\n    pub fn add_p_tag(&mut self, pubkey: String) {\n        self.tags.push(vec![\"p\".to_string(), pubkey]);\n    }\n\n    pub fn add_e_tag(&mut self, event_id: String) {\n        self.tags.push(vec![\"e\".to_string(), event_id]);\n    }\n\n    pub fn add_t_tag(&mut self, hashtag: String) {\n        self.tags.push(vec![\"t\".to_string(), hashtag]);\n    }\n\n    pub fn get_referenced_event_ids(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"e\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_referenced_pubkeys(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"p\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_hashtags(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"t\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn new_with_id(\n        id: EventId,\n        pubkey: String,\n        content: String,\n        kind: u32,\n        tags: Vec<Vec<String>>,\n        created_at: DateTime<Utc>,\n        sig: String,\n    ) -> Self {\n        Self {\n            id: id.to_hex(),\n            pubkey,\n            created_at,\n            kind,\n            tags,\n            content,\n            sig,\n        }\n    }\n}\n","traces":[{"line":17,"address":[25732684,25732610,25732096],"length":1,"stats":{"Line":2}},{"line":19,"address":[18866213],"length":1,"stats":{"Line":2}},{"line":21,"address":[18976183],"length":1,"stats":{"Line":2}},{"line":23,"address":[18972304],"length":1,"stats":{"Line":2}},{"line":25,"address":[13113964],"length":1,"stats":{"Line":2}},{"line":29,"address":[18934765,18934608],"length":1,"stats":{"Line":1}},{"line":30,"address":[18941568,18941650],"length":1,"stats":{"Line":2}},{"line":31,"address":[18860153],"length":1,"stats":{"Line":1}},{"line":34,"address":[13114496],"length":1,"stats":{"Line":0}},{"line":35,"address":[18873957],"length":1,"stats":{"Line":0}},{"line":38,"address":[18973328,18973342,18972928],"length":1,"stats":{"Line":0}},{"line":39,"address":[19073400,19073705,19073316],"length":1,"stats":{"Line":0}},{"line":42,"address":[19073744,19074144,19074158],"length":1,"stats":{"Line":0}},{"line":43,"address":[18942212,18942601,18942296],"length":1,"stats":{"Line":0}},{"line":46,"address":[18936126,18936112,18935712],"length":1,"stats":{"Line":0}},{"line":47,"address":[18979512,18979817,18979428],"length":1,"stats":{"Line":0}},{"line":50,"address":[18943088],"length":1,"stats":{"Line":0}},{"line":51,"address":[18943120],"length":1,"stats":{"Line":0}},{"line":53,"address":[19074771,19074752],"length":1,"stats":{"Line":0}},{"line":54,"address":[25734496,25734531],"length":1,"stats":{"Line":0}},{"line":58,"address":[18868656],"length":1,"stats":{"Line":0}},{"line":59,"address":[18980192],"length":1,"stats":{"Line":0}},{"line":61,"address":[18943504,18943523],"length":1,"stats":{"Line":0}},{"line":62,"address":[18980384,18980419],"length":1,"stats":{"Line":0}},{"line":66,"address":[18974880],"length":1,"stats":{"Line":0}},{"line":67,"address":[18943728],"length":1,"stats":{"Line":0}},{"line":69,"address":[18876067,18876048],"length":1,"stats":{"Line":0}},{"line":70,"address":[18862400,18862435],"length":1,"stats":{"Line":0}},{"line":74,"address":[19076121,19076049,19075552],"length":1,"stats":{"Line":2}},{"line":84,"address":[18944075],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":30},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","kind30078.rs"],"content":"use crate::domain::entities::event::{Event, KIND30078_KIND, KIND30078_MAX_ATTACHMENTS};\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Utc;\nuse serde_json::json;\nuse sha2::{Digest, Sha256};\n\nfn build_kind30078_event(\n    pubkey: String,\n    tags: Vec<Vec<String>>,\n    content: serde_json::Value,\n) -> Event {\n    let created_at = Utc::now();\n    let kind = KIND30078_KIND;\n    let content_str = content.to_string();\n    let tags_for_event = tags.clone();\n    let id_payload = json!([0, pubkey, created_at.timestamp(), kind, tags, content_str]);\n    let serialized = serde_json::to_vec(&id_payload).expect(\"serialize kind30078 event\");\n    let id = format!(\"{:x}\", Sha256::digest(&serialized));\n    Event {\n        id,\n        pubkey,\n        created_at,\n        kind,\n        tags: tags_for_event,\n        content: content_str,\n        sig: \"f\".repeat(128),\n    }\n}\n\nfn base_kind30078_tags(pubkey: &str, slug: &str, revision: &str) -> Vec<Vec<String>> {\n    vec![\n        vec![\n            \"d\".into(),\n            format!(\"kukuri:topic:{}:post:{}\", slug, revision),\n        ],\n        vec![\"k\".into(), \"topic-post\".into()],\n        vec![\"t\".into(), format!(\"topic:{}\", slug)],\n        vec![\n            \"a\".into(),\n            format!(\"30078:{}:kukuri:topic:{}:post:{}\", pubkey, slug, revision),\n        ],\n    ]\n}\n\n#[test]\nfn test_validate_kind30078_ok() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [\"iroh://attachment\"],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    assert!(event.validate_kind30078().is_ok());\n}\n\n#[test]\nfn test_validate_kind30078_missing_d_tag() {\n    let mut tags = base_kind30078_tags(&\"f\".repeat(64), \"slug\", &\"A\".repeat(26));\n    tags.retain(|tag| tag.first().map(|s| s != \"d\").unwrap_or(true));\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(\"f\".repeat(64), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMissing);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_t_value() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let mut tags = base_kind30078_tags(&pubkey, slug, &revision);\n    if let Some(t_tag) = tags\n        .iter_mut()\n        .find(|tag| tag.first().map(|s| s == \"t\").unwrap_or(false))\n    {\n        t_tag[1] = \"topic:wrong\".into();\n    }\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMismatch);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_attachment() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [\"invalid://attachment\"],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSchema);\n}\n\n#[test]\nfn test_validate_kind30078_missing_a_tag() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let mut tags = base_kind30078_tags(&pubkey, slug, &revision);\n    tags.retain(|tag| tag.first().map(|s| s != \"a\").unwrap_or(true));\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078TagMissing);\n}\n\n#[test]\nfn test_validate_kind30078_attachment_overflow() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let attachments: Vec<String> = (0..=KIND30078_MAX_ATTACHMENTS)\n        .map(|i| format!(\"iroh://attachment/{i}\"))\n        .collect();\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": attachments,\n        \"metadata\": {\"app_version\": \"1.0.0\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSize);\n}\n\n#[test]\nfn test_validate_kind30078_invalid_semver() {\n    let slug = \"sample-topic\";\n    let revision = \"A\".repeat(26);\n    let pubkey = \"f\".repeat(64);\n    let tags = base_kind30078_tags(&pubkey, slug, &revision);\n    let content = json!({\n        \"body\": \"hello\",\n        \"attachments\": [],\n        \"metadata\": {\"app_version\": \"not-a-version\", \"edited\": false}\n    });\n    let event = build_kind30078_event(pubkey.clone(), tags, content);\n    let err = event.validate_kind30078().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Kind30078ContentSchema);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","mod.rs"],"content":"mod kind30078;\nmod nip01;\nmod nip10_19;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","nip01.rs"],"content":"use crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Duration;\nuse nostr_sdk::prelude::*;\nuse serde_json::json;\nuse sha2::{Digest, Sha256};\n\n#[tokio::test]\nasync fn test_validate_nip01_ok() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"hello nip01\")\n        .sign_with_keys(&keys)\n        .unwrap();\n\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_secs() as i64, 0)\n            .unwrap();\n\n    let dom = Event {\n        id: nostr_ev.id.to_string(),\n        pubkey: nostr_ev.pubkey.to_string(),\n        created_at,\n        kind: nostr_ev.kind.as_u16() as u32,\n        tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: nostr_ev.content.clone(),\n        sig: nostr_ev.sig.to_string(),\n    };\n\n    assert!(dom.validate_nip01().is_ok());\n}\n\n#[tokio::test]\nasync fn test_validate_nip01_bad_id() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"oops\")\n        .sign_with_keys(&keys)\n        .unwrap();\n\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_secs() as i64, 0)\n            .unwrap();\n\n    let mut dom = Event {\n        id: nostr_ev.id.to_string(),\n        pubkey: nostr_ev.pubkey.to_string(),\n        created_at,\n        kind: nostr_ev.kind.as_u16() as u32,\n        tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: nostr_ev.content.clone(),\n        sig: nostr_ev.sig.to_string(),\n    };\n    dom.content = \"tampered\".into();\n    let err = dom.validate_nip01().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Nip01Integrity);\n}\n\nfn build_event_with_data(\n    pubkey: &str,\n    kind: u32,\n    tags: Vec<Vec<String>>,\n    content: &str,\n    created_at: chrono::DateTime<chrono::Utc>,\n) -> Event {\n    let id_payload = json!([0, pubkey, created_at.timestamp(), kind, tags, content]);\n    let serialized = serde_json::to_vec(&id_payload).expect(\"serialize event\");\n    let id = format!(\"{:x}\", Sha256::digest(&serialized));\n    Event {\n        id,\n        pubkey: pubkey.to_string(),\n        created_at,\n        kind,\n        tags,\n        content: content.to_string(),\n        sig: \"f\".repeat(128),\n    }\n}\n\n#[test]\nfn test_validate_nip01_rejects_timestamp_drift() {\n    let created_at = chrono::Utc::now() - Duration::hours(2);\n    let event = build_event_with_data(&\"f\".repeat(64), 1, Vec::new(), \"time drift\", created_at);\n    let err = event.validate_nip01().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::TimestampOutOfRange);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","tests","nip10_19.rs"],"content":"use crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse bech32::{Bech32, Hrp};\nuse nostr_sdk::prelude::*;\n\nfn dummy_event_with_tags(tags: Vec<Vec<String>>) -> Event {\n    Event {\n        id: \"0\".repeat(64),\n        pubkey: \"f\".repeat(64),\n        created_at: chrono::Utc::now(),\n        kind: 1,\n        tags,\n        content: String::new(),\n        sig: \"f\".repeat(128),\n    }\n}\n\nfn encode_bech32(hrp: &str, bytes: &[u8]) -> String {\n    let hrp = Hrp::parse(hrp).expect(\"valid hrp\");\n    bech32::encode::<Bech32>(hrp, bytes).expect(\"encode\")\n}\n\n#[test]\nfn test_validate_nip10_19_ok_with_bech32_refs() {\n    let keys = Keys::generate();\n    let npub = keys.public_key().to_bech32().unwrap();\n\n    let nostr_ev = EventBuilder::text_note(\"x\").sign_with_keys(&keys).unwrap();\n    let note = nostr_ev.id.to_bech32().unwrap();\n\n    let e_root = vec![\"e\".into(), note.clone(), String::new(), \"root\".into()];\n    let e_reply = vec![\"e\".into(), note, String::new(), \"reply\".into()];\n    let p_tag = vec![\"p\".into(), npub];\n    let ev = dummy_event_with_tags(vec![e_root, e_reply, p_tag]);\n    assert!(ev.validate_nip10_19().is_ok());\n}\n\n#[test]\nfn test_validate_nip10_19_rejects_invalid_marker_and_pk() {\n    let e_tag = vec![\"e\".into(), \"0\".repeat(64), String::new(), \"bad\".into()];\n    let p_tag = vec![\"p\".into(), \"zzz\".into()];\n    let ev = dummy_event_with_tags(vec![e_tag, p_tag]);\n    let err = ev.validate_nip10_19().unwrap_err();\n    assert_eq!(err.kind, ValidationFailureKind::Nip10TagStructure);\n}\n\n#[test]\nfn test_validate_nip10_reply_without_root_ok() {\n    let e_tag_reply = vec![\"e\".into(), \"0\".repeat(64), String::new(), \"reply\".into()];\n    let ev = dummy_event_with_tags(vec![e_tag_reply]);\n    assert!(ev.validate_nip10_19().is_ok());\n}\n\n#[test]\nfn test_nprofile_tlv_multiple_relays_ok() {\n    let keys = Keys::generate();\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&keys.public_key().to_bytes());\n    for relay in [\"wss://relay.one\", \"wss://relay.two\"] {\n        let relay_bytes = relay.as_bytes();\n        bytes.push(1);\n        bytes.push(relay_bytes.len() as u8);\n        bytes.extend_from_slice(relay_bytes);\n    }\n    let encoded = encode_bech32(\"nprofile\", &bytes);\n    assert!(Event::validate_nprofile_tlv(&encoded).is_ok());\n}\n\n#[test]\nfn test_nprofile_tlv_rejects_invalid_relay_scheme() {\n    let keys = Keys::generate();\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&keys.public_key().to_bytes());\n    let relay_bytes = b\"https://relay.invalid\";\n    bytes.push(1);\n    bytes.push(relay_bytes.len() as u8);\n    bytes.extend_from_slice(relay_bytes);\n    let encoded = encode_bech32(\"nprofile\", &bytes);\n    assert!(Event::validate_nprofile_tlv(&encoded).is_err());\n}\n\n#[test]\nfn test_nevent_tlv_with_optional_author_and_kind() {\n    let keys = Keys::generate();\n    let nostr_ev = EventBuilder::text_note(\"tlv\")\n        .sign_with_keys(&keys)\n        .expect(\"sign\");\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&nostr_ev.id.to_bytes());\n    let relay_bytes = b\"wss://relay.example\";\n    bytes.push(1);\n    bytes.push(relay_bytes.len() as u8);\n    bytes.extend_from_slice(relay_bytes);\n    bytes.push(2);\n    bytes.push(32);\n    bytes.extend_from_slice(&nostr_ev.pubkey.to_bytes());\n    let kind_bytes = (nostr_ev.kind.as_u16() as u32).to_be_bytes();\n    bytes.push(3);\n    bytes.push(kind_bytes.len() as u8);\n    bytes.extend_from_slice(&kind_bytes);\n    let encoded = encode_bech32(\"nevent\", &bytes);\n    assert!(Event::validate_nevent_tlv(&encoded).is_ok());\n}\n\n#[test]\nfn test_nevent_tlv_rejects_invalid_author_length() {\n    let mut bytes = Vec::new();\n    bytes.push(0);\n    bytes.push(32);\n    bytes.extend_from_slice(&[0u8; 32]);\n    bytes.push(2);\n    bytes.push(31);\n    bytes.extend_from_slice(&[0u8; 31]);\n    let encoded = encode_bech32(\"nevent\", &bytes);\n    assert!(Event::validate_nevent_tlv(&encoded).is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","errors.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse std::fmt;\n\npub type ValidationResult<T> = Result<T, EventValidationError>;\n\npub(super) const MAX_EVENT_TAGS: usize = 512;\npub(super) const MAX_EVENT_CONTENT_BYTES: usize = 1_048_576;\npub(super) const TIMESTAMP_DRIFT_SECS: i64 = 600;\n\n#[derive(Debug, Clone)]\npub struct EventValidationError {\n    pub kind: ValidationFailureKind,\n    pub message: String,\n}\n\nimpl EventValidationError {\n    pub fn new(kind: ValidationFailureKind, message: impl Into<String>) -> Self {\n        Self {\n            kind,\n            message: message.into(),\n        }\n    }\n}\n\nimpl fmt::Display for EventValidationError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}: {}\", self.kind, self.message)\n    }\n}\n\nimpl std::error::Error for EventValidationError {}\n","traces":[{"line":17,"address":[22947760,22947872],"length":1,"stats":{"Line":4}},{"line":20,"address":[24705399,24705506],"length":1,"stats":{"Line":4}},{"line":26,"address":[22948000],"length":1,"stats":{"Line":0}},{"line":27,"address":[23059543],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","kind30078.rs"],"content":"use super::errors::{EventValidationError, MAX_EVENT_CONTENT_BYTES, ValidationResult};\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse semver::Version;\nuse serde::Deserialize;\n\npub const KIND30078_KIND: u32 = 30_078;\npub const KIND30078_MAX_ATTACHMENTS: usize = 16;\n\n#[derive(Debug, Deserialize)]\nstruct Kind30078Content {\n    body: String,\n    #[serde(default)]\n    attachments: Vec<String>,\n    metadata: Kind30078Metadata,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Kind30078Metadata {\n    app_version: String,\n    edited: bool,\n}\n\nimpl Event {\n    /// kind:30078 (kukuri topic post PRE) のタグ・content検証\n    pub fn validate_kind30078(&self) -> ValidationResult<()> {\n        if self.kind != KIND30078_KIND {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::UnsupportedKind,\n                format!(\n                    \"kind mismatch for kind30078 (expected {}, got {})\",\n                    KIND30078_KIND, self.kind\n                ),\n            ));\n        }\n\n        let mut identifier: Option<(String, String)> = None;\n        let mut has_k = false;\n        let mut topic_tag: Option<String> = None;\n        let mut address_tag: Option<String> = None;\n\n        for tag in &self.tags {\n            if tag.is_empty() {\n                continue;\n            }\n            match tag[0].as_str() {\n                \"d\" => {\n                    if identifier.is_some() {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            \"multiple d tags detected for kind30078\",\n                        ));\n                    }\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"d tag must be [\\\"d\\\", <identifier>] (len={})\", tag.len()),\n                        ));\n                    }\n                    let (slug, revision) = parse_kind30078_identifier(&tag[1])?;\n                    ensure_slug_valid(&slug)?;\n                    ensure_revision_valid(&revision)?;\n                    identifier = Some((slug, revision));\n                }\n                \"k\" => {\n                    if has_k {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            \"multiple k tags detected for kind30078\",\n                        ));\n                    }\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"k tag must be [\\\"k\\\", \\\"topic-post\\\"] (len={})\", tag.len()),\n                        ));\n                    }\n                    if tag[1] != \"topic-post\" {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"k tag must equal \\\"topic-post\\\" (value={})\", tag[1]),\n                        ));\n                    }\n                    has_k = true;\n                }\n                \"t\" => {\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\n                                \"t tag must be [\\\"t\\\", \\\"topic:<slug>\\\"] (len={})\",\n                                tag.len()\n                            ),\n                        ));\n                    }\n                    topic_tag = Some(tag[1].clone());\n                }\n                \"a\" => {\n                    if tag.len() != 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Kind30078TagMismatch,\n                            format!(\"a tag must be [\\\"a\\\", <address>] (len={})\", tag.len()),\n                        ));\n                    }\n                    address_tag = Some(tag[1].clone());\n                }\n                _ => {}\n            }\n        }\n\n        let (slug, revision) = identifier.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing d tag for kind30078 event\",\n            )\n        })?;\n\n        if !has_k {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing k tag for kind30078 event\",\n            ));\n        }\n\n        let topic_value = topic_tag.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing t tag for kind30078 event\",\n            )\n        })?;\n\n        let expected_topic = format!(\"topic:{slug}\");\n        if topic_value != expected_topic {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMismatch,\n                format!(\"t tag must equal \\\"{expected_topic}\\\" (value={topic_value})\"),\n            ));\n        }\n\n        let address_value = address_tag.ok_or_else(|| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMissing,\n                \"missing a tag for kind30078 event\",\n            )\n        })?;\n\n        let expected_address = format!(\n            \"{}:{}:kukuri:topic:{}:post:{}\",\n            KIND30078_KIND, self.pubkey, slug, revision\n        );\n        if address_value != expected_address {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078TagMismatch,\n                format!(\"a tag must equal \\\"{expected_address}\\\" (value={address_value})\"),\n            ));\n        }\n\n        self.validate_kind30078_content()?;\n\n        Ok(())\n    }\n\n    fn validate_kind30078_content(&self) -> ValidationResult<()> {\n        let parsed: Kind30078Content = serde_json::from_str(&self.content).map_err(|err| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                format!(\"content must be valid JSON object: {err}\"),\n            )\n        })?;\n\n        if parsed.body.len() > MAX_EVENT_CONTENT_BYTES {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSize,\n                format!(\"body exceeds {MAX_EVENT_CONTENT_BYTES} bytes\"),\n            ));\n        }\n\n        if parsed.attachments.len() > KIND30078_MAX_ATTACHMENTS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSize,\n                format!(\"attachments exceed max {KIND30078_MAX_ATTACHMENTS}\"),\n            ));\n        }\n\n        for (idx, attachment) in parsed.attachments.iter().enumerate() {\n            if attachment.is_empty() {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\"attachment[{idx}] must not be empty\"),\n                ));\n            }\n            if !attachment.is_ascii() {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\"attachment[{idx}] must be ASCII\"),\n                ));\n            }\n            let lower = attachment.to_ascii_lowercase();\n            if !(lower.starts_with(\"iroh://\") || lower.starts_with(\"https://\")) {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Kind30078ContentSchema,\n                    format!(\n                        \"attachment[{idx}] must start with iroh:// or https:// (value={attachment})\"\n                    ),\n                ));\n            }\n        }\n\n        Version::parse(&parsed.metadata.app_version).map_err(|err| {\n            EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                format!(\"metadata.app_version must be semantic version: {err}\"),\n            )\n        })?;\n\n        if parsed.metadata.edited {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Kind30078ContentSchema,\n                \"metadata.edited=true is not supported for kind30078\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n}\n\nfn parse_kind30078_identifier(value: &str) -> ValidationResult<(String, String)> {\n    let rest = value.strip_prefix(\"kukuri:topic:\").ok_or_else(|| {\n        EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"d tag must start with kukuri:topic: (value={value})\"),\n        )\n    })?;\n    let (slug, revision) = rest.split_once(\":post:\").ok_or_else(|| {\n        EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"d tag must contain :post: separator (value={value})\"),\n        )\n    })?;\n    Ok((slug.to_string(), revision.to_string()))\n}\n\nfn ensure_slug_valid(slug: &str) -> ValidationResult<()> {\n    if slug.is_empty() || slug.len() > 48 {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"slug must be 1..48 characters (slug={slug})\"),\n        ));\n    }\n    if !slug\n        .chars()\n        .all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '-')\n    {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Kind30078TagMismatch,\n            format!(\"slug contains invalid characters: {slug}\"),\n        ));\n    }\n    Ok(())\n}\n\nfn ensure_revision_valid(revision: &str) -> ValidationResult<()> {\n    if revision.len() == 26 && is_crockford_base32(revision) {\n        return Ok(());\n    }\n    if revision.len() == 32 && revision.chars().all(|c| c.is_ascii_hexdigit()) {\n        return Ok(());\n    }\n    Err(EventValidationError::new(\n        ValidationFailureKind::Kind30078TagMismatch,\n        format!(\"invalid revision identifier: {revision}\"),\n    ))\n}\n\nfn is_crockford_base32(value: &str) -> bool {\n    value.chars().all(|c| {\n        let up = c.to_ascii_uppercase();\n        matches!(\n            up,\n            '0'..='9'\n                | 'A'..='H'\n                | 'J'..='K'\n                | 'M'..='N'\n                | 'P'..='T'\n                | 'V'..='Z'\n        )\n    })\n}\n","traces":[{"line":26,"address":[18984485,18988964,18981360],"length":1,"stats":{"Line":1}},{"line":27,"address":[18979751],"length":1,"stats":{"Line":1}},{"line":28,"address":[18863465],"length":1,"stats":{"Line":0}},{"line":29,"address":[18944791],"length":1,"stats":{"Line":0}},{"line":30,"address":[18863279],"length":1,"stats":{"Line":0}},{"line":37,"address":[18979811],"length":1,"stats":{"Line":1}},{"line":38,"address":[19076269],"length":1,"stats":{"Line":1}},{"line":39,"address":[18981493],"length":1,"stats":{"Line":1}},{"line":40,"address":[19076293],"length":1,"stats":{"Line":1}},{"line":42,"address":[18870021,18870396,18870567],"length":1,"stats":{"Line":3}},{"line":43,"address":[13120824,13118111],"length":1,"stats":{"Line":2}},{"line":46,"address":[18979242],"length":1,"stats":{"Line":1}},{"line":47,"address":[19079709],"length":1,"stats":{"Line":1}},{"line":48,"address":[18950332,18948238],"length":1,"stats":{"Line":2}},{"line":49,"address":[19083476,19081922],"length":1,"stats":{"Line":0}},{"line":50,"address":[18875626],"length":1,"stats":{"Line":0}},{"line":54,"address":[25741500,25741433],"length":1,"stats":{"Line":2}},{"line":55,"address":[18951821],"length":1,"stats":{"Line":0}},{"line":56,"address":[18985587],"length":1,"stats":{"Line":0}},{"line":57,"address":[18882715,18883926],"length":1,"stats":{"Line":0}},{"line":60,"address":[19083228,19081983,19082320,19082051],"length":1,"stats":{"Line":3}},{"line":61,"address":[18944062,18944628,18943960,18943815],"length":1,"stats":{"Line":4}},{"line":62,"address":[18869445,18869841,18870015,18869549],"length":1,"stats":{"Line":3}},{"line":63,"address":[18876683,18876406],"length":1,"stats":{"Line":1}},{"line":65,"address":[13120996,13121058,13122546],"length":1,"stats":{"Line":5}},{"line":66,"address":[18866802],"length":1,"stats":{"Line":2}},{"line":67,"address":[18981457,18980781],"length":1,"stats":{"Line":0}},{"line":68,"address":[18986357],"length":1,"stats":{"Line":0}},{"line":72,"address":[18868124,18868053],"length":1,"stats":{"Line":3}},{"line":73,"address":[18882410],"length":1,"stats":{"Line":0}},{"line":74,"address":[13122478],"length":1,"stats":{"Line":0}},{"line":75,"address":[18868515,18868182],"length":1,"stats":{"Line":0}},{"line":78,"address":[18881898,18881966],"length":1,"stats":{"Line":3}},{"line":79,"address":[18943007],"length":1,"stats":{"Line":0}},{"line":80,"address":[18949775],"length":1,"stats":{"Line":0}},{"line":81,"address":[18980967],"length":1,"stats":{"Line":0}},{"line":84,"address":[18949754],"length":1,"stats":{"Line":1}},{"line":86,"address":[13121080,13121132,13122109],"length":1,"stats":{"Line":5}},{"line":87,"address":[18979588,18980212],"length":1,"stats":{"Line":3}},{"line":88,"address":[18874734],"length":1,"stats":{"Line":0}},{"line":89,"address":[18867561],"length":1,"stats":{"Line":0}},{"line":90,"address":[18980527],"length":1,"stats":{"Line":0}},{"line":92,"address":[18867815,18867569],"length":1,"stats":{"Line":0}},{"line":96,"address":[18980226,18980300],"length":1,"stats":{"Line":2}},{"line":98,"address":[18948370,18948433,18948777],"length":1,"stats":{"Line":5}},{"line":99,"address":[13121234],"length":1,"stats":{"Line":1}},{"line":100,"address":[18867405],"length":1,"stats":{"Line":0}},{"line":101,"address":[18985298],"length":1,"stats":{"Line":0}},{"line":102,"address":[18948538,18948790],"length":1,"stats":{"Line":0}},{"line":105,"address":[18985336,18985259],"length":1,"stats":{"Line":3}},{"line":111,"address":[25736747,25736387,25739142,25736527],"length":1,"stats":{"Line":6}},{"line":112,"address":[23715889],"length":1,"stats":{"Line":1}},{"line":113,"address":[23776716],"length":1,"stats":{"Line":1}},{"line":118,"address":[13118320],"length":1,"stats":{"Line":1}},{"line":119,"address":[25736780,25736930],"length":1,"stats":{"Line":0}},{"line":120,"address":[18877857],"length":1,"stats":{"Line":0}},{"line":125,"address":[13118636,13118448,13118829,13120772],"length":1,"stats":{"Line":3}},{"line":126,"address":[23708977],"length":1,"stats":{"Line":0}},{"line":127,"address":[23708972],"length":1,"stats":{"Line":0}},{"line":132,"address":[18981098,18981238],"length":1,"stats":{"Line":3}},{"line":133,"address":[18946218,18946303],"length":1,"stats":{"Line":3}},{"line":134,"address":[18866351],"length":1,"stats":{"Line":1}},{"line":135,"address":[18983144],"length":1,"stats":{"Line":1}},{"line":136,"address":[18879968,18878624],"length":1,"stats":{"Line":2}},{"line":140,"address":[18984494,18983182,18983374,18983077],"length":1,"stats":{"Line":6}},{"line":141,"address":[23915329],"length":1,"stats":{"Line":1}},{"line":142,"address":[23702252],"length":1,"stats":{"Line":1}},{"line":147,"address":[25737814,25737671],"length":1,"stats":{"Line":3}},{"line":151,"address":[18978096,18978181],"length":1,"stats":{"Line":3}},{"line":152,"address":[18947581],"length":1,"stats":{"Line":0}},{"line":153,"address":[19078578],"length":1,"stats":{"Line":0}},{"line":154,"address":[13119818,13120222],"length":1,"stats":{"Line":0}},{"line":158,"address":[18940091,18940486,18940136,18940246],"length":1,"stats":{"Line":5}},{"line":160,"address":[25738267],"length":1,"stats":{"Line":1}},{"line":163,"address":[25745606,25746188,25743296],"length":1,"stats":{"Line":1}},{"line":164,"address":[23818944,23819169],"length":1,"stats":{"Line":2}},{"line":165,"address":[23709268],"length":1,"stats":{"Line":0}},{"line":166,"address":[23702325],"length":1,"stats":{"Line":0}},{"line":167,"address":[23820683,23820618],"length":1,"stats":{"Line":0}},{"line":171,"address":[13125351,13125519],"length":1,"stats":{"Line":3}},{"line":172,"address":[18955083],"length":1,"stats":{"Line":0}},{"line":173,"address":[25743818],"length":1,"stats":{"Line":0}},{"line":174,"address":[18987898,18990103],"length":1,"stats":{"Line":0}},{"line":178,"address":[18871295,18871223],"length":1,"stats":{"Line":3}},{"line":179,"address":[18990008],"length":1,"stats":{"Line":1}},{"line":180,"address":[18878120],"length":1,"stats":{"Line":1}},{"line":181,"address":[18954788,18952864],"length":1,"stats":{"Line":2}},{"line":185,"address":[18945981,18945893,18946233],"length":1,"stats":{"Line":3}},{"line":186,"address":[18885433,18885965],"length":1,"stats":{"Line":2}},{"line":187,"address":[18989813],"length":1,"stats":{"Line":0}},{"line":188,"address":[18885996],"length":1,"stats":{"Line":0}},{"line":189,"address":[18990532,18991361],"length":1,"stats":{"Line":0}},{"line":192,"address":[18946876,18946803],"length":1,"stats":{"Line":2}},{"line":193,"address":[25745018],"length":1,"stats":{"Line":0}},{"line":194,"address":[18872305],"length":1,"stats":{"Line":0}},{"line":195,"address":[18886073,18886128],"length":1,"stats":{"Line":0}},{"line":198,"address":[18886341,18886100],"length":1,"stats":{"Line":2}},{"line":199,"address":[18947188,18947353,18947259],"length":1,"stats":{"Line":3}},{"line":200,"address":[18989616],"length":1,"stats":{"Line":1}},{"line":201,"address":[13127102],"length":1,"stats":{"Line":1}},{"line":202,"address":[18947398],"length":1,"stats":{"Line":1}},{"line":209,"address":[18953136,18953719,18953482,18953225],"length":1,"stats":{"Line":5}},{"line":210,"address":[23777302],"length":1,"stats":{"Line":1}},{"line":211,"address":[23784112],"length":1,"stats":{"Line":1}},{"line":212,"address":[23702597],"length":1,"stats":{"Line":1}},{"line":216,"address":[18878775],"length":1,"stats":{"Line":1}},{"line":217,"address":[19085165],"length":1,"stats":{"Line":0}},{"line":218,"address":[18872038],"length":1,"stats":{"Line":0}},{"line":219,"address":[25744601],"length":1,"stats":{"Line":0}},{"line":223,"address":[19085081],"length":1,"stats":{"Line":1}},{"line":227,"address":[20522320,20523066],"length":1,"stats":{"Line":2}},{"line":228,"address":[23709833,23709563,23710320],"length":1,"stats":{"Line":2}},{"line":229,"address":[23710460],"length":1,"stats":{"Line":0}},{"line":230,"address":[20523110],"length":1,"stats":{"Line":0}},{"line":231,"address":[20523115],"length":1,"stats":{"Line":0}},{"line":234,"address":[23716660,23717062,23716835,23717472],"length":1,"stats":{"Line":4}},{"line":235,"address":[23816556],"length":1,"stats":{"Line":0}},{"line":236,"address":[20523286],"length":1,"stats":{"Line":0}},{"line":237,"address":[20523291],"length":1,"stats":{"Line":0}},{"line":240,"address":[23916253,23916400],"length":1,"stats":{"Line":2}},{"line":243,"address":[23820528],"length":1,"stats":{"Line":1}},{"line":244,"address":[23916987],"length":1,"stats":{"Line":2}},{"line":245,"address":[23704078],"length":1,"stats":{"Line":0}},{"line":246,"address":[23917031],"length":1,"stats":{"Line":0}},{"line":247,"address":[23778556],"length":1,"stats":{"Line":0}},{"line":250,"address":[23820784],"length":1,"stats":{"Line":1}},{"line":252,"address":[20524000,20524013],"length":1,"stats":{"Line":3}},{"line":254,"address":[23817032],"length":1,"stats":{"Line":0}},{"line":255,"address":[23816901],"length":1,"stats":{"Line":0}},{"line":256,"address":[23917277],"length":1,"stats":{"Line":0}},{"line":259,"address":[17958721],"length":1,"stats":{"Line":2}},{"line":262,"address":[23711312],"length":1,"stats":{"Line":1}},{"line":263,"address":[23821194],"length":1,"stats":{"Line":2}},{"line":264,"address":[23779213],"length":1,"stats":{"Line":2}},{"line":266,"address":[23817629,23817298,23817616,23817351],"length":1,"stats":{"Line":0}},{"line":267,"address":[23786399],"length":1,"stats":{"Line":0}},{"line":269,"address":[23779402],"length":1,"stats":{"Line":0}},{"line":270,"address":[23821331],"length":1,"stats":{"Line":0}},{"line":271,"address":[23917768],"length":1,"stats":{"Line":0}},{"line":275,"address":[23711728],"length":1,"stats":{"Line":1}},{"line":276,"address":[23918030,23918064],"length":1,"stats":{"Line":3}},{"line":277,"address":[23817709],"length":1,"stats":{"Line":2}},{"line":278,"address":[23823346,23823457],"length":1,"stats":{"Line":1}},{"line":280,"address":[23786545,23786573],"length":1,"stats":{"Line":3}},{"line":281,"address":[23718798,23718844],"length":1,"stats":{"Line":3}},{"line":282,"address":[23817814,23817773],"length":1,"stats":{"Line":0}},{"line":283,"address":[23705095,23705136],"length":1,"stats":{"Line":0}},{"line":284,"address":[23823450,23823409],"length":1,"stats":{"Line":0}},{"line":285,"address":[23718907,23718940],"length":1,"stats":{"Line":0}}],"covered":83,"coverable":149},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","mod.rs"],"content":"mod errors;\nmod kind30078;\nmod nip01;\nmod nip10_19;\nmod nip19;\nmod utils;\n\npub use errors::{EventValidationError, ValidationResult};\npub use kind30078::{KIND30078_KIND, KIND30078_MAX_ATTACHMENTS};\n\nuse super::Event;\n\nimpl Event {\n    pub fn validate_for_gateway(&self) -> ValidationResult<()> {\n        self.validate_nip01()?;\n        self.validate_nip10_19()?;\n        if self.kind == KIND30078_KIND {\n            self.validate_kind30078()?;\n        }\n        Ok(())\n    }\n\n    pub fn validate_nprofile_tlv(s: &str) -> ValidationResult<()> {\n        nip19::validate_nprofile_tlv(s)\n    }\n\n    pub fn validate_nevent_tlv(s: &str) -> ValidationResult<()> {\n        nip19::validate_nevent_tlv(s)\n    }\n}\n","traces":[{"line":14,"address":[18961072],"length":1,"stats":{"Line":2}},{"line":15,"address":[18886500,18886365],"length":1,"stats":{"Line":2}},{"line":16,"address":[18992348,18992506],"length":1,"stats":{"Line":2}},{"line":17,"address":[18893543],"length":1,"stats":{"Line":2}},{"line":18,"address":[19092988],"length":1,"stats":{"Line":0}},{"line":20,"address":[18998182],"length":1,"stats":{"Line":2}},{"line":23,"address":[19093168],"length":1,"stats":{"Line":1}},{"line":24,"address":[18996757],"length":1,"stats":{"Line":1}},{"line":27,"address":[18992848],"length":1,"stats":{"Line":1}},{"line":28,"address":[18992869],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip01.rs"],"content":"use super::errors::{\n    EventValidationError, MAX_EVENT_CONTENT_BYTES, MAX_EVENT_TAGS, TIMESTAMP_DRIFT_SECS,\n    ValidationResult,\n};\nuse super::utils::is_hex_n;\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse chrono::Utc;\nuse sha2::{Digest, Sha256};\n\nimpl Event {\n    /// NIP-01に基づく基本バリデーション\n    /// - idは[0,pubkey,created_at,kind,tags,content]のsha256\n    /// - pubkeyは32byte hex（64桁）\n    /// - sigは64byte hex（128桁）\n    pub fn validate_nip01(&self) -> ValidationResult<()> {\n        if !is_hex_n(&self.pubkey, 64) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid pubkey (expect 64 hex)\",\n            ));\n        }\n        if !is_hex_n(&self.sig, 128) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid sig (expect 128 hex)\",\n            ));\n        }\n        if !is_hex_n(&self.id, 64) {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"invalid id (expect 64 hex)\",\n            ));\n        }\n\n        let created_at_secs = self.created_at.timestamp();\n        let payload = serde_json::json!([\n            0,\n            self.pubkey,\n            created_at_secs,\n            self.kind,\n            self.tags,\n            self.content,\n        ]);\n        let serialized = serde_json::to_vec(&payload).map_err(|e| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                format!(\"serialization error: {e}\"),\n            )\n        })?;\n        let hash = Sha256::digest(&serialized);\n        let calc_id = format!(\"{hash:x}\");\n        if calc_id != self.id {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip01Integrity,\n                \"id mismatch (not NIP-01 compliant)\",\n            ));\n        }\n\n        let drift_secs = self\n            .created_at\n            .signed_duration_since(Utc::now())\n            .num_seconds()\n            .abs();\n        if drift_secs > TIMESTAMP_DRIFT_SECS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::TimestampOutOfRange,\n                format!(\"created_at outside ±{TIMESTAMP_DRIFT_SECS}s window (drift={drift_secs}s)\"),\n            ));\n        }\n\n        if self.tags.len() > MAX_EVENT_TAGS {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::TagLimitExceeded,\n                format!(\"too many tags: {} (max {MAX_EVENT_TAGS})\", self.tags.len()),\n            ));\n        }\n\n        if self.content.len() > MAX_EVENT_CONTENT_BYTES {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::ContentTooLarge,\n                format!(\n                    \"content exceeds {MAX_EVENT_CONTENT_BYTES} bytes (actual {})\",\n                    self.content.len()\n                ),\n            ));\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[18989775,18989786,18986384],"length":1,"stats":{"Line":2}},{"line":17,"address":[18990358],"length":1,"stats":{"Line":2}},{"line":18,"address":[18986459],"length":1,"stats":{"Line":0}},{"line":19,"address":[18955267],"length":1,"stats":{"Line":0}},{"line":23,"address":[18880623],"length":1,"stats":{"Line":2}},{"line":24,"address":[18873891],"length":1,"stats":{"Line":0}},{"line":25,"address":[18955403],"length":1,"stats":{"Line":0}},{"line":29,"address":[18986688],"length":1,"stats":{"Line":2}},{"line":30,"address":[18880801],"length":1,"stats":{"Line":0}},{"line":31,"address":[18955529],"length":1,"stats":{"Line":0}},{"line":36,"address":[18955633],"length":1,"stats":{"Line":2}},{"line":37,"address":[18958615,18955664,18956629],"length":1,"stats":{"Line":2}},{"line":45,"address":[21356272,21356497],"length":1,"stats":{"Line":4}},{"line":46,"address":[21437972],"length":1,"stats":{"Line":0}},{"line":47,"address":[21437813],"length":1,"stats":{"Line":0}},{"line":48,"address":[15610602,15610667],"length":1,"stats":{"Line":0}},{"line":51,"address":[18889082],"length":1,"stats":{"Line":2}},{"line":52,"address":[13129763],"length":1,"stats":{"Line":2}},{"line":53,"address":[18993879,18993950],"length":1,"stats":{"Line":4}},{"line":54,"address":[18876981,18875725],"length":1,"stats":{"Line":2}},{"line":55,"address":[18889477],"length":1,"stats":{"Line":1}},{"line":60,"address":[18992313,18992407],"length":1,"stats":{"Line":4}},{"line":62,"address":[19088770],"length":1,"stats":{"Line":2}},{"line":65,"address":[18988585],"length":1,"stats":{"Line":2}},{"line":66,"address":[18883668],"length":1,"stats":{"Line":1}},{"line":67,"address":[18957440],"length":1,"stats":{"Line":1}},{"line":68,"address":[18876741,18875928],"length":1,"stats":{"Line":2}},{"line":72,"address":[18889722,18889660],"length":1,"stats":{"Line":4}},{"line":73,"address":[18994937],"length":1,"stats":{"Line":0}},{"line":74,"address":[18992636],"length":1,"stats":{"Line":0}},{"line":75,"address":[18883256,18882788],"length":1,"stats":{"Line":0}},{"line":79,"address":[13130336,13130279],"length":1,"stats":{"Line":4}},{"line":80,"address":[18957878],"length":1,"stats":{"Line":0}},{"line":81,"address":[18988786],"length":1,"stats":{"Line":0}},{"line":82,"address":[18876165],"length":1,"stats":{"Line":0}},{"line":84,"address":[25748559,25748618],"length":1,"stats":{"Line":0}},{"line":89,"address":[18950647],"length":1,"stats":{"Line":2}}],"covered":21,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip10_19.rs"],"content":"use super::errors::{EventValidationError, ValidationResult};\nuse super::nip19::{validate_nevent_tlv, validate_nprofile_tlv};\nuse super::utils::{is_hex_n, is_ws_url};\nuse crate::domain::entities::event::Event;\nuse crate::shared::validation::ValidationFailureKind;\nuse nostr_sdk::prelude::{EventId as NostrEventId, FromBech32 as _, PublicKey as NostrPublicKey};\n\nimpl Event {\n    /// NIP-10/NIP-19 の返信タグ・bech32/TLVの検証\n    pub fn validate_nip10_19(&self) -> ValidationResult<()> {\n        let mut root_seen = 0usize;\n        let mut reply_seen = 0usize;\n\n        for tag in &self.tags {\n            if tag.is_empty() {\n                continue;\n            }\n            match tag[0].as_str() {\n                \"e\" => {\n                    if tag.len() < 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Nip10TagStructure,\n                            \"invalid e tag (len < 2)\",\n                        ));\n                    }\n                    let evref = &tag[1];\n                    if !is_hex_n(evref, 64) {\n                        ensure_event_ref(evref)?;\n                    }\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(EventValidationError::new(\n                                ValidationFailureKind::Nip10TagStructure,\n                                format!(\"invalid e tag relay_url: {relay_url}\"),\n                            ));\n                        }\n                    }\n                    if tag.len() >= 4 {\n                        let marker = tag[3].as_str();\n                        match marker {\n                            \"root\" => root_seen += 1,\n                            \"reply\" => reply_seen += 1,\n                            \"mention\" => {}\n                            _ => {\n                                return Err(EventValidationError::new(\n                                    ValidationFailureKind::Nip10TagStructure,\n                                    format!(\"invalid e tag marker: {marker}\"),\n                                ));\n                            }\n                        }\n                    }\n                }\n                \"p\" => {\n                    if tag.len() < 2 {\n                        return Err(EventValidationError::new(\n                            ValidationFailureKind::Nip10TagStructure,\n                            \"invalid p tag (len < 2)\",\n                        ));\n                    }\n                    let pkref = &tag[1];\n                    if !is_hex_n(pkref, 64) {\n                        ensure_pubkey_ref(pkref)?;\n                    }\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(EventValidationError::new(\n                                ValidationFailureKind::Nip10TagStructure,\n                                format!(\"invalid p tag relay_url: {relay_url}\"),\n                            ));\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if root_seen > 1 {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip10TagStructure,\n                \"multiple root markers in e tags\",\n            ));\n        }\n        if reply_seen > 1 {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip10TagStructure,\n                \"multiple reply markers in e tags\",\n            ));\n        }\n        Ok(())\n    }\n}\n\nfn ensure_event_ref(s: &str) -> ValidationResult<()> {\n    if s.starts_with(\"note1\") {\n        NostrEventId::from_bech32(s).map_err(|_| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip19Encoding,\n                \"invalid note reference bech32\",\n            )\n        })?;\n        Ok(())\n    } else if s.starts_with(\"nevent1\") {\n        validate_nevent_tlv(s)\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip10TagStructure,\n            format!(\"unsupported e tag reference format: {s}\"),\n        ))\n    }\n}\n\nfn ensure_pubkey_ref(s: &str) -> ValidationResult<()> {\n    if s.starts_with(\"npub1\") {\n        NostrPublicKey::from_bech32(s).map_err(|_| {\n            EventValidationError::new(\n                ValidationFailureKind::Nip19Encoding,\n                \"invalid npub reference bech32\",\n            )\n        })?;\n        Ok(())\n    } else if s.starts_with(\"nprofile1\") {\n        validate_nprofile_tlv(s)\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip10TagStructure,\n            format!(\"unsupported p tag reference format: {s}\"),\n        ))\n    }\n}\n","traces":[{"line":10,"address":[18995392],"length":1,"stats":{"Line":3}},{"line":11,"address":[18995430],"length":1,"stats":{"Line":3}},{"line":12,"address":[18989855],"length":1,"stats":{"Line":3}},{"line":14,"address":[18989864,18989936],"length":1,"stats":{"Line":6}},{"line":15,"address":[18951842],"length":1,"stats":{"Line":3}},{"line":18,"address":[13131807],"length":1,"stats":{"Line":3}},{"line":19,"address":[18995832],"length":1,"stats":{"Line":3}},{"line":20,"address":[18877606],"length":1,"stats":{"Line":2}},{"line":21,"address":[18995057],"length":1,"stats":{"Line":0}},{"line":22,"address":[18991113],"length":1,"stats":{"Line":0}},{"line":26,"address":[18959864],"length":1,"stats":{"Line":2}},{"line":27,"address":[18885162],"length":1,"stats":{"Line":2}},{"line":28,"address":[25750964,25751065],"length":1,"stats":{"Line":3}},{"line":30,"address":[13132894],"length":1,"stats":{"Line":3}},{"line":31,"address":[18997018],"length":1,"stats":{"Line":3}},{"line":32,"address":[18995412],"length":1,"stats":{"Line":3}},{"line":33,"address":[25751411],"length":1,"stats":{"Line":1}},{"line":34,"address":[18960342],"length":1,"stats":{"Line":1}},{"line":35,"address":[18960350],"length":1,"stats":{"Line":1}},{"line":39,"address":[25751159],"length":1,"stats":{"Line":3}},{"line":40,"address":[18960568],"length":1,"stats":{"Line":3}},{"line":42,"address":[18961040,18960686,18960610],"length":1,"stats":{"Line":7}},{"line":43,"address":[13133431,13133541,13133793],"length":1,"stats":{"Line":7}},{"line":44,"address":[18997482],"length":1,"stats":{"Line":2}},{"line":46,"address":[19092470],"length":1,"stats":{"Line":2}},{"line":47,"address":[18893024],"length":1,"stats":{"Line":2}},{"line":48,"address":[18886056],"length":1,"stats":{"Line":2}},{"line":54,"address":[18891335],"length":1,"stats":{"Line":3}},{"line":55,"address":[18959152],"length":1,"stats":{"Line":2}},{"line":56,"address":[18996010],"length":1,"stats":{"Line":0}},{"line":57,"address":[18994354],"length":1,"stats":{"Line":0}},{"line":61,"address":[18884433],"length":1,"stats":{"Line":2}},{"line":62,"address":[18995971],"length":1,"stats":{"Line":2}},{"line":63,"address":[18952410,18952515],"length":1,"stats":{"Line":3}},{"line":65,"address":[18891661],"length":1,"stats":{"Line":2}},{"line":66,"address":[18996306],"length":1,"stats":{"Line":1}},{"line":67,"address":[19091132],"length":1,"stats":{"Line":1}},{"line":68,"address":[18952844],"length":1,"stats":{"Line":1}},{"line":69,"address":[18959638],"length":1,"stats":{"Line":1}},{"line":70,"address":[18878126],"length":1,"stats":{"Line":1}},{"line":79,"address":[18951814],"length":1,"stats":{"Line":3}},{"line":80,"address":[13131587],"length":1,"stats":{"Line":0}},{"line":81,"address":[18993915],"length":1,"stats":{"Line":0}},{"line":85,"address":[25749729],"length":1,"stats":{"Line":3}},{"line":86,"address":[19090471],"length":1,"stats":{"Line":1}},{"line":87,"address":[25749854],"length":1,"stats":{"Line":1}},{"line":91,"address":[18995664],"length":1,"stats":{"Line":3}},{"line":95,"address":[13577088],"length":1,"stats":{"Line":2}},{"line":96,"address":[13613883,13614348],"length":1,"stats":{"Line":4}},{"line":97,"address":[13570257,13570587,13570752,13570711,13570852],"length":1,"stats":{"Line":6}},{"line":98,"address":[13608885],"length":1,"stats":{"Line":1}},{"line":99,"address":[13709248],"length":1,"stats":{"Line":1}},{"line":103,"address":[21271023],"length":1,"stats":{"Line":2}},{"line":104,"address":[13495627,13495955],"length":1,"stats":{"Line":1}},{"line":105,"address":[13502746],"length":1,"stats":{"Line":1}},{"line":107,"address":[21270849],"length":1,"stats":{"Line":0}},{"line":108,"address":[13570334],"length":1,"stats":{"Line":0}},{"line":109,"address":[13577270],"length":1,"stats":{"Line":0}},{"line":114,"address":[13510048],"length":1,"stats":{"Line":2}},{"line":115,"address":[13496315,13496780],"length":1,"stats":{"Line":4}},{"line":116,"address":[13510599,13510640,13510145,13510475,13510740],"length":1,"stats":{"Line":6}},{"line":117,"address":[13496901],"length":1,"stats":{"Line":1}},{"line":118,"address":[25753296],"length":1,"stats":{"Line":1}},{"line":122,"address":[13615055],"length":1,"stats":{"Line":2}},{"line":123,"address":[13503131,13503459],"length":1,"stats":{"Line":1}},{"line":124,"address":[13571274],"length":1,"stats":{"Line":1}},{"line":126,"address":[13496593],"length":1,"stats":{"Line":0}},{"line":127,"address":[13510222],"length":1,"stats":{"Line":0}},{"line":128,"address":[13503254],"length":1,"stats":{"Line":0}}],"covered":57,"coverable":69},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","nip19.rs"],"content":"use super::errors::{EventValidationError, ValidationResult};\nuse super::utils::is_ws_url;\nuse crate::shared::validation::ValidationFailureKind;\nuse bech32;\n\npub(super) const MAX_TLV_RELAY_URLS: usize = 16;\npub(super) const MAX_TLV_RELAY_URL_LEN: usize = 255;\n\npub(super) fn validate_nprofile_tlv(s: &str) -> ValidationResult<()> {\n    let (hrp, data) = bech32::decode(s).map_err(|_| {\n        EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            \"invalid nprofile bech32 encoding\",\n        )\n    })?;\n    if hrp.as_str() != \"nprofile\" {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            format!(\"unexpected nprofile hrp: {hrp}\"),\n        ));\n    }\n    let bytes = data;\n    let mut has_pubkey = false;\n    let mut relay_count = 0usize;\n    parse_tlv(&bytes, |tag, value| match tag {\n        0 => {\n            if has_pubkey || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nprofile tag 0 must appear exactly once with 32 bytes\",\n                ))\n            } else {\n                has_pubkey = true;\n                Ok(())\n            }\n        }\n        1 => {\n            relay_count += 1;\n            if relay_count > MAX_TLV_RELAY_URLS {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"nprofile relay entries exceed max {MAX_TLV_RELAY_URLS}\"),\n                ));\n            }\n            validate_tlv_relay(value)\n        }\n        _ => Ok(()),\n    })?;\n    if !has_pubkey {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"nprofile missing tag 0 (pubkey)\",\n        ));\n    }\n    Ok(())\n}\n\npub(super) fn validate_nevent_tlv(s: &str) -> ValidationResult<()> {\n    let (hrp, data) = bech32::decode(s).map_err(|_| {\n        EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            \"invalid nevent bech32 encoding\",\n        )\n    })?;\n    if hrp.as_str() != \"nevent\" {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Encoding,\n            format!(\"unexpected nevent hrp: {hrp}\"),\n        ));\n    }\n    let bytes = data;\n    let mut has_event_id = false;\n    let mut has_author = false;\n    let mut has_kind = false;\n    let mut relay_count = 0usize;\n    parse_tlv(&bytes, |tag, value| match tag {\n        0 => {\n            if has_event_id || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 0 must appear exactly once with 32 bytes\",\n                ))\n            } else {\n                has_event_id = true;\n                Ok(())\n            }\n        }\n        1 => {\n            relay_count += 1;\n            if relay_count > MAX_TLV_RELAY_URLS {\n                return Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"nevent relay entries exceed max {MAX_TLV_RELAY_URLS}\"),\n                ));\n            }\n            validate_tlv_relay(value)\n        }\n        2 => {\n            if has_author || value.len() != 32 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 2 (author) must be 32 bytes and appear at most once\",\n                ))\n            } else {\n                has_author = true;\n                Ok(())\n            }\n        }\n        3 => {\n            if has_kind || value.len() != 4 {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    \"nevent tag 3 (kind) must be 4 bytes and appear at most once\",\n                ))\n            } else {\n                has_kind = true;\n                Ok(())\n            }\n        }\n        _ => Ok(()),\n    })?;\n    if !has_event_id {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"nevent missing tag 0 (event id)\",\n        ));\n    }\n    Ok(())\n}\n\nfn parse_tlv(\n    bytes: &[u8],\n    mut handler: impl FnMut(u8, &[u8]) -> ValidationResult<()>,\n) -> ValidationResult<()> {\n    let mut i = 0usize;\n    while i + 2 <= bytes.len() {\n        let tag = bytes[i];\n        let len = bytes[i + 1] as usize;\n        i += 2;\n        if i + len > bytes.len() {\n            return Err(EventValidationError::new(\n                ValidationFailureKind::Nip19Tlv,\n                \"TLV value length exceeds buffer\",\n            ));\n        }\n        let value = &bytes[i..i + len];\n        handler(tag, value)?;\n        i += len;\n    }\n    if i == bytes.len() {\n        Ok(())\n    } else {\n        Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"TLV parse ended with trailing bytes\",\n        ))\n    }\n}\n\nfn validate_tlv_relay(value: &[u8]) -> ValidationResult<()> {\n    if value.len() > MAX_TLV_RELAY_URL_LEN {\n        return Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            format!(\"relay url exceeds {MAX_TLV_RELAY_URL_LEN} bytes\"),\n        ));\n    }\n    if value.is_empty() {\n        return Ok(());\n    }\n    match std::str::from_utf8(value) {\n        Ok(url) => {\n            if url.is_ascii() && is_ws_url(url) {\n                Ok(())\n            } else {\n                Err(EventValidationError::new(\n                    ValidationFailureKind::Nip19Tlv,\n                    format!(\"relay url must be ws[s]:// and ASCII: {url}\"),\n                ))\n            }\n        }\n        Err(_) => Err(EventValidationError::new(\n            ValidationFailureKind::Nip19Tlv,\n            \"relay url must be valid UTF-8\",\n        )),\n    }\n}\n","traces":[{"line":9,"address":[12690016,12691408,12691178],"length":1,"stats":{"Line":2}},{"line":10,"address":[12623632,12622241,12622691],"length":1,"stats":{"Line":2}},{"line":11,"address":[12698385],"length":1,"stats":{"Line":0}},{"line":12,"address":[20391836],"length":1,"stats":{"Line":0}},{"line":16,"address":[12732624,12732458],"length":1,"stats":{"Line":4}},{"line":17,"address":[12729399],"length":1,"stats":{"Line":0}},{"line":18,"address":[12629889],"length":1,"stats":{"Line":0}},{"line":19,"address":[12729299,12728841],"length":1,"stats":{"Line":0}},{"line":22,"address":[12616040],"length":1,"stats":{"Line":2}},{"line":23,"address":[12734368],"length":1,"stats":{"Line":2}},{"line":24,"address":[12829160],"length":1,"stats":{"Line":2}},{"line":25,"address":[12616360,12616912,12616242,12616981,12616100,12616565],"length":1,"stats":{"Line":12}},{"line":27,"address":[20392052,20392131,20392001],"length":1,"stats":{"Line":4}},{"line":28,"address":[12617087],"length":1,"stats":{"Line":0}},{"line":29,"address":[20392058],"length":1,"stats":{"Line":0}},{"line":33,"address":[20392143],"length":1,"stats":{"Line":2}},{"line":34,"address":[20949393],"length":1,"stats":{"Line":2}},{"line":38,"address":[12617040,12617227,12617208],"length":1,"stats":{"Line":4}},{"line":39,"address":[12735503],"length":1,"stats":{"Line":2}},{"line":40,"address":[12734038],"length":1,"stats":{"Line":0}},{"line":41,"address":[12830337],"length":1,"stats":{"Line":0}},{"line":42,"address":[12691865],"length":1,"stats":{"Line":0}},{"line":45,"address":[12735546],"length":1,"stats":{"Line":2}},{"line":47,"address":[12698522],"length":1,"stats":{"Line":0}},{"line":49,"address":[12690903],"length":1,"stats":{"Line":2}},{"line":50,"address":[12729182,12729101],"length":1,"stats":{"Line":2}},{"line":51,"address":[20391365],"length":1,"stats":{"Line":1}},{"line":55,"address":[12829523],"length":1,"stats":{"Line":2}},{"line":58,"address":[12731640,12730176,12731410],"length":1,"stats":{"Line":3}},{"line":59,"address":[12832048,12830577,12831027],"length":1,"stats":{"Line":5}},{"line":60,"address":[20393969],"length":1,"stats":{"Line":1}},{"line":61,"address":[12618988],"length":1,"stats":{"Line":1}},{"line":65,"address":[12730736,12730570],"length":1,"stats":{"Line":6}},{"line":66,"address":[12693407],"length":1,"stats":{"Line":0}},{"line":67,"address":[12736481],"length":1,"stats":{"Line":0}},{"line":68,"address":[12624985,12625499],"length":1,"stats":{"Line":0}},{"line":71,"address":[12624872],"length":1,"stats":{"Line":3}},{"line":72,"address":[12618128],"length":1,"stats":{"Line":3}},{"line":73,"address":[12831208],"length":1,"stats":{"Line":3}},{"line":74,"address":[12618144],"length":1,"stats":{"Line":3}},{"line":75,"address":[12624936],"length":1,"stats":{"Line":3}},{"line":76,"address":[12618685,12619040,12619105,12618164,12618480,12618290],"length":1,"stats":{"Line":14}},{"line":78,"address":[12693758,12693855,12693934],"length":1,"stats":{"Line":6}},{"line":79,"address":[20951482],"length":1,"stats":{"Line":0}},{"line":80,"address":[12735909],"length":1,"stats":{"Line":0}},{"line":84,"address":[12735994],"length":1,"stats":{"Line":3}},{"line":85,"address":[12832432],"length":1,"stats":{"Line":3}},{"line":89,"address":[20951621,20951389,20951602],"length":1,"stats":{"Line":4}},{"line":90,"address":[12626186],"length":1,"stats":{"Line":2}},{"line":91,"address":[12633345],"length":1,"stats":{"Line":0}},{"line":92,"address":[12619452],"length":1,"stats":{"Line":0}},{"line":93,"address":[20394436],"length":1,"stats":{"Line":0}},{"line":96,"address":[20951652],"length":1,"stats":{"Line":2}},{"line":99,"address":[12736302,12736437,12735857,12736402],"length":1,"stats":{"Line":7}},{"line":100,"address":[12732380],"length":1,"stats":{"Line":1}},{"line":101,"address":[12832740],"length":1,"stats":{"Line":1}},{"line":105,"address":[12626561],"length":1,"stats":{"Line":2}},{"line":106,"address":[20394760],"length":1,"stats":{"Line":2}},{"line":110,"address":[12832312,12832879,12832979,12833014],"length":1,"stats":{"Line":6}},{"line":111,"address":[12626605],"length":1,"stats":{"Line":0}},{"line":112,"address":[12694405],"length":1,"stats":{"Line":0}},{"line":116,"address":[12633682],"length":1,"stats":{"Line":2}},{"line":117,"address":[12736569],"length":1,"stats":{"Line":2}},{"line":120,"address":[12735783],"length":1,"stats":{"Line":0}},{"line":122,"address":[12632191],"length":1,"stats":{"Line":2}},{"line":123,"address":[12736886,12736805],"length":1,"stats":{"Line":2}},{"line":124,"address":[12735149],"length":1,"stats":{"Line":1}},{"line":128,"address":[12700091],"length":1,"stats":{"Line":2}},{"line":131,"address":[12834192,12833155,12833024,12834312],"length":1,"stats":{"Line":5}},{"line":135,"address":[12833086,12834243],"length":1,"stats":{"Line":5}},{"line":136,"address":[12737823,12737661,12738813,12736666],"length":1,"stats":{"Line":10}},{"line":137,"address":[20953709,20952350,20952520,20953661,20952568,20953491],"length":1,"stats":{"Line":10}},{"line":138,"address":[12634155,12635247,12634244,12635312,12635401,12634090],"length":1,"stats":{"Line":10}},{"line":139,"address":[20952654,20953795,20952747,20953888,20952719,20953860],"length":1,"stats":{"Line":10}},{"line":140,"address":[12833646,12834752,12833595,12834803],"length":1,"stats":{"Line":10}},{"line":141,"address":[20397187,20395624,20396781,20396035],"length":1,"stats":{"Line":0}},{"line":142,"address":[12733344,12734501],"length":1,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[20952811,20952910,20953952,20954051],"length":1,"stats":{"Line":10}},{"line":147,"address":[12696695,12695639,12695542,12696543,12695381,12696791],"length":1,"stats":{"Line":11}},{"line":148,"address":[20395989,20395901,20397055,20397154,20397141,20396002],"length":1,"stats":{"Line":10}},{"line":150,"address":[12701645,12702911,12702802,12701754],"length":1,"stats":{"Line":8}},{"line":151,"address":[20396354,20395197],"length":1,"stats":{"Line":4}},{"line":153,"address":[12736881,12737974,12738038,12736817],"length":1,"stats":{"Line":0}},{"line":154,"address":[12732873,12734030],"length":1,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[12703792],"length":1,"stats":{"Line":2}},{"line":161,"address":[12735019],"length":1,"stats":{"Line":3}},{"line":162,"address":[20397450],"length":1,"stats":{"Line":0}},{"line":163,"address":[12735057],"length":1,"stats":{"Line":0}},{"line":164,"address":[12738998],"length":1,"stats":{"Line":0}},{"line":167,"address":[12835406],"length":1,"stats":{"Line":3}},{"line":168,"address":[12697174],"length":1,"stats":{"Line":0}},{"line":170,"address":[20954725],"length":1,"stats":{"Line":3}},{"line":171,"address":[12735304],"length":1,"stats":{"Line":3}},{"line":172,"address":[20954807,20955151],"length":1,"stats":{"Line":4}},{"line":173,"address":[12741303],"length":1,"stats":{"Line":3}},{"line":175,"address":[12735600],"length":1,"stats":{"Line":1}},{"line":176,"address":[12629546],"length":1,"stats":{"Line":1}},{"line":177,"address":[20954944],"length":1,"stats":{"Line":1}},{"line":181,"address":[12636431],"length":1,"stats":{"Line":1}},{"line":182,"address":[12735367],"length":1,"stats":{"Line":1}}],"covered":70,"coverable":102},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event","validation","utils.rs"],"content":"pub(super) fn is_hex_n(s: &str, n: usize) -> bool {\n    s.len() == n && s.chars().all(|c| c.is_ascii_hexdigit())\n}\n\npub(super) fn is_ws_url(url: &str) -> bool {\n    let lower = url.to_ascii_lowercase();\n    (lower.starts_with(\"ws://\") || lower.starts_with(\"wss://\")) && lower.len() > 5\n}\n","traces":[{"line":1,"address":[16416432],"length":1,"stats":{"Line":3}},{"line":2,"address":[22280528,22280541,22280449],"length":1,"stats":{"Line":9}},{"line":5,"address":[22176313,22176032],"length":1,"stats":{"Line":4}},{"line":6,"address":[22243825],"length":1,"stats":{"Line":4}},{"line":7,"address":[22236972,22236907,22237130],"length":1,"stats":{"Line":11}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","domain_event.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Nostr イベントのタグを表現するドメイン型。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct EventTag {\n    name: String,\n    values: Vec<String>,\n}\n\nimpl EventTag {\n    /// 新しいタグを生成する。タグ名は1文字以上である必要がある。\n    pub fn new<N: Into<String>>(name: N, values: Vec<String>) -> Result<Self, String> {\n        let name = name.into();\n        if name.trim().is_empty() {\n            return Err(\"Tag name cannot be empty\".to_string());\n        }\n        Ok(Self { name, values })\n    }\n\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    pub fn values(&self) -> &[String] {\n        &self.values\n    }\n\n    pub fn to_raw(&self) -> Vec<String> {\n        std::iter::once(self.name.clone())\n            .chain(self.values.iter().cloned())\n            .collect()\n    }\n\n    pub fn into_raw(self) -> Vec<String> {\n        std::iter::once(self.name).chain(self.values).collect()\n    }\n}\n\nimpl TryFrom<Vec<String>> for EventTag {\n    type Error = String;\n\n    fn try_from(value: Vec<String>) -> Result<Self, Self::Error> {\n        let mut iter = value.into_iter();\n        let name = iter\n            .next()\n            .ok_or_else(|| \"Tag vector must contain at least one element\".to_string())?;\n        let values: Vec<String> = iter.collect();\n        Self::new(name, values)\n    }\n}\n\nimpl From<EventTag> for Vec<String> {\n    fn from(tag: EventTag) -> Self {\n        tag.into_raw()\n    }\n}\n\n/// Application 層が扱う Nostr ドメインイベント。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct DomainEvent {\n    pub id: EventId,\n    pub author: PublicKey,\n    pub kind: EventKind,\n    pub created_at: DateTime<Utc>,\n    pub content: String,\n    pub tags: Vec<EventTag>,\n    pub signature: String,\n}\n\nimpl DomainEvent {\n    const SIGNATURE_LENGTH: usize = 128;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: EventId,\n        author: PublicKey,\n        kind: EventKind,\n        created_at: DateTime<Utc>,\n        content: String,\n        tags: Vec<EventTag>,\n        signature: String,\n    ) -> Result<Self, String> {\n        Self::validate_signature(&signature)?;\n        Ok(Self {\n            id,\n            author,\n            kind,\n            created_at,\n            content,\n            tags,\n            signature,\n        })\n    }\n\n    pub fn with_tags(mut self, tags: Vec<EventTag>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn signature(&self) -> &str {\n        &self.signature\n    }\n\n    pub fn kind(&self) -> EventKind {\n        self.kind\n    }\n\n    pub fn to_event(&self) -> Event {\n        Event {\n            id: self.id.to_hex(),\n            pubkey: self.author.as_hex().to_string(),\n            created_at: self.created_at,\n            kind: u32::from(self.kind),\n            tags: self.tags.iter().map(EventTag::to_raw).collect(),\n            content: self.content.clone(),\n            sig: self.signature.clone(),\n        }\n    }\n\n    fn validate_signature(signature: &str) -> Result<(), String> {\n        if signature.len() != Self::SIGNATURE_LENGTH {\n            return Err(\"Signature must be 128 hex characters\".to_string());\n        }\n        if !signature.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Signature must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl TryFrom<Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .into_iter()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content,\n            tags,\n            value.sig,\n        )\n    }\n}\n\nimpl TryFrom<&Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: &Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .iter()\n            .cloned()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content.clone(),\n            tags,\n            value.sig.clone(),\n        )\n    }\n}\n\nimpl From<&DomainEvent> for Event {\n    fn from(value: &DomainEvent) -> Self {\n        value.to_event()\n    }\n}\n","traces":[{"line":15,"address":[25754556,25755116,25754592,25754048],"length":1,"stats":{"Line":1}},{"line":16,"address":[25754070,25754630],"length":1,"stats":{"Line":1}},{"line":17,"address":[13609803,13609868],"length":1,"stats":{"Line":2}},{"line":18,"address":[13614096,13614050],"length":1,"stats":{"Line":0}},{"line":20,"address":[13609930],"length":1,"stats":{"Line":1}},{"line":23,"address":[13614192],"length":1,"stats":{"Line":0}},{"line":24,"address":[25755157],"length":1,"stats":{"Line":0}},{"line":27,"address":[13572160],"length":1,"stats":{"Line":0}},{"line":28,"address":[13579093],"length":1,"stats":{"Line":0}},{"line":31,"address":[13511360,13511654,13511683],"length":1,"stats":{"Line":1}},{"line":32,"address":[13497828,13497870,13497630],"length":1,"stats":{"Line":3}},{"line":33,"address":[21272838,21272668,21272883],"length":1,"stats":{"Line":2}},{"line":37,"address":[13711225,13711258,13711008],"length":1,"stats":{"Line":0}},{"line":38,"address":[25755542,25755638],"length":1,"stats":{"Line":0}},{"line":45,"address":[13572800,13573310,13573348],"length":1,"stats":{"Line":0}},{"line":46,"address":[13511985],"length":1,"stats":{"Line":0}},{"line":47,"address":[13505057,13505117,13505322],"length":1,"stats":{"Line":0}},{"line":49,"address":[13617088,13616800,13617100],"length":1,"stats":{"Line":0}},{"line":50,"address":[13616734],"length":1,"stats":{"Line":0}},{"line":51,"address":[13498609],"length":1,"stats":{"Line":0}},{"line":56,"address":[16548624],"length":1,"stats":{"Line":0}},{"line":57,"address":[16592328],"length":1,"stats":{"Line":0}},{"line":77,"address":[13580368,13581417],"length":1,"stats":{"Line":1}},{"line":86,"address":[13580537,13580464,13581119],"length":1,"stats":{"Line":2}},{"line":87,"address":[13712371],"length":1,"stats":{"Line":1}},{"line":88,"address":[21274100],"length":1,"stats":{"Line":1}},{"line":89,"address":[13617447],"length":1,"stats":{"Line":1}},{"line":92,"address":[13712266],"length":1,"stats":{"Line":1}},{"line":93,"address":[13499229],"length":1,"stats":{"Line":1}},{"line":94,"address":[13615904],"length":1,"stats":{"Line":1}},{"line":98,"address":[21274896,21275053],"length":1,"stats":{"Line":0}},{"line":99,"address":[13581472,13581554],"length":1,"stats":{"Line":0}},{"line":100,"address":[13616697],"length":1,"stats":{"Line":0}},{"line":103,"address":[25757616],"length":1,"stats":{"Line":0}},{"line":104,"address":[13506885],"length":1,"stats":{"Line":0}},{"line":107,"address":[25757632],"length":1,"stats":{"Line":0}},{"line":108,"address":[13616757],"length":1,"stats":{"Line":0}},{"line":111,"address":[13613559,13612832],"length":1,"stats":{"Line":1}},{"line":113,"address":[13612862],"length":1,"stats":{"Line":1}},{"line":114,"address":[13713249,13713325],"length":1,"stats":{"Line":2}},{"line":115,"address":[13616917],"length":1,"stats":{"Line":1}},{"line":116,"address":[13500305],"length":1,"stats":{"Line":1}},{"line":117,"address":[13500375],"length":1,"stats":{"Line":1}},{"line":118,"address":[13500496],"length":1,"stats":{"Line":1}},{"line":119,"address":[13618856],"length":1,"stats":{"Line":1}},{"line":123,"address":[13575472],"length":1,"stats":{"Line":1}},{"line":124,"address":[13617570],"length":1,"stats":{"Line":1}},{"line":125,"address":[13500985],"length":1,"stats":{"Line":0}},{"line":127,"address":[13613657,13613840,13613853],"length":1,"stats":{"Line":3}},{"line":128,"address":[13575633],"length":1,"stats":{"Line":0}},{"line":130,"address":[13613806],"length":1,"stats":{"Line":1}},{"line":137,"address":[13582688,13584168],"length":1,"stats":{"Line":0}},{"line":138,"address":[21277786,21276174,21276468,21276314],"length":1,"stats":{"Line":0}},{"line":139,"address":[25758962,25760205,25759104,25759248],"length":1,"stats":{"Line":0}},{"line":140,"address":[13515498,13515643],"length":1,"stats":{"Line":0}},{"line":141,"address":[13615172,13614613],"length":1,"stats":{"Line":0}},{"line":147,"address":[13620443],"length":1,"stats":{"Line":0}},{"line":148,"address":[13620477],"length":1,"stats":{"Line":0}},{"line":150,"address":[13576821],"length":1,"stats":{"Line":0}},{"line":151,"address":[13509038],"length":1,"stats":{"Line":0}},{"line":152,"address":[13516046],"length":1,"stats":{"Line":0}},{"line":153,"address":[25759790],"length":1,"stats":{"Line":0}},{"line":161,"address":[13615920,13617487,13617693],"length":1,"stats":{"Line":0}},{"line":162,"address":[13716332,13716549],"length":1,"stats":{"Line":0}},{"line":163,"address":[13623262,13621890,13622057,13621736],"length":1,"stats":{"Line":0}},{"line":164,"address":[13503736,13503884],"length":1,"stats":{"Line":0}},{"line":165,"address":[25761757,25761331],"length":1,"stats":{"Line":0}},{"line":172,"address":[13616880],"length":1,"stats":{"Line":0}},{"line":173,"address":[13620864],"length":1,"stats":{"Line":0}},{"line":175,"address":[25761669],"length":1,"stats":{"Line":0}},{"line":176,"address":[13579027,13578889],"length":1,"stats":{"Line":0}},{"line":177,"address":[13622731],"length":1,"stats":{"Line":0}},{"line":178,"address":[13504491],"length":1,"stats":{"Line":0}},{"line":184,"address":[18992896],"length":1,"stats":{"Line":0}},{"line":185,"address":[18998497],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":75},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","mod.rs"],"content":"pub mod domain_event;\npub mod profile_metadata;\n\npub use domain_event::{DomainEvent, EventTag};\npub use profile_metadata::{PrivacyPreferences, ProfileMetadata, RelayEndpoint};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","profile_metadata.rs"],"content":"use nostr_sdk::prelude::Url;\nuse serde::{Deserialize, Serialize};\n\n/// NIP-65 Relay Listエントリ。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct RelayEndpoint {\n    pub url: String,\n    pub read: bool,\n    pub write: bool,\n}\n\nimpl RelayEndpoint {\n    pub fn new(url: String, read: bool, write: bool) -> Result<Self, String> {\n        Self::validate_url(&url)?;\n        Ok(Self { url, read, write })\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        Self::validate_url(&self.url)\n    }\n\n    fn validate_url(value: &str) -> Result<(), String> {\n        if value.is_empty() {\n            return Err(\"Relay URL must not be empty\".to_string());\n        }\n        let parsed =\n            Url::parse(value).map_err(|_| \"Relay URL must be a valid websocket URL\".to_string())?;\n        match parsed.scheme() {\n            \"ws\" | \"wss\" => Ok(()),\n            _ => Err(\"Relay URL must use ws:// or wss://\".to_string()),\n        }\n    }\n}\n\n/// プロフィール更新時に利用するメタデータ。\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]\npub struct ProfileMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub website: Option<String>,\n    pub relays: Option<Vec<RelayEndpoint>>,\n    pub privacy: Option<PrivacyPreferences>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct PrivacyPreferences {\n    pub public_profile: bool,\n    pub show_online_status: bool,\n}\n\nimpl ProfileMetadata {\n    const NAME_LIMIT: usize = 100;\n    const DISPLAY_NAME_LIMIT: usize = 100;\n    const ABOUT_LIMIT: usize = 1_000;\n    const URL_LIMIT: usize = 1_024;\n    const MAX_RELAYS: usize = 64;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n        picture: Option<String>,\n        banner: Option<String>,\n        nip05: Option<String>,\n        lud16: Option<String>,\n        website: Option<String>,\n        relays: Option<Vec<RelayEndpoint>>,\n        privacy: Option<PrivacyPreferences>,\n    ) -> Result<Self, String> {\n        let metadata = Self {\n            name,\n            display_name,\n            about,\n            picture,\n            banner,\n            nip05,\n            lud16,\n            website,\n            relays,\n            privacy,\n        };\n        metadata.validate()?;\n        Ok(metadata)\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if let Some(name) = self.name.as_ref() {\n            if name.chars().count() > Self::NAME_LIMIT {\n                return Err(format!(\n                    \"Name is too long (max {} characters)\",\n                    Self::NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(display_name) = self.display_name.as_ref() {\n            if display_name.chars().count() > Self::DISPLAY_NAME_LIMIT {\n                return Err(format!(\n                    \"Display name is too long (max {} characters)\",\n                    Self::DISPLAY_NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(about) = self.about.as_ref() {\n            if about.chars().count() > Self::ABOUT_LIMIT {\n                return Err(format!(\n                    \"About is too long (max {} characters)\",\n                    Self::ABOUT_LIMIT\n                ));\n            }\n        }\n\n        if let Some(picture) = self.picture.as_ref() {\n            Self::validate_url_length(picture, \"Picture\")?;\n        }\n\n        if let Some(banner) = self.banner.as_ref() {\n            Self::validate_url_length(banner, \"Banner\")?;\n        }\n\n        if let Some(website) = self.website.as_ref() {\n            Self::validate_url_length(website, \"Website\")?;\n        }\n\n        if let Some(relays) = self.relays.as_ref() {\n            if relays.len() > Self::MAX_RELAYS {\n                return Err(format!(\n                    \"Relay list is too long (max {} entries)\",\n                    Self::MAX_RELAYS\n                ));\n            }\n            for relay in relays {\n                relay.validate()?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn validate_url_length(value: &str, field: &str) -> Result<(), String> {\n        if value.chars().count() > Self::URL_LIMIT {\n            return Err(format!(\n                \"{} URL is too long (max {} characters)\",\n                field,\n                Self::URL_LIMIT\n            ));\n        }\n        Ok(())\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.name.is_none()\n            && self.display_name.is_none()\n            && self.about.is_none()\n            && self.picture.is_none()\n            && self.banner.is_none()\n            && self.nip05.is_none()\n            && self.lud16.is_none()\n            && self.website.is_none()\n            && self.relays.as_ref().is_none_or(|relays| relays.is_empty())\n            && self.privacy.is_none()\n    }\n}\n","traces":[{"line":13,"address":[19776239,19775808],"length":1,"stats":{"Line":1}},{"line":14,"address":[20955347,20955579,20955275],"length":1,"stats":{"Line":2}},{"line":15,"address":[19744836],"length":1,"stats":{"Line":2}},{"line":18,"address":[19781856],"length":1,"stats":{"Line":1}},{"line":19,"address":[19745120],"length":1,"stats":{"Line":1}},{"line":22,"address":[19677392,19678174],"length":1,"stats":{"Line":1}},{"line":23,"address":[19780331],"length":1,"stats":{"Line":2}},{"line":24,"address":[19780447],"length":1,"stats":{"Line":0}},{"line":26,"address":[19745987,19745230,19745386,19745602,19745968],"length":1,"stats":{"Line":4}},{"line":28,"address":[19780700,19780847],"length":1,"stats":{"Line":4}},{"line":29,"address":[19671007],"length":1,"stats":{"Line":2}},{"line":30,"address":[13918623],"length":1,"stats":{"Line":0}},{"line":64,"address":[19671280,19671839],"length":1,"stats":{"Line":1}},{"line":88,"address":[19878038,19877860,19877925],"length":1,"stats":{"Line":2}},{"line":89,"address":[19739507],"length":1,"stats":{"Line":1}},{"line":92,"address":[19678848],"length":1,"stats":{"Line":1}},{"line":93,"address":[13919430],"length":1,"stats":{"Line":1}},{"line":94,"address":[19783464],"length":1,"stats":{"Line":1}},{"line":95,"address":[20957366],"length":1,"stats":{"Line":0}},{"line":102,"address":[19783712,19783502],"length":1,"stats":{"Line":1}},{"line":103,"address":[13919744],"length":1,"stats":{"Line":0}},{"line":104,"address":[19782174],"length":1,"stats":{"Line":0}},{"line":111,"address":[19746998,19747224],"length":1,"stats":{"Line":1}},{"line":112,"address":[19665720],"length":1,"stats":{"Line":0}},{"line":113,"address":[20957912],"length":1,"stats":{"Line":0}},{"line":120,"address":[19747506,19747280],"length":1,"stats":{"Line":1}},{"line":121,"address":[20958251,20958098],"length":1,"stats":{"Line":0}},{"line":124,"address":[19740821,19740690],"length":1,"stats":{"Line":1}},{"line":125,"address":[19747765,19747921],"length":1,"stats":{"Line":0}},{"line":128,"address":[20958436,20958569],"length":1,"stats":{"Line":1}},{"line":129,"address":[19673428,19673275],"length":1,"stats":{"Line":0}},{"line":132,"address":[19673371,19673502],"length":1,"stats":{"Line":2}},{"line":133,"address":[19666739],"length":1,"stats":{"Line":1}},{"line":134,"address":[19666808],"length":1,"stats":{"Line":0}},{"line":139,"address":[13921282,13921085],"length":1,"stats":{"Line":2}},{"line":140,"address":[19748569],"length":1,"stats":{"Line":1}},{"line":144,"address":[19783398],"length":1,"stats":{"Line":1}},{"line":147,"address":[20959296],"length":1,"stats":{"Line":0}},{"line":148,"address":[19748805],"length":1,"stats":{"Line":0}},{"line":149,"address":[19785620],"length":1,"stats":{"Line":0}},{"line":155,"address":[19880386],"length":1,"stats":{"Line":0}},{"line":158,"address":[19780256],"length":1,"stats":{"Line":0}},{"line":159,"address":[19880637],"length":1,"stats":{"Line":0}},{"line":160,"address":[19880661],"length":1,"stats":{"Line":0}},{"line":161,"address":[19785897],"length":1,"stats":{"Line":0}},{"line":162,"address":[19780333],"length":1,"stats":{"Line":0}},{"line":163,"address":[19784289],"length":1,"stats":{"Line":0}},{"line":164,"address":[19681429],"length":1,"stats":{"Line":0}},{"line":165,"address":[19784329],"length":1,"stats":{"Line":0}},{"line":166,"address":[19880787],"length":1,"stats":{"Line":0}},{"line":167,"address":[20959888,20959897,20959821],"length":1,"stats":{"Line":0}},{"line":168,"address":[20959854],"length":1,"stats":{"Line":0}}],"covered":26,"coverable":52},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","mod.rs"],"content":"pub mod account;\npub mod bookmark;\npub mod direct_message;\npub mod event;\npub mod event_gateway;\npub mod offline;\npub mod pending_topic;\npub mod post;\npub mod profile_avatar;\npub mod topic;\npub mod topic_metrics;\npub mod user;\n\npub use account::{AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret};\npub use bookmark::Bookmark;\npub use direct_message::{DirectMessage, MessageDirection, NewDirectMessage};\npub use event::{Event, EventKind};\npub use event_gateway::{DomainEvent, EventTag, ProfileMetadata};\npub use offline::{\n    CacheMetadataRecord, CacheStatusSnapshot, CacheTypeStatus, OfflineActionDraft,\n    OfflineActionFilter, OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord,\n    SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusRecord,\n    SyncStatusUpdate,\n};\npub use pending_topic::{PendingTopic, PendingTopicStatus};\npub use post::Post;\npub use profile_avatar::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry};\npub use topic::{Topic, TopicVisibility};\npub use topic_metrics::{\n    MetricsWindow, ScoreWeights, TopicActivityRow, TopicMetricsRecord, TopicMetricsSnapshot,\n    TopicMetricsUpsert,\n};\npub use user::{User, UserMetadata, UserProfile};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_metadata.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataRecord {\n    pub record_id: i64,\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub last_accessed_at: Option<DateTime<Utc>>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<DateTime<Utc>>,\n    pub metadata: Option<Value>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_status.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheTypeStatus {\n    pub cache_type: CacheType,\n    pub item_count: u64,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub is_stale: bool,\n    pub metadata: Option<Value>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheStatusSnapshot {\n    pub total_items: u64,\n    pub stale_items: u64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\nimpl CacheStatusSnapshot {\n    pub fn new(total_items: u64, stale_items: u64, cache_types: Vec<CacheTypeStatus>) -> Self {\n        Self {\n            total_items,\n            stale_items,\n            cache_types,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataUpdate {\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub metadata: Option<Value>,\n    pub expiry: Option<DateTime<Utc>>,\n    pub is_stale: Option<bool>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n","traces":[{"line":26,"address":[12966064],"length":1,"stats":{"Line":2}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","commands.rs"],"content":"use crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// オフラインアクションを保存する際に使用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionDraft {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n}\n\nimpl OfflineActionDraft {\n    pub fn new(\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        }\n    }\n}\n\n/// オフラインアクション取得時のフィルタ。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct OfflineActionFilter {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\nimpl OfflineActionFilter {\n    pub fn new(\n        user_pubkey: Option<PublicKey>,\n        include_synced: Option<bool>,\n        limit: Option<u32>,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            include_synced,\n            limit,\n        }\n    }\n}\n\n/// 同期キューに追加する際のドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItemDraft {\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub priority: Option<u8>,\n}\n\nimpl SyncQueueItemDraft {\n    pub fn new(\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        priority: Option<u8>,\n    ) -> Self {\n        Self {\n            action_type,\n            payload,\n            priority,\n        }\n    }\n}\n\n/// 楽観的更新の保存に利用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateDraft {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n}\n\nimpl OptimisticUpdateDraft {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        original_data: Option<OfflinePayload>,\n        updated_data: OfflinePayload,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            original_data,\n            updated_data,\n        }\n    }\n}\n\n/// 同期状態の更新に使用するコマンド。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusUpdate {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl SyncStatusUpdate {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        sync_status: SyncStatus,\n        conflict_data: Option<OfflinePayload>,\n        updated_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            sync_status,\n            conflict_data,\n            updated_at,\n        }\n    }\n}\n","traces":[{"line":18,"address":[11068848],"length":1,"stats":{"Line":2}},{"line":42,"address":[16932944],"length":1,"stats":{"Line":2}},{"line":64,"address":[16828480],"length":1,"stats":{"Line":2}},{"line":87,"address":[16896352],"length":1,"stats":{"Line":1}},{"line":113,"address":[16889536],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","mod.rs"],"content":"pub mod cache_metadata;\npub mod cache_status;\npub mod commands;\npub mod offline_action;\npub mod optimistic_update;\npub mod saved_action;\npub mod sync_queue_item;\npub mod sync_result;\npub mod sync_status_record;\n\npub use cache_metadata::CacheMetadataRecord;\npub use cache_status::{CacheMetadataUpdate, CacheStatusSnapshot, CacheTypeStatus};\npub use commands::{\n    OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft, SyncQueueItemDraft,\n    SyncStatusUpdate,\n};\npub use offline_action::OfflineActionRecord;\npub use optimistic_update::OptimisticUpdateRecord;\npub use saved_action::SavedOfflineAction;\npub use sync_queue_item::SyncQueueItem;\npub use sync_result::SyncResult;\npub use sync_status_record::SyncStatusRecord;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","offline_action.rs"],"content":"use crate::domain::value_objects::{\n    EntityId, OfflineActionId, OfflineActionType, OfflinePayload, PublicKey, RemoteEventId,\n    SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionRecord {\n    pub record_id: Option<i64>,\n    pub action_id: OfflineActionId,\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n    pub remote_id: Option<RemoteEventId>,\n    pub sync_status: SyncStatus,\n    pub created_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl OfflineActionRecord {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        record_id: Option<i64>,\n        action_id: OfflineActionId,\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n        sync_status: SyncStatus,\n        created_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) -> Self {\n        Self {\n            record_id,\n            action_id,\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n            remote_id,\n            sync_status,\n            created_at,\n            synced_at,\n            error_message: None,\n        }\n    }\n\n    pub fn with_error_message(mut self, message: Option<String>) -> Self {\n        self.error_message = message;\n        self\n    }\n\n    pub fn mark_synced(\n        &mut self,\n        status: SyncStatus,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) {\n        self.sync_status = status;\n        self.synced_at = synced_at;\n        self.remote_id = remote_id;\n    }\n}\n","traces":[{"line":25,"address":[21438048],"length":1,"stats":{"Line":3}},{"line":52,"address":[21363855,21363680],"length":1,"stats":{"Line":0}},{"line":53,"address":[21370688,21370779],"length":1,"stats":{"Line":0}},{"line":54,"address":[21431643],"length":1,"stats":{"Line":0}},{"line":57,"address":[20525872,20525568,20525894],"length":1,"stats":{"Line":0}},{"line":63,"address":[21357132],"length":1,"stats":{"Line":0}},{"line":64,"address":[21431854],"length":1,"stats":{"Line":0}},{"line":65,"address":[21570353],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","optimistic_update.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, OptimisticUpdateId};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateRecord {\n    pub record_id: i64,\n    pub update_id: OptimisticUpdateId,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n    pub is_confirmed: bool,\n    pub created_at: DateTime<Utc>,\n    pub confirmed_at: Option<DateTime<Utc>>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","saved_action.rs"],"content":"use super::OfflineActionRecord;\nuse crate::domain::value_objects::OfflineActionId;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SavedOfflineAction {\n    pub local_id: OfflineActionId,\n    pub action: OfflineActionRecord,\n}\n\nimpl SavedOfflineAction {\n    pub fn new(local_id: OfflineActionId, action: OfflineActionRecord) -> Self {\n        Self { local_id, action }\n    }\n}\n","traces":[{"line":12,"address":[19289408],"length":1,"stats":{"Line":3}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_queue_item.rs"],"content":"use crate::domain::value_objects::{\n    OfflineActionType, OfflinePayload, SyncQueueId, SyncQueueStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItem {\n    pub id: SyncQueueId,\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub status: SyncQueueStatus,\n    pub retry_count: u32,\n    pub max_retries: u32,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl SyncQueueItem {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: SyncQueueId,\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        status: SyncQueueStatus,\n        retry_count: u32,\n        max_retries: u32,\n        created_at: DateTime<Utc>,\n        updated_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        error_message: Option<String>,\n    ) -> Self {\n        Self {\n            id,\n            action_type,\n            payload,\n            status,\n            retry_count,\n            max_retries,\n            created_at,\n            updated_at,\n            synced_at,\n            error_message,\n        }\n    }\n}\n","traces":[{"line":23,"address":[23077808],"length":1,"stats":{"Line":3}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_result.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct SyncResult {\n    pub synced_count: u32,\n    pub failed_count: u32,\n    pub pending_count: u32,\n}\n\nimpl SyncResult {\n    pub fn new(synced_count: u32, failed_count: u32, pending_count: u32) -> Self {\n        Self {\n            synced_count,\n            failed_count,\n            pending_count,\n        }\n    }\n}\n","traces":[{"line":11,"address":[14393600],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_status_record.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, SyncStatus};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusRecord {\n    pub record_id: i64,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: DateTime<Utc>,\n    pub last_remote_sync: Option<DateTime<Utc>>,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","pending_topic.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum PendingTopicStatus {\n    #[serde(rename = \"queued\")]\n    Queued,\n    #[serde(rename = \"synced\")]\n    Synced,\n    #[serde(rename = \"failed\")]\n    Failed,\n}\n\nimpl PendingTopicStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            PendingTopicStatus::Queued => \"queued\",\n            PendingTopicStatus::Synced => \"synced\",\n            PendingTopicStatus::Failed => \"failed\",\n        }\n    }\n\n    pub fn from_value(value: &str) -> Self {\n        match value {\n            \"synced\" => PendingTopicStatus::Synced,\n            \"failed\" => PendingTopicStatus::Failed,\n            _ => PendingTopicStatus::Queued,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PendingTopic {\n    pub pending_id: String,\n    pub user_pubkey: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub status: PendingTopicStatus,\n    pub offline_action_id: String,\n    pub synced_topic_id: Option<String>,\n    pub error_message: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl PendingTopic {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        pending_id: String,\n        user_pubkey: String,\n        name: String,\n        description: Option<String>,\n        status: PendingTopicStatus,\n        offline_action_id: String,\n        synced_topic_id: Option<String>,\n        error_message: Option<String>,\n        created_at: DateTime<Utc>,\n        updated_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            pending_id,\n            user_pubkey,\n            name,\n            description,\n            status,\n            offline_action_id,\n            synced_topic_id,\n            error_message,\n            created_at,\n            updated_at,\n        }\n    }\n\n    pub fn with_status(mut self, status: PendingTopicStatus) -> Self {\n        self.status = status;\n        self.updated_at = Utc::now();\n        self\n    }\n}\n","traces":[{"line":15,"address":[22275520],"length":1,"stats":{"Line":0}},{"line":16,"address":[22375893],"length":1,"stats":{"Line":0}},{"line":17,"address":[22275557],"length":1,"stats":{"Line":0}},{"line":18,"address":[22279516],"length":1,"stats":{"Line":0}},{"line":19,"address":[22275603],"length":1,"stats":{"Line":0}},{"line":23,"address":[22237536],"length":1,"stats":{"Line":0}},{"line":25,"address":[22275724,22275671],"length":1,"stats":{"Line":0}},{"line":26,"address":[16417301,16417338],"length":1,"stats":{"Line":0}},{"line":27,"address":[22275731],"length":1,"stats":{"Line":0}},{"line":48,"address":[22169840],"length":1,"stats":{"Line":0}},{"line":74,"address":[22376544,22376416],"length":1,"stats":{"Line":0}},{"line":75,"address":[22163368],"length":1,"stats":{"Line":0}},{"line":76,"address":[22276078,22276134],"length":1,"stats":{"Line":0}},{"line":77,"address":[17045352],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","post.rs"],"content":"use super::user::User;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Post {\n    pub id: String,\n    pub content: String,\n    pub author: User,\n    pub topic_id: String,\n    pub created_at: DateTime<Utc>,\n    pub tags: Vec<String>,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: Vec<Post>,\n    pub is_synced: bool,\n    pub is_boosted: bool,\n    pub is_bookmarked: bool,\n    pub scope: Option<String>,\n    pub epoch: Option<i64>,\n    pub is_encrypted: bool,\n    pub local_id: Option<String>,\n    pub event_id: Option<String>,\n}\n\nimpl Post {\n    pub fn new(content: String, author: User, topic_id: String) -> Self {\n        let id = uuid::Uuid::new_v4().to_string();\n        let local_id = id.clone();\n\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at: chrono::Utc::now(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: Some(local_id),\n            event_id: None,\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn mark_as_synced(&mut self, event_id: String) {\n        self.is_synced = true;\n        self.event_id = Some(event_id);\n    }\n\n    pub fn add_reply(&mut self, reply: Post) {\n        self.replies.push(reply);\n    }\n\n    pub fn increment_likes(&mut self) {\n        self.likes += 1;\n    }\n\n    pub fn decrement_likes(&mut self) {\n        if self.likes > 0 {\n            self.likes -= 1;\n        }\n    }\n\n    pub fn increment_boosts(&mut self) {\n        self.boosts += 1;\n        self.is_boosted = true;\n    }\n\n    pub fn toggle_bookmark(&mut self) {\n        self.is_bookmarked = !self.is_bookmarked;\n    }\n\n    pub fn new_with_id(\n        id: String,\n        content: String,\n        author: User,\n        topic_id: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at,\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    pub fn mark_as_unsynced(&mut self) {\n        self.is_synced = false;\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostDraft {\n    pub id: String,\n    pub content: String,\n    pub topic_id: String,\n    pub tags: Vec<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl PostDraft {\n    pub fn new(content: String, topic_id: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            content,\n            topic_id,\n            tags: Vec::new(),\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn update_content(&mut self, content: String) {\n        self.content = content;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn into_post(self, author: User) -> Post {\n        Post::new(self.content, author, self.topic_id).with_tags(self.tags)\n    }\n}\n","traces":[{"line":27,"address":[18048689,18047408,18048540],"length":1,"stats":{"Line":2}},{"line":28,"address":[14337377,14337264],"length":1,"stats":{"Line":4}},{"line":29,"address":[14432190],"length":1,"stats":{"Line":2}},{"line":36,"address":[14293907],"length":1,"stats":{"Line":2}},{"line":37,"address":[14432450],"length":1,"stats":{"Line":2}},{"line":40,"address":[21994373],"length":1,"stats":{"Line":1}},{"line":47,"address":[21994468],"length":1,"stats":{"Line":2}},{"line":52,"address":[14433344,14433519],"length":1,"stats":{"Line":0}},{"line":53,"address":[14301824,14301915],"length":1,"stats":{"Line":0}},{"line":54,"address":[14337067],"length":1,"stats":{"Line":0}},{"line":57,"address":[14220480,14220565],"length":1,"stats":{"Line":1}},{"line":58,"address":[18048926],"length":1,"stats":{"Line":1}},{"line":59,"address":[14302021,14302116],"length":1,"stats":{"Line":2}},{"line":62,"address":[14302160],"length":1,"stats":{"Line":0}},{"line":63,"address":[14234405],"length":1,"stats":{"Line":0}},{"line":66,"address":[21995648],"length":1,"stats":{"Line":0}},{"line":67,"address":[14227469,14227506],"length":1,"stats":{"Line":0}},{"line":70,"address":[21995728],"length":1,"stats":{"Line":0}},{"line":71,"address":[14339108,14339054],"length":1,"stats":{"Line":0}},{"line":72,"address":[14337425,14337462],"length":1,"stats":{"Line":0}},{"line":76,"address":[14234608],"length":1,"stats":{"Line":0}},{"line":77,"address":[14433933,14433977],"length":1,"stats":{"Line":0}},{"line":78,"address":[14295485],"length":1,"stats":{"Line":0}},{"line":81,"address":[14339216],"length":1,"stats":{"Line":0}},{"line":82,"address":[14295525],"length":1,"stats":{"Line":0}},{"line":85,"address":[14302480,14303252,14303309],"length":1,"stats":{"Line":1}},{"line":98,"address":[21996058],"length":1,"stats":{"Line":1}},{"line":101,"address":[14339433],"length":1,"stats":{"Line":1}},{"line":113,"address":[14434880],"length":1,"stats":{"Line":1}},{"line":114,"address":[14303333],"length":1,"stats":{"Line":1}},{"line":129,"address":[14228608,14229065,14229137],"length":1,"stats":{"Line":0}},{"line":130,"address":[14235611],"length":1,"stats":{"Line":0}},{"line":132,"address":[14228724],"length":1,"stats":{"Line":0}},{"line":135,"address":[14296635],"length":1,"stats":{"Line":0}},{"line":141,"address":[14435456,14435513],"length":1,"stats":{"Line":0}},{"line":142,"address":[14236162,14236236],"length":1,"stats":{"Line":0}},{"line":143,"address":[14304019],"length":1,"stats":{"Line":0}},{"line":146,"address":[14335248,14335509,14335490],"length":1,"stats":{"Line":0}},{"line":147,"address":[21997541,21997683],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","profile_avatar.rs"],"content":"use std::str::FromStr;\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// プロフィールアバターの共有範囲\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ProfileAvatarAccessLevel {\n    #[default]\n    Public,\n    ContactsOnly,\n    Private,\n}\n\nimpl ProfileAvatarAccessLevel {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            ProfileAvatarAccessLevel::Public => \"public\",\n            ProfileAvatarAccessLevel::ContactsOnly => \"contacts_only\",\n            ProfileAvatarAccessLevel::Private => \"private\",\n        }\n    }\n}\n\nimpl FromStr for ProfileAvatarAccessLevel {\n    type Err = &'static str;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"public\" => Ok(ProfileAvatarAccessLevel::Public),\n            \"contacts_only\" => Ok(ProfileAvatarAccessLevel::ContactsOnly),\n            \"private\" => Ok(ProfileAvatarAccessLevel::Private),\n            _ => Err(\"invalid access level\"),\n        }\n    }\n}\n\n/// Doc に保存するプロフィールアバターのメタデータ\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileAvatarDocEntry {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub encrypted_key: String,\n    pub key_nonce: String,\n    pub encryption_nonce: String,\n    pub content_sha256: String,\n    pub updated_at: DateTime<Utc>,\n    pub version: u64,\n}\n","traces":[{"line":17,"address":[23786736],"length":1,"stats":{"Line":2}},{"line":18,"address":[23712005],"length":1,"stats":{"Line":2}},{"line":19,"address":[23817957],"length":1,"stats":{"Line":1}},{"line":20,"address":[23719036],"length":1,"stats":{"Line":1}},{"line":21,"address":[23918371],"length":1,"stats":{"Line":0}},{"line":29,"address":[23823632],"length":1,"stats":{"Line":2}},{"line":31,"address":[23918464,23918522],"length":1,"stats":{"Line":3}},{"line":32,"address":[23822062,23822148],"length":1,"stats":{"Line":2}},{"line":33,"address":[23818263,23818184],"length":1,"stats":{"Line":0}},{"line":34,"address":[23818238],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","topic.rs"],"content":"use crate::domain::constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\npub enum TopicVisibility {\n    #[default]\n    Public,\n    Private,\n}\n\nimpl TopicVisibility {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            TopicVisibility::Public => \"public\",\n            TopicVisibility::Private => \"private\",\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Topic {\n    pub id: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub is_joined: bool,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub visibility: TopicVisibility,\n    pub owner: Option<String>,\n    pub image_url: Option<String>,\n}\n\nimpl Topic {\n    pub fn new(name: String, description: Option<String>) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            name,\n            description,\n            created_at: now,\n            updated_at: now,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn public_topic() -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            name: \"#public\".to_string(),\n            description: Some(\"公開タイムライン\".to_string()),\n            created_at: now,\n            updated_at: now,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn join(&mut self) {\n        self.is_joined = true;\n        self.member_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn leave(&mut self) {\n        self.is_joined = false;\n        if self.member_count > 0 {\n            self.member_count -= 1;\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn increment_post_count(&mut self) {\n        self.post_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn decrement_post_count(&mut self) {\n        if self.post_count > 0 {\n            self.post_count -= 1;\n            self.updated_at = chrono::Utc::now();\n        }\n    }\n\n    pub fn update_description(&mut self, description: String) {\n        self.description = Some(description);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn set_owner(&mut self, owner: String) {\n        self.owner = Some(owner);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn new_with_id(\n        id: String,\n        name: String,\n        description: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            name,\n            description: Some(description),\n            created_at,\n            updated_at: created_at,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            visibility: TopicVisibility::Public,\n            owner: None,\n            image_url: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStats {\n    pub topic_id: String,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub active_members: u32,\n    pub posts_today: u32,\n    pub last_activity: Option<i64>,\n}\n\nimpl TopicStats {\n    pub fn new(topic_id: String) -> Self {\n        Self {\n            topic_id,\n            member_count: 0,\n            post_count: 0,\n            active_members: 0,\n            posts_today: 0,\n            last_activity: None,\n        }\n    }\n}\n","traces":[{"line":13,"address":[13505024],"length":1,"stats":{"Line":0}},{"line":14,"address":[13617733],"length":1,"stats":{"Line":0}},{"line":15,"address":[13718114],"length":1,"stats":{"Line":0}},{"line":16,"address":[21280041],"length":1,"stats":{"Line":0}},{"line":37,"address":[13623392,13623885,13623910],"length":1,"stats":{"Line":1}},{"line":38,"address":[13621771],"length":1,"stats":{"Line":1}},{"line":40,"address":[13586708],"length":1,"stats":{"Line":1}},{"line":54,"address":[13519408,13519937],"length":1,"stats":{"Line":0}},{"line":55,"address":[13622305],"length":1,"stats":{"Line":0}},{"line":57,"address":[13505679],"length":1,"stats":{"Line":0}},{"line":58,"address":[13587235],"length":1,"stats":{"Line":0}},{"line":59,"address":[13718849,13718925],"length":1,"stats":{"Line":0}},{"line":71,"address":[13624496],"length":1,"stats":{"Line":0}},{"line":72,"address":[13624510],"length":1,"stats":{"Line":0}},{"line":73,"address":[13622945,13622869],"length":1,"stats":{"Line":0}},{"line":74,"address":[13719334],"length":1,"stats":{"Line":0}},{"line":77,"address":[26508144],"length":1,"stats":{"Line":0}},{"line":78,"address":[13619054],"length":1,"stats":{"Line":0}},{"line":79,"address":[13520209,13520117],"length":1,"stats":{"Line":0}},{"line":80,"address":[26508222,26508259],"length":1,"stats":{"Line":0}},{"line":82,"address":[13624654],"length":1,"stats":{"Line":0}},{"line":85,"address":[21281456],"length":1,"stats":{"Line":0}},{"line":86,"address":[13719642,13719566],"length":1,"stats":{"Line":0}},{"line":87,"address":[13719599],"length":1,"stats":{"Line":0}},{"line":90,"address":[13624880],"length":1,"stats":{"Line":0}},{"line":91,"address":[21281674,21281582],"length":1,"stats":{"Line":0}},{"line":92,"address":[13506625,13506700],"length":1,"stats":{"Line":0}},{"line":93,"address":[21281636],"length":1,"stats":{"Line":0}},{"line":97,"address":[13623429,13623360],"length":1,"stats":{"Line":0}},{"line":98,"address":[13588340,13588254],"length":1,"stats":{"Line":0}},{"line":99,"address":[13619551],"length":1,"stats":{"Line":0}},{"line":102,"address":[26508773,26508704],"length":1,"stats":{"Line":0}},{"line":103,"address":[13720068,13719982],"length":1,"stats":{"Line":0}},{"line":104,"address":[13720095],"length":1,"stats":{"Line":0}},{"line":107,"address":[13507072],"length":1,"stats":{"Line":0}},{"line":116,"address":[13520835],"length":1,"stats":{"Line":0}},{"line":140,"address":[13720416],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","topic_metrics.rs"],"content":"use serde::Serialize;\n\n#[derive(Debug, Clone, Copy, Serialize)]\npub struct MetricsWindow {\n    pub start: i64,\n    pub end: i64,\n}\n\nimpl MetricsWindow {\n    pub fn new(start: i64, end: i64) -> Self {\n        Self { start, end }\n    }\n\n    pub fn duration_millis(&self) -> i64 {\n        self.end.saturating_sub(self.start)\n    }\n}\n\n#[derive(Debug, Clone, Copy, Serialize)]\npub struct ScoreWeights {\n    pub posts: f64,\n    pub unique_authors: f64,\n    pub boosts: f64,\n}\n\nimpl Default for ScoreWeights {\n    fn default() -> Self {\n        Self {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        }\n    }\n}\n\nimpl ScoreWeights {\n    pub fn score(&self, posts: i64, unique_authors: i64, boosts: i64) -> f64 {\n        (posts as f64 * self.posts)\n            + (unique_authors as f64 * self.unique_authors)\n            + (boosts as f64 * self.boosts)\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicActivityRow {\n    pub topic_id: String,\n    pub posts_count: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n}\n\nimpl TopicActivityRow {\n    pub fn empty(topic_id: impl Into<String>) -> Self {\n        Self {\n            topic_id: topic_id.into(),\n            posts_count: 0,\n            unique_authors: 0,\n            boosts: 0,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsUpsert {\n    pub topic_id: String,\n    pub window_start: i64,\n    pub window_end: i64,\n    pub posts_24h: i64,\n    pub posts_6h: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n    pub score_24h: f64,\n    pub score_6h: f64,\n    pub updated_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsRecord {\n    pub topic_id: String,\n    pub window_start: i64,\n    pub window_end: i64,\n    pub posts_24h: i64,\n    pub posts_6h: i64,\n    pub unique_authors: i64,\n    pub boosts: i64,\n    pub replies: i64,\n    pub bookmarks: i64,\n    pub participant_delta: i64,\n    pub score_24h: f64,\n    pub score_6h: f64,\n    pub updated_at: i64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct TopicMetricsSnapshot {\n    pub window_start: i64,\n    pub window_end: i64,\n    pub metrics: Vec<TopicMetricsRecord>,\n}\n","traces":[{"line":10,"address":[12836128],"length":1,"stats":{"Line":0}},{"line":14,"address":[12735792],"length":1,"stats":{"Line":0}},{"line":15,"address":[12741381],"length":1,"stats":{"Line":0}},{"line":27,"address":[12636928],"length":1,"stats":{"Line":1}},{"line":37,"address":[12697808],"length":1,"stats":{"Line":0}},{"line":38,"address":[12697861,12697847,12697828],"length":1,"stats":{"Line":0}},{"line":39,"address":[12739885],"length":1,"stats":{"Line":0}},{"line":40,"address":[12630043],"length":1,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}}],"covered":1,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","user.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n// UserProfile for compatibility with SqliteRepository\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct UserProfile {\n    pub display_name: String,\n    pub bio: String,\n    pub avatar_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct User {\n    pub npub: String,\n    pub pubkey: String,\n    pub profile: UserProfile,\n    pub name: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub public_profile: bool,\n    pub show_online_status: bool,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl User {\n    pub fn new(npub: String, pubkey: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            npub,\n            pubkey,\n            profile: UserProfile {\n                display_name: String::new(),\n                bio: String::new(),\n                avatar_url: None,\n            },\n            name: None,\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn with_profile(\n        mut self,\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n    ) -> Self {\n        self.name = name;\n        self.profile.display_name = display_name.unwrap_or_default();\n        self.profile.bio = about.unwrap_or_default();\n        self.updated_at = chrono::Utc::now();\n        self\n    }\n\n    pub fn update_metadata(&mut self, metadata: UserMetadata) {\n        if let Some(name) = metadata.name {\n            self.name = Some(name);\n        }\n        if let Some(display_name) = metadata.display_name {\n            self.profile.display_name = display_name;\n        }\n        if let Some(about) = metadata.about {\n            self.profile.bio = about;\n        }\n        if let Some(picture) = metadata.picture {\n            self.profile.avatar_url = Some(picture);\n        }\n        if let Some(nip05) = metadata.nip05 {\n            self.nip05 = Some(nip05);\n        }\n        if let Some(lud16) = metadata.lud16 {\n            self.lud16 = Some(lud16);\n        }\n        if let Some(public_profile) = metadata.public_profile {\n            self.public_profile = public_profile;\n        }\n        if let Some(show_online_status) = metadata.show_online_status {\n            self.show_online_status = show_online_status;\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn pubkey(&self) -> &str {\n        &self.pubkey\n    }\n\n    pub fn npub(&self) -> &str {\n        &self.npub\n    }\n\n    pub fn from_pubkey(pubkey: &str) -> Self {\n        use nostr_sdk::prelude::*;\n\n        let npub = PublicKey::from_hex(pubkey)\n            .ok()\n            .and_then(|pk| pk.to_bech32().ok())\n            .unwrap_or_else(|| pubkey.to_string());\n\n        Self::new(npub, pubkey.to_string())\n    }\n\n    pub fn new_with_profile(npub: String, profile: UserProfile) -> Self {\n        let mut user = Self::new(npub.clone(), String::new());\n        user.profile = profile;\n        user\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub public_profile: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n","traces":[{"line":27,"address":[19749360,19750138,19750193],"length":1,"stats":{"Line":2}},{"line":28,"address":[19667866],"length":1,"stats":{"Line":2}},{"line":32,"address":[19784789],"length":1,"stats":{"Line":2}},{"line":47,"address":[13923008,13923652,13923693],"length":1,"stats":{"Line":0}},{"line":53,"address":[19675533],"length":1,"stats":{"Line":0}},{"line":54,"address":[13923196,13923288],"length":1,"stats":{"Line":0}},{"line":55,"address":[19669083],"length":1,"stats":{"Line":0}},{"line":56,"address":[19785880],"length":1,"stats":{"Line":0}},{"line":57,"address":[19683057],"length":1,"stats":{"Line":0}},{"line":60,"address":[19784094,19784797,19782112],"length":1,"stats":{"Line":1}},{"line":61,"address":[19782136,19782474],"length":1,"stats":{"Line":2}},{"line":62,"address":[19882748,19882664],"length":1,"stats":{"Line":1}},{"line":64,"address":[19676612,19676783,19676416],"length":1,"stats":{"Line":3}},{"line":65,"address":[19683614,19683674],"length":1,"stats":{"Line":1}},{"line":67,"address":[19788481,19788301,19788162],"length":1,"stats":{"Line":3}},{"line":68,"address":[19676886,19676826],"length":1,"stats":{"Line":1}},{"line":70,"address":[19684194,19683822,19683967],"length":1,"stats":{"Line":1}},{"line":71,"address":[19670331,19670239],"length":1,"stats":{"Line":0}},{"line":73,"address":[19745298,19744883,19745040],"length":1,"stats":{"Line":1}},{"line":74,"address":[19787123,19787225],"length":1,"stats":{"Line":0}},{"line":76,"address":[19884043,19883610,19883792],"length":1,"stats":{"Line":1}},{"line":77,"address":[19883830,19883922],"length":1,"stats":{"Line":0}},{"line":79,"address":[26512221,26512393],"length":1,"stats":{"Line":1}},{"line":80,"address":[19677787],"length":1,"stats":{"Line":0}},{"line":82,"address":[26512425],"length":1,"stats":{"Line":1}},{"line":83,"address":[19884140],"length":1,"stats":{"Line":0}},{"line":85,"address":[19783781],"length":1,"stats":{"Line":1}},{"line":88,"address":[19790832],"length":1,"stats":{"Line":2}},{"line":89,"address":[19785253],"length":1,"stats":{"Line":2}},{"line":92,"address":[19785264],"length":1,"stats":{"Line":2}},{"line":93,"address":[19785269],"length":1,"stats":{"Line":2}},{"line":96,"address":[19747515,19747483,19747168],"length":1,"stats":{"Line":1}},{"line":99,"address":[19679403],"length":1,"stats":{"Line":1}},{"line":101,"address":[19791232,19791246],"length":1,"stats":{"Line":0}},{"line":102,"address":[19789669,19789648],"length":1,"stats":{"Line":2}},{"line":104,"address":[19754263,19754424],"length":1,"stats":{"Line":3}},{"line":107,"address":[13927360,13927911,13927849],"length":1,"stats":{"Line":3}},{"line":108,"address":[19786258,19785870,19785786],"length":1,"stats":{"Line":6}},{"line":109,"address":[19687039,19687234],"length":1,"stats":{"Line":6}},{"line":110,"address":[19687266],"length":1,"stats":{"Line":3}}],"covered":28,"coverable":40},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","mod.rs"],"content":"#![allow(unused_imports)]\n\npub mod constants;\npub mod entities;\npub mod p2p;\npub mod value_objects;\n\npub use constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\npub use entities::{Event, Post, Topic, User};\npub use p2p::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, P2PEvent, TopicMesh, TopicStats,\n    generate_topic_id, user_topic_id,\n};\npub use value_objects::{EventId, Npub, TopicId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","distribution.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// イベント配信時の戦略を表すドメイン値。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum DistributionStrategy {\n    Broadcast,\n    Gossip,\n    Direct(String),\n    Hybrid,\n    Nostr,\n    P2P,\n}\n\n/// 配信時のメトリクス記録を抽象化するトレイト。\npub trait DistributionMetrics: Send + Sync {\n    fn record_attempt(&self, _strategy: &DistributionStrategy) {}\n    fn record_success(&self, _strategy: &DistributionStrategy) {}\n    fn record_failure(&self, _strategy: &DistributionStrategy) {}\n}\n","traces":[{"line":16,"address":[15205152,15205162],"length":1,"stats":{"Line":2}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","events.rs"],"content":"use crate::domain::p2p::message::GossipMessage;\n\n#[derive(Clone, Debug)]\npub enum P2PEvent {\n    MessageReceived {\n        topic_id: String,\n        message: GossipMessage,\n        _from_peer: Vec<u8>,\n    },\n    PeerJoined {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n    PeerLeft {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n    NetworkConnected {\n        node_id: String,\n        addresses: Vec<String>,\n    },\n    NetworkDisconnected {\n        node_id: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","message.rs"],"content":"use crate::domain::constants::TOPIC_NAMESPACE;\nuse crate::domain::entities::TopicVisibility;\nuse bincode::{Decode, Encode};\nuse chrono::Utc;\nuse secp256k1::ecdsa::Signature;\nuse secp256k1::{Message as Secp256k1Message, PublicKey, SECP256K1, SecretKey};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse uuid::Uuid;\n\npub type MessageId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GossipMessage {\n    /// メッセージID（重複チェック用）\n    pub id: MessageId,\n\n    /// メッセージタイプ\n    pub msg_type: MessageType,\n\n    /// ペイロード\n    pub payload: Vec<u8>,\n\n    /// タイムスタンプ\n    pub timestamp: i64,\n\n    /// 送信者の公開鍵（33バイト - 圧縮形式）\n    pub sender: Vec<u8>,\n\n    /// 署名\n    pub signature: Vec<u8>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Encode, Decode)]\npub enum MessageType {\n    /// Nostrイベント\n    NostrEvent,\n\n    /// トピック情報の同期\n    TopicSync,\n\n    /// ピア情報の交換\n    PeerExchange,\n\n    /// ハートビート\n    Heartbeat,\n}\n\nimpl GossipMessage {\n    /// 新しいメッセージを作成\n    pub fn new(msg_type: MessageType, payload: Vec<u8>, sender: Vec<u8>) -> Self {\n        let id = generate_message_id();\n        let timestamp = Utc::now().timestamp();\n\n        Self {\n            id,\n            msg_type,\n            payload,\n            timestamp,\n            sender,\n            signature: Vec::new(), // 署名は後で追加\n        }\n    }\n\n    /// メッセージを署名用のバイト列に変換\n    pub fn to_signing_bytes(&self) -> Vec<u8> {\n        let mut bytes = Vec::new();\n        bytes.extend_from_slice(&self.id);\n        bytes.extend_from_slice(&(self.msg_type as u8).to_le_bytes());\n        bytes.extend_from_slice(&self.payload);\n        bytes.extend_from_slice(&self.timestamp.to_le_bytes());\n        // 注意: senderは署名に含めない（署名作成時にはまだ設定されていないため）\n        bytes\n    }\n\n    /// バイト列からメッセージを復元\n    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {\n        bincode::decode_from_slice(bytes, bincode::config::standard())\n            .map(|(msg, _)| msg)\n            .map_err(|e| format!(\"Failed to deserialize message: {e}\"))\n    }\n\n    /// メッセージをバイト列に変換\n    pub fn to_bytes(&self) -> Result<Vec<u8>, String> {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| format!(\"Failed to serialize message: {e}\"))\n    }\n\n    /// メッセージに署名を付ける\n    pub fn sign(&mut self, secret_key: &SecretKey) -> Result<(), String> {\n        let signing_bytes = self.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest(hash.into());\n\n        // 署名\n        let signature = SECP256K1.sign_ecdsa(message, secret_key);\n        self.signature = signature.serialize_compact().to_vec();\n\n        // 公開鍵を設定（圧縮形式）\n        let public_key = PublicKey::from_secret_key(SECP256K1, secret_key);\n        self.sender = public_key.serialize().to_vec();\n\n        Ok(())\n    }\n\n    /// 署名を検証\n    pub fn verify_signature(&self) -> Result<bool, String> {\n        if self.signature.is_empty() || self.sender.is_empty() {\n            return Ok(false);\n        }\n\n        // 公開鍵を復元\n        let public_key =\n            PublicKey::from_slice(&self.sender).map_err(|e| format!(\"Invalid public key: {e}\"))?;\n\n        // 署名を復元\n        let signature = Signature::from_compact(&self.signature)\n            .map_err(|e| format!(\"Invalid signature: {e}\"))?;\n\n        // 署名対象のバイト列を作成\n        let mut message_for_verification = self.clone();\n        message_for_verification.signature = Vec::new(); // 署名フィールドを空にする\n        let signing_bytes = message_for_verification.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest(hash.into());\n\n        // 署名を検証\n        Ok(SECP256K1\n            .verify_ecdsa(message, &signature, &public_key)\n            .is_ok())\n    }\n}\n\n/// トピックIDの生成（既に `kukuri:` で始まる場合は再利用する）\npub fn generate_topic_id(topic_name: &str) -> String {\n    generate_topic_id_with_visibility(topic_name, TopicVisibility::Public)\n}\n\npub fn generate_topic_id_with_visibility(topic_name: &str, _visibility: TopicVisibility) -> String {\n    let trimmed = topic_name.trim();\n    let base = if trimmed.is_empty() {\n        format!(\"{TOPIC_NAMESPACE}default\")\n    } else {\n        let normalized = trimmed.to_lowercase();\n        if normalized.starts_with(TOPIC_NAMESPACE) {\n            normalized\n        } else {\n            format!(\"{TOPIC_NAMESPACE}{normalized}\")\n        }\n    };\n\n    if is_hashed_topic_id(&base) {\n        return base;\n    }\n\n    hash_topic_id(&base)\n}\n\npub fn topic_id_bytes(canonical_id: &str) -> [u8; 32] {\n    if let Some(tail) = canonical_id.strip_prefix(TOPIC_NAMESPACE) {\n        if tail.len() == 64 && tail.chars().all(|c| c.is_ascii_hexdigit()) {\n            if let Ok(decoded) = hex::decode(tail) {\n                if decoded.len() >= 32 {\n                    let mut out = [0u8; 32];\n                    out.copy_from_slice(&decoded[..32]);\n                    return out;\n                }\n            }\n        }\n    }\n\n    *blake3::hash(canonical_id.as_bytes()).as_bytes()\n}\n\nfn is_hashed_topic_id(topic_id: &str) -> bool {\n    topic_id\n        .strip_prefix(TOPIC_NAMESPACE)\n        .is_some_and(|tail| tail.len() == 64 && tail.chars().all(|c| c.is_ascii_hexdigit()))\n}\n\nfn hash_topic_id(base: &str) -> String {\n    let mut hasher = blake3::Hasher::new();\n    hasher.update(base.as_bytes());\n    format!(\n        \"{TOPIC_NAMESPACE}{}\",\n        hex::encode(hasher.finalize().as_bytes())\n    )\n}\n\n/// グローバルトピック（全体のタイムライン）\npub const GLOBAL_TOPIC: &str = \"kukuri:global\";\n\n/// ユーザー固有トピック\npub fn user_topic_id(pubkey: &str) -> String {\n    format!(\"kukuri:user:{pubkey}\")\n}\n\nfn generate_message_id() -> MessageId {\n    let uuid = Uuid::new_v4();\n    let mut id = [0u8; 32];\n    let uuid_bytes = uuid.as_bytes();\n    id[..16].copy_from_slice(uuid_bytes);\n    let timestamp = Utc::now().timestamp_nanos_opt().unwrap_or(0);\n    id[16..24].copy_from_slice(&timestamp.to_le_bytes());\n    id[24..].copy_from_slice(&uuid_bytes[8..]);\n    id\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_message_signing_and_verification() {\n        // 秘密鍵を生成\n        let mut rng = rand::rng();\n        let secret_key = SecretKey::new(&mut rng);\n\n        // メッセージを作成\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3, 4, 5], vec![]);\n\n        // 署名\n        assert!(message.sign(&secret_key).is_ok());\n        assert!(!message.signature.is_empty());\n        assert!(!message.sender.is_empty());\n\n        // 検証 - 正しい署名\n        assert!(message.verify_signature().unwrap());\n\n        // ペイロードを改ざん\n        message.payload.push(6);\n        assert!(!message.verify_signature().unwrap());\n\n        // 署名を改ざん\n        message.payload.pop(); // 元に戻す\n        if !message.signature.is_empty() {\n            message.signature[0] ^= 0xFF;\n        }\n        assert!(!message.verify_signature().unwrap());\n    }\n\n    #[test]\n    fn test_message_serialization() {\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![10, 20, 30],\n            vec![1; 33], // 公開鍵は33バイト\n        );\n\n        // シリアライズ\n        let bytes = message.to_bytes().unwrap();\n\n        // デシリアライズ\n        let deserialized = GossipMessage::from_bytes(&bytes).unwrap();\n\n        assert_eq!(message.id, deserialized.id);\n        assert_eq!(message.msg_type as u8, deserialized.msg_type as u8);\n        assert_eq!(message.payload, deserialized.payload);\n        assert_eq!(message.timestamp, deserialized.timestamp);\n        assert_eq!(message.sender, deserialized.sender);\n    }\n}\n","traces":[{"line":51,"address":[17960376,17960432,17959904],"length":1,"stats":{"Line":1}},{"line":52,"address":[23822281],"length":1,"stats":{"Line":1}},{"line":53,"address":[17960030],"length":1,"stats":{"Line":1}},{"line":61,"address":[23918912],"length":1,"stats":{"Line":1}},{"line":66,"address":[25762976,25763363],"length":1,"stats":{"Line":1}},{"line":67,"address":[17960491],"length":1,"stats":{"Line":1}},{"line":68,"address":[23719976],"length":1,"stats":{"Line":1}},{"line":69,"address":[23787806],"length":1,"stats":{"Line":2}},{"line":70,"address":[25763185],"length":1,"stats":{"Line":2}},{"line":71,"address":[23823068],"length":1,"stats":{"Line":2}},{"line":73,"address":[23706513],"length":1,"stats":{"Line":2}},{"line":77,"address":[23819280],"length":1,"stats":{"Line":1}},{"line":78,"address":[25763434],"length":1,"stats":{"Line":1}},{"line":79,"address":[23819408,23819420],"length":1,"stats":{"Line":2}},{"line":80,"address":[25763552,25763578],"length":1,"stats":{"Line":0}},{"line":84,"address":[23706944],"length":1,"stats":{"Line":1}},{"line":85,"address":[23788488],"length":1,"stats":{"Line":1}},{"line":86,"address":[23707045,23707024],"length":1,"stats":{"Line":0}},{"line":90,"address":[23788752,23789654],"length":1,"stats":{"Line":1}},{"line":91,"address":[23788795],"length":1,"stats":{"Line":1}},{"line":94,"address":[23721049],"length":1,"stats":{"Line":1}},{"line":95,"address":[23788866],"length":1,"stats":{"Line":1}},{"line":96,"address":[17961671],"length":1,"stats":{"Line":1}},{"line":99,"address":[17961801],"length":1,"stats":{"Line":1}},{"line":102,"address":[25764382],"length":1,"stats":{"Line":1}},{"line":103,"address":[17962001],"length":1,"stats":{"Line":1}},{"line":106,"address":[23789373],"length":1,"stats":{"Line":1}},{"line":107,"address":[23782516],"length":1,"stats":{"Line":1}},{"line":109,"address":[23921169],"length":1,"stats":{"Line":1}},{"line":113,"address":[23723314,23721920],"length":1,"stats":{"Line":1}},{"line":114,"address":[25764998],"length":1,"stats":{"Line":1}},{"line":115,"address":[23708238],"length":1,"stats":{"Line":0}},{"line":119,"address":[17962569,17963888,17963912,17962809],"length":1,"stats":{"Line":1}},{"line":123,"address":[23790314,23789926,23790101],"length":1,"stats":{"Line":2}},{"line":124,"address":[23715530,23716496,23716520],"length":1,"stats":{"Line":0}},{"line":127,"address":[23722477],"length":1,"stats":{"Line":1}},{"line":128,"address":[17963168,17963026],"length":1,"stats":{"Line":2}},{"line":129,"address":[23922059],"length":1,"stats":{"Line":1}},{"line":132,"address":[23825654],"length":1,"stats":{"Line":1}},{"line":133,"address":[17963381],"length":1,"stats":{"Line":1}},{"line":134,"address":[23827392],"length":1,"stats":{"Line":1}},{"line":137,"address":[23922315],"length":1,"stats":{"Line":1}},{"line":140,"address":[23783924],"length":1,"stats":{"Line":1}},{"line":147,"address":[23716624],"length":1,"stats":{"Line":1}},{"line":148,"address":[23716646],"length":1,"stats":{"Line":1}},{"line":151,"address":[25766672,25767375],"length":1,"stats":{"Line":1}},{"line":152,"address":[23826614],"length":1,"stats":{"Line":1}},{"line":153,"address":[17964323,17964868],"length":1,"stats":{"Line":2}},{"line":154,"address":[23826733],"length":1,"stats":{"Line":1}},{"line":156,"address":[23723798],"length":1,"stats":{"Line":1}},{"line":157,"address":[23828684,23828565,23828361],"length":1,"stats":{"Line":3}},{"line":158,"address":[23791860],"length":1,"stats":{"Line":1}},{"line":160,"address":[23724074,23724161],"length":1,"stats":{"Line":2}},{"line":164,"address":[23710590,23710680],"length":1,"stats":{"Line":2}},{"line":165,"address":[23827371],"length":1,"stats":{"Line":0}},{"line":168,"address":[23923855,23923781],"length":1,"stats":{"Line":2}},{"line":171,"address":[23786088,23785424],"length":1,"stats":{"Line":1}},{"line":172,"address":[23785483],"length":1,"stats":{"Line":1}},{"line":173,"address":[23792610,23792501,23793040,23793053],"length":1,"stats":{"Line":4}},{"line":174,"address":[23792655],"length":1,"stats":{"Line":1}},{"line":175,"address":[23711293,23711204],"length":1,"stats":{"Line":2}},{"line":176,"address":[23792838],"length":1,"stats":{"Line":1}},{"line":177,"address":[23725097],"length":1,"stats":{"Line":1}},{"line":178,"address":[23828062],"length":1,"stats":{"Line":1}},{"line":184,"address":[23924074],"length":1,"stats":{"Line":0}},{"line":187,"address":[23725312],"length":1,"stats":{"Line":1}},{"line":188,"address":[23786158],"length":1,"stats":{"Line":1}},{"line":190,"address":[23824320,23824344,23824429,23824416],"length":1,"stats":{"Line":2}},{"line":193,"address":[23825028,23824448],"length":1,"stats":{"Line":1}},{"line":194,"address":[23786379],"length":1,"stats":{"Line":1}},{"line":195,"address":[23828451,23828519],"length":1,"stats":{"Line":2}},{"line":196,"address":[25768739],"length":1,"stats":{"Line":1}},{"line":198,"address":[23786487],"length":1,"stats":{"Line":1}},{"line":206,"address":[23712352],"length":1,"stats":{"Line":1}},{"line":207,"address":[23829018],"length":1,"stats":{"Line":1}},{"line":210,"address":[23719280],"length":1,"stats":{"Line":1}},{"line":211,"address":[23925585],"length":1,"stats":{"Line":1}},{"line":212,"address":[23825228],"length":1,"stats":{"Line":1}},{"line":213,"address":[23925613],"length":1,"stats":{"Line":1}},{"line":214,"address":[23829204],"length":1,"stats":{"Line":2}},{"line":215,"address":[23794136],"length":1,"stats":{"Line":1}},{"line":216,"address":[23712666],"length":1,"stats":{"Line":1}},{"line":217,"address":[25769541],"length":1,"stats":{"Line":1}},{"line":218,"address":[23925947],"length":1,"stats":{"Line":1}}],"covered":78,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","mod.rs"],"content":"pub mod distribution;\npub mod events;\npub mod message;\npub mod topic_mesh;\n\n#[cfg(test)]\nmod tests;\n\npub use distribution::{DistributionMetrics, DistributionStrategy};\npub use events::P2PEvent;\npub use message::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, generate_topic_id,\n    generate_topic_id_with_visibility, topic_id_bytes, user_topic_id,\n};\npub use topic_mesh::{TopicMesh, TopicStats};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","gossip_tests.rs"],"content":"#[cfg(test)]\r\nmod tests {\r\n    use crate::domain::entities::Event;\r\n    use crate::domain::p2p::generate_topic_id;\r\n    use crate::infrastructure::p2p::gossip_service::GossipService;\r\n    use crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\r\n    use iroh::{Endpoint, discovery::static_provider::StaticProvider};\r\n    use std::sync::Arc;\r\n\r\n    macro_rules! skip_unless_p2p_enabled {\r\n        ($name:literal) => {\r\n            if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\r\n                eprintln!(\"skipping {} (ENABLE_P2P_INTEGRATION!=1)\", $name);\r\n                return;\r\n            }\r\n        };\r\n    }\r\n\r\n    async fn create_test_service() -> IrohGossipService {\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Endpoint::builder()\r\n            .discovery(static_discovery.clone())\r\n            .bind()\r\n            .await\r\n            .unwrap();\r\n        IrohGossipService::new(Arc::new(endpoint), static_discovery).unwrap()\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_topic_join_leave() {\r\n        skip_unless_p2p_enabled!(\"test_topic_join_leave\");\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"test-topic\");\r\n\r\n        // Join topic\r\n        let result = service.join_topic(&topic_id, vec![]).await;\r\n        assert!(result.is_ok());\r\n\r\n        // Verify topic is active\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert!(active_topics.contains(&topic_id));\r\n\r\n        // Leave topic\r\n        let result = service.leave_topic(&topic_id).await;\r\n        assert!(result.is_ok());\r\n\r\n        // Verify topic is removed\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert!(!active_topics.contains(&topic_id));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_multiple_topics() {\r\n        skip_unless_p2p_enabled!(\"test_multiple_topics\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"topic1\", \"topic2\", \"topic3\"];\r\n\r\n        // Join multiple topics\r\n        for topic in &topics {\r\n            let id = generate_topic_id(topic);\r\n            service.join_topic(&id, vec![]).await.unwrap();\r\n        }\r\n\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 3);\r\n\r\n        // Leave one topic\r\n        let id = generate_topic_id(\"topic2\");\r\n        service.leave_topic(&id).await.unwrap();\r\n\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 2);\r\n        assert!(!active_topics.contains(&generate_topic_id(\"topic2\")));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_leave_nonexistent_topic() {\r\n        skip_unless_p2p_enabled!(\"test_leave_nonexistent_topic\");\r\n        let service = create_test_service().await;\r\n        let topic = generate_topic_id(\"nonexistent\");\r\n        let result = service.leave_topic(&topic).await;\r\n        // 未参加トピックのleaveは冪等（エラーにしない）\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_broadcast_to_topic() {\r\n        skip_unless_p2p_enabled!(\"test_broadcast_to_topic\");\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"broadcast-test\");\r\n\r\n        // まずトピックに参加\r\n        service.join_topic(&topic_id, vec![]).await.unwrap();\r\n\r\n        // ダミーEventを作成してブロードキャスト\r\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(&topic_id, &event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_broadcast_to_nonexistent_topic() {\r\n        skip_unless_p2p_enabled!(\"test_broadcast_to_nonexistent_topic\");\r\n        let service = create_test_service().await;\r\n\r\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(\"nonexistent-topic\", &event).await;\r\n        // 未参加トピックのbroadcastはエラー\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_get_topic_status() {\r\n        skip_unless_p2p_enabled!(\"test_get_topic_status\");\r\n        // IrohGossipServiceではステータスAPIは最小提供のためスキップ\r\n        // 代わりにjoin後にget_joined_topicsで存在確認\r\n        let service = create_test_service().await;\r\n        let topic_id = generate_topic_id(\"status-test\");\r\n        service.join_topic(&topic_id, vec![]).await.unwrap();\r\n        let topics = service.get_joined_topics().await.unwrap();\r\n        assert!(topics.contains(&topic_id));\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_get_all_topic_stats() {\r\n        skip_unless_p2p_enabled!(\"test_get_all_topic_stats\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"stats-topic1\", \"stats-topic2\", \"stats-topic3\"];\r\n        for topic in &topics {\r\n            service\r\n                .join_topic(&generate_topic_id(topic), vec![])\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let joined = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(joined.len(), 3);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_shutdown() {\r\n        skip_unless_p2p_enabled!(\"test_shutdown\");\r\n        let service = create_test_service().await;\r\n        let topics = vec![\"shutdown-topic1\", \"shutdown-topic2\"];\r\n        for topic in &topics {\r\n            service\r\n                .join_topic(&generate_topic_id(topic), vec![])\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 2);\r\n        // leave all\r\n        for topic in &topics {\r\n            service\r\n                .leave_topic(&generate_topic_id(topic))\r\n                .await\r\n                .unwrap();\r\n        }\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 0);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_node_id() {\r\n        skip_unless_p2p_enabled!(\"test_node_id\");\r\n        // IrohGossipServiceでは直接のNodeID APIは提供しないため簡易確認のみ\r\n        let _service = create_test_service().await;\r\n        assert!(true);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_node_addr() {\r\n        skip_unless_p2p_enabled!(\"test_node_addr\");\r\n        // IrohGossipServiceでは直接のアドレスAPIは提供しないためスキップ\r\n        let _service = create_test_service().await;\r\n        assert!(true);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_concurrent_topic_operations() {\r\n        skip_unless_p2p_enabled!(\"test_concurrent_topic_operations\");\r\n        use std::sync::Arc;\r\n        use tokio::task;\r\n\r\n        let service = Arc::new(create_test_service().await);\r\n        let mut handles = vec![];\r\n\r\n        // 並行して複数のトピック操作を実行\r\n        for i in 0..5 {\r\n            let service_clone = service.clone();\r\n            let handle = task::spawn(async move {\r\n                let topic_id = generate_topic_id(&format!(\"concurrent-topic-{i}\"));\r\n                service_clone.join_topic(&topic_id, vec![]).await.unwrap();\r\n                let joined = service_clone.get_joined_topics().await.unwrap();\r\n                assert!(joined.contains(&topic_id));\r\n                service_clone.leave_topic(&topic_id).await.unwrap();\r\n            });\r\n            handles.push(handle);\r\n        }\r\n\r\n        // すべてのタスクが完了するのを待つ\r\n        for handle in handles {\r\n            handle.await.unwrap();\r\n        }\r\n\r\n        // 最終的にすべてのトピックから離脱していることを確認\r\n        let active_topics = service.get_joined_topics().await.unwrap();\r\n        assert_eq!(active_topics.len(), 0);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","message_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::constants::{DEFAULT_PUBLIC_TOPIC_ID, TOPIC_NAMESPACE};\n    use crate::domain::entities::TopicVisibility;\n    use crate::domain::p2p::message::*;\n\n    #[test]\n    fn test_message_type_copy() {\n        let msg_type = MessageType::NostrEvent;\n        let copied = msg_type;\n        assert!(matches!(copied, MessageType::NostrEvent));\n    }\n\n    #[test]\n    fn test_gossip_message_creation() {\n        let msg_type = MessageType::NostrEvent;\n        let payload = vec![1, 2, 3, 4, 5];\n        let sender = vec![0; 32];\n\n        let message = GossipMessage::new(msg_type, payload.clone(), sender.clone());\n\n        assert!(matches!(message.msg_type, MessageType::NostrEvent));\n        assert_eq!(message.payload, payload);\n        assert_eq!(message.sender, sender);\n        assert!(message.timestamp > 0);\n        assert_eq!(message.signature.len(), 0); // 初期状態では署名なし\n    }\n\n    #[test]\n    fn test_message_id_uniqueness() {\n        let messages: Vec<GossipMessage> = (0..100)\n            .map(|i| GossipMessage::new(MessageType::Heartbeat, vec![i as u8], vec![0; 32]))\n            .collect();\n\n        // すべてのメッセージIDがユニークであることを確認\n        let mut ids = messages.iter().map(|m| m.id).collect::<Vec<_>>();\n        ids.sort();\n        ids.dedup();\n        assert_eq!(ids.len(), 100);\n    }\n\n    #[test]\n    fn test_generate_topic_id() {\n        let bitcoin_base = format!(\"{TOPIC_NAMESPACE}bitcoin\");\n        let nostr_base = format!(\"{TOPIC_NAMESPACE}nostr\");\n        let test_topic_base = format!(\"{TOPIC_NAMESPACE}test topic\");\n        assert_eq!(\n            generate_topic_id(\"Bitcoin\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(bitcoin_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(\n            generate_topic_id(\"NOSTR\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(nostr_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(\n            generate_topic_id(\"Test Topic\"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(test_topic_base.as_bytes()).as_bytes())\n            )\n        );\n        assert_eq!(generate_topic_id(\"public\"), DEFAULT_PUBLIC_TOPIC_ID);\n        assert_eq!(\n            generate_topic_id(\"   kukuri:tauri:public   \"),\n            DEFAULT_PUBLIC_TOPIC_ID\n        );\n        let default_base = format!(\"{TOPIC_NAMESPACE}default\");\n        assert_eq!(\n            generate_topic_id(\"   \"),\n            format!(\n                \"{TOPIC_NAMESPACE}{}\",\n                hex::encode(blake3::hash(default_base.as_bytes()).as_bytes())\n            )\n        );\n\n        let private = generate_topic_id_with_visibility(\"secret-room\", TopicVisibility::Private);\n        assert!(private.starts_with(TOPIC_NAMESPACE));\n        let tail = private.trim_start_matches(TOPIC_NAMESPACE);\n        assert_eq!(tail.len(), 64);\n        assert!(tail.chars().all(|c| c.is_ascii_hexdigit()));\n    }\n\n    #[test]\n    fn test_topic_id_bytes_respects_visibility() {\n        let private = generate_topic_id_with_visibility(\"hidden\", TopicVisibility::Private);\n        let private_tail = private.trim_start_matches(TOPIC_NAMESPACE);\n        let bytes = topic_id_bytes(&private);\n        assert_eq!(hex::encode(bytes), private_tail[..64]);\n\n        let public_bytes = topic_id_bytes(DEFAULT_PUBLIC_TOPIC_ID);\n        let public_tail = DEFAULT_PUBLIC_TOPIC_ID.trim_start_matches(TOPIC_NAMESPACE);\n        assert_eq!(public_bytes.len(), 32);\n        assert_eq!(hex::encode(public_bytes), public_tail);\n    }\n\n    #[test]\n    fn test_global_topic_constant() {\n        assert_eq!(GLOBAL_TOPIC, \"kukuri:global\");\n    }\n\n    #[test]\n    fn test_user_topic_id() {\n        let pubkey = \"npub1234567890abcdef\";\n        assert_eq!(user_topic_id(pubkey), \"kukuri:user:npub1234567890abcdef\");\n    }\n\n    #[test]\n    fn test_message_to_signing_bytes() {\n        let message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3], vec![4, 5, 6]);\n\n        let signing_bytes = message.to_signing_bytes();\n\n        // 署名用バイト列が正しく生成されることを確認\n        assert!(!signing_bytes.is_empty());\n        assert!(signing_bytes.len() > message.id.len() + message.payload.len());\n    }\n\n    #[test]\n    fn test_all_message_types() {\n        let types = vec![\n            MessageType::NostrEvent,\n            MessageType::TopicSync,\n            MessageType::PeerExchange,\n            MessageType::Heartbeat,\n        ];\n\n        for msg_type in types {\n            let message = GossipMessage::new(msg_type, vec![], vec![0; 32]);\n            assert!(matches!(message.msg_type, _));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","mod.rs"],"content":"mod gossip_tests;\nmod message_tests;\nmod topic_mesh_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","topic_mesh_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::p2p::message::{GossipMessage, MessageType};\n    use crate::domain::p2p::topic_mesh::*;\n\n    fn create_test_mesh() -> TopicMesh {\n        TopicMesh::new(\"test-topic\".to_string())\n    }\n\n    fn create_test_message(id: u8) -> GossipMessage {\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![id], vec![id; 32]);\n        // 一意のIDを設定\n        message.id[0] = id;\n        message\n    }\n\n    #[tokio::test]\n    async fn test_topic_mesh_creation() {\n        let mesh = create_test_mesh();\n        let stats = mesh.get_stats().await;\n\n        assert_eq!(stats.peer_count, 0);\n        assert_eq!(stats.message_count, 0);\n        assert_eq!(stats.last_activity, 0);\n    }\n\n    #[tokio::test]\n    async fn test_message_handling() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(1);\n\n        // メッセージ処理\n        let result = mesh.handle_message(message.clone()).await;\n        assert!(result.is_ok());\n\n        // 統計情報の確認\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.message_count, 1);\n        assert_eq!(stats.peer_count, 1);\n        assert!(stats.last_activity > 0);\n    }\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(2);\n\n        // 最初のメッセージは重複ではない\n        assert!(!mesh.is_duplicate(&message.id).await);\n\n        // メッセージを処理\n        mesh.handle_message(message.clone()).await.unwrap();\n\n        // 同じメッセージは重複として検出される\n        assert!(mesh.is_duplicate(&message.id).await);\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = create_test_mesh();\n        let peer1 = vec![1; 32];\n        let peer2 = vec![2; 32];\n\n        // ピアの追加\n        mesh.update_peer_status(peer1.clone(), true).await;\n        mesh.update_peer_status(peer2.clone(), true).await;\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 2);\n\n        // ピアの削除\n        mesh.update_peer_status(peer1, false).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n    }\n\n    #[tokio::test]\n    async fn test_cache_limit() {\n        let mesh = create_test_mesh();\n\n        // キャッシュ制限（1000）を超えるメッセージを追加しようとする\n        // 実際にはLRUキャッシュが古いメッセージを削除する\n        for i in 0..1100 {\n            let mut message = create_test_message((i % 256) as u8);\n            // より一意なIDを設定\n            message.id[0] = (i % 256) as u8;\n            message.id[1] = ((i >> 8) % 256) as u8;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        // キャッシュサイズは1000以下\n        assert!(stats.message_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_message_handling() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 10個の並行タスクでメッセージを送信\n        for i in 0..10 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..100 {\n                    let mut message = create_test_message((i * 100 + j) as u8);\n                    // より一意なメッセージIDを設定\n                    message.id[0] = ((i * 100 + j) % 256) as u8;\n                    message.id[1] = ((i * 100 + j) / 256) as u8;\n                    mesh_clone.handle_message(message).await.unwrap();\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 統計情報を確認\n        let stats = mesh.get_stats().await;\n        // 1000メッセージ送信したが、重複があるため実際のメッセージ数は少ない\n        assert!(stats.message_count > 0);\n        assert!(stats.message_count <= 1000); // キャッシュ制限を超えない\n        assert!(stats.peer_count > 0);\n        assert!(stats.peer_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_peer_updates() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 並行してピアの追加/削除を行う\n        for i in 0..5 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..20 {\n                    let peer = vec![(i * 20 + j) as u8; 32];\n                    mesh_clone.update_peer_status(peer.clone(), true).await;\n                    if j % 2 == 0 {\n                        mesh_clone.update_peer_status(peer, false).await;\n                    }\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 最終的なピア数を確認\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 50); // 奇数番号のピアのみ残る\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_cache_operations() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n\n        // メッセージ追加タスク\n        let mesh_add = mesh.clone();\n        let add_task = task::spawn(async move {\n            for i in 0..500 {\n                let message = create_test_message(i as u8);\n                mesh_add.handle_message(message).await.unwrap();\n                tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\n            }\n        });\n\n        // 統計情報取得タスク\n        let mesh_stats = mesh.clone();\n        let stats_task = task::spawn(async move {\n            let mut last_count = 0;\n            for _ in 0..50 {\n                let stats = mesh_stats.get_stats().await;\n                assert!(stats.message_count >= last_count); // 単調増加\n                last_count = stats.message_count;\n                tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n            }\n        });\n\n        // すべてのタスクが完了するのを待つ\n        add_task.await.unwrap();\n        stats_task.await.unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","topic_mesh.rs"],"content":"use crate::domain::p2p::message::{GossipMessage, MessageId};\nuse anyhow::Result;\nuse lru::LruCache;\nuse std::collections::{HashMap, HashSet};\nuse std::num::NonZeroUsize;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse tokio::sync::{RwLock, mpsc};\n\nconst DEFAULT_SUBSCRIBER_BUFFER: usize = 128;\nconst DEFAULT_REPLAY_LIMIT: usize = 64;\n\n#[derive(Clone)]\npub struct TopicMesh {\n    peers: Arc<RwLock<HashSet<Vec<u8>>>>, // PublicKeyのバイト表現\n    message_cache: Arc<RwLock<LruCache<MessageId, GossipMessage>>>,\n    subscribers: Arc<RwLock<HashMap<u64, mpsc::Sender<GossipMessage>>>>,\n    next_subscription_id: Arc<AtomicU64>,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct TopicStats {\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\nimpl TopicMesh {\n    /// 新しいTopicMeshを作成\n    pub fn new(_topic_id: String) -> Self {\n        let cache_size = NonZeroUsize::new(1000).unwrap(); // 最大1000メッセージをキャッシュ\n\n        Self {\n            peers: Arc::new(RwLock::new(HashSet::new())),\n            message_cache: Arc::new(RwLock::new(LruCache::new(cache_size))),\n            subscribers: Arc::new(RwLock::new(HashMap::new())),\n            next_subscription_id: Arc::new(AtomicU64::new(1)),\n        }\n    }\n\n    /// メッセージの受信処理\n    pub async fn handle_message(&self, message: GossipMessage) -> Result<()> {\n        // 重複チェック\n        if self.is_duplicate(&message.id).await {\n            return Ok(()); // 重複メッセージは無視\n        }\n\n        // メッセージをキャッシュに追加\n        let mut cache = self.message_cache.write().await;\n        cache.put(message.id, message.clone());\n\n        // ピアリストに送信者を追加\n        let mut peers = self.peers.write().await;\n        peers.insert(message.sender.clone());\n        drop(peers);\n\n        self.notify_subscribers(&message).await;\n\n        Ok(())\n    }\n\n    /// ピアの接続状態管理\n    pub async fn update_peer_status(&self, peer: Vec<u8>, connected: bool) {\n        let mut peers = self.peers.write().await;\n        if connected {\n            peers.insert(peer);\n        } else {\n            peers.remove(&peer);\n        }\n    }\n\n    /// メッセージの重複チェック\n    pub async fn is_duplicate(&self, message_id: &MessageId) -> bool {\n        let cache = self.message_cache.read().await;\n        cache.contains(message_id)\n    }\n\n    /// トピックの統計情報を取得\n    pub async fn get_stats(&self) -> TopicStats {\n        let peers = self.peers.read().await;\n        let cache = self.message_cache.read().await;\n\n        let last_activity = cache\n            .iter()\n            .map(|(_, msg)| msg.timestamp)\n            .max()\n            .unwrap_or(0);\n\n        TopicStats {\n            peer_count: peers.len(),\n            message_count: cache.len(),\n            last_activity,\n        }\n    }\n\n    /// Gossipメッセージ購読用のチャネルを生成\n    pub async fn subscribe(&self) -> TopicMeshSubscription {\n        let (tx, rx) = mpsc::channel(DEFAULT_SUBSCRIBER_BUFFER);\n        let subscription_id = self.next_subscription_id.fetch_add(1, Ordering::Relaxed);\n\n        {\n            let mut subscribers = self.subscribers.write().await;\n            subscribers.insert(subscription_id, tx.clone());\n        }\n\n        // Receiver がクローズされたら自動的に購読登録を解除する\n        {\n            let drop_tx = tx.clone();\n            let mesh = self.clone();\n            tokio::spawn(async move {\n                drop_tx.closed().await;\n                mesh.unsubscribe(subscription_id).await;\n            });\n        }\n\n        // 直近メッセージを購読開始直後に配信（最新→古い順で保持し、古→新順で送信）\n        if let Err(_e) = self\n            .replay_recent_messages(tx.clone(), DEFAULT_REPLAY_LIMIT)\n            .await\n        {\n            // リプレイ開始前に購読者が離脱した場合は登録を解除\n            self.unsubscribe(subscription_id).await;\n        }\n\n        TopicMeshSubscription {\n            id: subscription_id,\n            receiver: rx,\n        }\n    }\n\n    /// 指定された購読IDを解除\n    pub async fn unsubscribe(&self, subscription_id: u64) {\n        let mut subscribers = self.subscribers.write().await;\n        subscribers.remove(&subscription_id);\n    }\n\n    async fn notify_subscribers(&self, message: &GossipMessage) {\n        let subscribers = self.subscribers.read().await;\n        if subscribers.is_empty() {\n            return;\n        }\n\n        let senders: Vec<(u64, mpsc::Sender<GossipMessage>)> = subscribers\n            .iter()\n            .map(|(&id, sender)| (id, sender.clone()))\n            .collect();\n        drop(subscribers);\n\n        let mut closed_ids = Vec::new();\n        for (id, sender) in senders {\n            match sender.try_send(message.clone()) {\n                Ok(_) => {}\n                Err(mpsc::error::TrySendError::Full(pending)) => {\n                    if sender.send(pending).await.is_err() {\n                        closed_ids.push(id);\n                    }\n                }\n                Err(mpsc::error::TrySendError::Closed(_)) => closed_ids.push(id),\n            }\n        }\n\n        if !closed_ids.is_empty() {\n            let mut subscribers = self.subscribers.write().await;\n            for id in closed_ids {\n                subscribers.remove(&id);\n            }\n        }\n    }\n\n    async fn replay_recent_messages(\n        &self,\n        sender: mpsc::Sender<GossipMessage>,\n        limit: usize,\n    ) -> Result<(), ()> {\n        if limit == 0 {\n            return Ok(());\n        }\n\n        let messages = {\n            let cache = self.message_cache.read().await;\n            let mut cached: Vec<_> = cache.iter().map(|(_, msg)| msg.clone()).collect();\n            if cached.is_empty() {\n                return Ok(());\n            }\n            // LruCacheは最新アクセス順なので一度降順に並べ替えて上位limit件を確保\n            cached.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));\n            cached.truncate(limit.min(DEFAULT_SUBSCRIBER_BUFFER));\n            cached.reverse();\n            cached\n        };\n\n        for message in messages {\n            if sender.send(message).await.is_err() {\n                // 送信に失敗した場合は購読終了とみなし、呼び出し元で解除する\n                return Err(());\n            }\n        }\n\n        // 送信完了\n        let _ = sender;\n        Ok(())\n    }\n\n    #[cfg(test)]\n    pub async fn subscriber_count(&self) -> usize {\n        let subscribers = self.subscribers.read().await;\n        subscribers.len()\n    }\n}\n\npub struct TopicMeshSubscription {\n    pub id: u64,\n    pub receiver: mpsc::Receiver<GossipMessage>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::p2p::message::MessageType;\n    use tokio::time::{Duration, sleep};\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![1, 2, 3],\n            vec![0x02; 33], // 33バイトの公開鍵\n        );\n        let id = message.id;\n\n        mesh.handle_message(message.clone()).await.unwrap();\n        assert!(mesh.is_duplicate(&id).await);\n\n        // もう一度同じメッセージを処理\n        let result = mesh.handle_message(message).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let peer = vec![0x02; 33];\n\n        mesh.update_peer_status(peer.clone(), true).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n\n        mesh.update_peer_status(peer, false).await;\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_stats() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n\n        for i in 0..5 {\n            let mut message =\n                GossipMessage::new(MessageType::TopicSync, vec![i as u8], vec![0x02; 33]);\n            message.timestamp = i;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n        assert_eq!(stats.message_count, 5);\n        assert_eq!(stats.last_activity, 4);\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_and_receive_messages() {\n        let mesh = TopicMesh::new(\"topic_subscribe\".into());\n        let mut subscription = mesh.subscribe().await;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        let message = GossipMessage::new(MessageType::NostrEvent, vec![42, 24], vec![0x02; 33]);\n        mesh.handle_message(message.clone()).await.unwrap();\n\n        let received = subscription\n            .receiver\n            .recv()\n            .await\n            .expect(\"subscriber should receive message\");\n        assert_eq!(received.payload, message.payload);\n        assert_eq!(received.msg_type as u8, MessageType::NostrEvent as u8);\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_replays_recent_messages() {\n        let mesh = TopicMesh::new(\"topic_replay\".into());\n\n        for ts in 0..5 {\n            let mut message =\n                GossipMessage::new(MessageType::TopicSync, vec![ts as u8], vec![0x02; 33]);\n            message.timestamp = ts;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let mut subscription = mesh.subscribe().await;\n        let mut received = Vec::new();\n        for _ in 0..5 {\n            let message = subscription\n                .receiver\n                .recv()\n                .await\n                .expect(\"replay should deliver cached message\");\n            received.push(message.timestamp);\n        }\n\n        assert_eq!(received, vec![0, 1, 2, 3, 4]);\n    }\n\n    #[tokio::test]\n    async fn test_unsubscribe_removes_channel() {\n        let mesh = TopicMesh::new(\"topic_unsubscribe\".into());\n        let subscription = mesh.subscribe().await;\n        let subscription_id = subscription.id;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        mesh.unsubscribe(subscription_id).await;\n        assert_eq!(mesh.subscriber_count().await, 0);\n\n        // Drop receiver without explicit unsubscribe: should be cleaned up on notify\n        let subscription = mesh.subscribe().await;\n        let dropped_id = subscription.id;\n        drop(subscription);\n\n        let message = GossipMessage::new(MessageType::TopicSync, vec![1, 2, 3], vec![0x02; 33]);\n        mesh.handle_message(message).await.unwrap();\n\n        // 送信エラー処理が走る時間を確保\n        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n\n        let subscribers = mesh.subscribers.read().await;\n        assert!(\n            !subscribers.contains_key(&dropped_id),\n            \"closed channel should be removed automatically\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_subscription_auto_unsubscribes_on_drop() {\n        let mesh = TopicMesh::new(\"topic_auto_unsubscribe\".into());\n        let subscription = mesh.subscribe().await;\n        assert_eq!(mesh.subscriber_count().await, 1);\n\n        drop(subscription);\n\n        // Allow the drop guard to execute unsubscribe inside spawned task\n        sleep(Duration::from_millis(10)).await;\n\n        assert_eq!(\n            mesh.subscriber_count().await,\n            0,\n            \"subscription drop should trigger unsubscribe\"\n        );\n    }\n}\n","traces":[{"line":30,"address":[18887024,18887698],"length":1,"stats":{"Line":1}},{"line":31,"address":[18998617,18998550],"length":1,"stats":{"Line":2}},{"line":34,"address":[13134669],"length":1,"stats":{"Line":1}},{"line":35,"address":[18993155,18993215],"length":1,"stats":{"Line":3}},{"line":36,"address":[13134949,13134886],"length":1,"stats":{"Line":4}},{"line":37,"address":[18962241,18962302],"length":1,"stats":{"Line":4}},{"line":42,"address":[19094340,19094121,19094016,19094985,19095084,19094567,19094096,19094051],"length":1,"stats":{"Line":8}},{"line":44,"address":[18994114,18994231,18993999,18993931],"length":1,"stats":{"Line":6}},{"line":45,"address":[13136067],"length":1,"stats":{"Line":1}},{"line":49,"address":[11426422],"length":1,"stats":{"Line":5}},{"line":50,"address":[13136563,13136639],"length":1,"stats":{"Line":3}},{"line":53,"address":[11494256],"length":1,"stats":{"Line":3}},{"line":54,"address":[13137259,13137186],"length":1,"stats":{"Line":4}},{"line":55,"address":[18889801],"length":1,"stats":{"Line":3}},{"line":57,"address":[11433450],"length":1,"stats":{"Line":3}},{"line":59,"address":[19001663],"length":1,"stats":{"Line":3}},{"line":63,"address":[18996192,18996431,18996212,18996256,18996610,18997151,18996281],"length":1,"stats":{"Line":4}},{"line":64,"address":[19000578,19000454,19000351,19000394],"length":1,"stats":{"Line":2}},{"line":65,"address":[18884356,18884274,18884153],"length":1,"stats":{"Line":3}},{"line":66,"address":[19097260,19097368],"length":1,"stats":{"Line":2}},{"line":68,"address":[13138558,13138471],"length":1,"stats":{"Line":2}},{"line":73,"address":[18884862,18884528,18884721,18884560,18885254,18884541,18884585,18884684],"length":1,"stats":{"Line":6}},{"line":74,"address":[11495092],"length":1,"stats":{"Line":4}},{"line":75,"address":[18891900,18891967],"length":1,"stats":{"Line":3}},{"line":79,"address":[18886124,18885272,18885264,18885280,18885327,18885432,18885652,18885496],"length":1,"stats":{"Line":4}},{"line":80,"address":[11406767],"length":1,"stats":{"Line":4}},{"line":81,"address":[11523426],"length":1,"stats":{"Line":6}},{"line":83,"address":[18967904,18967977],"length":1,"stats":{"Line":7}},{"line":85,"address":[20966128,20966143],"length":1,"stats":{"Line":3}},{"line":90,"address":[20965887],"length":1,"stats":{"Line":1}},{"line":91,"address":[19099696],"length":1,"stats":{"Line":1}},{"line":97,"address":[13142772,13141184,13141168,13141176,13141427,13141342,13141827,13141215],"length":1,"stats":{"Line":9}},{"line":98,"address":[18893970,18893780],"length":1,"stats":{"Line":6}},{"line":99,"address":[19100373,19100282],"length":1,"stats":{"Line":6}},{"line":102,"address":[19181969],"length":1,"stats":{"Line":3}},{"line":103,"address":[19100939,19100871],"length":1,"stats":{"Line":6}},{"line":108,"address":[20967222,20967286],"length":1,"stats":{"Line":6}},{"line":109,"address":[20967302],"length":1,"stats":{"Line":3}},{"line":110,"address":[19001840,19001865,19002108,19001939,19002406,19000839,19002645],"length":1,"stats":{"Line":5}},{"line":111,"address":[19002035,19002140,19001915,19001966],"length":1,"stats":{"Line":2}},{"line":112,"address":[19006228,19006351,19005917],"length":1,"stats":{"Line":1}},{"line":117,"address":[19006625,19006877,19006964,19006676,19006578],"length":1,"stats":{"Line":13}},{"line":118,"address":[18902067],"length":1,"stats":{"Line":3}},{"line":119,"address":[18969997,18969938,18968609,18969881,18970125],"length":1,"stats":{"Line":8}},{"line":122,"address":[10761649],"length":1,"stats":{"Line":0}},{"line":132,"address":[18890105,18890061,18890080,18890204,18890241,18890792,18890382,18890048],"length":1,"stats":{"Line":4}},{"line":133,"address":[11624804],"length":1,"stats":{"Line":2}},{"line":134,"address":[18897410,18897477],"length":1,"stats":{"Line":2}},{"line":137,"address":[19003552,19003520,19003533,19003583,19003860,19004022,19005034,19003763],"length":1,"stats":{"Line":12}},{"line":138,"address":[11507377],"length":1,"stats":{"Line":6}},{"line":139,"address":[19009989,19009909],"length":1,"stats":{"Line":6}},{"line":143,"address":[18966408,18966318],"length":1,"stats":{"Line":2}},{"line":145,"address":[20973728,20973747],"length":1,"stats":{"Line":2}},{"line":147,"address":[19004605],"length":1,"stats":{"Line":1}},{"line":149,"address":[19105056],"length":1,"stats":{"Line":1}},{"line":150,"address":[18967887,18966763,18966635,18967950],"length":1,"stats":{"Line":4}},{"line":151,"address":[18907487,18907150,18907403],"length":1,"stats":{"Line":4}},{"line":152,"address":[19012010],"length":1,"stats":{"Line":1}},{"line":153,"address":[19012037],"length":1,"stats":{"Line":0}},{"line":154,"address":[20971308,20970146,20972867,20972779,20971836,20971998],"length":1,"stats":{"Line":0}},{"line":155,"address":[18899808],"length":1,"stats":{"Line":0}},{"line":158,"address":[13148327,13148225],"length":1,"stats":{"Line":2}},{"line":162,"address":[18893501,18893432],"length":1,"stats":{"Line":2}},{"line":163,"address":[18907839,18907229,18904891,18907268],"length":1,"stats":{"Line":2}},{"line":164,"address":[18968904,18969212,18969166,18969019],"length":1,"stats":{"Line":4}},{"line":165,"address":[18901535,18901420],"length":1,"stats":{"Line":2}},{"line":170,"address":[13149264],"length":1,"stats":{"Line":3}},{"line":175,"address":[19011813],"length":1,"stats":{"Line":3}},{"line":176,"address":[18895254],"length":1,"stats":{"Line":0}},{"line":180,"address":[13149808,13149524,13149672,13149573],"length":1,"stats":{"Line":6}},{"line":181,"address":[18972104,18970339,18972064,18970412],"length":1,"stats":{"Line":8}},{"line":182,"address":[18895893,18895964],"length":1,"stats":{"Line":4}},{"line":183,"address":[19109071],"length":1,"stats":{"Line":2}},{"line":186,"address":[19010240,19010272,19008674,19008743],"length":1,"stats":{"Line":4}},{"line":187,"address":[19014338],"length":1,"stats":{"Line":1}},{"line":188,"address":[19109179],"length":1,"stats":{"Line":1}},{"line":189,"address":[18970749],"length":1,"stats":{"Line":1}},{"line":192,"address":[20975781,20974980,20975717],"length":1,"stats":{"Line":3}},{"line":193,"address":[19009899,19007945,19010059,19009074,19009595],"length":1,"stats":{"Line":4}},{"line":195,"address":[19015708],"length":1,"stats":{"Line":0}},{"line":201,"address":[19009938],"length":1,"stats":{"Line":1}},{"line":205,"address":[20976411,20976448,20976577,20976304,20976296,20976329,20976958,20976288],"length":1,"stats":{"Line":4}},{"line":206,"address":[10781156],"length":1,"stats":{"Line":2}},{"line":207,"address":[20976888,20976834],"length":1,"stats":{"Line":2}}],"covered":78,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","bookmark_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Bookmark エンティティの識別子。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct BookmarkId(String);\n\nimpl BookmarkId {\n    /// 既存の識別子文字列から `BookmarkId` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"BookmarkId cannot be empty\".to_string());\n        }\n        uuid::Uuid::parse_str(&value).map_err(|err| format!(\"Invalid BookmarkId format: {err}\"))?;\n        Ok(Self(value))\n    }\n\n    /// 新規 BookmarkId を生成する。\n    pub fn random() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    /// 内部の文字列を参照する。\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for BookmarkId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<BookmarkId> for String {\n    fn from(value: BookmarkId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":10,"address":[13507985,13507440],"length":1,"stats":{"Line":1}},{"line":11,"address":[20525990,20525934],"length":1,"stats":{"Line":2}},{"line":12,"address":[13507949,13507554],"length":1,"stats":{"Line":0}},{"line":14,"address":[21282513,21282840,21282571,21282992,21283009,21282905],"length":1,"stats":{"Line":2}},{"line":15,"address":[13624371],"length":1,"stats":{"Line":1}},{"line":19,"address":[13582736],"length":1,"stats":{"Line":1}},{"line":20,"address":[13508157],"length":1,"stats":{"Line":1}},{"line":24,"address":[13589744],"length":1,"stats":{"Line":1}},{"line":25,"address":[20526677],"length":1,"stats":{"Line":1}},{"line":30,"address":[13620944],"length":1,"stats":{"Line":0}},{"line":31,"address":[13508264],"length":1,"stats":{"Line":0}},{"line":36,"address":[24750624],"length":1,"stats":{"Line":0}},{"line":37,"address":[24845411],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","mod.rs"],"content":"pub mod bookmark_id;\n\npub use bookmark_id::BookmarkId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","encrypted_post.rs"],"content":"use serde::{Deserialize, Serialize};\n\nconst ENCRYPTED_POST_SCHEMA: &str = \"kukuri-post-cipher-v1\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct EncryptedPostPayload {\n    pub schema: String,\n    pub topic: String,\n    pub scope: String,\n    pub epoch: i64,\n    pub payload_b64: String,\n}\n\nimpl EncryptedPostPayload {\n    pub fn new(topic: String, scope: String, epoch: i64, payload_b64: String) -> Self {\n        Self {\n            schema: ENCRYPTED_POST_SCHEMA.to_string(),\n            topic,\n            scope,\n            epoch,\n            payload_b64,\n        }\n    }\n\n    pub fn schema() -> &'static str {\n        ENCRYPTED_POST_SCHEMA\n    }\n\n    pub fn try_parse(content: &str) -> Option<Self> {\n        let value: Self = serde_json::from_str(content).ok()?;\n        if value.schema == ENCRYPTED_POST_SCHEMA {\n            Some(value)\n        } else {\n            None\n        }\n    }\n}\n","traces":[{"line":15,"address":[13508702,13508352,13508743],"length":1,"stats":{"Line":1}},{"line":17,"address":[13582988],"length":1,"stats":{"Line":1}},{"line":29,"address":[21283760,21284330],"length":1,"stats":{"Line":1}},{"line":30,"address":[13590684,13590337],"length":1,"stats":{"Line":2}},{"line":31,"address":[13509228,13509252,13509136],"length":1,"stats":{"Line":2}},{"line":32,"address":[13590774],"length":1,"stats":{"Line":1}},{"line":34,"address":[13590759],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","mod.rs"],"content":"pub mod public_key;\npub mod reaction_value;\npub mod topic_content;\n\npub use public_key::PublicKey;\npub use reaction_value::ReactionValue;\npub use topic_content::TopicContent;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","public_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Nostr の公開鍵（hex 64文字）を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PublicKey(String);\n\nimpl PublicKey {\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn from_hex_str(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    /// 内部の16進文字列を参照で取得する。\n    pub fn as_hex(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.len() != 64 {\n            return Err(\"Public key must be 64 hex characters\".to_string());\n        }\n        if !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Public key must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for PublicKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<PublicKey> for String {\n    fn from(value: PublicKey) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for PublicKey {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::from_hex_str(value)\n    }\n}\n","traces":[{"line":10,"address":[16488283,16487904],"length":1,"stats":{"Line":0}},{"line":11,"address":[17046726,17046446,17046519],"length":1,"stats":{"Line":0}},{"line":12,"address":[16687393],"length":1,"stats":{"Line":0}},{"line":16,"address":[16556080],"length":1,"stats":{"Line":2}},{"line":17,"address":[24249579,24249752],"length":1,"stats":{"Line":2}},{"line":18,"address":[16587375],"length":1,"stats":{"Line":2}},{"line":22,"address":[16549440],"length":1,"stats":{"Line":2}},{"line":23,"address":[17047109],"length":1,"stats":{"Line":2}},{"line":26,"address":[16488624],"length":1,"stats":{"Line":2}},{"line":27,"address":[16591554],"length":1,"stats":{"Line":2}},{"line":28,"address":[17047222],"length":1,"stats":{"Line":0}},{"line":30,"address":[16688192,16688205,16688007],"length":1,"stats":{"Line":6}},{"line":31,"address":[16556543],"length":1,"stats":{"Line":0}},{"line":33,"address":[16488844],"length":1,"stats":{"Line":2}},{"line":38,"address":[16688224],"length":1,"stats":{"Line":0}},{"line":39,"address":[16549768],"length":1,"stats":{"Line":0}},{"line":44,"address":[24713888],"length":1,"stats":{"Line":0}},{"line":45,"address":[24749011],"length":1,"stats":{"Line":0}},{"line":52,"address":[16587968],"length":1,"stats":{"Line":0}},{"line":53,"address":[24250261],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","reaction_value.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// リアクション（例: 👍, ❤️）の値を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ReactionValue(String);\n\nimpl ReactionValue {\n    const MAX_LENGTH: usize = 20;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Reaction cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Reaction is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for ReactionValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<ReactionValue> for String {\n    fn from(value: ReactionValue) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for ReactionValue {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for ReactionValue {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[16591952,16592331],"length":1,"stats":{"Line":0}},{"line":12,"address":[16475342,16475622,16475415],"length":1,"stats":{"Line":0}},{"line":13,"address":[16593777],"length":1,"stats":{"Line":0}},{"line":16,"address":[20527200],"length":1,"stats":{"Line":0}},{"line":17,"address":[16550363,16550536],"length":1,"stats":{"Line":0}},{"line":18,"address":[16594127],"length":1,"stats":{"Line":0}},{"line":21,"address":[24250992],"length":1,"stats":{"Line":0}},{"line":22,"address":[16689093],"length":1,"stats":{"Line":0}},{"line":25,"address":[16592672],"length":1,"stats":{"Line":0}},{"line":26,"address":[16689161],"length":1,"stats":{"Line":0}},{"line":27,"address":[16550734],"length":1,"stats":{"Line":0}},{"line":29,"address":[16588822],"length":1,"stats":{"Line":0}},{"line":30,"address":[16550816],"length":1,"stats":{"Line":0}},{"line":35,"address":[16588910],"length":1,"stats":{"Line":0}},{"line":40,"address":[16593024],"length":1,"stats":{"Line":0}},{"line":41,"address":[16483192],"length":1,"stats":{"Line":0}},{"line":46,"address":[24845472],"length":1,"stats":{"Line":0}},{"line":47,"address":[24750691],"length":1,"stats":{"Line":0}},{"line":54,"address":[16594784],"length":1,"stats":{"Line":0}},{"line":55,"address":[20527989],"length":1,"stats":{"Line":0}},{"line":62,"address":[16594832],"length":1,"stats":{"Line":0}},{"line":63,"address":[16483349],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","topic_content.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// トピック投稿など、長文コンテンツを扱う値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TopicContent(String);\n\nimpl TopicContent {\n    const MAX_LENGTH: usize = 10_000;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn into_string(self) -> String {\n        self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Content is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for TopicContent {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicContent> for String {\n    fn from(value: TopicContent) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for TopicContent {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for TopicContent {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[14230011,14229632],"length":1,"stats":{"Line":0}},{"line":12,"address":[14222878,14222951,14223158],"length":1,"stats":{"Line":0}},{"line":13,"address":[14335729],"length":1,"stats":{"Line":0}},{"line":16,"address":[25770096],"length":1,"stats":{"Line":0}},{"line":17,"address":[14340120,14339947],"length":1,"stats":{"Line":0}},{"line":18,"address":[25770207],"length":1,"stats":{"Line":0}},{"line":21,"address":[21998528],"length":1,"stats":{"Line":0}},{"line":22,"address":[14298149],"length":1,"stats":{"Line":0}},{"line":25,"address":[25770400],"length":1,"stats":{"Line":0}},{"line":26,"address":[21998547],"length":1,"stats":{"Line":0}},{"line":29,"address":[14340240],"length":1,"stats":{"Line":0}},{"line":30,"address":[14305177],"length":1,"stats":{"Line":0}},{"line":31,"address":[14436784],"length":1,"stats":{"Line":0}},{"line":33,"address":[14340326],"length":1,"stats":{"Line":0}},{"line":34,"address":[14230578],"length":1,"stats":{"Line":0}},{"line":39,"address":[14305296],"length":1,"stats":{"Line":0}},{"line":44,"address":[14336656],"length":1,"stats":{"Line":0}},{"line":45,"address":[14336680],"length":1,"stats":{"Line":0}},{"line":50,"address":[12212544],"length":1,"stats":{"Line":0}},{"line":51,"address":[12212547],"length":1,"stats":{"Line":0}},{"line":58,"address":[14298656],"length":1,"stats":{"Line":0}},{"line":59,"address":[14336789],"length":1,"stats":{"Line":0}},{"line":66,"address":[25770944],"length":1,"stats":{"Line":0}},{"line":67,"address":[14298725],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EventId(String);\n\nimpl EventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Event ID cannot be empty\".to_string());\n        }\n        // Validate hex format (64 characters)\n        if value.len() != 64 || !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Invalid event ID format: must be 64 hex characters\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        use sha2::{Digest, Sha256};\n        let random_bytes = uuid::Uuid::new_v4().as_bytes().to_vec();\n        let hash = Sha256::digest(&random_bytes);\n        Self(format!(\"{hash:x}\"))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn from_hex(hex: &str) -> Result<Self, String> {\n        Self::new(hex.to_string())\n    }\n\n    pub fn to_hex(&self) -> String {\n        self.0.clone()\n    }\n}\n\nimpl fmt::Display for EventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EventId> for String {\n    fn from(id: EventId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[20715264,20715799],"length":1,"stats":{"Line":2}},{"line":9,"address":[20528150,20528094],"length":1,"stats":{"Line":4}},{"line":10,"address":[20914685,20915075],"length":1,"stats":{"Line":0}},{"line":13,"address":[20783584,20783597,20783121,20783241,20783169],"length":1,"stats":{"Line":10}},{"line":14,"address":[14956246,14955981],"length":1,"stats":{"Line":0}},{"line":16,"address":[20814502],"length":1,"stats":{"Line":2}},{"line":19,"address":[20776688,20777002],"length":1,"stats":{"Line":1}},{"line":21,"address":[20528673],"length":1,"stats":{"Line":1}},{"line":22,"address":[20715934],"length":1,"stats":{"Line":1}},{"line":23,"address":[20818871],"length":1,"stats":{"Line":1}},{"line":26,"address":[20528992],"length":1,"stats":{"Line":1}},{"line":27,"address":[20915509],"length":1,"stats":{"Line":1}},{"line":30,"address":[20783968],"length":1,"stats":{"Line":2}},{"line":31,"address":[20716231],"length":1,"stats":{"Line":2}},{"line":34,"address":[20915584],"length":1,"stats":{"Line":2}},{"line":35,"address":[20777121],"length":1,"stats":{"Line":2}},{"line":40,"address":[20784080],"length":1,"stats":{"Line":1}},{"line":41,"address":[20819224],"length":1,"stats":{"Line":1}},{"line":46,"address":[24745168],"length":1,"stats":{"Line":0}},{"line":47,"address":[18886771],"length":1,"stats":{"Line":0}}],"covered":16,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","keychain.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\nconst LEDGER_VERSION: u32 = 1;\n\n/// 個々の鍵素材を表すレコード。公開情報のみを保持する。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMaterialRecord {\n    pub npub: String,\n    pub public_key: String,\n    pub created_at: DateTime<Utc>,\n    pub last_used: DateTime<Utc>,\n}\n\nimpl KeyMaterialRecord {\n    pub fn new(npub: String, public_key: String) -> Self {\n        let now = Utc::now();\n        Self {\n            npub,\n            public_key,\n            created_at: now,\n            last_used: now,\n        }\n    }\n\n    pub fn touch(&mut self) {\n        self.last_used = Utc::now();\n    }\n}\n\n/// KeyManager が参照する鍵素材の台帳。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyMaterialLedger {\n    pub version: u32,\n    pub records: HashMap<String, KeyMaterialRecord>,\n    pub current_npub: Option<String>,\n}\n\nimpl Default for KeyMaterialLedger {\n    fn default() -> Self {\n        Self {\n            version: LEDGER_VERSION,\n            records: HashMap::new(),\n            current_npub: None,\n        }\n    }\n}\n\nimpl KeyMaterialLedger {\n    pub fn upsert(&mut self, record: KeyMaterialRecord) {\n        let npub = record.npub.clone();\n        self.records.insert(npub, record);\n    }\n\n    pub fn remove(&mut self, npub: &str) -> bool {\n        let removed = self.records.remove(npub).is_some();\n        if removed && self.current_npub.as_deref() == Some(npub) {\n            self.current_npub = None;\n        }\n        removed\n    }\n\n    pub fn touch_current(&mut self, npub: &str) {\n        if let Some(record) = self.records.get_mut(npub) {\n            record.touch();\n            self.current_npub = Some(npub.to_string());\n        }\n    }\n}\n","traces":[{"line":17,"address":[15982320,15982582,15982557],"length":1,"stats":{"Line":0}},{"line":18,"address":[16078776],"length":1,"stats":{"Line":0}},{"line":27,"address":[15947472],"length":1,"stats":{"Line":0}},{"line":28,"address":[15872750],"length":1,"stats":{"Line":0}},{"line":41,"address":[15947536],"length":1,"stats":{"Line":0}},{"line":44,"address":[16079101],"length":1,"stats":{"Line":0}},{"line":51,"address":[15866381,15866128,15866352],"length":1,"stats":{"Line":0}},{"line":52,"address":[16079224],"length":1,"stats":{"Line":0}},{"line":53,"address":[15978938],"length":1,"stats":{"Line":0}},{"line":56,"address":[16079472,16079870],"length":1,"stats":{"Line":0}},{"line":57,"address":[15941046],"length":1,"stats":{"Line":0}},{"line":58,"address":[12213692,12213487,12213465],"length":1,"stats":{"Line":0}},{"line":59,"address":[15873456],"length":1,"stats":{"Line":0}},{"line":64,"address":[23641992,23641808],"length":1,"stats":{"Line":0}},{"line":65,"address":[15866868,15867075],"length":1,"stats":{"Line":0}},{"line":66,"address":[15948439],"length":1,"stats":{"Line":0}},{"line":67,"address":[15880809,15880759,15880698],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","mod.rs"],"content":"pub mod bookmark;\npub mod encrypted_post;\npub mod event_gateway;\npub mod event_id;\npub mod keychain;\npub mod npub;\npub mod offline;\npub mod subscription;\npub mod topic_id;\n\npub use bookmark::BookmarkId;\npub use encrypted_post::EncryptedPostPayload;\npub use event_gateway::{PublicKey, ReactionValue, TopicContent};\npub use event_id::EventId;\npub use keychain::{KeyMaterialLedger, KeyMaterialRecord};\npub use npub::Npub;\npub use offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\npub use subscription::{\n    RESYNC_BACKOFF_SECS, SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use topic_id::TopicId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","npub.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Npub(String);\n\nimpl Npub {\n    pub fn new(value: String) -> Result<Self, String> {\n        if !value.starts_with(\"npub1\") {\n            return Err(\"Invalid npub format: must start with 'npub1'\".to_string());\n        }\n        if value.len() != 63 {\n            return Err(\"Invalid npub format: incorrect length\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn to_pubkey(&self) -> Result<String, String> {\n        // This would normally use bech32 decoding\n        // For now, return a placeholder\n        Ok(format!(\"pubkey_from_{}\", self.0))\n    }\n}\n\nimpl fmt::Display for Npub {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<Npub> for String {\n    fn from(npub: Npub) -> Self {\n        npub.0\n    }\n}\n","traces":[{"line":8,"address":[15980241,15979792],"length":1,"stats":{"Line":0}},{"line":9,"address":[16080190,16080258],"length":1,"stats":{"Line":0}},{"line":10,"address":[15979976,15979927],"length":1,"stats":{"Line":0}},{"line":12,"address":[15983966,15983896],"length":1,"stats":{"Line":0}},{"line":13,"address":[15980156,15980202],"length":1,"stats":{"Line":0}},{"line":15,"address":[15941934],"length":1,"stats":{"Line":0}},{"line":18,"address":[15980272],"length":1,"stats":{"Line":0}},{"line":19,"address":[23642549],"length":1,"stats":{"Line":0}},{"line":22,"address":[15980288],"length":1,"stats":{"Line":0}},{"line":25,"address":[15874392],"length":1,"stats":{"Line":0}},{"line":30,"address":[16080832],"length":1,"stats":{"Line":0}},{"line":31,"address":[15867784],"length":1,"stats":{"Line":0}},{"line":36,"address":[24745200],"length":1,"stats":{"Line":0}},{"line":37,"address":[12213971],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// アプリケーションが参照するオフラインアクションの識別子（`local_id` 相当）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionId(String);\n\nimpl OfflineActionId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionId> for String {\n    fn from(id: OfflineActionId) -> Self {\n        id.0\n    }\n}\n\nimpl FromStr for OfflineActionId {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":9,"address":[16933360,16933739],"length":1,"stats":{"Line":0}},{"line":10,"address":[16927806,16928086,16927879],"length":1,"stats":{"Line":0}},{"line":11,"address":[17047745],"length":1,"stats":{"Line":0}},{"line":14,"address":[17047968],"length":1,"stats":{"Line":2}},{"line":15,"address":[16928235,16928408],"length":1,"stats":{"Line":2}},{"line":16,"address":[16897119],"length":1,"stats":{"Line":2}},{"line":19,"address":[11070080],"length":1,"stats":{"Line":1}},{"line":20,"address":[16829541],"length":1,"stats":{"Line":2}},{"line":23,"address":[16934080],"length":1,"stats":{"Line":2}},{"line":24,"address":[16890432],"length":1,"stats":{"Line":2}},{"line":25,"address":[16890472],"length":1,"stats":{"Line":0}},{"line":27,"address":[16890457],"length":1,"stats":{"Line":2}},{"line":32,"address":[16822736],"length":1,"stats":{"Line":2}},{"line":33,"address":[16822760],"length":1,"stats":{"Line":3}},{"line":38,"address":[24714048],"length":1,"stats":{"Line":0}},{"line":39,"address":[24707123],"length":1,"stats":{"Line":0}},{"line":46,"address":[17048544],"length":1,"stats":{"Line":0}},{"line":47,"address":[16934373],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// オフラインアクションの種類（例: `publish_text_note`、`send_reaction`）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionType(String);\n\nimpl OfflineActionType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionType> for String {\n    fn from(kind: OfflineActionType) -> Self {\n        kind.0\n    }\n}\n","traces":[{"line":9,"address":[15117323,15116944],"length":1,"stats":{"Line":2}},{"line":10,"address":[24706582,24706302,24706375],"length":1,"stats":{"Line":4}},{"line":11,"address":[15117121],"length":1,"stats":{"Line":2}},{"line":14,"address":[22892336],"length":1,"stats":{"Line":2}},{"line":15,"address":[15234005],"length":1,"stats":{"Line":2}},{"line":18,"address":[15191968],"length":1,"stats":{"Line":2}},{"line":19,"address":[15117424],"length":1,"stats":{"Line":2}},{"line":20,"address":[15198984],"length":1,"stats":{"Line":0}},{"line":22,"address":[24706761],"length":1,"stats":{"Line":2}},{"line":27,"address":[15230240],"length":1,"stats":{"Line":0}},{"line":28,"address":[15117560],"length":1,"stats":{"Line":0}},{"line":33,"address":[24750848],"length":1,"stats":{"Line":0}},{"line":34,"address":[24845635],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheKey(String);\n\nimpl CacheKey {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache key cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheKey> for String {\n    fn from(key: CacheKey) -> Self {\n        key.0\n    }\n}\n","traces":[{"line":8,"address":[16816112,16816491],"length":1,"stats":{"Line":4}},{"line":9,"address":[23920318,23920391,23920598],"length":1,"stats":{"Line":8}},{"line":10,"address":[16816289],"length":1,"stats":{"Line":4}},{"line":13,"address":[11070832],"length":1,"stats":{"Line":2}},{"line":14,"address":[16933173],"length":1,"stats":{"Line":2}},{"line":17,"address":[16891136],"length":1,"stats":{"Line":4}},{"line":18,"address":[16816592],"length":1,"stats":{"Line":4}},{"line":19,"address":[16898152],"length":1,"stats":{"Line":0}},{"line":21,"address":[23920777],"length":1,"stats":{"Line":4}},{"line":26,"address":[16929408],"length":1,"stats":{"Line":0}},{"line":27,"address":[16816728],"length":1,"stats":{"Line":0}},{"line":32,"address":[24750880],"length":1,"stats":{"Line":0}},{"line":33,"address":[24845667],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheType(String);\n\nimpl CacheType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheType> for String {\n    fn from(value: CacheType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[23712928,23713307],"length":1,"stats":{"Line":3}},{"line":9,"address":[18051710,18051783,18051990],"length":1,"stats":{"Line":5}},{"line":10,"address":[23713105],"length":1,"stats":{"Line":3}},{"line":13,"address":[17967648],"length":1,"stats":{"Line":2}},{"line":14,"address":[23829989],"length":1,"stats":{"Line":2}},{"line":17,"address":[23787952],"length":1,"stats":{"Line":2}},{"line":18,"address":[23713408],"length":1,"stats":{"Line":3}},{"line":19,"address":[23794968],"length":1,"stats":{"Line":0}},{"line":21,"address":[18052169],"length":1,"stats":{"Line":2}},{"line":26,"address":[23826224],"length":1,"stats":{"Line":3}},{"line":27,"address":[23713544],"length":1,"stats":{"Line":3}},{"line":32,"address":[24750912],"length":1,"stats":{"Line":0}},{"line":33,"address":[24845699],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityId(String);\n\nimpl EntityId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityId> for String {\n    fn from(value: EntityId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[23713632,23714011],"length":1,"stats":{"Line":2}},{"line":9,"address":[24707270,24706990,24707063],"length":1,"stats":{"Line":4}},{"line":10,"address":[23713809],"length":1,"stats":{"Line":2}},{"line":13,"address":[17968352],"length":1,"stats":{"Line":2}},{"line":14,"address":[23830693],"length":1,"stats":{"Line":2}},{"line":17,"address":[23788656],"length":1,"stats":{"Line":2}},{"line":18,"address":[23714112],"length":1,"stats":{"Line":2}},{"line":19,"address":[23795672],"length":1,"stats":{"Line":0}},{"line":21,"address":[24707449],"length":1,"stats":{"Line":2}},{"line":26,"address":[23826928],"length":1,"stats":{"Line":2}},{"line":27,"address":[23714248],"length":1,"stats":{"Line":2}},{"line":32,"address":[24750944],"length":1,"stats":{"Line":0}},{"line":33,"address":[24845731],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityType(String);\n\nimpl EntityType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityType> for String {\n    fn from(value: EntityType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[24632688,24633067],"length":1,"stats":{"Line":2}},{"line":9,"address":[19289591,19289518,19289798],"length":1,"stats":{"Line":4}},{"line":10,"address":[24632865],"length":1,"stats":{"Line":2}},{"line":13,"address":[18887408],"length":1,"stats":{"Line":2}},{"line":14,"address":[24749749],"length":1,"stats":{"Line":2}},{"line":17,"address":[24707712],"length":1,"stats":{"Line":2}},{"line":18,"address":[24633168],"length":1,"stats":{"Line":2}},{"line":19,"address":[24714728],"length":1,"stats":{"Line":0}},{"line":21,"address":[19289977],"length":1,"stats":{"Line":2}},{"line":26,"address":[24745984],"length":1,"stats":{"Line":1}},{"line":27,"address":[24633304],"length":1,"stats":{"Line":1}},{"line":32,"address":[24751680],"length":1,"stats":{"Line":0}},{"line":33,"address":[24846467],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","mod.rs"],"content":"pub mod action_id;\npub mod action_type;\npub mod cache_key;\npub mod cache_type;\npub mod entity_id;\npub mod entity_type;\npub mod optimistic_update_id;\npub mod payload;\npub mod remote_event_id;\npub mod sync_queue_id;\npub mod sync_queue_status;\npub mod sync_status;\n\npub use action_id::OfflineActionId;\npub use action_type::OfflineActionType;\npub use cache_key::CacheKey;\npub use cache_type::CacheType;\npub use entity_id::EntityId;\npub use entity_type::EntityType;\npub use optimistic_update_id::OptimisticUpdateId;\npub use payload::OfflinePayload;\npub use remote_event_id::RemoteEventId;\npub use sync_queue_id::SyncQueueId;\npub use sync_queue_status::SyncQueueStatus;\npub use sync_status::SyncStatus;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","optimistic_update_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OptimisticUpdateId(String);\n\nimpl OptimisticUpdateId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Optimistic update ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OptimisticUpdateId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OptimisticUpdateId> for String {\n    fn from(value: OptimisticUpdateId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[22941392,22941771],"length":1,"stats":{"Line":1}},{"line":9,"address":[12966215,12966422,12966142],"length":1,"stats":{"Line":2}},{"line":10,"address":[22941569],"length":1,"stats":{"Line":1}},{"line":13,"address":[17196112],"length":1,"stats":{"Line":1}},{"line":14,"address":[23058453],"length":1,"stats":{"Line":1}},{"line":17,"address":[23016416],"length":1,"stats":{"Line":1}},{"line":18,"address":[22941872],"length":1,"stats":{"Line":1}},{"line":19,"address":[23023432],"length":1,"stats":{"Line":0}},{"line":21,"address":[12966601],"length":1,"stats":{"Line":1}},{"line":26,"address":[23054688],"length":1,"stats":{"Line":0}},{"line":27,"address":[22942008],"length":1,"stats":{"Line":0}},{"line":32,"address":[24751712],"length":1,"stats":{"Line":0}},{"line":33,"address":[24846499],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","payload.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflinePayload(Value);\n\nimpl OfflinePayload {\n    pub fn new(value: Value) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn from_json_str(json: &str) -> Result<Self, String> {\n        let value: Value =\n            serde_json::from_str(json).map_err(|e| format!(\"Invalid JSON payload: {e}\"))?;\n        Self::new(value)\n    }\n\n    pub fn as_json(&self) -> &Value {\n        &self.0\n    }\n\n    pub fn into_inner(self) -> Value {\n        self.0\n    }\n\n    fn validate(value: &Value) -> Result<(), String> {\n        if value.is_null() {\n            return Err(\"Offline payload cannot be null\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl From<OfflinePayload> for Value {\n    fn from(payload: OfflinePayload) -> Self {\n        payload.0\n    }\n}\n","traces":[{"line":8,"address":[23155168,23155532],"length":1,"stats":{"Line":2}},{"line":9,"address":[22942123,22942391,22942171],"length":1,"stats":{"Line":4}},{"line":10,"address":[23016830],"length":1,"stats":{"Line":2}},{"line":13,"address":[23024016,23024367,23024396],"length":1,"stats":{"Line":2}},{"line":14,"address":[26515424],"length":1,"stats":{"Line":2}},{"line":16,"address":[22942665],"length":1,"stats":{"Line":2}},{"line":19,"address":[23156176],"length":1,"stats":{"Line":2}},{"line":23,"address":[23017712],"length":1,"stats":{"Line":1}},{"line":24,"address":[26516003],"length":1,"stats":{"Line":1}},{"line":27,"address":[23061456],"length":1,"stats":{"Line":2}},{"line":28,"address":[23156270],"length":1,"stats":{"Line":2}},{"line":29,"address":[23156300],"length":1,"stats":{"Line":0}},{"line":31,"address":[22943213],"length":1,"stats":{"Line":2}},{"line":36,"address":[16483376],"length":1,"stats":{"Line":0}},{"line":37,"address":[16589299],"length":1,"stats":{"Line":0}}],"covered":12,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","remote_event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RemoteEventId(String);\n\nimpl RemoteEventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.trim().is_empty() {\n            return Err(\"Remote event ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for RemoteEventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<RemoteEventId> for String {\n    fn from(value: RemoteEventId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[21439323,21438976],"length":1,"stats":{"Line":0}},{"line":9,"address":[21364270,21364338],"length":1,"stats":{"Line":0}},{"line":10,"address":[21470414,21470465],"length":1,"stats":{"Line":0}},{"line":12,"address":[21371372],"length":1,"stats":{"Line":0}},{"line":15,"address":[21570912],"length":1,"stats":{"Line":0}},{"line":16,"address":[21476133],"length":1,"stats":{"Line":0}},{"line":21,"address":[21570928],"length":1,"stats":{"Line":0}},{"line":22,"address":[21474520],"length":1,"stats":{"Line":0}},{"line":27,"address":[24746160],"length":1,"stats":{"Line":0}},{"line":28,"address":[24746163],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct SyncQueueId(i64);\n\nimpl SyncQueueId {\n    pub fn new(value: i64) -> Result<Self, String> {\n        if value <= 0 {\n            return Err(\"Sync queue id must be positive\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn value(&self) -> i64 {\n        self.0\n    }\n}\n\nimpl fmt::Display for SyncQueueId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<SyncQueueId> for i64 {\n    fn from(id: SyncQueueId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[14437232],"length":1,"stats":{"Line":4}},{"line":9,"address":[14336887],"length":1,"stats":{"Line":3}},{"line":10,"address":[14237977],"length":1,"stats":{"Line":0}},{"line":12,"address":[14342486],"length":1,"stats":{"Line":4}},{"line":15,"address":[21999264],"length":1,"stats":{"Line":1}},{"line":16,"address":[14437365],"length":1,"stats":{"Line":1}},{"line":21,"address":[14437376],"length":1,"stats":{"Line":0}},{"line":22,"address":[14298920],"length":1,"stats":{"Line":0}},{"line":27,"address":[14395440],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_status.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncQueueStatus {\n    Pending,\n    Processing,\n    Failed,\n    Completed,\n    Unknown(String),\n}\n\nimpl SyncQueueStatus {\n    pub fn as_str(&self) -> &str {\n        match self {\n            SyncQueueStatus::Pending => \"pending\",\n            SyncQueueStatus::Processing => \"processing\",\n            SyncQueueStatus::Failed => \"failed\",\n            SyncQueueStatus::Completed => \"completed\",\n            SyncQueueStatus::Unknown(value) => value.as_str(),\n        }\n    }\n}\n\nimpl From<&str> for SyncQueueStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncQueueStatus::Pending,\n            \"processing\" => SyncQueueStatus::Processing,\n            \"failed\" => SyncQueueStatus::Failed,\n            \"completed\" => SyncQueueStatus::Completed,\n            other => SyncQueueStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":13,"address":[15117648],"length":1,"stats":{"Line":2}},{"line":14,"address":[15205182,15205359],"length":1,"stats":{"Line":4}},{"line":15,"address":[15117722],"length":1,"stats":{"Line":2}},{"line":16,"address":[22892721],"length":1,"stats":{"Line":0}},{"line":17,"address":[15234408],"length":1,"stats":{"Line":1}},{"line":18,"address":[15192383],"length":1,"stats":{"Line":0}},{"line":19,"address":[15117819],"length":1,"stats":{"Line":0}},{"line":25,"address":[15199376],"length":1,"stats":{"Line":2}},{"line":27,"address":[15205424,15205482],"length":1,"stats":{"Line":5}},{"line":28,"address":[15230721,15230638],"length":1,"stats":{"Line":1}},{"line":29,"address":[15118069,15117989],"length":1,"stats":{"Line":2}},{"line":30,"address":[15236329,15236430],"length":1,"stats":{"Line":0}},{"line":31,"address":[15331165],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_status.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse serde::{Deserialize, Serialize};\nuse std::borrow::Cow;\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncStatus {\n    Pending,\n    SentToNostr,\n    SentToP2P,\n    FullySynced,\n    Failed,\n    Conflict,\n    Invalid(ValidationFailureKind),\n    Unknown(String),\n}\n\nimpl SyncStatus {\n    pub fn as_str(&self) -> Cow<'static, str> {\n        match self {\n            SyncStatus::Pending => Cow::Borrowed(\"pending\"),\n            SyncStatus::SentToNostr => Cow::Borrowed(\"sent_to_nostr\"),\n            SyncStatus::SentToP2P => Cow::Borrowed(\"sent_to_p2p\"),\n            SyncStatus::FullySynced => Cow::Borrowed(\"fully_synced\"),\n            SyncStatus::Failed => Cow::Borrowed(\"failed\"),\n            SyncStatus::Conflict => Cow::Borrowed(\"conflict\"),\n            SyncStatus::Invalid(kind) => Cow::Owned(format!(\"invalid:{}\", kind.as_str())),\n            SyncStatus::Unknown(value) => Cow::Owned(value.clone()),\n        }\n    }\n\n    pub fn is_terminal(&self) -> bool {\n        matches!(\n            self,\n            SyncStatus::FullySynced\n                | SyncStatus::Failed\n                | SyncStatus::Conflict\n                | SyncStatus::Invalid(_)\n        )\n    }\n}\n\nimpl fmt::Display for SyncStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl From<&str> for SyncStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncStatus::Pending,\n            \"sent_to_nostr\" => SyncStatus::SentToNostr,\n            \"sent_to_p2p\" => SyncStatus::SentToP2P,\n            \"fully_synced\" => SyncStatus::FullySynced,\n            \"failed\" => SyncStatus::Failed,\n            \"conflict\" => SyncStatus::Conflict,\n            value if value.starts_with(\"invalid:\") => {\n                let reason = &value[8..];\n                let kind = reason.parse().unwrap_or(ValidationFailureKind::Generic);\n                SyncStatus::Invalid(kind)\n            }\n            other => SyncStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":19,"address":[14337136],"length":1,"stats":{"Line":2}},{"line":20,"address":[14238222],"length":1,"stats":{"Line":2}},{"line":21,"address":[14231311],"length":1,"stats":{"Line":2}},{"line":22,"address":[14306089],"length":1,"stats":{"Line":0}},{"line":23,"address":[14306131],"length":1,"stats":{"Line":0}},{"line":24,"address":[14437725],"length":1,"stats":{"Line":0}},{"line":25,"address":[14299287],"length":1,"stats":{"Line":0}},{"line":26,"address":[21999713],"length":1,"stats":{"Line":0}},{"line":27,"address":[14299371],"length":1,"stats":{"Line":0}},{"line":28,"address":[14337666],"length":1,"stats":{"Line":1}},{"line":32,"address":[14231824],"length":1,"stats":{"Line":0}},{"line":33,"address":[14299669],"length":1,"stats":{"Line":0}},{"line":34,"address":[14299637],"length":1,"stats":{"Line":0}},{"line":44,"address":[16438192,16438384],"length":1,"stats":{"Line":0}},{"line":45,"address":[14238914],"length":1,"stats":{"Line":0}},{"line":50,"address":[14239104],"length":1,"stats":{"Line":2}},{"line":52,"address":[14225437,14225368],"length":1,"stats":{"Line":4}},{"line":53,"address":[14307013,14306919],"length":1,"stats":{"Line":1}},{"line":54,"address":[14343743,14343837],"length":1,"stats":{"Line":1}},{"line":55,"address":[14232389,14232295],"length":1,"stats":{"Line":1}},{"line":56,"address":[14232351,14232445],"length":1,"stats":{"Line":1}},{"line":57,"address":[16438800,16438695],"length":1,"stats":{"Line":1}},{"line":58,"address":[14239439],"length":1,"stats":{"Line":1}},{"line":59,"address":[16438872],"length":1,"stats":{"Line":0}},{"line":60,"address":[14300436],"length":1,"stats":{"Line":0}},{"line":61,"address":[14232664],"length":1,"stats":{"Line":0}},{"line":63,"address":[14232530],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":27},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","subscription.rs"],"content":"use crate::shared::{AppError, ValidationFailureKind};\nuse nostr_sdk::prelude::Timestamp;\nuse std::str::FromStr;\n\npub const RESYNC_BACKOFF_SECS: i64 = 300;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum SubscriptionTarget {\n    Topic(String),\n    User(String),\n}\n\nimpl SubscriptionTarget {\n    pub fn as_parts(&self) -> (&str, &str) {\n        match self {\n            SubscriptionTarget::Topic(id) => (\"topic\", id.as_str()),\n            SubscriptionTarget::User(id) => (\"user\", id.as_str()),\n        }\n    }\n\n    pub fn from_parts(target_type: &str, target: String) -> Result<Self, AppError> {\n        match target_type {\n            \"topic\" => Ok(SubscriptionTarget::Topic(target)),\n            \"user\" => Ok(SubscriptionTarget::User(target)),\n            other => Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unknown subscription target type: {other}\"),\n            )),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SubscriptionStatus {\n    Pending,\n    Subscribed,\n    NeedsResync,\n}\n\nimpl SubscriptionStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            SubscriptionStatus::Pending => \"pending\",\n            SubscriptionStatus::Subscribed => \"subscribed\",\n            SubscriptionStatus::NeedsResync => \"needs_resync\",\n        }\n    }\n\n    pub fn parse(value: &str) -> Result<Self, AppError> {\n        match value {\n            \"pending\" => Ok(SubscriptionStatus::Pending),\n            \"subscribed\" => Ok(SubscriptionStatus::Subscribed),\n            \"needs_resync\" => Ok(SubscriptionStatus::NeedsResync),\n            other => Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Unknown subscription status: {other}\"),\n            )),\n        }\n    }\n}\n\nimpl FromStr for SubscriptionStatus {\n    type Err = AppError;\n\n    fn from_str(value: &str) -> Result<Self, Self::Err> {\n        Self::parse(value)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SubscriptionRecord {\n    pub target: SubscriptionTarget,\n    pub status: SubscriptionStatus,\n    pub last_synced_at: Option<i64>,\n    pub last_attempt_at: Option<i64>,\n    pub failure_count: i64,\n    pub error_message: Option<String>,\n}\n\nimpl SubscriptionRecord {\n    pub fn new(target: SubscriptionTarget) -> Self {\n        Self {\n            target,\n            status: SubscriptionStatus::Pending,\n            last_synced_at: None,\n            last_attempt_at: None,\n            failure_count: 0,\n            error_message: None,\n        }\n    }\n\n    pub fn mark_requested(&mut self, attempt_ts: i64) {\n        self.status = SubscriptionStatus::Pending;\n        self.last_attempt_at = Some(attempt_ts);\n        self.error_message = None;\n    }\n\n    pub fn mark_subscribed(&mut self, synced_at: i64) {\n        self.status = SubscriptionStatus::Subscribed;\n        self.last_synced_at = Some(synced_at);\n        self.failure_count = 0;\n        self.error_message = None;\n    }\n\n    pub fn mark_failure(&mut self, attempt_ts: i64, error_message: impl Into<String>) {\n        self.status = SubscriptionStatus::NeedsResync;\n        self.last_attempt_at = Some(attempt_ts);\n        self.failure_count += 1;\n        self.error_message = Some(error_message.into());\n    }\n\n    pub fn since_timestamp(&self) -> Option<Timestamp> {\n        let last_synced = self.last_synced_at?;\n        let adjusted = last_synced.saturating_sub(RESYNC_BACKOFF_SECS);\n        Some(Timestamp::from(adjusted as u64))\n    }\n}\n","traces":[{"line":14,"address":[16476640],"length":1,"stats":{"Line":1}},{"line":15,"address":[16593304],"length":1,"stats":{"Line":1}},{"line":16,"address":[16593315],"length":1,"stats":{"Line":1}},{"line":17,"address":[16483514],"length":1,"stats":{"Line":1}},{"line":21,"address":[16690617,16689872],"length":1,"stats":{"Line":1}},{"line":22,"address":[16490624],"length":1,"stats":{"Line":2}},{"line":23,"address":[16476948,16476997,16476880],"length":1,"stats":{"Line":6}},{"line":24,"address":[16595252,16595406,16595486],"length":1,"stats":{"Line":3}},{"line":25,"address":[16590155,16589838],"length":1,"stats":{"Line":0}},{"line":26,"address":[16690222],"length":1,"stats":{"Line":0}},{"line":27,"address":[16551943,16551750],"length":1,"stats":{"Line":0}},{"line":41,"address":[16477568],"length":1,"stats":{"Line":2}},{"line":42,"address":[16484357],"length":1,"stats":{"Line":2}},{"line":43,"address":[16559125],"length":1,"stats":{"Line":2}},{"line":44,"address":[16559148],"length":1,"stats":{"Line":1}},{"line":45,"address":[16491411],"length":1,"stats":{"Line":1}},{"line":49,"address":[24252672],"length":1,"stats":{"Line":2}},{"line":51,"address":[12215427,12215369],"length":1,"stats":{"Line":4}},{"line":52,"address":[16484567,16484656],"length":1,"stats":{"Line":2}},{"line":53,"address":[16594480,16594724],"length":1,"stats":{"Line":2}},{"line":54,"address":[16491661,16491796],"length":1,"stats":{"Line":0}},{"line":55,"address":[16594551],"length":1,"stats":{"Line":0}},{"line":56,"address":[24252892],"length":1,"stats":{"Line":0}},{"line":65,"address":[16594752],"length":1,"stats":{"Line":0}},{"line":66,"address":[16552725],"length":1,"stats":{"Line":0}},{"line":81,"address":[24253136],"length":1,"stats":{"Line":2}},{"line":92,"address":[16691506,16691392],"length":1,"stats":{"Line":2}},{"line":93,"address":[16492098],"length":1,"stats":{"Line":2}},{"line":94,"address":[16559870],"length":1,"stats":{"Line":2}},{"line":95,"address":[16591168,16591096],"length":1,"stats":{"Line":4}},{"line":98,"address":[16560016,16560138],"length":1,"stats":{"Line":1}},{"line":99,"address":[16553106],"length":1,"stats":{"Line":1}},{"line":100,"address":[16595166],"length":1,"stats":{"Line":1}},{"line":101,"address":[24253534],"length":1,"stats":{"Line":1}},{"line":102,"address":[16492408,16492336],"length":1,"stats":{"Line":2}},{"line":105,"address":[16595328,16595696],"length":1,"stats":{"Line":1}},{"line":106,"address":[12216355],"length":1,"stats":{"Line":1}},{"line":107,"address":[16485545],"length":1,"stats":{"Line":1}},{"line":108,"address":[16691934,16691865],"length":1,"stats":{"Line":1}},{"line":109,"address":[16691906,16691997],"length":1,"stats":{"Line":2}},{"line":112,"address":[16560592],"length":1,"stats":{"Line":0}},{"line":113,"address":[16492926,16492844],"length":1,"stats":{"Line":0}},{"line":114,"address":[16692198],"length":1,"stats":{"Line":0}},{"line":115,"address":[24254120],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":44},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","topic_id.rs"],"content":"use crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct TopicId(String);\n\nimpl TopicId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Topic ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn public() -> Self {\n        Self(DEFAULT_PUBLIC_TOPIC_ID.to_string())\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn is_public(&self) -> bool {\n        self.0 == DEFAULT_PUBLIC_TOPIC_ID\n    }\n}\n\nimpl fmt::Display for TopicId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicId> for String {\n    fn from(id: TopicId) -> Self {\n        id.0\n    }\n}\n\nimpl Default for TopicId {\n    fn default() -> Self {\n        Self::public()\n    }\n}\n","traces":[{"line":9,"address":[21476526,21476256],"length":1,"stats":{"Line":0}},{"line":10,"address":[21470697,21470746],"length":1,"stats":{"Line":0}},{"line":11,"address":[19290357,19290404],"length":1,"stats":{"Line":0}},{"line":13,"address":[19290265],"length":1,"stats":{"Line":0}},{"line":16,"address":[21470976],"length":1,"stats":{"Line":0}},{"line":17,"address":[21439805],"length":1,"stats":{"Line":0}},{"line":20,"address":[15612656],"length":1,"stats":{"Line":0}},{"line":21,"address":[21372125],"length":1,"stats":{"Line":0}},{"line":24,"address":[21476720],"length":1,"stats":{"Line":0}},{"line":25,"address":[21433029],"length":1,"stats":{"Line":0}},{"line":28,"address":[21433040],"length":1,"stats":{"Line":0}},{"line":29,"address":[21433045],"length":1,"stats":{"Line":0}},{"line":34,"address":[21365264],"length":1,"stats":{"Line":0}},{"line":35,"address":[21365288],"length":1,"stats":{"Line":0}},{"line":40,"address":[24715008],"length":1,"stats":{"Line":0}},{"line":41,"address":[24708083],"length":1,"stats":{"Line":0}},{"line":46,"address":[19290800],"length":1,"stats":{"Line":0}},{"line":47,"address":[21476888],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","mod.rs"],"content":"pub mod post_cache;\n\npub use post_cache::PostCacheService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","post_cache.rs"],"content":"use crate::application::ports::cache::PostCache;\nuse crate::domain::entities::Post;\nuse async_trait::async_trait;\nuse std::collections::{HashMap, VecDeque};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nconst MAX_TOPIC_CACHE: usize = 200;\n\n#[derive(Clone)]\npub struct PostCacheService {\n    inner: Arc<RwLock<PostCacheInner>>,\n}\n\nstruct PostCacheInner {\n    posts_by_id: HashMap<String, Post>,\n    topic_index: HashMap<String, VecDeque<(String, i64)>>,\n}\n\nimpl Default for PostCacheService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl PostCacheService {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(PostCacheInner {\n                posts_by_id: HashMap::new(),\n                topic_index: HashMap::new(),\n            })),\n        }\n    }\n\n    pub async fn add(&self, post: Post) {\n        Self::add_internal(&self.inner, post).await;\n    }\n\n    pub async fn get(&self, id: &str) -> Option<Post> {\n        let inner = self.inner.read().await;\n        inner.posts_by_id.get(id).cloned()\n    }\n\n    pub async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        let inner = self.inner.read().await;\n        inner\n            .topic_index\n            .get(topic_id)\n            .into_iter()\n            .flat_map(|entries| {\n                entries\n                    .iter()\n                    .filter_map(|(post_id, _)| inner.posts_by_id.get(post_id))\n                    .take(limit)\n                    .cloned()\n            })\n            .collect()\n    }\n\n    pub async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        let mut inner = self.inner.write().await;\n\n        if let Some(entries) = inner.topic_index.remove(topic_id) {\n            for (post_id, _) in entries {\n                if let Some(existing) = inner.posts_by_id.get(&post_id) {\n                    if existing.topic_id == topic_id {\n                        inner.posts_by_id.remove(&post_id);\n                    }\n                } else {\n                    inner.posts_by_id.remove(&post_id);\n                }\n            }\n        }\n\n        let mut sorted_posts = posts;\n        sorted_posts.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n\n        let mut entries = VecDeque::new();\n        for post in sorted_posts.into_iter().take(MAX_TOPIC_CACHE) {\n            let timestamp = post.created_at.timestamp();\n            let post_id = post.id.clone();\n            inner.posts_by_id.insert(post_id.clone(), post);\n            entries.push_back((post_id, timestamp));\n        }\n\n        inner.topic_index.insert(topic_id.to_string(), entries);\n    }\n\n    pub async fn invalidate_topic(&self, topic_id: &str) {\n        let mut inner = self.inner.write().await;\n        if let Some(entries) = inner.topic_index.remove(topic_id) {\n            for (post_id, _) in entries {\n                if let Some(existing) = inner.posts_by_id.get(&post_id) {\n                    if existing.topic_id == topic_id {\n                        inner.posts_by_id.remove(&post_id);\n                    }\n                } else {\n                    inner.posts_by_id.remove(&post_id);\n                }\n            }\n        }\n    }\n\n    pub async fn remove(&self, id: &str) -> Option<Post> {\n        let mut inner = self.inner.write().await;\n        let removed = inner.posts_by_id.remove(id);\n        if removed.is_some() {\n            for entries in inner.topic_index.values_mut() {\n                entries.retain(|(post_id, _)| post_id != id);\n            }\n        }\n        removed\n    }\n\n    async fn add_internal(inner: &Arc<RwLock<PostCacheInner>>, post: Post) {\n        let mut guard = inner.write().await;\n        let topic_id = post.topic_id.clone();\n        let post_id = post.id.clone();\n        let timestamp = post.created_at.timestamp();\n\n        guard.posts_by_id.insert(post_id.clone(), post);\n\n        let entries = guard.topic_index.entry(topic_id).or_default();\n        entries.retain(|(id, _)| id != &post_id);\n        let position = entries.iter().position(|(_, ts)| *ts < timestamp);\n        match position {\n            Some(idx) => entries.insert(idx, (post_id, timestamp)),\n            None => entries.push_back((post_id, timestamp)),\n        }\n        if entries.len() > MAX_TOPIC_CACHE {\n            entries.truncate(MAX_TOPIC_CACHE);\n        }\n    }\n}\n\n#[cfg(test)]\nimpl PostCacheService {\n    pub async fn add_many(&self, posts: Vec<Post>) {\n        for post in posts {\n            Self::add_internal(&self.inner, post).await;\n        }\n    }\n\n    #[allow(dead_code)]\n    pub async fn get_many(&self, ids: &[String]) -> Vec<Post> {\n        let inner = self.inner.read().await;\n        ids.iter()\n            .filter_map(|id| inner.posts_by_id.get(id).cloned())\n            .collect()\n    }\n\n    pub async fn clear(&self) {\n        let mut inner = self.inner.write().await;\n        inner.posts_by_id.clear();\n        inner.topic_index.clear();\n    }\n\n    pub async fn size(&self) -> usize {\n        let inner = self.inner.read().await;\n        inner.posts_by_id.len()\n    }\n}\n\n#[async_trait]\nimpl PostCache for PostCacheService {\n    async fn add(&self, post: Post) {\n        PostCacheService::add(self, post).await;\n    }\n\n    async fn get(&self, id: &str) -> Option<Post> {\n        PostCacheService::get(self, id).await\n    }\n\n    async fn remove(&self, id: &str) -> Option<Post> {\n        PostCacheService::remove(self, id).await\n    }\n\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        PostCacheService::get_by_topic(self, topic_id, limit).await\n    }\n\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        PostCacheService::set_topic_posts(self, topic_id, posts).await;\n    }\n\n    async fn invalidate_topic(&self, topic_id: &str) {\n        PostCacheService::invalidate_topic(self, topic_id).await;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::{TimeZone, Utc};\n\n    fn create_test_post(id: &str, topic_id: &str, ts: i64) -> Post {\n        use crate::domain::entities::user::User;\n\n        let author = User {\n            npub: \"npub1test\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: \"Test User\".to_string(),\n                bio: \"Test bio\".to_string(),\n                avatar_url: None,\n            },\n            name: Some(\"Test User\".to_string()),\n            nip05: None,\n            lud16: None,\n            public_profile: true,\n            show_online_status: false,\n            created_at: Utc::now(),\n            updated_at: Utc::now(),\n        };\n\n        Post {\n            id: id.to_string(),\n            content: \"Test content\".to_string(),\n            author,\n            topic_id: topic_id.to_string(),\n            created_at: Utc.timestamp_opt(ts, 0).unwrap(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: true,\n            is_boosted: false,\n            is_bookmarked: false,\n            scope: None,\n            epoch: None,\n            is_encrypted: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_add_and_get() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\", 1);\n\n        cache.add(post.clone()).await;\n        let retrieved = cache.get(\"1\").await;\n\n        assert!(retrieved.is_some());\n        assert_eq!(retrieved.unwrap().id, \"1\");\n    }\n\n    #[tokio::test]\n    async fn test_topic_ordering_and_limit() {\n        let cache = PostCacheService::new();\n        for i in 0..5 {\n            let post = create_test_post(&format!(\"p{i}\"), \"topic\", i);\n            cache.add(post).await;\n        }\n\n        let posts = cache.get_by_topic(\"topic\", 3).await;\n        assert_eq!(posts.len(), 3);\n        assert_eq!(posts[0].id, \"p4\");\n        assert_eq!(posts[1].id, \"p3\");\n        assert_eq!(posts[2].id, \"p2\");\n    }\n\n    #[tokio::test]\n    async fn test_set_topic_posts_replaces_existing() {\n        let cache = PostCacheService::new();\n\n        let initial = vec![\n            create_test_post(\"old1\", \"topic\", 1),\n            create_test_post(\"old2\", \"topic\", 2),\n        ];\n        cache.set_topic_posts(\"topic\", initial).await;\n\n        let replacement = vec![\n            create_test_post(\"new1\", \"topic\", 10),\n            create_test_post(\"new2\", \"topic\", 11),\n        ];\n        cache.set_topic_posts(\"topic\", replacement.clone()).await;\n\n        let posts = cache.get_by_topic(\"topic\", 10).await;\n        assert_eq!(posts.len(), 2);\n        assert_eq!(posts[0].id, \"new2\");\n        assert_eq!(posts[1].id, \"new1\");\n\n        assert!(cache.get(\"old1\").await.is_none());\n        assert!(cache.get(\"old2\").await.is_none());\n        assert!(cache.get(\"new1\").await.is_some());\n        assert!(cache.get(\"new2\").await.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_invalidate_topic() {\n        let cache = PostCacheService::new();\n        let posts = vec![\n            create_test_post(\"1\", \"topic1\", 1),\n            create_test_post(\"2\", \"topic1\", 2),\n        ];\n\n        cache.set_topic_posts(\"topic1\", posts).await;\n        cache.invalidate_topic(\"topic1\").await;\n\n        assert!(cache.get_by_topic(\"topic1\", 10).await.is_empty());\n        assert!(cache.get(\"1\").await.is_none());\n        assert!(cache.get(\"2\").await.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_remove_post() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\", 1);\n\n        cache.add(post.clone()).await;\n        let removed = cache.remove(\"1\").await;\n\n        assert!(removed.is_some());\n        assert_eq!(removed.unwrap().id, \"1\");\n        assert!(cache.get_by_topic(\"topic1\", 10).await.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_clear_resets_cache() {\n        let cache = PostCacheService::new();\n        cache\n            .add_many(vec![\n                create_test_post(\"1\", \"topic1\", 1),\n                create_test_post(\"2\", \"topic2\", 2),\n            ])\n            .await;\n\n        assert_eq!(cache.size().await, 2);\n        cache.clear().await;\n        assert_eq!(cache.size().await, 0);\n    }\n}\n","traces":[{"line":21,"address":[13622080],"length":1,"stats":{"Line":0}},{"line":22,"address":[21284353],"length":1,"stats":{"Line":0}},{"line":27,"address":[13722464,13722652],"length":1,"stats":{"Line":4}},{"line":29,"address":[13523239],"length":1,"stats":{"Line":4}},{"line":36,"address":[13722793,13722768,13722688,13723320,13722929,13723096,13722966,13722723],"length":1,"stats":{"Line":4}},{"line":37,"address":[13516725,13516840,13516668,13516622],"length":1,"stats":{"Line":2}},{"line":40,"address":[13517282,13517245,13517139,13517874,13517074,13517056,13517104,13517425],"length":1,"stats":{"Line":4}},{"line":41,"address":[11555223],"length":1,"stats":{"Line":2}},{"line":42,"address":[13510906,13510973],"length":1,"stats":{"Line":2}},{"line":45,"address":[13593544,13592826,13592647,13592624,13593006,13592672,13592863,13592707],"length":1,"stats":{"Line":4}},{"line":46,"address":[13627930,13628158,13627973,13628035],"length":1,"stats":{"Line":2}},{"line":47,"address":[13630112,13630045,13630180,13630129],"length":1,"stats":{"Line":4}},{"line":49,"address":[13511828],"length":1,"stats":{"Line":1}},{"line":51,"address":[13525643,13525808],"length":1,"stats":{"Line":2}},{"line":52,"address":[13525904,13525857,13525876],"length":1,"stats":{"Line":3}},{"line":54,"address":[23080624,23080704,23080723],"length":1,"stats":{"Line":3}},{"line":55,"address":[13624841],"length":1,"stats":{"Line":1}},{"line":61,"address":[13629201,13628896,13631912,13630577,13628914,13628960,13629400,13628991],"length":1,"stats":{"Line":4}},{"line":62,"address":[11531761],"length":1,"stats":{"Line":2}},{"line":64,"address":[13594548,13594621],"length":1,"stats":{"Line":2}},{"line":65,"address":[13527151,13526967,13527016,13527205],"length":1,"stats":{"Line":4}},{"line":66,"address":[13527237,13527400],"length":1,"stats":{"Line":2}},{"line":67,"address":[13588314,13588372],"length":1,"stats":{"Line":2}},{"line":68,"address":[13513808],"length":1,"stats":{"Line":1}},{"line":71,"address":[13527512,13527648],"length":1,"stats":{"Line":0}},{"line":76,"address":[13626208],"length":1,"stats":{"Line":1}},{"line":77,"address":[13626263,13628064,13626701,13628032],"length":1,"stats":{"Line":4}},{"line":79,"address":[13588600],"length":1,"stats":{"Line":1}},{"line":80,"address":[13514328,13515144,13514059,13514373,13514172],"length":1,"stats":{"Line":5}},{"line":81,"address":[13595931,13596266],"length":1,"stats":{"Line":2}},{"line":82,"address":[13521597,13521538],"length":1,"stats":{"Line":2}},{"line":83,"address":[13589413,13589475],"length":1,"stats":{"Line":2}},{"line":84,"address":[13627718],"length":1,"stats":{"Line":1}},{"line":87,"address":[23082822],"length":1,"stats":{"Line":1}},{"line":90,"address":[13628114,13629517,13628455,13628169,13628096,13628275,13628312,13628144],"length":1,"stats":{"Line":4}},{"line":91,"address":[11531847],"length":1,"stats":{"Line":2}},{"line":92,"address":[13515998,13516065,13516822],"length":1,"stats":{"Line":2}},{"line":93,"address":[23084683,23084506,23084633,23084481],"length":1,"stats":{"Line":4}},{"line":94,"address":[13516527,13516438],"length":1,"stats":{"Line":2}},{"line":95,"address":[13633249,13633301],"length":1,"stats":{"Line":2}},{"line":96,"address":[13530449],"length":1,"stats":{"Line":1}},{"line":99,"address":[13530524,13530396],"length":1,"stats":{"Line":0}},{"line":105,"address":[13633693,13633873,13633587,13633730,13634609,13633522,13633504,13633552],"length":1,"stats":{"Line":4}},{"line":106,"address":[13591857,13591672,13591734,13591629],"length":1,"stats":{"Line":2}},{"line":107,"address":[13635774,13635841],"length":1,"stats":{"Line":2}},{"line":108,"address":[23085794,23085846],"length":1,"stats":{"Line":2}},{"line":109,"address":[13599228],"length":1,"stats":{"Line":1}},{"line":110,"address":[13636286,13636184,13636272,13636252],"length":1,"stats":{"Line":4}},{"line":113,"address":[23085880],"length":1,"stats":{"Line":1}},{"line":116,"address":[13731209,13731104,13731566,13731139,13731184,13732955,13732912,13731377],"length":1,"stats":{"Line":4}},{"line":117,"address":[13636680,13636620,13636577,13636814],"length":1,"stats":{"Line":2}},{"line":118,"address":[13518836,13518753],"length":1,"stats":{"Line":2}},{"line":119,"address":[21293820,21293897],"length":1,"stats":{"Line":2}},{"line":120,"address":[13600449,13600520],"length":1,"stats":{"Line":2}},{"line":122,"address":[13635648],"length":1,"stats":{"Line":1}},{"line":124,"address":[13525950],"length":1,"stats":{"Line":1}},{"line":125,"address":[13733022,13733008,13732375],"length":1,"stats":{"Line":3}},{"line":126,"address":[21294976,21294986,21294303],"length":1,"stats":{"Line":3}},{"line":127,"address":[21294385],"length":1,"stats":{"Line":2}},{"line":128,"address":[13632404,13632251],"length":1,"stats":{"Line":2}},{"line":129,"address":[13636317,13636065],"length":1,"stats":{"Line":4}},{"line":131,"address":[23087863,23087786,23087805],"length":1,"stats":{"Line":4}},{"line":132,"address":[23087825],"length":1,"stats":{"Line":0}},{"line":167,"address":[13834153,13834649,13834289,13834456,13834326,13834128,13834047],"length":1,"stats":{"Line":5}},{"line":168,"address":[13702936,13702718,13702764,13702821],"length":1,"stats":{"Line":2}},{"line":171,"address":[13628447,13628496,13628707,13628730,13628618,13629192,13628531,13628945],"length":1,"stats":{"Line":0}},{"line":172,"address":[13622052,13622193,13621861],"length":1,"stats":{"Line":0}},{"line":175,"address":[13636968,13636272,13636506,13636223,13636721,13636307,13636483,13636394],"length":1,"stats":{"Line":5}},{"line":176,"address":[23223843,23223525,23223712],"length":1,"stats":{"Line":1}},{"line":179,"address":[13637888,13637601,13637334,13637088,13637225,13637123,13637362,13637031],"length":1,"stats":{"Line":5}},{"line":180,"address":[11717767],"length":1,"stats":{"Line":1}},{"line":183,"address":[13737270,13737457,13736960,13736879,13737114,13736985,13737151],"length":1,"stats":{"Line":4}},{"line":184,"address":[11233504],"length":1,"stats":{"Line":2}},{"line":187,"address":[13631615,13631790,13631946,13631827,13632133,13631689,13631664],"length":1,"stats":{"Line":0}},{"line":188,"address":[11834489],"length":1,"stats":{"Line":0}}],"covered":66,"coverable":75},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_encryption_service.rs"],"content":"use super::encryption_service::EncryptionService;\nuse crate::shared::error::AppError;\nuse aes_gcm::{\n    Aes256Gcm, Key, Nonce,\n    aead::{Aead, AeadCore, KeyInit, OsRng},\n};\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose};\nuse sha2::{Digest, Sha256};\nuse std::str;\n\nconst NONCE_SIZE: usize = 12;\n\npub struct DefaultEncryptionService;\n\nimpl DefaultEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn derive_key(password: &str) -> Key<Aes256Gcm> {\n        let mut hasher = Sha256::new();\n        hasher.update(password.as_bytes());\n        let result = hasher.finalize();\n        let mut key = Key::<Aes256Gcm>::default();\n        key.copy_from_slice(&result);\n        key\n    }\n\n    fn encrypt_internal(plaintext: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Encryption failed: {err}\")))?;\n\n        let mut combined = nonce.to_vec();\n        combined.extend_from_slice(&ciphertext);\n\n        Ok(general_purpose::STANDARD.encode(combined).into_bytes())\n    }\n\n    fn decrypt_internal(encrypted_data: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let encoded = str::from_utf8(encrypted_data)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid encrypted payload: {err}\")))?;\n        let combined = general_purpose::STANDARD\n            .decode(encoded)\n            .map_err(|err| AppError::Crypto(format!(\"Base64 decode failed: {err}\")))?;\n\n        if combined.len() < NONCE_SIZE {\n            return Err(AppError::Crypto(\n                \"Encrypted data is shorter than nonce size\".to_string(),\n            ));\n        }\n\n        let (nonce_bytes, ciphertext) = combined.split_at(NONCE_SIZE);\n        let mut nonce = Nonce::default();\n        nonce.copy_from_slice(nonce_bytes);\n\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n\n        cipher\n            .decrypt(&nonce, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Decryption failed: {err}\")))\n    }\n}\n\nimpl Default for DefaultEncryptionService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EncryptionService for DefaultEncryptionService {\n    async fn encrypt(\n        &self,\n        _data: &[u8],\n        _recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric encryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn decrypt(\n        &self,\n        _encrypted_data: &[u8],\n        _sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric decryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::encrypt_internal(data, password).map_err(|err| Box::new(err) as _)\n    }\n\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::decrypt_internal(encrypted_data, password).map_err(|err| Box::new(err) as _)\n    }\n}\n","traces":[{"line":21,"address":[24254192],"length":1,"stats":{"Line":0}},{"line":22,"address":[16553850],"length":1,"stats":{"Line":0}},{"line":23,"address":[16692350],"length":1,"stats":{"Line":0}},{"line":24,"address":[16597585],"length":1,"stats":{"Line":0}},{"line":25,"address":[16560862],"length":1,"stats":{"Line":0}},{"line":26,"address":[16595996],"length":1,"stats":{"Line":0}},{"line":27,"address":[16554032],"length":1,"stats":{"Line":0}},{"line":30,"address":[16593097,16592208,16593122],"length":1,"stats":{"Line":0}},{"line":31,"address":[16592293],"length":1,"stats":{"Line":0}},{"line":32,"address":[16486401],"length":1,"stats":{"Line":0}},{"line":33,"address":[16592338],"length":1,"stats":{"Line":0}},{"line":34,"address":[24254691,24254951],"length":1,"stats":{"Line":0}},{"line":36,"address":[16598215,16598737,16598720],"length":1,"stats":{"Line":0}},{"line":38,"address":[16554650,16554485],"length":1,"stats":{"Line":0}},{"line":39,"address":[19291766,19291689],"length":1,"stats":{"Line":0}},{"line":41,"address":[16486972],"length":1,"stats":{"Line":0}},{"line":44,"address":[24256687,24255584,24256583],"length":1,"stats":{"Line":0}},{"line":45,"address":[16480896,16480667],"length":1,"stats":{"Line":0}},{"line":46,"address":[16481744,16480868,16481728],"length":1,"stats":{"Line":0}},{"line":47,"address":[16487557,16487706,16487825],"length":1,"stats":{"Line":0}},{"line":49,"address":[16598528,16597650,16598544],"length":1,"stats":{"Line":0}},{"line":51,"address":[16480986,16481116],"length":1,"stats":{"Line":0}},{"line":52,"address":[19293211],"length":1,"stats":{"Line":0}},{"line":53,"address":[16555743],"length":1,"stats":{"Line":0}},{"line":57,"address":[16494882,16494955],"length":1,"stats":{"Line":0}},{"line":58,"address":[16594014],"length":1,"stats":{"Line":0}},{"line":59,"address":[16594033],"length":1,"stats":{"Line":0}},{"line":61,"address":[16556006],"length":1,"stats":{"Line":0}},{"line":62,"address":[16562941],"length":1,"stats":{"Line":0}},{"line":64,"address":[16599746,16599830],"length":1,"stats":{"Line":0}},{"line":66,"address":[24257024,24257041],"length":1,"stats":{"Line":0}},{"line":71,"address":[24257200],"length":1,"stats":{"Line":0}},{"line":72,"address":[16489009],"length":1,"stats":{"Line":0}},{"line":78,"address":[16733600,16733804,16733832,16733565,16733630,16733713,16734104],"length":1,"stats":{"Line":0}},{"line":83,"address":[16697207],"length":1,"stats":{"Line":0}},{"line":84,"address":[16732296],"length":1,"stats":{"Line":0}},{"line":88,"address":[16732764,16732792,16733064,16732673,16732560,16732525,16732590],"length":1,"stats":{"Line":0}},{"line":93,"address":[16732935],"length":1,"stats":{"Line":0}},{"line":94,"address":[16734552],"length":1,"stats":{"Line":0}},{"line":98,"address":[16623779,16623456,16623344,16623547,16623277,16623373,16623574],"length":1,"stats":{"Line":0}},{"line":103,"address":[24392017,24392016,24391878],"length":1,"stats":{"Line":0}},{"line":106,"address":[16730102,16729805,16730075,16729872,16729984,16730307,16729901],"length":1,"stats":{"Line":0}},{"line":111,"address":[16692102,16692240,16692241],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":43},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::infrastructure::crypto::signature_service::SignatureService;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::*;\n\n/// デフォルトの署名サービス実装\npub struct DefaultSignatureService;\n\nimpl DefaultSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Default for DefaultSignatureService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SignatureService for DefaultSignatureService {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // Nostr SDKを使用してイベントに署名\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // イベントIDを計算\n        let tags: Vec<nostr_sdk::Tag> = event\n            .tags\n            .clone()\n            .into_iter()\n            .map(|t| {\n                // Convert Vec<String> to Tag\n                if !t.is_empty() {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(t[0].as_str()), t[1..].to_vec())\n                } else {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(\"\"), Vec::<String>::new())\n                }\n            })\n            .collect();\n\n        let mut event_builder =\n            nostr_sdk::EventBuilder::new(Kind::from(event.kind as u16), event.content.clone());\n        for tag in tags {\n            event_builder = event_builder.tag(tag);\n        }\n\n        // 署名を生成\n        let signed_event = event_builder.sign_with_keys(&keys)?;\n        event.sig = signed_event.sig.to_string();\n        event.id = signed_event.id.to_hex();\n\n        Ok(())\n    }\n\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // イベントの署名を検証\n        let _public_key = PublicKey::from_hex(&event.pubkey)?;\n\n        // Nostrイベントを再構築\n        let nostr_event = nostr_sdk::Event::from_json(serde_json::to_string(event)?)?;\n\n        // 署名を検証\n        Ok(nostr_event.verify().is_ok())\n    }\n\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // Create a simple text note event and sign it\n        let event = EventBuilder::text_note(message).sign_with_keys(&keys)?;\n\n        // Return the signature\n        Ok(event.sig.to_string())\n    }\n\n    async fn verify_message(\n        &self,\n        _message: &str,\n        _signature: &str,\n        _public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // For now, we'll use the Nostr event verification approach\n        // In a real implementation, you'd need to reconstruct the event with the signature\n        // and verify it properly\n\n        // This is a simplified version - you may need to store more context\n        // to properly verify standalone signatures\n        Ok(true) // Placeholder implementation\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_sign_and_verify_message() {\n        let service = DefaultSignatureService::new();\n        let keys = Keys::generate();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let public_key = keys.public_key().to_string();\n\n        let message = \"Test message\";\n        let signature = service.sign_message(message, &private_key).await.unwrap();\n\n        let is_valid = service\n            .verify_message(message, &signature, &public_key)\n            .await\n            .unwrap();\n        assert!(is_valid);\n    }\n}\n","traces":[{"line":16,"address":[21476928],"length":1,"stats":{"Line":0}},{"line":17,"address":[21358641],"length":1,"stats":{"Line":0}},{"line":23,"address":[21562955,21563047,21565167,21562878,21565390,21562848,21562792],"length":1,"stats":{"Line":5}},{"line":29,"address":[21531971,21532031,21534185,21532215],"length":1,"stats":{"Line":2}},{"line":30,"address":[21663704],"length":1,"stats":{"Line":1}},{"line":33,"address":[21663951,21663863],"length":1,"stats":{"Line":2}},{"line":37,"address":[21527312,21527874,21527732],"length":1,"stats":{"Line":1}},{"line":39,"address":[21467018,21466594,21466518],"length":1,"stats":{"Line":2}},{"line":40,"address":[21565825,21565609,21565549],"length":1,"stats":{"Line":2}},{"line":42,"address":[21534669,21534783,21534392],"length":1,"stats":{"Line":0}},{"line":47,"address":[21464728,21464833],"length":1,"stats":{"Line":2}},{"line":49,"address":[21532676,21532784,21532919,21533009,21534104],"length":1,"stats":{"Line":5}},{"line":50,"address":[21459334,21458280],"length":1,"stats":{"Line":2}},{"line":54,"address":[21533162,21533475,21534006],"length":1,"stats":{"Line":1}},{"line":55,"address":[21458709,21458869],"length":1,"stats":{"Line":2}},{"line":56,"address":[21533731],"length":1,"stats":{"Line":1}},{"line":58,"address":[21466117],"length":1,"stats":{"Line":1}},{"line":61,"address":[21570000,21569950,21570030,21570083,21571099,21570179,21571128],"length":1,"stats":{"Line":0}},{"line":66,"address":[15707951,15708787,15708115],"length":1,"stats":{"Line":0}},{"line":69,"address":[21460971,21460567,21460648,21461257],"length":1,"stats":{"Line":0}},{"line":72,"address":[21535700,21535820],"length":1,"stats":{"Line":0}},{"line":75,"address":[24056157,24056238,24056208,24057461,24056329,24056444,24057391],"length":1,"stats":{"Line":5}},{"line":80,"address":[21571860,21571676,21571616,21572534],"length":1,"stats":{"Line":2}},{"line":81,"address":[21529749],"length":1,"stats":{"Line":1}},{"line":84,"address":[15709715,15709884,15709618],"length":1,"stats":{"Line":2}},{"line":87,"address":[21568413,21568254],"length":1,"stats":{"Line":2}},{"line":90,"address":[21462764,21462826,21463095,21462968,21462879,21462800,21462941],"length":1,"stats":{"Line":5}},{"line":102,"address":[24057841],"length":1,"stats":{"Line":1}}],"covered":21,"coverable":28},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","encryption_service.rs"],"content":"use async_trait::async_trait;\n\n#[async_trait]\npub trait EncryptionService: Send + Sync {\n    async fn encrypt(\n        &self,\n        data: &[u8],\n        recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt(\n        &self,\n        encrypted_data: &[u8],\n        sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","key_manager.rs"],"content":"use crate::application::ports::key_manager::{KeyManager, KeyMaterialStore, KeyPair};\nuse crate::shared::error::AppError;\nuse anyhow::{Result, anyhow};\nuse async_trait::async_trait;\nuse nostr_sdk::{FromBech32, prelude::*};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::warn;\n\n/// デフォルトのKeyManager実装\n#[derive(Clone)]\npub struct DefaultKeyManager {\n    inner: Arc<RwLock<KeyManagerInner>>,\n    key_store: Arc<dyn KeyMaterialStore>,\n}\n\nstruct KeyManagerInner {\n    keys: Option<Keys>,\n}\n\nimpl DefaultKeyManager {\n    pub fn new() -> Self {\n        Self::with_store(Arc::new(InMemoryKeyMaterialStore::default()))\n    }\n\n    pub fn with_store(key_store: Arc<dyn KeyMaterialStore>) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(KeyManagerInner { keys: None })),\n            key_store,\n        }\n    }\n\n    /// 旧インターフェース用: 新しいキーペアを生成（タプル形式）\n    pub async fn generate(&self) -> Result<(String, String, String)> {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_hex();\n        let secret_key = keys.secret_key().to_bech32()?;\n        let npub = keys.public_key().to_bech32()?;\n\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, secret_key, npub))\n    }\n\n    /// 旧インターフェース用: nsecでログイン\n    pub async fn login(&self, nsec: &str) -> Result<(String, String)> {\n        let secret_key = SecretKey::from_bech32(nsec)?;\n        let keys = Keys::new(secret_key);\n\n        let public_key = keys.public_key().to_hex();\n        let npub = keys.public_key().to_bech32()?;\n\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, npub))\n    }\n\n    /// 旧インターフェース用: ログアウト\n    pub async fn logout(&self) -> Result<()> {\n        let mut inner = self.inner.write().await;\n        inner.keys = None;\n        Ok(())\n    }\n\n    /// 旧インターフェース用: 現在の鍵を取得\n    pub async fn get_keys(&self) -> Result<Keys> {\n        let inner = self.inner.read().await;\n        inner.keys.clone().ok_or_else(|| anyhow!(\"No keys loaded\"))\n    }\n\n    async fn save_generated_keys(&self, keys: &Keys, keypair: &KeyPair) -> Result<(), AppError> {\n        {\n            let mut inner = self.inner.write().await;\n            inner.keys = Some(keys.clone());\n        }\n        self.key_store.save_keypair(keypair).await?;\n\n        if let Err(err) = self.key_store.set_current(&keypair.npub).await {\n            warn!(\n                npub = %keypair.npub,\n                \"set_current failed after save_keypair, retrying once: {err}\"\n            );\n            self.key_store.save_keypair(keypair).await?;\n            self.key_store.set_current(&keypair.npub).await?;\n        }\n        Ok(())\n    }\n\n    async fn install_current_from_pair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        let keys = keys_from_keypair(keypair)?;\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n        Ok(())\n    }\n}\n\nimpl Default for DefaultKeyManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl KeyManager for DefaultKeyManager {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n        let keys = Keys::generate();\n        let keypair = keypair_from_keys(&keys)?;\n        self.save_generated_keys(&keys, &keypair).await?;\n        Ok(keypair)\n    }\n\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError> {\n        let secret_key = SecretKey::from_bech32(nsec)\n            .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e:?}\")))?;\n        let keys = Keys::new(secret_key);\n        let keypair = keypair_from_keys(&keys)?;\n        self.save_generated_keys(&keys, &keypair).await?;\n        Ok(keypair)\n    }\n\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_store\n            .get_keypair(npub)\n            .await?\n            .map(|kp| kp.nsec)\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_store\n            .get_keypair(npub)\n            .await?\n            .map(|kp| kp.public_key)\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        self.key_store.save_keypair(keypair).await?;\n        self.key_store.set_current(&keypair.npub).await?;\n        self.install_current_from_pair(keypair).await\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        self.key_store.delete_keypair(npub).await?;\n        let mut inner = self.inner.write().await;\n        if let Some(keys) = &inner.keys {\n            let current_npub = keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert npub: {e:?}\")))?;\n            if current_npub == npub {\n                inner.keys = None;\n            }\n        }\n        Ok(())\n    }\n\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n        let pairs = self.key_store.list_keypairs().await?;\n        Ok(pairs.into_iter().map(|kp| kp.npub).collect())\n    }\n\n    async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        if let Some(keys) = self.inner.read().await.keys.clone() {\n            let npub = keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert npub: {e:?}\")))?;\n            if let Some(pair) = self.key_store.get_keypair(&npub).await? {\n                return Ok(pair);\n            }\n        }\n\n        if let Some(pair) = self.key_store.current_keypair().await? {\n            self.install_current_from_pair(&pair).await?;\n            Ok(pair)\n        } else {\n            // Fallback: if no \"current\" is set, try the first stored keypair to avoid empty auth state\n            let mut fallback = self.key_store.list_keypairs().await?;\n            if let Some(pair) = fallback.pop() {\n                self.key_store.set_current(&pair.npub).await.ok();\n                self.install_current_from_pair(&pair).await?;\n                Ok(pair)\n            } else {\n                Err(AppError::NotFound(\"No keys loaded\".into()))\n            }\n        }\n    }\n}\n\nfn keypair_from_keys(keys: &Keys) -> Result<KeyPair, AppError> {\n    let public_key = keys.public_key().to_hex();\n    let private_key = keys.secret_key().display_secret().to_string();\n    let npub = keys\n        .public_key()\n        .to_bech32()\n        .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n    let nsec = keys\n        .secret_key()\n        .to_bech32()\n        .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n\n    Ok(KeyPair {\n        public_key,\n        private_key,\n        npub,\n        nsec,\n    })\n}\n\nfn keys_from_keypair(keypair: &KeyPair) -> Result<Keys, AppError> {\n    let secret_key = SecretKey::from_bech32(&keypair.nsec)\n        .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e:?}\")))?;\n    Ok(Keys::new(secret_key))\n}\n\n#[derive(Default)]\nstruct InMemoryKeyMaterialStore {\n    keys: RwLock<HashMap<String, KeyPair>>,\n    current: RwLock<Option<String>>,\n}\n\n#[async_trait]\nimpl KeyMaterialStore for InMemoryKeyMaterialStore {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        let mut guard = self.keys.write().await;\n        guard.insert(keypair.npub.clone(), keypair.clone());\n        Ok(())\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        let mut guard = self.keys.write().await;\n        guard.remove(npub);\n        let mut current = self.current.write().await;\n        if current.as_deref() == Some(npub) {\n            *current = None;\n        }\n        Ok(())\n    }\n\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        Ok(guard.get(npub).cloned())\n    }\n\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        Ok(guard.values().cloned().collect())\n    }\n\n    async fn set_current(&self, npub: &str) -> Result<(), AppError> {\n        let guard = self.keys.read().await;\n        if guard.contains_key(npub) {\n            let mut current = self.current.write().await;\n            *current = Some(npub.to_string());\n            Ok(())\n        } else {\n            Err(AppError::NotFound(format!(\n                \"Keypair not found for npub {npub}\"\n            )))\n        }\n    }\n\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError> {\n        let guard = self.keys.read().await;\n        let current = self.current.read().await;\n        Ok(match current.as_deref() {\n            Some(npub) => guard.get(npub).cloned(),\n            None => None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_key_manager_new() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.get_keys().await;\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), \"No keys loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_generate_keypair() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.generate_keypair().await;\n        assert!(result.is_ok());\n        let pair = result.unwrap();\n        assert!(!pair.public_key.is_empty());\n        assert!(!pair.npub.is_empty());\n        assert!(!pair.nsec.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_import_private_key_roundtrip() {\n        let key_manager = DefaultKeyManager::new();\n        let (_, nsec, _) = key_manager.generate().await.expect(\"generate\");\n        let pair = key_manager\n            .import_private_key(&nsec)\n            .await\n            .expect(\"import should work\");\n        assert_eq!(pair.nsec, nsec);\n    }\n\n    #[tokio::test]\n    async fn test_store_and_export_keypair() {\n        let key_manager = DefaultKeyManager::new();\n        let generated = key_manager.generate_keypair().await.expect(\"generate\");\n        key_manager.store_keypair(&generated).await.expect(\"store\");\n        let exported = key_manager\n            .export_private_key(&generated.npub)\n            .await\n            .expect(\"export\");\n        assert_eq!(exported, generated.nsec);\n    }\n\n    #[tokio::test]\n    async fn test_delete_keypair_clears_current() {\n        let key_manager = DefaultKeyManager::new();\n        let pair = key_manager.generate_keypair().await.expect(\"generate\");\n        key_manager\n            .store_keypair(&pair)\n            .await\n            .expect(\"store default\");\n        key_manager\n            .delete_keypair(&pair.npub)\n            .await\n            .expect(\"delete\");\n        let result = key_manager.current_keypair().await;\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":23,"address":[14225920],"length":1,"stats":{"Line":3}},{"line":24,"address":[14439008],"length":1,"stats":{"Line":3}},{"line":27,"address":[14300592,14300794],"length":1,"stats":{"Line":3}},{"line":29,"address":[14232923,14232811],"length":1,"stats":{"Line":6}},{"line":35,"address":[22001200,22003245,22001420,22001472,22001232,22001267,22002232,22001208],"length":1,"stats":{"Line":4}},{"line":36,"address":[14307945],"length":1,"stats":{"Line":1}},{"line":37,"address":[14301225,14301135],"length":1,"stats":{"Line":2}},{"line":38,"address":[22001728,22001642],"length":1,"stats":{"Line":2}},{"line":39,"address":[14308480,14308396],"length":1,"stats":{"Line":2}},{"line":41,"address":[10872537],"length":1,"stats":{"Line":2}},{"line":42,"address":[14344860,14344890,14344153],"length":1,"stats":{"Line":1}},{"line":44,"address":[14241557],"length":1,"stats":{"Line":1}},{"line":48,"address":[14228701,14228467,14230493,14228649,14228432,14228384,14228402,14229630],"length":1,"stats":{"Line":0}},{"line":49,"address":[22003908,22003606,22003724],"length":1,"stats":{"Line":0}},{"line":50,"address":[14242818,14242627],"length":1,"stats":{"Line":0}},{"line":52,"address":[14303662,14303743],"length":1,"stats":{"Line":0}},{"line":53,"address":[14229187,14229271],"length":1,"stats":{"Line":0}},{"line":55,"address":[14310931,14311182,14310196,14310997],"length":1,"stats":{"Line":0}},{"line":56,"address":[14348175,14348732,14348762],"length":1,"stats":{"Line":0}},{"line":58,"address":[14346809],"length":1,"stats":{"Line":0}},{"line":62,"address":[14349771,14349205,14348904,14348896,14348937,14349027,14349064,14348912],"length":1,"stats":{"Line":0}},{"line":63,"address":[14230949,14230825,14230723,14230766],"length":1,"stats":{"Line":0}},{"line":64,"address":[14306056,14305761,14306029],"length":1,"stats":{"Line":0}},{"line":65,"address":[14349648],"length":1,"stats":{"Line":0}},{"line":69,"address":[22006791,22006531,22006496,22007224,22006480,22006650,22006488,22006613],"length":1,"stats":{"Line":4}},{"line":70,"address":[20534983,20534879,20534773,20534812],"length":1,"stats":{"Line":2}},{"line":71,"address":[14313661,14313792,14313596,14313796],"length":1,"stats":{"Line":4}},{"line":74,"address":[14239120,14239168,14240506,14239138,14239369,14239496,14239667,14239215],"length":1,"stats":{"Line":18}},{"line":76,"address":[14445687,14445842,14445623,14445987],"length":1,"stats":{"Line":9}},{"line":77,"address":[14314682,14315213],"length":1,"stats":{"Line":4}},{"line":79,"address":[11670171],"length":1,"stats":{"Line":5}},{"line":81,"address":[14352749,14352320,14350945,14352480],"length":1,"stats":{"Line":9}},{"line":82,"address":[14242211,14242387,14241577,14274665,14241686,14274799],"length":1,"stats":{"Line":0}},{"line":86,"address":[11571273],"length":1,"stats":{"Line":0}},{"line":87,"address":[11557536],"length":1,"stats":{"Line":0}},{"line":89,"address":[14311479],"length":1,"stats":{"Line":6}},{"line":92,"address":[14354544,14355276,14354576,14354794,14354742,14354611,14354557,14355897],"length":1,"stats":{"Line":8}},{"line":93,"address":[14238083,14238201,14238348],"length":1,"stats":{"Line":4}},{"line":94,"address":[14320188,14320003,14319649,14319849],"length":1,"stats":{"Line":4}},{"line":95,"address":[14246022,14245992,14245667],"length":1,"stats":{"Line":3}},{"line":96,"address":[22014140],"length":1,"stats":{"Line":3}},{"line":101,"address":[22014272],"length":1,"stats":{"Line":0}},{"line":102,"address":[20542120],"length":1,"stats":{"Line":0}},{"line":108,"address":[14343974,14343257,14343008,14343043,14344607,14344579,14343145,14342959],"length":1,"stats":{"Line":21}},{"line":109,"address":[14481848],"length":1,"stats":{"Line":3}},{"line":110,"address":[14385435,14385510,14385788,14385994],"length":1,"stats":{"Line":9}},{"line":111,"address":[20627934,20627650,20627819,20628383,20627124],"length":1,"stats":{"Line":9}},{"line":112,"address":[14344275],"length":1,"stats":{"Line":6}},{"line":115,"address":[14483135,14483235,14483200,14485214,14483461,14484598,14485238,14483349],"length":1,"stats":{"Line":10}},{"line":116,"address":[14284332,14284264,14284613,14285267],"length":1,"stats":{"Line":4}},{"line":117,"address":[14346822,14345397,14346800],"length":1,"stats":{"Line":0}},{"line":118,"address":[20629215],"length":1,"stats":{"Line":2}},{"line":119,"address":[14278064,14277719,14277791,14278266],"length":1,"stats":{"Line":4}},{"line":120,"address":[14345995,14345842,14344896,14346150,14346614],"length":1,"stats":{"Line":4}},{"line":121,"address":[14278611],"length":1,"stats":{"Line":2}},{"line":124,"address":[14347155,14348218,14348208,14347120,14347346,14347234,14347590,14347075],"length":1,"stats":{"Line":10}},{"line":125,"address":[14385665,14385606,14385991,14386325,14385845,14386267,14386224,14385558],"length":1,"stats":{"Line":12}},{"line":126,"address":[20631313],"length":1,"stats":{"Line":2}},{"line":127,"address":[14390112,14389670,14389614,14389309,14389877,14389570],"length":1,"stats":{"Line":6}},{"line":128,"address":[14391959,14391936],"length":1,"stats":{"Line":4}},{"line":129,"address":[14273861,14273554,14273840],"length":1,"stats":{"Line":2}},{"line":132,"address":[14274306,14274550,14275168,14274035,14274080,14274194,14274115,14275178],"length":1,"stats":{"Line":0}},{"line":133,"address":[14288832,14288273,14288599,14288453,14288166,14288933,14288214,14288875],"length":1,"stats":{"Line":0}},{"line":134,"address":[14281225],"length":1,"stats":{"Line":0}},{"line":135,"address":[11844948],"length":1,"stats":{"Line":0}},{"line":136,"address":[14281984,14282007],"length":1,"stats":{"Line":0}},{"line":137,"address":[11887011,11887047],"length":1,"stats":{"Line":0}},{"line":140,"address":[14488663,14489907,14490625,14489305,14488851,14488751,14488704,14489017],"length":1,"stats":{"Line":12}},{"line":141,"address":[11982353],"length":1,"stats":{"Line":2}},{"line":142,"address":[14395430,14394962,14395596,14394820,14395132,14394118],"length":1,"stats":{"Line":4}},{"line":143,"address":[19544297],"length":1,"stats":{"Line":4}},{"line":146,"address":[20635926,20637860,20635839,20636413,20636022,20635888,20636154,20636894],"length":1,"stats":{"Line":5}},{"line":147,"address":[14353102,14352401,14352813,14353293,14352615],"length":1,"stats":{"Line":1}},{"line":148,"address":[11844821],"length":1,"stats":{"Line":2}},{"line":149,"address":[20637185,20637128],"length":1,"stats":{"Line":2}},{"line":150,"address":[14353931,14353642,14353679],"length":1,"stats":{"Line":2}},{"line":153,"address":[14392465,14392448,14391995],"length":1,"stats":{"Line":0}},{"line":154,"address":[22054233,22054400,22054618],"length":1,"stats":{"Line":3}},{"line":155,"address":[14286431,14286236],"length":1,"stats":{"Line":1}},{"line":158,"address":[14292817],"length":1,"stats":{"Line":1}},{"line":161,"address":[14293689,14294226,14294923,14293763,14294950,14293728,14293850,14294967,14293962],"length":1,"stats":{"Line":0}},{"line":162,"address":[11976020],"length":1,"stats":{"Line":0}},{"line":163,"address":[20639123,20638922,20639296,20639324],"length":1,"stats":{"Line":0}},{"line":166,"address":[14356126,14356064,14360515,14356769,14358066,14356253,14356503,14356015],"length":1,"stats":{"Line":17}},{"line":167,"address":[14399979,14400313,14400865,14400497],"length":1,"stats":{"Line":8}},{"line":168,"address":[14399412,14399302,14399682,14400014],"length":1,"stats":{"Line":8}},{"line":171,"address":[14369473,14364514,14369456],"length":1,"stats":{"Line":0}},{"line":172,"address":[11887995],"length":1,"stats":{"Line":8}},{"line":173,"address":[14290827],"length":1,"stats":{"Line":4}},{"line":177,"address":[11984452],"length":1,"stats":{"Line":2}},{"line":178,"address":[20643711,20643377,20639834,20642997,20643119],"length":1,"stats":{"Line":0}},{"line":179,"address":[14404042],"length":1,"stats":{"Line":0}},{"line":182,"address":[11984502],"length":1,"stats":{"Line":1}},{"line":183,"address":[14300233,14300067],"length":1,"stats":{"Line":2}},{"line":184,"address":[11771455],"length":1,"stats":{"Line":0}},{"line":185,"address":[14301081,14301556,14295577],"length":1,"stats":{"Line":0}},{"line":186,"address":[22062708],"length":1,"stats":{"Line":0}},{"line":188,"address":[20644732],"length":1,"stats":{"Line":1}},{"line":194,"address":[14353220,14353244,14352032],"length":1,"stats":{"Line":4}},{"line":195,"address":[20542184],"length":1,"stats":{"Line":5}},{"line":196,"address":[14246177,14246235],"length":1,"stats":{"Line":10}},{"line":197,"address":[14321092,14321044,14322045,14321332],"length":1,"stats":{"Line":10}},{"line":200,"address":[14247361,14247344,14246548],"length":1,"stats":{"Line":0}},{"line":201,"address":[14246531,14246674,14247226],"length":1,"stats":{"Line":9}},{"line":204,"address":[20543186,20543537,20543520],"length":1,"stats":{"Line":0}},{"line":206,"address":[14240177],"length":1,"stats":{"Line":3}},{"line":207,"address":[14246829],"length":1,"stats":{"Line":5}},{"line":208,"address":[14453156],"length":1,"stats":{"Line":3}},{"line":209,"address":[14321649],"length":1,"stats":{"Line":4}},{"line":214,"address":[14247696,14248094,14248123],"length":1,"stats":{"Line":2}},{"line":215,"address":[14315778,14315542],"length":1,"stats":{"Line":2}},{"line":216,"address":[14322902,14322880,14322678],"length":1,"stats":{"Line":0}},{"line":217,"address":[14322776,14322621],"length":1,"stats":{"Line":4}},{"line":228,"address":[14407066,14406762,14406845,14407673,14406596,14406868,14406640,14406675,14407646],"length":1,"stats":{"Line":22}},{"line":229,"address":[22063656,22063477,22063786],"length":1,"stats":{"Line":4}},{"line":230,"address":[20646770,20647075,20646821],"length":1,"stats":{"Line":7}},{"line":231,"address":[14363897],"length":1,"stats":{"Line":4}},{"line":234,"address":[22064499,22064693,22064415,22064464,22064919,22065405,22066140,22064716,22064586],"length":1,"stats":{"Line":5}},{"line":235,"address":[12006607],"length":1,"stats":{"Line":1}},{"line":236,"address":[14303952,14304027],"length":1,"stats":{"Line":2}},{"line":237,"address":[12006626],"length":1,"stats":{"Line":1}},{"line":238,"address":[14407298,14407371,14407753],"length":1,"stats":{"Line":3}},{"line":239,"address":[14365761,14365470],"length":1,"stats":{"Line":1}},{"line":241,"address":[14403552],"length":1,"stats":{"Line":1}},{"line":244,"address":[14298080,14299063,14298303,14298326,14298031,14298524,14298115,14298214],"length":1,"stats":{"Line":25}},{"line":245,"address":[14291457,14291642,14291772],"length":1,"stats":{"Line":5}},{"line":246,"address":[20649667,20649610],"length":1,"stats":{"Line":10}},{"line":249,"address":[14505459,14505538,14505385,14505424,14505621,14505644,14505842,14506335],"length":1,"stats":{"Line":5}},{"line":250,"address":[11904836],"length":1,"stats":{"Line":1}},{"line":251,"address":[14411322,14411393],"length":1,"stats":{"Line":2}},{"line":254,"address":[14376645,14375109,14375002,14374880,14374915,14375132,14374831,14375335,14376056],"length":1,"stats":{"Line":26}},{"line":255,"address":[11904895],"length":1,"stats":{"Line":4}},{"line":256,"address":[14375671,14375596],"length":1,"stats":{"Line":9}},{"line":257,"address":[14300311,14301001,14301241,14301329],"length":1,"stats":{"Line":11}},{"line":258,"address":[14376285,14376650],"length":1,"stats":{"Line":6}},{"line":259,"address":[14369661],"length":1,"stats":{"Line":6}},{"line":261,"address":[14410829,14410892],"length":1,"stats":{"Line":0}},{"line":267,"address":[14309046,14309160,14309296,14309517,14308959,14310689,14309968,14309270,14309008],"length":1,"stats":{"Line":5}},{"line":268,"address":[14508499,14508713,14508861],"length":1,"stats":{"Line":1}},{"line":269,"address":[11914306],"length":1,"stats":{"Line":2}},{"line":270,"address":[14409411,14409172,14409245],"length":1,"stats":{"Line":3}},{"line":271,"address":[14303421,14303621],"length":1,"stats":{"Line":0}},{"line":272,"address":[22071593],"length":1,"stats":{"Line":1}}],"covered":104,"coverable":143},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","mod.rs"],"content":"pub mod default_encryption_service;\npub mod default_signature_service;\npub mod encryption_service;\npub mod key_manager;\npub mod signature_service;\npub mod stream_encryptor;\n\npub use default_encryption_service::DefaultEncryptionService;\npub use default_signature_service::DefaultSignatureService;\npub use encryption_service::EncryptionService;\npub use key_manager::DefaultKeyManager;\npub use signature_service::SignatureService;\npub use stream_encryptor::{\n    CapabilityEncryptor, EncryptedSessionKey, StreamEncryptionResult, StreamEncryptor,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SignatureService: Send + Sync {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_message(\n        &self,\n        message: &str,\n        signature: &str,\n        public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","stream_encryptor.rs"],"content":"use aes_gcm::{\n    Aes256Gcm, Key,\n    aead::{Aead, AeadCore, KeyInit, OsRng, rand_core::RngCore},\n};\n\nuse crate::shared::AppError;\n\nconst AES_KEY_SIZE: usize = 32;\nconst AES_NONCE_SIZE: usize = 12;\n\ntype AesGcmNonce = aes_gcm::Nonce<<Aes256Gcm as AeadCore>::NonceSize>;\n\n/// ストリーム暗号化結果\n#[derive(Debug, Clone)]\npub struct StreamEncryptionResult {\n    pub ciphertext: Vec<u8>,\n    pub session_key: [u8; AES_KEY_SIZE],\n    pub nonce: [u8; AES_NONCE_SIZE],\n}\n\n/// セッションキーを Capability で暗号化した結果\n#[derive(Debug, Clone)]\npub struct EncryptedSessionKey {\n    pub ciphertext: Vec<u8>,\n    pub nonce: [u8; AES_NONCE_SIZE],\n}\n\n/// Blob 本体を暗号化するユーティリティ\npub struct StreamEncryptor;\n\nimpl StreamEncryptor {\n    pub fn encrypt(plaintext: &[u8]) -> Result<StreamEncryptionResult, AppError> {\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut session_key);\n\n        let key = Key::<Aes256Gcm>::from(session_key);\n        let cipher = Aes256Gcm::new(&key);\n\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt stream: {err}\")))?;\n\n        let mut nonce_bytes = [0u8; AES_NONCE_SIZE];\n        nonce_bytes.copy_from_slice(&nonce);\n\n        Ok(StreamEncryptionResult {\n            ciphertext,\n            session_key,\n            nonce: nonce_bytes,\n        })\n    }\n\n    pub fn decrypt(\n        ciphertext: &[u8],\n        session_key: &[u8; AES_KEY_SIZE],\n        nonce: &[u8; AES_NONCE_SIZE],\n    ) -> Result<Vec<u8>, AppError> {\n        let key = Key::<Aes256Gcm>::from(*session_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = AesGcmNonce::from(*nonce);\n        cipher\n            .decrypt(&nonce, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt stream: {err}\")))\n    }\n}\n\n/// Capability 秘密を用いたセッションキー暗号化ユーティリティ\npub struct CapabilityEncryptor;\n\nimpl CapabilityEncryptor {\n    pub fn encrypt_session_key(\n        session_key: &[u8; AES_KEY_SIZE],\n        capability_key: &[u8; AES_KEY_SIZE],\n    ) -> Result<EncryptedSessionKey, AppError> {\n        let key = Key::<Aes256Gcm>::from(*capability_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, session_key.as_slice())\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt session key: {err}\")))?;\n\n        let mut nonce_bytes = [0u8; AES_NONCE_SIZE];\n        nonce_bytes.copy_from_slice(&nonce);\n\n        Ok(EncryptedSessionKey {\n            ciphertext,\n            nonce: nonce_bytes,\n        })\n    }\n\n    pub fn decrypt_session_key(\n        encrypted: &EncryptedSessionKey,\n        capability_key: &[u8; AES_KEY_SIZE],\n    ) -> Result<[u8; AES_KEY_SIZE], AppError> {\n        let key = Key::<Aes256Gcm>::from(*capability_key);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = AesGcmNonce::from(encrypted.nonce);\n        let decrypted = cipher\n            .decrypt(&nonce, encrypted.ciphertext.as_slice())\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt session key: {err}\")))?;\n\n        if decrypted.len() != AES_KEY_SIZE {\n            return Err(AppError::Crypto(\n                \"Decrypted session key has unexpected length\".to_string(),\n            ));\n        }\n\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        session_key.copy_from_slice(&decrypted);\n        Ok(session_key)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn encrypt_and_decrypt_roundtrip() {\n        let data = b\"hello profile avatar\";\n        let encrypted = StreamEncryptor::encrypt(data).expect(\"encrypt\");\n        let decrypted = StreamEncryptor::decrypt(\n            &encrypted.ciphertext,\n            &encrypted.session_key,\n            &encrypted.nonce,\n        )\n        .expect(\"decrypt\");\n        assert_eq!(decrypted, data);\n    }\n\n    #[test]\n    fn capability_encryption_roundtrip() {\n        let mut capability_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut capability_key);\n        let mut session_key = [0u8; AES_KEY_SIZE];\n        OsRng.fill_bytes(&mut session_key);\n\n        let encrypted = CapabilityEncryptor::encrypt_session_key(&session_key, &capability_key)\n            .expect(\"encrypt\");\n        let decrypted =\n            CapabilityEncryptor::decrypt_session_key(&encrypted, &capability_key).expect(\"decrypt\");\n        assert_eq!(session_key, decrypted);\n    }\n}\n","traces":[{"line":32,"address":[19015195,19015220,19014240],"length":1,"stats":{"Line":2}},{"line":33,"address":[19014283],"length":1,"stats":{"Line":2}},{"line":34,"address":[19015944],"length":1,"stats":{"Line":2}},{"line":36,"address":[18972272],"length":1,"stats":{"Line":2}},{"line":37,"address":[18972330],"length":1,"stats":{"Line":2}},{"line":39,"address":[13152059],"length":1,"stats":{"Line":2}},{"line":40,"address":[18979356,18979639],"length":1,"stats":{"Line":2}},{"line":42,"address":[18972663,18973217,18973200],"length":1,"stats":{"Line":0}},{"line":44,"address":[18898014],"length":1,"stats":{"Line":2}},{"line":45,"address":[18979557,18979722],"length":1,"stats":{"Line":4}},{"line":47,"address":[20979012],"length":1,"stats":{"Line":2}},{"line":48,"address":[19010942],"length":1,"stats":{"Line":2}},{"line":49,"address":[19010990],"length":1,"stats":{"Line":2}},{"line":50,"address":[18972930],"length":1,"stats":{"Line":2}},{"line":54,"address":[18912544,18912848],"length":1,"stats":{"Line":2}},{"line":59,"address":[18905631],"length":1,"stats":{"Line":2}},{"line":60,"address":[18898893],"length":1,"stats":{"Line":2}},{"line":61,"address":[18980432],"length":1,"stats":{"Line":2}},{"line":62,"address":[18905792],"length":1,"stats":{"Line":2}},{"line":64,"address":[19112192,19112209],"length":1,"stats":{"Line":0}},{"line":72,"address":[19016761,19015936,19016786],"length":1,"stats":{"Line":2}},{"line":76,"address":[18980854],"length":1,"stats":{"Line":2}},{"line":77,"address":[18906164],"length":1,"stats":{"Line":2}},{"line":78,"address":[20980033],"length":1,"stats":{"Line":2}},{"line":79,"address":[18981306,18981024],"length":1,"stats":{"Line":2}},{"line":80,"address":[18980993],"length":1,"stats":{"Line":2}},{"line":81,"address":[19016378,19016800,19016817],"length":1,"stats":{"Line":0}},{"line":83,"address":[18899682],"length":1,"stats":{"Line":2}},{"line":84,"address":[18974460,18974297],"length":1,"stats":{"Line":4}},{"line":86,"address":[18913742],"length":1,"stats":{"Line":2}},{"line":87,"address":[19018192],"length":1,"stats":{"Line":2}},{"line":88,"address":[18913712],"length":1,"stats":{"Line":2}},{"line":92,"address":[18908056,18907120,18908045],"length":1,"stats":{"Line":2}},{"line":96,"address":[18981894],"length":1,"stats":{"Line":2}},{"line":97,"address":[18981943],"length":1,"stats":{"Line":2}},{"line":98,"address":[18900445],"length":1,"stats":{"Line":2}},{"line":99,"address":[18908054,18907613,18907358],"length":1,"stats":{"Line":2}},{"line":100,"address":[19013247],"length":1,"stats":{"Line":2}},{"line":101,"address":[18908097,18907565,18908080],"length":1,"stats":{"Line":0}},{"line":103,"address":[19017547,19017392],"length":1,"stats":{"Line":4}},{"line":104,"address":[20981730],"length":1,"stats":{"Line":0}},{"line":105,"address":[20981541],"length":1,"stats":{"Line":0}},{"line":109,"address":[18975505],"length":1,"stats":{"Line":2}},{"line":110,"address":[18975524,18975597],"length":1,"stats":{"Line":4}},{"line":111,"address":[18914801],"length":1,"stats":{"Line":2}}],"covered":39,"coverable":45},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","connection_pool.rs"],"content":"use sqlx::{SqlitePool, sqlite::SqlitePoolOptions};\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct ConnectionPool {\n    pool: Arc<SqlitePool>,\n}\n\nimpl ConnectionPool {\n    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(5)\n            .connect(database_url)\n            .await?;\n\n        Ok(Self {\n            pool: Arc::new(pool),\n        })\n    }\n\n    pub async fn from_memory() -> Result<Self, sqlx::Error> {\n        Self::new(\":memory:\").await\n    }\n\n    pub fn get_pool(&self) -> &SqlitePool {\n        &self.pool\n    }\n\n    pub async fn migrate(&self) -> Result<(), sqlx::migrate::MigrateError> {\n        sqlx::migrate!(\"./migrations\").run(self.pool.as_ref()).await\n    }\n\n    pub async fn close(&self) {\n        self.pool.close().await;\n    }\n}\n","traces":[{"line":10,"address":[12630096,12630264,12630312,12630146,12630501,12630077,12630064,12631084],"length":1,"stats":{"Line":19}},{"line":11,"address":[12836647,12836740,12837044,12836933,12836533,12837193],"length":1,"stats":{"Line":29}},{"line":14,"address":[20398483,20398668,20398885,20398725,20398620,20399058],"length":1,"stats":{"Line":22}},{"line":16,"address":[12637959],"length":1,"stats":{"Line":7}},{"line":17,"address":[12698646],"length":1,"stats":{"Line":7}},{"line":21,"address":[20399890,20399362,20399299,20399595,20399446,20399483,20399312,20399296],"length":1,"stats":{"Line":8}},{"line":22,"address":[12699031,12699089,12699146,12699243],"length":1,"stats":{"Line":5}},{"line":25,"address":[12699520],"length":1,"stats":{"Line":6}},{"line":26,"address":[12631717],"length":1,"stats":{"Line":6}},{"line":29,"address":[12638736,12639069,12638883,12638712,12638771,12638704,12639439,12639344],"length":1,"stats":{"Line":28}},{"line":30,"address":[19292999],"length":1,"stats":{"Line":10}},{"line":33,"address":[12639598,12639779,12639456,12639464,12639488,12639513,12639997,12639635],"length":1,"stats":{"Line":4}},{"line":34,"address":[12700457,12700519,12700414,12700643],"length":1,"stats":{"Line":3}}],"covered":13,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","mod.rs"],"content":"pub mod connection_pool;\npub mod repository;\npub mod sqlite_repository;\npub mod subscription_state_repository;\n\npub use connection_pool::ConnectionPool;\npub use repository::Repository;\npub use subscription_state_repository::SqliteSubscriptionStateRepository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","repository.rs"],"content":"use crate::application::ports::repositories::{\n    BookmarkRepository, DirectMessageRepository, EventRepository, PostRepository, TopicRepository,\n    UserRepository,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait Repository:\n    PostRepository\n    + TopicRepository\n    + UserRepository\n    + EventRepository\n    + BookmarkRepository\n    + DirectMessageRepository\n{\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn health_check(&self) -> Result<bool, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","bookmarks.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    DELETE_BOOKMARK, INSERT_BOOKMARK, SELECT_BOOKMARK_BY_USER_AND_POST, SELECT_BOOKMARKS_BY_USER,\n};\nuse crate::application::ports::repositories::BookmarkRepository;\nuse crate::domain::entities::Bookmark;\nuse crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse chrono::{TimeZone, Utc};\nuse sqlx::FromRow;\n\n#[derive(Debug, FromRow)]\nstruct BookmarkRow {\n    id: String,\n    user_pubkey: String,\n    post_id: String,\n    created_at: i64,\n}\n\nimpl BookmarkRow {\n    fn into_domain(self) -> Result<Bookmark, AppError> {\n        let id = BookmarkId::new(self.id).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid BookmarkId: {err}\"),\n            )\n        })?;\n        let user_pubkey = PublicKey::from_hex_str(&self.user_pubkey).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid public key: {err}\"),\n            )\n        })?;\n        let post_id = EventId::from_hex(&self.post_id).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid post id: {err}\"),\n            )\n        })?;\n        let created_at = Utc\n            .timestamp_millis_opt(self.created_at)\n            .single()\n            .ok_or_else(|| AppError::DeserializationError(\"Invalid timestamp\".to_string()))?;\n\n        Ok(Bookmark::from_parts(id, user_pubkey, post_id, created_at))\n    }\n}\n\nimpl SqliteRepository {\n    async fn fetch_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let row = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARK_BY_USER_AND_POST)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => row.into_domain(),\n            None => Err(AppError::NotFound(\"Bookmark not found\".to_string())),\n        }\n    }\n}\n\n#[async_trait]\nimpl BookmarkRepository for SqliteRepository {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let bookmark = Bookmark::new(user_pubkey.clone(), post_id.clone());\n\n        let result = sqlx::query(INSERT_BOOKMARK)\n            .bind(bookmark.id().as_str())\n            .bind(bookmark.user_pubkey().as_hex())\n            .bind(bookmark.post_id().as_str())\n            .bind(bookmark.created_at().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        if result.rows_affected() == 0 {\n            return self.fetch_bookmark(user_pubkey, post_id).await;\n        }\n\n        Ok(bookmark)\n    }\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError> {\n        sqlx::query(DELETE_BOOKMARK)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError> {\n        let rows = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARKS_BY_USER)\n            .bind(user_pubkey.as_hex())\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        rows.into_iter().map(BookmarkRow::into_domain).collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::database::connection_pool::ConnectionPool;\n\n    async fn setup_repository() -> SqliteRepository {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            );\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create table\");\n\n        SqliteRepository::new(pool)\n    }\n\n    fn sample_pubkey() -> PublicKey {\n        let hex = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n        PublicKey::from_hex_str(hex).expect(\"valid pubkey\")\n    }\n\n    fn sample_event_id() -> EventId {\n        EventId::generate()\n    }\n\n    #[tokio::test]\n    async fn create_and_list_bookmarks() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert_eq!(bookmarks.len(), 1);\n        assert_eq!(bookmarks[0].post_id().as_str(), event_id.as_str());\n        assert_eq!(bookmarks[0].user_pubkey().as_hex(), pubkey.as_hex());\n    }\n\n    #[tokio::test]\n    async fn create_is_idempotent() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        let first = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n        let second = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark idempotent\");\n\n        assert_eq!(first.id().as_str(), second.id().as_str());\n    }\n\n    #[tokio::test]\n    async fn delete_bookmark_succeeds() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        repo.delete_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"deleted\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert!(bookmarks.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[24709801,24708112],"length":1,"stats":{"Line":1}},{"line":23,"address":[12217001,12218736,12216870,12217183,12218632,12218951],"length":1,"stats":{"Line":2}},{"line":24,"address":[24635663],"length":1,"stats":{"Line":0}},{"line":25,"address":[24642293],"length":1,"stats":{"Line":0}},{"line":26,"address":[24752154,24752213],"length":1,"stats":{"Line":0}},{"line":29,"address":[24649723,24647559,24647707,24647956,24649107,24649504],"length":1,"stats":{"Line":2}},{"line":30,"address":[24642703],"length":1,"stats":{"Line":0}},{"line":31,"address":[24642549],"length":1,"stats":{"Line":0}},{"line":32,"address":[24710421,24710362],"length":1,"stats":{"Line":0}},{"line":35,"address":[24717520,24717739,24715796,24716052,24715642,24716819],"length":1,"stats":{"Line":2}},{"line":36,"address":[18890479],"length":1,"stats":{"Line":0}},{"line":37,"address":[24636021],"length":1,"stats":{"Line":0}},{"line":38,"address":[24849098,24849157],"length":1,"stats":{"Line":0}},{"line":41,"address":[24709194,24709582,24709047],"length":1,"stats":{"Line":2}},{"line":42,"address":[24641235],"length":1,"stats":{"Line":1}},{"line":44,"address":[24716462,24717790,24717776],"length":1,"stats":{"Line":0}},{"line":46,"address":[24634742,24635029],"length":1,"stats":{"Line":2}},{"line":51,"address":[17048592],"length":1,"stats":{"Line":1}},{"line":56,"address":[24711314,24711237,24711968,24712108,24711560,24712309,24711126,24711682,24711442],"length":1,"stats":{"Line":8}},{"line":57,"address":[24711245,24711354,24711803,24711197],"length":1,"stats":{"Line":2}},{"line":58,"address":[12219966,12220070,12220342],"length":1,"stats":{"Line":2}},{"line":59,"address":[24711595,24711498,24711736],"length":1,"stats":{"Line":2}},{"line":60,"address":[12017108],"length":1,"stats":{"Line":4}},{"line":62,"address":[24651395],"length":1,"stats":{"Line":1}},{"line":63,"address":[24637788,24638080],"length":1,"stats":{"Line":2}},{"line":64,"address":[18892270,18892058],"length":1,"stats":{"Line":0}},{"line":71,"address":[17218575],"length":1,"stats":{"Line":5}},{"line":76,"address":[24772936,24774346],"length":1,"stats":{"Line":1}},{"line":78,"address":[24706041,24705730,24705574,24707336,24705886,24706758,24707076,24706284,24705363,24706881,24706166,24705461],"length":1,"stats":{"Line":10}},{"line":79,"address":[24692762,24692807,24691709,24691634,24691849],"length":1,"stats":{"Line":2}},{"line":80,"address":[24809346,24808505,24809383,24808282,24808645,24809410],"length":1,"stats":{"Line":2}},{"line":81,"address":[24767279,24766613,24767250,24766242,24766753,24767306,24767370],"length":1,"stats":{"Line":2}},{"line":82,"address":[24808817,24808298,24808956,24809269,24809306,24809362,24809426],"length":1,"stats":{"Line":2}},{"line":83,"address":[18946978,18947098,18946636,18946745,18946895,18947034,18945970],"length":1,"stats":{"Line":2}},{"line":84,"address":[12021426],"length":1,"stats":{"Line":4}},{"line":86,"address":[24809877,24809998],"length":1,"stats":{"Line":2}},{"line":87,"address":[24906676,24906558,24906436,24904283],"length":1,"stats":{"Line":3}},{"line":90,"address":[24693399],"length":1,"stats":{"Line":1}},{"line":93,"address":[18949648,18948304,18948339,18948554,18949218,18948442,18949278],"length":1,"stats":{"Line":5}},{"line":98,"address":[24769231,24769710,24769099,24769419,24769808,24769989,24769349,24768947,24769013],"length":1,"stats":{"Line":8}},{"line":99,"address":[24807133,24807090,24807656,24807246],"length":1,"stats":{"Line":2}},{"line":100,"address":[12316875,12316758,12317103],"length":1,"stats":{"Line":2}},{"line":101,"address":[24907864,24907954,24907767],"length":1,"stats":{"Line":2}},{"line":102,"address":[11904996],"length":1,"stats":{"Line":4}},{"line":103,"address":[24702094],"length":1,"stats":{"Line":1}},{"line":106,"address":[12835959],"length":1,"stats":{"Line":5}},{"line":107,"address":[24908867,24909019,24908933,24909242,24909137,24909501,24909599,24909852],"length":1,"stats":{"Line":7}},{"line":108,"address":[24814551,24814157,24814114,24814275],"length":1,"stats":{"Line":2}},{"line":109,"address":[24777745,24777523,24777620],"length":1,"stats":{"Line":2}},{"line":110,"address":[11433348],"length":1,"stats":{"Line":4}},{"line":112,"address":[24703449,24703638],"length":1,"stats":{"Line":2}}],"covered":40,"coverable":51},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","direct_messages.rs"],"content":"use super::SqliteRepository;\nuse crate::application::ports::repositories::{\n    DirectMessageConversationCursor, DirectMessageConversationPageRaw,\n    DirectMessageConversationRecord, DirectMessageCursor, DirectMessageListDirection,\n    DirectMessagePageRaw, DirectMessageRepository,\n};\nuse crate::domain::entities::{DirectMessage, MessageDirection, NewDirectMessage};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse sqlx::sqlite::SqliteRow;\nuse sqlx::{Acquire, FromRow, Row};\nuse sqlx::{QueryBuilder, Sqlite};\nuse std::str::FromStr;\n\nuse super::queries::{\n    INSERT_DIRECT_MESSAGE, INSERT_DM_CONVERSATION, MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID,\n    MARK_DM_CONVERSATION_READ, SELECT_DIRECT_MESSAGE_BY_ID, UPDATE_DM_CONVERSATION_LAST_MESSAGE,\n};\n\n#[derive(Debug, Clone)]\nstruct DirectMessageRow {\n    id: i64,\n    owner_npub: String,\n    conversation_npub: String,\n    sender_npub: String,\n    recipient_npub: String,\n    event_id: Option<String>,\n    client_message_id: Option<String>,\n    payload_cipher_base64: String,\n    created_at: i64,\n    delivered: i64,\n    direction: String,\n}\n\nimpl<'r> FromRow<'r, SqliteRow> for DirectMessageRow {\n    fn from_row(row: &'r SqliteRow) -> Result<Self, sqlx::Error> {\n        Ok(Self {\n            id: row.try_get(\"id\")?,\n            owner_npub: row.try_get(\"owner_npub\")?,\n            conversation_npub: row.try_get(\"conversation_npub\")?,\n            sender_npub: row.try_get(\"sender_npub\")?,\n            recipient_npub: row.try_get(\"recipient_npub\")?,\n            event_id: row.try_get(\"event_id\")?,\n            client_message_id: row.try_get(\"client_message_id\")?,\n            payload_cipher_base64: row.try_get(\"payload_cipher_base64\")?,\n            created_at: row.try_get(\"created_at\")?,\n            delivered: row.try_get(\"delivered\")?,\n            direction: row.try_get(\"direction\")?,\n        })\n    }\n}\n\nimpl From<DirectMessageRow> for DirectMessage {\n    fn from(row: DirectMessageRow) -> Self {\n        let direction = row.direction.parse().unwrap_or(MessageDirection::Outbound);\n        let delivered = row.delivered != 0;\n        DirectMessage::new(\n            row.id,\n            row.owner_npub,\n            row.conversation_npub,\n            row.sender_npub,\n            row.recipient_npub,\n            row.event_id,\n            row.client_message_id,\n            row.payload_cipher_base64,\n            row.created_at,\n            delivered,\n            direction,\n        )\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct DirectMessageConversationJoinedRow {\n    owner_npub: String,\n    conversation_npub: String,\n    last_message_created_at: Option<i64>,\n    last_read_at: i64,\n    unread_count: i64,\n    msg_id: Option<i64>,\n    msg_owner_npub: Option<String>,\n    msg_conversation_npub: Option<String>,\n    msg_sender_npub: Option<String>,\n    msg_recipient_npub: Option<String>,\n    msg_event_id: Option<String>,\n    msg_client_message_id: Option<String>,\n    msg_payload_cipher_base64: Option<String>,\n    msg_created_at: Option<i64>,\n    msg_delivered: Option<i64>,\n    msg_direction: Option<String>,\n}\n\nimpl<'r> FromRow<'r, SqliteRow> for DirectMessageConversationJoinedRow {\n    fn from_row(row: &'r SqliteRow) -> Result<Self, sqlx::Error> {\n        Ok(Self {\n            owner_npub: row.try_get(\"owner_npub\")?,\n            conversation_npub: row.try_get(\"conversation_npub\")?,\n            last_message_created_at: row.try_get(\"last_message_created_at\")?,\n            last_read_at: row.try_get(\"last_read_at\")?,\n            unread_count: row.try_get(\"unread_count\")?,\n            msg_id: row.try_get(\"msg_id\")?,\n            msg_owner_npub: row.try_get(\"msg_owner_npub\")?,\n            msg_conversation_npub: row.try_get(\"msg_conversation_npub\")?,\n            msg_sender_npub: row.try_get(\"msg_sender_npub\")?,\n            msg_recipient_npub: row.try_get(\"msg_recipient_npub\")?,\n            msg_event_id: row.try_get(\"msg_event_id\")?,\n            msg_client_message_id: row.try_get(\"msg_client_message_id\")?,\n            msg_payload_cipher_base64: row.try_get(\"msg_payload_cipher_base64\")?,\n            msg_created_at: row.try_get(\"msg_created_at\")?,\n            msg_delivered: row.try_get(\"msg_delivered\")?,\n            msg_direction: row.try_get(\"msg_direction\")?,\n        })\n    }\n}\n\nimpl DirectMessageConversationJoinedRow {\n    fn into_record(self) -> DirectMessageConversationRecord {\n        let last_message = self.build_message();\n        DirectMessageConversationRecord {\n            owner_npub: self.owner_npub,\n            conversation_npub: self.conversation_npub,\n            last_message,\n            last_message_created_at: self.last_message_created_at,\n            last_read_at: self.last_read_at,\n            unread_count: self.unread_count,\n        }\n    }\n\n    fn build_message(&self) -> Option<DirectMessage> {\n        let (\n            Some(id),\n            Some(owner_npub),\n            Some(conversation_npub),\n            Some(sender_npub),\n            Some(recipient_npub),\n            Some(payload),\n            Some(created_at),\n            Some(direction_str),\n        ) = (\n            self.msg_id,\n            self.msg_owner_npub.clone(),\n            self.msg_conversation_npub.clone(),\n            self.msg_sender_npub.clone(),\n            self.msg_recipient_npub.clone(),\n            self.msg_payload_cipher_base64.clone(),\n            self.msg_created_at,\n            self.msg_direction.clone(),\n        )\n        else {\n            return None;\n        };\n\n        let delivered = self.msg_delivered.unwrap_or(1) != 0;\n        let direction =\n            MessageDirection::from_str(&direction_str).unwrap_or(MessageDirection::Outbound);\n\n        Some(DirectMessage::new(\n            id,\n            owner_npub,\n            conversation_npub,\n            sender_npub,\n            recipient_npub,\n            self.msg_event_id.clone(),\n            self.msg_client_message_id.clone(),\n            payload,\n            created_at,\n            delivered,\n            direction,\n        ))\n    }\n}\n\n#[async_trait]\nimpl DirectMessageRepository for SqliteRepository {\n    async fn insert_direct_message(\n        &self,\n        message: &NewDirectMessage,\n    ) -> Result<DirectMessage, AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let mut tx = conn.begin().await?;\n\n        sqlx::query(INSERT_DIRECT_MESSAGE)\n            .bind(&message.owner_npub)\n            .bind(&message.conversation_npub)\n            .bind(&message.sender_npub)\n            .bind(&message.recipient_npub)\n            .bind(&message.event_id)\n            .bind(&message.client_message_id)\n            .bind(&message.payload_cipher_base64)\n            .bind(message.created_at.timestamp_millis())\n            .bind(if message.delivered { 1 } else { 0 })\n            .bind(message.direction.as_str())\n            .execute(&mut *tx)\n            .await?;\n\n        let inserted_id: i64 = sqlx::query_scalar(\"SELECT last_insert_rowid()\")\n            .fetch_one(&mut *tx)\n            .await?;\n\n        let row = sqlx::query_as::<_, DirectMessageRow>(SELECT_DIRECT_MESSAGE_BY_ID)\n            .bind(inserted_id)\n            .fetch_one(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n\n        Ok(row.into())\n    }\n\n    async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        cursor: Option<DirectMessageCursor>,\n        limit: usize,\n        direction: DirectMessageListDirection,\n    ) -> Result<DirectMessagePageRaw, AppError> {\n        let fetch_limit = limit.saturating_add(1);\n\n        let mut builder = QueryBuilder::<Sqlite>::new(\n            \"SELECT id,\n                    owner_npub,\n                    conversation_npub,\n                    sender_npub,\n                    recipient_npub,\n                    event_id,\n                    client_message_id,\n                    payload_cipher_base64,\n                    created_at,\n                    delivered,\n                    direction\n             FROM direct_messages\n             WHERE owner_npub = \",\n        );\n\n        builder.push_bind(owner_npub);\n        builder.push(\" AND conversation_npub = \");\n        builder.push_bind(conversation_npub);\n\n        if let Some(cur) = cursor.as_ref() {\n            match direction {\n                DirectMessageListDirection::Backward => {\n                    builder.push(\" AND (created_at < \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" OR (created_at = \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" AND IFNULL(event_id, '') < \");\n                    builder.push_bind(cur.event_id.clone().unwrap_or_default());\n                    builder.push(\"))\");\n                }\n                DirectMessageListDirection::Forward => {\n                    builder.push(\" AND (created_at > \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" OR (created_at = \");\n                    builder.push_bind(cur.created_at);\n                    builder.push(\" AND IFNULL(event_id, '') > \");\n                    builder.push_bind(cur.event_id.clone().unwrap_or_default());\n                    builder.push(\"))\");\n                }\n            }\n        }\n\n        builder.push(\" ORDER BY created_at \");\n        match direction {\n            DirectMessageListDirection::Backward => {\n                builder.push(\"DESC, IFNULL(event_id, '') DESC\");\n            }\n            DirectMessageListDirection::Forward => {\n                builder.push(\"ASC, IFNULL(event_id, '') ASC\");\n            }\n        }\n\n        builder.push(\" LIMIT \");\n        builder.push_bind(fetch_limit as i64);\n\n        let query = builder.build_query_as::<DirectMessageRow>();\n        let mut rows = query.fetch_all(self.pool.get_pool()).await?;\n\n        let has_more = rows.len() > limit;\n        if has_more {\n            rows.truncate(limit);\n        }\n\n        let next_cursor = rows.last().map(|row| {\n            let dm: DirectMessage = row.clone().into();\n            dm.cursor()\n        });\n\n        let items = rows.into_iter().map(Into::into).collect();\n\n        Ok(DirectMessagePageRaw {\n            items,\n            next_cursor,\n            has_more,\n        })\n    }\n\n    async fn mark_delivered_by_client_id(\n        &self,\n        owner_npub: &str,\n        client_message_id: &str,\n        event_id: Option<String>,\n        delivered: bool,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        sqlx::query(MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID)\n            .bind(owner_npub)\n            .bind(client_message_id)\n            .bind(event_id.as_deref())\n            .bind(if delivered { 1 } else { 0 })\n            .execute(&mut *conn)\n            .await?;\n        Ok(())\n    }\n\n    async fn upsert_conversation_metadata(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        last_message_id: i64,\n        last_message_created_at: i64,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let updated = sqlx::query(UPDATE_DM_CONVERSATION_LAST_MESSAGE)\n            .bind(owner_npub)\n            .bind(conversation_npub)\n            .bind(last_message_id)\n            .bind(last_message_created_at)\n            .execute(&mut *conn)\n            .await?;\n\n        if updated.rows_affected() == 0 {\n            sqlx::query(INSERT_DM_CONVERSATION)\n                .bind(owner_npub)\n                .bind(conversation_npub)\n                .bind(last_message_id)\n                .bind(last_message_created_at)\n                .bind(0_i64)\n                .execute(&mut *conn)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        conversation_npub: &str,\n        read_at: i64,\n    ) -> Result<(), AppError> {\n        let mut conn = self.pool.get_pool().acquire().await?;\n        let updated = sqlx::query(MARK_DM_CONVERSATION_READ)\n            .bind(owner_npub)\n            .bind(conversation_npub)\n            .bind(read_at)\n            .execute(&mut *conn)\n            .await?;\n\n        if updated.rows_affected() == 0 {\n            sqlx::query(INSERT_DM_CONVERSATION)\n                .bind(owner_npub)\n                .bind(conversation_npub)\n                .bind(None::<i64>)\n                .bind(None::<i64>)\n                .bind(read_at)\n                .execute(&mut *conn)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        cursor: Option<DirectMessageConversationCursor>,\n        limit: usize,\n    ) -> Result<DirectMessageConversationPageRaw, AppError> {\n        let fetch_limit = limit.saturating_add(1).max(1);\n        let mut builder = QueryBuilder::<Sqlite>::new(\n            r#\"\nSELECT\n    c.owner_npub AS owner_npub,\n    c.conversation_npub AS conversation_npub,\n    c.last_message_id AS last_message_id,\n    c.last_message_created_at AS last_message_created_at,\n    c.last_read_at AS last_read_at,\n    (\n        SELECT COUNT(*)\n        FROM direct_messages dm_unread\n        WHERE dm_unread.owner_npub = c.owner_npub\n          AND dm_unread.conversation_npub = c.conversation_npub\n          AND dm_unread.direction = 'inbound'\n          AND dm_unread.created_at > c.last_read_at\n    ) AS unread_count,\n    dm.id AS msg_id,\n    dm.owner_npub AS msg_owner_npub,\n    dm.conversation_npub AS msg_conversation_npub,\n    dm.sender_npub AS msg_sender_npub,\n    dm.recipient_npub AS msg_recipient_npub,\n    dm.event_id AS msg_event_id,\n    dm.client_message_id AS msg_client_message_id,\n    dm.payload_cipher_base64 AS msg_payload_cipher_base64,\n    dm.created_at AS msg_created_at,\n    dm.delivered AS msg_delivered,\n    dm.direction AS msg_direction\nFROM direct_message_conversations c\nLEFT JOIN direct_messages dm ON dm.id = c.last_message_id\nWHERE c.owner_npub = \"#,\n        );\n        builder.push_bind(owner_npub);\n\n        if let Some(cursor) = &cursor {\n            let bucket = cursor.bucket();\n            builder.push(\" AND (\");\n            builder.push(\"CASE WHEN c.last_message_created_at IS NULL THEN 1 ELSE 0 END > \");\n            builder.push_bind(bucket);\n            builder.push(\" OR (\");\n            builder.push(\"CASE WHEN c.last_message_created_at IS NULL THEN 1 ELSE 0 END = \");\n            builder.push_bind(bucket);\n            builder.push(\" AND \");\n            if bucket == 0 {\n                let created_at = cursor.last_message_created_at.unwrap_or(0);\n                builder.push(\"(\");\n                builder.push(\"c.last_message_created_at < \");\n                builder.push_bind(created_at);\n                builder.push(\" OR (c.last_message_created_at = \");\n                builder.push_bind(created_at);\n                builder.push(\" AND c.conversation_npub > \");\n                builder.push_bind(&cursor.conversation_npub);\n                builder.push(\"))\");\n            } else {\n                builder.push(\"(\");\n                builder.push(\"c.last_message_created_at IS NULL AND c.conversation_npub > \");\n                builder.push_bind(&cursor.conversation_npub);\n                builder.push(\")\");\n            }\n            builder.push(\"))\");\n        }\n\n        builder.push(\n            \" ORDER BY\n    c.last_message_created_at IS NULL,\n    c.last_message_created_at DESC,\n    c.conversation_npub ASC\nLIMIT \",\n        );\n        builder.push_bind(fetch_limit as i64);\n\n        let mut rows = builder\n            .build_query_as::<DirectMessageConversationJoinedRow>()\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let has_more = rows.len() > limit;\n        if has_more {\n            rows.truncate(limit);\n        }\n\n        let records: Vec<DirectMessageConversationRecord> =\n            rows.into_iter().map(|row| row.into_record()).collect();\n\n        let next_cursor = if has_more {\n            records.last().map(|record| {\n                DirectMessageConversationCursor::new(\n                    record.last_message_created_at,\n                    record.conversation_npub.clone(),\n                )\n                .to_string()\n            })\n        } else {\n            None\n        };\n\n        Ok(DirectMessageConversationPageRaw {\n            items: records,\n            next_cursor,\n            has_more,\n        })\n    }\n}\n","traces":[{"line":36,"address":[15135678,15131936],"length":1,"stats":{"Line":1}},{"line":37,"address":[15195603],"length":1,"stats":{"Line":1}},{"line":38,"address":[15234846,15235043],"length":1,"stats":{"Line":1}},{"line":39,"address":[15236603,15236753,15236848],"length":1,"stats":{"Line":2}},{"line":40,"address":[15118529,15118661,15118828],"length":1,"stats":{"Line":2}},{"line":41,"address":[15200312,15200636,15200469],"length":1,"stats":{"Line":2}},{"line":42,"address":[15126021,15126188,15125864],"length":1,"stats":{"Line":2}},{"line":43,"address":[15119525,15119368,15119692],"length":1,"stats":{"Line":2}},{"line":44,"address":[15126764,15126440,15126597],"length":1,"stats":{"Line":2}},{"line":45,"address":[15126885,15127052,15126728],"length":1,"stats":{"Line":2}},{"line":46,"address":[18054368,18054517,18054637],"length":1,"stats":{"Line":2}},{"line":47,"address":[15333706,15333549,15333829],"length":1,"stats":{"Line":2}},{"line":48,"address":[18054841,18055523,18054990],"length":1,"stats":{"Line":2}},{"line":54,"address":[16557545,16556832,16557760],"length":1,"stats":{"Line":1}},{"line":55,"address":[24257246,24257430],"length":1,"stats":{"Line":2}},{"line":56,"address":[16695602],"length":1,"stats":{"Line":1}},{"line":58,"address":[16496311],"length":1,"stats":{"Line":1}},{"line":59,"address":[24257534],"length":1,"stats":{"Line":1}},{"line":60,"address":[16496346],"length":1,"stats":{"Line":1}},{"line":61,"address":[16489402],"length":1,"stats":{"Line":1}},{"line":62,"address":[16599290],"length":1,"stats":{"Line":1}},{"line":63,"address":[20547698],"length":1,"stats":{"Line":1}},{"line":64,"address":[16595424],"length":1,"stats":{"Line":1}},{"line":65,"address":[20547774],"length":1,"stats":{"Line":1}},{"line":66,"address":[16489574],"length":1,"stats":{"Line":1}},{"line":94,"address":[18058096,18063480],"length":1,"stats":{"Line":1}},{"line":95,"address":[15244970],"length":1,"stats":{"Line":1}},{"line":96,"address":[15240659,15240842],"length":1,"stats":{"Line":1}},{"line":97,"address":[18058409,18058282,18058572],"length":1,"stats":{"Line":2}},{"line":98,"address":[15205954,15206256,15206111],"length":1,"stats":{"Line":2}},{"line":99,"address":[15242988,15243269,15243145],"length":1,"stats":{"Line":2}},{"line":100,"address":[15206622,15206465,15206746],"length":1,"stats":{"Line":2}},{"line":101,"address":[18059433,18059554,18059268],"length":1,"stats":{"Line":2}},{"line":102,"address":[18059830,18059687,18059522],"length":1,"stats":{"Line":2}},{"line":103,"address":[15132852,15132528,15132685],"length":1,"stats":{"Line":2}},{"line":104,"address":[15244477,15244644,15244320],"length":1,"stats":{"Line":2}},{"line":105,"address":[15126644,15126320,15126477],"length":1,"stats":{"Line":2}},{"line":106,"address":[15243248,15243572,15243405],"length":1,"stats":{"Line":2}},{"line":107,"address":[18061210,18060902,18061067],"length":1,"stats":{"Line":2}},{"line":108,"address":[15208861,15209028,15208704],"length":1,"stats":{"Line":2}},{"line":109,"address":[15240478,15240176,15240333],"length":1,"stats":{"Line":2}},{"line":110,"address":[15134824,15134522,15134679],"length":1,"stats":{"Line":2}},{"line":111,"address":[15134788,15134945,15135690],"length":1,"stats":{"Line":2}},{"line":117,"address":[15246585,15245792],"length":1,"stats":{"Line":1}},{"line":118,"address":[15133115],"length":1,"stats":{"Line":1}},{"line":120,"address":[15251461],"length":1,"stats":{"Line":1}},{"line":121,"address":[15249837],"length":1,"stats":{"Line":1}},{"line":123,"address":[15140005],"length":1,"stats":{"Line":1}},{"line":124,"address":[15207829],"length":1,"stats":{"Line":1}},{"line":125,"address":[15133249],"length":1,"stats":{"Line":1}},{"line":129,"address":[15210974,15211225,15208496],"length":1,"stats":{"Line":1}},{"line":130,"address":[15251689,15251576,15251650,15251743,15251611,15251133,15251464],"length":1,"stats":{"Line":7}},{"line":131,"address":[15247854,15246641],"length":1,"stats":{"Line":2}},{"line":132,"address":[15247875],"length":1,"stats":{"Line":1}},{"line":133,"address":[22910187],"length":1,"stats":{"Line":1}},{"line":134,"address":[15247955],"length":1,"stats":{"Line":1}},{"line":135,"address":[22910267],"length":1,"stats":{"Line":1}},{"line":136,"address":[18069266],"length":1,"stats":{"Line":1}},{"line":137,"address":[15252011],"length":1,"stats":{"Line":1}},{"line":138,"address":[15135392],"length":1,"stats":{"Line":1}},{"line":140,"address":[15347089],"length":1,"stats":{"Line":1}},{"line":141,"address":[18067977],"length":1,"stats":{"Line":1}},{"line":142,"address":[15250726],"length":1,"stats":{"Line":1}},{"line":143,"address":[15252445],"length":1,"stats":{"Line":1}},{"line":144,"address":[15134232],"length":1,"stats":{"Line":1}},{"line":145,"address":[15208899],"length":1,"stats":{"Line":1}},{"line":146,"address":[15141166],"length":1,"stats":{"Line":1}},{"line":147,"address":[15347472],"length":1,"stats":{"Line":1}},{"line":150,"address":[15216438],"length":1,"stats":{"Line":0}},{"line":153,"address":[15142208,15142286],"length":1,"stats":{"Line":2}},{"line":154,"address":[15135528],"length":1,"stats":{"Line":1}},{"line":157,"address":[15254317,15254533],"length":1,"stats":{"Line":2}},{"line":159,"address":[22910608],"length":1,"stats":{"Line":1}},{"line":160,"address":[15210272],"length":1,"stats":{"Line":1}},{"line":161,"address":[15210320],"length":1,"stats":{"Line":1}},{"line":162,"address":[15149536],"length":1,"stats":{"Line":1}},{"line":163,"address":[15217419,15217344],"length":1,"stats":{"Line":2}},{"line":164,"address":[15210499],"length":1,"stats":{"Line":1}},{"line":165,"address":[15248693],"length":1,"stats":{"Line":1}},{"line":175,"address":[13035351],"length":1,"stats":{"Line":5}},{"line":179,"address":[12132564],"length":1,"stats":{"Line":2}},{"line":180,"address":[12001038],"length":1,"stats":{"Line":3}},{"line":182,"address":[18295381,18296077,18296787,18295465,18295507,18295339,18295552,18295693,18296492,18296618,18295161,18295784,18295423,18295952,18297087,18295594,18296195],"length":1,"stats":{"Line":15}},{"line":183,"address":[15256476],"length":1,"stats":{"Line":1}},{"line":184,"address":[15242758],"length":1,"stats":{"Line":1}},{"line":185,"address":[15256564],"length":1,"stats":{"Line":1}},{"line":186,"address":[15355554],"length":1,"stats":{"Line":1}},{"line":187,"address":[15249680],"length":1,"stats":{"Line":1}},{"line":188,"address":[18295514],"length":1,"stats":{"Line":1}},{"line":189,"address":[15256797,15256751],"length":1,"stats":{"Line":2}},{"line":190,"address":[15317637,15317756,15317273,15318349],"length":1,"stats":{"Line":2}},{"line":191,"address":[15317764,15317889],"length":1,"stats":{"Line":2}},{"line":192,"address":[15318023,15318327,15317897,15317846],"length":1,"stats":{"Line":2}},{"line":193,"address":[15250490,15250046,15250231,15250340],"length":1,"stats":{"Line":2}},{"line":194,"address":[12032248],"length":1,"stats":{"Line":4}},{"line":196,"address":[15319581,15318899,15319419,15318748,15319293,15319051,15318981,15319972],"length":1,"stats":{"Line":6}},{"line":197,"address":[15361064,15360955,15360912,15361163],"length":1,"stats":{"Line":2}},{"line":198,"address":[18296992,18297032,18293551,18297115,18297457,18297273],"length":1,"stats":{"Line":4}},{"line":200,"address":[23020042,23019886,23020151,23020507,23020587,23020263,23020909,23021085],"length":1,"stats":{"Line":6}},{"line":201,"address":[15361733],"length":1,"stats":{"Line":1}},{"line":202,"address":[15458173,15458282,15458098,15458423],"length":1,"stats":{"Line":2}},{"line":203,"address":[12001116],"length":1,"stats":{"Line":4}},{"line":205,"address":[12037910],"length":1,"stats":{"Line":3}},{"line":207,"address":[15246437,15246633],"length":1,"stats":{"Line":2}},{"line":210,"address":[12940698],"length":1,"stats":{"Line":0}},{"line":218,"address":[15460397,15460479],"length":1,"stats":{"Line":0}},{"line":236,"address":[15247450],"length":1,"stats":{"Line":0}},{"line":237,"address":[23022508],"length":1,"stats":{"Line":0}},{"line":238,"address":[18300007],"length":1,"stats":{"Line":0}},{"line":240,"address":[15365889],"length":1,"stats":{"Line":0}},{"line":241,"address":[15322284],"length":1,"stats":{"Line":0}},{"line":243,"address":[15460822],"length":1,"stats":{"Line":0}},{"line":244,"address":[23022804],"length":1,"stats":{"Line":0}},{"line":245,"address":[18300271],"length":1,"stats":{"Line":0}},{"line":246,"address":[15460967],"length":1,"stats":{"Line":0}},{"line":247,"address":[15329442],"length":1,"stats":{"Line":0}},{"line":248,"address":[15247962],"length":1,"stats":{"Line":0}},{"line":249,"address":[15366337],"length":1,"stats":{"Line":0}},{"line":252,"address":[15366073],"length":1,"stats":{"Line":0}},{"line":253,"address":[15360798],"length":1,"stats":{"Line":0}},{"line":254,"address":[15461193],"length":1,"stats":{"Line":0}},{"line":255,"address":[15248161],"length":1,"stats":{"Line":0}},{"line":256,"address":[15254972],"length":1,"stats":{"Line":0}},{"line":257,"address":[15366516],"length":1,"stats":{"Line":0}},{"line":258,"address":[15329835],"length":1,"stats":{"Line":0}},{"line":263,"address":[15364352],"length":1,"stats":{"Line":0}},{"line":264,"address":[15329875],"length":1,"stats":{"Line":0}},{"line":266,"address":[15365083,15365013],"length":1,"stats":{"Line":0}},{"line":269,"address":[15255264,15255192],"length":1,"stats":{"Line":0}},{"line":273,"address":[23023421],"length":1,"stats":{"Line":0}},{"line":274,"address":[15330007],"length":1,"stats":{"Line":0}},{"line":276,"address":[15461582],"length":1,"stats":{"Line":0}},{"line":277,"address":[11452077],"length":1,"stats":{"Line":0}},{"line":279,"address":[15249278,15249433],"length":1,"stats":{"Line":0}},{"line":280,"address":[15330984],"length":1,"stats":{"Line":0}},{"line":281,"address":[15366137],"length":1,"stats":{"Line":0}},{"line":284,"address":[15249540,15250429,15250272,15249468],"length":1,"stats":{"Line":0}},{"line":285,"address":[15363014],"length":1,"stats":{"Line":0}},{"line":286,"address":[15264116],"length":1,"stats":{"Line":0}},{"line":289,"address":[15366331,15366220],"length":1,"stats":{"Line":0}},{"line":291,"address":[15249781],"length":1,"stats":{"Line":0}},{"line":293,"address":[15331269],"length":1,"stats":{"Line":0}},{"line":298,"address":[15264635,15265966,15266486,15264497,15266577,15264372,15264783,15264224,15264259,15265999],"length":1,"stats":{"Line":0}},{"line":305,"address":[11932057],"length":1,"stats":{"Line":0}},{"line":306,"address":[15368096,15368300,15368494,15368645,15368416,15369111,15369013,15368763,15369284,15368260],"length":1,"stats":{"Line":0}},{"line":307,"address":[15258391],"length":1,"stats":{"Line":0}},{"line":308,"address":[15369935,15369975],"length":1,"stats":{"Line":0}},{"line":309,"address":[15464767,15464883,15464644,15465287],"length":1,"stats":{"Line":0}},{"line":310,"address":[15368459,15368563],"length":1,"stats":{"Line":0}},{"line":311,"address":[15368680,15368528,15368571,15368817],"length":1,"stats":{"Line":0}},{"line":312,"address":[15465222,15465334,15463729,15465493,15465668,15465120],"length":1,"stats":{"Line":0}},{"line":313,"address":[15465637],"length":1,"stats":{"Line":0}},{"line":316,"address":[15266656,15266952,15267209,15266706,15266804,15268223,15269663],"length":1,"stats":{"Line":5}},{"line":323,"address":[15267670,15267084,15267241,15266831,15268232],"length":1,"stats":{"Line":2}},{"line":324,"address":[15466951,15467155,15467227,15467448,15467333,15467768,15467191,15467664,15467957,15467115,15468524],"length":1,"stats":{"Line":9}},{"line":325,"address":[15467102],"length":1,"stats":{"Line":1}},{"line":326,"address":[23029046],"length":1,"stats":{"Line":1}},{"line":327,"address":[15372398],"length":1,"stats":{"Line":1}},{"line":328,"address":[15267942,15267906],"length":1,"stats":{"Line":2}},{"line":329,"address":[15366699,15366894,15367000,15367138],"length":1,"stats":{"Line":2}},{"line":330,"address":[15254406,15254837,15253089,15254304,15254477,15254640],"length":1,"stats":{"Line":4}},{"line":332,"address":[15268569,15269550,15268687],"length":1,"stats":{"Line":3}},{"line":333,"address":[15367787,15368547,15368400,15368296,15367823,15367996,15368066,15368612,15367637,15367747,15367859],"length":1,"stats":{"Line":9}},{"line":334,"address":[15329622],"length":1,"stats":{"Line":1}},{"line":335,"address":[15373358],"length":1,"stats":{"Line":1}},{"line":336,"address":[15255110],"length":1,"stats":{"Line":1}},{"line":337,"address":[15367850],"length":1,"stats":{"Line":1}},{"line":339,"address":[15329813,15329587,15330012,15329919],"length":1,"stats":{"Line":2}},{"line":340,"address":[12042990],"length":1,"stats":{"Line":4}},{"line":343,"address":[15254964],"length":1,"stats":{"Line":1}},{"line":346,"address":[12935559],"length":1,"stats":{"Line":5}},{"line":352,"address":[18308588,18308220,18309511,18308992,18308450],"length":1,"stats":{"Line":2}},{"line":353,"address":[15470287,15470896,15470402,15469941,15470181,15471506,15470145,15470612,15470710,15470105],"length":1,"stats":{"Line":8}},{"line":354,"address":[15257020],"length":1,"stats":{"Line":1}},{"line":355,"address":[15263844],"length":1,"stats":{"Line":1}},{"line":356,"address":[18309224,18309188],"length":1,"stats":{"Line":2}},{"line":357,"address":[23031961,23032361,23032120,23032226],"length":1,"stats":{"Line":2}},{"line":358,"address":[11937170],"length":1,"stats":{"Line":4}},{"line":360,"address":[15470823,15470938,15471841],"length":1,"stats":{"Line":2}},{"line":361,"address":[15257872,15258116,15258887,15258822,15257982,15258574,15258274,15258675,15258022,15258061,15258168,15258344],"length":1,"stats":{"Line":0}},{"line":362,"address":[15257969],"length":1,"stats":{"Line":0}},{"line":363,"address":[18310093],"length":1,"stats":{"Line":0}},{"line":364,"address":[15376337],"length":1,"stats":{"Line":0}},{"line":365,"address":[15339624],"length":1,"stats":{"Line":0}},{"line":366,"address":[15376447,15376483],"length":1,"stats":{"Line":0}},{"line":367,"address":[23032910,23033378,23033179,23033285],"length":1,"stats":{"Line":0}},{"line":368,"address":[12136501],"length":1,"stats":{"Line":0}},{"line":371,"address":[15332495],"length":1,"stats":{"Line":1}},{"line":374,"address":[12143478],"length":1,"stats":{"Line":4}},{"line":380,"address":[15376093,15376011],"length":1,"stats":{"Line":2}},{"line":412,"address":[15377810],"length":1,"stats":{"Line":1}},{"line":414,"address":[15472676],"length":1,"stats":{"Line":1}},{"line":415,"address":[15266502,15266443],"length":1,"stats":{"Line":0}},{"line":416,"address":[15376366],"length":1,"stats":{"Line":0}},{"line":417,"address":[15378049],"length":1,"stats":{"Line":0}},{"line":418,"address":[18311845],"length":1,"stats":{"Line":0}},{"line":419,"address":[15341344],"length":1,"stats":{"Line":0}},{"line":420,"address":[15273619],"length":1,"stats":{"Line":0}},{"line":421,"address":[15378187],"length":1,"stats":{"Line":0}},{"line":422,"address":[15472994],"length":1,"stats":{"Line":0}},{"line":423,"address":[23034938],"length":1,"stats":{"Line":0}},{"line":424,"address":[15273803,15273733],"length":1,"stats":{"Line":0}},{"line":425,"address":[15372755],"length":1,"stats":{"Line":0}},{"line":426,"address":[18312102],"length":1,"stats":{"Line":0}},{"line":427,"address":[15473198],"length":1,"stats":{"Line":0}},{"line":428,"address":[15273909],"length":1,"stats":{"Line":0}},{"line":429,"address":[15260189],"length":1,"stats":{"Line":0}},{"line":430,"address":[23035188],"length":1,"stats":{"Line":0}},{"line":431,"address":[15274012],"length":1,"stats":{"Line":0}},{"line":432,"address":[15267063],"length":1,"stats":{"Line":0}},{"line":434,"address":[23034976],"length":1,"stats":{"Line":0}},{"line":435,"address":[15473423],"length":1,"stats":{"Line":0}},{"line":436,"address":[15377031],"length":1,"stats":{"Line":0}},{"line":437,"address":[15378706],"length":1,"stats":{"Line":0}},{"line":439,"address":[15473530,15473388],"length":1,"stats":{"Line":0}},{"line":442,"address":[15376315],"length":1,"stats":{"Line":1}},{"line":449,"address":[15274228],"length":1,"stats":{"Line":1}},{"line":451,"address":[15377945,15377374,15377619,15377131,15377269,15377739],"length":1,"stats":{"Line":5}},{"line":453,"address":[15378952,15378810,15379086,15378858],"length":1,"stats":{"Line":2}},{"line":454,"address":[15260767,15259124,15261027,15260861,15261257,15260672],"length":1,"stats":{"Line":4}},{"line":456,"address":[15379676,15379521],"length":1,"stats":{"Line":2}},{"line":457,"address":[15474491],"length":1,"stats":{"Line":1}},{"line":458,"address":[18313403],"length":1,"stats":{"Line":0}},{"line":461,"address":[23036399,23037264,23036499,23037292],"length":1,"stats":{"Line":4}},{"line":464,"address":[15474677,15474653],"length":1,"stats":{"Line":2}},{"line":465,"address":[15380806,15380217,15380624,15379895],"length":1,"stats":{"Line":0}},{"line":466,"address":[23037392],"length":1,"stats":{"Line":0}},{"line":467,"address":[15380649],"length":1,"stats":{"Line":0}},{"line":468,"address":[18314234],"length":1,"stats":{"Line":0}},{"line":470,"address":[18314309],"length":1,"stats":{"Line":0}},{"line":473,"address":[15268371],"length":1,"stats":{"Line":1}},{"line":476,"address":[15378347],"length":1,"stats":{"Line":1}},{"line":477,"address":[18313540],"length":1,"stats":{"Line":1}},{"line":478,"address":[15275435],"length":1,"stats":{"Line":1}}],"covered":148,"coverable":234},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","events.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_event_row;\nuse super::queries::{\n    INSERT_EVENT, INSERT_EVENT_TOPIC, MARK_EVENT_DELETED, MARK_EVENT_SYNCED, SELECT_EVENT_BY_ID,\n    SELECT_EVENT_TOPICS, SELECT_EVENTS_BY_AUTHOR, SELECT_EVENTS_BY_KIND, SELECT_UNSYNC_EVENTS,\n};\nuse crate::application::ports::repositories::EventRepository;\nuse crate::domain::entities::Event;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl EventRepository for SqliteRepository {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError> {\n        let tags_json = serde_json::to_string(&event.tags).unwrap_or_else(|_| \"[]\".to_string());\n\n        sqlx::query(INSERT_EVENT)\n            .bind(event.id.to_string())\n            .bind(&event.pubkey)\n            .bind(&event.content)\n            .bind(event.kind as i64)\n            .bind(&tags_json)\n            .bind(event.created_at.timestamp_millis())\n            .bind(&event.sig)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        for tag in &event.tags {\n            if tag.len() >= 2 {\n                let key = tag[0].to_lowercase();\n                if (key == \"topic\" || key == \"t\") && !tag[1].is_empty() {\n                    let _ = self.add_event_topic(&event.id, &tag[1]).await;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        let row = sqlx::query(SELECT_EVENT_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_event_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_KIND)\n            .bind(kind as i64)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_AUTHOR)\n            .bind(pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_EVENTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_SYNCED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError> {\n        sqlx::query(INSERT_EVENT_TOPIC)\n            .bind(event_id)\n            .bind(topic_id)\n            .bind(Utc::now().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_EVENT_TOPICS)\n            .bind(event_id)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            topics.push(row.try_get::<String, _>(\"topic_id\")?);\n        }\n\n        Ok(topics)\n    }\n}\n","traces":[{"line":16,"address":[12897671],"length":1,"stats":{"Line":0}},{"line":17,"address":[15713744,15713728,15711077],"length":1,"stats":{"Line":0}},{"line":19,"address":[21532137,21531504,21532255,21532654,21532839,21531773,21531726,21531990,21531931,21531581,21532544,21531812,21531438,21531648],"length":1,"stats":{"Line":0}},{"line":20,"address":[21670852,21670104,21669992,21669949],"length":1,"stats":{"Line":0}},{"line":21,"address":[21569744],"length":1,"stats":{"Line":0}},{"line":22,"address":[21538638],"length":1,"stats":{"Line":0}},{"line":23,"address":[21573801],"length":1,"stats":{"Line":0}},{"line":24,"address":[21670280,21670319],"length":1,"stats":{"Line":0}},{"line":25,"address":[21471518,21470843,21471015,21471134],"length":1,"stats":{"Line":0}},{"line":26,"address":[21575670,21575748],"length":1,"stats":{"Line":0}},{"line":27,"address":[15711729,15711772,15711884,15712031],"length":1,"stats":{"Line":0}},{"line":28,"address":[21539719,21539108,21539354,21539213,21539520,21538070],"length":1,"stats":{"Line":0}},{"line":30,"address":[21671911,21671369,21671228,21671843],"length":1,"stats":{"Line":0}},{"line":31,"address":[21575503,21575561],"length":1,"stats":{"Line":0}},{"line":32,"address":[21575579],"length":1,"stats":{"Line":0}},{"line":33,"address":[21540559],"length":1,"stats":{"Line":0}},{"line":34,"address":[12003666],"length":1,"stats":{"Line":0}},{"line":39,"address":[21458808],"length":1,"stats":{"Line":0}},{"line":42,"address":[21572275,21572390,21572502,21572240,21572964,21573689],"length":1,"stats":{"Line":0}},{"line":43,"address":[21459982,21460413,21459903,21460521,21460081,21460805,21461424,21460186],"length":1,"stats":{"Line":0}},{"line":44,"address":[21572718,21572673],"length":1,"stats":{"Line":0}},{"line":45,"address":[21473694,21473782,21473998,21473876],"length":1,"stats":{"Line":0}},{"line":46,"address":[21459713,21460301,21460461,21460124,21460757,21460213],"length":1,"stats":{"Line":0}},{"line":48,"address":[21535315],"length":1,"stats":{"Line":0}},{"line":49,"address":[21475116,21474648,21474750],"length":1,"stats":{"Line":0}},{"line":50,"address":[21577482],"length":1,"stats":{"Line":0}},{"line":54,"address":[12830008],"length":1,"stats":{"Line":0}},{"line":55,"address":[21675800,21675254,21674941,21675149,21675594,21676945,21675490,21675015],"length":1,"stats":{"Line":0}},{"line":56,"address":[21536531],"length":1,"stats":{"Line":0}},{"line":57,"address":[21574711],"length":1,"stats":{"Line":0}},{"line":58,"address":[21578880,21578540,21578752,21578655],"length":1,"stats":{"Line":0}},{"line":59,"address":[12016948],"length":1,"stats":{"Line":0}},{"line":61,"address":[21581099,21580944],"length":1,"stats":{"Line":0}},{"line":62,"address":[15717435,15717141,15717387,15717252],"length":1,"stats":{"Line":0}},{"line":63,"address":[21477144,21476939,21477362],"length":1,"stats":{"Line":0}},{"line":64,"address":[21580188],"length":1,"stats":{"Line":0}},{"line":67,"address":[21537781],"length":1,"stats":{"Line":0}},{"line":70,"address":[21538618,21538515,21539249,21540305,21538730,21538480],"length":1,"stats":{"Line":0}},{"line":75,"address":[21678186,21677337,21679329,21677980,21677882,21677416,21677655,21677550],"length":1,"stats":{"Line":0}},{"line":76,"address":[21577035],"length":1,"stats":{"Line":0}},{"line":77,"address":[21545928],"length":1,"stats":{"Line":0}},{"line":78,"address":[21478273,21478395,21478176,21478056],"length":1,"stats":{"Line":0}},{"line":79,"address":[21539658,21539113,21539202,21538645,21539290,21539450],"length":1,"stats":{"Line":0}},{"line":81,"address":[21678114,21678269],"length":1,"stats":{"Line":0}},{"line":82,"address":[21478983,21479094,21479229,21479277],"length":1,"stats":{"Line":0}},{"line":83,"address":[21578690,21578474,21578269],"length":1,"stats":{"Line":0}},{"line":84,"address":[21479692],"length":1,"stats":{"Line":0}},{"line":87,"address":[21479335],"length":1,"stats":{"Line":0}},{"line":90,"address":[12940047],"length":1,"stats":{"Line":0}},{"line":91,"address":[21679911,21679685,21680045,21680375,21680115,21680473,21679756,21680654,21679855],"length":1,"stats":{"Line":0}},{"line":92,"address":[21679764,21680200,21679890,21679716],"length":1,"stats":{"Line":0}},{"line":93,"address":[21480586,21480666],"length":1,"stats":{"Line":0}},{"line":94,"address":[21583292,21583554,21583506,21583737,21583648],"length":1,"stats":{"Line":0}},{"line":95,"address":[11972724],"length":1,"stats":{"Line":0}},{"line":97,"address":[21467495],"length":1,"stats":{"Line":0}},{"line":100,"address":[21580474,21580336,21580371,21581008,21582064,21580586],"length":1,"stats":{"Line":0}},{"line":101,"address":[21468761,21468230,21468058,21469906,21468457,21468125,21467987,21468555],"length":1,"stats":{"Line":0}},{"line":102,"address":[21586570,21586354,21586448,21586306],"length":1,"stats":{"Line":0}},{"line":103,"address":[12011172],"length":1,"stats":{"Line":0}},{"line":105,"address":[21585329,21585484],"length":1,"stats":{"Line":0}},{"line":106,"address":[21543573,21543462,21543708,21543756],"length":1,"stats":{"Line":0}},{"line":107,"address":[21544227,21544009,21543804],"length":1,"stats":{"Line":0}},{"line":108,"address":[21469581],"length":1,"stats":{"Line":0}},{"line":111,"address":[21585862],"length":1,"stats":{"Line":0}},{"line":114,"address":[12837295],"length":1,"stats":{"Line":0}},{"line":115,"address":[21683333,21683763,21683404,21683559,21684121,21684302,21683503,21683693,21684023],"length":1,"stats":{"Line":0}},{"line":116,"address":[21160944,21160992,21161118,21161412],"length":1,"stats":{"Line":0}},{"line":117,"address":[15724778,15724858],"length":1,"stats":{"Line":0}},{"line":118,"address":[21470656,21470745,21470514,21470562,21470300],"length":1,"stats":{"Line":0}},{"line":119,"address":[21583422,21583544,21583703,21583886,21582781,21583368],"length":1,"stats":{"Line":0}},{"line":121,"address":[21471143],"length":1,"stats":{"Line":0}},{"line":124,"address":[21546784,21545907,21546111,21546005,21547156,21545872,21546746],"length":1,"stats":{"Line":4}},{"line":125,"address":[21485758,21486095,21485640,21485474,21486196,21485828,21485390,21486377,21485514],"length":1,"stats":{"Line":9}},{"line":126,"address":[21684773],"length":1,"stats":{"Line":1}},{"line":127,"address":[21588421,21588381],"length":1,"stats":{"Line":2}},{"line":128,"address":[21478445,21478704,21478947,21478573],"length":1,"stats":{"Line":2}},{"line":129,"address":[21685105,21685008,21684741,21685194],"length":1,"stats":{"Line":2}},{"line":130,"address":[12011895],"length":1,"stats":{"Line":5}},{"line":131,"address":[21472530],"length":1,"stats":{"Line":0}},{"line":134,"address":[21554306,21554211,21554412,21554176,21554874,21555944],"length":1,"stats":{"Line":0}},{"line":135,"address":[15727301,15727479,15727584,15727909,15728114,15729101,15727380,15727811],"length":1,"stats":{"Line":0}},{"line":136,"address":[21589703,21589748],"length":1,"stats":{"Line":0}},{"line":137,"address":[15727420,15727332,15727514,15727636],"length":1,"stats":{"Line":0}},{"line":138,"address":[12109428],"length":1,"stats":{"Line":0}},{"line":140,"address":[21555259,21555412],"length":1,"stats":{"Line":0}},{"line":141,"address":[21686990,21687101,21687236,21687284],"length":1,"stats":{"Line":0}},{"line":142,"address":[21165001,21164776],"length":1,"stats":{"Line":0}},{"line":145,"address":[21488046],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":88},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mapper.rs"],"content":"pub(super) use crate::application::shared::mappers::{\n    map_event_row, map_joined_topic_row, map_post_row, map_topic_row, map_user_row,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mod.rs"],"content":"use super::ConnectionPool;\nuse super::Repository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\nmod bookmarks;\nmod direct_messages;\nmod events;\nmod mapper;\nmod pending_topics;\nmod posts;\nmod queries;\nmod topic_metrics;\nmod topics;\nmod users;\n\npub struct SqliteRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl Repository for SqliteRepository {\n    async fn initialize(&self) -> Result<(), AppError> {\n        self.pool.migrate().await?;\n        Ok(())\n    }\n\n    async fn health_check(&self) -> Result<bool, AppError> {\n        let result = sqlx::query(\"SELECT 1\")\n            .fetch_one(self.pool.get_pool())\n            .await;\n        Ok(result.is_ok())\n    }\n}\n","traces":[{"line":22,"address":[12708000],"length":1,"stats":{"Line":7}},{"line":29,"address":[12944192,12944619,12944143,12944415,12944309,12945052,12944227,12944960],"length":1,"stats":{"Line":33}},{"line":30,"address":[12940715,12941029,12940585,12940400],"length":1,"stats":{"Line":10}},{"line":31,"address":[12944926],"length":1,"stats":{"Line":6}},{"line":34,"address":[12945325,12945732,12945081,12945242,12945155,12945120,12946164,12945348],"length":1,"stats":{"Line":0}},{"line":35,"address":[12941585,12941652,12941517,12941722,12941949],"length":1,"stats":{"Line":0}},{"line":36,"address":[12945623,12945529,12945484,12945710],"length":1,"stats":{"Line":0}},{"line":37,"address":[12910565,12910861,12910149,12910653,12910511],"length":1,"stats":{"Line":0}},{"line":38,"address":[12947679,12947750],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","pending_topics.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    DELETE_PENDING_TOPIC, INSERT_PENDING_TOPIC, SELECT_PENDING_TOPIC_BY_ID,\n    SELECT_PENDING_TOPICS_BY_USER, UPDATE_PENDING_TOPIC_STATUS,\n};\nuse crate::application::ports::repositories::PendingTopicRepository;\nuse crate::domain::entities::{PendingTopic, PendingTopicStatus};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse sqlx::Row;\n\nfn map_pending_topic(row: &sqlx::sqlite::SqliteRow) -> Result<PendingTopic, AppError> {\n    let created_at = DateTime::<Utc>::from_timestamp_millis(row.try_get::<i64, _>(\"created_at\")?)\n        .ok_or_else(|| AppError::Internal(\"Invalid created_at timestamp\".into()))?;\n    let updated_at = DateTime::<Utc>::from_timestamp_millis(row.try_get::<i64, _>(\"updated_at\")?)\n        .ok_or_else(|| AppError::Internal(\"Invalid updated_at timestamp\".into()))?;\n    let status_value: String = row.try_get(\"status\")?;\n\n    Ok(PendingTopic::new(\n        row.try_get(\"pending_id\")?,\n        row.try_get(\"user_pubkey\")?,\n        row.try_get(\"name\")?,\n        row.try_get::<Option<String>, _>(\"description\")?,\n        PendingTopicStatus::from_value(status_value.as_str()),\n        row.try_get(\"offline_action_id\")?,\n        row.try_get::<Option<String>, _>(\"synced_topic_id\")?,\n        row.try_get::<Option<String>, _>(\"error_message\")?,\n        created_at,\n        updated_at,\n    ))\n}\n\n#[async_trait]\nimpl PendingTopicRepository for SqliteRepository {\n    async fn insert_pending_topic(&self, topic: &PendingTopic) -> Result<(), AppError> {\n        sqlx::query(INSERT_PENDING_TOPIC)\n            .bind(&topic.pending_id)\n            .bind(&topic.user_pubkey)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.status.as_str())\n            .bind(&topic.offline_action_id)\n            .bind(&topic.synced_topic_id)\n            .bind(&topic.error_message)\n            .bind(topic.created_at.timestamp_millis())\n            .bind(topic.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn list_pending_topics(&self, user_pubkey: &str) -> Result<Vec<PendingTopic>, AppError> {\n        let rows = sqlx::query(SELECT_PENDING_TOPICS_BY_USER)\n            .bind(user_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        rows.iter().map(map_pending_topic).collect()\n    }\n\n    async fn get_pending_topic(&self, pending_id: &str) -> Result<Option<PendingTopic>, AppError> {\n        let row = sqlx::query(SELECT_PENDING_TOPIC_BY_ID)\n            .bind(pending_id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => map_pending_topic(&row).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    async fn update_pending_topic_status(\n        &self,\n        pending_id: &str,\n        status: PendingTopicStatus,\n        synced_topic_id: Option<&str>,\n        error_message: Option<&str>,\n    ) -> Result<(), AppError> {\n        let now = Utc::now().timestamp_millis();\n        sqlx::query(UPDATE_PENDING_TOPIC_STATUS)\n            .bind(pending_id)\n            .bind(status.as_str())\n            .bind(synced_topic_id)\n            .bind(error_message)\n            .bind(now)\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn delete_pending_topic(&self, pending_id: &str) -> Result<(), AppError> {\n        sqlx::query(DELETE_PENDING_TOPIC)\n            .bind(pending_id)\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[20920773,20919541,20915744],"length":1,"stats":{"Line":0}},{"line":14,"address":[20815406,20815836],"length":1,"stats":{"Line":0}},{"line":15,"address":[20920800,20916176,20920814],"length":1,"stats":{"Line":0}},{"line":16,"address":[20716776,20716918,20717232],"length":1,"stats":{"Line":0}},{"line":17,"address":[20987104,20987118,20982807],"length":1,"stats":{"Line":0}},{"line":18,"address":[20717113,20717358,20717263],"length":1,"stats":{"Line":0}},{"line":20,"address":[20780620,20780219],"length":1,"stats":{"Line":0}},{"line":21,"address":[20710658,20710483,20710351],"length":1,"stats":{"Line":0}},{"line":22,"address":[20983518,20983198,20983347],"length":1,"stats":{"Line":0}},{"line":23,"address":[14958595,14958770,14958438],"length":1,"stats":{"Line":0}},{"line":24,"address":[20711535,20711214,20711371],"length":1,"stats":{"Line":0}},{"line":25,"address":[20917801,20917954],"length":1,"stats":{"Line":0}},{"line":26,"address":[20817606,20817812],"length":1,"stats":{"Line":0}},{"line":27,"address":[20823517,20823360,20823692],"length":1,"stats":{"Line":0}},{"line":28,"address":[20719128,20719285,20719617],"length":1,"stats":{"Line":0}},{"line":36,"address":[20831554,20831296,20831442,20832750,20833120,20832668,20831331],"length":1,"stats":{"Line":0}},{"line":37,"address":[20864357,20862998,20862843,20863161,20864078,20863292,20862918,20863577,20862958,20863217,20863765,20863335,20864176,20863695,20863038,20863448],"length":1,"stats":{"Line":0}},{"line":38,"address":[20750205],"length":1,"stats":{"Line":0}},{"line":39,"address":[20866881],"length":1,"stats":{"Line":0}},{"line":40,"address":[20866921],"length":1,"stats":{"Line":0}},{"line":41,"address":[20750321,20750361],"length":1,"stats":{"Line":0}},{"line":42,"address":[15004474,15004796,15004673,15005512],"length":1,"stats":{"Line":0}},{"line":43,"address":[20757284],"length":1,"stats":{"Line":0}},{"line":44,"address":[20863279],"length":1,"stats":{"Line":0}},{"line":45,"address":[20750615,20750658],"length":1,"stats":{"Line":0}},{"line":46,"address":[20869474,20869067,20868954,20868828],"length":1,"stats":{"Line":0}},{"line":47,"address":[20757941,20757579,20757697],"length":1,"stats":{"Line":0}},{"line":48,"address":[15005233,15005330,15005420],"length":1,"stats":{"Line":0}},{"line":49,"address":[15004253,15005726,15005392,15005338,15005566,15005909],"length":1,"stats":{"Line":0}},{"line":50,"address":[20864270],"length":1,"stats":{"Line":0}},{"line":53,"address":[12905385],"length":1,"stats":{"Line":0}},{"line":54,"address":[20758994,20759595,20759389,20758895,20758819,20759291,20759064,20759817],"length":1,"stats":{"Line":0}},{"line":55,"address":[20864802,20864847],"length":1,"stats":{"Line":0}},{"line":56,"address":[20758935,20758850,20759029,20759116],"length":1,"stats":{"Line":0}},{"line":57,"address":[20758629,20759179,20759037,20759091,20759339,20759547],"length":1,"stats":{"Line":0}},{"line":59,"address":[20871019,20871190],"length":1,"stats":{"Line":0}},{"line":62,"address":[20753040,20754681,20753190,20753075,20753302,20753764,20754489],"length":1,"stats":{"Line":0}},{"line":63,"address":[20867013,20866190,20866289,20866111,20866394,20866621,20866729],"length":1,"stats":{"Line":0}},{"line":64,"address":[20866177,20866222],"length":1,"stats":{"Line":0}},{"line":65,"address":[20871814,20871908,20872030,20871726],"length":1,"stats":{"Line":0}},{"line":66,"address":[20865921,20866965,20866332,20866509,20866669,20866421],"length":1,"stats":{"Line":0}},{"line":68,"address":[21169619],"length":1,"stats":{"Line":0}},{"line":69,"address":[20867096,20867198],"length":1,"stats":{"Line":0}},{"line":70,"address":[20867050],"length":1,"stats":{"Line":0}},{"line":74,"address":[13037165],"length":1,"stats":{"Line":0}},{"line":81,"address":[20761926],"length":1,"stats":{"Line":0}},{"line":82,"address":[20830567,20830317,20830247,20829869,20829790,20830849,20830113,20830041,20829988,20830668],"length":1,"stats":{"Line":0}},{"line":83,"address":[20755264,20755304],"length":1,"stats":{"Line":0}},{"line":84,"address":[20868514,20867933,20868145,20868016],"length":1,"stats":{"Line":0}},{"line":87,"address":[20873873],"length":1,"stats":{"Line":0}},{"line":88,"address":[20873978,20873764,20873881,20874067],"length":1,"stats":{"Line":0}},{"line":89,"address":[20874497,20873136,20874152,20874040,20874311,20873986],"length":1,"stats":{"Line":0}},{"line":90,"address":[20830762],"length":1,"stats":{"Line":0}},{"line":93,"address":[13037289],"length":1,"stats":{"Line":0}},{"line":94,"address":[20838402,20838908,20838233,20838157,20838332,20838629,20838727],"length":1,"stats":{"Line":0}},{"line":95,"address":[15011049,15011004],"length":1,"stats":{"Line":0}},{"line":96,"address":[20873487,20873393,20873308,20873574],"length":1,"stats":{"Line":0}},{"line":97,"address":[12035540],"length":1,"stats":{"Line":0}},{"line":98,"address":[15011605],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","posts.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_post_row;\nuse super::queries::{\n    INSERT_POST_EVENT, MARK_POST_DELETED, MARK_POST_SYNCED, SELECT_POST_BY_ID,\n    SELECT_POSTS_BY_AUTHOR, SELECT_POSTS_BY_TOPIC, SELECT_RECENT_POSTS, SELECT_UNSYNC_POSTS,\n    UPDATE_POST_CONTENT,\n};\nuse crate::application::ports::repositories::{PostFeedCursor, PostFeedPage, PostRepository};\nuse crate::domain::entities::Post;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{QueryBuilder, Sqlite};\n\nfn serialize_topic_tags(post: &Post) -> String {\n    let mut tags = vec![vec![\"t\".to_string(), post.topic_id.clone()]];\n    if let Some(scope) = post.scope.as_ref() {\n        tags.push(vec![\"scope\".to_string(), scope.clone()]);\n    }\n    if let Some(epoch) = post.epoch {\n        tags.push(vec![\"epoch\".to_string(), epoch.to_string()]);\n    }\n    serde_json::to_string(&tags).unwrap_or_else(|_| \"[]\".to_string())\n}\n\nfn topic_tag_like(topic_id: &str) -> String {\n    format!(r#\"[\"t\",\"{topic_id}\"]\"#)\n}\n\n#[async_trait]\nimpl PostRepository for SqliteRepository {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError> {\n        let tags_json = serialize_topic_tags(post);\n\n        sqlx::query(INSERT_POST_EVENT)\n            .bind(&post.id)\n            .bind(post.author.pubkey())\n            .bind(&post.content)\n            .bind(1)\n            .bind(&tags_json)\n            .bind(post.created_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        let row = sqlx::query(SELECT_POST_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_post_row(&row, None)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_TOPIC)\n            .bind(topic_tag_like(topic_id))\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, Some(topic_id))?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn update_post(&self, post: &Post) -> Result<(), AppError> {\n        sqlx::query(UPDATE_POST_CONTENT)\n            .bind(&post.content)\n            .bind(Utc::now().timestamp_millis())\n            .bind(&post.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_POSTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let mut post = map_post_row(&row, None)?;\n            post.mark_as_unsynced();\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_SYNCED)\n            .bind(event_id)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_AUTHOR)\n            .bind(author_pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_RECENT_POSTS)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        cursor: Option<PostFeedCursor>,\n        limit: usize,\n    ) -> Result<PostFeedPage, AppError> {\n        let limit = limit.clamp(1, 100);\n        let fetch_limit = limit + 1;\n\n        let mut builder: QueryBuilder<Sqlite> = QueryBuilder::new(\n            \"SELECT e.event_id, e.public_key, e.content, e.tags, e.created_at \\\n             FROM events e \\\n             INNER JOIN follows f ON f.followed_pubkey = e.public_key \\\n             WHERE f.follower_pubkey = \",\n        );\n        builder.push_bind(follower_pubkey);\n        builder.push(\" AND e.kind = 1 AND e.deleted = 0\");\n\n        if let Some(cursor) = cursor {\n            builder.push(\" AND (e.created_at < \");\n            builder.push_bind(cursor.created_at);\n            builder.push(\" OR (e.created_at = \");\n            builder.push_bind(cursor.created_at);\n            builder.push(\" AND e.event_id < \");\n            builder.push_bind(cursor.event_id);\n            builder.push(\"))\");\n        }\n\n        builder.push(\" ORDER BY e.created_at DESC, e.event_id DESC LIMIT \");\n        builder.push_bind(fetch_limit as i64);\n\n        let rows = builder.build().fetch_all(self.pool.get_pool()).await?;\n\n        let mut rows_iter = rows.into_iter();\n        let mut posts = Vec::with_capacity(limit.min(fetch_limit));\n\n        for _ in 0..limit {\n            if let Some(row) = rows_iter.next() {\n                let post = map_post_row(&row, None)?;\n                posts.push(post);\n            } else {\n                break;\n            }\n        }\n\n        let has_more = rows_iter.next().is_some();\n        let next_cursor = if has_more {\n            posts.last().map(|post| {\n                PostFeedCursor {\n                    created_at: post.created_at.timestamp_millis(),\n                    event_id: post.id.clone(),\n                }\n                .to_string()\n            })\n        } else {\n            None\n        };\n\n        Ok(PostFeedPage {\n            items: posts,\n            next_cursor,\n            has_more,\n        })\n    }\n}\n","traces":[{"line":15,"address":[16564704,16565835,16566338],"length":1,"stats":{"Line":2}},{"line":16,"address":[12966845,12967401,12968423],"length":1,"stats":{"Line":2}},{"line":17,"address":[16596474,16596559],"length":1,"stats":{"Line":4}},{"line":18,"address":[16490707,16491108,16490744],"length":1,"stats":{"Line":2}},{"line":20,"address":[16697406,16697012],"length":1,"stats":{"Line":3}},{"line":21,"address":[16491140,16491184],"length":1,"stats":{"Line":2}},{"line":23,"address":[12968432,12967985,12968448,12968364],"length":1,"stats":{"Line":4}},{"line":26,"address":[16603248],"length":1,"stats":{"Line":1}},{"line":27,"address":[16484986],"length":1,"stats":{"Line":1}},{"line":32,"address":[13037367],"length":1,"stats":{"Line":10}},{"line":33,"address":[16631795],"length":1,"stats":{"Line":2}},{"line":35,"address":[16699892,16700826,16699654,16699575,16700558,16700046,16699774,16700164,16699830,16699933,16700279,16700656],"length":1,"stats":{"Line":22}},{"line":36,"address":[16730865,16730825],"length":1,"stats":{"Line":4}},{"line":37,"address":[24393062,24393145,24393265,24393849],"length":1,"stats":{"Line":4}},{"line":38,"address":[16734937],"length":1,"stats":{"Line":2}},{"line":40,"address":[16632164,16632200],"length":1,"stats":{"Line":4}},{"line":41,"address":[16632208,16632611,16632097,16632326],"length":1,"stats":{"Line":4}},{"line":42,"address":[16700102,16700199,16700333],"length":1,"stats":{"Line":4}},{"line":43,"address":[11960452],"length":1,"stats":{"Line":8}},{"line":45,"address":[16619230],"length":1,"stats":{"Line":2}},{"line":48,"address":[12831161],"length":1,"stats":{"Line":5}},{"line":49,"address":[16739588,16738573,16738675,16738241,16738346,16738956,16738063,16738142],"length":1,"stats":{"Line":6}},{"line":50,"address":[16619886,16619841],"length":1,"stats":{"Line":2}},{"line":51,"address":[16738398,16738182,16738094,16738276],"length":1,"stats":{"Line":2}},{"line":52,"address":[11888436],"length":1,"stats":{"Line":4}},{"line":54,"address":[16737229],"length":1,"stats":{"Line":1}},{"line":55,"address":[13302116,13301637,13301767],"length":1,"stats":{"Line":1}},{"line":56,"address":[24395681],"length":1,"stats":{"Line":0}},{"line":60,"address":[16734913,16736036,16734016,16734051,16734944,16734162,16734274],"length":1,"stats":{"Line":5}},{"line":65,"address":[16697280,16698459,16696429,16696619,16696724,16696485,16696355,16697074,16696976,16696289],"length":1,"stats":{"Line":8}},{"line":66,"address":[16628512,16629002,16628669,16628555],"length":1,"stats":{"Line":2}},{"line":67,"address":[16734664],"length":1,"stats":{"Line":1}},{"line":68,"address":[16621968,16621920,16622187,16622062],"length":1,"stats":{"Line":2}},{"line":69,"address":[16740720,16740928,16739773,16740358,16740447,16740560],"length":1,"stats":{"Line":4}},{"line":71,"address":[16739256,16739411],"length":1,"stats":{"Line":2}},{"line":72,"address":[13303896,13303725,13303622,13303852],"length":1,"stats":{"Line":4}},{"line":73,"address":[16736093,16736300,16735827],"length":1,"stats":{"Line":2}},{"line":74,"address":[16836614],"length":1,"stats":{"Line":1}},{"line":77,"address":[16739834],"length":1,"stats":{"Line":1}},{"line":80,"address":[24399084,24398848,24399776,24400145,24398883,24398978,24399735],"length":1,"stats":{"Line":0}},{"line":81,"address":[16837685,16837285,16838015,16837369,16837755,16838113,16837495,16837551,16838294],"length":1,"stats":{"Line":0}},{"line":82,"address":[16698916,16698876],"length":1,"stats":{"Line":0}},{"line":83,"address":[16638218,16638004,16638092,16638528],"length":1,"stats":{"Line":0}},{"line":84,"address":[16742754,16742834],"length":1,"stats":{"Line":0}},{"line":85,"address":[24399713,24399624,24399482,24399530,24399228],"length":1,"stats":{"Line":0}},{"line":86,"address":[16699583,16699302,16699766,16698621,16699248,16699424],"length":1,"stats":{"Line":0}},{"line":88,"address":[16625135],"length":1,"stats":{"Line":0}},{"line":91,"address":[16706819,16706914,16707020,16707631,16706784,16708041,16707672],"length":1,"stats":{"Line":5}},{"line":92,"address":[16742935,16743033,16742316,16742245,16742415,16742675,16742605,16743214,16742471],"length":1,"stats":{"Line":8}},{"line":93,"address":[24401096,24400660,24400786,24400612],"length":1,"stats":{"Line":2}},{"line":94,"address":[16625818,16625898],"length":1,"stats":{"Line":2}},{"line":95,"address":[16738610,16738348,16738562,16738793,16738704],"length":1,"stats":{"Line":2}},{"line":96,"address":[16743166,16742824,16742983,16742702,16742061,16742648],"length":1,"stats":{"Line":4}},{"line":98,"address":[16626487],"length":1,"stats":{"Line":1}},{"line":101,"address":[12942969],"length":1,"stats":{"Line":5}},{"line":102,"address":[16702345,16703533,16702041,16701709,16702139,16701642,16701571,16701814],"length":1,"stats":{"Line":9}},{"line":103,"address":[16745298,16745562,16745440,16745346],"length":1,"stats":{"Line":3}},{"line":104,"address":[16745993,16745077,16745537,16745625,16745448,16745785],"length":1,"stats":{"Line":6}},{"line":106,"address":[16641596,16641441],"length":1,"stats":{"Line":2}},{"line":107,"address":[16702748,16702565,16702700,16702454],"length":1,"stats":{"Line":4}},{"line":108,"address":[16841260,16841509,16841661],"length":1,"stats":{"Line":2}},{"line":109,"address":[24403554],"length":1,"stats":{"Line":1}},{"line":110,"address":[24403691],"length":1,"stats":{"Line":1}},{"line":113,"address":[16841314],"length":1,"stats":{"Line":1}},{"line":116,"address":[16642837,16642704,16642943,16643600,16643641,16644013,16642739],"length":1,"stats":{"Line":5}},{"line":117,"address":[16710898,16711645,16711080,16710814,16711826,16711214,16711284,16711024,16711544],"length":1,"stats":{"Line":8}},{"line":118,"address":[16746005,16746045],"length":1,"stats":{"Line":2}},{"line":119,"address":[16747613,16747827,16747701,16748137],"length":1,"stats":{"Line":2}},{"line":120,"address":[16742251,16742331],"length":1,"stats":{"Line":2}},{"line":121,"address":[16704179,16704227,16704410,16704321,16703925],"length":1,"stats":{"Line":2}},{"line":122,"address":[16636521,16637042,16636575,16635888,16636697,16636856],"length":1,"stats":{"Line":4}},{"line":124,"address":[24405195],"length":1,"stats":{"Line":1}},{"line":127,"address":[16845277,16843674,16843424,16843459,16844193,16843562],"length":1,"stats":{"Line":0}},{"line":132,"address":[16637513,16637831,16638362,16637592,16639524,16637726,16638156,16638058],"length":1,"stats":{"Line":0}},{"line":133,"address":[13311383],"length":1,"stats":{"Line":0}},{"line":134,"address":[16743576],"length":1,"stats":{"Line":0}},{"line":135,"address":[16743464,16743803,16743584,16743681],"length":1,"stats":{"Line":0}},{"line":136,"address":[12015332],"length":1,"stats":{"Line":0}},{"line":138,"address":[16645266,16645421],"length":1,"stats":{"Line":0}},{"line":139,"address":[16631798,16631687,16631933,16631981],"length":1,"stats":{"Line":0}},{"line":140,"address":[16744717,16745173,16744966],"length":1,"stats":{"Line":0}},{"line":141,"address":[16749055],"length":1,"stats":{"Line":0}},{"line":144,"address":[16744771],"length":1,"stats":{"Line":0}},{"line":147,"address":[16845859,16846074,16845824,16845962,16847634,16846550],"length":1,"stats":{"Line":0}},{"line":148,"address":[13313884,13314209,13314391,13313621,13315497,13313692,13314099,13313787],"length":1,"stats":{"Line":0}},{"line":149,"address":[16633232],"length":1,"stats":{"Line":0}},{"line":150,"address":[16640024,16640118,16639944,16640240],"length":1,"stats":{"Line":0}},{"line":151,"address":[19668932],"length":1,"stats":{"Line":0}},{"line":153,"address":[24408994,24408839],"length":1,"stats":{"Line":0}},{"line":154,"address":[16750684,16750930,16750795,16750978],"length":1,"stats":{"Line":0}},{"line":155,"address":[13314798,13315063,13315246],"length":1,"stats":{"Line":0}},{"line":156,"address":[24409748],"length":1,"stats":{"Line":0}},{"line":159,"address":[16709016],"length":1,"stats":{"Line":0}},{"line":162,"address":[16635104,16635348,16639188,16636489,16635151,16635464,16636866,16638966,16635688],"length":1,"stats":{"Line":4}},{"line":168,"address":[16752279,16752414],"length":1,"stats":{"Line":2}},{"line":169,"address":[16642645,16642561],"length":1,"stats":{"Line":1}},{"line":177,"address":[16649641],"length":1,"stats":{"Line":1}},{"line":178,"address":[16748667],"length":1,"stats":{"Line":1}},{"line":180,"address":[16636452,16635998],"length":1,"stats":{"Line":2}},{"line":181,"address":[16752732],"length":1,"stats":{"Line":1}},{"line":182,"address":[16710798],"length":1,"stats":{"Line":1}},{"line":183,"address":[16748941],"length":1,"stats":{"Line":1}},{"line":184,"address":[24411248],"length":1,"stats":{"Line":1}},{"line":185,"address":[16710895],"length":1,"stats":{"Line":1}},{"line":186,"address":[16710930],"length":1,"stats":{"Line":1}},{"line":187,"address":[16711001],"length":1,"stats":{"Line":1}},{"line":190,"address":[16649887],"length":1,"stats":{"Line":1}},{"line":191,"address":[13316846],"length":1,"stats":{"Line":1}},{"line":193,"address":[16636898,16637347,16636780,16639183,16635378,16636528],"length":1,"stats":{"Line":3}},{"line":195,"address":[16755568],"length":1,"stats":{"Line":1}},{"line":196,"address":[16850545,16850623],"length":1,"stats":{"Line":2}},{"line":198,"address":[16651425,16651337],"length":1,"stats":{"Line":2}},{"line":199,"address":[24412753],"length":1,"stats":{"Line":1}},{"line":200,"address":[16754630,16754505,16754839],"length":1,"stats":{"Line":2}},{"line":201,"address":[16712737],"length":1,"stats":{"Line":1}},{"line":207,"address":[16850819,16851541],"length":1,"stats":{"Line":2}},{"line":208,"address":[16755236,16755212],"length":1,"stats":{"Line":2}},{"line":209,"address":[16755238,16756258,16756080,16755504],"length":1,"stats":{"Line":3}},{"line":210,"address":[16757813],"length":1,"stats":{"Line":1}},{"line":211,"address":[16752175],"length":1,"stats":{"Line":1}},{"line":212,"address":[16852569],"length":1,"stats":{"Line":1}},{"line":214,"address":[16653326],"length":1,"stats":{"Line":0}},{"line":217,"address":[16755218],"length":1,"stats":{"Line":1}},{"line":220,"address":[16638698],"length":1,"stats":{"Line":1}},{"line":221,"address":[13318878],"length":1,"stats":{"Line":1}},{"line":222,"address":[13318910],"length":1,"stats":{"Line":1}}],"covered":95,"coverable":126},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","queries.rs"],"content":"﻿pub(super) const INSERT_BOOKMARK: &str = r#\"\n    INSERT INTO bookmarks (id, user_pubkey, post_id, created_at)\n    VALUES (?1, ?2, ?3, ?4)\n    ON CONFLICT(user_pubkey, post_id) DO NOTHING\n\"#;\n\npub(super) const DELETE_BOOKMARK: &str = r#\"\n    DELETE FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARK_BY_USER_AND_POST: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARKS_BY_USER: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const INSERT_DIRECT_MESSAGE: &str = r#\"\n    INSERT INTO direct_messages (\n        owner_npub,\n        conversation_npub,\n        sender_npub,\n        recipient_npub,\n        event_id,\n        client_message_id,\n        payload_cipher_base64,\n        created_at,\n        delivered,\n        direction\n    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\n\"#;\n\npub(super) const MARK_DIRECT_MESSAGE_DELIVERED_BY_CLIENT_ID: &str = r#\"\n    UPDATE direct_messages\n    SET delivered = ?4,\n        event_id = COALESCE(?3, event_id)\n    WHERE owner_npub = ?1\n      AND client_message_id = ?2\n\"#;\n\npub(super) const SELECT_DIRECT_MESSAGE_BY_ID: &str = r#\"\n    SELECT id,\n           owner_npub,\n           conversation_npub,\n           sender_npub,\n           recipient_npub,\n           event_id,\n           client_message_id,\n           payload_cipher_base64,\n           created_at,\n           delivered,\n           direction\n    FROM direct_messages\n    WHERE id = ?1\n\"#;\n\npub(super) const UPDATE_DM_CONVERSATION_LAST_MESSAGE: &str = r#\"\n    UPDATE direct_message_conversations\n    SET last_message_id = ?3,\n        last_message_created_at = ?4\n    WHERE owner_npub = ?1 AND conversation_npub = ?2\n\"#;\n\npub(super) const INSERT_DM_CONVERSATION: &str = r#\"\n    INSERT INTO direct_message_conversations (\n        owner_npub,\n        conversation_npub,\n        last_message_id,\n        last_message_created_at,\n        last_read_at\n    ) VALUES (?1, ?2, ?3, ?4, ?5)\n\"#;\n\npub(super) const MARK_DM_CONVERSATION_READ: &str = r#\"\n    UPDATE direct_message_conversations\n    SET last_read_at = MAX(last_read_at, ?3)\n    WHERE owner_npub = ?1 AND conversation_npub = ?2\n\"#;\n\npub(super) const INSERT_POST_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at)\n    VALUES (?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_POST_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE event_id = ? AND kind = 1\n\"#;\n\npub(super) const SELECT_POSTS_BY_TOPIC: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND tags LIKE '%' || ? || '%'\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const UPDATE_POST_CONTENT: &str = r#\"\n    UPDATE events\n    SET content = ?, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const MARK_POST_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND (sync_status IS NULL OR sync_status = 0)\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_POST_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, sync_event_id = ?, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_POSTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1 AND public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_RECENT_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const INSERT_TOPIC: &str = r#\"\n    INSERT INTO topics (topic_id, name, description, created_at, updated_at, visibility)\n    VALUES (?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const INSERT_PENDING_TOPIC: &str = r#\"\n    INSERT INTO topics_pending (\n        pending_id,\n        user_pubkey,\n        name,\n        description,\n        status,\n        offline_action_id,\n        synced_topic_id,\n        error_message,\n        created_at,\n        updated_at\n    ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)\n\"#;\n\npub(super) const SELECT_TOPIC_BY_ID: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count, visibility\n    FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const SELECT_ALL_TOPICS: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count, visibility\n    FROM topics\n    ORDER BY created_at ASC\n\"#;\n\npub(super) const SELECT_PENDING_TOPIC_BY_ID: &str = r#\"\n    SELECT pending_id,\n           user_pubkey,\n           name,\n           description,\n           status,\n           offline_action_id,\n           synced_topic_id,\n           error_message,\n           created_at,\n           updated_at\n    FROM topics_pending\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const SELECT_PENDING_TOPICS_BY_USER: &str = r#\"\n    SELECT pending_id,\n           user_pubkey,\n           name,\n           description,\n           status,\n           offline_action_id,\n           synced_topic_id,\n           error_message,\n           created_at,\n           updated_at\n    FROM topics_pending\n    WHERE user_pubkey = ?1\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const UPDATE_PENDING_TOPIC_STATUS: &str = r#\"\n    UPDATE topics_pending\n    SET status = ?2,\n        synced_topic_id = ?3,\n        error_message = ?4,\n        updated_at = ?5\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const DELETE_PENDING_TOPIC: &str = r#\"\n    DELETE FROM topics_pending\n    WHERE pending_id = ?1\n\"#;\n\npub(super) const SELECT_JOINED_TOPICS: &str = r#\"\n    SELECT t.topic_id, t.name, t.description, t.created_at, t.updated_at, t.member_count, t.post_count, t.visibility\n    FROM topics t\n    INNER JOIN user_topics ut ON t.topic_id = ut.topic_id\n    WHERE ut.is_joined = 1 AND ut.user_pubkey = ?\n    ORDER BY t.created_at ASC\n\"#;\n\npub(super) const UPDATE_TOPIC: &str = r#\"\n    UPDATE topics\n    SET name = ?, description = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_USER_TOPICS_BY_TOPIC: &str = r#\"\n    DELETE FROM user_topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_TOPIC: &str = r#\"\n    DELETE FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const UPSERT_USER_TOPIC: &str = r#\"\n    INSERT INTO user_topics (topic_id, user_pubkey, is_joined, joined_at, left_at)\n    VALUES (?1, ?2, 1, ?3, NULL)\n    ON CONFLICT(topic_id, user_pubkey) DO UPDATE SET\n        is_joined = 1,\n        joined_at = excluded.joined_at,\n        left_at = NULL\n\"#;\n\npub(super) const SELECT_TOPIC_MEMBER_COUNT: &str = r#\"\n    SELECT COUNT(*) as count\n    FROM user_topics\n    WHERE topic_id = ?1 AND is_joined = 1\n\"#;\n\npub(super) const UPDATE_TOPIC_MEMBER_COUNT: &str = r#\"\n    UPDATE topics\n    SET member_count = ?1, updated_at = ?2\n    WHERE topic_id = ?3\n\"#;\n\npub(super) const MARK_TOPIC_LEFT: &str = r#\"\n    UPDATE user_topics\n    SET is_joined = 0, left_at = ?1\n    WHERE topic_id = ?2 AND user_pubkey = ?3\n\"#;\n\npub(super) const UPDATE_TOPIC_STATS: &str = r#\"\n    UPDATE topics\n    SET member_count = ?, post_count = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const UPSERT_TOPIC_METRICS: &str = r#\"\n    INSERT INTO topic_metrics (\n        topic_id,\n        window_start,\n        window_end,\n        posts_24h,\n        posts_6h,\n        unique_authors,\n        boosts,\n        replies,\n        bookmarks,\n        participant_delta,\n        score_24h,\n        score_6h,\n        updated_at\n    ) VALUES (\n        ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13\n    )\n    ON CONFLICT(topic_id, window_start) DO UPDATE SET\n        window_end = excluded.window_end,\n        posts_24h = excluded.posts_24h,\n        posts_6h = excluded.posts_6h,\n        unique_authors = excluded.unique_authors,\n        boosts = excluded.boosts,\n        replies = excluded.replies,\n        bookmarks = excluded.bookmarks,\n        participant_delta = excluded.participant_delta,\n        score_24h = excluded.score_24h,\n        score_6h = excluded.score_6h,\n        updated_at = excluded.updated_at\n\"#;\n\npub(super) const CLEANUP_TOPIC_METRICS: &str = r#\"\n    DELETE FROM topic_metrics\n    WHERE window_end < ?1\n\"#;\n\npub(super) const COLLECT_TOPIC_ACTIVITY: &str = r#\"\n    SELECT\n        et.topic_id AS topic_id,\n        COUNT(DISTINCT e.event_id) AS posts_count,\n        COUNT(DISTINCT e.public_key) AS unique_authors,\n        0 AS boosts,\n        0 AS replies,\n        0 AS bookmarks,\n        0 AS participant_delta\n    FROM event_topics et\n    INNER JOIN events e ON e.event_id = et.event_id\n    WHERE e.kind = 1\n      AND e.deleted = 0\n      AND e.created_at >= ?1\n      AND e.created_at < ?2\n    GROUP BY et.topic_id\n\"#;\n\npub(super) const SELECT_LATEST_METRICS_WINDOW_END: &str = r#\"\n    SELECT MAX(window_end) as window_end\n    FROM topic_metrics\n\"#;\n\npub(super) const SELECT_METRICS_BY_WINDOW: &str = r#\"\n    SELECT\n        topic_id,\n        window_start,\n        window_end,\n        posts_24h,\n        posts_6h,\n        unique_authors,\n        boosts,\n        replies,\n        bookmarks,\n        participant_delta,\n        score_24h,\n        score_6h,\n        updated_at\n    FROM topic_metrics\n    WHERE window_end = ?1\n    ORDER BY score_24h DESC, score_6h DESC, posts_24h DESC, topic_id ASC\n    LIMIT ?2\n\"#;\n\npub(super) const INSERT_USER: &str = r#\"\n    INSERT INTO users (\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    )\n    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_USER_BY_NPUB: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_USER_BY_PUBKEY: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE pubkey = ?\n\"#;\n\npub(super) const SEARCH_USERS: &str = r#\"\n    SELECT\n        npub,\n        pubkey,\n        display_name,\n        bio,\n        avatar_url,\n        is_profile_public,\n        show_online_status,\n        created_at,\n        updated_at\n    FROM users\n    WHERE display_name LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR npub LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR pubkey LIKE '%' || ?1 || '%' COLLATE NOCASE\n       OR bio LIKE '%' || ?1 || '%' COLLATE NOCASE\n    ORDER BY updated_at DESC\n    LIMIT ?2\n\"#;\n\npub(super) const UPDATE_USER: &str = r#\"\n    UPDATE users\n    SET\n        display_name = ?,\n        bio = ?,\n        avatar_url = ?,\n        is_profile_public = ?,\n        show_online_status = ?,\n        updated_at = ?\n    WHERE npub = ?\n\"#;\n\npub(super) const DELETE_USER: &str = r#\"\n    DELETE FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_FOLLOWING_PUBKEYS: &str = r#\"\n    SELECT followed_pubkey\n    FROM follows\n    WHERE follower_pubkey = ?1\n\"#;\n\npub(super) const SELECT_FOLLOWER_PUBKEYS: &str = r#\"\n    SELECT follower_pubkey\n    FROM follows\n    WHERE followed_pubkey = ?1\n\"#;\n\npub(super) const UPSERT_FOLLOW_RELATION: &str = r#\"\n    INSERT INTO follows (follower_pubkey, followed_pubkey)\n    VALUES (?1, ?2)\n    ON CONFLICT(follower_pubkey, followed_pubkey) DO NOTHING\n\"#;\n\npub(super) const DELETE_FOLLOW_RELATION: &str = r#\"\n    DELETE FROM follows\n    WHERE follower_pubkey = ?1 AND followed_pubkey = ?2\n\"#;\n\npub(super) const INSERT_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at, sig)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_EVENT_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_KIND: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE kind = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const MARK_EVENT_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_EVENTS: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE sync_status IS NULL OR sync_status = 0\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_EVENT_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const INSERT_EVENT_TOPIC: &str = r#\"\n    INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at)\n    VALUES (?1, ?2, ?3)\n\"#;\n\npub(super) const SELECT_EVENT_TOPICS: &str = r#\"\n    SELECT topic_id FROM event_topics WHERE event_id = ?1\n\"#;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","topic_metrics.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    CLEANUP_TOPIC_METRICS, COLLECT_TOPIC_ACTIVITY, SELECT_LATEST_METRICS_WINDOW_END,\n    SELECT_METRICS_BY_WINDOW, UPSERT_TOPIC_METRICS,\n};\nuse crate::application::ports::repositories::TopicMetricsRepository;\nuse crate::domain::entities::{\n    MetricsWindow, TopicActivityRow, TopicMetricsRecord, TopicMetricsSnapshot, TopicMetricsUpsert,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse sqlx::FromRow;\n\n#[derive(Debug, FromRow)]\nstruct DbTopicActivityRow {\n    topic_id: String,\n    posts_count: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n}\n\n#[derive(Debug, FromRow)]\nstruct DbTopicMetricsRow {\n    topic_id: String,\n    window_start: i64,\n    window_end: i64,\n    posts_24h: i64,\n    posts_6h: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n    score_24h: f64,\n    score_6h: f64,\n    updated_at: i64,\n}\n\nimpl From<DbTopicMetricsRow> for TopicMetricsRecord {\n    fn from(value: DbTopicMetricsRow) -> Self {\n        Self {\n            topic_id: value.topic_id,\n            window_start: value.window_start,\n            window_end: value.window_end,\n            posts_24h: value.posts_24h,\n            posts_6h: value.posts_6h,\n            unique_authors: value.unique_authors,\n            boosts: value.boosts,\n            replies: value.replies,\n            bookmarks: value.bookmarks,\n            participant_delta: value.participant_delta,\n            score_24h: value.score_24h,\n            score_6h: value.score_6h,\n            updated_at: value.updated_at,\n        }\n    }\n}\n\n#[async_trait]\nimpl TopicMetricsRepository for SqliteRepository {\n    async fn upsert_metrics(&self, metrics: TopicMetricsUpsert) -> Result<(), AppError> {\n        sqlx::query(UPSERT_TOPIC_METRICS)\n            .bind(&metrics.topic_id)\n            .bind(metrics.window_start)\n            .bind(metrics.window_end)\n            .bind(metrics.posts_24h)\n            .bind(metrics.posts_6h)\n            .bind(metrics.unique_authors)\n            .bind(metrics.boosts)\n            .bind(metrics.replies)\n            .bind(metrics.bookmarks)\n            .bind(metrics.participant_delta)\n            .bind(metrics.score_24h)\n            .bind(metrics.score_6h)\n            .bind(metrics.updated_at)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn cleanup_expired(&self, cutoff_millis: i64) -> Result<u64, AppError> {\n        let result = sqlx::query(CLEANUP_TOPIC_METRICS)\n            .bind(cutoff_millis)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected())\n    }\n\n    async fn collect_activity(\n        &self,\n        window: MetricsWindow,\n    ) -> Result<Vec<TopicActivityRow>, AppError> {\n        let rows: Vec<DbTopicActivityRow> = sqlx::query_as(COLLECT_TOPIC_ACTIVITY)\n            .bind(window.start)\n            .bind(window.end)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut activities = Vec::with_capacity(rows.len());\n        for row in rows {\n            activities.push(TopicActivityRow {\n                topic_id: row.topic_id,\n                posts_count: row.posts_count,\n                unique_authors: row.unique_authors,\n                boosts: row.boosts,\n                replies: row.replies,\n                bookmarks: row.bookmarks,\n                participant_delta: row.participant_delta,\n            });\n        }\n\n        Ok(activities)\n    }\n\n    async fn latest_window_end(&self) -> Result<Option<i64>, AppError> {\n        let result: Option<(i64,)> = sqlx::query_as(SELECT_LATEST_METRICS_WINDOW_END)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n        Ok(result.map(|row| row.0))\n    }\n\n    async fn list_recent_metrics(\n        &self,\n        limit: usize,\n    ) -> Result<Option<TopicMetricsSnapshot>, AppError> {\n        let Some(window_end) = self.latest_window_end().await? else {\n            return Ok(None);\n        };\n\n        let fetch_limit = if limit == 0 { 1 } else { limit }.min(i64::MAX as usize);\n        let rows: Vec<DbTopicMetricsRow> = sqlx::query_as(SELECT_METRICS_BY_WINDOW)\n            .bind(window_end)\n            .bind(fetch_limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        if rows.is_empty() {\n            return Ok(Some(TopicMetricsSnapshot {\n                window_start: window_end,\n                window_end,\n                metrics: Vec::new(),\n            }));\n        }\n\n        let window_start = rows\n            .first()\n            .map(|row| row.window_start)\n            .unwrap_or(window_end);\n\n        let metrics = if limit == 0 {\n            Vec::new()\n        } else {\n            rows.into_iter()\n                .take(limit)\n                .map(TopicMetricsRecord::from)\n                .collect()\n        };\n\n        Ok(Some(TopicMetricsSnapshot {\n            window_start,\n            window_end,\n            metrics,\n        }))\n    }\n}\n","traces":[{"line":43,"address":[12744592],"length":1,"stats":{"Line":0}},{"line":45,"address":[20401293],"length":1,"stats":{"Line":0}},{"line":46,"address":[20401319],"length":1,"stats":{"Line":0}},{"line":47,"address":[12707867],"length":1,"stats":{"Line":0}},{"line":48,"address":[12700943],"length":1,"stats":{"Line":0}},{"line":49,"address":[12700947],"length":1,"stats":{"Line":0}},{"line":50,"address":[12839431],"length":1,"stats":{"Line":0}},{"line":51,"address":[12839435],"length":1,"stats":{"Line":0}},{"line":52,"address":[12707887],"length":1,"stats":{"Line":0}},{"line":53,"address":[23921075],"length":1,"stats":{"Line":0}},{"line":54,"address":[12744663],"length":1,"stats":{"Line":0}},{"line":55,"address":[12700971],"length":1,"stats":{"Line":0}},{"line":56,"address":[12707904],"length":1,"stats":{"Line":0}},{"line":57,"address":[20401365],"length":1,"stats":{"Line":0}},{"line":64,"address":[12943407],"length":1,"stats":{"Line":0}},{"line":65,"address":[24916859,24916172,24916445,24916563,24916603,24916211,24916406,24916484,24916328,24917093,24916523,24916744,24916367,24916250,24916642,24917197,24916289,24916097,24917415],"length":1,"stats":{"Line":0}},{"line":66,"address":[19450127],"length":1,"stats":{"Line":0}},{"line":67,"address":[24821415],"length":1,"stats":{"Line":0}},{"line":68,"address":[24716926],"length":1,"stats":{"Line":0}},{"line":69,"address":[24716965],"length":1,"stats":{"Line":0}},{"line":70,"address":[24916316],"length":1,"stats":{"Line":0}},{"line":71,"address":[18957587],"length":1,"stats":{"Line":0}},{"line":72,"address":[24703322],"length":1,"stats":{"Line":0}},{"line":73,"address":[24703361],"length":1,"stats":{"Line":0}},{"line":74,"address":[24820040],"length":1,"stats":{"Line":0}},{"line":75,"address":[24778031],"length":1,"stats":{"Line":0}},{"line":76,"address":[24784998],"length":1,"stats":{"Line":0}},{"line":77,"address":[24710302],"length":1,"stats":{"Line":0}},{"line":78,"address":[24778194,24778150],"length":1,"stats":{"Line":0}},{"line":79,"address":[24821995,24821898,24822132,24821344],"length":1,"stats":{"Line":0}},{"line":80,"address":[12029249],"length":1,"stats":{"Line":0}},{"line":82,"address":[24778811],"length":1,"stats":{"Line":0}},{"line":85,"address":[24711312,24711546,24711984,24711347,24711434,24712498],"length":1,"stats":{"Line":0}},{"line":86,"address":[24786576,24786409,24786873,24786477,24787153,24786971,24787239,24786646],"length":1,"stats":{"Line":0}},{"line":87,"address":[24817693],"length":1,"stats":{"Line":0}},{"line":88,"address":[24711781,24711704,24711962,24711875],"length":1,"stats":{"Line":0}},{"line":89,"address":[24719161,24719345,24718437,24718859,24719001,24718913],"length":1,"stats":{"Line":0}},{"line":91,"address":[24822201,24822312],"length":1,"stats":{"Line":0}},{"line":94,"address":[24918800,24918835,24919045,24920904,24918933,24919579,24920864],"length":1,"stats":{"Line":0}},{"line":98,"address":[24720088,24720193,24720420,24720726,24720521,24719954,24719883],"length":1,"stats":{"Line":0}},{"line":100,"address":[24824546],"length":1,"stats":{"Line":0}},{"line":101,"address":[24706154,24706363,24706266,24706485],"length":1,"stats":{"Line":0}},{"line":102,"address":[24705888,24706708,24706918,24706460,24706548,24706371],"length":1,"stats":{"Line":0}},{"line":104,"address":[24819752,24819599],"length":1,"stats":{"Line":0}},{"line":105,"address":[19454057,19453954,19454184,19454237],"length":1,"stats":{"Line":0}},{"line":106,"address":[24714321,24714581],"length":1,"stats":{"Line":0}},{"line":107,"address":[24820161],"length":1,"stats":{"Line":0}},{"line":108,"address":[24714273],"length":1,"stats":{"Line":0}},{"line":109,"address":[24920569],"length":1,"stats":{"Line":0}},{"line":110,"address":[24824145],"length":1,"stats":{"Line":0}},{"line":111,"address":[18961817],"length":1,"stats":{"Line":0}},{"line":112,"address":[24920593],"length":1,"stats":{"Line":0}},{"line":113,"address":[19454389],"length":1,"stats":{"Line":0}},{"line":117,"address":[24707654],"length":1,"stats":{"Line":0}},{"line":120,"address":[24789482,24789395,24789978,24790486,24789360,24789594],"length":1,"stats":{"Line":0}},{"line":121,"address":[24825251,24825512,24824887,24825349,24824954,24824819,24825611,24825024],"length":1,"stats":{"Line":0}},{"line":122,"address":[24821053,24821140,24820959,24820914],"length":1,"stats":{"Line":0}},{"line":123,"address":[24722117,24722259,24722419,24722584,24721749,24722171],"length":1,"stats":{"Line":0}},{"line":124,"address":[24821680,24821688,24821507,24821620],"length":1,"stats":{"Line":0}},{"line":127,"address":[18963606,18963461,18963343,18963860,18964880,18963296,18966043],"length":1,"stats":{"Line":0}},{"line":131,"address":[12032863],"length":1,"stats":{"Line":0}},{"line":132,"address":[24828314],"length":1,"stats":{"Line":0}},{"line":135,"address":[19456887,19456805],"length":1,"stats":{"Line":0}},{"line":136,"address":[24823200,24824687,24822954,24822876,24823409,24823728,24823523,24823095],"length":1,"stats":{"Line":0}},{"line":137,"address":[24828526],"length":1,"stats":{"Line":0}},{"line":138,"address":[18964613],"length":1,"stats":{"Line":0}},{"line":139,"address":[24923275,24923498,24923626,24923389],"length":1,"stats":{"Line":0}},{"line":140,"address":[12028946],"length":1,"stats":{"Line":0}},{"line":142,"address":[24792626,24792473],"length":1,"stats":{"Line":0}},{"line":143,"address":[24793293],"length":1,"stats":{"Line":0}},{"line":144,"address":[24724901],"length":1,"stats":{"Line":0}},{"line":146,"address":[19457907],"length":1,"stats":{"Line":0}},{"line":150,"address":[24829547,24829400,24829483],"length":1,"stats":{"Line":0}},{"line":152,"address":[24725765,24725760],"length":1,"stats":{"Line":0}},{"line":153,"address":[24924319],"length":1,"stats":{"Line":0}},{"line":155,"address":[24829576],"length":1,"stats":{"Line":0}},{"line":156,"address":[24824096,24824007],"length":1,"stats":{"Line":0}},{"line":158,"address":[18965923,18965626],"length":1,"stats":{"Line":0}},{"line":159,"address":[24786199],"length":1,"stats":{"Line":0}},{"line":164,"address":[24718243],"length":1,"stats":{"Line":0}},{"line":166,"address":[24792919],"length":1,"stats":{"Line":0}},{"line":167,"address":[24718195],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":82},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","topics.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::{map_joined_topic_row, map_topic_row};\nuse super::queries::{\n    DELETE_TOPIC, DELETE_USER_TOPICS_BY_TOPIC, INSERT_TOPIC, MARK_TOPIC_LEFT, SELECT_ALL_TOPICS,\n    SELECT_JOINED_TOPICS, SELECT_TOPIC_BY_ID, SELECT_TOPIC_MEMBER_COUNT, UPDATE_TOPIC,\n    UPDATE_TOPIC_MEMBER_COUNT, UPDATE_TOPIC_STATS, UPSERT_USER_TOPIC,\n};\nuse crate::application::ports::repositories::TopicRepository;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::Topic;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl TopicRepository for SqliteRepository {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(INSERT_TOPIC)\n            .bind(&topic.id)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.created_at.timestamp_millis())\n            .bind(topic.updated_at.timestamp_millis())\n            .bind(topic.visibility.as_str())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        let row = sqlx::query(SELECT_TOPIC_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_topic_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_ALL_TOPICS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_JOINED_TOPICS)\n            .bind(user_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_joined_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.updated_at.timestamp_millis())\n            .bind(&topic.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        if id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"デフォルトトピックは削除できません\".into());\n        }\n\n        sqlx::query(DELETE_USER_TOPICS_BY_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        sqlx::query(DELETE_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(UPSERT_USER_TOPIC)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .bind(now)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        if topic_id == DEFAULT_PUBLIC_TOPIC_ID {\n            return Err(\"デフォルトトピックから離脱することはできません\".into());\n        }\n\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(MARK_TOPIC_LEFT)\n            .bind(now)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn update_topic_stats(\n        &self,\n        id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC_STATS)\n            .bind(member_count as i64)\n            .bind(post_count as i64)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[19952467,19951331,19951296,19952556,19951554,19952926,19951442],"length":1,"stats":{"Line":0}},{"line":19,"address":[19982918,19982958,19983494,19983237,19983982,19984163,19983564,19983884,19983108,19982843,19982998,19983376],"length":1,"stats":{"Line":0}},{"line":20,"address":[19982909],"length":1,"stats":{"Line":0}},{"line":21,"address":[19870241],"length":1,"stats":{"Line":0}},{"line":22,"address":[18314913,18314877],"length":1,"stats":{"Line":0}},{"line":23,"address":[19870439,19871014,19870329,19870170],"length":1,"stats":{"Line":0}},{"line":24,"address":[19877769,19877352,19877239],"length":1,"stats":{"Line":0}},{"line":25,"address":[19877740,19877368,19877496],"length":1,"stats":{"Line":0}},{"line":26,"address":[19952248,19952345,19952435],"length":1,"stats":{"Line":0}},{"line":27,"address":[19951469,19952588,19952353,19952748,19952931,19952407],"length":1,"stats":{"Line":0}},{"line":29,"address":[19885132],"length":1,"stats":{"Line":0}},{"line":32,"address":[19946358,19947545,19946246,19946820,19946096,19946131],"length":1,"stats":{"Line":0}},{"line":33,"address":[19988590,19989021,19989129,19988511,19989413,19990030,19988794,19988689],"length":1,"stats":{"Line":0}},{"line":34,"address":[19878766,19878721],"length":1,"stats":{"Line":0}},{"line":35,"address":[19953510,19953726,19953604,19953422],"length":1,"stats":{"Line":0}},{"line":36,"address":[12002900],"length":1,"stats":{"Line":0}},{"line":38,"address":[14126995],"length":1,"stats":{"Line":0}},{"line":39,"address":[19954842,19954376,19954478],"length":1,"stats":{"Line":0}},{"line":40,"address":[19991098],"length":1,"stats":{"Line":0}},{"line":44,"address":[12938361],"length":1,"stats":{"Line":0}},{"line":45,"address":[19873747,19874521,19874217,19874315,19873885,19873990,19875666,19873818],"length":1,"stats":{"Line":0}},{"line":46,"address":[14128082,14128346,14128130,14128224],"length":1,"stats":{"Line":0}},{"line":47,"address":[19991845,19992761,19992216,19992305,19992393,19992553],"length":1,"stats":{"Line":0}},{"line":49,"address":[19987153,19987308],"length":1,"stats":{"Line":0}},{"line":50,"address":[19993029,19993212,19992918,19993164],"length":1,"stats":{"Line":0}},{"line":51,"address":[19993683,19993260,19993465],"length":1,"stats":{"Line":0}},{"line":52,"address":[14129645],"length":1,"stats":{"Line":0}},{"line":55,"address":[19991622],"length":1,"stats":{"Line":0}},{"line":58,"address":[12900313],"length":1,"stats":{"Line":0}},{"line":59,"address":[20089390,20089617,20089921,20089186,20089285,20089715,20091066,20089107],"length":1,"stats":{"Line":0}},{"line":60,"address":[19988805,19988850],"length":1,"stats":{"Line":0}},{"line":61,"address":[20089138,20089226,20089320,20089442],"length":1,"stats":{"Line":0}},{"line":62,"address":[12017508],"length":1,"stats":{"Line":0}},{"line":64,"address":[19951524,19951369],"length":1,"stats":{"Line":0}},{"line":65,"address":[19958478,19958772,19958589,19958724],"length":1,"stats":{"Line":0}},{"line":66,"address":[19877505,19877723,19877300],"length":1,"stats":{"Line":0}},{"line":67,"address":[19995957],"length":1,"stats":{"Line":0}},{"line":70,"address":[19993950],"length":1,"stats":{"Line":0}},{"line":73,"address":[19994675,19994770,19995545,19994640,19995576,19994876,19995945],"length":1,"stats":{"Line":0}},{"line":74,"address":[19892385,19892839,19893118,19892101,19892589,19892937,19892220,19892519,19892180,19892333],"length":1,"stats":{"Line":0}},{"line":75,"address":[20091479],"length":1,"stats":{"Line":0}},{"line":76,"address":[19885231,19885271],"length":1,"stats":{"Line":0}},{"line":77,"address":[19885392,19885698,19885279,19885156],"length":1,"stats":{"Line":0}},{"line":78,"address":[18322940,18323012],"length":1,"stats":{"Line":0}},{"line":79,"address":[19885484,19885578,19885436,19885667],"length":1,"stats":{"Line":0}},{"line":80,"address":[19892728,19893070,19892562,19891917,19892616,19892887],"length":1,"stats":{"Line":0}},{"line":82,"address":[19960791],"length":1,"stats":{"Line":0}},{"line":85,"address":[17230511],"length":1,"stats":{"Line":0}},{"line":86,"address":[20092830],"length":1,"stats":{"Line":0}},{"line":87,"address":[19992534,19992882],"length":1,"stats":{"Line":0}},{"line":90,"address":[19998207,19998087,19998739,19998912,19998641,19999243,19998310,19998380],"length":1,"stats":{"Line":0}},{"line":91,"address":[19998194,19998234],"length":1,"stats":{"Line":0}},{"line":92,"address":[18324151,18324411,18324234,18324329],"length":1,"stats":{"Line":0}},{"line":93,"address":[19893325,19893879,19893825,19894336,19894001,19894161],"length":1,"stats":{"Line":0}},{"line":95,"address":[19997711,19997185,19997452,19997522,19997349,19997809,19997990],"length":1,"stats":{"Line":0}},{"line":96,"address":[19997376,19997336],"length":1,"stats":{"Line":0}},{"line":97,"address":[19993637,19993448,19993365,19993551],"length":1,"stats":{"Line":0}},{"line":98,"address":[19955711,19955501,19955894,19955552,19954175,19955447],"length":1,"stats":{"Line":0}},{"line":100,"address":[19962783],"length":1,"stats":{"Line":0}},{"line":103,"address":[12907487],"length":1,"stats":{"Line":0}},{"line":104,"address":[19881889],"length":1,"stats":{"Line":0}},{"line":105,"address":[11969999],"length":1,"stats":{"Line":0}},{"line":107,"address":[20095698,20096510,20095864,20096683,20097042,20096055,20095907,20096403,20095946,20096170],"length":1,"stats":{"Line":0}},{"line":108,"address":[14137081],"length":1,"stats":{"Line":0}},{"line":109,"address":[19964339],"length":1,"stats":{"Line":0}},{"line":110,"address":[19896661,19896622],"length":1,"stats":{"Line":0}},{"line":111,"address":[20001306,20001447,20001030,20001197],"length":1,"stats":{"Line":0}},{"line":112,"address":[12006786],"length":1,"stats":{"Line":0}},{"line":114,"address":[20000338,20000447,20000857,20001304,20001787,20000517,20000172,20001073,20000750,20001154],"length":1,"stats":{"Line":0}},{"line":115,"address":[19883725,19883683],"length":1,"stats":{"Line":0}},{"line":116,"address":[19958530,19958434,19958240,19958325],"length":1,"stats":{"Line":0}},{"line":117,"address":[11888520],"length":1,"stats":{"Line":0}},{"line":120,"address":[18329772,18329177,18328846,18329412,18328998,18329107,18328917,18329890,18328956,18329519],"length":1,"stats":{"Line":0}},{"line":122,"address":[20001439],"length":1,"stats":{"Line":0}},{"line":123,"address":[20001478,20001520],"length":1,"stats":{"Line":0}},{"line":124,"address":[20001733,20001528,20001372,20001637],"length":1,"stats":{"Line":0}},{"line":125,"address":[19895422,19899075,19899339,19898912,19898765,19898825],"length":1,"stats":{"Line":0}},{"line":127,"address":[20099161,20098826,20098544,20094752,20098733],"length":1,"stats":{"Line":0}},{"line":128,"address":[19967558],"length":1,"stats":{"Line":0}},{"line":131,"address":[12944367],"length":1,"stats":{"Line":0}},{"line":132,"address":[20099815],"length":1,"stats":{"Line":0}},{"line":133,"address":[19900562,19900829],"length":1,"stats":{"Line":0}},{"line":136,"address":[14141087,14141147],"length":1,"stats":{"Line":0}},{"line":137,"address":[19961724,19961554,19961051,19962218,19961494,19962758],"length":1,"stats":{"Line":0}},{"line":139,"address":[20101482,20101372,20101139,20102014,20100872,20100667,20100915,20101024,20101655,20100830],"length":1,"stats":{"Line":0}},{"line":140,"address":[19887746],"length":1,"stats":{"Line":0}},{"line":141,"address":[14142089],"length":1,"stats":{"Line":0}},{"line":142,"address":[18331915,18331958],"length":1,"stats":{"Line":0}},{"line":143,"address":[19969507,19969398,19969648,19969231],"length":1,"stats":{"Line":0}},{"line":144,"address":[11889938],"length":1,"stats":{"Line":0}},{"line":146,"address":[20101921,20102264,20101851,20102480,20102711,20102154,20102561,20103194,20101576,20101742],"length":1,"stats":{"Line":0}},{"line":147,"address":[20005337,20005295],"length":1,"stats":{"Line":0}},{"line":148,"address":[20006908,20007102,20006993,20007198],"length":1,"stats":{"Line":0}},{"line":149,"address":[19888882,19888967,19888822,19889130,19886495,19889360],"length":1,"stats":{"Line":0}},{"line":152,"address":[19965319,19964339,19964529,19964834,19964420,19964378,19964944,19964268,19965197,19964599],"length":1,"stats":{"Line":0}},{"line":154,"address":[14144078],"length":1,"stats":{"Line":0}},{"line":155,"address":[20002559,20002517],"length":1,"stats":{"Line":0}},{"line":156,"address":[18334017,18334113,18333908,18333752],"length":1,"stats":{"Line":0}},{"line":157,"address":[12006622],"length":1,"stats":{"Line":0}},{"line":159,"address":[12002708],"length":1,"stats":{"Line":0}},{"line":160,"address":[19972539],"length":1,"stats":{"Line":0}},{"line":163,"address":[12944478],"length":1,"stats":{"Line":0}},{"line":169,"address":[20104916,20104972,20105176,20104755,20105536,20105717,20104790,20105438,20105106,20104673],"length":1,"stats":{"Line":0}},{"line":170,"address":[20104751],"length":1,"stats":{"Line":0}},{"line":171,"address":[19905505,19905474],"length":1,"stats":{"Line":0}},{"line":172,"address":[19966345,19966471,19966782,19966224],"length":1,"stats":{"Line":0}},{"line":173,"address":[19973407,19973487],"length":1,"stats":{"Line":0}},{"line":174,"address":[20104999,20105141,20105231,20104712,20105047],"length":1,"stats":{"Line":0}},{"line":175,"address":[14146381,14146901,14146558,14145677,14146435,14146718],"length":1,"stats":{"Line":0}},{"line":177,"address":[19967150],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":110},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","users.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_user_row;\nuse super::queries::{\n    DELETE_FOLLOW_RELATION, DELETE_USER, INSERT_USER, SEARCH_USERS, SELECT_FOLLOWER_PUBKEYS,\n    SELECT_FOLLOWING_PUBKEYS, SELECT_USER_BY_NPUB, SELECT_USER_BY_PUBKEY, UPDATE_USER,\n    UPSERT_FOLLOW_RELATION,\n};\nuse crate::application::ports::repositories::{FollowListSort, UserCursorPage, UserRepository};\nuse crate::domain::entities::User;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};\nuse sqlx::{QueryBuilder, Row, Sqlite};\n\nconst SORT_KEY_LOWER_EXPR: &str = \"LOWER(COALESCE(NULLIF(TRIM(u.display_name), ''), u.npub))\";\n\nfn encode_follow_cursor(sort: FollowListSort, primary: &str, pubkey: &str) -> String {\n    let encoded_primary = URL_SAFE_NO_PAD.encode(primary.as_bytes());\n    format!(\"{}|{}|{}\", sort.as_str(), encoded_primary, pubkey)\n}\n\nfn decode_follow_cursor(\n    cursor: &str,\n    expected_sort: FollowListSort,\n) -> Result<(String, String), AppError> {\n    let mut parts = cursor.splitn(3, '|');\n    let sort_part = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    if sort_part != expected_sort.as_str() {\n        return Err(AppError::InvalidInput(\"Cursor sort mismatch\".into()));\n    }\n    let primary_encoded = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    let pubkey = parts\n        .next()\n        .ok_or_else(|| AppError::InvalidInput(\"Invalid cursor format\".into()))?;\n    let primary_bytes = URL_SAFE_NO_PAD\n        .decode(primary_encoded.as_bytes())\n        .map_err(|_| AppError::InvalidInput(\"Invalid cursor payload\".into()))?;\n    let primary = String::from_utf8(primary_bytes)\n        .map_err(|_| AppError::InvalidInput(\"Invalid cursor payload\".into()))?;\n    if pubkey.is_empty() {\n        return Err(AppError::InvalidInput(\"Invalid cursor pubkey\".into()));\n    }\n    Ok((primary, pubkey.to_string()))\n}\n\nstruct FollowQueryDescriptor {\n    join_expr: &'static str,\n    filter_column: &'static str,\n    relation_column: &'static str,\n}\n\nasync fn query_follow_relation(\n    repo: &SqliteRepository,\n    npub: &str,\n    cursor: Option<&str>,\n    limit: usize,\n    sort: FollowListSort,\n    search: Option<&str>,\n    descriptor: FollowQueryDescriptor,\n) -> Result<UserCursorPage, AppError> {\n    let limit = limit.clamp(1, 100);\n    let fetch_limit = limit + 1;\n    let normalized_search = search.map(|s| s.to_lowercase());\n\n    let mut builder: QueryBuilder<Sqlite> = QueryBuilder::new(&format!(\n        \"SELECT u.npub, u.pubkey, u.display_name, u.bio, u.avatar_url, u.is_profile_public, u.show_online_status, u.created_at, u.updated_at, \\\n                f.created_at AS relation_created_at, {relation_column} AS relation_pubkey, \\\n                {SORT_KEY_LOWER_EXPR} AS sort_key_normalized \\\n             FROM users u \\\n             INNER JOIN follows f ON u.pubkey = {join_expr} \\\n             WHERE {filter_column} = (SELECT pubkey FROM users WHERE npub = ?)\",\n        relation_column = descriptor.relation_column,\n        join_expr = descriptor.join_expr,\n        filter_column = descriptor.filter_column,\n    ));\n    builder.push_bind(npub);\n\n    let mut count_builder: QueryBuilder<Sqlite> = QueryBuilder::new(&format!(\n        \"SELECT COUNT(*) as total_count \\\n         FROM users u \\\n         INNER JOIN follows f ON u.pubkey = {join_expr} \\\n         WHERE {filter_column} = (SELECT pubkey FROM users WHERE npub = ?)\",\n        join_expr = descriptor.join_expr,\n        filter_column = descriptor.filter_column,\n    ));\n    count_builder.push_bind(npub);\n\n    if let Some(search_value) = normalized_search.as_ref() {\n        let pattern = format!(\"%{search_value}%\");\n        for builder_ref in [&mut builder, &mut count_builder] {\n            builder_ref.push(\" AND (\");\n            builder_ref.push(SORT_KEY_LOWER_EXPR);\n            builder_ref.push(\" LIKE ? OR LOWER(u.npub) LIKE ? OR LOWER(u.pubkey) LIKE ?)\");\n            builder_ref.push_bind(pattern.clone());\n            builder_ref.push_bind(pattern.clone());\n            builder_ref.push_bind(pattern.clone());\n        }\n    }\n\n    if let Some(cursor_str) = cursor {\n        let (primary_str, cursor_pubkey) = decode_follow_cursor(cursor_str, sort)?;\n        match sort {\n            FollowListSort::Recent => {\n                let timestamp = primary_str\n                    .parse::<i64>()\n                    .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\n                builder.push(format!(\n                    \" AND (f.created_at < ? OR (f.created_at = ? AND {relation_column} < ?))\",\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(timestamp);\n                builder.push_bind(timestamp);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::Oldest => {\n                let timestamp = primary_str\n                    .parse::<i64>()\n                    .map_err(|_| AppError::InvalidInput(\"Invalid cursor timestamp\".into()))?;\n                builder.push(format!(\n                    \" AND (f.created_at > ? OR (f.created_at = ? AND {relation_column} > ?))\",\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(timestamp);\n                builder.push_bind(timestamp);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::NameAsc => {\n                builder.push(\" AND (\");\n                builder.push(SORT_KEY_LOWER_EXPR);\n                builder.push(format!(\n                    \" > ? OR ({expr} = ? AND {relation_column} > ?))\",\n                    expr = SORT_KEY_LOWER_EXPR,\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(cursor_pubkey.clone());\n            }\n            FollowListSort::NameDesc => {\n                builder.push(\" AND (\");\n                builder.push(SORT_KEY_LOWER_EXPR);\n                builder.push(format!(\n                    \" < ? OR ({expr} = ? AND {relation_column} < ?))\",\n                    expr = SORT_KEY_LOWER_EXPR,\n                    relation_column = descriptor.relation_column,\n                ));\n                builder.push_bind(primary_str.clone());\n                builder.push_bind(primary_str);\n                builder.push_bind(cursor_pubkey.clone());\n            }\n        }\n    }\n\n    match sort {\n        FollowListSort::Recent => {\n            builder.push(format!(\n                \" ORDER BY f.created_at DESC, {relation_column} DESC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::Oldest => {\n            builder.push(format!(\n                \" ORDER BY f.created_at ASC, {relation_column} ASC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::NameAsc => {\n            builder.push(format!(\n                \" ORDER BY sort_key_normalized ASC, {relation_column} ASC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n        FollowListSort::NameDesc => {\n            builder.push(format!(\n                \" ORDER BY sort_key_normalized DESC, {relation_column} DESC\",\n                relation_column = descriptor.relation_column,\n            ));\n        }\n    }\n    builder.push(\" LIMIT ?\");\n    builder.push_bind(fetch_limit as i64);\n\n    let rows = builder.build().fetch_all(repo.pool.get_pool()).await?;\n    let count_row = count_builder\n        .build()\n        .fetch_one(repo.pool.get_pool())\n        .await?;\n    let total_count: i64 = count_row.try_get(\"total_count\")?;\n    let total_count = total_count.max(0) as u64;\n\n    let mut users = Vec::with_capacity(rows.len().min(limit));\n    let mut next_cursor = None;\n\n    for (index, row) in rows.into_iter().enumerate() {\n        if index >= limit {\n            let relation_pubkey: String = row.try_get(\"relation_pubkey\")?;\n            let primary_value = match sort {\n                FollowListSort::Recent | FollowListSort::Oldest => {\n                    let timestamp: i64 = row.try_get(\"relation_created_at\")?;\n                    timestamp.to_string()\n                }\n                FollowListSort::NameAsc | FollowListSort::NameDesc => {\n                    row.try_get::<String, _>(\"sort_key_normalized\")?\n                }\n            };\n            next_cursor = Some(encode_follow_cursor(sort, &primary_value, &relation_pubkey));\n            break;\n        }\n        users.push(map_user_row(&row)?);\n    }\n\n    let has_more = next_cursor.is_some();\n\n    Ok(UserCursorPage {\n        users,\n        next_cursor,\n        has_more,\n        total_count,\n    })\n}\n\n#[async_trait]\nimpl UserRepository for SqliteRepository {\n    async fn create_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(INSERT_USER)\n            .bind(user.npub())\n            .bind(user.pubkey())\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(if user.public_profile { 1 } else { 0 })\n            .bind(if user.show_online_status { 1 } else { 0 })\n            .bind(user.created_at.timestamp_millis())\n            .bind(user.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_NPUB)\n            .bind(npub)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_PUBKEY)\n            .bind(pubkey)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn search_users(&self, query: &str, limit: usize) -> Result<Vec<User>, AppError> {\n        if query.trim().is_empty() {\n            return Ok(vec![]);\n        }\n\n        let rows = sqlx::query(SEARCH_USERS)\n            .bind(query)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut users = Vec::with_capacity(rows.len());\n        for row in rows {\n            users.push(map_user_row(&row)?);\n        }\n\n        Ok(users)\n    }\n\n    async fn update_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(UPDATE_USER)\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(if user.public_profile { 1 } else { 0 })\n            .bind(if user.show_online_status { 1 } else { 0 })\n            .bind(user.updated_at.timestamp_millis())\n            .bind(user.npub())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\n        sqlx::query(DELETE_USER)\n            .bind(npub)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_followers_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        query_follow_relation(\n            self,\n            npub,\n            cursor,\n            limit,\n            sort,\n            search,\n            FollowQueryDescriptor {\n                join_expr: \"f.follower_pubkey\",\n                filter_column: \"f.followed_pubkey\",\n                relation_column: \"f.follower_pubkey\",\n            },\n        )\n        .await\n    }\n\n    async fn get_following_paginated(\n        &self,\n        npub: &str,\n        cursor: Option<&str>,\n        limit: usize,\n        sort: FollowListSort,\n        search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        query_follow_relation(\n            self,\n            npub,\n            cursor,\n            limit,\n            sort,\n            search,\n            FollowQueryDescriptor {\n                join_expr: \"f.followed_pubkey\",\n                filter_column: \"f.follower_pubkey\",\n                relation_column: \"f.followed_pubkey\",\n            },\n        )\n        .await\n    }\n\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let result = sqlx::query(UPSERT_FOLLOW_RELATION)\n            .bind(follower_pubkey)\n            .bind(followed_pubkey)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected() > 0)\n    }\n\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let result = sqlx::query(DELETE_FOLLOW_RELATION)\n            .bind(follower_pubkey)\n            .bind(followed_pubkey)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(result.rows_affected() > 0)\n    }\n\n    async fn list_following_pubkeys(&self, follower_pubkey: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWING_PUBKEYS)\n            .bind(follower_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut result = Vec::with_capacity(rows.len());\n        for row in rows {\n            result.push(row.try_get::<String, _>(\"followed_pubkey\")?);\n        }\n        Ok(result)\n    }\n\n    async fn list_follower_pubkeys(&self, followed_pubkey: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWER_PUBKEYS)\n            .bind(followed_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut result = Vec::with_capacity(rows.len());\n        for row in rows {\n            result.push(row.try_get::<String, _>(\"follower_pubkey\")?);\n        }\n        Ok(result)\n    }\n}\n","traces":[{"line":17,"address":[13594640,13595064],"length":1,"stats":{"Line":0}},{"line":18,"address":[13533878],"length":1,"stats":{"Line":0}},{"line":19,"address":[13638445,13638522],"length":1,"stats":{"Line":0}},{"line":22,"address":[13603965,13602016,13603796],"length":1,"stats":{"Line":0}},{"line":26,"address":[13595127],"length":1,"stats":{"Line":0}},{"line":27,"address":[13733858,13733645],"length":1,"stats":{"Line":0}},{"line":29,"address":[13733827,13735566,13735552],"length":1,"stats":{"Line":0}},{"line":30,"address":[13534456],"length":1,"stats":{"Line":0}},{"line":31,"address":[13595488],"length":1,"stats":{"Line":0}},{"line":33,"address":[13639476,13639100,13639323],"length":1,"stats":{"Line":0}},{"line":35,"address":[21296133,21297552,21297566],"length":1,"stats":{"Line":0}},{"line":36,"address":[13633781,13634114,13633928],"length":1,"stats":{"Line":0}},{"line":38,"address":[13639326,13638019,13639312],"length":1,"stats":{"Line":0}},{"line":39,"address":[13535196,13535044,13535362],"length":1,"stats":{"Line":0}},{"line":40,"address":[23922393],"length":1,"stats":{"Line":0}},{"line":41,"address":[13639422,13638211,13639408],"length":1,"stats":{"Line":0}},{"line":42,"address":[13603414,13603189,13603028,13603950],"length":1,"stats":{"Line":0}},{"line":43,"address":[13640134,13641152,13641170],"length":1,"stats":{"Line":0}},{"line":44,"address":[13634534,13634672],"length":1,"stats":{"Line":0}},{"line":45,"address":[13596635,13596882],"length":1,"stats":{"Line":0}},{"line":47,"address":[13596576,13596676],"length":1,"stats":{"Line":0}},{"line":56,"address":[13736096],"length":1,"stats":{"Line":0}},{"line":65,"address":[13605132,13605313],"length":1,"stats":{"Line":0}},{"line":66,"address":[13636500,13636590],"length":1,"stats":{"Line":0}},{"line":67,"address":[13598452,13608960,13608982],"length":1,"stats":{"Line":0}},{"line":69,"address":[13642194,13642337],"length":1,"stats":{"Line":0}},{"line":80,"address":[13531226],"length":1,"stats":{"Line":0}},{"line":82,"address":[13531252],"length":1,"stats":{"Line":0}},{"line":90,"address":[13643098],"length":1,"stats":{"Line":0}},{"line":92,"address":[21299812],"length":1,"stats":{"Line":0}},{"line":93,"address":[13531715,13531780],"length":1,"stats":{"Line":0}},{"line":94,"address":[13532134,13532190,13531991,13531880],"length":1,"stats":{"Line":0}},{"line":95,"address":[13532214],"length":1,"stats":{"Line":0}},{"line":96,"address":[13539243],"length":1,"stats":{"Line":0}},{"line":97,"address":[13638218],"length":1,"stats":{"Line":0}},{"line":98,"address":[21300513],"length":1,"stats":{"Line":0}},{"line":99,"address":[13642231],"length":1,"stats":{"Line":0}},{"line":100,"address":[13738717],"length":1,"stats":{"Line":0}},{"line":104,"address":[13637662,13638417,13641314],"length":1,"stats":{"Line":0}},{"line":105,"address":[13539505,13539818,13542416,13539585],"length":1,"stats":{"Line":0}},{"line":106,"address":[13638715],"length":1,"stats":{"Line":0}},{"line":108,"address":[13643211,13642993,13642791,13643543],"length":1,"stats":{"Line":0}},{"line":110,"address":[13534437,13526523,13534416],"length":1,"stats":{"Line":0}},{"line":111,"address":[13643115,13643248],"length":1,"stats":{"Line":0}},{"line":115,"address":[13739815],"length":1,"stats":{"Line":0}},{"line":116,"address":[13601369],"length":1,"stats":{"Line":0}},{"line":117,"address":[13526803],"length":1,"stats":{"Line":0}},{"line":120,"address":[13540703,13540921,13539945,13541234],"length":1,"stats":{"Line":0}},{"line":122,"address":[21302089,21309488,21309509],"length":1,"stats":{"Line":0}},{"line":123,"address":[13645353,13645486],"length":1,"stats":{"Line":0}},{"line":127,"address":[13601925],"length":1,"stats":{"Line":0}},{"line":128,"address":[13645655],"length":1,"stats":{"Line":0}},{"line":129,"address":[13534177],"length":1,"stats":{"Line":0}},{"line":132,"address":[13526211],"length":1,"stats":{"Line":0}},{"line":133,"address":[13645896],"length":1,"stats":{"Line":0}},{"line":134,"address":[13534430],"length":1,"stats":{"Line":0}},{"line":139,"address":[13640572],"length":1,"stats":{"Line":0}},{"line":140,"address":[21302920],"length":1,"stats":{"Line":0}},{"line":141,"address":[13646308],"length":1,"stats":{"Line":0}},{"line":144,"address":[13644540],"length":1,"stats":{"Line":0}},{"line":145,"address":[13609621],"length":1,"stats":{"Line":0}},{"line":146,"address":[13640843],"length":1,"stats":{"Line":0}},{"line":151,"address":[13741433],"length":1,"stats":{"Line":0}},{"line":152,"address":[13535221],"length":1,"stats":{"Line":0}},{"line":153,"address":[13528511],"length":1,"stats":{"Line":0}},{"line":158,"address":[13638482],"length":1,"stats":{"Line":0}},{"line":160,"address":[13646949,13647153],"length":1,"stats":{"Line":0}},{"line":166,"address":[13542472,13542795],"length":1,"stats":{"Line":0}},{"line":172,"address":[13641467,13641871],"length":1,"stats":{"Line":0}},{"line":178,"address":[13645939,13645454],"length":1,"stats":{"Line":0}},{"line":184,"address":[13647282],"length":1,"stats":{"Line":0}},{"line":185,"address":[13610959],"length":1,"stats":{"Line":0}},{"line":187,"address":[11549410],"length":1,"stats":{"Line":0}},{"line":188,"address":[13643643,13646944,13643175,13642939,13643293,13643517,13643859],"length":1,"stats":{"Line":0}},{"line":190,"address":[13643210,13643101,13643058,13643355],"length":1,"stats":{"Line":0}},{"line":191,"address":[11563192],"length":1,"stats":{"Line":0}},{"line":192,"address":[23932065,23932163,23931905,23934945],"length":1,"stats":{"Line":0}},{"line":193,"address":[13545184,13545074],"length":1,"stats":{"Line":0}},{"line":195,"address":[13545192],"length":1,"stats":{"Line":0}},{"line":196,"address":[13644244],"length":1,"stats":{"Line":0}},{"line":198,"address":[21306799,21306524,21306866,21306648],"length":1,"stats":{"Line":0}},{"line":199,"address":[13538754],"length":1,"stats":{"Line":0}},{"line":200,"address":[21306990,21307367,21309038,21307518],"length":1,"stats":{"Line":0}},{"line":201,"address":[13650805],"length":1,"stats":{"Line":0}},{"line":203,"address":[13645569,13645699,13645456,13645331],"length":1,"stats":{"Line":0}},{"line":204,"address":[13532838,13532947],"length":1,"stats":{"Line":0}},{"line":207,"address":[13645370,13645723,13646761],"length":1,"stats":{"Line":0}},{"line":210,"address":[13614859,13614469],"length":1,"stats":{"Line":0}},{"line":213,"address":[13606959,13606692,13606579],"length":1,"stats":{"Line":0}},{"line":216,"address":[21308615],"length":1,"stats":{"Line":0}},{"line":218,"address":[13608337],"length":1,"stats":{"Line":0}},{"line":219,"address":[13615201],"length":1,"stats":{"Line":0}},{"line":220,"address":[13746785],"length":1,"stats":{"Line":0}},{"line":228,"address":[13632442,13634152,13632211,13632330,13633783,13633669,13632176],"length":1,"stats":{"Line":9}},{"line":229,"address":[13744900,13745528,13744651,13745430,13744771,13744506,13745088,13745018,13745709,13744051,13744466,13744391,13744335,13744117,13744203,13744575],"length":1,"stats":{"Line":26}},{"line":230,"address":[13626977,13625837,13625794,13625950],"length":1,"stats":{"Line":4}},{"line":231,"address":[13839154,13840017,13839038],"length":1,"stats":{"Line":4}},{"line":232,"address":[13700682],"length":1,"stats":{"Line":1}},{"line":233,"address":[13707685],"length":1,"stats":{"Line":1}},{"line":234,"address":[13839277],"length":1,"stats":{"Line":1}},{"line":235,"address":[13707765],"length":1,"stats":{"Line":1}},{"line":236,"address":[13633105,13633181],"length":1,"stats":{"Line":2}},{"line":237,"address":[13640278,13640683,13640165,13639890],"length":1,"stats":{"Line":4}},{"line":238,"address":[21401510,21401628,21401870],"length":1,"stats":{"Line":2}},{"line":239,"address":[13708188,13708373,13708285],"length":1,"stats":{"Line":4}},{"line":240,"address":[13743467,13743671,13743830,13744013,13742213,13743413],"length":1,"stats":{"Line":6}},{"line":242,"address":[13708854],"length":1,"stats":{"Line":1}},{"line":245,"address":[13746483,13747212,13745760,13745795,13746022,13745910],"length":1,"stats":{"Line":0}},{"line":246,"address":[13702431,13702714,13702940,13703332,13703048,13702510,13702609,13703953],"length":1,"stats":{"Line":0}},{"line":247,"address":[13740654,13740609],"length":1,"stats":{"Line":0}},{"line":248,"address":[21402934,21403149,21403028,21402846],"length":1,"stats":{"Line":0}},{"line":249,"address":[11994484],"length":1,"stats":{"Line":0}},{"line":251,"address":[13746946],"length":1,"stats":{"Line":0}},{"line":252,"address":[13745569,13745463,13745933],"length":1,"stats":{"Line":0}},{"line":253,"address":[13635561],"length":1,"stats":{"Line":0}},{"line":257,"address":[13636195,13636310,13636422,13636160,13636883,13637612],"length":1,"stats":{"Line":0}},{"line":258,"address":[13644120,13643582,13644404,13643681,13645025,13643786,13643503,13644012],"length":1,"stats":{"Line":0}},{"line":259,"address":[13711329,13711374],"length":1,"stats":{"Line":0}},{"line":260,"address":[13643837,13643534,13643716,13643622],"length":1,"stats":{"Line":0}},{"line":261,"address":[12109652],"length":1,"stats":{"Line":0}},{"line":263,"address":[13705154],"length":1,"stats":{"Line":0}},{"line":264,"address":[21405703,21405809,21406173],"length":1,"stats":{"Line":0}},{"line":265,"address":[13630681],"length":1,"stats":{"Line":0}},{"line":269,"address":[13640031,13638980,13638099,13638194,13638306,13638910,13638064],"length":1,"stats":{"Line":10}},{"line":270,"address":[13631649],"length":1,"stats":{"Line":1}},{"line":271,"address":[24064113,24064480],"length":1,"stats":{"Line":0}},{"line":274,"address":[13750099,13750233,13750628,13751906,13749998,13750932,13750726,13750338],"length":1,"stats":{"Line":9}},{"line":275,"address":[13744502],"length":1,"stats":{"Line":1}},{"line":276,"address":[13748515],"length":1,"stats":{"Line":1}},{"line":277,"address":[13748523,13748620,13748744,13748403],"length":1,"stats":{"Line":4}},{"line":278,"address":[11415844],"length":1,"stats":{"Line":5}},{"line":280,"address":[13845799,13845644],"length":1,"stats":{"Line":3}},{"line":281,"address":[13714273,13714384,13714519,13714567],"length":1,"stats":{"Line":6}},{"line":282,"address":[13633296,13633079],"length":1,"stats":{"Line":5}},{"line":285,"address":[13633109],"length":1,"stats":{"Line":3}},{"line":288,"address":[13633882,13634877,13634817,13633770,13633632,13635247,13633667],"length":1,"stats":{"Line":0}},{"line":289,"address":[21409267,21409042,21409191,21409082,21410276,21409707,21409997,21408963,21410095,21409122,21409519,21409387,21409637],"length":1,"stats":{"Line":0}},{"line":290,"address":[13746757],"length":1,"stats":{"Line":0}},{"line":291,"address":[13750733],"length":1,"stats":{"Line":0}},{"line":292,"address":[21409109],"length":1,"stats":{"Line":0}},{"line":293,"address":[13708765],"length":1,"stats":{"Line":0}},{"line":294,"address":[21409301,21409225],"length":1,"stats":{"Line":0}},{"line":295,"address":[13647778,13648093,13648615,13648206],"length":1,"stats":{"Line":0}},{"line":296,"address":[13751102,13751223,13751466],"length":1,"stats":{"Line":0}},{"line":297,"address":[13634696,13634599,13634785],"length":1,"stats":{"Line":0}},{"line":298,"address":[11886612],"length":1,"stats":{"Line":0}},{"line":300,"address":[13753501],"length":1,"stats":{"Line":0}},{"line":303,"address":[13642779,13643158,13642128,13642356,13642163,13642250],"length":1,"stats":{"Line":0}},{"line":304,"address":[13749131,13748381,13748556,13748626,13748457,13748852,13748950],"length":1,"stats":{"Line":0}},{"line":305,"address":[13710332,13710377],"length":1,"stats":{"Line":0}},{"line":306,"address":[13635708,13635887,13635793,13635973],"length":1,"stats":{"Line":0}},{"line":307,"address":[19661476],"length":1,"stats":{"Line":0}},{"line":309,"address":[13752980],"length":1,"stats":{"Line":0}},{"line":312,"address":[13650492,13650278,13650240,13650469,13650911,13650380,13651211],"length":1,"stats":{"Line":0}},{"line":322,"address":[13749645],"length":1,"stats":{"Line":0}},{"line":327,"address":[13636954],"length":1,"stats":{"Line":0}},{"line":333,"address":[13636647,13637073,13637127,13637183,13637359],"length":1,"stats":{"Line":0}},{"line":336,"address":[13718992,13719221,13719663,13719132,13719030,13719244,13719963],"length":1,"stats":{"Line":0}},{"line":346,"address":[13750637],"length":1,"stats":{"Line":0}},{"line":351,"address":[13651706],"length":1,"stats":{"Line":0}},{"line":357,"address":[13750343,13750879,13750769,13751055,13750823],"length":1,"stats":{"Line":0}},{"line":360,"address":[12840911],"length":1,"stats":{"Line":5}},{"line":365,"address":[13639015,13639311,13639409,13638797,13638873,13638913,13639085,13639590,13639683],"length":1,"stats":{"Line":7}},{"line":366,"address":[13638860],"length":1,"stats":{"Line":1}},{"line":367,"address":[13851972,13852017],"length":1,"stats":{"Line":2}},{"line":368,"address":[21413929,21413804,21414026,21414112],"length":1,"stats":{"Line":2}},{"line":369,"address":[11980852],"length":1,"stats":{"Line":4}},{"line":371,"address":[13756159,13756268],"length":1,"stats":{"Line":2}},{"line":374,"address":[13646480,13647694,13646602,13646515,13646708,13647174],"length":1,"stats":{"Line":0}},{"line":379,"address":[13647606,13647101,13646889,13646813,13647699,13647425,13646929,13647327,13647031],"length":1,"stats":{"Line":0}},{"line":380,"address":[13714684],"length":1,"stats":{"Line":0}},{"line":381,"address":[13714724,13714769],"length":1,"stats":{"Line":0}},{"line":382,"address":[13653820,13654128,13654042,13653945],"length":1,"stats":{"Line":0}},{"line":383,"address":[12022052],"length":1,"stats":{"Line":0}},{"line":385,"address":[24072921,24072816],"length":1,"stats":{"Line":0}},{"line":388,"address":[12841113],"length":1,"stats":{"Line":5}},{"line":389,"address":[13641269,13643068,13641552,13641348,13641876,13641447,13641778,13642081],"length":1,"stats":{"Line":6}},{"line":390,"address":[13754039,13754084],"length":1,"stats":{"Line":2}},{"line":391,"address":[13758028,13757940,13758243,13758122],"length":1,"stats":{"Line":2}},{"line":392,"address":[13758219,13758306,13757725,13758466,13758130,13758673],"length":1,"stats":{"Line":4}},{"line":394,"address":[13855235,13855082],"length":1,"stats":{"Line":2}},{"line":395,"address":[13656195,13656243,13655949,13656060],"length":1,"stats":{"Line":4}},{"line":396,"address":[13656275,13656504],"length":1,"stats":{"Line":2}},{"line":398,"address":[13642557],"length":1,"stats":{"Line":1}},{"line":401,"address":[13643107,13643308,13643072,13643769,13643202,13644839],"length":1,"stats":{"Line":5}},{"line":402,"address":[13757916,13756295,13756196,13756626,13756724,13756929,13756400,13756117],"length":1,"stats":{"Line":6}},{"line":403,"address":[13724999,13725044],"length":1,"stats":{"Line":2}},{"line":404,"address":[13756148,13756236,13756330,13756451],"length":1,"stats":{"Line":2}},{"line":405,"address":[13643810,13643970,13644177,13643229,13643634,13643723],"length":1,"stats":{"Line":4}},{"line":407,"address":[13857226,13857379],"length":1,"stats":{"Line":2}},{"line":408,"address":[13725853,13726147,13726099,13725964],"length":1,"stats":{"Line":4}},{"line":409,"address":[13658419,13658648],"length":1,"stats":{"Line":2}},{"line":411,"address":[21419677],"length":1,"stats":{"Line":1}}],"covered":50,"coverable":193},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","subscription_state_repository.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{Row, SqlitePool, sqlite::SqliteRow};\n\n#[derive(Clone)]\npub struct SqliteSubscriptionStateRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteSubscriptionStateRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &SqlitePool {\n        self.pool.get_pool()\n    }\n\n    fn row_to_record(row: SqliteRow) -> Result<SubscriptionRecord, AppError> {\n        let target_value: String = row.get(\"target\");\n        let target_type: String = row.get(\"target_type\");\n        let status: String = row.get(\"status\");\n        let last_synced_at: Option<i64> = row.get(\"last_synced_at\");\n        let last_attempt_at: Option<i64> = row.get(\"last_attempt_at\");\n        let failure_count: i64 = row.get(\"failure_count\");\n        let error_message: Option<String> = row.get(\"error_message\");\n\n        let target = SubscriptionTarget::from_parts(&target_type, target_value)?;\n        let status = SubscriptionStatus::parse(&status)?;\n\n        Ok(SubscriptionRecord {\n            target,\n            status,\n            last_synced_at,\n            last_attempt_at,\n            failure_count,\n            error_message,\n        })\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateRepository for SqliteSubscriptionStateRepository {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError> {\n        let (target_type, target_value) = record.target.as_parts();\n        let now_ms = Utc::now().timestamp_millis();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO nostr_subscriptions (\n                target,\n                target_type,\n                status,\n                last_synced_at,\n                last_attempt_at,\n                failure_count,\n                error_message,\n                created_at,\n                updated_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?8)\n            ON CONFLICT(target, target_type) DO UPDATE SET\n                status = excluded.status,\n                last_synced_at = excluded.last_synced_at,\n                last_attempt_at = excluded.last_attempt_at,\n                failure_count = excluded.failure_count,\n                error_message = excluded.error_message,\n                updated_at = excluded.updated_at\n            \"#,\n        )\n        .bind(target_value)\n        .bind(target_type)\n        .bind(record.status.as_str())\n        .bind(record.last_synced_at)\n        .bind(record.last_attempt_at)\n        .bind(record.failure_count)\n        .bind(record.error_message.clone())\n        .bind(now_ms)\n        .execute(self.pool())\n        .await?;\n\n        self.find(&record.target)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Subscription record missing after upsert\".into()))\n    }\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError> {\n        let (target_type, target_value) = target.as_parts();\n\n        let row = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE target_type = ?1 AND target = ?2\n            \"#,\n        )\n        .bind(target_type)\n        .bind(target_value)\n        .fetch_optional(self.pool())\n        .await?;\n\n        match row {\n            Some(row) => Ok(Some(Self::row_to_record(row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError> {\n        sqlx::query(\n            r#\"\n            UPDATE nostr_subscriptions\n            SET status = 'needs_resync',\n                updated_at = ?1,\n                error_message = NULL\n            WHERE status = 'subscribed'\n            \"#,\n        )\n        .bind(updated_at_ms)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE status IN ('pending', 'needs_resync')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            ORDER BY target_type ASC, target ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n}\n","traces":[{"line":17,"address":[15942464],"length":1,"stats":{"Line":1}},{"line":21,"address":[15881648],"length":1,"stats":{"Line":1}},{"line":22,"address":[15980597],"length":1,"stats":{"Line":1}},{"line":25,"address":[15876361,15874688,15876269],"length":1,"stats":{"Line":2}},{"line":26,"address":[15868018,15867926],"length":1,"stats":{"Line":4}},{"line":27,"address":[15949546],"length":1,"stats":{"Line":2}},{"line":28,"address":[15984747],"length":1,"stats":{"Line":2}},{"line":29,"address":[15881951,15882047],"length":1,"stats":{"Line":4}},{"line":30,"address":[16081391],"length":1,"stats":{"Line":2}},{"line":31,"address":[15875190],"length":1,"stats":{"Line":1}},{"line":32,"address":[17050643],"length":1,"stats":{"Line":1}},{"line":34,"address":[15950096,15950025,15950308,15951014],"length":1,"stats":{"Line":2}},{"line":35,"address":[15950287,15950438,15950842],"length":1,"stats":{"Line":4}},{"line":37,"address":[23644079],"length":1,"stats":{"Line":2}},{"line":38,"address":[15985679],"length":1,"stats":{"Line":2}},{"line":43,"address":[23644047],"length":1,"stats":{"Line":1}},{"line":50,"address":[15943698,15943436,15943348,15944911,15946067,15944858,15943559,15943392],"length":1,"stats":{"Line":9}},{"line":51,"address":[16046686],"length":1,"stats":{"Line":2}},{"line":52,"address":[16011681],"length":1,"stats":{"Line":2}},{"line":77,"address":[17234861],"length":1,"stats":{"Line":2}},{"line":78,"address":[16005721,16004957,16005080,16004840],"length":1,"stats":{"Line":4}},{"line":79,"address":[16047136],"length":1,"stats":{"Line":2}},{"line":80,"address":[15930578],"length":1,"stats":{"Line":2}},{"line":81,"address":[15937409,15937452],"length":1,"stats":{"Line":3}},{"line":82,"address":[16005268,16005135,16005699,16005392],"length":1,"stats":{"Line":2}},{"line":83,"address":[16012390],"length":1,"stats":{"Line":1}},{"line":84,"address":[16005668,16005427,16005470,16005572],"length":1,"stats":{"Line":2}},{"line":85,"address":[17235525,17235488,17235814,17235659,17236003,17234338],"length":1,"stats":{"Line":4}},{"line":87,"address":[23706801,23706979,23707288,23706642,23706482,23707223],"length":1,"stats":{"Line":6}},{"line":88,"address":[11870210],"length":1,"stats":{"Line":5}},{"line":89,"address":[15932334,15932320],"length":1,"stats":{"Line":0}},{"line":92,"address":[16045319,16045431,16046038,16046748,16045134,16045184,16045219],"length":1,"stats":{"Line":7}},{"line":96,"address":[23707808],"length":1,"stats":{"Line":1}},{"line":106,"address":[15939873],"length":1,"stats":{"Line":1}},{"line":107,"address":[23708288,23707951,23708166,23708073],"length":1,"stats":{"Line":2}},{"line":108,"address":[15946402,15947047,15947135,15947582,15946958,15947295],"length":1,"stats":{"Line":6}},{"line":110,"address":[16052079],"length":1,"stats":{"Line":2}},{"line":111,"address":[16046813,16046651],"length":1,"stats":{"Line":3}},{"line":112,"address":[16046611],"length":1,"stats":{"Line":2}},{"line":116,"address":[16009162,16009040,16009075,16009268,16010079,16008990,16009701],"length":1,"stats":{"Line":5}},{"line":126,"address":[16053191],"length":1,"stats":{"Line":1}},{"line":127,"address":[16047615,16047791,16047538,16047705],"length":1,"stats":{"Line":2}},{"line":128,"address":[11891812],"length":1,"stats":{"Line":4}},{"line":130,"address":[16148525],"length":1,"stats":{"Line":1}},{"line":133,"address":[16010185,16010460,16011544,16010224,16010259,16010354,16011579,16010878],"length":1,"stats":{"Line":5}},{"line":142,"address":[16017572,16017784,16017662,16017524],"length":1,"stats":{"Line":2}},{"line":143,"address":[11884580],"length":1,"stats":{"Line":4}},{"line":145,"address":[16018195,16018384],"length":1,"stats":{"Line":2}},{"line":148,"address":[16054334,16053916,16055000,16053715,16053680,16053810,16055035,16053641],"length":1,"stats":{"Line":8}},{"line":156,"address":[15944196,15944456,15944244,15944334],"length":1,"stats":{"Line":4}},{"line":157,"address":[11878260],"length":1,"stats":{"Line":7}},{"line":159,"address":[15944867,15945056],"length":1,"stats":{"Line":2}}],"covered":51,"coverable":52},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","event_manager_gateway.rs"],"content":"use crate::application::ports::event_gateway::EventGateway;\r\n#[cfg(test)]\r\nuse crate::application::ports::key_manager::KeyPair;\r\nuse crate::application::shared::mappers::{domain_event_to_nostr_event, profile_metadata_to_nostr};\r\nuse crate::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\r\nuse crate::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\r\nuse crate::domain::value_objects::{EventId, TopicId};\r\nuse crate::infrastructure::event::manager_handle::EventManagerHandle;\r\nuse crate::infrastructure::event::metrics::{self, GatewayMetricKind};\r\nuse crate::infrastructure::p2p::metrics as p2p_metrics;\r\nuse crate::shared::{AppError, ValidationFailureKind};\r\nuse async_trait::async_trait;\r\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId};\r\nuse once_cell::sync::Lazy;\r\nuse serde::Serialize;\r\nuse std::collections::HashMap;\r\nuse std::sync::{Arc, Mutex};\r\nuse std::time::{Duration, Instant};\r\nuse tauri::{AppHandle, Emitter};\r\nuse tokio::sync::RwLock;\r\nuse tracing::error;\r\n\r\npub struct LegacyEventManagerGateway {\r\n    manager: Arc<dyn EventManagerHandle>,\r\n    app_handle: Arc<RwLock<Option<AppHandle>>>,\r\n}\r\n\r\nconst VALIDATION_LOG_WINDOW: Duration = Duration::from_secs(60);\r\nconst VALIDATION_WARN_THRESHOLD: u32 = 3;\r\n\r\nstruct ValidationLogWindow {\r\n    window_start: Instant,\r\n    count: u32,\r\n}\r\n\r\nstatic VALIDATION_LOG_WINDOWS: Lazy<Mutex<HashMap<ValidationFailureKind, ValidationLogWindow>>> =\r\n    Lazy::new(|| Mutex::new(HashMap::new()));\r\n\r\n#[derive(Debug, Clone, Serialize)]\r\nstruct FrontendEventPayload {\r\n    id: String,\r\n    author: String,\r\n    content: String,\r\n    created_at: u64,\r\n    kind: u32,\r\n    tags: Vec<Vec<String>>,\r\n}\r\n\r\nimpl From<&NostrEvent> for FrontendEventPayload {\r\n    fn from(event: &NostrEvent) -> Self {\r\n        Self {\r\n            id: event.id.to_string(),\r\n            author: event.pubkey.to_string(),\r\n            content: event.content.clone(),\r\n            created_at: event.created_at.as_secs(),\n            kind: event.kind.as_u16() as u32,\r\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::application::ports::event_topic_store::EventTopicStore;\r\n    use crate::domain::entities::EventKind;\r\n    use crate::domain::entities::event_gateway::EventTag;\r\n    use crate::domain::value_objects::EventId;\r\n    use crate::infrastructure::event::manager_handle::LegacyEventManagerHandle;\r\n    use crate::infrastructure::event::metrics;\r\n    use crate::infrastructure::p2p::GossipService;\r\n    use anyhow::{Result as AnyResult, anyhow};\r\n    use chrono::Utc;\r\n    use nostr_sdk::Timestamp;\r\n    use nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata};\r\n\r\n    #[derive(Default)]\r\n    struct TestEventManagerHandle {\r\n        fail_handle_event: bool,\r\n        fail_publish_text: bool,\r\n    }\r\n\r\n    impl TestEventManagerHandle {\r\n        fn with_handle_failure() -> Self {\r\n            Self {\r\n                fail_handle_event: true,\r\n                fail_publish_text: false,\r\n            }\r\n        }\r\n\r\n        fn with_publish_failure() -> Self {\r\n            Self {\r\n                fail_handle_event: false,\r\n                fail_publish_text: true,\r\n            }\r\n        }\r\n    }\r\n\r\n    #[async_trait]\r\n    impl EventManagerHandle for TestEventManagerHandle {\r\n        async fn set_gossip_service(&self, _: Arc<dyn GossipService>) {}\r\n\r\n        async fn set_event_topic_store(&self, _: Arc<dyn EventTopicStore>) {}\r\n\r\n        async fn set_default_p2p_topic_id(&self, _: &str) {}\r\n\r\n        async fn set_default_p2p_topics(&self, _: Vec<String>) {}\r\n\r\n        async fn list_default_p2p_topics(&self) -> Vec<String> {\r\n            vec![]\r\n        }\r\n\r\n        async fn handle_p2p_event(&self, _: NostrEvent) -> AnyResult<()> {\r\n            if self.fail_handle_event {\r\n                Err(anyhow!(\"forced incoming failure\"))\r\n            } else {\r\n                Ok(())\r\n            }\r\n        }\r\n\r\n        async fn publish_text_note(&self, _: &str) -> AnyResult<NostrEventId> {\r\n            if self.fail_publish_text {\r\n                Err(anyhow!(\"forced publish failure\"))\r\n            } else {\r\n                Ok(sample_nostr_event_id('1'))\r\n            }\r\n        }\r\n\r\n        async fn publish_topic_post(\n            &self,\n            _: &str,\n            _: &str,\n            _: Option<NostrEventId>,\n            _: Option<&str>,\n            _: Option<i64>,\n        ) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('2'))\n        }\n\r\n        async fn publish_repost(&self, _: &NostrEventId) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('4'))\r\n        }\r\n\r\n        async fn publish_event(&self, _: NostrEvent) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('6'))\r\n        }\r\n\r\n        async fn send_reaction(&self, _: &NostrEventId, _: &str) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('3'))\r\n        }\r\n\r\n        async fn update_metadata(&self, _: Metadata) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('4'))\r\n        }\r\n\r\n        async fn delete_events(\r\n            &self,\r\n            _: Vec<NostrEventId>,\r\n            _: Option<String>,\r\n        ) -> AnyResult<NostrEventId> {\r\n            Ok(sample_nostr_event_id('5'))\r\n        }\r\n\r\n        async fn disconnect(&self) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn get_public_key(&self) -> Option<nostr_sdk::prelude::PublicKey> {\r\n            None\r\n        }\r\n\r\n        async fn subscribe_to_topic(&self, _: &str, _: Option<Timestamp>) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn subscribe_to_user(\r\n            &self,\r\n            _: nostr_sdk::prelude::PublicKey,\r\n            _: Option<Timestamp>,\r\n        ) -> AnyResult<()> {\r\n            Ok(())\r\n        }\r\n\r\n        async fn register_event_callback(&self, _: Arc<dyn Fn(NostrEvent) + Send + Sync>) {}\r\n\r\n        async fn initialize_with_keypair(&self, _: KeyPair) -> anyhow::Result<()> {\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    fn sample_nostr_event_id(ch: char) -> NostrEventId {\r\n        let hex: String = std::iter::repeat(ch).take(64).collect();\r\n        NostrEventId::from_hex(&hex).expect(\"valid nostr id\")\r\n    }\r\n\r\n    fn repeating_hex(ch: char, len: usize) -> String {\r\n        std::iter::repeat(ch).take(len).collect()\r\n    }\r\n\r\n    fn sample_domain_event() -> DomainEvent {\r\n        let event_id = EventId::from_hex(&repeating_hex('a', 64)).expect(\"valid event id\");\r\n        let public_key = PublicKey::from_hex_str(&repeating_hex('b', 64)).expect(\"valid pubkey\");\r\n        let tags = vec![\r\n            EventTag::new(\"p\", vec![repeating_hex('c', 64)]).expect(\"valid p tag\"),\r\n            EventTag::new(\"t\", vec![\"sample\".to_string()]).expect(\"valid t tag\"),\r\n        ];\r\n        DomainEvent::new(\r\n            event_id,\r\n            public_key,\r\n            EventKind::TextNote,\r\n            Utc::now(),\r\n            \"sample content\".to_string(),\r\n            tags,\r\n            repeating_hex('d', 128),\r\n        )\r\n        .expect(\"valid domain event\")\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn handle_incoming_event_without_app_handle_succeeds() {\r\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(LegacyEventManagerHandle::new());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        let event = sample_domain_event();\r\n\r\n        let result = gateway.handle_incoming_event(event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn frontend_payload_matches_nostr_event() {\r\n        let event = sample_domain_event();\r\n        let nostr_event = domain_event_to_nostr_event(&event).expect(\"domain to nostr\");\r\n        let payload = FrontendEventPayload::from(&nostr_event);\r\n\r\n        assert_eq!(payload.id, nostr_event.id.to_string());\r\n        assert_eq!(payload.author, nostr_event.pubkey.to_string());\r\n        assert_eq!(payload.content, nostr_event.content);\r\n        assert_eq!(payload.kind, nostr_event.kind.as_u16() as u32);\r\n        assert_eq!(payload.tags.len(), nostr_event.tags.len());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_incoming_success() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(TestEventManagerHandle::default());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        gateway\r\n            .handle_incoming_event(sample_domain_event())\r\n            .await\r\n            .expect(\"incoming event succeeds\");\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(snapshot.incoming.total, before.incoming.total + 1);\r\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_incoming_failure() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> =\r\n            Arc::new(TestEventManagerHandle::with_handle_failure());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n        let result = gateway.handle_incoming_event(sample_domain_event()).await;\r\n        assert!(result.is_err());\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures + 1);\r\n        assert_eq!(snapshot.incoming.total, before.incoming.total);\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn gateway_metrics_record_publish_failure() {\r\n        let _metrics_guard = metrics::test_guard();\r\n        metrics::reset();\r\n        let before = metrics::snapshot();\r\n        let manager: Arc<dyn EventManagerHandle> =\r\n            Arc::new(TestEventManagerHandle::with_publish_failure());\r\n        let gateway = LegacyEventManagerGateway::new(manager);\r\n\r\n        let result = gateway.publish_text_note(\"metrics-check\").await;\r\n        assert!(result.is_err());\r\n\r\n        let snapshot = metrics::snapshot();\r\n        assert_eq!(\r\n            snapshot.publish_text_note.failures,\r\n            before.publish_text_note.failures + 1\r\n        );\r\n        assert_eq!(\r\n            snapshot.publish_text_note.total,\r\n            before.publish_text_note.total\r\n        );\r\n    }\r\n}\r\n\r\nimpl LegacyEventManagerGateway {\r\n    pub fn new(manager: Arc<dyn EventManagerHandle>) -> Self {\r\n        Self {\r\n            manager,\r\n            app_handle: Arc::new(RwLock::new(None)),\r\n        }\r\n    }\r\n\r\n    fn to_nostr_event_id(event_id: &EventId) -> Result<NostrEventId, AppError> {\r\n        NostrEventId::from_hex(event_id.as_str())\r\n            .map_err(|err| AppError::NostrError(err.to_string()))\r\n    }\r\n\r\n    fn to_domain_event_id(event_id: NostrEventId) -> Result<EventId, AppError> {\r\n        EventId::from_hex(&event_id.to_hex()).map_err(|err| {\r\n            AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Invalid event ID returned: {err}\"),\r\n            )\r\n        })\r\n    }\r\n\r\n    fn to_domain_public_key(pk: nostr_sdk::prelude::PublicKey) -> Result<PublicKey, AppError> {\r\n        PublicKey::from_hex_str(&pk.to_hex()).map_err(|err| {\r\n            AppError::validation(\r\n                ValidationFailureKind::Generic,\r\n                format!(\"Invalid public key: {err}\"),\r\n            )\r\n        })\r\n    }\r\n\r\n    pub async fn set_app_handle(&self, handle: AppHandle) {\r\n        let mut guard = self.app_handle.write().await;\r\n        *guard = Some(handle);\r\n    }\r\n\r\n    async fn emit_frontend_event(&self, event: &NostrEvent) {\r\n        let handle = self.app_handle.read().await.clone();\r\n        if let Some(handle) = handle {\r\n            let payload = FrontendEventPayload::from(event);\r\n\r\n            if let Err(err) = handle.emit(\"nostr://event/p2p\", payload) {\r\n                error!(\"Failed to emit nostr event to frontend: {}\", err);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn record_p2p_broadcast_metrics<T>(result: Result<T, AppError>) -> Result<T, AppError> {\r\n    match result {\r\n        Ok(value) => {\r\n            p2p_metrics::record_broadcast_success();\r\n            Ok(value)\r\n        }\r\n        Err(err) => {\r\n            p2p_metrics::record_broadcast_failure();\r\n            Err(err)\r\n        }\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl EventGateway for LegacyEventManagerGateway {\r\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError> {\r\n        let result = metrics::record_outcome(\r\n            async {\r\n                let nostr_event = domain_event_to_nostr_event(&event)?;\r\n                self.manager\r\n                    .handle_p2p_event(nostr_event.clone())\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                self.emit_frontend_event(&nostr_event).await;\r\n                Ok(())\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Incoming,\r\n        );\r\n\r\n        match &result {\r\n            Ok(_) => {\r\n                p2p_metrics::record_receive_success();\r\n            }\r\n            Err(err) => {\r\n                if let Some(kind) = err.validation_kind() {\r\n                    p2p_metrics::record_receive_failure_with_reason(kind);\r\n                    log_validation_failure(&event, kind, err.validation_message());\r\n                } else {\r\n                    p2p_metrics::record_receive_failure();\r\n                }\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let event_id = self\r\n                    .manager\r\n                    .publish_text_note(content)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::PublishTextNote,\r\n        ))\r\n    }\r\n\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let reply_to_converted = if let Some(reply) = reply_to {\r\n                    Some(Self::to_nostr_event_id(reply)?)\r\n                } else {\r\n                    None\r\n                };\r\n\r\n                let event_id = self\n                    .manager\n                    .publish_topic_post(\n                        topic_id.as_str(),\n                        content.as_str(),\n                        reply_to_converted,\n                        scope,\n                        epoch,\n                    )\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::PublishTopicPost,\r\n        ))\r\n    }\r\n\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &EventId,\r\n        reaction: &ReactionValue,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_event_id = Self::to_nostr_event_id(target)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .send_reaction(&nostr_event_id, reaction.as_str())\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Reaction,\r\n        ))\r\n    }\r\n\r\n    async fn update_profile_metadata(\r\n        &self,\r\n        metadata: &ProfileMetadata,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_metadata = profile_metadata_to_nostr(metadata)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .update_metadata(nostr_metadata)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::MetadataUpdate,\r\n        ))\r\n    }\r\n\r\n    async fn delete_events(\r\n        &self,\r\n        targets: &[EventId],\r\n        reason: Option<&str>,\r\n    ) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_ids = targets\r\n                    .iter()\r\n                    .map(Self::to_nostr_event_id)\r\n                    .collect::<Result<Vec<_>, _>>()?;\r\n                let event_id = self\r\n                    .manager\r\n                    .delete_events(nostr_ids, reason.map(|value| value.to_string()))\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::DeleteEvents,\r\n        ))\r\n    }\r\n\r\n    async fn publish_repost(&self, target: &EventId) -> Result<EventId, AppError> {\r\n        record_p2p_broadcast_metrics(metrics::record_outcome(\r\n            async {\r\n                let nostr_id = Self::to_nostr_event_id(target)?;\r\n                let event_id = self\r\n                    .manager\r\n                    .publish_repost(&nostr_id)\r\n                    .await\r\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\r\n                Self::to_domain_event_id(event_id)\r\n            }\r\n            .await,\r\n            GatewayMetricKind::Repost,\r\n        ))\r\n    }\r\n\r\n    async fn disconnect(&self) -> Result<(), AppError> {\r\n        metrics::record_outcome(\r\n            self.manager\r\n                .disconnect()\r\n                .await\r\n                .map_err(|err| AppError::NostrError(err.to_string())),\r\n            GatewayMetricKind::Disconnect,\r\n        )\r\n    }\r\n\r\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError> {\r\n        let maybe_pk = self.manager.get_public_key().await;\r\n        maybe_pk.map(Self::to_domain_public_key).transpose()\r\n    }\r\n\r\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError> {\r\n        let topic_strings: Vec<String> = topics\r\n            .iter()\r\n            .map(|topic| topic.as_str().to_string())\r\n            .collect();\r\n        self.manager.set_default_p2p_topics(topic_strings).await;\r\n        Ok(())\r\n    }\r\n\r\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError> {\r\n        let topics = self.manager.list_default_p2p_topics().await;\r\n        topics\r\n            .into_iter()\r\n            .map(|t| {\r\n                TopicId::new(t).map_err(|err| {\r\n                    AppError::validation(\r\n                        ValidationFailureKind::Generic,\r\n                        format!(\"Invalid topic identifier returned: {err}\"),\r\n                    )\r\n                })\r\n            })\r\n            .collect()\r\n    }\r\n}\r\n\r\nfn log_validation_failure(event: &DomainEvent, kind: ValidationFailureKind, message: Option<&str>) {\r\n    if let Ok(mut map) = VALIDATION_LOG_WINDOWS.lock() {\r\n        let entry = map.entry(kind).or_insert(ValidationLogWindow {\r\n            window_start: Instant::now(),\r\n            count: 0,\r\n        });\r\n        if entry.window_start.elapsed() > VALIDATION_LOG_WINDOW {\r\n            entry.window_start = Instant::now();\r\n            entry.count = 0;\r\n        }\r\n        entry.count += 1;\r\n        let log_message = message.unwrap_or(\"\");\r\n        let event_kind = u32::from(event.kind);\r\n        let event_id = event.id.to_hex();\r\n        if entry.count <= VALIDATION_WARN_THRESHOLD {\r\n            tracing::warn!(\r\n                reason = %kind,\r\n                event_id = %event_id,\r\n                event_kind,\r\n                message = log_message,\r\n                \"dropped invalid nostr event\",\r\n            );\r\n        } else {\r\n            tracing::debug!(\r\n                reason = %kind,\r\n                event_id = %event_id,\r\n                event_kind,\r\n                message = log_message,\r\n                \"dropped invalid nostr event\",\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":37,"address":[22280162,22280144],"length":1,"stats":{"Line":0}},{"line":50,"address":[22280208,22280728],"length":1,"stats":{"Line":1}},{"line":52,"address":[20548302],"length":1,"stats":{"Line":1}},{"line":53,"address":[22177381],"length":1,"stats":{"Line":1}},{"line":54,"address":[20548387],"length":1,"stats":{"Line":1}},{"line":55,"address":[22163753],"length":1,"stats":{"Line":1}},{"line":56,"address":[22238410],"length":1,"stats":{"Line":1}},{"line":57,"address":[16418462,16418158,16418416],"length":1,"stats":{"Line":3}},{"line":300,"address":[22170992,22171179],"length":1,"stats":{"Line":1}},{"line":303,"address":[16418636,16418555],"length":1,"stats":{"Line":2}},{"line":307,"address":[22178192],"length":1,"stats":{"Line":0}},{"line":308,"address":[22171246],"length":1,"stats":{"Line":0}},{"line":309,"address":[22377584,22377602],"length":1,"stats":{"Line":0}},{"line":312,"address":[22246176,22246327],"length":1,"stats":{"Line":0}},{"line":313,"address":[16419136,16418984,16419053,16419355],"length":1,"stats":{"Line":0}},{"line":314,"address":[22246527],"length":1,"stats":{"Line":0}},{"line":315,"address":[22171637],"length":1,"stats":{"Line":0}},{"line":316,"address":[16419162,16419221],"length":1,"stats":{"Line":0}},{"line":321,"address":[22178848,22178999],"length":1,"stats":{"Line":0}},{"line":322,"address":[16419416,16419568,16419787,16419485],"length":1,"stats":{"Line":0}},{"line":323,"address":[22378511],"length":1,"stats":{"Line":0}},{"line":324,"address":[22378357],"length":1,"stats":{"Line":0}},{"line":325,"address":[22239941,22239882],"length":1,"stats":{"Line":0}},{"line":330,"address":[22180383,22179280,22179734,22179315,22179385,22179360,22180362,22179549],"length":1,"stats":{"Line":0}},{"line":331,"address":[20550468,20550425,20550646,20550536],"length":1,"stats":{"Line":0}},{"line":332,"address":[16420860,16420887,16420531],"length":1,"stats":{"Line":0}},{"line":335,"address":[20551280,20551518,20551312,20553952,20551293,20551467,20551668,20551343],"length":1,"stats":{"Line":4}},{"line":336,"address":[19412004],"length":1,"stats":{"Line":2}},{"line":337,"address":[22167550,22167645],"length":1,"stats":{"Line":2}},{"line":338,"address":[20552178],"length":1,"stats":{"Line":0}},{"line":340,"address":[22244009,22242286],"length":1,"stats":{"Line":0}},{"line":341,"address":[22388959,22286714,22286213,22388825,22286112],"length":1,"stats":{"Line":0}},{"line":347,"address":[22169568,22169805],"length":1,"stats":{"Line":1}},{"line":348,"address":[22244182],"length":1,"stats":{"Line":1}},{"line":349,"address":[22183375],"length":1,"stats":{"Line":0}},{"line":350,"address":[16423937],"length":1,"stats":{"Line":0}},{"line":351,"address":[22183492],"length":1,"stats":{"Line":0}},{"line":353,"address":[20554189],"length":1,"stats":{"Line":1}},{"line":354,"address":[16423979],"length":1,"stats":{"Line":1}},{"line":355,"address":[22286505],"length":1,"stats":{"Line":1}},{"line":362,"address":[22389279,22389456,22389491,22390033,22389600,22389762,22390139,22390818,22389727,22390631],"length":1,"stats":{"Line":4}},{"line":364,"address":[20658688,20658890,20657866,20658735,20657969,20658826,20658152,20659987,20659470],"length":1,"stats":{"Line":5}},{"line":365,"address":[22286432,22287063,22286747,22286572],"length":1,"stats":{"Line":2}},{"line":366,"address":[22347540,22347839,22348202,22348108,22347772,22348352],"length":1,"stats":{"Line":6}},{"line":367,"address":[22347735],"length":1,"stats":{"Line":1}},{"line":368,"address":[11975156],"length":1,"stats":{"Line":3}},{"line":369,"address":[22486784,22487234,22487216],"length":1,"stats":{"Line":3}},{"line":370,"address":[22287441,22287554,22286509,22287680],"length":1,"stats":{"Line":2}},{"line":371,"address":[16528402],"length":1,"stats":{"Line":1}},{"line":373,"address":[11829617],"length":1,"stats":{"Line":3}},{"line":374,"address":[22485160],"length":1,"stats":{"Line":1}},{"line":377,"address":[22485203],"length":1,"stats":{"Line":1}},{"line":379,"address":[22388796,22388885],"length":1,"stats":{"Line":2}},{"line":381,"address":[22346767],"length":1,"stats":{"Line":1}},{"line":382,"address":[22388823,22389013],"length":1,"stats":{"Line":2}},{"line":383,"address":[22385127],"length":1,"stats":{"Line":0}},{"line":384,"address":[22347040],"length":1,"stats":{"Line":0}},{"line":386,"address":[22272525,22272437],"length":1,"stats":{"Line":2}},{"line":391,"address":[22390535],"length":1,"stats":{"Line":1}},{"line":394,"address":[22387200,22387644,22387964,22387397,22387420,22387314,22387235,22387030],"length":1,"stats":{"Line":5}},{"line":395,"address":[22275176],"length":1,"stats":{"Line":1}},{"line":396,"address":[22282218,22282382,22281672,22282064,22282893,22281854,22282178,22281600,22282099],"length":1,"stats":{"Line":5}},{"line":397,"address":[22488437,22488573,22488902,22489179,22488632,22488804,22489098],"length":1,"stats":{"Line":7}},{"line":399,"address":[22392128],"length":1,"stats":{"Line":1}},{"line":400,"address":[22350121,22350013,22350372,22350222,22350165],"length":1,"stats":{"Line":3}},{"line":401,"address":[22388850,22388832,22388688],"length":1,"stats":{"Line":3}},{"line":402,"address":[22276060,22275929],"length":1,"stats":{"Line":0}},{"line":404,"address":[22391612,22391501,22391555,22391758,22391277],"length":1,"stats":{"Line":3}},{"line":405,"address":[22488240],"length":1,"stats":{"Line":1}},{"line":409,"address":[22395737,22395064,22394676,22394981,22395087,22394899,22395414,22394864],"length":1,"stats":{"Line":0}},{"line":417,"address":[22351957],"length":1,"stats":{"Line":0}},{"line":418,"address":[22490032,22490328,22490146,22490544,22490693,22490594,22490786,22491568,22492076],"length":1,"stats":{"Line":0}},{"line":419,"address":[22395997,22395952,22396241,22395872],"length":1,"stats":{"Line":0}},{"line":420,"address":[22278076,22277761,22277955,22277694],"length":1,"stats":{"Line":0}},{"line":422,"address":[22284485],"length":1,"stats":{"Line":0}},{"line":425,"address":[22360480,22360519,22360266,22359557,22359887,22359972,22360153],"length":1,"stats":{"Line":0}},{"line":428,"address":[22291921],"length":1,"stats":{"Line":0}},{"line":429,"address":[22285010],"length":1,"stats":{"Line":0}},{"line":430,"address":[22292049],"length":1,"stats":{"Line":0}},{"line":431,"address":[22352929,22352945],"length":1,"stats":{"Line":0}},{"line":432,"address":[22352952,22352941],"length":1,"stats":{"Line":0}},{"line":434,"address":[11370292],"length":1,"stats":{"Line":0}},{"line":435,"address":[16533346,16533216,16533328],"length":1,"stats":{"Line":0}},{"line":436,"address":[22278994,22278857],"length":1,"stats":{"Line":0}},{"line":438,"address":[22351693,22351312,22351639,22351750,22351896],"length":1,"stats":{"Line":0}},{"line":439,"address":[20663081],"length":1,"stats":{"Line":0}},{"line":443,"address":[22361692,22361148,22361372,22361125,22360732,22360928,22360963,22361042],"length":1,"stats":{"Line":0}},{"line":448,"address":[22396728],"length":1,"stats":{"Line":0}},{"line":449,"address":[22288165,22286512,22287139,22286584,22287666,22287099,22286976,22287014,22286766],"length":1,"stats":{"Line":0}},{"line":450,"address":[16534593,16535136,16534706,16534855],"length":1,"stats":{"Line":0}},{"line":451,"address":[16534822,16535030,16535089,16535427,16535641,16535323,16535680],"length":1,"stats":{"Line":0}},{"line":453,"address":[22355248],"length":1,"stats":{"Line":0}},{"line":454,"address":[11858596],"length":1,"stats":{"Line":0}},{"line":455,"address":[22281392,22281289,22281410],"length":1,"stats":{"Line":0}},{"line":456,"address":[22281234,22281371],"length":1,"stats":{"Line":0}},{"line":458,"address":[22396467,22396524,22396413,22396189,22396670],"length":1,"stats":{"Line":0}},{"line":459,"address":[16534384],"length":1,"stats":{"Line":0}},{"line":463,"address":[22281747,22282144,22281932,22281826,22282464,22281566,22281909,22281712],"length":1,"stats":{"Line":0}},{"line":467,"address":[22289164],"length":1,"stats":{"Line":0}},{"line":468,"address":[16537989,16536902,16536951,16536336,16536578,16536396,16537459,16536784,16536819],"length":1,"stats":{"Line":0}},{"line":469,"address":[20668166,20668019,20668431,20667877],"length":1,"stats":{"Line":0}},{"line":470,"address":[22396082,22396296,22396384,22395536,22395752,22395811,22395988],"length":1,"stats":{"Line":0}},{"line":472,"address":[20668289],"length":1,"stats":{"Line":0}},{"line":473,"address":[11976964],"length":1,"stats":{"Line":0}},{"line":474,"address":[22283746,22283544,22283728],"length":1,"stats":{"Line":0}},{"line":475,"address":[22496561],"length":1,"stats":{"Line":0}},{"line":477,"address":[20667181,20667439,20667492,20667405,20667634],"length":1,"stats":{"Line":0}},{"line":478,"address":[22399012],"length":1,"stats":{"Line":0}},{"line":482,"address":[22358949,22359549,22358972,22358866,22358527,22358787,22358752,22359229],"length":1,"stats":{"Line":0}},{"line":487,"address":[20669941],"length":1,"stats":{"Line":0}},{"line":488,"address":[16539318,16540212,16538889,16539280,16540240,16538805,16539434,16539486,16539071],"length":1,"stats":{"Line":0}},{"line":489,"address":[22367021,22366759,22367437,22366593],"length":1,"stats":{"Line":0}},{"line":492,"address":[22403741],"length":1,"stats":{"Line":0}},{"line":493,"address":[22292201,22293166,22292852,22292952,22293260,22292528,22292619],"length":1,"stats":{"Line":0}},{"line":495,"address":[16540838,16540816,16540180,16539907,16540100],"length":1,"stats":{"Line":0}},{"line":496,"address":[16540420,16540154,16540108,16540272,16539461],"length":1,"stats":{"Line":0}},{"line":497,"address":[22499650,22499406,22499632],"length":1,"stats":{"Line":0}},{"line":498,"address":[22398983],"length":1,"stats":{"Line":0}},{"line":500,"address":[11815844],"length":1,"stats":{"Line":0}},{"line":501,"address":[22284865],"length":1,"stats":{"Line":0}},{"line":505,"address":[22361634,22361520,22361329,22361555,22361740,22361717,22362272,22361952],"length":1,"stats":{"Line":0}},{"line":506,"address":[22294380],"length":1,"stats":{"Line":0}},{"line":507,"address":[22399952,22401450,22400961,22400548,22400508,22400012,22400194,22400400,22400435],"length":1,"stats":{"Line":0}},{"line":508,"address":[22362611,22362480,22362802,22362373],"length":1,"stats":{"Line":0}},{"line":509,"address":[22295525,22295174,22294773,22294898,22294957,22295272,22295486],"length":1,"stats":{"Line":0}},{"line":511,"address":[22288105],"length":1,"stats":{"Line":0}},{"line":512,"address":[11853268],"length":1,"stats":{"Line":0}},{"line":513,"address":[22302528,22302414,22302546],"length":1,"stats":{"Line":0}},{"line":514,"address":[22370256,22370119],"length":1,"stats":{"Line":0}},{"line":516,"address":[11930356],"length":1,"stats":{"Line":0}},{"line":517,"address":[22287588],"length":1,"stats":{"Line":0}},{"line":521,"address":[22502585,22502163,22502331,22502242,22502895,22502009,22502354,22502128],"length":1,"stats":{"Line":0}},{"line":523,"address":[22407670,22407949,22407763,22408023],"length":1,"stats":{"Line":0}},{"line":525,"address":[22289545,22289444,22289488,22289681,22289197],"length":1,"stats":{"Line":0}},{"line":526,"address":[22296624,22296642],"length":1,"stats":{"Line":0}},{"line":527,"address":[22502826],"length":1,"stats":{"Line":0}},{"line":531,"address":[22371529,22371762,22372459,22371648,22371851,22371874,22371683,22372104],"length":1,"stats":{"Line":0}},{"line":532,"address":[11930244],"length":1,"stats":{"Line":0}},{"line":533,"address":[22372333],"length":1,"stats":{"Line":0}},{"line":536,"address":[22403824,22404577,22404810,22403683,22404086,22404060,22403862,22403968],"length":1,"stats":{"Line":0}},{"line":537,"address":[16545884,16545801],"length":1,"stats":{"Line":0}},{"line":539,"address":[16546483,16546448],"length":1,"stats":{"Line":0}},{"line":541,"address":[11903254],"length":1,"stats":{"Line":0}},{"line":542,"address":[22305820],"length":1,"stats":{"Line":0}},{"line":545,"address":[22410640,22410866,22410675,22410843,22410521,22411425,22410754,22411093],"length":1,"stats":{"Line":0}},{"line":546,"address":[11898036],"length":1,"stats":{"Line":0}},{"line":547,"address":[16547334],"length":1,"stats":{"Line":0}},{"line":549,"address":[22367744],"length":1,"stats":{"Line":0}},{"line":550,"address":[22374752,22374704,22374971],"length":1,"stats":{"Line":0}},{"line":551,"address":[22300191],"length":1,"stats":{"Line":0}},{"line":552,"address":[22307013],"length":1,"stats":{"Line":0}},{"line":553,"address":[22411546,22411605],"length":1,"stats":{"Line":0}},{"line":561,"address":[16425462,16429349,16424224],"length":1,"stats":{"Line":0}},{"line":562,"address":[22183745],"length":1,"stats":{"Line":0}},{"line":563,"address":[22288444,22288346,22288512],"length":1,"stats":{"Line":0}},{"line":564,"address":[22170183],"length":1,"stats":{"Line":0}},{"line":567,"address":[22251821,22252017],"length":1,"stats":{"Line":0}},{"line":568,"address":[22251955],"length":1,"stats":{"Line":0}},{"line":569,"address":[22283194],"length":1,"stats":{"Line":0}},{"line":571,"address":[22288699,22288855,22288818],"length":1,"stats":{"Line":0}},{"line":572,"address":[22383605,22383683],"length":1,"stats":{"Line":0}},{"line":573,"address":[22283331],"length":1,"stats":{"Line":0}},{"line":574,"address":[22283377],"length":1,"stats":{"Line":0}},{"line":575,"address":[22170700],"length":1,"stats":{"Line":0}},{"line":576,"address":[22252254,22254467,22375199,22375065],"length":1,"stats":{"Line":0}},{"line":584,"address":[22252816,22252336,22375695,22252680,22252226,22375561],"length":1,"stats":{"Line":0}}],"covered":43,"coverable":166},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","handler.rs"],"content":"use crate::infrastructure::database::connection_pool::ConnectionPool;\nuse anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, info};\n\n/// イベントコールバックの型エイリアス\ntype EventCallback = Arc<dyn Fn(Event) + Send + Sync>;\n\n/// Nostrイベントハンドラー\npub struct EventHandler {\n    event_callbacks: Arc<RwLock<Vec<EventCallback>>>,\n    connection_pool: Option<ConnectionPool>,\n}\n\nimpl EventHandler {\n    /// 新しいEventHandlerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            event_callbacks: Arc::new(RwLock::new(Vec::new())),\n            connection_pool: None,\n        }\n    }\n\n    /// データベースプールを設定\n    pub fn set_connection_pool(&mut self, pool: ConnectionPool) {\n        self.connection_pool = Some(pool);\n    }\n\n    pub async fn register_callback(&self, callback: EventCallback) {\n        let mut callbacks = self.event_callbacks.write().await;\n        callbacks.push(callback);\n    }\n\n    /// イベントを処理\n    pub async fn handle_event(&self, event: Event) -> Result<()> {\n        debug!(\"Handling event: {}\", event.id);\n\n        let callbacks = self.event_callbacks.read().await;\n        for callback in callbacks.iter() {\n            callback(event.clone());\n        }\n\n        // イベントの種類に応じた処理\n        match event.kind {\n            Kind::TextNote => {\n                self.handle_text_note(&event).await?;\n            }\n            Kind::Metadata => {\n                self.handle_metadata(&event).await?;\n            }\n            Kind::ContactList => {\n                self.handle_contact_list(&event).await?;\n            }\n            Kind::Reaction => {\n                self.handle_reaction(&event).await?;\n            }\n            _ => {\n                debug!(\"Unhandled event kind: {:?}\", event.kind);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// テキストノートイベントを処理\n    async fn handle_text_note(&self, event: &Event) -> Result<()> {\n        info!(\n            \"Received text note from {}: {}\",\n            event.pubkey, event.content\n        );\n\n        // データベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let event_id = event.id.to_string();\n            let public_key = event.pubkey.to_string();\n            let created_at = event.created_at.as_secs() as i64;\n            let kind = event.kind.as_u16() as i64;\n            let content = event.content.clone();\n            let tags = serde_json::to_string(&event.tags)?;\n            let signature = event.sig.to_string();\n            let saved_at = chrono::Utc::now().timestamp();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO events (event_id, public_key, created_at, kind, content, tags, sig, saved_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(event_id) DO NOTHING\n                \"#,\n                event_id,\n                public_key,\n                created_at,\n                kind,\n                content,\n                tags,\n                signature,\n                saved_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Text note saved to database: {}\", event.id);\n\n            // イベントのタグからトピックIDを抽出し、マッピングを保存（冪等）\n            // 対象: Hashtag(\"t\") と Custom(\"topic\")\n            for tag in event.tags.iter() {\n                if let Some(nostr_sdk::TagStandard::Hashtag(topic)) = tag.as_standardized() {\n                    let _ = sqlx::query(\n                        r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                    )\n                    .bind(event.id.to_string())\n                    .bind(topic)\n                    .bind(chrono::Utc::now().timestamp_millis())\n                    .execute(pool.get_pool())\n                    .await;\n                }\n                // カスタムタグ 'topic'\n                if tag.kind().to_string() == \"topic\" {\n                    if let Some(content) = tag.content() {\n                        let _ = sqlx::query(\n                            r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                        )\n                        .bind(event.id.to_string())\n                        .bind(content)\n                        .bind(chrono::Utc::now().timestamp_millis())\n                        .execute(pool.get_pool())\n                        .await;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// メタデータイベントを処理\n    async fn handle_metadata(&self, event: &Event) -> Result<()> {\n        info!(\"Received metadata update from {}\", event.pubkey);\n\n        // メタデータをパースしてデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let metadata: serde_json::Value = serde_json::from_str(&event.content)?;\n            let display_name = metadata\n                .get(\"name\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let about = metadata\n                .get(\"about\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let picture_url = metadata\n                .get(\"picture\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let banner_url = metadata\n                .get(\"banner\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let nip05 = metadata\n                .get(\"nip05\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let created_at = event.created_at.as_secs() as i64;\n            let updated_at = chrono::Utc::now().timestamp();\n            let public_key = event.pubkey.to_string();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO profiles (public_key, display_name, about, picture_url, banner_url, nip05, created_at, updated_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(public_key) DO UPDATE SET\n                    display_name = excluded.display_name,\n                    about = excluded.about,\n                    picture_url = excluded.picture_url,\n                    banner_url = excluded.banner_url,\n                    nip05 = excluded.nip05,\n                    updated_at = excluded.updated_at\n                \"#,\n                public_key,\n                display_name,\n                about,\n                picture_url,\n                banner_url,\n                nip05,\n                created_at,\n                updated_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Profile metadata saved to database for: {}\", event.pubkey);\n        }\n\n        Ok(())\n    }\n\n    /// コンタクトリストイベントを処理\n    async fn handle_contact_list(&self, event: &Event) -> Result<()> {\n        info!(\"Received contact list from {}\", event.pubkey);\n\n        // フォロー関係をデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            // 既存のフォロー関係を削除\n            let follower_pubkey = event.pubkey.to_string();\n            sqlx::query!(\n                r#\"DELETE FROM follows WHERE follower_pubkey = ?\"#,\n                follower_pubkey\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            // 新しいフォロー関係を追加\n            for tag in event.tags.iter() {\n                if let Some(TagStandard::PublicKey { public_key, .. }) = tag.as_standardized() {\n                    let followed_pubkey = public_key.to_string();\n                    let created_at = chrono::Utc::now().timestamp();\n                    sqlx::query!(\n                        r#\"\n                        INSERT INTO follows (follower_pubkey, followed_pubkey, created_at)\n                        VALUES (?1, ?2, ?3)\n                        ON CONFLICT(follower_pubkey, followed_pubkey) DO NOTHING\n                        \"#,\n                        follower_pubkey,\n                        followed_pubkey,\n                        created_at\n                    )\n                    .execute(pool.get_pool())\n                    .await?;\n                }\n            }\n\n            debug!(\n                \"Contact list processed and saved for: {}\",\n                event.pubkey.to_string()\n            );\n        }\n\n        Ok(())\n    }\n\n    /// リアクションイベントを処理\n    async fn handle_reaction(&self, event: &Event) -> Result<()> {\n        info!(\"Received reaction from {}: {}\", event.pubkey, event.content);\n\n        // リアクションをデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            if event.tags.is_empty() || event.content.is_empty() {\n                return Ok(());\n            }\n\n            let Some(first_tag) = event.tags.get(0) else {\n                return Ok(());\n            };\n            let Some(target_event_id) = first_tag.content() else {\n                return Ok(());\n            };\n\n            let reactor_pubkey = event.pubkey.to_string();\n            let reaction_content = event.content.clone();\n            let created_at = event.created_at.as_secs() as i64;\n            let updated_at = chrono::Utc::now().timestamp();\n            sqlx::query!(\n                r#\"\n                INSERT INTO reactions (target_event_id, reactor_pubkey, reaction_content, created_at, updated_at)\n                VALUES (?1, ?2, ?3, ?4, ?5)\n                ON CONFLICT(reactor_pubkey, target_event_id) DO UPDATE SET\n                    reaction_content = excluded.reaction_content,\n                    updated_at = excluded.updated_at\n                \"#,\n                target_event_id,\n                reactor_pubkey,\n                reaction_content,\n                created_at,\n                updated_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Reaction saved to database: {}\", event.id);\n        }\n\n        Ok(())\n    }\n}\n\nimpl Default for EventHandler {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[24260080],"length":1,"stats":{"Line":4}},{"line":21,"address":[16601748],"length":1,"stats":{"Line":4}},{"line":27,"address":[16597904,16597957],"length":1,"stats":{"Line":2}},{"line":28,"address":[24260195,24260260],"length":1,"stats":{"Line":4}},{"line":31,"address":[16698591,16698402,16698384,16698432,16698762,16699170,16698457,16699191],"length":1,"stats":{"Line":0}},{"line":32,"address":[16698794,16698618,16698575,16698678],"length":1,"stats":{"Line":0}},{"line":33,"address":[16492780,16492713],"length":1,"stats":{"Line":0}},{"line":37,"address":[16601051,16598915,16598880,16605569,16599156,16598960,16604110,16599006],"length":1,"stats":{"Line":8}},{"line":38,"address":[16646623,16493421,16646489,16493205,16493937],"length":1,"stats":{"Line":7}},{"line":40,"address":[24263355,24261458,24262085,24263210],"length":1,"stats":{"Line":4}},{"line":41,"address":[16502788,16502425,16502518],"length":1,"stats":{"Line":4}},{"line":42,"address":[16609589,16607332],"length":1,"stats":{"Line":0}},{"line":46,"address":[16488975],"length":1,"stats":{"Line":2}},{"line":47,"address":[16604429],"length":1,"stats":{"Line":2}},{"line":48,"address":[11561884],"length":1,"stats":{"Line":5}},{"line":50,"address":[16604801],"length":1,"stats":{"Line":0}},{"line":51,"address":[16702353,16702177,16705174,16699596,16704883],"length":1,"stats":{"Line":0}},{"line":53,"address":[16705517],"length":1,"stats":{"Line":0}},{"line":54,"address":[10803924],"length":1,"stats":{"Line":0}},{"line":56,"address":[24267769],"length":1,"stats":{"Line":0}},{"line":57,"address":[16602276,16599270,16605211,16605502,16601941,16605690],"length":1,"stats":{"Line":0}},{"line":60,"address":[16721721,16571716,16571196,16570594,16721855],"length":1,"stats":{"Line":0}},{"line":64,"address":[24265124],"length":1,"stats":{"Line":2}},{"line":68,"address":[16574560,16574592,16574623,16574826,16579175,16574573,16574911,16579248],"length":1,"stats":{"Line":8}},{"line":69,"address":[16647615,16500768,16647481,16500059,16500232],"length":1,"stats":{"Line":7}},{"line":75,"address":[24268904,24270145],"length":1,"stats":{"Line":3}},{"line":76,"address":[16569773],"length":1,"stats":{"Line":1}},{"line":77,"address":[16611869],"length":1,"stats":{"Line":1}},{"line":78,"address":[16495395,16495308],"length":1,"stats":{"Line":2}},{"line":79,"address":[24270383],"length":1,"stats":{"Line":1}},{"line":80,"address":[16495464],"length":1,"stats":{"Line":1}},{"line":81,"address":[16613783,16615982,16614028,16613862],"length":1,"stats":{"Line":2}},{"line":82,"address":[16577223],"length":1,"stats":{"Line":1}},{"line":83,"address":[16509593,16509660],"length":1,"stats":{"Line":2}},{"line":85,"address":[24272982,24273152,24272529,24272857,24270944,24272459,24274899,24271238,24272640],"length":1,"stats":{"Line":6}},{"line":100,"address":[16614507,16615806,16615911,16615691],"length":1,"stats":{"Line":2}},{"line":101,"address":[16615874,16611624,16616048,16615814,16616217,16616416],"length":1,"stats":{"Line":4}},{"line":103,"address":[16572692,16717711,16572812,16717577,16573329],"length":1,"stats":{"Line":3}},{"line":107,"address":[16581348,16582062,16580212,16581999],"length":1,"stats":{"Line":4}},{"line":108,"address":[16618980,16618853,16619093],"length":1,"stats":{"Line":3}},{"line":112,"address":[16508605,16507809,16507645,16507688],"length":1,"stats":{"Line":2}},{"line":113,"address":[16613807],"length":1,"stats":{"Line":1}},{"line":114,"address":[24276225,24276087,24276768,24276036],"length":1,"stats":{"Line":2}},{"line":115,"address":[16575660,16576352,16575966,16575857],"length":1,"stats":{"Line":2}},{"line":116,"address":[11709544],"length":1,"stats":{"Line":5}},{"line":119,"address":[16613476,16614547],"length":1,"stats":{"Line":2}},{"line":120,"address":[16502070],"length":1,"stats":{"Line":0}},{"line":124,"address":[16615588,16614981,16614938,16615107],"length":1,"stats":{"Line":0}},{"line":125,"address":[24277457],"length":1,"stats":{"Line":0}},{"line":126,"address":[17068704,17068755,17068893,17069106],"length":1,"stats":{"Line":0}},{"line":127,"address":[16502446,16502823,16502643,16502750],"length":1,"stats":{"Line":0}},{"line":128,"address":[17069069,17059762,17069029,17066697,17066464],"length":1,"stats":{"Line":0}},{"line":134,"address":[16576732],"length":1,"stats":{"Line":2}},{"line":138,"address":[16615874,16620719,16615831,16615616,16615629,16615679,16615648,16620605],"length":1,"stats":{"Line":0}},{"line":139,"address":[16503099,16643481,16503227,16503763,16643615],"length":1,"stats":{"Line":0}},{"line":142,"address":[16616411,16617550],"length":1,"stats":{"Line":0}},{"line":143,"address":[16617630,16617558,16617808,16620644],"length":1,"stats":{"Line":0}},{"line":144,"address":[16621845,16621701],"length":1,"stats":{"Line":0}},{"line":146,"address":[24285305,24285296],"length":1,"stats":{"Line":0}},{"line":148,"address":[16512154,16512055],"length":1,"stats":{"Line":0}},{"line":150,"address":[16510361,16510352],"length":1,"stats":{"Line":0}},{"line":152,"address":[16618140,16618239],"length":1,"stats":{"Line":0}},{"line":154,"address":[16627033,16627024],"length":1,"stats":{"Line":0}},{"line":156,"address":[16519460,16519361],"length":1,"stats":{"Line":0}},{"line":158,"address":[16628713,16628704],"length":1,"stats":{"Line":0}},{"line":160,"address":[16505865,16505766],"length":1,"stats":{"Line":0}},{"line":162,"address":[16628736,16628745],"length":1,"stats":{"Line":0}},{"line":164,"address":[16624222,16624315],"length":1,"stats":{"Line":0}},{"line":165,"address":[16624330],"length":1,"stats":{"Line":0}},{"line":166,"address":[16618833],"length":1,"stats":{"Line":0}},{"line":168,"address":[16582391,16583055,16581053,16582502,16582885,16580755,16582270,16584730,16582760],"length":1,"stats":{"Line":0}},{"line":189,"address":[16514394,16514653,16514497,16513202],"length":1,"stats":{"Line":0}},{"line":190,"address":[11539927],"length":1,"stats":{"Line":0}},{"line":192,"address":[16626795,16764191,16626675,16627303,16764057],"length":1,"stats":{"Line":0}},{"line":195,"address":[16518653],"length":1,"stats":{"Line":0}},{"line":199,"address":[16629060,16628800,16628768,16628781,16628996,16631517,16631548,16628831],"length":1,"stats":{"Line":0}},{"line":200,"address":[16764553,16628968,16764687,16629650,16629114],"length":1,"stats":{"Line":0}},{"line":203,"address":[17077498,17078658],"length":1,"stats":{"Line":0}},{"line":205,"address":[16519241],"length":1,"stats":{"Line":0}},{"line":206,"address":[16594538,16595049,16594656,16595226,16595377,16594025,16594758,16594119,16594930],"length":1,"stats":{"Line":0}},{"line":210,"address":[16725628,16726010,16726125,16726272],"length":1,"stats":{"Line":0}},{"line":211,"address":[11512511],"length":1,"stats":{"Line":0}},{"line":214,"address":[16527383,16527516,16528180,16528245],"length":1,"stats":{"Line":0}},{"line":215,"address":[16631141,16632970],"length":1,"stats":{"Line":0}},{"line":216,"address":[16629142],"length":1,"stats":{"Line":0}},{"line":217,"address":[16516461],"length":1,"stats":{"Line":0}},{"line":218,"address":[16632495,16632663,16635551,16634822,16635688,16635621,16632328,16634960],"length":1,"stats":{"Line":0}},{"line":228,"address":[16634920,16635586,16635479,16635656],"length":1,"stats":{"Line":0}},{"line":229,"address":[10879758],"length":1,"stats":{"Line":0}},{"line":233,"address":[16590516,16590170],"length":1,"stats":{"Line":0}},{"line":239,"address":[17078701],"length":1,"stats":{"Line":0}},{"line":243,"address":[24296388,24292511,24292706,24292480,24292663,24292461,24296486,24292448],"length":1,"stats":{"Line":0}},{"line":244,"address":[16631027,16630363,16630491,16760857,16760991],"length":1,"stats":{"Line":0}},{"line":247,"address":[16731339,16732580],"length":1,"stats":{"Line":0}},{"line":248,"address":[24294492,24294602,24294542],"length":1,"stats":{"Line":0}},{"line":249,"address":[16637890],"length":1,"stats":{"Line":0}},{"line":252,"address":[24294608],"length":1,"stats":{"Line":0}},{"line":253,"address":[16526531],"length":1,"stats":{"Line":0}},{"line":255,"address":[16632484,16632428],"length":1,"stats":{"Line":0}},{"line":256,"address":[17086053],"length":1,"stats":{"Line":0}},{"line":259,"address":[17086022],"length":1,"stats":{"Line":0}},{"line":260,"address":[17086070],"length":1,"stats":{"Line":0}},{"line":261,"address":[16519984,16520071],"length":1,"stats":{"Line":0}},{"line":262,"address":[16601603],"length":1,"stats":{"Line":0}},{"line":263,"address":[16535076,16535181,16535542,16537274,16535712,16535006,16533928,16534134,16535420],"length":1,"stats":{"Line":0}},{"line":277,"address":[16633985,16634084,16633035,16633882],"length":1,"stats":{"Line":0}},{"line":278,"address":[16636005,16639830,16639634,16639577,16639996,16640192],"length":1,"stats":{"Line":0}},{"line":280,"address":[16535756,16663529,16536261,16663663,16535636],"length":1,"stats":{"Line":0}},{"line":283,"address":[16732614],"length":1,"stats":{"Line":0}},{"line":288,"address":[16736656],"length":1,"stats":{"Line":0}},{"line":289,"address":[16636289],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":111},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","core.rs"],"content":"use crate::application::ports::{\n    event_topic_store::EventTopicStore,\n    key_manager::{KeyManager, KeyPair},\n};\nuse crate::application::shared::default_topics::DefaultTopicsRegistry;\nuse crate::application::shared::nostr::EventPublisher;\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::infrastructure::event::{\n    handler::EventHandler, nostr_client_manager::NostrClientManager,\n};\nuse crate::infrastructure::p2p::GossipService;\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrイベントマネージャー - イベント処理の中心的な管理者\npub struct EventManager {\n    pub(crate) client_manager: Arc<RwLock<NostrClientManager>>,\n    pub(crate) event_handler: Arc<EventHandler>,\n    pub(crate) event_publisher: Arc<RwLock<EventPublisher>>,\n    pub(crate) default_topics: Arc<DefaultTopicsRegistry>,\n    is_initialized: Arc<RwLock<bool>>,\n    /// P2P配信用のGossipService（任意）\n    pub(crate) gossip_service: Arc<RwLock<Option<Arc<dyn GossipService>>>>,\n    /// 参照トピック解決用のEventTopicStore（任意）\n    pub(crate) event_topic_store: Arc<RwLock<Option<Arc<dyn EventTopicStore>>>>,\n}\n\nimpl EventManager {\n    /// 新しいEventManagerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(EventHandler::new()),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\n                DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            ])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_topic_store: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 新しいEventManagerインスタンスをConnectionPoolと共に作成\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        let mut event_handler = EventHandler::new();\n        event_handler.set_connection_pool(pool);\n\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(event_handler),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\n                DEFAULT_PUBLIC_TOPIC_ID.to_string(),\n            ])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_topic_store: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 既定の配信先トピックIDを設定\n    pub async fn set_default_p2p_topic_id(&self, topic_id: impl Into<String>) {\n        self.default_topics\n            .replace_with_single(topic_id.into())\n            .await;\n    }\n\n    /// 既定配信先トピックを一括設定（複数）\n    pub async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.default_topics.replace_all(topics).await;\n    }\n\n    /// 既定配信先トピックを追加\n    pub async fn add_default_p2p_topic(&self, topic_id: impl Into<String>) {\n        self.default_topics.add(topic_id.into()).await;\n    }\n\n    /// 既定配信先トピックを削除\n    pub async fn remove_default_p2p_topic(&self, topic_id: &str) {\n        self.default_topics.remove(topic_id).await;\n    }\n\n    /// 既定配信先トピック一覧を取得\n    pub async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.default_topics.list().await\n    }\n\n    pub async fn register_event_callback(&self, callback: Arc<dyn Fn(Event) + Send + Sync>) {\n        self.event_handler.register_callback(callback).await;\n    }\n\n    /// KeyManagerからの秘密鍵でマネージャーを初期化\n    pub async fn initialize_with_key_manager(\n        &self,\n        key_manager: &(dyn KeyManager + Send + Sync),\n    ) -> Result<()> {\n        let keypair = key_manager\n            .current_keypair()\n            .await\n            .map_err(|e| anyhow!(\"Failed to load current keypair: {e}\"))?;\n        self.initialize_with_keypair(&keypair).await\n    }\n\n    /// KeyPair を直接用いて EventManager を初期化\n    pub async fn initialize_with_keypair(&self, keypair: &KeyPair) -> Result<()> {\n        let secret_key = SecretKey::from_bech32(&keypair.nsec)\n            .map_err(|e| anyhow!(\"Invalid secret key: {e}\"))?;\n        let keys = Keys::new(secret_key);\n\n        // クライアントマネージャーを初期化\n        let mut client_manager = self.client_manager.write().await;\n        client_manager.init_with_keys(keys.secret_key()).await?;\n\n        // パブリッシャーに鍵を設定\n        let mut publisher = self.event_publisher.write().await;\n        publisher.set_keys(keys);\n\n        *self.is_initialized.write().await = true;\n\n        info!(\"EventManager initialized successfully\");\n        Ok(())\n    }\n\n    /// 特定のトピックをサブスクライブ\n    pub async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().hashtag(topic_id).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to topic: {}\", topic_id);\n        Ok(())\n    }\n\n    /// ユーザーの投稿をサブスクライブ\n    pub async fn subscribe_to_user(\n        &self,\n        pubkey: PublicKey,\n        since: Option<Timestamp>,\n    ) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().author(pubkey).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to user: {}\", pubkey);\n        Ok(())\n    }\n\n    /// 初期化状態を確認\n    pub(crate) async fn ensure_initialized(&self) -> Result<()> {\n        if !*self.is_initialized.read().await {\n            Err(anyhow!(\"EventManager not initialized\"))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// 公開鍵を取得\n    pub async fn get_public_key(&self) -> Option<PublicKey> {\n        let publisher = self.event_publisher.read().await;\n        if let Some(pk) = publisher.get_public_key() {\n            return Some(pk);\n        }\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.get_public_key()\n    }\n\n    /// 切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_manager = self.client_manager.read().await;\n        client_manager.disconnect().await?;\n        *self.is_initialized.write().await = false;\n        Ok(())\n    }\n}\n\nimpl Default for EventManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":34,"address":[24708511,24707648],"length":1,"stats":{"Line":2}},{"line":36,"address":[16082689],"length":1,"stats":{"Line":2}},{"line":37,"address":[15982465,15982393],"length":1,"stats":{"Line":6}},{"line":38,"address":[23644826,23644766],"length":1,"stats":{"Line":6}},{"line":39,"address":[16083068],"length":1,"stats":{"Line":3}},{"line":42,"address":[24708160,24708088],"length":1,"stats":{"Line":4}},{"line":43,"address":[23645275,23645177],"length":1,"stats":{"Line":4}},{"line":44,"address":[24708308,24708406],"length":1,"stats":{"Line":4}},{"line":49,"address":[15953237,15952096,15953265],"length":1,"stats":{"Line":1}},{"line":50,"address":[16083670,16083766],"length":1,"stats":{"Line":3}},{"line":51,"address":[16083776],"length":1,"stats":{"Line":2}},{"line":54,"address":[15884539],"length":1,"stats":{"Line":2}},{"line":55,"address":[15870860,15870940],"length":1,"stats":{"Line":4}},{"line":56,"address":[15945540,15945600],"length":1,"stats":{"Line":4}},{"line":57,"address":[15871154],"length":1,"stats":{"Line":2}},{"line":60,"address":[15952842,15952770],"length":1,"stats":{"Line":4}},{"line":61,"address":[15989647,15989745],"length":1,"stats":{"Line":4}},{"line":62,"address":[15946086,15946184],"length":1,"stats":{"Line":2}},{"line":67,"address":[15990064,15990082,15990112,15990137,15990529,15990772,15990299,15990751],"length":1,"stats":{"Line":0}},{"line":68,"address":[15953720,15953511,15953669],"length":1,"stats":{"Line":0}},{"line":69,"address":[23647082],"length":1,"stats":{"Line":0}},{"line":70,"address":[11708774],"length":1,"stats":{"Line":0}},{"line":74,"address":[15947541,15947771,15947792,15947104,15947177,15947152,15947313,15947112],"length":1,"stats":{"Line":8}},{"line":75,"address":[16086053,16085883,16085773,16085820],"length":1,"stats":{"Line":4}},{"line":79,"address":[24711303,24711120,24711145,24711731,24711072,24711521,24711752,24711090],"length":1,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[23648425,23648619,23648242,23648272,23648297,23648465,23648224,23648837],"length":1,"stats":{"Line":4}},{"line":85,"address":[15955195,15954996,15954949,15955071],"length":1,"stats":{"Line":2}},{"line":89,"address":[16087258,16086960,16086944,16086995,16087081,16087118,16087555,16086952],"length":1,"stats":{"Line":4}},{"line":90,"address":[15986693,15986799,15986740,15986922],"length":1,"stats":{"Line":2}},{"line":93,"address":[15991794,15991209,15991184,15991551,15991136,15991355,15991773,15991154],"length":1,"stats":{"Line":0}},{"line":94,"address":[11676827],"length":1,"stats":{"Line":0}},{"line":98,"address":[15949792],"length":1,"stats":{"Line":4}},{"line":102,"address":[15957678,15957224,15956884,15957042,15957839,15957376],"length":1,"stats":{"Line":16}},{"line":104,"address":[15988113,15988195,15988239,15988504,15988296],"length":1,"stats":{"Line":12}},{"line":105,"address":[23651584,23651599,23651121],"length":1,"stats":{"Line":0}},{"line":106,"address":[15988817,15989089,15988933,15988128],"length":1,"stats":{"Line":8}},{"line":110,"address":[15958680,15958399,15958349,15958368,15959875,15958336,15958559,15959352],"length":1,"stats":{"Line":12}},{"line":111,"address":[15951601,15951818,15952082,15952396],"length":1,"stats":{"Line":6}},{"line":112,"address":[15877474,15881488,15881503],"length":1,"stats":{"Line":0}},{"line":113,"address":[15994040,15994222],"length":1,"stats":{"Line":6}},{"line":116,"address":[11770964],"length":1,"stats":{"Line":6}},{"line":117,"address":[15959640,15959884,15960402,15960228,15959719,15958610],"length":1,"stats":{"Line":6}},{"line":120,"address":[15960194,15958631,15960278,15960543],"length":1,"stats":{"Line":12}},{"line":121,"address":[15886063,15886142],"length":1,"stats":{"Line":12}},{"line":123,"address":[16092514,16090204],"length":1,"stats":{"Line":6}},{"line":125,"address":[15996594,16055097,16055231,15997146],"length":1,"stats":{"Line":12}},{"line":126,"address":[15998749],"length":1,"stats":{"Line":6}},{"line":130,"address":[15998461,15998717,15998852,15998336,15999847,15998364,15998400,15998632],"length":1,"stats":{"Line":4}},{"line":131,"address":[11749953],"length":1,"stats":{"Line":4}},{"line":133,"address":[16095625,16095716],"length":1,"stats":{"Line":0}},{"line":134,"address":[15957347,15957599],"length":1,"stats":{"Line":0}},{"line":135,"address":[15889582,15889746],"length":1,"stats":{"Line":0}},{"line":138,"address":[11649605],"length":1,"stats":{"Line":0}},{"line":139,"address":[24721599,24721680,24722314,24723859,24720236],"length":1,"stats":{"Line":0}},{"line":141,"address":[15958802,16013679,15959399,16013545,15958882],"length":1,"stats":{"Line":0}},{"line":142,"address":[15898522],"length":1,"stats":{"Line":0}},{"line":146,"address":[15967392],"length":1,"stats":{"Line":0}},{"line":151,"address":[16003416,16004035,16003091,16002796,16002860,16002965],"length":1,"stats":{"Line":0}},{"line":153,"address":[15900529,15900623],"length":1,"stats":{"Line":0}},{"line":154,"address":[15894042,15893781],"length":1,"stats":{"Line":0}},{"line":155,"address":[15999744,15999914],"length":1,"stats":{"Line":0}},{"line":158,"address":[11531995],"length":1,"stats":{"Line":0}},{"line":159,"address":[23661238,23665064,23662824,23662735,23663504],"length":1,"stats":{"Line":0}},{"line":161,"address":[16014175,15963172,16014041,15963689,15963092],"length":1,"stats":{"Line":0}},{"line":162,"address":[15889052],"length":1,"stats":{"Line":0}},{"line":166,"address":[15896968,15896960,15897001,15897124,15897265,15897781,15896976,15897087],"length":1,"stats":{"Line":8}},{"line":167,"address":[15904273,15904043,15904090,15904149,15904755],"length":1,"stats":{"Line":6}},{"line":168,"address":[15904612],"length":1,"stats":{"Line":1}},{"line":170,"address":[16003687],"length":1,"stats":{"Line":2}},{"line":175,"address":[15965976,15965667,15965608,15965768,15965835,15966652,15965632,15965600],"length":1,"stats":{"Line":4}},{"line":176,"address":[15898200,15897987,15897931,15898076],"length":1,"stats":{"Line":2}},{"line":177,"address":[15973241,15973173],"length":1,"stats":{"Line":2}},{"line":178,"address":[15905550],"length":1,"stats":{"Line":3}},{"line":180,"address":[15973366],"length":1,"stats":{"Line":1}},{"line":182,"address":[24729137,24729808,24729929],"length":1,"stats":{"Line":1}},{"line":183,"address":[15899085,15899156],"length":1,"stats":{"Line":2}},{"line":187,"address":[24730408,24730272,24730280,24730484,24730288,24730628,24731069,24730316],"length":1,"stats":{"Line":4}},{"line":188,"address":[11571537],"length":1,"stats":{"Line":2}},{"line":189,"address":[15974628,15974153,15974709,15974822,15975128,15975284],"length":1,"stats":{"Line":2}},{"line":190,"address":[15907619,15907336,15906411,15907412],"length":1,"stats":{"Line":2}},{"line":191,"address":[16107268],"length":1,"stats":{"Line":1}},{"line":196,"address":[24731952],"length":1,"stats":{"Line":0}},{"line":197,"address":[15908008],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":84},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","mod.rs"],"content":"mod core;\nmod p2p;\nmod publishing;\n\npub use core::EventManager;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","p2p.rs"],"content":"use std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse anyhow::{Result, anyhow};\r\nuse nostr_sdk::prelude::*;\r\nuse tracing::error;\r\n\r\nuse super::EventManager;\r\nuse crate::application::ports::event_topic_store::EventTopicStore;\r\nuse crate::application::shared::mappers::nostr_event_to_domain_event;\r\nuse crate::domain::p2p::user_topic_id;\r\nuse crate::infrastructure::p2p::GossipService;\r\n\r\nimpl EventManager {\r\n    /// GossipServiceを接続（P2P配信用）。未設定でも動作は継続。\r\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\r\n        let mut gs = self.gossip_service.write().await;\r\n        *gs = Some(gossip);\r\n    }\r\n\r\n    /// EventTopicStoreを接続（参照トピック解決用）。未設定でも動作は継続。\r\n    pub async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>) {\r\n        let mut r = self.event_topic_store.write().await;\r\n        *r = Some(store);\r\n    }\r\n\r\n    /// P2Pネットワークから受信したNostrイベントを処理\r\n    pub async fn handle_p2p_event(&self, event: Event) -> Result<()> {\r\n        if let Err(e) = self.event_handler.handle_event(event.clone()).await {\r\n            error!(\"Error handling P2P event: {}\", e);\r\n            return Err(e);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 複数トピックへ冪等Join + 重複排除つきでブロードキャスト\r\n    pub(crate) async fn broadcast_to_topics(\r\n        &self,\r\n        gossip: &Arc<dyn GossipService>,\r\n        topics: &[String],\r\n        nostr_event: &Event,\r\n    ) -> Result<()> {\r\n        let mut uniq: HashSet<String> = HashSet::new();\r\n        for t in topics {\r\n            if !t.is_empty() {\r\n                uniq.insert(t.clone());\r\n            }\r\n        }\r\n        if uniq.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        let domain_event =\r\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\r\n        for topic in uniq.into_iter() {\r\n            let _ = gossip.join_topic(&topic, vec![]).await;\r\n            if let Err(e) = gossip.broadcast(&topic, &domain_event).await {\r\n                error!(\"Failed to broadcast to topic {}: {}\", topic, e);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) async fn broadcast_to_topic(\r\n        &self,\r\n        gossip: &Arc<dyn GossipService>,\r\n        topic_id: &str,\r\n        nostr_event: &Event,\r\n    ) -> Result<()> {\r\n        let domain_event =\r\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\r\n        let _ = gossip.join_topic(topic_id, vec![]).await;\r\n        gossip\r\n            .broadcast(topic_id, &domain_event)\r\n            .await\r\n            .map_err(|e| anyhow::anyhow!(\"{}\", e))?;\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) async fn resolve_topics_for_referenced_event(\r\n        &self,\r\n        event_id: &str,\r\n    ) -> Option<Vec<String>> {\r\n        if let Some(store) = self.event_topic_store.read().await.as_ref().cloned() {\r\n            match store.get_event_topics(event_id).await {\r\n                Ok(v) if !v.is_empty() => return Some(v),\r\n                _ => {}\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    pub(crate) async fn default_topics_with_user_topic(&self) -> Vec<String> {\r\n        let mut topics = self.default_topics.snapshot().await;\r\n        if let Some(pk) = self.get_public_key().await {\r\n            topics.insert(user_topic_id(&pk.to_string()));\r\n        }\r\n        topics.into_iter().collect()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[15968882,15968864],"length":1,"stats":{"Line":12}},{"line":17,"address":[23935506,23935463,23935574,23935670],"length":1,"stats":{"Line":6}},{"line":18,"address":[15137253,15137543,15137570],"length":1,"stats":{"Line":3}},{"line":22,"address":[16007024,16007042],"length":1,"stats":{"Line":8}},{"line":23,"address":[15350934,15351110,15350887,15350994],"length":1,"stats":{"Line":4}},{"line":24,"address":[15250949,15251239,15251266],"length":1,"stats":{"Line":2}},{"line":28,"address":[15894368,15894403],"length":1,"stats":{"Line":8}},{"line":29,"address":[11831793],"length":1,"stats":{"Line":5}},{"line":30,"address":[15139971,15139638,15262601,15140614,15262735,15140170],"length":1,"stats":{"Line":0}},{"line":31,"address":[23938499],"length":1,"stats":{"Line":0}},{"line":34,"address":[15259991],"length":1,"stats":{"Line":2}},{"line":38,"address":[15901232],"length":1,"stats":{"Line":1}},{"line":44,"address":[15260267],"length":1,"stats":{"Line":1}},{"line":45,"address":[15258896,15259014,15258790],"length":1,"stats":{"Line":3}},{"line":46,"address":[15142398,15143055],"length":1,"stats":{"Line":2}},{"line":47,"address":[15356145],"length":1,"stats":{"Line":1}},{"line":50,"address":[23940280,23940358],"length":1,"stats":{"Line":2}},{"line":51,"address":[23940387],"length":1,"stats":{"Line":0}},{"line":54,"address":[22917412,22917911,22922000,22922015,22917448,22917722],"length":1,"stats":{"Line":2}},{"line":56,"address":[15255364,15258755,15258816,15255546],"length":1,"stats":{"Line":4}},{"line":57,"address":[15159908,15156936,15160040,15155795],"length":1,"stats":{"Line":3}},{"line":58,"address":[11871816],"length":1,"stats":{"Line":3}},{"line":59,"address":[15357262,15357461,15476169,15476303,15356929,15357882],"length":1,"stats":{"Line":0}},{"line":62,"address":[15152974],"length":1,"stats":{"Line":1}},{"line":65,"address":[24732240],"length":1,"stats":{"Line":1}},{"line":71,"address":[15261920,15260191,15261935,15260548,15260324,15260881],"length":1,"stats":{"Line":2}},{"line":73,"address":[11758628],"length":1,"stats":{"Line":2}},{"line":74,"address":[15265224,15265346,15265287,15265516,15265641,15265782],"length":1,"stats":{"Line":5}},{"line":75,"address":[22923603],"length":1,"stats":{"Line":1}},{"line":76,"address":[11751867],"length":1,"stats":{"Line":3}},{"line":77,"address":[22924480,22924102,22924495],"length":1,"stats":{"Line":0}},{"line":78,"address":[15155872],"length":1,"stats":{"Line":1}},{"line":81,"address":[23669568],"length":1,"stats":{"Line":0}},{"line":85,"address":[19560223],"length":1,"stats":{"Line":0}},{"line":86,"address":[15363706,15363997,15363823,15363026],"length":1,"stats":{"Line":0}},{"line":87,"address":[15267964,15267863],"length":1,"stats":{"Line":0}},{"line":91,"address":[15363965],"length":1,"stats":{"Line":0}},{"line":94,"address":[15151648,15151851,15152436,15151683,15151992,15151784],"length":1,"stats":{"Line":0}},{"line":95,"address":[11774959],"length":1,"stats":{"Line":0}},{"line":96,"address":[19549954],"length":1,"stats":{"Line":0}},{"line":97,"address":[22927679,22927803],"length":1,"stats":{"Line":0}},{"line":99,"address":[22927939,22927716],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":42},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager","publishing.rs"],"content":"use std::collections::HashSet;\n\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse tracing::error;\n\nuse super::EventManager;\n\nimpl EventManager {\n    /// テキストノートを投稿\n    pub async fn publish_text_note(&self, content: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_text_note(content, vec![])?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = match client_manager.publish_event(event.clone()).await {\n            Ok(id) => id,\n            Err(e) => {\n                if std::env::var(\"KUKURI_ALLOW_NO_RELAY\")\n                    .map(|value| value == \"1\")\n                    .unwrap_or(false)\n                    && e.to_string().contains(\"no relays specified\")\n                {\n                    event.id\n                } else {\n                    return Err(e);\n                }\n            }\n        };\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast to P2P (text_note): {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// トピック投稿を作成・送信\n    pub async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_topic_post(topic_id, content, reply_to, scope, epoch)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = match client_manager.publish_event(event.clone()).await {\n            Ok(id) => id,\n            Err(e) => {\n                let msg = e.to_string();\n                let allow_no_relay = std::env::var(\"KUKURI_ALLOW_NO_RELAY\")\n                    .map(|value| value == \"1\")\n                    .unwrap_or(false)\n                    || msg.contains(\"no relays specified\")\n                    || msg.contains(\"not connected to any relays\");\n\n                if allow_no_relay {\n                    tracing::warn!(\n                        target: \"event_manager\",\n                        \"publish_event skipped (no relay connected): {msg}\"\n                    );\n                    event.id\n                } else {\n                    return Err(e);\n                }\n            }\n        };\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            if let Err(e) = self.broadcast_to_topic(&gossip, topic_id, &event).await {\n                error!(\"Failed to broadcast to P2P (topic {}): {}\", topic_id, e);\n            }\n        }\n\n        if let Some(store) = self.event_topic_store.read().await.as_ref().cloned() {\n            tracing::debug!(\n                target: \"event_manager\",\n                \"adding event_topic mapping for {}\",\n                event.id.to_hex()\n            );\n            let _ = store.add_event_topic(&event.id.to_string(), topic_id).await;\n        }\n\n        Ok(event_id)\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(&self, event_id: &EventId, reaction: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_reaction(event_id, reaction)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topic_list = if let Some(resolved_topics) = self\n                .resolve_topics_for_referenced_event(&event_id.to_hex())\n                .await\n            {\n                if resolved_topics.is_empty() {\n                    self.default_topics_with_user_topic().await\n                } else {\n                    let unique: HashSet<_> = resolved_topics.into_iter().collect();\n                    unique.into_iter().collect()\n                }\n            } else {\n                self.default_topics_with_user_topic().await\n            };\n\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topic_list, &event).await {\n                error!(\"Failed to broadcast reaction to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n\n    /// 投稿を再配信 (Repost) する\n    pub async fn publish_repost(&self, target: &EventId) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_repost(target)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topic_list = if let Some(resolved_topics) = self\n                .resolve_topics_for_referenced_event(&target.to_hex())\n                .await\n            {\n                if resolved_topics.is_empty() {\n                    self.default_topics_with_user_topic().await\n                } else {\n                    let unique: HashSet<_> = resolved_topics.into_iter().collect();\n                    unique.into_iter().collect()\n                }\n            } else {\n                self.default_topics_with_user_topic().await\n            };\n\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topic_list, &event).await {\n                error!(\"Failed to broadcast repost to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n\n    /// 指定したイベントを削除するための削除イベントを発行\n    pub async fn delete_events(\n        &self,\n        target_ids: Vec<EventId>,\n        reason: Option<String>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n        if target_ids.is_empty() {\n            return Err(anyhow!(\"No event IDs provided\"));\n        }\n\n        let publisher = self.event_publisher.read().await;\n        let deletion_event = publisher.create_deletion(target_ids.clone(), reason.as_deref())?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let deletion_event_id = client_manager.publish_event(deletion_event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let mut topics: HashSet<String> = HashSet::new();\n            for event_id in &target_ids {\n                if let Some(resolved_topics) = self\n                    .resolve_topics_for_referenced_event(&event_id.to_hex())\n                    .await\n                {\n                    topics.extend(resolved_topics);\n                }\n            }\n\n            if topics.is_empty() {\n                topics.extend(self.default_topics_with_user_topic().await);\n            }\n\n            let topic_list: Vec<String> = topics.into_iter().collect();\n            if let Err(e) = self\n                .broadcast_to_topics(&gossip, &topic_list, &deletion_event)\n                .await\n            {\n                error!(\"Failed to broadcast deletion to P2P: {}\", e);\n            }\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    /// リポスト（ブースト）を送信\n    /// 任意のイベントを発行\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast generic event to P2P: {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(&self, metadata: Metadata) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_metadata(metadata)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast metadata to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n}\n","traces":[{"line":11,"address":[15901474,15901456],"length":1,"stats":{"Line":4}},{"line":12,"address":[19673862,19673929,19674118,19674244,19674583,19674791],"length":1,"stats":{"Line":4}},{"line":14,"address":[19680734,19681329,19681643,19681462],"length":1,"stats":{"Line":0}},{"line":15,"address":[19794114,19793439,19793831,19793521],"length":1,"stats":{"Line":0}},{"line":16,"address":[19682279],"length":1,"stats":{"Line":0}},{"line":18,"address":[11778100],"length":1,"stats":{"Line":0}},{"line":19,"address":[11248497],"length":1,"stats":{"Line":0}},{"line":20,"address":[19676629],"length":1,"stats":{"Line":0}},{"line":21,"address":[19789467],"length":1,"stats":{"Line":0}},{"line":22,"address":[19758299,19758425],"length":1,"stats":{"Line":0}},{"line":23,"address":[19797600,19797609],"length":1,"stats":{"Line":0}},{"line":25,"address":[19890098],"length":1,"stats":{"Line":0}},{"line":27,"address":[19793951],"length":1,"stats":{"Line":0}},{"line":29,"address":[19690733],"length":1,"stats":{"Line":0}},{"line":33,"address":[20990242],"length":1,"stats":{"Line":0}},{"line":35,"address":[13931667,13932196,13928317],"length":1,"stats":{"Line":0}},{"line":36,"address":[11877119],"length":1,"stats":{"Line":0}},{"line":37,"address":[11839032],"length":1,"stats":{"Line":0}},{"line":38,"address":[21172793,20992635,20992538,20993136,21172927],"length":1,"stats":{"Line":0}},{"line":42,"address":[19891380],"length":1,"stats":{"Line":0}},{"line":46,"address":[15976240],"length":1,"stats":{"Line":2}},{"line":54,"address":[11252578],"length":1,"stats":{"Line":6}},{"line":56,"address":[19688919,19689231,19689049,19688302],"length":1,"stats":{"Line":2}},{"line":57,"address":[19895812,19895902,19896546,19896259],"length":1,"stats":{"Line":2}},{"line":58,"address":[19799779],"length":1,"stats":{"Line":1}},{"line":60,"address":[11849508],"length":1,"stats":{"Line":2}},{"line":61,"address":[19796581,19794264,19796499],"length":1,"stats":{"Line":2}},{"line":62,"address":[19684286],"length":1,"stats":{"Line":0}},{"line":63,"address":[19691204],"length":1,"stats":{"Line":1}},{"line":64,"address":[19802732],"length":1,"stats":{"Line":1}},{"line":65,"address":[19802851,19802923,19803022],"length":1,"stats":{"Line":3}},{"line":66,"address":[21006249,21006240],"length":1,"stats":{"Line":2}},{"line":68,"address":[19691547,19691495],"length":1,"stats":{"Line":0}},{"line":69,"address":[13939118],"length":1,"stats":{"Line":0}},{"line":71,"address":[19797603],"length":1,"stats":{"Line":1}},{"line":72,"address":[19692440,19691903,19900159,19691744,19900025],"length":1,"stats":{"Line":3}},{"line":76,"address":[19802231],"length":1,"stats":{"Line":1}},{"line":78,"address":[13939213],"length":1,"stats":{"Line":0}},{"line":82,"address":[19691255],"length":1,"stats":{"Line":1}},{"line":84,"address":[11781798],"length":1,"stats":{"Line":2}},{"line":85,"address":[11768063],"length":1,"stats":{"Line":2}},{"line":86,"address":[20006575,20006441,19800783,19800884,19801385],"length":1,"stats":{"Line":0}},{"line":90,"address":[11252704],"length":1,"stats":{"Line":3}},{"line":91,"address":[19808395,19808739],"length":1,"stats":{"Line":3}},{"line":96,"address":[19905526,19894716,19905944,19904219],"length":1,"stats":{"Line":3}},{"line":99,"address":[19809390],"length":1,"stats":{"Line":1}},{"line":103,"address":[19707519,19707292,19708512,19707874,19707730,19707200],"length":1,"stats":{"Line":0}},{"line":104,"address":[11757460],"length":1,"stats":{"Line":0}},{"line":106,"address":[11970558],"length":1,"stats":{"Line":0}},{"line":107,"address":[19811783,19812033,19812316,19811693],"length":1,"stats":{"Line":0}},{"line":108,"address":[19811985],"length":1,"stats":{"Line":0}},{"line":110,"address":[11240480],"length":1,"stats":{"Line":0}},{"line":111,"address":[19695996,19696620,19696078,19693852],"length":1,"stats":{"Line":0}},{"line":112,"address":[19703356],"length":1,"stats":{"Line":0}},{"line":114,"address":[19778456,19778826,19775393,19778185],"length":1,"stats":{"Line":0}},{"line":115,"address":[19910837,19910557,19911307,19910791,19911169],"length":1,"stats":{"Line":0}},{"line":116,"address":[19704393,19704292],"length":1,"stats":{"Line":0}},{"line":117,"address":[11240546],"length":1,"stats":{"Line":0}},{"line":119,"address":[19911517,19911400],"length":1,"stats":{"Line":0}},{"line":120,"address":[11970688],"length":1,"stats":{"Line":0}},{"line":122,"address":[19698451,19698565],"length":1,"stats":{"Line":0}},{"line":123,"address":[19773184],"length":1,"stats":{"Line":0}},{"line":126,"address":[21006844,21011456,21012040],"length":1,"stats":{"Line":0}},{"line":129,"address":[19532644],"length":1,"stats":{"Line":0}},{"line":130,"address":[19901647,19707037,19706936,19707538,19901513],"length":1,"stats":{"Line":0}},{"line":134,"address":[21010549],"length":1,"stats":{"Line":0}},{"line":138,"address":[16013296,16013309],"length":1,"stats":{"Line":0}},{"line":139,"address":[11876356],"length":1,"stats":{"Line":0}},{"line":141,"address":[19818846,19819616,19819483,19819797],"length":1,"stats":{"Line":0}},{"line":142,"address":[19822063,19822346,19821827,19821737],"length":1,"stats":{"Line":0}},{"line":143,"address":[19916799],"length":1,"stats":{"Line":0}},{"line":145,"address":[19820585,19818867,19820726,19820504],"length":1,"stats":{"Line":0}},{"line":146,"address":[19704378,19705002,19702248,19704460],"length":1,"stats":{"Line":0}},{"line":147,"address":[19817658],"length":1,"stats":{"Line":0}},{"line":149,"address":[11773580],"length":1,"stats":{"Line":0}},{"line":150,"address":[19818851,19818805,19819321,19818571,19819183],"length":1,"stats":{"Line":0}},{"line":151,"address":[13960295,13960194],"length":1,"stats":{"Line":0}},{"line":152,"address":[11773606],"length":1,"stats":{"Line":0}},{"line":154,"address":[19823467,19823350],"length":1,"stats":{"Line":0}},{"line":155,"address":[11876512],"length":1,"stats":{"Line":0}},{"line":157,"address":[19706833,19706947],"length":1,"stats":{"Line":0}},{"line":158,"address":[19920046],"length":1,"stats":{"Line":0}},{"line":161,"address":[11876538],"length":1,"stats":{"Line":0}},{"line":164,"address":[19825976,19826427,19820641],"length":1,"stats":{"Line":0}},{"line":165,"address":[19715419,19715920,19902009,19715318,19902143],"length":1,"stats":{"Line":0}},{"line":169,"address":[19720003],"length":1,"stats":{"Line":0}},{"line":173,"address":[16011696],"length":1,"stats":{"Line":0}},{"line":178,"address":[11867906],"length":1,"stats":{"Line":0}},{"line":179,"address":[13965614,13965532],"length":1,"stats":{"Line":0}},{"line":180,"address":[19792871,19793074],"length":1,"stats":{"Line":0}},{"line":183,"address":[19823318,19824020,19824134,19824365],"length":1,"stats":{"Line":0}},{"line":184,"address":[19794280,19793968,19793546,19793467,19794252],"length":1,"stats":{"Line":0}},{"line":185,"address":[19793926],"length":1,"stats":{"Line":0}},{"line":187,"address":[19530230],"length":1,"stats":{"Line":0}},{"line":188,"address":[11829872],"length":1,"stats":{"Line":0}},{"line":189,"address":[19720438],"length":1,"stats":{"Line":0}},{"line":191,"address":[11968378],"length":1,"stats":{"Line":0}},{"line":192,"address":[21026780],"length":1,"stats":{"Line":0}},{"line":193,"address":[19833149,19834065,19833267,19833995],"length":1,"stats":{"Line":0}},{"line":194,"address":[21027797,21028152,21027529,21028182,21027350],"length":1,"stats":{"Line":0}},{"line":195,"address":[19834101,19834382],"length":1,"stats":{"Line":0}},{"line":196,"address":[11871972],"length":1,"stats":{"Line":0}},{"line":198,"address":[19797108],"length":1,"stats":{"Line":0}},{"line":202,"address":[19790336,19790429],"length":1,"stats":{"Line":0}},{"line":203,"address":[19828944,19823423,19828645],"length":1,"stats":{"Line":0}},{"line":206,"address":[19790435,19791092],"length":1,"stats":{"Line":0}},{"line":207,"address":[19730460,19730710,19730506,19730294,19730802],"length":1,"stats":{"Line":0}},{"line":208,"address":[19798208,19798074],"length":1,"stats":{"Line":0}},{"line":209,"address":[11868088],"length":1,"stats":{"Line":0}},{"line":211,"address":[19830393,20008559,19829892,19829791,20008425],"length":1,"stats":{"Line":0}},{"line":215,"address":[19831704],"length":1,"stats":{"Line":0}},{"line":220,"address":[15969763,15969728],"length":1,"stats":{"Line":0}},{"line":221,"address":[19801532,19800627,19800694,19800989,19800863,19801324],"length":1,"stats":{"Line":0}},{"line":223,"address":[11831196],"length":1,"stats":{"Line":0}},{"line":224,"address":[11763414],"length":1,"stats":{"Line":0}},{"line":225,"address":[13975231],"length":1,"stats":{"Line":0}},{"line":227,"address":[11763440],"length":1,"stats":{"Line":0}},{"line":228,"address":[11969754],"length":1,"stats":{"Line":0}},{"line":229,"address":[19722502,19722659,19719279],"length":1,"stats":{"Line":0}},{"line":230,"address":[19723061,19723162,19896217,19896351,19723663],"length":1,"stats":{"Line":0}},{"line":234,"address":[21033853],"length":1,"stats":{"Line":0}},{"line":238,"address":[16013539,16013504],"length":1,"stats":{"Line":0}},{"line":239,"address":[11244866],"length":1,"stats":{"Line":0}},{"line":241,"address":[11843292],"length":1,"stats":{"Line":0}},{"line":242,"address":[19845224,19844934,19844630,19844548],"length":1,"stats":{"Line":0}},{"line":243,"address":[19801190],"length":1,"stats":{"Line":0}},{"line":245,"address":[19801334,19799705,19801415,19801556],"length":1,"stats":{"Line":0}},{"line":246,"address":[19809407,19806654,19808776,19808858],"length":1,"stats":{"Line":0}},{"line":247,"address":[13982143],"length":1,"stats":{"Line":0}},{"line":249,"address":[11244954],"length":1,"stats":{"Line":0}},{"line":250,"address":[11244976],"length":1,"stats":{"Line":0}},{"line":251,"address":[21036873,21041143,21040986],"length":1,"stats":{"Line":0}},{"line":252,"address":[19903497,19737487,19736986,19903631,19736885],"length":1,"stats":{"Line":0}},{"line":256,"address":[21040617],"length":1,"stats":{"Line":0}}],"covered":23,"coverable":134},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager_handle.rs"],"content":"use crate::application::ports::{event_topic_store::EventTopicStore, key_manager::KeyPair};\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::infrastructure::event::EventManager;\nuse crate::infrastructure::p2p::GossipService;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata, PublicKey};\nuse std::sync::Arc;\n\n#[async_trait]\npub trait EventManagerHandle: Send + Sync {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>);\n    async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>);\n    async fn set_default_p2p_topic_id(&self, topic_id: &str);\n    async fn set_default_p2p_topics(&self, topics: Vec<String>);\n    async fn list_default_p2p_topics(&self) -> Vec<String>;\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()>;\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<NostrEventId>;\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId>;\n    async fn publish_repost(&self, target: &NostrEventId) -> Result<NostrEventId>;\n    async fn publish_event(&self, event: NostrEvent) -> Result<NostrEventId>;\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId>;\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId>;\n    async fn disconnect(&self) -> Result<()>;\n    async fn get_public_key(&self) -> Option<PublicKey>;\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()>;\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()>;\n    async fn register_event_callback(&self, callback: Arc<dyn Fn(NostrEvent) + Send + Sync>);\n    async fn initialize_with_keypair(&self, keypair: KeyPair) -> Result<()>;\n}\n\n#[derive(Clone)]\npub struct LegacyEventManagerHandle {\n    inner: Arc<EventManager>,\n}\n\nimpl LegacyEventManagerHandle {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(EventManager::new()),\n        }\n    }\n\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        Self {\n            inner: Arc::new(EventManager::new_with_connection_pool(pool)),\n        }\n    }\n\n    pub fn as_event_manager(&self) -> Arc<EventManager> {\n        Arc::clone(&self.inner)\n    }\n}\n\nimpl Default for LegacyEventManagerHandle {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventManagerHandle for LegacyEventManagerHandle {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        self.inner.set_gossip_service(gossip).await;\n    }\n\n    async fn set_event_topic_store(&self, store: Arc<dyn EventTopicStore>) {\n        self.inner.set_event_topic_store(store).await;\n    }\n\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\n        self.inner.set_default_p2p_topic_id(topic_id).await;\n    }\n\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.inner.set_default_p2p_topics(topics).await;\n    }\n\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.inner.list_default_p2p_topics().await\n    }\n\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()> {\n        self.inner.handle_p2p_event(event).await\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId> {\n        self.inner.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        scope: Option<&str>,\n        epoch: Option<i64>,\n    ) -> Result<NostrEventId> {\n        self.inner\n            .publish_topic_post(topic_id, content, reply_to, scope, epoch)\n            .await\n    }\n\n    async fn publish_repost(&self, target: &NostrEventId) -> Result<NostrEventId> {\n        self.inner.publish_repost(target).await\n    }\n\n    async fn publish_event(&self, event: NostrEvent) -> Result<NostrEventId> {\n        self.inner.publish_event(event).await\n    }\n\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId> {\n        self.inner.send_reaction(target, reaction).await\n    }\n\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId> {\n        self.inner.update_metadata(metadata).await\n    }\n\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId> {\n        self.inner.delete_events(target_ids, reason).await\n    }\n\n    async fn disconnect(&self) -> Result<()> {\n        self.inner.disconnect().await\n    }\n\n    async fn get_public_key(&self) -> Option<PublicKey> {\n        self.inner.get_public_key().await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_topic(topic_id, since).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_user(pubkey, since).await\n    }\n\n    async fn register_event_callback(&self, callback: Arc<dyn Fn(NostrEvent) + Send + Sync>) {\n        self.inner.register_event_callback(callback).await;\n    }\n\n    async fn initialize_with_keypair(&self, keypair: KeyPair) -> Result<()> {\n        self.inner.initialize_with_keypair(&keypair).await\n    }\n}\n","traces":[{"line":51,"address":[22181872],"length":1,"stats":{"Line":1}},{"line":53,"address":[22388164],"length":1,"stats":{"Line":1}},{"line":57,"address":[22181904],"length":1,"stats":{"Line":1}},{"line":59,"address":[22388204],"length":1,"stats":{"Line":1}},{"line":63,"address":[22256688],"length":1,"stats":{"Line":1}},{"line":64,"address":[22256693],"length":1,"stats":{"Line":1}},{"line":69,"address":[22388256],"length":1,"stats":{"Line":0}},{"line":70,"address":[22181969],"length":1,"stats":{"Line":0}},{"line":76,"address":[22411353,22411870,22411167,22411328,22411495,22411535,22411691],"length":1,"stats":{"Line":8}},{"line":77,"address":[11940491],"length":1,"stats":{"Line":4}},{"line":80,"address":[22414366,22413849,22413663,22414187,22414031,22413824,22413991],"length":1,"stats":{"Line":8}},{"line":81,"address":[22309553,22309447,22309691,22309490],"length":1,"stats":{"Line":4}},{"line":84,"address":[20680394,20680288,20680313,20680576,20680239,20680751,20680431],"length":1,"stats":{"Line":0}},{"line":85,"address":[22378106,22377998,22378243,22378041],"length":1,"stats":{"Line":0}},{"line":88,"address":[22410021,22409981,22409647,22410396,22410209,22409849,22409824],"length":1,"stats":{"Line":4}},{"line":89,"address":[11946068],"length":1,"stats":{"Line":2}},{"line":92,"address":[22414608,22414745,22414854,22414643,22414463,22415112,22415398,22414882],"length":1,"stats":{"Line":0}},{"line":93,"address":[11841783],"length":1,"stats":{"Line":0}},{"line":96,"address":[22374482,22374032,22373391,22373568,22373701,22373593,22374235,22373762,22373797],"length":1,"stats":{"Line":8}},{"line":97,"address":[22374267,22373728,22374016,22374077],"length":1,"stats":{"Line":5}},{"line":100,"address":[22313936,22314189,22314166,22314426,22314083,22314686,22314001,22313774],"length":1,"stats":{"Line":0}},{"line":101,"address":[11898151],"length":1,"stats":{"Line":0}},{"line":104,"address":[22308342,22308250,22308368,22308096,22308837,22309099,22308162,22307861],"length":1,"stats":{"Line":5}},{"line":112,"address":[22308971,22308663,22308785,22308601],"length":1,"stats":{"Line":4}},{"line":113,"address":[22414562],"length":1,"stats":{"Line":1}},{"line":114,"address":[16555797,16556278,16556332,16556539,16556389],"length":1,"stats":{"Line":4}},{"line":117,"address":[22415078,22415379,22415297,22415462,22415232,22415485,22415718,22415978],"length":1,"stats":{"Line":0}},{"line":118,"address":[16557191,16557350,16557006],"length":1,"stats":{"Line":0}},{"line":121,"address":[22422368,22422134,22421857,22421792,22422573,22421978,22422099,22422839,22421614],"length":1,"stats":{"Line":0}},{"line":122,"address":[22317824,22317477,22318077,22317885],"length":1,"stats":{"Line":0}},{"line":125,"address":[22386637,22386449,22386214,22387138,22386384,22386531,22386878,22386614],"length":1,"stats":{"Line":0}},{"line":126,"address":[22312174,22311822,22312007],"length":1,"stats":{"Line":0}},{"line":129,"address":[20689495,20688545,20688414,20688787,20688818,20688666,20689241,20688480,20689048],"length":1,"stats":{"Line":0}},{"line":130,"address":[11826929],"length":1,"stats":{"Line":0}},{"line":133,"address":[22382129,22382164,22381598,22383024,22382513,22381857,22382764,22382014,22381792],"length":1,"stats":{"Line":0}},{"line":138,"address":[22389724,22388969,22389425,22389491],"length":1,"stats":{"Line":0}},{"line":141,"address":[22521937,22522485,22521840,22521695,22521865,22521998,22522244,22522016],"length":1,"stats":{"Line":0}},{"line":142,"address":[11889079],"length":1,"stats":{"Line":0}},{"line":145,"address":[16564336,16564595,16563759,16563904,16564143,16564104,16563939,16564021],"length":1,"stats":{"Line":0}},{"line":146,"address":[22316602,22316528,22316848,22316718],"length":1,"stats":{"Line":0}},{"line":149,"address":[22429038,22428670,22429020,22428832,22429328,22429569,22428887,22428959],"length":1,"stats":{"Line":0}},{"line":150,"address":[11827943],"length":1,"stats":{"Line":0}},{"line":153,"address":[22428951,22428160,22428712,22427982,22428287,22428366,22428215,22428348],"length":1,"stats":{"Line":0}},{"line":154,"address":[22428744,22428314,22428546],"length":1,"stats":{"Line":0}},{"line":157,"address":[22429168,22429710,22429193,22429335,22429375,22429007,22429531],"length":1,"stats":{"Line":0}},{"line":158,"address":[22425383,22425426,22425489,22425627],"length":1,"stats":{"Line":0}},{"line":161,"address":[22527109,22527354,22526697,22526505,22526480,22526271,22526952,22526662,22526601],"length":1,"stats":{"Line":0}},{"line":162,"address":[22327316,22327624,22327829,22327690],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":48},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","metrics.rs"],"content":"use crate::shared::error::AppError;\nuse crate::shared::metrics::AtomicMetric;\nuse serde::Serialize;\n#[cfg(test)]\nuse std::cell::Cell;\n#[cfg(test)]\nuse std::sync::{Mutex, OnceLock};\n\r\nstatic INCOMING_EVENTS: AtomicMetric = AtomicMetric::new();\r\nstatic PUBLISH_TEXT: AtomicMetric = AtomicMetric::new();\r\nstatic PUBLISH_TOPIC: AtomicMetric = AtomicMetric::new();\r\nstatic SEND_REACTION: AtomicMetric = AtomicMetric::new();\r\nstatic UPDATE_METADATA: AtomicMetric = AtomicMetric::new();\r\nstatic DELETE_EVENTS: AtomicMetric = AtomicMetric::new();\r\nstatic DISCONNECT: AtomicMetric = AtomicMetric::new();\r\nstatic REPOST_EVENTS: AtomicMetric = AtomicMetric::new();\r\n\r\n#[cfg(test)]\r\nstatic TEST_LOCK: OnceLock<Mutex<()>> = OnceLock::new();\r\n#[cfg(test)]\r\nthread_local! {\r\n    static LOCK_DEPTH: Cell<u32> = Cell::new(0);\r\n}\r\n\r\n#[cfg(test)]\r\npub(crate) struct MetricsGuard {\n    _guard: Option<std::sync::MutexGuard<'static, ()>>,\n}\n\r\n#[cfg(test)]\r\nimpl Drop for MetricsGuard {\r\n    fn drop(&mut self) {\r\n        LOCK_DEPTH.with(|depth| {\r\n            let current = depth.get();\r\n            depth.set(current.saturating_sub(1));\r\n        });\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nfn lock_guard() -> MetricsGuard {\r\n    LOCK_DEPTH.with(|depth| {\r\n        let current = depth.get();\r\n        depth.set(current + 1);\r\n        if current == 0 {\r\n            MetricsGuard {\n                _guard: Some(\n                    TEST_LOCK\n                        .get_or_init(|| Mutex::new(()))\n                        .lock()\n                        .expect(\"event metrics lock\"),\n                ),\n            }\n        } else {\n            MetricsGuard { _guard: None }\n        }\n    })\n}\n\r\n#[cfg(not(test))]\r\nstruct MetricsGuard;\r\n\r\n#[cfg(not(test))]\r\nfn lock_guard() -> MetricsGuard {\r\n    MetricsGuard\r\n}\r\n\r\n#[cfg(test)]\npub(crate) fn test_guard() -> MetricsGuard {\n    lock_guard()\r\n}\r\n\r\n#[derive(Debug, Clone, Copy)]\r\npub enum GatewayMetricKind {\r\n    Incoming,\r\n    PublishTextNote,\r\n    PublishTopicPost,\r\n    Reaction,\r\n    MetadataUpdate,\r\n    DeleteEvents,\r\n    Disconnect,\r\n    Repost,\r\n}\r\n\r\nfn metric(kind: GatewayMetricKind) -> &'static AtomicMetric {\r\n    match kind {\r\n        GatewayMetricKind::Incoming => &INCOMING_EVENTS,\r\n        GatewayMetricKind::PublishTextNote => &PUBLISH_TEXT,\r\n        GatewayMetricKind::PublishTopicPost => &PUBLISH_TOPIC,\r\n        GatewayMetricKind::Reaction => &SEND_REACTION,\r\n        GatewayMetricKind::MetadataUpdate => &UPDATE_METADATA,\r\n        GatewayMetricKind::DeleteEvents => &DELETE_EVENTS,\r\n        GatewayMetricKind::Disconnect => &DISCONNECT,\r\n        GatewayMetricKind::Repost => &REPOST_EVENTS,\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct GatewayMetricSnapshot {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\r\n#[derive(Debug, Clone, Serialize, PartialEq)]\r\npub struct EventGatewayMetrics {\n    pub incoming: GatewayMetricSnapshot,\n    pub publish_text_note: GatewayMetricSnapshot,\r\n    pub publish_topic_post: GatewayMetricSnapshot,\r\n    pub reactions: GatewayMetricSnapshot,\r\n    pub metadata_updates: GatewayMetricSnapshot,\r\n    pub deletions: GatewayMetricSnapshot,\r\n    pub disconnects: GatewayMetricSnapshot,\r\n    pub reposts: GatewayMetricSnapshot,\n}\n\nfn snapshot_from_atomic(metric: &AtomicMetric) -> GatewayMetricSnapshot {\n    let snapshot = metric.snapshot();\n    GatewayMetricSnapshot {\n        total: snapshot.successes,\n        failures: snapshot.failures,\n        last_success_ms: snapshot.last_success_ms,\n        last_failure_ms: snapshot.last_failure_ms,\n    }\n}\n\r\npub fn record_success(kind: GatewayMetricKind) {\n    let _guard = lock_guard();\r\n    metric(kind).record_success();\r\n}\r\n\r\npub fn record_failure(kind: GatewayMetricKind) {\r\n    let _guard = lock_guard();\r\n    metric(kind).record_failure();\r\n}\r\n\r\npub fn record_outcome<T>(\r\n    result: Result<T, AppError>,\r\n    kind: GatewayMetricKind,\r\n) -> Result<T, AppError> {\r\n    match result {\r\n        Ok(value) => {\r\n            record_success(kind);\r\n            Ok(value)\r\n        }\r\n        Err(err) => {\r\n            record_failure(kind);\r\n            Err(err)\r\n        }\r\n    }\r\n}\r\n\r\npub fn snapshot() -> EventGatewayMetrics {\n    let _guard = lock_guard();\n    EventGatewayMetrics {\n        incoming: snapshot_from_atomic(&INCOMING_EVENTS),\n        publish_text_note: snapshot_from_atomic(&PUBLISH_TEXT),\n        publish_topic_post: snapshot_from_atomic(&PUBLISH_TOPIC),\n        reactions: snapshot_from_atomic(&SEND_REACTION),\n        metadata_updates: snapshot_from_atomic(&UPDATE_METADATA),\n        deletions: snapshot_from_atomic(&DELETE_EVENTS),\n        disconnects: snapshot_from_atomic(&DISCONNECT),\n        reposts: snapshot_from_atomic(&REPOST_EVENTS),\n    }\n}\n\r\n#[cfg(test)]\npub fn reset() {\n    let _guard = lock_guard();\r\n    INCOMING_EVENTS.reset();\r\n    PUBLISH_TEXT.reset();\r\n    PUBLISH_TOPIC.reset();\r\n    SEND_REACTION.reset();\r\n    UPDATE_METADATA.reset();\r\n    DELETE_EVENTS.reset();\r\n    DISCONNECT.reset();\r\n    REPOST_EVENTS.reset();\r\n}\r\n","traces":[{"line":22,"address":[18336689],"length":1,"stats":{"Line":1}},{"line":41,"address":[18070688],"length":1,"stats":{"Line":1}},{"line":42,"address":[18070704,18070689],"length":1,"stats":{"Line":2}},{"line":43,"address":[18070718],"length":1,"stats":{"Line":1}},{"line":44,"address":[18070770,18070732],"length":1,"stats":{"Line":1}},{"line":45,"address":[18070763,18070872],"length":1,"stats":{"Line":2}},{"line":46,"address":[18070854],"length":1,"stats":{"Line":1}},{"line":47,"address":[18070842],"length":1,"stats":{"Line":1}},{"line":48,"address":[18070786],"length":1,"stats":{"Line":1}},{"line":49,"address":[18070912,18070916],"length":1,"stats":{"Line":2}},{"line":55,"address":[18070874],"length":1,"stats":{"Line":1}},{"line":69,"address":[18070960],"length":1,"stats":{"Line":1}},{"line":70,"address":[18070961],"length":1,"stats":{"Line":1}},{"line":85,"address":[21475312],"length":1,"stats":{"Line":1}},{"line":86,"address":[21475319,21475462],"length":1,"stats":{"Line":2}},{"line":87,"address":[21372472],"length":1,"stats":{"Line":1}},{"line":88,"address":[21440246],"length":1,"stats":{"Line":1}},{"line":89,"address":[21477028],"length":1,"stats":{"Line":0}},{"line":90,"address":[15613058],"length":1,"stats":{"Line":0}},{"line":91,"address":[21440288],"length":1,"stats":{"Line":0}},{"line":92,"address":[21372542],"length":1,"stats":{"Line":0}},{"line":93,"address":[21440316],"length":1,"stats":{"Line":0}},{"line":94,"address":[21571882],"length":1,"stats":{"Line":0}},{"line":118,"address":[21477120],"length":1,"stats":{"Line":1}},{"line":119,"address":[15613154],"length":1,"stats":{"Line":1}},{"line":121,"address":[21440389],"length":1,"stats":{"Line":1}},{"line":122,"address":[21358874],"length":1,"stats":{"Line":1}},{"line":123,"address":[21440399],"length":1,"stats":{"Line":1}},{"line":124,"address":[21571961],"length":1,"stats":{"Line":1}},{"line":128,"address":[21365712],"length":1,"stats":{"Line":1}},{"line":129,"address":[21372700],"length":1,"stats":{"Line":1}},{"line":130,"address":[21471653],"length":1,"stats":{"Line":2}},{"line":133,"address":[21475616],"length":1,"stats":{"Line":1}},{"line":134,"address":[21572060],"length":1,"stats":{"Line":1}},{"line":135,"address":[18071396,18071444],"length":1,"stats":{"Line":2}},{"line":138,"address":[15613855,15613942,15613589,15613696,15613328],"length":1,"stats":{"Line":2}},{"line":142,"address":[21572130,21572495],"length":1,"stats":{"Line":2}},{"line":143,"address":[21372846],"length":1,"stats":{"Line":0}},{"line":144,"address":[21359447,21359104],"length":1,"stats":{"Line":1}},{"line":145,"address":[18071664,18071975],"length":1,"stats":{"Line":1}},{"line":147,"address":[21440646,21440989],"length":1,"stats":{"Line":2}},{"line":148,"address":[21475792,21476135],"length":1,"stats":{"Line":2}},{"line":149,"address":[21366129,21366380],"length":1,"stats":{"Line":2}},{"line":154,"address":[21359648],"length":1,"stats":{"Line":1}},{"line":155,"address":[21477952],"length":1,"stats":{"Line":1}},{"line":157,"address":[18072127],"length":1,"stats":{"Line":1}},{"line":158,"address":[18072183],"length":1,"stats":{"Line":1}},{"line":159,"address":[21373463],"length":1,"stats":{"Line":1}},{"line":160,"address":[21441240],"length":1,"stats":{"Line":1}},{"line":161,"address":[18072246],"length":1,"stats":{"Line":1}},{"line":162,"address":[21441280],"length":1,"stats":{"Line":1}},{"line":163,"address":[21472484],"length":1,"stats":{"Line":1}},{"line":164,"address":[21373560],"length":1,"stats":{"Line":1}},{"line":169,"address":[18072784,18072608],"length":1,"stats":{"Line":1}},{"line":170,"address":[18072612],"length":1,"stats":{"Line":1}},{"line":171,"address":[18072626],"length":1,"stats":{"Line":1}},{"line":172,"address":[18072671],"length":1,"stats":{"Line":1}},{"line":173,"address":[18072685],"length":1,"stats":{"Line":1}},{"line":174,"address":[18072699],"length":1,"stats":{"Line":1}},{"line":175,"address":[18072713],"length":1,"stats":{"Line":1}},{"line":176,"address":[18072727],"length":1,"stats":{"Line":1}},{"line":177,"address":[18072741],"length":1,"stats":{"Line":1}},{"line":178,"address":[18072755],"length":1,"stats":{"Line":1}}],"covered":56,"coverable":63},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","mod.rs"],"content":"pub mod event_manager_gateway;\npub mod handler;\npub mod manager;\npub mod manager_handle;\npub mod metrics;\npub mod nostr_client_manager;\npub mod subscription_invoker;\npub mod topic_store;\n\npub use event_manager_gateway::LegacyEventManagerGateway;\npub use manager::EventManager;\npub use manager_handle::{EventManagerHandle, LegacyEventManagerHandle};\npub use subscription_invoker::EventManagerSubscriptionInvoker;\npub use topic_store::RepositoryEventTopicStore;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","nostr_client_manager.rs"],"content":"use anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrクライアントの管理構造体\npub struct NostrClientManager {\n    client: Arc<RwLock<Option<Client>>>,\n    keys: Option<Keys>,\n}\n\nimpl NostrClientManager {\n    /// 新しいNostrClientManagerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            client: Arc::new(RwLock::new(None)),\n            keys: None,\n        }\n    }\n\n    /// 秘密鍵からクライアントを初期化\n    pub async fn init_with_keys(&mut self, secret_key: &SecretKey) -> Result<()> {\n        let keys = Keys::new(secret_key.clone());\n        self.keys = Some(keys.clone());\n\n        let client = Client::new(keys.clone());\n\n        *self.client.write().await = Some(client);\n\n        info!(\"Nostr client initialized with keys\");\n        Ok(())\n    }\n\n    /// 全てのリレーから切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            client.disconnect().await;\n            info!(\"Disconnected from all relays\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// カスタムイベントを投稿\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            let output = client.send_event(&event).await?;\n            let event_id = output.id();\n            info!(\"Published event: {}\", event_id);\n            Ok(*event_id)\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// イベントをサブスクライブ\n    pub async fn subscribe(&self, filters: Vec<Filter>) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            for filter in filters {\n                client.subscribe(filter, None).await?;\n            }\n            info!(\"Subscribed to filters\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// 公開鍵を取得\n    pub fn get_public_key(&self) -> Option<PublicKey> {\n        self.keys.as_ref().map(|k| k.public_key())\n    }\n}\n\nimpl Default for NostrClientManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_client_initialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        assert!(manager.init_with_keys(&secret_key).await.is_ok());\n        assert!(manager.get_public_key().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_client_not_initialized_error() {\n        let manager = NostrClientManager::new();\n\n        // クライアントが初期化されていない状態でのテスト\n        assert!(manager.disconnect().await.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_public_key_generation() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        // 初期化前は公開鍵がない\n        assert!(manager.get_public_key().is_none());\n\n        // 初期化後は公開鍵が取得できる\n        manager.init_with_keys(&secret_key).await.unwrap();\n        let public_key = manager.get_public_key().unwrap();\n        assert_eq!(public_key, Keys::new(secret_key).public_key());\n    }\n\n    #[tokio::test]\n    async fn test_client_reinitialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key1 = SecretKey::generate();\n        let secret_key2 = SecretKey::generate();\n\n        // 最初の初期化\n        manager.init_with_keys(&secret_key1).await.unwrap();\n        let public_key1 = manager.get_public_key().unwrap();\n\n        // 再初期化\n        manager.init_with_keys(&secret_key2).await.unwrap();\n        let public_key2 = manager.get_public_key().unwrap();\n\n        // 公開鍵が更新されていることを確認\n        assert_ne!(public_key1, public_key2);\n        assert_eq!(public_key2, Keys::new(secret_key2).public_key());\n    }\n}\n","traces":[{"line":15,"address":[21360048],"length":1,"stats":{"Line":5}},{"line":17,"address":[15614368],"length":1,"stats":{"Line":5}},{"line":23,"address":[25771168,25771199,25771120,25771994,25771133,25771348,25771965,25771391],"length":1,"stats":{"Line":12}},{"line":24,"address":[25771341,25771441],"length":1,"stats":{"Line":6}},{"line":25,"address":[21442047,21442128],"length":1,"stats":{"Line":6}},{"line":27,"address":[21442271],"length":1,"stats":{"Line":3}},{"line":29,"address":[21574179,21574127,21573880,21576198,21573506],"length":1,"stats":{"Line":5}},{"line":31,"address":[21478838,21593551,21593417,21478283],"length":1,"stats":{"Line":11}},{"line":32,"address":[21474854],"length":1,"stats":{"Line":6}},{"line":36,"address":[25775128,25774112,25774104,25774310,25774246,25774463,25774143,25774096],"length":1,"stats":{"Line":4}},{"line":37,"address":[11771777],"length":1,"stats":{"Line":2}},{"line":38,"address":[21480539,21480626,21481649],"length":1,"stats":{"Line":3}},{"line":39,"address":[11640245],"length":1,"stats":{"Line":2}},{"line":40,"address":[21589977,21477725,21477194,21590111],"length":1,"stats":{"Line":2}},{"line":41,"address":[21446517],"length":1,"stats":{"Line":1}},{"line":43,"address":[21577153,21577278],"length":1,"stats":{"Line":2}},{"line":48,"address":[15623945,15620256,15620413,15620811,15620336,15620575,15621553,15620291],"length":1,"stats":{"Line":4}},{"line":49,"address":[21482885,21482941,21483034,21483179],"length":1,"stats":{"Line":2}},{"line":50,"address":[21479520,21479613],"length":1,"stats":{"Line":2}},{"line":51,"address":[11784882],"length":1,"stats":{"Line":3}},{"line":52,"address":[15622338,15622183],"length":1,"stats":{"Line":0}},{"line":53,"address":[21443241,21552495,21442634,21552361],"length":1,"stats":{"Line":0}},{"line":54,"address":[21443141],"length":1,"stats":{"Line":0}},{"line":56,"address":[21485307,21485438],"length":1,"stats":{"Line":0}},{"line":61,"address":[21451376,21452590,21455051,21451328,21451336,21451437,21451592,21451816],"length":1,"stats":{"Line":0}},{"line":62,"address":[11628649],"length":1,"stats":{"Line":0}},{"line":63,"address":[21377383,21379379,21377470],"length":1,"stats":{"Line":0}},{"line":64,"address":[25781485,25782597,25782656,25781582],"length":1,"stats":{"Line":0}},{"line":65,"address":[10938280,10938451,10938387],"length":1,"stats":{"Line":0}},{"line":67,"address":[25895849,25782762,25783293,25895983],"length":1,"stats":{"Line":0}},{"line":68,"address":[21386343],"length":1,"stats":{"Line":0}},{"line":70,"address":[21489270,21489129],"length":1,"stats":{"Line":0}},{"line":75,"address":[21492112],"length":1,"stats":{"Line":1}},{"line":76,"address":[21486560,21486592,21486608],"length":1,"stats":{"Line":3}},{"line":81,"address":[21486624],"length":1,"stats":{"Line":0}},{"line":82,"address":[21448520],"length":1,"stats":{"Line":0}}],"covered":22,"coverable":36},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","subscription_invoker.rs"],"content":"use crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::infrastructure::event::EventManagerHandle;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{PublicKey, Timestamp};\nuse std::sync::Arc;\n\npub struct EventManagerSubscriptionInvoker {\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl EventManagerSubscriptionInvoker {\n    pub fn new(event_manager: Arc<dyn EventManagerHandle>) -> Self {\n        Self { event_manager }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionInvoker for EventManagerSubscriptionInvoker {\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError> {\n        self.event_manager\n            .subscribe_to_topic(topic_id, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError> {\n        let public_key = PublicKey::from_hex(pubkey)?;\n        self.event_manager\n            .subscribe_to_user(public_key, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n}\n","traces":[{"line":13,"address":[16523600],"length":1,"stats":{"Line":0}},{"line":20,"address":[19459586,19458784,19459002,19458910,19458822,19459024,19459326,19458733],"length":1,"stats":{"Line":0}},{"line":25,"address":[16651013,16651093,16650756,16650699,16650818],"length":1,"stats":{"Line":0}},{"line":26,"address":[16763444],"length":1,"stats":{"Line":0}},{"line":27,"address":[16657678,16657571,16657618,16657241,16657817],"length":1,"stats":{"Line":0}},{"line":28,"address":[16651152,16651170],"length":1,"stats":{"Line":0}},{"line":31,"address":[24426637,24426384,24427439,24426317,24426519,24426425,24427158],"length":1,"stats":{"Line":0}},{"line":32,"address":[19460232,19460366,19460573],"length":1,"stats":{"Line":0}},{"line":33,"address":[16768577,16768671,16768773,16768973,16769058],"length":1,"stats":{"Line":0}},{"line":35,"address":[12058260],"length":1,"stats":{"Line":0}},{"line":36,"address":[16770768,16770786],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","topic_store.rs"],"content":"use crate::application::ports::event_topic_store::EventTopicStore;\nuse crate::application::ports::repositories::EventRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\npub struct RepositoryEventTopicStore {\n    repository: Arc<dyn EventRepository>,\n}\n\nimpl RepositoryEventTopicStore {\n    pub fn new(repository: Arc<dyn EventRepository>) -> Self {\n        Self { repository }\n    }\n}\n\n#[async_trait]\nimpl EventTopicStore for RepositoryEventTopicStore {\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError> {\n        self.repository.add_event_topic(event_id, topic_id).await\n    }\n\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError> {\n        self.repository.get_event_topics(event_id).await\n    }\n}\n","traces":[{"line":12,"address":[18072816],"length":1,"stats":{"Line":2}},{"line":19,"address":[16734989,16734370,16734291,16734731,16734189,16734459,16734256,16734482],"length":1,"stats":{"Line":5}},{"line":20,"address":[16727835,16727469,16727654],"length":1,"stats":{"Line":2}},{"line":23,"address":[16667267,16667426,16667538,16667779,16667347,16667312,16667515,16668037],"length":1,"stats":{"Line":0}},{"line":24,"address":[12022356],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","mod.rs"],"content":"pub mod trending_metrics_job;\npub mod trending_metrics_metrics;\npub mod trending_metrics_server;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_job.rs"],"content":"use super::trending_metrics_metrics::TrendingMetricsRecorder;\nuse crate::application::ports::repositories::TopicMetricsRepository;\nuse crate::domain::entities::{MetricsWindow, ScoreWeights, TopicActivityRow, TopicMetricsUpsert};\nuse crate::shared::error::AppError;\nuse chrono::Duration;\nuse chrono::Utc;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Instant;\n\n#[derive(Debug, Default, Clone)]\nstruct AggregatedTopicMetrics {\n    posts_24h: i64,\n    posts_6h: i64,\n    unique_authors: i64,\n    boosts: i64,\n    replies: i64,\n    bookmarks: i64,\n    participant_delta: i64,\n}\n\npub struct TrendingMetricsJob {\n    metrics_repository: Arc<dyn TopicMetricsRepository>,\n    score_weights: ScoreWeights,\n    ttl_hours: u64,\n    metrics_recorder: Option<Arc<TrendingMetricsRecorder>>,\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct TrendingMetricsRunStats {\n    pub topics_upserted: u64,\n    pub expired_records: u64,\n    pub cutoff_millis: i64,\n    pub window_start_millis: i64,\n    pub window_end_millis: i64,\n    pub lag_millis: i64,\n    pub score_weights: ScoreWeights,\n}\n\nimpl TrendingMetricsJob {\n    pub fn new(\n        metrics_repository: Arc<dyn TopicMetricsRepository>,\n        score_weights: Option<ScoreWeights>,\n        ttl_hours: u64,\n        metrics_recorder: Option<Arc<TrendingMetricsRecorder>>,\n    ) -> Self {\n        Self {\n            metrics_repository,\n            score_weights: score_weights.unwrap_or_default(),\n            ttl_hours,\n            metrics_recorder,\n        }\n    }\n\n    pub async fn run_once(&self) -> Result<(), AppError> {\n        let started = Instant::now();\n        let result = self.execute_once().await;\n        let duration = started.elapsed();\n        let duration_ms = duration.as_millis().min(u128::from(u64::MAX)) as u64;\n\n        if let Some(recorder) = &self.metrics_recorder {\n            match &result {\n                Ok(stats) => recorder.record_success(duration, stats),\n                Err(_) => recorder.record_failure(duration),\n            }\n        }\n\n        if let Ok(stats) = &result {\n            tracing::info!(\n                target: \"metrics::trending\",\n                topics_upserted = stats.topics_upserted,\n                cutoff_millis = stats.cutoff_millis,\n                removed_records = stats.expired_records,\n                window_start_millis = stats.window_start_millis,\n                window_end_millis = stats.window_end_millis,\n                lag_millis = stats.lag_millis,\n                score_weight_posts = stats.score_weights.posts,\n                score_weight_unique_authors = stats.score_weights.unique_authors,\n                score_weight_boosts = stats.score_weights.boosts,\n                duration_ms,\n                \"trending metrics job completed\"\n            );\n        }\n\n        result.map(|_| ())\n    }\n\n    async fn execute_once(&self) -> Result<TrendingMetricsRunStats, AppError> {\n        let now = Utc::now().timestamp_millis();\n        let window_24h = MetricsWindow::new(now - Duration::hours(24).num_milliseconds(), now);\n        let window_6h = MetricsWindow::new(now - Duration::hours(6).num_milliseconds(), now);\n\n        let activity_24h = self.metrics_repository.collect_activity(window_24h).await?;\n        let activity_6h = self.metrics_repository.collect_activity(window_6h).await?;\n\n        let aggregated = merge_activity(activity_24h, activity_6h);\n\n        let mut upserted = 0usize;\n        for (topic_id, metrics) in aggregated {\n            let score_24h =\n                self.score_weights\n                    .score(metrics.posts_24h, metrics.unique_authors, metrics.boosts);\n            let score_6h =\n                self.score_weights\n                    .score(metrics.posts_6h, metrics.unique_authors, metrics.boosts);\n\n            let upsert = TopicMetricsUpsert {\n                topic_id,\n                window_start: window_24h.start,\n                window_end: window_24h.end,\n                posts_24h: metrics.posts_24h,\n                posts_6h: metrics.posts_6h,\n                unique_authors: metrics.unique_authors,\n                boosts: metrics.boosts,\n                replies: metrics.replies,\n                bookmarks: metrics.bookmarks,\n                participant_delta: metrics.participant_delta,\n                score_24h,\n                score_6h,\n                updated_at: now,\n            };\n\n            self.metrics_repository.upsert_metrics(upsert).await?;\n            upserted += 1;\n        }\n\n        let cutoff = now - (self.ttl_hours as i64 * Duration::hours(1).num_milliseconds());\n        let removed = self.metrics_repository.cleanup_expired(cutoff).await?;\n        let lag_millis = now.saturating_sub(window_24h.end).max(0);\n\n        Ok(TrendingMetricsRunStats {\n            topics_upserted: upserted as u64,\n            expired_records: removed,\n            cutoff_millis: cutoff,\n            window_start_millis: window_24h.start,\n            window_end_millis: window_24h.end,\n            lag_millis,\n            score_weights: self.score_weights,\n        })\n    }\n}\n\nfn merge_activity(\n    activity_24h: Vec<TopicActivityRow>,\n    activity_6h: Vec<TopicActivityRow>,\n) -> HashMap<String, AggregatedTopicMetrics> {\n    let mut aggregated: HashMap<String, AggregatedTopicMetrics> = HashMap::new();\n\n    for row in activity_24h {\n        let entry = aggregated.entry(row.topic_id.clone()).or_default();\n        entry.posts_24h = row.posts_count;\n        entry.unique_authors = row.unique_authors;\n        entry.boosts = row.boosts;\n        entry.replies = row.replies;\n        entry.bookmarks = row.bookmarks;\n        entry.participant_delta = row.participant_delta;\n    }\n\n    for row in activity_6h {\n        let entry = aggregated.entry(row.topic_id.clone()).or_default();\n        entry.posts_6h = row.posts_count;\n\n        if entry.unique_authors == 0 {\n            entry.unique_authors = row.unique_authors;\n        }\n        if entry.boosts == 0 {\n            entry.boosts = row.boosts;\n        }\n        if entry.replies == 0 {\n            entry.replies = row.replies;\n        }\n        if entry.bookmarks == 0 {\n            entry.bookmarks = row.bookmarks;\n        }\n        if entry.participant_delta == 0 {\n            entry.participant_delta = row.participant_delta;\n        }\n    }\n\n    aggregated\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn merge_activity_prefers_24h_metrics() {\n        let topic = \"topic-1\";\n        let activity_24h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 12,\n            unique_authors: 5,\n            boosts: 3,\n            replies: 1,\n            bookmarks: 2,\n            participant_delta: 1,\n        }];\n\n        let activity_6h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 4,\n            unique_authors: 2,\n            boosts: 1,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }];\n\n        let merged = merge_activity(activity_24h, activity_6h);\n        let metrics = merged.get(topic).expect(\"metrics\");\n        assert_eq!(metrics.posts_24h, 12);\n        assert_eq!(metrics.posts_6h, 4);\n        assert_eq!(metrics.unique_authors, 5);\n        assert_eq!(metrics.boosts, 3);\n        assert_eq!(metrics.replies, 1);\n        assert_eq!(metrics.bookmarks, 2);\n    }\n\n    #[test]\n    fn merge_activity_falls_back_to_6h_when_24h_missing() {\n        let topic = \"topic-2\";\n        let activity_6h = vec![TopicActivityRow {\n            topic_id: topic.to_string(),\n            posts_count: 2,\n            unique_authors: 1,\n            boosts: 0,\n            replies: 0,\n            bookmarks: 0,\n            participant_delta: 0,\n        }];\n\n        let merged = merge_activity(vec![], activity_6h);\n        let metrics = merged.get(topic).expect(\"metrics\");\n        assert_eq!(metrics.posts_24h, 0);\n        assert_eq!(metrics.posts_6h, 2);\n        assert_eq!(metrics.unique_authors, 1);\n    }\n}\n","traces":[{"line":41,"address":[12640462,12640256,12640487],"length":1,"stats":{"Line":0}},{"line":49,"address":[12739251],"length":1,"stats":{"Line":0}},{"line":55,"address":[12701600,12701352,12701423,12701830,12701344,12701376,12705497,12701557],"length":1,"stats":{"Line":0}},{"line":56,"address":[12701511,12701673],"length":1,"stats":{"Line":0}},{"line":57,"address":[12701862,12701742,12701587,12701679],"length":1,"stats":{"Line":0}},{"line":58,"address":[12740320,12740414],"length":1,"stats":{"Line":0}},{"line":59,"address":[12746021],"length":1,"stats":{"Line":0}},{"line":61,"address":[20402829,20402910],"length":1,"stats":{"Line":0}},{"line":62,"address":[12627921],"length":1,"stats":{"Line":0}},{"line":63,"address":[12841102,12841016],"length":1,"stats":{"Line":0}},{"line":64,"address":[12634779,12634863],"length":1,"stats":{"Line":0}},{"line":68,"address":[12702650,12702699],"length":1,"stats":{"Line":0}},{"line":69,"address":[12912173,12710806,12710017,12710172,12709804,12709651,12710549,12912039],"length":1,"stats":{"Line":0}},{"line":85,"address":[12712448,12709679],"length":1,"stats":{"Line":0}},{"line":88,"address":[12743730,12744825,12743984,12745575,12743680,12743648,12743656,12743878],"length":1,"stats":{"Line":0}},{"line":89,"address":[12749440,12749615],"length":1,"stats":{"Line":0}},{"line":90,"address":[12631393],"length":1,"stats":{"Line":0}},{"line":91,"address":[12713155],"length":1,"stats":{"Line":0}},{"line":93,"address":[11576337],"length":1,"stats":{"Line":0}},{"line":94,"address":[12749513,12751893,12750994,12751168,12751651,12750794],"length":1,"stats":{"Line":0}},{"line":96,"address":[12751525],"length":1,"stats":{"Line":0}},{"line":98,"address":[20408469],"length":1,"stats":{"Line":0}},{"line":99,"address":[12708762,12708101,12708839,12708907],"length":1,"stats":{"Line":0}},{"line":100,"address":[12976883,12976366,12976406],"length":1,"stats":{"Line":0}},{"line":102,"address":[12641221],"length":1,"stats":{"Line":0}},{"line":103,"address":[20409979,20409939],"length":1,"stats":{"Line":0}},{"line":105,"address":[12648739],"length":1,"stats":{"Line":0}},{"line":109,"address":[12977013],"length":1,"stats":{"Line":0}},{"line":110,"address":[12635099],"length":1,"stats":{"Line":0}},{"line":111,"address":[12716623],"length":1,"stats":{"Line":0}},{"line":112,"address":[12716631],"length":1,"stats":{"Line":0}},{"line":113,"address":[12848191],"length":1,"stats":{"Line":0}},{"line":114,"address":[20410103],"length":1,"stats":{"Line":0}},{"line":115,"address":[12848207],"length":1,"stats":{"Line":0}},{"line":116,"address":[20410119],"length":1,"stats":{"Line":0}},{"line":117,"address":[12753439],"length":1,"stats":{"Line":0}},{"line":123,"address":[12752329,12752240,12749534,12753586,12751930],"length":1,"stats":{"Line":0}},{"line":124,"address":[12750644,12750815,12750774],"length":1,"stats":{"Line":0}},{"line":127,"address":[12716004,12716268],"length":1,"stats":{"Line":0}},{"line":128,"address":[11637235],"length":1,"stats":{"Line":0}},{"line":129,"address":[12748699,12748884],"length":1,"stats":{"Line":0}},{"line":131,"address":[12754599],"length":1,"stats":{"Line":0}},{"line":132,"address":[12748920],"length":1,"stats":{"Line":0}},{"line":134,"address":[12710820],"length":1,"stats":{"Line":0}},{"line":135,"address":[12978062],"length":1,"stats":{"Line":0}},{"line":136,"address":[20411227],"length":1,"stats":{"Line":0}},{"line":138,"address":[12636263],"length":1,"stats":{"Line":0}},{"line":143,"address":[12643408,12644588,12644829],"length":1,"stats":{"Line":1}},{"line":147,"address":[12978459],"length":1,"stats":{"Line":1}},{"line":149,"address":[12643529,12643622,12643799,12643745],"length":1,"stats":{"Line":4}},{"line":150,"address":[12749799,12750561],"length":1,"stats":{"Line":2}},{"line":151,"address":[12651684],"length":1,"stats":{"Line":1}},{"line":152,"address":[20412911],"length":1,"stats":{"Line":1}},{"line":153,"address":[12979684],"length":1,"stats":{"Line":1}},{"line":154,"address":[12851031],"length":1,"stats":{"Line":1}},{"line":155,"address":[12754611],"length":1,"stats":{"Line":1}},{"line":156,"address":[12637983],"length":1,"stats":{"Line":1}},{"line":159,"address":[12850202,12850395,12850449],"length":1,"stats":{"Line":3}},{"line":160,"address":[20412537,20412433],"length":1,"stats":{"Line":2}},{"line":161,"address":[12651390],"length":1,"stats":{"Line":1}},{"line":163,"address":[12637642],"length":1,"stats":{"Line":1}},{"line":164,"address":[12850726],"length":1,"stats":{"Line":1}},{"line":166,"address":[12644455],"length":1,"stats":{"Line":1}},{"line":167,"address":[12979436],"length":1,"stats":{"Line":1}},{"line":169,"address":[12850772],"length":1,"stats":{"Line":1}},{"line":170,"address":[12756000],"length":1,"stats":{"Line":1}},{"line":172,"address":[20412705],"length":1,"stats":{"Line":1}},{"line":173,"address":[12979494],"length":1,"stats":{"Line":1}},{"line":175,"address":[12637758],"length":1,"stats":{"Line":1}},{"line":176,"address":[12756058],"length":1,"stats":{"Line":1}},{"line":180,"address":[12750193],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":71},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_metrics.rs"],"content":"use super::trending_metrics_job::TrendingMetricsRunStats;\nuse crate::shared::error::AppError;\nuse prometheus::{\n    Encoder, Gauge, Histogram, HistogramOpts, IntCounter, IntGauge, Opts, Registry, TextEncoder,\n};\nuse std::sync::Arc;\nuse std::time::Duration;\n\nfn now_millis() -> i64 {\n    chrono::Utc::now().timestamp_millis()\n}\n\nfn prometheus_err(err: prometheus::Error) -> AppError {\n    AppError::Internal(err.to_string())\n}\n\npub struct TrendingMetricsRecorder {\n    registry: Arc<Registry>,\n    encoder: TextEncoder,\n    runs_total: IntCounter,\n    failures_total: IntCounter,\n    topics_upserted: IntGauge,\n    expired_records: IntGauge,\n    last_success_ms: IntGauge,\n    last_failure_ms: IntGauge,\n    window_start_ms: IntGauge,\n    window_end_ms: IntGauge,\n    lag_ms: IntGauge,\n    weight_posts: Gauge,\n    weight_unique_authors: Gauge,\n    weight_boosts: Gauge,\n    duration_seconds: Option<Histogram>,\n}\n\nimpl TrendingMetricsRecorder {\n    pub fn new(emit_histogram: bool) -> Result<Self, AppError> {\n        let registry = Registry::new_custom(Some(\"kukuri\".into()), None).map_err(prometheus_err)?;\n\n        let runs_total = IntCounter::with_opts(Opts::new(\n            \"trending_metrics_job_runs_total\",\n            \"Total number of successful trending metrics job executions\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(runs_total.clone()))\n            .map_err(prometheus_err)?;\n\n        let failures_total = IntCounter::with_opts(Opts::new(\n            \"trending_metrics_job_failures_total\",\n            \"Total number of failed trending metrics job executions\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(failures_total.clone()))\n            .map_err(prometheus_err)?;\n\n        let topics_upserted = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_topics_upserted\",\n            \"Latest topics_upserted count emitted by the job\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(topics_upserted.clone()))\n            .map_err(prometheus_err)?;\n\n        let expired_records = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_expired_records\",\n            \"Latest expired records count removed by the job\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(expired_records.clone()))\n            .map_err(prometheus_err)?;\n\n        let last_success_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_last_success_timestamp\",\n            \"Unix timestamp in milliseconds of the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(last_success_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let last_failure_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_last_failure_timestamp\",\n            \"Unix timestamp in milliseconds of the last failed execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(last_failure_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let window_start_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_window_start_ms\",\n            \"Window start timestamp (milliseconds) for the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(window_start_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let window_end_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_window_end_ms\",\n            \"Window end timestamp (milliseconds) for the last successful execution\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(window_end_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let lag_ms = IntGauge::with_opts(Opts::new(\n            \"trending_metrics_job_lag_ms\",\n            \"Lag in milliseconds between now and the emitted window end\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(lag_ms.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_posts = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_posts\",\n            \"Configured score weight applied to posts\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_posts.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_unique_authors = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_unique_authors\",\n            \"Configured score weight applied to unique authors\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_unique_authors.clone()))\n            .map_err(prometheus_err)?;\n\n        let weight_boosts = Gauge::with_opts(Opts::new(\n            \"trending_metrics_score_weight_boosts\",\n            \"Configured score weight applied to boosts\",\n        ))\n        .map_err(prometheus_err)?;\n        registry\n            .register(Box::new(weight_boosts.clone()))\n            .map_err(prometheus_err)?;\n\n        let duration_seconds = if emit_histogram {\n            let histogram = Histogram::with_opts(\n                HistogramOpts::new(\n                    \"trending_metrics_job_duration_seconds\",\n                    \"Observed duration of trending metrics job executions\",\n                )\n                .buckets(vec![0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]),\n            )\n            .map_err(prometheus_err)?;\n            registry\n                .register(Box::new(histogram.clone()))\n                .map_err(prometheus_err)?;\n            Some(histogram)\n        } else {\n            None\n        };\n\n        Ok(Self {\n            registry: Arc::new(registry),\n            encoder: TextEncoder::new(),\n            runs_total,\n            failures_total,\n            topics_upserted,\n            expired_records,\n            last_success_ms,\n            last_failure_ms,\n            window_start_ms,\n            window_end_ms,\n            lag_ms,\n            weight_posts,\n            weight_unique_authors,\n            weight_boosts,\n            duration_seconds,\n        })\n    }\n\n    pub fn record_success(&self, duration: Duration, stats: &TrendingMetricsRunStats) {\n        self.runs_total.inc();\n        self.topics_upserted.set(stats.topics_upserted as i64);\n        self.expired_records.set(stats.expired_records as i64);\n        self.last_success_ms.set(now_millis());\n        self.window_start_ms.set(stats.window_start_millis);\n        self.window_end_ms.set(stats.window_end_millis);\n        self.lag_ms.set(stats.lag_millis);\n        self.weight_posts.set(stats.score_weights.posts);\n        self.weight_unique_authors\n            .set(stats.score_weights.unique_authors);\n        self.weight_boosts.set(stats.score_weights.boosts);\n        if let Some(histogram) = &self.duration_seconds {\n            histogram.observe(duration.as_secs_f64());\n        }\n    }\n\n    pub fn record_failure(&self, duration: Duration) {\n        self.failures_total.inc();\n        self.last_failure_ms.set(now_millis());\n        if let Some(histogram) = &self.duration_seconds {\n            histogram.observe(duration.as_secs_f64());\n        }\n    }\n\n    pub fn encode(&self) -> Result<Vec<u8>, AppError> {\n        let metric_families = self.registry.gather();\n        let mut buffer = Vec::new();\n        self.encoder\n            .encode(&metric_families, &mut buffer)\n            .map_err(prometheus_err)?;\n        Ok(buffer)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::ScoreWeights;\n    use std::str;\n\n    fn contains_metric(haystack: &str, key: &str, value: &str) -> bool {\n        haystack\n            .lines()\n            .any(|line| line.trim().starts_with(key) && line.trim().ends_with(value))\n    }\n\n    #[test]\n    fn record_success_and_failure_update_metrics() {\n        let recorder = TrendingMetricsRecorder::new(true).expect(\"recorder\");\n        let stats = TrendingMetricsRunStats {\n            topics_upserted: 3,\n            expired_records: 1,\n            cutoff_millis: 0,\n            window_start_millis: 0,\n            window_end_millis: 0,\n            lag_millis: 0,\n            score_weights: ScoreWeights::default(),\n        };\n\n        recorder.record_success(Duration::from_millis(1200), &stats);\n        let snapshot = String::from_utf8(recorder.encode().expect(\"encode\")).expect(\"utf8\");\n        assert!(\n            contains_metric(&snapshot, \"kukuri_trending_metrics_job_runs_total\", \"1\"),\n            \"runs_total metric missing: {snapshot}\"\n        );\n        assert!(snapshot.contains(\"trending_metrics_job_topics_upserted 3\"));\n\n        recorder.record_failure(Duration::from_millis(800));\n        let snapshot = String::from_utf8(recorder.encode().expect(\"encode\")).expect(\"utf8\");\n        assert!(\n            contains_metric(&snapshot, \"kukuri_trending_metrics_job_failures_total\", \"1\"),\n            \"failures_total metric missing: {snapshot}\"\n        );\n    }\n}\n","traces":[{"line":9,"address":[14354320],"length":1,"stats":{"Line":1}},{"line":10,"address":[14248404],"length":1,"stats":{"Line":1}},{"line":13,"address":[14354352,14354475],"length":1,"stats":{"Line":0}},{"line":14,"address":[14354429,14354371],"length":1,"stats":{"Line":0}},{"line":36,"address":[14368941,14360080,14368584],"length":1,"stats":{"Line":1}},{"line":37,"address":[14242143,14241859],"length":1,"stats":{"Line":1}},{"line":39,"address":[14360387,14360748,14368926,14360532],"length":1,"stats":{"Line":2}},{"line":43,"address":[14323932],"length":1,"stats":{"Line":0}},{"line":44,"address":[14264380,14256541,14256328],"length":1,"stats":{"Line":1}},{"line":45,"address":[14324061,14323894],"length":1,"stats":{"Line":1}},{"line":46,"address":[14359373],"length":1,"stats":{"Line":0}},{"line":48,"address":[22025594,22017786,22018002,22017657],"length":1,"stats":{"Line":2}},{"line":52,"address":[14359618],"length":1,"stats":{"Line":0}},{"line":53,"address":[14361422,14368885,14361635],"length":1,"stats":{"Line":1}},{"line":54,"address":[14243107,14242940],"length":1,"stats":{"Line":1}},{"line":55,"address":[22018275],"length":1,"stats":{"Line":0}},{"line":57,"address":[14356080,14355951,14363299,14356296],"length":1,"stats":{"Line":2}},{"line":61,"address":[14243544],"length":1,"stats":{"Line":0}},{"line":62,"address":[14264334,14257673,14257460],"length":1,"stats":{"Line":1}},{"line":63,"address":[14250457,14250290],"length":1,"stats":{"Line":1}},{"line":64,"address":[16441528],"length":1,"stats":{"Line":0}},{"line":66,"address":[14250942,14250597,14250726,14257356],"length":1,"stats":{"Line":2}},{"line":70,"address":[16441753],"length":1,"stats":{"Line":0}},{"line":71,"address":[16442244,16449176,16442043],"length":1,"stats":{"Line":1}},{"line":72,"address":[14244239,14244072],"length":1,"stats":{"Line":1}},{"line":73,"address":[14251215],"length":1,"stats":{"Line":0}},{"line":75,"address":[14325141,14319100,14319316,14318971],"length":1,"stats":{"Line":2}},{"line":79,"address":[14326196],"length":1,"stats":{"Line":0}},{"line":80,"address":[14361472,14361685,14367168],"length":1,"stats":{"Line":1}},{"line":81,"address":[14362926,14363093],"length":1,"stats":{"Line":1}},{"line":82,"address":[14244997],"length":1,"stats":{"Line":0}},{"line":84,"address":[14244945,14245074,14250526,14245290],"length":1,"stats":{"Line":2}},{"line":88,"address":[22020218],"length":1,"stats":{"Line":0}},{"line":89,"address":[14363686,14363899,14368793],"length":1,"stats":{"Line":1}},{"line":90,"address":[22020347,22020180],"length":1,"stats":{"Line":1}},{"line":91,"address":[14363851],"length":1,"stats":{"Line":0}},{"line":93,"address":[16443621,16443484,16443805,16449136],"length":1,"stats":{"Line":2}},{"line":97,"address":[14252592],"length":1,"stats":{"Line":0}},{"line":98,"address":[22021147,22025458,22020934],"length":1,"stats":{"Line":1}},{"line":99,"address":[14252554,14252721],"length":1,"stats":{"Line":1}},{"line":100,"address":[14252907],"length":1,"stats":{"Line":0}},{"line":102,"address":[14363184,14358904,14358775,14359117],"length":1,"stats":{"Line":2}},{"line":106,"address":[14246365],"length":1,"stats":{"Line":0}},{"line":107,"address":[14325051,14321317,14321104],"length":1,"stats":{"Line":1}},{"line":108,"address":[14363131,14362970],"length":1,"stats":{"Line":1}},{"line":109,"address":[14364965],"length":1,"stats":{"Line":0}},{"line":111,"address":[16445141,16444957,16444820,16449098],"length":1,"stats":{"Line":2}},{"line":115,"address":[14363559],"length":1,"stats":{"Line":0}},{"line":116,"address":[14257220,14253850,14254063],"length":1,"stats":{"Line":1}},{"line":117,"address":[14359588,14359749],"length":1,"stats":{"Line":1}},{"line":118,"address":[14363871],"length":1,"stats":{"Line":0}},{"line":120,"address":[14254305,14253963,14257218,14254092],"length":1,"stats":{"Line":2}},{"line":124,"address":[14261233],"length":1,"stats":{"Line":0}},{"line":125,"address":[14247620,14247833,14250413],"length":1,"stats":{"Line":1}},{"line":126,"address":[14254383,14254222],"length":1,"stats":{"Line":1}},{"line":127,"address":[22022761],"length":1,"stats":{"Line":0}},{"line":129,"address":[14264171,14261493,14261835,14261622],"length":1,"stats":{"Line":2}},{"line":133,"address":[14329547],"length":1,"stats":{"Line":0}},{"line":134,"address":[22025366,22023150,22023363],"length":1,"stats":{"Line":1}},{"line":135,"address":[22023129,22022968],"length":1,"stats":{"Line":1}},{"line":136,"address":[14255123],"length":1,"stats":{"Line":0}},{"line":138,"address":[14248416,14248287,14248629,14250388],"length":1,"stats":{"Line":2}},{"line":142,"address":[14262341],"length":1,"stats":{"Line":0}},{"line":143,"address":[14323502,14324959,14323320],"length":1,"stats":{"Line":1}},{"line":144,"address":[14262306,14262467],"length":1,"stats":{"Line":1}},{"line":145,"address":[14248862],"length":1,"stats":{"Line":0}},{"line":147,"address":[14249813,14248951,14248848],"length":1,"stats":{"Line":2}},{"line":149,"address":[14330845,14330473],"length":1,"stats":{"Line":2}},{"line":153,"address":[14249368,14249032,14250345],"length":1,"stats":{"Line":2}},{"line":155,"address":[16448093],"length":1,"stats":{"Line":0}},{"line":156,"address":[14256658,14256468],"length":1,"stats":{"Line":1}},{"line":157,"address":[16448070],"length":1,"stats":{"Line":1}},{"line":158,"address":[14368114],"length":1,"stats":{"Line":0}},{"line":159,"address":[14331317],"length":1,"stats":{"Line":1}},{"line":161,"address":[14255723],"length":1,"stats":{"Line":0}},{"line":164,"address":[14250124],"length":1,"stats":{"Line":1}},{"line":165,"address":[14331472,14330517],"length":1,"stats":{"Line":2}},{"line":166,"address":[14249960],"length":1,"stats":{"Line":1}},{"line":167,"address":[14368308],"length":1,"stats":{"Line":1}},{"line":168,"address":[14324620],"length":1,"stats":{"Line":1}},{"line":169,"address":[14331556],"length":1,"stats":{"Line":1}},{"line":170,"address":[14362748],"length":1,"stats":{"Line":1}},{"line":171,"address":[14463124],"length":1,"stats":{"Line":1}},{"line":172,"address":[14368348],"length":1,"stats":{"Line":1}},{"line":173,"address":[14362772],"length":1,"stats":{"Line":1}},{"line":174,"address":[14362780],"length":1,"stats":{"Line":1}},{"line":175,"address":[22025060],"length":1,"stats":{"Line":1}},{"line":176,"address":[16448753],"length":1,"stats":{"Line":1}},{"line":177,"address":[14366740],"length":1,"stats":{"Line":1}},{"line":178,"address":[14366748],"length":1,"stats":{"Line":1}},{"line":179,"address":[14256900],"length":1,"stats":{"Line":1}},{"line":183,"address":[14463760],"length":1,"stats":{"Line":1}},{"line":184,"address":[22025697],"length":1,"stats":{"Line":1}},{"line":185,"address":[14463813],"length":1,"stats":{"Line":1}},{"line":186,"address":[16449386],"length":1,"stats":{"Line":1}},{"line":187,"address":[14367423],"length":1,"stats":{"Line":1}},{"line":188,"address":[14264579],"length":1,"stats":{"Line":1}},{"line":189,"address":[14369131],"length":1,"stats":{"Line":1}},{"line":190,"address":[14264627],"length":1,"stats":{"Line":1}},{"line":191,"address":[14363595],"length":1,"stats":{"Line":1}},{"line":192,"address":[14363620,14363629],"length":1,"stats":{"Line":2}},{"line":193,"address":[14363624],"length":1,"stats":{"Line":1}},{"line":194,"address":[14464013],"length":1,"stats":{"Line":1}},{"line":195,"address":[14464033],"length":1,"stats":{"Line":1}},{"line":196,"address":[16449622],"length":1,"stats":{"Line":1}},{"line":200,"address":[14332560],"length":1,"stats":{"Line":1}},{"line":201,"address":[14264823],"length":1,"stats":{"Line":1}},{"line":202,"address":[14369366],"length":1,"stats":{"Line":1}},{"line":203,"address":[14367749],"length":1,"stats":{"Line":1}},{"line":204,"address":[14367796],"length":1,"stats":{"Line":1}},{"line":208,"address":[14369472,14369994],"length":1,"stats":{"Line":1}},{"line":209,"address":[14325814],"length":1,"stats":{"Line":1}},{"line":210,"address":[14258032],"length":1,"stats":{"Line":1}},{"line":211,"address":[16450011,16450226,16449914],"length":1,"stats":{"Line":2}},{"line":212,"address":[22026295],"length":1,"stats":{"Line":1}},{"line":213,"address":[16450184],"length":1,"stats":{"Line":0}},{"line":214,"address":[14258284],"length":1,"stats":{"Line":1}}],"covered":87,"coverable":117},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","jobs","trending_metrics_server.rs"],"content":"use super::trending_metrics_metrics::TrendingMetricsRecorder;\nuse std::sync::Arc;\nuse tiny_http::{Header, Method, Response, Server, StatusCode};\n\nconst CONTENT_TYPE: &str = \"text/plain; version=0.0.4\";\n\npub fn spawn_prometheus_exporter(port: u16, recorder: Arc<TrendingMetricsRecorder>) {\n    let address = format!(\"127.0.0.1:{port}\");\n    tauri::async_runtime::spawn_blocking(move || match Server::http(&address) {\n        Ok(server) => {\n            tracing::info!(\n                target: \"metrics::trending\",\n                port,\n                \"prometheus exporter listening\"\n            );\n            for request in server.incoming_requests() {\n                let response = if request.method() == &Method::Get && request.url() == \"/metrics\" {\n                    match recorder.encode() {\n                        Ok(body) => Response::from_data(body)\n                            .with_status_code(StatusCode(200))\n                            .with_header(Header::from_bytes(\"Content-Type\", CONTENT_TYPE).unwrap()),\n                        Err(err) => {\n                            tracing::error!(\n                                target: \"metrics::trending\",\n                                error = %err,\n                                \"failed to encode metrics payload\"\n                            );\n                            Response::from_string(\"failed to encode metrics\")\n                                .with_status_code(StatusCode(500))\n                        }\n                    }\n                } else {\n                    Response::from_string(\"not found\").with_status_code(StatusCode(404))\n                };\n\n                if let Err(err) = request.respond(response) {\n                    tracing::warn!(\n                        target: \"metrics::trending\",\n                        error = %err,\n                        \"failed to respond to metrics request\"\n                    );\n                }\n            }\n        }\n        Err(err) => {\n            tracing::error!(\n                target: \"metrics::trending\",\n                port,\n                error = %err,\n                \"failed to bind prometheus exporter\"\n            );\n        }\n    });\n}\n","traces":[{"line":7,"address":[16817155,16816816,16817126],"length":1,"stats":{"Line":0}},{"line":8,"address":[16933557,16933476],"length":1,"stats":{"Line":0}},{"line":9,"address":[16891872,16891793,16891760,16891594,16894781,16900167],"length":1,"stats":{"Line":0}},{"line":10,"address":[16898853],"length":1,"stats":{"Line":0}},{"line":11,"address":[16892553,16965247,16892069,16965113,16891927],"length":1,"stats":{"Line":0}},{"line":16,"address":[16942089,16937466,16937359,16936231],"length":1,"stats":{"Line":0}},{"line":17,"address":[17032390,17032486,17032304],"length":1,"stats":{"Line":0}},{"line":18,"address":[16826310,16826558],"length":1,"stats":{"Line":0}},{"line":19,"address":[16932660,16932815,16932522],"length":1,"stats":{"Line":0}},{"line":20,"address":[26520104],"length":1,"stats":{"Line":0}},{"line":21,"address":[16938284,16938442],"length":1,"stats":{"Line":0}},{"line":22,"address":[16932581],"length":1,"stats":{"Line":0}},{"line":23,"address":[16894841,16894517,16965609,16965743,16895331],"length":1,"stats":{"Line":0}},{"line":28,"address":[16834465,16835679],"length":1,"stats":{"Line":0}},{"line":33,"address":[17032444,17032624],"length":1,"stats":{"Line":0}},{"line":36,"address":[16940269,16937874],"length":1,"stats":{"Line":0}},{"line":37,"address":[17035106,17035207,17035685,17104585,17104719],"length":1,"stats":{"Line":0}},{"line":45,"address":[16824147],"length":1,"stats":{"Line":0}},{"line":46,"address":[16891987,16898949,16966601,16966735,16898471],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","messaging","mod.rs"],"content":"pub mod nostr_gateway;\n\npub use nostr_gateway::NostrMessagingGateway;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","messaging","nostr_gateway.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::application::ports::messaging_gateway::{MessagingGateway, MessagingSendResult};\nuse crate::infrastructure::event::manager_handle::EventManagerHandle;\nuse crate::shared::{AppError, ValidationFailureKind};\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{EventBuilder, FromBech32, Keys, Kind, PublicKey, SecretKey, Tag, nip04};\nuse std::sync::Arc;\nuse tracing::warn;\n\npub struct NostrMessagingGateway {\n    key_manager: Arc<dyn KeyManager>,\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl NostrMessagingGateway {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        event_manager: Arc<dyn EventManagerHandle>,\n    ) -> Self {\n        Self {\n            key_manager,\n            event_manager,\n        }\n    }\n\n    async fn load_keys(&self, owner_npub: &str) -> Result<Keys, AppError> {\n        let nsec = self.key_manager.export_private_key(owner_npub).await?;\n        let secret_key = SecretKey::from_bech32(&nsec)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid nsec for {owner_npub}: {err}\")))?;\n        Ok(Keys::new(secret_key))\n    }\n\n    fn parse_npub(npub: &str) -> Result<PublicKey, AppError> {\n        PublicKey::from_bech32(npub).map_err(|err| AppError::ValidationError {\n            kind: ValidationFailureKind::Generic,\n            message: format!(\"Invalid npub {npub}: {err}\"),\n        })\n    }\n\n    fn encrypt_payload(\n        sender_secret: &SecretKey,\n        recipient: &PublicKey,\n        plaintext: &str,\n    ) -> Result<String, AppError> {\n        nip04::encrypt(sender_secret, recipient, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to encrypt direct message: {err}\")))\n    }\n\n    fn decrypt_payload(\n        owner_secret: &SecretKey,\n        counterparty: &PublicKey,\n        ciphertext: &str,\n    ) -> Result<String, AppError> {\n        nip04::decrypt(owner_secret, counterparty, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Failed to decrypt direct message: {err}\")))\n    }\n}\n\n#[async_trait]\nimpl MessagingGateway for NostrMessagingGateway {\n    async fn encrypt_and_send(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<MessagingSendResult, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let recipient_pk = Self::parse_npub(recipient_npub)?;\n\n        let ciphertext = Self::encrypt_payload(keys.secret_key(), &recipient_pk, plaintext)?;\n\n        let event = EventBuilder::new(Kind::EncryptedDirectMessage, ciphertext.clone())\n            .tags([Tag::public_key(recipient_pk)])\n            .sign_with_keys(&keys)?;\n\n        if let Err(err) = self.event_manager.publish_event(event.clone()).await {\n            warn!(\"Failed to publish direct message event: {err}\");\n            return Err(AppError::NostrError(format!(\n                \"Failed to publish direct message: {err}\"\n            )));\n        }\n\n        let created_at_millis = (event.created_at.as_secs() as i64) * 1000;\n        let event_id = event.id.to_hex();\n\n        Ok(MessagingSendResult {\n            event_id: Some(event_id),\n            ciphertext,\n            created_at_millis,\n            delivered: true,\n        })\n    }\n\n    async fn encrypt_only(\n        &self,\n        owner_npub: &str,\n        recipient_npub: &str,\n        plaintext: &str,\n    ) -> Result<String, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let recipient_pk = Self::parse_npub(recipient_npub)?;\n        Self::encrypt_payload(keys.secret_key(), &recipient_pk, plaintext)\n    }\n\n    async fn decrypt_with_counterparty(\n        &self,\n        owner_npub: &str,\n        counterparty_npub: &str,\n        ciphertext: &str,\n    ) -> Result<String, AppError> {\n        let keys = self.load_keys(owner_npub).await?;\n        let counterparty_pk = Self::parse_npub(counterparty_npub)?;\n        Self::decrypt_payload(keys.secret_key(), &counterparty_pk, ciphertext)\n    }\n}\n","traces":[{"line":16,"address":[18901472],"length":1,"stats":{"Line":0}},{"line":26,"address":[18984462,18983123,18983279,18983239,18983058,18983443,18983040,18983088],"length":1,"stats":{"Line":0}},{"line":27,"address":[11636084],"length":1,"stats":{"Line":0}},{"line":28,"address":[18909250,18909516,18909060,18909222],"length":1,"stats":{"Line":0}},{"line":29,"address":[18902992,18902457,18903018,18902684],"length":1,"stats":{"Line":0}},{"line":30,"address":[18902810,18902621],"length":1,"stats":{"Line":0}},{"line":33,"address":[19021584],"length":1,"stats":{"Line":0}},{"line":34,"address":[19016023,19016368,19016080,19016312],"length":1,"stats":{"Line":0}},{"line":35,"address":[19116475],"length":1,"stats":{"Line":0}},{"line":36,"address":[18978000,18978070],"length":1,"stats":{"Line":0}},{"line":40,"address":[18903696],"length":1,"stats":{"Line":0}},{"line":45,"address":[18910513],"length":1,"stats":{"Line":0}},{"line":46,"address":[18917552,18917536],"length":1,"stats":{"Line":0}},{"line":49,"address":[12223712],"length":1,"stats":{"Line":0}},{"line":54,"address":[19020609],"length":1,"stats":{"Line":0}},{"line":55,"address":[12223808,12223792],"length":1,"stats":{"Line":0}},{"line":61,"address":[13214391,13214254,13214119,13214192,13219512,13216871,13214536,13214767],"length":1,"stats":{"Line":0}},{"line":67,"address":[19041637,19042015,19044140,19042391,19041861],"length":1,"stats":{"Line":0}},{"line":68,"address":[19037184,19035596,19035745,19035429],"length":1,"stats":{"Line":0}},{"line":70,"address":[19073989,19073830,19074208,19075280],"length":1,"stats":{"Line":0}},{"line":72,"address":[19042980,19043466,19043721,19044037,19043343,19043144,19043414],"length":1,"stats":{"Line":0}},{"line":73,"address":[13215979,13215893,13216162,13216849],"length":1,"stats":{"Line":0}},{"line":74,"address":[19175225,19174938],"length":1,"stats":{"Line":0}},{"line":76,"address":[11898258],"length":1,"stats":{"Line":0}},{"line":77,"address":[18975039,18969725,18969826,18974905,18970335],"length":1,"stats":{"Line":0}},{"line":78,"address":[18970298,18971306],"length":1,"stats":{"Line":0}},{"line":83,"address":[19077574,19077480],"length":1,"stats":{"Line":0}},{"line":84,"address":[12324124],"length":1,"stats":{"Line":0}},{"line":86,"address":[19039569],"length":1,"stats":{"Line":0}},{"line":87,"address":[19081535],"length":1,"stats":{"Line":0}},{"line":88,"address":[18978687],"length":1,"stats":{"Line":0}},{"line":94,"address":[19178897,19179712,19178499,19178578,19179685,19178391,19178464,19178690],"length":1,"stats":{"Line":0}},{"line":100,"address":[11814564],"length":1,"stats":{"Line":0}},{"line":101,"address":[19079013,19078853,19079149],"length":1,"stats":{"Line":0}},{"line":102,"address":[19084820,19084721],"length":1,"stats":{"Line":0}},{"line":105,"address":[19083367,19083666,19084661,19084688,19083873,19083475,19083440,19083554],"length":1,"stats":{"Line":0}},{"line":111,"address":[19180660,19180337,19181129,19180013,19180198],"length":1,"stats":{"Line":0}},{"line":112,"address":[19084357,19084493,19084197],"length":1,"stats":{"Line":0}},{"line":113,"address":[18981601,18981700],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","mod.rs"],"content":"pub mod cache;\npub mod crypto;\npub mod database;\npub mod event;\npub mod jobs;\npub mod messaging;\npub mod offline;\npub mod p2p;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mappers.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataRecord, OfflineActionRecord, OptimisticUpdateRecord, SyncQueueItem,\n    SyncStatusRecord,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{DateTime, Utc};\n\nuse super::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\n\npub fn offline_action_from_row(row: OfflineActionRow) -> Result<OfflineActionRecord, AppError> {\n    let action_id = OfflineActionId::parse(&row.local_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let public_key = PublicKey::from_hex_str(&row.user_pubkey)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let action_type = OfflineActionType::new(row.action_type.clone())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let target_id = row\n        .target_id\n        .map(|id| {\n            EntityId::new(id).map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        })\n        .transpose()?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.action_data)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let sync_status = if row.is_synced {\n        SyncStatus::FullySynced\n    } else {\n        SyncStatus::Pending\n    };\n    let created_at = timestamp_to_datetime(row.created_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n    let remote_id = row\n        .remote_id\n        .map(|id| {\n            RemoteEventId::new(id)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        })\n        .transpose()?;\n\n    Ok(OfflineActionRecord::new(\n        Some(row.id),\n        action_id,\n        public_key,\n        action_type,\n        target_id,\n        payload,\n        sync_status,\n        created_at,\n        synced_at,\n        remote_id,\n    ))\n}\n\npub fn sync_queue_item_from_row(row: SyncQueueItemRow) -> Result<SyncQueueItem, AppError> {\n    let id = SyncQueueId::new(row.id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let action_type = OfflineActionType::new(row.action_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.payload)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let status = SyncQueueStatus::from(row.status.as_str());\n    let created_at = timestamp_to_datetime(row.created_at);\n    let updated_at = timestamp_to_datetime(row.updated_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n\n    Ok(SyncQueueItem::new(\n        id,\n        action_type,\n        payload,\n        status,\n        try_i32_to_u32(row.retry_count, \"retry_count\")?,\n        try_i32_to_u32(row.max_retries, \"max_retries\")?,\n        created_at,\n        updated_at,\n        synced_at,\n        row.error_message,\n    ))\n}\n\npub fn cache_metadata_from_row(row: CacheMetadataRow) -> Result<CacheMetadataRecord, AppError> {\n    let cache_key = CacheKey::new(row.cache_key)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let cache_type = CacheType::new(row.cache_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let last_synced_at = row.last_synced_at.map(timestamp_to_datetime);\n    let last_accessed_at = row.last_accessed_at.map(timestamp_to_datetime);\n    let expiry_time = row.expiry_time.map(timestamp_to_datetime);\n    let metadata = row\n        .metadata\n        .map(|value| serde_json::from_str(&value))\n        .transpose()\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n    Ok(CacheMetadataRecord {\n        record_id: row.id,\n        cache_key,\n        cache_type,\n        last_synced_at,\n        last_accessed_at,\n        data_version: row.data_version,\n        is_stale: row.is_stale,\n        expiry_time,\n        metadata,\n        doc_version: row.doc_version,\n        blob_hash: row.blob_hash,\n        payload_bytes: row.payload_bytes,\n    })\n}\n\npub fn optimistic_update_from_row(\n    row: OptimisticUpdateRow,\n) -> Result<OptimisticUpdateRecord, AppError> {\n    let update_id = OptimisticUpdateId::new(row.update_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_type = EntityType::new(row.entity_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_id = EntityId::new(row.entity_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let original_data = row\n        .original_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n    let updated_data = payload_from_json_str(&row.updated_data)?;\n    let created_at = timestamp_to_datetime(row.created_at);\n    let confirmed_at = row.confirmed_at.map(timestamp_to_datetime);\n\n    Ok(OptimisticUpdateRecord {\n        record_id: row.id,\n        update_id,\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n        is_confirmed: row.is_confirmed,\n        created_at,\n        confirmed_at,\n    })\n}\n\npub fn sync_status_from_row(row: SyncStatusRow) -> Result<SyncStatusRecord, AppError> {\n    let entity_type = EntityType::new(row.entity_type)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let entity_id = EntityId::new(row.entity_id)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n    let sync_status = SyncStatus::from(row.sync_status.as_str());\n    let last_local_update = timestamp_to_datetime(row.last_local_update);\n    let last_remote_sync = row.last_remote_sync.map(timestamp_to_datetime);\n    let conflict_data = row\n        .conflict_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n\n    Ok(SyncStatusRecord {\n        record_id: row.id,\n        entity_type,\n        entity_id,\n        local_version: row.local_version,\n        remote_version: row.remote_version,\n        last_local_update,\n        last_remote_sync,\n        sync_status,\n        conflict_data,\n    })\n}\n\npub fn sync_queue_id_from_i64(value: i64) -> Result<SyncQueueId, AppError> {\n    SyncQueueId::new(value).map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn optimistic_update_id_from_string(value: String) -> Result<OptimisticUpdateId, AppError> {\n    OptimisticUpdateId::new(value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn payload_from_optional_json_str(\n    value: Option<String>,\n) -> Result<Option<OfflinePayload>, AppError> {\n    value.map(|json| payload_from_json_str(&json)).transpose()\n}\n\npub fn payload_from_json_str(json: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(json)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\npub fn payload_to_string(payload: &OfflinePayload) -> Result<String, AppError> {\n    serde_json::to_string(payload.as_json())\n        .map_err(|err| AppError::SerializationError(err.to_string()))\n}\n\npub fn timestamp_to_datetime(ts: i64) -> DateTime<Utc> {\n    DateTime::<Utc>::from_timestamp(ts, 0)\n        .or_else(|| DateTime::<Utc>::from_timestamp_millis(ts))\n        .unwrap_or_else(Utc::now)\n}\n\npub fn try_i32_to_u32(value: i32, label: &str) -> Result<u32, AppError> {\n    value.try_into().map_err(|_| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"{label} cannot be negative\"),\n        )\n    })\n}\n","traces":[{"line":17,"address":[23056000,23059973],"length":1,"stats":{"Line":2}},{"line":18,"address":[23022369,23017918,23018283,23018486,23018134,23018237],"length":1,"stats":{"Line":8}},{"line":19,"address":[23062134,23061857,23061971,23066444],"length":1,"stats":{"Line":4}},{"line":20,"address":[23018666,23018712,23022295,23018917,23018412,23018566],"length":1,"stats":{"Line":8}},{"line":21,"address":[26531406,26527830,26528094,26527933],"length":1,"stats":{"Line":4}},{"line":22,"address":[23019141,23022222,23019095,23018841,23018987,23019389],"length":1,"stats":{"Line":8}},{"line":23,"address":[22947659,22944430,22944749,22944541],"length":1,"stats":{"Line":4}},{"line":24,"address":[22944682,22944867,22947579,22945097],"length":1,"stats":{"Line":4}},{"line":26,"address":[23029840,23030002,23029976],"length":1,"stats":{"Line":2}},{"line":27,"address":[23066754,23066622],"length":1,"stats":{"Line":2}},{"line":30,"address":[23061663,23064168,23061817,23062111],"length":1,"stats":{"Line":4}},{"line":31,"address":[23065154,23062063,23065136],"length":1,"stats":{"Line":0}},{"line":32,"address":[26529120,26529302,26529379,26531156,26529678,26529437],"length":1,"stats":{"Line":12}},{"line":33,"address":[23062521,23062189,23062300,23064124],"length":1,"stats":{"Line":6}},{"line":34,"address":[23020457,23020576],"length":1,"stats":{"Line":6}},{"line":35,"address":[23058690],"length":1,"stats":{"Line":1}},{"line":37,"address":[23159030],"length":1,"stats":{"Line":3}},{"line":39,"address":[23062657],"length":1,"stats":{"Line":3}},{"line":40,"address":[22952869],"length":1,"stats":{"Line":3}},{"line":41,"address":[17201198,17200420],"length":1,"stats":{"Line":3}},{"line":43,"address":[23023248,23023410,23023384],"length":1,"stats":{"Line":0}},{"line":44,"address":[22962430,22962513],"length":1,"stats":{"Line":0}},{"line":45,"address":[23067070,23067090,23066982],"length":1,"stats":{"Line":0}},{"line":49,"address":[22960408,22960749],"length":1,"stats":{"Line":6}},{"line":50,"address":[22953125],"length":1,"stats":{"Line":3}},{"line":51,"address":[23020960],"length":1,"stats":{"Line":3}},{"line":52,"address":[22953192],"length":1,"stats":{"Line":3}},{"line":53,"address":[23059152],"length":1,"stats":{"Line":3}},{"line":54,"address":[23159560],"length":1,"stats":{"Line":3}},{"line":55,"address":[22953312],"length":1,"stats":{"Line":3}},{"line":56,"address":[23159640],"length":1,"stats":{"Line":3}},{"line":59,"address":[23021200],"length":1,"stats":{"Line":3}},{"line":63,"address":[22951826,22948832],"length":1,"stats":{"Line":3}},{"line":64,"address":[23030556,23030380,23034021,23030637,23030683,23030876],"length":1,"stats":{"Line":11}},{"line":65,"address":[17203459,17203612,17203348,17207016],"length":1,"stats":{"Line":4}},{"line":66,"address":[17203545,17203773,17204025,17206769,17203689,17203819],"length":1,"stats":{"Line":11}},{"line":67,"address":[23066033,23066147,23066313,23069119],"length":1,"stats":{"Line":4}},{"line":68,"address":[23067932,23070700,23068089,23068386],"length":1,"stats":{"Line":5}},{"line":69,"address":[22959616,22959634,22956834],"length":1,"stats":{"Line":0}},{"line":70,"address":[26534049,26535791,26533805,26533863,26533543,26533728],"length":1,"stats":{"Line":11}},{"line":71,"address":[23025045,23024879,23024768,23026960],"length":1,"stats":{"Line":4}},{"line":72,"address":[23163496,23163653],"length":1,"stats":{"Line":5}},{"line":73,"address":[23025205],"length":1,"stats":{"Line":3}},{"line":74,"address":[17204979],"length":1,"stats":{"Line":2}},{"line":75,"address":[22964462],"length":1,"stats":{"Line":3}},{"line":77,"address":[23164383,23164771],"length":1,"stats":{"Line":4}},{"line":79,"address":[23163805],"length":1,"stats":{"Line":2}},{"line":80,"address":[17205085],"length":1,"stats":{"Line":3}},{"line":81,"address":[23032349],"length":1,"stats":{"Line":2}},{"line":82,"address":[22957661,22957857,22957738],"length":1,"stats":{"Line":5}},{"line":83,"address":[17205833,17205498,17205333],"length":1,"stats":{"Line":5}},{"line":87,"address":[23032799],"length":1,"stats":{"Line":3}},{"line":91,"address":[23071589,23071810,23069632],"length":1,"stats":{"Line":3}},{"line":92,"address":[23034755,23035001,23034674,23034534,23036514,23034798],"length":1,"stats":{"Line":12}},{"line":93,"address":[23029775,23028034,23027862,23027754],"length":1,"stats":{"Line":6}},{"line":94,"address":[23073246,23071839,23071666,23071966,23071920,23072166],"length":1,"stats":{"Line":12}},{"line":95,"address":[26537210,26538316,26536955,26537058],"length":1,"stats":{"Line":6}},{"line":96,"address":[26537183],"length":1,"stats":{"Line":3}},{"line":97,"address":[23028548],"length":1,"stats":{"Line":3}},{"line":98,"address":[23072276],"length":1,"stats":{"Line":3}},{"line":99,"address":[23029467,23028612],"length":1,"stats":{"Line":3}},{"line":101,"address":[23168379,23168352],"length":1,"stats":{"Line":6}},{"line":103,"address":[23067531,23068146,23068128],"length":1,"stats":{"Line":0}},{"line":105,"address":[23167510],"length":1,"stats":{"Line":3}},{"line":106,"address":[23070909],"length":1,"stats":{"Line":3}},{"line":107,"address":[23028868],"length":1,"stats":{"Line":3}},{"line":108,"address":[22968075],"length":1,"stats":{"Line":3}},{"line":111,"address":[23072651],"length":1,"stats":{"Line":3}},{"line":112,"address":[26537718],"length":1,"stats":{"Line":3}},{"line":115,"address":[23167449],"length":1,"stats":{"Line":3}},{"line":116,"address":[23072673],"length":1,"stats":{"Line":3}},{"line":117,"address":[22954430],"length":1,"stats":{"Line":3}},{"line":121,"address":[17212647,17209888,17213058],"length":1,"stats":{"Line":0}},{"line":124,"address":[22958487,22956097,22955894,22955606,22955770,22955851],"length":1,"stats":{"Line":0}},{"line":125,"address":[23030650,23033359,23030370,23030478],"length":1,"stats":{"Line":0}},{"line":126,"address":[22956531,22955994,22958451,22956294,22956248,22956167],"length":1,"stats":{"Line":0}},{"line":127,"address":[23074463,23074574,23076753,23074771],"length":1,"stats":{"Line":0}},{"line":128,"address":[22963515,22965195,22963469,22963388,22963755,22963203],"length":1,"stats":{"Line":0}},{"line":129,"address":[22972189,22970372,22970683,22970483],"length":1,"stats":{"Line":0}},{"line":130,"address":[23073496,23075030,23073684,23073905],"length":1,"stats":{"Line":0}},{"line":132,"address":[23033515,23033488],"length":1,"stats":{"Line":0}},{"line":134,"address":[23032102,23031947,23031784],"length":1,"stats":{"Line":0}},{"line":135,"address":[23074123],"length":1,"stats":{"Line":0}},{"line":136,"address":[17211940],"length":1,"stats":{"Line":0}},{"line":138,"address":[22971708],"length":1,"stats":{"Line":0}},{"line":139,"address":[26540884],"length":1,"stats":{"Line":0}},{"line":140,"address":[22964463],"length":1,"stats":{"Line":0}},{"line":141,"address":[23032310],"length":1,"stats":{"Line":0}},{"line":142,"address":[23032358],"length":1,"stats":{"Line":0}},{"line":143,"address":[23076102],"length":1,"stats":{"Line":0}},{"line":144,"address":[22964662],"length":1,"stats":{"Line":0}},{"line":145,"address":[23171014],"length":1,"stats":{"Line":0}},{"line":151,"address":[23172112,23174042,23174239],"length":1,"stats":{"Line":1}},{"line":152,"address":[23072030,23071906,23072233,23071766,23071987,23073719],"length":1,"stats":{"Line":4}},{"line":153,"address":[23172282,23172562,23174272,23172390],"length":1,"stats":{"Line":2}},{"line":154,"address":[23077887,23078014,23078208,23077968,23079267,23077714],"length":1,"stats":{"Line":4}},{"line":155,"address":[17214176,17213911,17214022,17215297],"length":1,"stats":{"Line":2}},{"line":156,"address":[22966631,22966786],"length":1,"stats":{"Line":2}},{"line":157,"address":[23034618],"length":1,"stats":{"Line":1}},{"line":158,"address":[26543222],"length":1,"stats":{"Line":1}},{"line":159,"address":[26543989,26543249],"length":1,"stats":{"Line":1}},{"line":161,"address":[23042843,23042816],"length":1,"stats":{"Line":0}},{"line":164,"address":[26543604],"length":1,"stats":{"Line":1}},{"line":165,"address":[26543453],"length":1,"stats":{"Line":1}},{"line":166,"address":[23173417],"length":1,"stats":{"Line":1}},{"line":167,"address":[23173456],"length":1,"stats":{"Line":1}},{"line":168,"address":[23073136],"length":1,"stats":{"Line":1}},{"line":169,"address":[23078726],"length":1,"stats":{"Line":1}},{"line":172,"address":[22967228],"length":1,"stats":{"Line":1}},{"line":177,"address":[22961440,22961581,22961607],"length":1,"stats":{"Line":4}},{"line":178,"address":[22975219,22975351],"length":1,"stats":{"Line":3}},{"line":181,"address":[23043272,23043298,23043136],"length":1,"stats":{"Line":1}},{"line":182,"address":[23080001,23079918],"length":1,"stats":{"Line":2}},{"line":183,"address":[22961654,22961742,22961762],"length":1,"stats":{"Line":2}},{"line":186,"address":[26544848],"length":1,"stats":{"Line":1}},{"line":189,"address":[23080093,23080171,23080144],"length":1,"stats":{"Line":3}},{"line":192,"address":[26545174,26545196,26545040],"length":1,"stats":{"Line":1}},{"line":193,"address":[23074811,23074728],"length":1,"stats":{"Line":2}},{"line":194,"address":[17216440,17216352,17216460],"length":1,"stats":{"Line":2}},{"line":197,"address":[23078832],"length":1,"stats":{"Line":2}},{"line":198,"address":[22962222],"length":1,"stats":{"Line":2}},{"line":199,"address":[17216576,17216594],"length":1,"stats":{"Line":0}},{"line":202,"address":[22969216],"length":1,"stats":{"Line":3}},{"line":203,"address":[22969235],"length":1,"stats":{"Line":3}},{"line":204,"address":[23079168,23079185],"length":1,"stats":{"Line":0}},{"line":208,"address":[22969360],"length":1,"stats":{"Line":2}},{"line":209,"address":[17216919,17216960],"length":1,"stats":{"Line":3}},{"line":210,"address":[26545818],"length":1,"stats":{"Line":0}},{"line":211,"address":[17216981],"length":1,"stats":{"Line":0}},{"line":212,"address":[22976442],"length":1,"stats":{"Line":0}}],"covered":98,"coverable":130},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","metrics.rs"],"content":"use serde::Serialize;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{LazyLock, Mutex};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n#[derive(Debug, Clone, Copy, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"snake_case\")]\npub enum RetryOutcomeStatus {\n    Success,\n    Failure,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"camelCase\")]\npub struct OfflineRetryMetricsSnapshot {\n    pub total_success: u64,\n    pub total_failure: u64,\n    pub consecutive_failure: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n    pub last_outcome: Option<RetryOutcomeStatus>,\n    pub last_job_id: Option<String>,\n    pub last_job_reason: Option<String>,\n    pub last_trigger: Option<String>,\n    pub last_user_pubkey: Option<String>,\n    pub last_retry_count: Option<u32>,\n    pub last_max_retries: Option<u32>,\n    pub last_backoff_ms: Option<u64>,\n    pub last_duration_ms: Option<u64>,\n    pub last_success_count: Option<u32>,\n    pub last_failure_count: Option<u32>,\n    pub last_timestamp_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq, Eq)]\n#[serde(rename_all = \"camelCase\")]\npub struct RetryOutcomeMetadata {\n    pub job_id: Option<String>,\n    pub job_reason: Option<String>,\n    pub trigger: Option<String>,\n    pub user_pubkey: Option<String>,\n    pub retry_count: Option<u32>,\n    pub max_retries: Option<u32>,\n    pub backoff_ms: Option<u64>,\n    pub duration_ms: Option<u64>,\n    pub success_count: Option<u32>,\n    pub failure_count: Option<u32>,\n    pub timestamp_ms: Option<u64>,\n}\n\nimpl RetryOutcomeMetadata {\n    pub fn new() -> Self {\n        Self {\n            job_id: None,\n            job_reason: None,\n            trigger: None,\n            user_pubkey: None,\n            retry_count: None,\n            max_retries: None,\n            backoff_ms: None,\n            duration_ms: None,\n            success_count: None,\n            failure_count: None,\n            timestamp_ms: None,\n        }\n    }\n}\n\nimpl Default for RetryOutcomeMetadata {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[derive(Default, Clone)]\nstruct LastRetryMetadata {\n    last_outcome: Option<RetryOutcomeStatus>,\n    job_id: Option<String>,\n    job_reason: Option<String>,\n    trigger: Option<String>,\n    user_pubkey: Option<String>,\n    retry_count: Option<u32>,\n    max_retries: Option<u32>,\n    backoff_ms: Option<u64>,\n    duration_ms: Option<u64>,\n    success_count: Option<u32>,\n    failure_count: Option<u32>,\n    timestamp_ms: Option<u64>,\n}\n\nstruct OfflineRetryMetrics {\n    success: AtomicU64,\n    failure: AtomicU64,\n    consecutive_failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n    metadata: Mutex<LastRetryMetadata>,\n}\n\nimpl OfflineRetryMetrics {\n    fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            consecutive_failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(0),\n            last_failure_ms: AtomicU64::new(0),\n            metadata: Mutex::new(LastRetryMetadata::default()),\n        }\n    }\n\n    fn record(&self, status: RetryOutcomeStatus, meta: &RetryOutcomeMetadata) {\n        match status {\n            RetryOutcomeStatus::Success => {\n                self.success.fetch_add(1, Ordering::Relaxed);\n                self.last_success_ms\n                    .store(current_unix_ms(), Ordering::Relaxed);\n                self.consecutive_failure.store(0, Ordering::Relaxed);\n            }\n            RetryOutcomeStatus::Failure => {\n                self.failure.fetch_add(1, Ordering::Relaxed);\n                self.last_failure_ms\n                    .store(current_unix_ms(), Ordering::Relaxed);\n                self.consecutive_failure.fetch_add(1, Ordering::Relaxed);\n            }\n        }\n\n        if let Ok(mut guard) = self.metadata.lock() {\n            guard.last_outcome = Some(status);\n            guard.job_id = meta.job_id.clone();\n            guard.job_reason = meta.job_reason.clone();\n            guard.trigger = meta.trigger.clone();\n            guard.user_pubkey = meta.user_pubkey.clone();\n            guard.retry_count = meta.retry_count;\n            guard.max_retries = meta.max_retries;\n            guard.backoff_ms = meta.backoff_ms;\n            guard.duration_ms = meta.duration_ms;\n            guard.success_count = meta.success_count;\n            guard.failure_count = meta.failure_count;\n            guard.timestamp_ms = meta.timestamp_ms.or_else(|| Some(current_unix_ms()));\n        }\n    }\n\n    fn snapshot(&self) -> OfflineRetryMetricsSnapshot {\n        let metadata = self\n            .metadata\n            .lock()\n            .map(|guard| guard.clone())\n            .unwrap_or_else(|_| LastRetryMetadata::default());\n\n        OfflineRetryMetricsSnapshot {\n            total_success: self.success.load(Ordering::Relaxed),\n            total_failure: self.failure.load(Ordering::Relaxed),\n            consecutive_failure: self.consecutive_failure.load(Ordering::Relaxed),\n            last_success_ms: to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n            last_outcome: metadata.last_outcome,\n            last_job_id: metadata.job_id,\n            last_job_reason: metadata.job_reason,\n            last_trigger: metadata.trigger,\n            last_user_pubkey: metadata.user_pubkey,\n            last_retry_count: metadata.retry_count,\n            last_max_retries: metadata.max_retries,\n            last_backoff_ms: metadata.backoff_ms,\n            last_duration_ms: metadata.duration_ms,\n            last_success_count: metadata.success_count,\n            last_failure_count: metadata.failure_count,\n            last_timestamp_ms: metadata.timestamp_ms,\n        }\n    }\n}\n\nfn to_option(value: u64) -> Option<u64> {\n    if value == 0 { None } else { Some(value) }\n}\n\nfn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|duration| duration.as_millis() as u64)\n        .unwrap_or(0)\n}\n\nstatic OFFLINE_RETRY_METRICS: LazyLock<OfflineRetryMetrics> =\n    LazyLock::new(OfflineRetryMetrics::new);\n\npub fn record_outcome(\n    status: RetryOutcomeStatus,\n    metadata: &RetryOutcomeMetadata,\n) -> OfflineRetryMetricsSnapshot {\n    OFFLINE_RETRY_METRICS.record(status, metadata);\n    OFFLINE_RETRY_METRICS.snapshot()\n}\n\npub fn snapshot() -> OfflineRetryMetricsSnapshot {\n    OFFLINE_RETRY_METRICS.snapshot()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{RetryOutcomeMetadata, RetryOutcomeStatus};\n\n    #[test]\n    fn record_success_and_failure() {\n        let meta = RetryOutcomeMetadata {\n            job_id: Some(\"job-1\".into()),\n            job_reason: Some(\"pending-actions\".into()),\n            trigger: Some(\"worker\".into()),\n            retry_count: Some(1),\n            max_retries: Some(3),\n            backoff_ms: Some(5_000),\n            duration_ms: Some(800),\n            success_count: Some(2),\n            failure_count: Some(0),\n            timestamp_ms: Some(1_000),\n            user_pubkey: Some(\"npub\".into()),\n        };\n\n        super::record_outcome(RetryOutcomeStatus::Success, &meta);\n\n        let snapshot = super::snapshot();\n        assert_eq!(snapshot.total_success, 1);\n        assert_eq!(snapshot.total_failure, 0);\n        assert_eq!(snapshot.last_outcome, Some(RetryOutcomeStatus::Success));\n        assert_eq!(snapshot.last_job_id.as_deref(), Some(\"job-1\"));\n        assert_eq!(snapshot.last_backoff_ms, Some(5_000));\n\n        let failure_meta = RetryOutcomeMetadata {\n            job_id: Some(\"job-2\".into()),\n            failure_count: Some(1),\n            ..RetryOutcomeMetadata::default()\n        };\n\n        super::record_outcome(RetryOutcomeStatus::Failure, &failure_meta);\n        let snapshot = super::snapshot();\n        assert_eq!(snapshot.total_success, 1);\n        assert_eq!(snapshot.total_failure, 1);\n        assert_eq!(snapshot.last_outcome, Some(RetryOutcomeStatus::Failure));\n        assert_eq!(snapshot.last_job_id.as_deref(), Some(\"job-2\"));\n    }\n}\n","traces":[{"line":52,"address":[23927408],"length":1,"stats":{"Line":1}},{"line":70,"address":[23827424],"length":1,"stats":{"Line":1}},{"line":71,"address":[23796248],"length":1,"stats":{"Line":1}},{"line":101,"address":[23833040],"length":1,"stats":{"Line":1}},{"line":103,"address":[23827472],"length":1,"stats":{"Line":1}},{"line":104,"address":[23721582],"length":1,"stats":{"Line":1}},{"line":105,"address":[23927900],"length":1,"stats":{"Line":1}},{"line":106,"address":[17969162],"length":1,"stats":{"Line":1}},{"line":107,"address":[23721672],"length":1,"stats":{"Line":1}},{"line":108,"address":[23789510],"length":1,"stats":{"Line":1}},{"line":112,"address":[23715056,23717374,23717449],"length":1,"stats":{"Line":1}},{"line":113,"address":[23833395],"length":1,"stats":{"Line":1}},{"line":115,"address":[23789761],"length":1,"stats":{"Line":1}},{"line":116,"address":[17969552,17969514],"length":1,"stats":{"Line":2}},{"line":117,"address":[12224840],"length":1,"stats":{"Line":1}},{"line":118,"address":[23831909],"length":1,"stats":{"Line":1}},{"line":121,"address":[23828018],"length":1,"stats":{"Line":1}},{"line":122,"address":[23789947,23789985],"length":1,"stats":{"Line":2}},{"line":123,"address":[23828073],"length":1,"stats":{"Line":1}},{"line":124,"address":[23729174],"length":1,"stats":{"Line":1}},{"line":128,"address":[23796975],"length":1,"stats":{"Line":1}},{"line":129,"address":[23832274,23832152],"length":1,"stats":{"Line":2}},{"line":130,"address":[17969951,17971731],"length":1,"stats":{"Line":1}},{"line":131,"address":[23834189,23835693],"length":1,"stats":{"Line":1}},{"line":132,"address":[23832795,23834023],"length":1,"stats":{"Line":1}},{"line":133,"address":[23829113,23830056],"length":1,"stats":{"Line":1}},{"line":134,"address":[23834960],"length":1,"stats":{"Line":1}},{"line":135,"address":[23791359],"length":1,"stats":{"Line":1}},{"line":136,"address":[23833502],"length":1,"stats":{"Line":1}},{"line":137,"address":[23716933],"length":1,"stats":{"Line":1}},{"line":138,"address":[23723790],"length":1,"stats":{"Line":1}},{"line":139,"address":[23791675],"length":1,"stats":{"Line":1}},{"line":140,"address":[23717488,23717160,23717492],"length":1,"stats":{"Line":3}},{"line":144,"address":[23799056,23800174],"length":1,"stats":{"Line":1}},{"line":145,"address":[17971883],"length":1,"stats":{"Line":1}},{"line":148,"address":[23837003,23836976],"length":1,"stats":{"Line":2}},{"line":149,"address":[17973161,17973136],"length":1,"stats":{"Line":0}},{"line":152,"address":[23835953],"length":1,"stats":{"Line":1}},{"line":153,"address":[23731515],"length":1,"stats":{"Line":1}},{"line":154,"address":[23834438],"length":1,"stats":{"Line":1}},{"line":155,"address":[23930913],"length":1,"stats":{"Line":1}},{"line":156,"address":[23717926],"length":1,"stats":{"Line":1}},{"line":157,"address":[23836284],"length":1,"stats":{"Line":1}},{"line":158,"address":[23834647],"length":1,"stats":{"Line":1}},{"line":159,"address":[23834695],"length":1,"stats":{"Line":1}},{"line":160,"address":[23834743],"length":1,"stats":{"Line":1}},{"line":161,"address":[23731911],"length":1,"stats":{"Line":1}},{"line":162,"address":[23718199],"length":1,"stats":{"Line":1}},{"line":163,"address":[23799738],"length":1,"stats":{"Line":1}},{"line":164,"address":[23792825],"length":1,"stats":{"Line":1}},{"line":165,"address":[23725033],"length":1,"stats":{"Line":1}},{"line":166,"address":[23725049],"length":1,"stats":{"Line":1}},{"line":167,"address":[23792873],"length":1,"stats":{"Line":1}},{"line":168,"address":[23732056],"length":1,"stats":{"Line":1}},{"line":173,"address":[23835584],"length":1,"stats":{"Line":1}},{"line":174,"address":[23800474],"length":1,"stats":{"Line":1}},{"line":177,"address":[23732768],"length":1,"stats":{"Line":1}},{"line":178,"address":[12228532],"length":1,"stats":{"Line":1}},{"line":180,"address":[12228608,12228623],"length":1,"stats":{"Line":2}},{"line":187,"address":[23732880],"length":1,"stats":{"Line":1}},{"line":191,"address":[23793749],"length":1,"stats":{"Line":1}},{"line":192,"address":[23719193],"length":1,"stats":{"Line":1}},{"line":195,"address":[23837520],"length":1,"stats":{"Line":1}},{"line":196,"address":[23733006],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":64},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mod.rs"],"content":"mod mappers;\npub mod metrics;\npub mod reindex_job;\nmod rows;\npub mod sqlite_store;\n\npub use reindex_job::OfflineReindexJob;\npub use sqlite_store::SqliteOfflinePersistence;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","reindex_job.rs"],"content":"﻿use crate::application::ports::offline_store::OfflinePersistence;\r\nuse crate::domain::entities::offline::{OfflineActionFilter, OfflineActionRecord};\r\nuse crate::shared::error::AppError;\r\nuse chrono::Utc;\r\nuse serde::{Deserialize, Serialize};\r\nuse std::sync::Arc;\r\nuse tauri::Emitter;\r\nuse tokio::sync::Mutex;\r\n\r\npub trait ReindexEventEmitter: Send + Sync {\r\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String>;\r\n    fn emit_failure(&self, message: &str) -> Result<(), String>;\r\n}\r\n\r\nstruct TauriEventEmitter {\r\n    handle: tauri::AppHandle,\r\n}\r\n\r\nimpl ReindexEventEmitter for TauriEventEmitter {\r\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String> {\r\n        self.handle\r\n            .emit(\"offline://reindex_complete\", report)\r\n            .map_err(|err| err.to_string())\r\n    }\r\n\r\n    fn emit_failure(&self, message: &str) -> Result<(), String> {\r\n        self.handle\r\n            .emit(\"offline://reindex_failed\", message.to_string())\r\n            .map_err(|err| err.to_string())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SyncConflictDigest {\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub sync_status: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct OfflineReindexReport {\r\n    pub offline_action_count: usize,\r\n    pub queued_action_count: usize,\r\n    pub pending_queue_count: usize,\r\n    pub stale_cache_keys: Vec<String>,\r\n    pub optimistic_update_ids: Vec<String>,\r\n    pub sync_conflicts: Vec<SyncConflictDigest>,\r\n    pub queued_offline_action_ids: Vec<String>,\r\n    pub emitted_at: i64,\r\n}\r\n\r\npub struct OfflineReindexJob {\r\n    event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\r\n    persistence: Arc<dyn OfflinePersistence>,\r\n    gate: Mutex<()>,\r\n}\r\n\r\nimpl OfflineReindexJob {\r\n    pub fn create(\r\n        app_handle: Option<tauri::AppHandle>,\r\n        persistence: Arc<dyn OfflinePersistence>,\r\n    ) -> Arc<Self> {\r\n        let emitter = app_handle\r\n            .map(|handle| Arc::new(TauriEventEmitter { handle }) as Arc<dyn ReindexEventEmitter>);\r\n        Self::with_emitter(emitter, persistence)\r\n    }\r\n\r\n    pub fn with_emitter(\r\n        event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\r\n        persistence: Arc<dyn OfflinePersistence>,\r\n    ) -> Arc<Self> {\r\n        Arc::new(Self {\r\n            event_emitter,\r\n            persistence,\r\n            gate: Mutex::new(()),\r\n        })\r\n    }\r\n\r\n    pub fn trigger(self: &Arc<Self>) {\r\n        let job = Arc::clone(self);\r\n        tauri::async_runtime::spawn(async move {\r\n            job.run_guarded().await;\r\n        });\r\n    }\r\n\r\n    pub async fn reindex_once(&self) -> Result<OfflineReindexReport, AppError> {\r\n        let unsynced = self\r\n            .persistence\r\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\r\n            .await?;\r\n\r\n        let mut queued_action_count = 0usize;\r\n        let mut queued_local_ids = Vec::new();\r\n\r\n        for action in &unsynced {\r\n            if self.ensure_action_in_queue(action).await? {\r\n                queued_action_count += 1;\r\n                queued_local_ids.push(action.action_id.to_string());\r\n            }\r\n        }\r\n\r\n        let pending_queue = self.persistence.pending_sync_items().await?;\r\n        let stale_cache = self.persistence.stale_cache_entries().await?;\r\n        let optimistic_updates = self.persistence.unconfirmed_updates().await?;\r\n        let conflicts = self.persistence.sync_conflicts().await?;\r\n\r\n        let report = OfflineReindexReport {\r\n            offline_action_count: unsynced.len(),\r\n            queued_action_count,\r\n            pending_queue_count: pending_queue.len(),\r\n            stale_cache_keys: stale_cache\r\n                .into_iter()\r\n                .map(|entry| entry.cache_key.to_string())\r\n                .collect(),\r\n            optimistic_update_ids: optimistic_updates\r\n                .into_iter()\r\n                .map(|item| item.update_id.to_string())\r\n                .collect(),\r\n            sync_conflicts: conflicts\r\n                .into_iter()\r\n                .map(|record| SyncConflictDigest {\r\n                    entity_type: record.entity_type.to_string(),\r\n                    entity_id: record.entity_id.to_string(),\r\n                    sync_status: record.sync_status.as_str().into_owned(),\r\n                })\r\n                .collect(),\r\n            queued_offline_action_ids: queued_local_ids,\r\n            emitted_at: Utc::now().timestamp_millis(),\r\n        };\r\n\r\n        Ok(report)\r\n    }\r\n\r\n    async fn ensure_action_in_queue(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\r\n        self.persistence.enqueue_if_missing(action).await\r\n    }\r\n\r\n    async fn run_guarded(self: Arc<Self>) {\r\n        let _guard = self.gate.lock().await;\r\n        match self.reindex_once().await {\r\n            Ok(report) => self.emit_success(&report),\r\n            Err(err) => self.emit_failure(&err.to_string()),\r\n        }\r\n    }\r\n\r\n    fn emit_success(&self, report: &OfflineReindexReport) {\r\n        if let Some(emitter) = &self.event_emitter {\r\n            if let Err(err) = emitter.emit_report(report) {\r\n                tracing::warn!(\r\n                    target: \"offline::reindex\",\r\n                    error = %err,\r\n                    \"failed to emit offline reindex completion event\"\r\n                );\r\n            }\r\n        }\r\n        tracing::info!(\r\n            target: \"offline::reindex\",\r\n            queued = report.queued_action_count,\r\n            pending = report.pending_queue_count,\r\n            \"offline reindex completed\"\r\n        );\r\n    }\r\n\r\n    fn emit_failure(&self, message: &str) {\r\n        if let Some(emitter) = &self.event_emitter {\r\n            if let Err(err) = emitter.emit_failure(message) {\r\n                tracing::warn!(\r\n                    target: \"offline::reindex\",\r\n                    error = %err,\r\n                    \"failed to emit offline reindex failure event\"\r\n                );\r\n            }\r\n        }\r\n        tracing::error!(\r\n            target: \"offline::reindex\",\r\n            error = message,\r\n            \"offline reindex job failed\"\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::domain::entities::offline::{OfflineActionDraft, OfflineActionFilter};\r\n    use crate::domain::value_objects::event_gateway::PublicKey;\r\n    use crate::domain::value_objects::offline::{EntityId, OfflineActionType, OfflinePayload};\r\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\r\n    use sqlx::sqlite::SqlitePoolOptions;\r\n\r\n    const PUBKEY: &str = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\r\n\r\n    async fn setup_persistence() -> Arc<dyn OfflinePersistence> {\r\n        let pool = SqlitePoolOptions::new()\r\n            .max_connections(1)\r\n            .connect(\"sqlite::memory:\")\r\n            .await\r\n            .unwrap();\r\n\r\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\r\n\r\n        Arc::new(SqliteOfflinePersistence::new(pool))\r\n    }\r\n\r\n    fn sample_draft(index: u32) -> OfflineActionDraft {\r\n        OfflineActionDraft::new(\r\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\r\n            OfflineActionType::new(\"queue_test\".to_string()).unwrap(),\r\n            Some(EntityId::new(format!(\"post_{index}\")).unwrap()),\r\n            OfflinePayload::from_json_str(&format!(\"{{\\\"idx\\\": {index}}}\")).unwrap(),\r\n        )\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_reindex_queues_unsynced_actions() {\r\n        let persistence = setup_persistence().await;\r\n        persistence.save_action(sample_draft(1)).await.unwrap();\r\n        persistence.save_action(sample_draft(2)).await.unwrap();\r\n\r\n        let job = OfflineReindexJob::with_emitter(None, persistence.clone());\r\n\r\n        let report = job.reindex_once().await.unwrap();\r\n        assert_eq!(report.offline_action_count, 2);\r\n        assert_eq!(report.queued_action_count, 2);\r\n        assert_eq!(report.pending_queue_count, 2);\r\n        assert_eq!(report.queued_offline_action_ids.len(), 2);\r\n\r\n        // 再実行すると新規キュー追加は発生しない\r\n        let report_second = job.reindex_once().await.unwrap();\r\n        assert_eq!(report_second.queued_action_count, 0);\r\n        assert_eq!(report_second.pending_queue_count, 2);\r\n\r\n        let unsynced_after = persistence\r\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\r\n            .await\r\n            .unwrap();\r\n        assert_eq!(unsynced_after.len(), 2);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[17973600],"length":1,"stats":{"Line":0}},{"line":21,"address":[19293899],"length":1,"stats":{"Line":0}},{"line":23,"address":[23800896,23800912],"length":1,"stats":{"Line":0}},{"line":26,"address":[23836128],"length":1,"stats":{"Line":0}},{"line":27,"address":[23794160],"length":1,"stats":{"Line":0}},{"line":28,"address":[23837840],"length":1,"stats":{"Line":0}},{"line":29,"address":[23726432,23726416],"length":1,"stats":{"Line":0}},{"line":59,"address":[17974205,17974048,17974179],"length":1,"stats":{"Line":0}},{"line":63,"address":[23719758,23719824],"length":1,"stats":{"Line":0}},{"line":64,"address":[23838208,23838240],"length":1,"stats":{"Line":0}},{"line":65,"address":[23836474],"length":1,"stats":{"Line":0}},{"line":68,"address":[23794576,23794804,23794779],"length":1,"stats":{"Line":2}},{"line":72,"address":[23794696],"length":1,"stats":{"Line":2}},{"line":73,"address":[23733783],"length":1,"stats":{"Line":2}},{"line":74,"address":[23933105],"length":1,"stats":{"Line":2}},{"line":75,"address":[23720043],"length":1,"stats":{"Line":2}},{"line":79,"address":[19294784],"length":1,"stats":{"Line":0}},{"line":80,"address":[23794847],"length":1,"stats":{"Line":0}},{"line":81,"address":[23833500,23832973,23833049,23833024,23833125,23833162,23833282],"length":1,"stats":{"Line":0}},{"line":82,"address":[23801918,23801968,23802130,23802025],"length":1,"stats":{"Line":0}},{"line":86,"address":[23720895,23720824,23720816,23721205,23722321,23720848,23721531,23721057],"length":1,"stats":{"Line":8}},{"line":87,"address":[23735238,23736025,23735551,23735147,23734776,23735431,23735757],"length":1,"stats":{"Line":10}},{"line":89,"address":[23839582],"length":1,"stats":{"Line":2}},{"line":90,"address":[11650657],"length":1,"stats":{"Line":8}},{"line":92,"address":[23934979],"length":1,"stats":{"Line":2}},{"line":93,"address":[23840211],"length":1,"stats":{"Line":2}},{"line":95,"address":[23838846,23838734,23839574,23839649],"length":1,"stats":{"Line":9}},{"line":96,"address":[11745464],"length":1,"stats":{"Line":9}},{"line":97,"address":[19297216,19297316],"length":1,"stats":{"Line":2}},{"line":98,"address":[23729679,23729598],"length":1,"stats":{"Line":5}},{"line":102,"address":[11650706],"length":1,"stats":{"Line":7}},{"line":103,"address":[23727934,23730797,23730451,23730653,23731464,23731194],"length":1,"stats":{"Line":7}},{"line":104,"address":[23739137,23738328,23734931,23738874,23738129,23738480],"length":1,"stats":{"Line":7}},{"line":105,"address":[11607079],"length":1,"stats":{"Line":7}},{"line":108,"address":[23842412],"length":1,"stats":{"Line":2}},{"line":110,"address":[23838647],"length":1,"stats":{"Line":3}},{"line":111,"address":[19300256],"length":1,"stats":{"Line":2}},{"line":115,"address":[23807608,23807729],"length":1,"stats":{"Line":5}},{"line":119,"address":[23839078,23838967],"length":1,"stats":{"Line":5}},{"line":128,"address":[23844760,23844823],"length":1,"stats":{"Line":5}},{"line":131,"address":[23726737],"length":1,"stats":{"Line":3}},{"line":134,"address":[23846747,23846179,23846328,23846483,23846112,23846144,23846125,23846288],"length":1,"stats":{"Line":8}},{"line":135,"address":[11789988],"length":1,"stats":{"Line":6}},{"line":138,"address":[23730107,23728608,23729206,23728521,23728480,23728812,23728488,23728496],"length":1,"stats":{"Line":0}},{"line":139,"address":[11637913],"length":1,"stats":{"Line":0}},{"line":140,"address":[17982957,17983519,17983412,17983337],"length":1,"stats":{"Line":0}},{"line":141,"address":[23942847,23942618],"length":1,"stats":{"Line":0}},{"line":142,"address":[17984189,17984003],"length":1,"stats":{"Line":0}},{"line":146,"address":[23730192,23730848,23732121],"length":1,"stats":{"Line":0}},{"line":147,"address":[23842927],"length":1,"stats":{"Line":0}},{"line":148,"address":[23730279,23730379],"length":1,"stats":{"Line":0}},{"line":149,"address":[19304553,19305076,19469001,19304897,19469158,19304458],"length":1,"stats":{"Line":0}},{"line":156,"address":[23806735,23807385,23804939,23952409,23952543],"length":1,"stats":{"Line":0}},{"line":164,"address":[23846144,23848075,23846808],"length":1,"stats":{"Line":0}},{"line":165,"address":[17987775],"length":1,"stats":{"Line":0}},{"line":166,"address":[23733527,23733635],"length":1,"stats":{"Line":0}},{"line":167,"address":[23815187,23959967,23959833,23815282,23815626,23815759],"length":1,"stats":{"Line":0}},{"line":174,"address":[23809985,23810569,23953535,23808195,23953401],"length":1,"stats":{"Line":0}}],"covered":28,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","rows.rs"],"content":"use serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OfflineActionRow {\n    pub id: i64,\n    pub user_pubkey: String,\n    pub action_type: String,\n    pub target_id: Option<String>,\n    pub action_data: String,\n    pub local_id: String,\n    pub remote_id: Option<String>,\n    pub is_synced: bool,\n    pub created_at: i64,\n    pub synced_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncQueueItemRow {\n    pub id: i64,\n    pub action_type: String,\n    pub payload: String,\n    pub status: String,\n    pub retry_count: i32,\n    pub max_retries: i32,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub synced_at: Option<i64>,\n    pub error_message: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct CacheMetadataRow {\n    pub id: i64,\n    pub cache_key: String,\n    pub cache_type: String,\n    pub last_synced_at: Option<i64>,\n    pub last_accessed_at: Option<i64>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<i64>,\n    pub metadata: Option<String>,\n    pub doc_version: Option<i64>,\n    pub blob_hash: Option<String>,\n    pub payload_bytes: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OptimisticUpdateRow {\n    pub id: i64,\n    pub update_id: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub original_data: Option<String>,\n    pub updated_data: String,\n    pub is_confirmed: bool,\n    pub created_at: i64,\n    pub confirmed_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncStatusRow {\n    pub id: i64,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: i64,\n    pub last_remote_sync: Option<i64>,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","sqlite_store.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheMetadataUpdate, CacheStatusSnapshot, CacheTypeStatus,\n    OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord, SyncQueueItem,\n    SyncQueueItemDraft, SyncResult, SyncStatusRecord, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::CacheType;\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::infrastructure::offline::mappers::{\n    cache_metadata_from_row, offline_action_from_row, optimistic_update_from_row,\n    optimistic_update_id_from_string, payload_from_optional_json_str, payload_to_string,\n    sync_queue_id_from_i64, sync_queue_item_from_row, sync_status_from_row,\n};\nuse crate::infrastructure::offline::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\nuse crate::shared::{ValidationFailureKind, error::AppError};\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse serde_json::Value;\nuse sqlx::{Pool, QueryBuilder, Row, Sqlite};\nuse std::collections::HashMap;\nuse std::convert::TryInto;\nuse uuid::Uuid;\n\npub struct SqliteOfflinePersistence {\n    pool: Pool<Sqlite>,\n}\n\nimpl SqliteOfflinePersistence {\n    pub fn new(pool: Pool<Sqlite>) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &Pool<Sqlite> {\n        &self.pool\n    }\n\n    pub async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\n        let payload = payload_to_string(&action.payload)?;\n\n        let existing = sqlx::query(\n            r#\"\n            SELECT id FROM sync_queue\n            WHERE action_type = ?1 AND payload = ?2\n              AND status IN ('pending', 'failed')\n            LIMIT 1\n            \"#,\n        )\n        .bind(action.action_type.as_str())\n        .bind(&payload)\n        .fetch_optional(self.pool())\n        .await?;\n\n        if existing.is_some() {\n            return Ok(false);\n        }\n\n        self.enqueue_sync(SyncQueueItemDraft::new(\n            action.action_type.clone(),\n            action.payload.clone(),\n            None,\n        ))\n        .await?;\n\n        Ok(true)\n    }\n\n    pub async fn list_pending_sync_queue(&self) -> Result<Vec<SyncQueueItem>, AppError> {\n        let rows = sqlx::query_as::<_, SyncQueueItemRow>(\n            r#\"\n            SELECT * FROM sync_queue\n            WHERE status IN ('pending', 'failed')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_queue_item_from_row).collect()\n    }\n\n    pub async fn list_recent_sync_queue(&self, limit: u32) -> Result<Vec<SyncQueueItem>, AppError> {\n        let rows = sqlx::query_as::<_, SyncQueueItemRow>(\n            r#\"\n            SELECT * FROM sync_queue\n            ORDER BY updated_at DESC\n            LIMIT ?1\n            \"#,\n        )\n        .bind(i64::from(limit))\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_queue_item_from_row).collect()\n    }\n\n    pub async fn list_stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError> {\n        let now = Utc::now().timestamp();\n        let rows = sqlx::query_as::<_, CacheMetadataRow>(\n            r#\"\n            SELECT * FROM cache_metadata\n            WHERE is_stale = 1\n               OR (expiry_time IS NOT NULL AND expiry_time < ?1)\n            ORDER BY COALESCE(last_synced_at, 0) ASC\n            \"#,\n        )\n        .bind(now)\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(cache_metadata_from_row).collect()\n    }\n\n    pub async fn list_unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError> {\n        let rows = sqlx::query_as::<_, OptimisticUpdateRow>(\n            r#\"\n            SELECT * FROM optimistic_updates\n            WHERE is_confirmed = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(optimistic_update_from_row).collect()\n    }\n\n    pub async fn list_sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError> {\n        let rows = sqlx::query_as::<_, SyncStatusRow>(\n            r#\"\n            SELECT\n                rowid as id,\n                entity_type,\n                entity_id,\n                local_version,\n                NULL AS remote_version,\n                last_local_update,\n                NULL AS last_remote_sync,\n                sync_status,\n                conflict_data\n            FROM sync_status\n            WHERE sync_status IN ('conflict', 'failed', 'pending')\n               OR sync_status LIKE 'invalid:%'\n            ORDER BY last_local_update DESC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_status_from_row).collect()\n    }\n\n    async fn get_offline_action_by_id(&self, id: i64) -> Result<OfflineActionRecord, AppError> {\n        let action = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE id = ?1\n            \"#,\n        )\n        .bind(id)\n        .fetch_one(self.pool())\n        .await?;\n\n        offline_action_from_row(action)\n    }\n}\n\n#[async_trait]\nimpl OfflinePersistence for SqliteOfflinePersistence {\n    async fn save_action(\n        &self,\n        draft: crate::domain::entities::offline::OfflineActionDraft,\n    ) -> Result<crate::domain::entities::offline::SavedOfflineAction, AppError> {\n        use crate::domain::entities::offline::{OfflineActionDraft, SavedOfflineAction};\n\n        let OfflineActionDraft {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        } = draft;\n\n        let local_id = Uuid::new_v4().to_string();\n        let action_data = payload_to_string(&payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO offline_actions (\n                user_pubkey, action_type, target_id, action_data,\n                local_id, is_synced, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .bind(action_type.as_str())\n        .bind(target_id.as_ref().map(|value| value.to_string()))\n        .bind(&action_data)\n        .bind(&local_id)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        let id = result.last_insert_rowid();\n        let action = self.get_offline_action_by_id(id).await?;\n\n        Ok(SavedOfflineAction::new(action.action_id.clone(), action))\n    }\n\n    async fn list_actions(\n        &self,\n        filter: crate::domain::entities::offline::OfflineActionFilter,\n    ) -> Result<Vec<crate::domain::entities::offline::OfflineActionRecord>, AppError> {\n        let mut builder: QueryBuilder<Sqlite> =\n            QueryBuilder::new(\"SELECT * FROM offline_actions WHERE 1=1\");\n\n        if let Some(user_pubkey) = filter.user_pubkey.as_ref() {\n            builder.push(\" AND user_pubkey = \");\n            builder.push_bind(user_pubkey.as_hex());\n        }\n\n        if let Some(is_synced) = filter.include_synced {\n            builder.push(\" AND is_synced = \");\n            builder.push_bind(if is_synced { 1 } else { 0 });\n        }\n\n        builder.push(\" ORDER BY created_at DESC\");\n\n        if let Some(limit) = filter.limit {\n            builder.push(\" LIMIT \");\n            builder.push_bind(limit as i64);\n        }\n\n        let query = builder.build_query_as::<OfflineActionRow>();\n        let actions = query.fetch_all(self.pool()).await?;\n\n        actions.into_iter().map(offline_action_from_row).collect()\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        let unsynced_actions = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_all(self.pool())\n        .await?;\n\n        let domain_actions = unsynced_actions\n            .into_iter()\n            .map(offline_action_from_row)\n            .collect::<Result<Vec<_>, AppError>>()?;\n\n        let mut synced_count: u32 = 0;\n\n        for action in domain_actions.iter() {\n            let enqueue_result = self\n                .enqueue_sync(SyncQueueItemDraft::new(\n                    action.action_type.clone(),\n                    action.payload.clone(),\n                    None,\n                ))\n                .await;\n\n            if enqueue_result.is_ok() {\n                let Some(record_id) = action.record_id else {\n                    continue;\n                };\n                let synced_at = Utc::now().timestamp();\n                sqlx::query(\n                    r#\"\n                    UPDATE offline_actions\n                    SET is_synced = 1, synced_at = ?1\n                    WHERE id = ?2\n                    \"#,\n                )\n                .bind(synced_at)\n                .bind(record_id)\n                .execute(self.pool())\n                .await?;\n                synced_count = synced_count.saturating_add(1);\n            }\n        }\n\n        let pending_result = sqlx::query(\n            r#\"\n            SELECT COUNT(*) as count\n            FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_one(self.pool())\n        .await?;\n\n        let pending_count: u32 = pending_result\n            .try_get::<i32, _>(\"count\")\n            .unwrap_or(0)\n            .try_into()\n            .unwrap_or(0);\n\n        Ok(SyncResult::new(synced_count, 0, pending_count))\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        let rows = sqlx::query_as::<_, CacheMetadataRow>(\n            r#\"\n            SELECT * FROM cache_metadata\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        let records = rows\n            .into_iter()\n            .map(cache_metadata_from_row)\n            .collect::<Result<Vec<_>, AppError>>()?;\n\n        let total_items = records.len() as u64;\n        let stale_items = records.iter().filter(|record| record.is_stale).count() as u64;\n\n        #[derive(Clone, Default)]\n        struct DocFieldSnapshot {\n            doc_version: Option<i64>,\n            blob_hash: Option<String>,\n            payload_bytes: Option<i64>,\n        }\n\n        #[derive(Default)]\n        struct CacheTypeGroup {\n            item_count: u64,\n            is_stale: bool,\n            last_synced_at: Option<DateTime<Utc>>,\n            latest_metadata: Option<(DateTime<Utc>, Value)>,\n            latest_doc_fields: Option<(DateTime<Utc>, DocFieldSnapshot)>,\n        }\n\n        let mut groups: HashMap<String, CacheTypeGroup> = HashMap::new();\n\n        for record in records {\n            let cache_type_key = record.cache_type.to_string();\n            let entry = groups.entry(cache_type_key).or_default();\n            entry.item_count = entry.item_count.saturating_add(1);\n            if record.is_stale {\n                entry.is_stale = true;\n            }\n            if let Some(last_synced_at) = record.last_synced_at {\n                let should_replace = entry\n                    .last_synced_at\n                    .map(|current| last_synced_at > current)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.last_synced_at = Some(last_synced_at);\n                }\n            }\n            if let Some(metadata) = record.metadata.clone() {\n                let timestamp = record\n                    .last_accessed_at\n                    .or(record.last_synced_at)\n                    .unwrap_or_else(Utc::now);\n                let should_replace = entry\n                    .latest_metadata\n                    .as_ref()\n                    .map(|(current_ts, _)| timestamp >= *current_ts)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.latest_metadata = Some((timestamp, metadata));\n                }\n            }\n            if record.doc_version.is_some()\n                || record.blob_hash.is_some()\n                || record.payload_bytes.is_some()\n            {\n                let timestamp = record\n                    .last_accessed_at\n                    .or(record.last_synced_at)\n                    .unwrap_or_else(Utc::now);\n                let should_replace = entry\n                    .latest_doc_fields\n                    .as_ref()\n                    .map(|(current_ts, _)| timestamp >= *current_ts)\n                    .unwrap_or(true);\n                if should_replace {\n                    entry.latest_doc_fields = Some((\n                        timestamp,\n                        DocFieldSnapshot {\n                            doc_version: record.doc_version,\n                            blob_hash: record.blob_hash.clone(),\n                            payload_bytes: record.payload_bytes,\n                        },\n                    ));\n                }\n            }\n        }\n\n        let mut cache_types = Vec::with_capacity(groups.len());\n        for (cache_type_name, summary) in groups {\n            let cache_type = CacheType::new(cache_type_name)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n            let metadata = summary\n                .latest_metadata\n                .as_ref()\n                .map(|(_, value)| value.clone());\n            let doc_version = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.doc_version);\n            let blob_hash = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.blob_hash.clone());\n            let payload_bytes = summary\n                .latest_doc_fields\n                .as_ref()\n                .and_then(|(_, snapshot)| snapshot.payload_bytes);\n            cache_types.push(CacheTypeStatus {\n                cache_type,\n                item_count: summary.item_count,\n                last_synced_at: summary.last_synced_at,\n                is_stale: summary.is_stale,\n                metadata,\n                doc_version,\n                blob_hash,\n                payload_bytes,\n            });\n        }\n\n        cache_types.sort_by(|a, b| a.cache_type.as_str().cmp(b.cache_type.as_str()));\n\n        Ok(CacheStatusSnapshot::new(\n            total_items,\n            stale_items,\n            cache_types,\n        ))\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        let payload_json = payload_to_string(&draft.payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO sync_queue (action_type, payload, status, created_at, updated_at)\n            VALUES (?1, ?2, 'pending', ?3, ?3)\n            \"#,\n        )\n        .bind(draft.action_type.as_str())\n        .bind(&payload_json)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        sync_queue_id_from_i64(result.last_insert_rowid())\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        let now = Utc::now().timestamp();\n        let metadata = update\n            .metadata\n            .map(|value| serde_json::to_string(&value))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        let expiry_time = update.expiry.map(|expiry| {\n            let seconds = expiry.signed_duration_since(Utc::now()).num_seconds();\n            now + seconds.max(0)\n        });\n        let is_stale = update.is_stale.unwrap_or(false);\n\n        sqlx::query(\n            r#\"\n            INSERT INTO cache_metadata (\n                cache_key, cache_type, last_synced_at, last_accessed_at,\n                data_version, is_stale, expiry_time, metadata, doc_version, blob_hash, payload_bytes\n            ) VALUES (?1, ?2, ?3, ?3, 1, ?4, ?5, ?6, ?7, ?8, ?9)\n            ON CONFLICT(cache_key) DO UPDATE SET\n                cache_type = excluded.cache_type,\n                last_synced_at = excluded.last_synced_at,\n                last_accessed_at = excluded.last_accessed_at,\n                data_version = data_version + 1,\n                is_stale = excluded.is_stale,\n                expiry_time = excluded.expiry_time,\n                metadata = excluded.metadata,\n                doc_version = excluded.doc_version,\n                blob_hash = excluded.blob_hash,\n                payload_bytes = excluded.payload_bytes\n            \"#,\n        )\n        .bind(update.cache_key.as_str())\n        .bind(update.cache_type.as_str())\n        .bind(now)\n        .bind(if is_stale { 1 } else { 0 })\n        .bind(expiry_time)\n        .bind(metadata)\n        .bind(update.doc_version)\n        .bind(update.blob_hash.as_deref())\n        .bind(update.payload_bytes)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        let update_id = Uuid::new_v4().to_string();\n        let created_at = Utc::now().timestamp();\n        let original = draft\n            .original_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated = payload_to_string(&draft.updated_data)?;\n\n        sqlx::query(\n            r#\"\n            INSERT INTO optimistic_updates (\n                update_id, entity_type, entity_id, original_data,\n                updated_data, is_confirmed, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(&update_id)\n        .bind(draft.entity_type.as_str())\n        .bind(draft.entity_id.as_str())\n        .bind(&original)\n        .bind(&updated)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        optimistic_update_id_from_string(update_id)\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        let confirmed_at = Utc::now().timestamp();\n\n        sqlx::query(\n            r#\"\n            UPDATE optimistic_updates\n            SET is_confirmed = 1, confirmed_at = ?1\n            WHERE update_id = ?2\n            \"#,\n        )\n        .bind(confirmed_at)\n        .bind(update_id.as_str())\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        let update = sqlx::query_as::<_, (Option<String>,)>(\n            r#\"\n                SELECT original_data FROM optimistic_updates\n                WHERE update_id = ?1\n                \"#,\n        )\n        .bind(update_id.as_str())\n        .fetch_optional(self.pool())\n        .await?;\n\n        if let Some((original_data,)) = update {\n            sqlx::query(r#\"DELETE FROM optimistic_updates WHERE update_id = ?1\"#)\n                .bind(update_id.as_str())\n                .execute(self.pool())\n                .await?;\n\n            return payload_from_optional_json_str(original_data);\n        }\n\n        Ok(None)\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        let now = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            DELETE FROM cache_metadata\n            WHERE expiry_time IS NOT NULL AND expiry_time < ?1\n            \"#,\n        )\n        .bind(now)\n        .execute(self.pool())\n        .await?;\n\n        result\n            .rows_affected()\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed u32\".to_string()))\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        let conflict_data = update\n            .conflict_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated_at = update.updated_at.timestamp();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO sync_status (\n                entity_type, entity_id, local_version, last_local_update,\n                sync_status, conflict_data\n            ) VALUES (?1, ?2, 1, ?3, ?4, ?5)\n            ON CONFLICT(entity_type, entity_id) DO UPDATE SET\n                local_version = local_version + 1,\n                last_local_update = excluded.last_local_update,\n                sync_status = excluded.sync_status,\n                conflict_data = excluded.conflict_data\n            \"#,\n        )\n        .bind(update.entity_type.as_str())\n        .bind(update.entity_id.as_str())\n        .bind(updated_at)\n        .bind(update.sync_status.as_str().as_ref())\n        .bind(&conflict_data)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn enqueue_if_missing(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\n        SqliteOfflinePersistence::enqueue_if_missing(self, action).await\n    }\n\n    async fn recent_sync_queue_items(\n        &self,\n        limit: Option<u32>,\n    ) -> Result<Vec<SyncQueueItem>, AppError> {\n        let limit = limit.unwrap_or(25).clamp(1, 200);\n        SqliteOfflinePersistence::list_recent_sync_queue(self, limit).await\n    }\n\n    async fn pending_sync_items(&self) -> Result<Vec<SyncQueueItem>, AppError> {\n        SqliteOfflinePersistence::list_pending_sync_queue(self).await\n    }\n\n    async fn stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError> {\n        SqliteOfflinePersistence::list_stale_cache_entries(self).await\n    }\n\n    async fn unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError> {\n        SqliteOfflinePersistence::list_unconfirmed_updates(self).await\n    }\n\n    async fn sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError> {\n        SqliteOfflinePersistence::list_sync_conflicts(self).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::offline::{\n        CacheMetadataUpdate, OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft,\n        SyncStatusUpdate,\n    };\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{\n        CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n        SyncQueueStatus, SyncStatus,\n    };\n    use chrono::Utc;\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    const PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    async fn setup_persistence() -> SqliteOfflinePersistence {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .unwrap();\n\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\n\n        SqliteOfflinePersistence::new(pool)\n    }\n\n    fn sample_draft() -> OfflineActionDraft {\n        OfflineActionDraft::new(\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\n            OfflineActionType::new(\"create_post\".to_string()).unwrap(),\n            Some(EntityId::new(\"post_123\".to_string()).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"content\":\"test\"}\"#).unwrap(),\n        )\n    }\n\n    #[tokio::test]\n    async fn test_save_offline_action() {\n        let persistence = setup_persistence().await;\n        let saved = persistence.save_action(sample_draft()).await.unwrap();\n\n        assert_eq!(saved.action.user_pubkey.as_hex(), PUBKEY);\n        assert_eq!(saved.action.sync_status, SyncStatus::Pending);\n        assert!(!saved.action.payload.as_json().is_null());\n    }\n\n    #[tokio::test]\n    async fn test_list_offline_actions() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let actions = persistence\n            .list_actions(OfflineActionFilter::new(\n                Some(PublicKey::from_hex_str(PUBKEY).unwrap()),\n                Some(false),\n                None,\n            ))\n            .await\n            .unwrap();\n\n        assert_eq!(actions.len(), 1);\n        assert_eq!(actions[0].user_pubkey.as_hex(), PUBKEY);\n    }\n\n    #[tokio::test]\n    async fn test_enqueue_and_pending_queue() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let unsynced = persistence\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\n            .await\n            .unwrap();\n        let action = unsynced.first().unwrap();\n\n        let inserted = persistence.enqueue_if_missing(action).await.unwrap();\n        assert!(inserted);\n\n        // 重複登録は false を返す\n        let duplicated = persistence.enqueue_if_missing(action).await.unwrap();\n        assert!(!duplicated);\n\n        let pending = persistence.list_pending_sync_queue().await.unwrap();\n        assert_eq!(pending.len(), 1);\n        assert_eq!(pending[0].status, SyncQueueStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn test_cache_metadata_and_status() {\n        let persistence = setup_persistence().await;\n        persistence\n            .upsert_cache_metadata(CacheMetadataUpdate {\n                cache_key: CacheKey::new(\"posts\".to_string()).unwrap(),\n                cache_type: CacheType::new(\"topic\".to_string()).unwrap(),\n                metadata: Some(serde_json::json!({\"last_id\": \"1\"})),\n                expiry: Some(Utc::now()),\n                is_stale: Some(true),\n                doc_version: None,\n                blob_hash: None,\n                payload_bytes: None,\n            })\n            .await\n            .unwrap();\n\n        let status = persistence.cache_status().await.unwrap();\n        assert_eq!(status.total_items, 1);\n        assert_eq!(status.stale_items, 1);\n        assert_eq!(status.cache_types.len(), 1);\n        assert!(status.cache_types[0].is_stale);\n    }\n\n    #[tokio::test]\n    async fn test_optimistic_update_lifecycle() {\n        let persistence = setup_persistence().await;\n        let draft = OptimisticUpdateDraft::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_1\".to_string()).unwrap(),\n            Some(OfflinePayload::from_json_str(r#\"{\"likes\":10}\"#).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"likes\":11}\"#).unwrap(),\n        );\n\n        let update_id = persistence.save_optimistic_update(draft).await.unwrap();\n        persistence\n            .confirm_optimistic_update(update_id.clone())\n            .await\n            .unwrap();\n\n        let rollback_id = persistence\n            .save_optimistic_update(OptimisticUpdateDraft::new(\n                EntityType::new(\"post\".to_string()).unwrap(),\n                EntityId::new(\"post_2\".to_string()).unwrap(),\n                Some(OfflinePayload::from_json_str(r#\"{\"likes\":1}\"#).unwrap()),\n                OfflinePayload::from_json_str(r#\"{\"likes\":2}\"#).unwrap(),\n            ))\n            .await\n            .unwrap();\n\n        let rolled_back = persistence\n            .rollback_optimistic_update(rollback_id)\n            .await\n            .unwrap();\n        assert!(rolled_back.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_sync_status_update() {\n        let persistence = setup_persistence().await;\n        let update = SyncStatusUpdate::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_3\".to_string()).unwrap(),\n            SyncStatus::Pending,\n            None,\n            Utc::now(),\n        );\n        persistence.update_sync_status(update).await.unwrap();\n\n        let conflicts = persistence.list_sync_conflicts().await.unwrap();\n        assert_eq!(conflicts.len(), 1);\n        assert_eq!(conflicts[0].entity_id.to_string(), \"post_3\");\n    }\n}\n","traces":[{"line":32,"address":[24719696],"length":1,"stats":{"Line":5}},{"line":36,"address":[24638192],"length":1,"stats":{"Line":3}},{"line":40,"address":[24638240,24638467,24639325,24638221,24638275,24638409,24639247,24638208],"length":1,"stats":{"Line":9}},{"line":41,"address":[25784971,25785693,25785095,25784822],"length":1,"stats":{"Line":5}},{"line":51,"address":[24638783,24639256,24638740,24638900],"length":1,"stats":{"Line":5}},{"line":52,"address":[24713500,24713571],"length":1,"stats":{"Line":5}},{"line":53,"address":[24639225,24638944,24638987,24639090],"length":1,"stats":{"Line":5}},{"line":54,"address":[24752061,24751802,24751901,24752221,24751140,24752421],"length":1,"stats":{"Line":10}},{"line":56,"address":[24752394,24752555],"length":1,"stats":{"Line":5}},{"line":57,"address":[24752598],"length":1,"stats":{"Line":1}},{"line":60,"address":[24722001,24722210,24721377,24721628,24721698,24722153,24721903,24721552],"length":1,"stats":{"Line":19}},{"line":61,"address":[24852943,24853019],"length":1,"stats":{"Line":5}},{"line":62,"address":[25786347],"length":1,"stats":{"Line":3}},{"line":63,"address":[24721544],"length":1,"stats":{"Line":2}},{"line":65,"address":[24713046,24714783,24715023,24715177,24714874,24714739],"length":1,"stats":{"Line":12}},{"line":67,"address":[24753253],"length":1,"stats":{"Line":4}},{"line":70,"address":[24853784,24854287,24853827,24853792,24853776,24853945,24854170],"length":1,"stats":{"Line":10}},{"line":78,"address":[24654673,24654721,24654815,24654953],"length":1,"stats":{"Line":5}},{"line":79,"address":[24757540,24757809,24758055,24758282,24757896,24757703],"length":1,"stats":{"Line":10}},{"line":81,"address":[24641581,24641762],"length":1,"stats":{"Line":4}},{"line":84,"address":[24655664,24655731,24656341,24656372,24655876,24656214,24655676,24655696],"length":1,"stats":{"Line":4}},{"line":92,"address":[24716748,24717182,24716890,24716795],"length":1,"stats":{"Line":2}},{"line":93,"address":[18896715,18896856,18896618],"length":1,"stats":{"Line":2}},{"line":94,"address":[24856105,24855597,24855215,24855716,24855491,24855875],"length":1,"stats":{"Line":4}},{"line":96,"address":[18897276,18897460],"length":1,"stats":{"Line":2}},{"line":99,"address":[18897754,18898221,18897794,18897600,18897608,18897651,18897616],"length":1,"stats":{"Line":10}},{"line":100,"address":[24657194,24657294],"length":1,"stats":{"Line":5}},{"line":109,"address":[24718263],"length":1,"stats":{"Line":3}},{"line":110,"address":[18898199,18897903,18897983,18898077],"length":1,"stats":{"Line":5}},{"line":111,"address":[24857190,24856942,24856853,24857429,24857030,24856549],"length":1,"stats":{"Line":10}},{"line":113,"address":[24757000,24757187],"length":1,"stats":{"Line":5}},{"line":116,"address":[24658392,24658384,24658553,24658435,24658778,24658400,24658895],"length":1,"stats":{"Line":10}},{"line":124,"address":[18899279,18899417,18899137,18899185],"length":1,"stats":{"Line":5}},{"line":125,"address":[11047460],"length":1,"stats":{"Line":10}},{"line":127,"address":[24858754,24858573],"length":1,"stats":{"Line":5}},{"line":130,"address":[24859290,24859407,24858904,24859065,24858912,24858896,24858947],"length":1,"stats":{"Line":10}},{"line":149,"address":[24646175,24646033,24646081,24646313],"length":1,"stats":{"Line":5}},{"line":150,"address":[24652804,24653073,24652967,24653319,24653546,24653160],"length":1,"stats":{"Line":10}},{"line":152,"address":[24653666,24653485],"length":1,"stats":{"Line":5}},{"line":155,"address":[18901916,18901538,18901360,18901328,18901395,18901795,18901341],"length":1,"stats":{"Line":8}},{"line":162,"address":[24728866],"length":1,"stats":{"Line":2}},{"line":163,"address":[24661350,24661208,24661034,24661114],"length":1,"stats":{"Line":4}},{"line":164,"address":[11742823],"length":1,"stats":{"Line":8}},{"line":166,"address":[24766281],"length":1,"stats":{"Line":2}},{"line":172,"address":[24793551,24795760,24793723,24793895,24795883,24797705,24794026,24793664,24797517],"length":1,"stats":{"Line":9}},{"line":179,"address":[24719486],"length":1,"stats":{"Line":2}},{"line":180,"address":[24787329],"length":1,"stats":{"Line":2}},{"line":181,"address":[24831063],"length":1,"stats":{"Line":2}},{"line":182,"address":[24712813],"length":1,"stats":{"Line":2}},{"line":185,"address":[24719635,24719705],"length":1,"stats":{"Line":4}},{"line":186,"address":[25897203,25897300,25898526,25897424],"length":1,"stats":{"Line":4}},{"line":187,"address":[24825866,24826024],"length":1,"stats":{"Line":4}},{"line":197,"address":[25897779,25897624,25898504,25897667],"length":1,"stats":{"Line":4}},{"line":198,"address":[24831851,24831973,24832569],"length":1,"stats":{"Line":4}},{"line":199,"address":[24926912,24926773,24929376,24927321,24929360],"length":1,"stats":{"Line":8}},{"line":200,"address":[24713848],"length":1,"stats":{"Line":2}},{"line":201,"address":[24713925],"length":1,"stats":{"Line":2}},{"line":202,"address":[24713999],"length":1,"stats":{"Line":2}},{"line":203,"address":[24727978,24727876,24727650,24727767],"length":1,"stats":{"Line":4}},{"line":204,"address":[11814748],"length":1,"stats":{"Line":8}},{"line":206,"address":[24796269,24796390],"length":1,"stats":{"Line":4}},{"line":207,"address":[24827644,24828131,24827582,24827766,24825124],"length":1,"stats":{"Line":6}},{"line":209,"address":[24790145,24789996],"length":1,"stats":{"Line":6}},{"line":212,"address":[11919654],"length":1,"stats":{"Line":9}},{"line":216,"address":[24833473],"length":1,"stats":{"Line":2}},{"line":219,"address":[24835204,24835282],"length":1,"stats":{"Line":4}},{"line":220,"address":[24835340],"length":1,"stats":{"Line":2}},{"line":221,"address":[18971430],"length":1,"stats":{"Line":2}},{"line":224,"address":[24798712,24798607],"length":1,"stats":{"Line":4}},{"line":225,"address":[24717216],"length":1,"stats":{"Line":2}},{"line":226,"address":[18971594],"length":1,"stats":{"Line":2}},{"line":229,"address":[24724035],"length":1,"stats":{"Line":2}},{"line":231,"address":[18971664],"length":1,"stats":{"Line":2}},{"line":232,"address":[24835687],"length":1,"stats":{"Line":0}},{"line":233,"address":[24731229],"length":1,"stats":{"Line":0}},{"line":236,"address":[24835722],"length":1,"stats":{"Line":2}},{"line":237,"address":[24835791,24836581,24836014,24836148,24834890],"length":1,"stats":{"Line":8}},{"line":239,"address":[24836707,24836514],"length":1,"stats":{"Line":5}},{"line":242,"address":[11921652,11921623],"length":1,"stats":{"Line":4}},{"line":250,"address":[24733221,24733732,24733264,24733392],"length":1,"stats":{"Line":2}},{"line":251,"address":[24719763,24719931,24719648],"length":1,"stats":{"Line":2}},{"line":252,"address":[24733955,24734245,24733654,24733786,24732913,24733531],"length":1,"stats":{"Line":4}},{"line":254,"address":[24795488,24795000,24795210,24795725],"length":1,"stats":{"Line":2}},{"line":259,"address":[25904662],"length":1,"stats":{"Line":1}},{"line":261,"address":[24934873,24933878,24934069,24934941],"length":1,"stats":{"Line":4}},{"line":262,"address":[25906556,25905704,25906372,25906426],"length":1,"stats":{"Line":4}},{"line":263,"address":[24729279],"length":1,"stats":{"Line":1}},{"line":264,"address":[24935479,24934978],"length":1,"stats":{"Line":2}},{"line":265,"address":[24935487],"length":1,"stats":{"Line":1}},{"line":266,"address":[24804007],"length":1,"stats":{"Line":1}},{"line":268,"address":[24722610,24722877,24721178,24719174,24722663],"length":1,"stats":{"Line":5}},{"line":270,"address":[24936017],"length":1,"stats":{"Line":1}},{"line":271,"address":[24841273],"length":1,"stats":{"Line":1}},{"line":274,"address":[24839672,24839717],"length":1,"stats":{"Line":2}},{"line":283,"address":[24835948],"length":1,"stats":{"Line":1}},{"line":284,"address":[24804881,24804772,24804954,24804665],"length":1,"stats":{"Line":2}},{"line":285,"address":[24793787,24795807,24798021,24796253,24797961,24796010],"length":1,"stats":{"Line":5}},{"line":286,"address":[24838268,24838393],"length":1,"stats":{"Line":2}},{"line":297,"address":[24834795,24835054,24834636,24834679],"length":1,"stats":{"Line":2}},{"line":298,"address":[24735976,24736078,24735867],"length":1,"stats":{"Line":2}},{"line":299,"address":[19578228],"length":1,"stats":{"Line":4}},{"line":301,"address":[18978191,18978362],"length":1,"stats":{"Line":2}},{"line":307,"address":[24840782],"length":1,"stats":{"Line":1}},{"line":310,"address":[24844285,24841461,24841279,24841183,24841232,24841585,24842040],"length":1,"stats":{"Line":10}},{"line":316,"address":[24843666,24843435,24843535,24843384],"length":1,"stats":{"Line":4}},{"line":317,"address":[11296996],"length":1,"stats":{"Line":9}},{"line":319,"address":[24725811,24726015,24731155,24726268],"length":1,"stats":{"Line":6}},{"line":324,"address":[24844481,24844642],"length":1,"stats":{"Line":6}},{"line":325,"address":[24744960,24740122,24744970],"length":1,"stats":{"Line":9}},{"line":343,"address":[18980838],"length":1,"stats":{"Line":3}},{"line":345,"address":[24726588,24726701,24726909,24726836],"length":1,"stats":{"Line":12}},{"line":346,"address":[24740671],"length":1,"stats":{"Line":3}},{"line":347,"address":[24845870],"length":1,"stats":{"Line":3}},{"line":348,"address":[24845942],"length":1,"stats":{"Line":3}},{"line":349,"address":[24736170,24736121],"length":1,"stats":{"Line":6}},{"line":350,"address":[18983683],"length":1,"stats":{"Line":3}},{"line":352,"address":[24942465,24942419],"length":1,"stats":{"Line":6}},{"line":353,"address":[24736297,24736207],"length":1,"stats":{"Line":6}},{"line":355,"address":[24843936,24843941],"length":1,"stats":{"Line":2}},{"line":357,"address":[24736336,24736405],"length":1,"stats":{"Line":6}},{"line":358,"address":[24842267],"length":1,"stats":{"Line":3}},{"line":361,"address":[18983786,18983930,18984574],"length":1,"stats":{"Line":9}},{"line":362,"address":[18984157,18984059,18983999],"length":1,"stats":{"Line":9}},{"line":364,"address":[24811245],"length":1,"stats":{"Line":3}},{"line":366,"address":[25913311],"length":1,"stats":{"Line":2}},{"line":369,"address":[24944349,24944336],"length":1,"stats":{"Line":2}},{"line":371,"address":[24846623,24846897],"length":1,"stats":{"Line":6}},{"line":372,"address":[24811531],"length":1,"stats":{"Line":3}},{"line":375,"address":[24744086,24744132],"length":1,"stats":{"Line":6}},{"line":376,"address":[24737284,24737162],"length":1,"stats":{"Line":6}},{"line":377,"address":[24744266],"length":1,"stats":{"Line":3}},{"line":379,"address":[25913892,25913964,25913808],"length":1,"stats":{"Line":3}},{"line":381,"address":[24805023],"length":1,"stats":{"Line":1}},{"line":383,"address":[24843308],"length":1,"stats":{"Line":1}},{"line":386,"address":[24847952,24847965],"length":1,"stats":{"Line":0}},{"line":388,"address":[25914078,25914489],"length":1,"stats":{"Line":2}},{"line":389,"address":[24847488],"length":1,"stats":{"Line":1}},{"line":391,"address":[25914171],"length":1,"stats":{"Line":1}},{"line":392,"address":[24847340],"length":1,"stats":{"Line":1}},{"line":393,"address":[24843430],"length":1,"stats":{"Line":1}},{"line":394,"address":[24849056],"length":1,"stats":{"Line":1}},{"line":401,"address":[18981245,18981315],"length":1,"stats":{"Line":4}},{"line":402,"address":[24808783,24808689,24808565,24808828],"length":1,"stats":{"Line":8}},{"line":403,"address":[18981674,18981989,18982076,18982201,18982376,18982122],"length":1,"stats":{"Line":10}},{"line":404,"address":[24940722,24940765,24941096,24940882,24942214],"length":1,"stats":{"Line":4}},{"line":405,"address":[24844806,24844634],"length":1,"stats":{"Line":4}},{"line":408,"address":[24745137,24745120,24741945],"length":1,"stats":{"Line":6}},{"line":409,"address":[24941338,24941265],"length":1,"stats":{"Line":4}},{"line":412,"address":[24848048,24848053],"length":1,"stats":{"Line":2}},{"line":413,"address":[25911904,25911844],"length":1,"stats":{"Line":4}},{"line":416,"address":[24735208,24738224,24738241],"length":1,"stats":{"Line":4}},{"line":417,"address":[24803091,24803024],"length":1,"stats":{"Line":4}},{"line":420,"address":[24944560,24944565],"length":1,"stats":{"Line":2}},{"line":421,"address":[18983026],"length":1,"stats":{"Line":2}},{"line":422,"address":[24845196],"length":1,"stats":{"Line":2}},{"line":423,"address":[24845236],"length":1,"stats":{"Line":2}},{"line":424,"address":[24742364],"length":1,"stats":{"Line":2}},{"line":425,"address":[18982938],"length":1,"stats":{"Line":2}},{"line":426,"address":[24810162],"length":1,"stats":{"Line":2}},{"line":428,"address":[24941754],"length":1,"stats":{"Line":2}},{"line":433,"address":[24844040,24848160,24848197],"length":1,"stats":{"Line":4}},{"line":435,"address":[24844158],"length":1,"stats":{"Line":2}},{"line":438,"address":[24802070],"length":1,"stats":{"Line":2}},{"line":442,"address":[24733078,24733660,24731885,24731647,24732163,24733045,24733754,24731992,24731763,24731728],"length":1,"stats":{"Line":11}},{"line":443,"address":[24739133,24738992,24739860,24738919],"length":1,"stats":{"Line":5}},{"line":444,"address":[24807074,24806919],"length":1,"stats":{"Line":5}},{"line":452,"address":[24814113,24814226,24814574,24814070],"length":1,"stats":{"Line":5}},{"line":453,"address":[24849354],"length":1,"stats":{"Line":2}},{"line":454,"address":[24851113],"length":1,"stats":{"Line":3}},{"line":455,"address":[24849567,24849393,24849473,24849663],"length":1,"stats":{"Line":5}},{"line":456,"address":[24733485,24733296,24733133,24732935,24731912,24732992],"length":1,"stats":{"Line":11}},{"line":458,"address":[24846166,24846286],"length":1,"stats":{"Line":7}},{"line":461,"address":[24846879,24846640,24846995,24846687,24849002,24849104,24849681,24849567,24849948,24846559,24847178,24850213],"length":1,"stats":{"Line":11}},{"line":462,"address":[24851095,24851165],"length":1,"stats":{"Line":5}},{"line":463,"address":[24736383,24735023,24734581,24734703],"length":1,"stats":{"Line":5}},{"line":465,"address":[24819152,24819168],"length":1,"stats":{"Line":5}},{"line":467,"address":[24948047,24950834,24950816],"length":1,"stats":{"Line":0}},{"line":468,"address":[24741676,24741902,24744688],"length":1,"stats":{"Line":6}},{"line":469,"address":[24819438],"length":1,"stats":{"Line":2}},{"line":470,"address":[24854633,24854687],"length":1,"stats":{"Line":2}},{"line":472,"address":[24853438],"length":1,"stats":{"Line":2}},{"line":493,"address":[24748985,24749147,24750121,24749028],"length":1,"stats":{"Line":4}},{"line":494,"address":[24750089,24749163,24749285],"length":1,"stats":{"Line":4}},{"line":495,"address":[24852173],"length":1,"stats":{"Line":2}},{"line":496,"address":[24948686],"length":1,"stats":{"Line":2}},{"line":498,"address":[24810307],"length":1,"stats":{"Line":3}},{"line":499,"address":[24854134,24854085],"length":1,"stats":{"Line":6}},{"line":500,"address":[24949379,24948926,24948647,24949048],"length":1,"stats":{"Line":5}},{"line":501,"address":[24848777,24848688],"length":1,"stats":{"Line":5}},{"line":502,"address":[24810625,24810767,24810868,24810673],"length":1,"stats":{"Line":4}},{"line":503,"address":[24818412,24818146,24815725,24817981,24817703,24817763],"length":1,"stats":{"Line":11}},{"line":505,"address":[24853432],"length":1,"stats":{"Line":4}},{"line":508,"address":[24856515,24856776,24856480,24856367,24858689,24858573,24859294,24859587,24856669,24859855,24857004],"length":1,"stats":{"Line":4}},{"line":512,"address":[24951757,24951833],"length":1,"stats":{"Line":2}},{"line":513,"address":[24857092,24857156],"length":1,"stats":{"Line":2}},{"line":514,"address":[24745689,24747157,24745991],"length":1,"stats":{"Line":1}},{"line":516,"address":[24858320,24858336],"length":1,"stats":{"Line":2}},{"line":518,"address":[24739292,24739442,24739125,24740348],"length":1,"stats":{"Line":2}},{"line":528,"address":[25922697,25922662],"length":1,"stats":{"Line":2}},{"line":529,"address":[24858010,24857897,24858614,24857815],"length":1,"stats":{"Line":2}},{"line":530,"address":[25922945,25923360,25922830],"length":1,"stats":{"Line":2}},{"line":531,"address":[18994169],"length":1,"stats":{"Line":1}},{"line":532,"address":[24953011],"length":1,"stats":{"Line":1}},{"line":533,"address":[24740015],"length":1,"stats":{"Line":1}},{"line":534,"address":[25923329,25922988,25923192,25923103],"length":1,"stats":{"Line":2}},{"line":535,"address":[12041137],"length":1,"stats":{"Line":4}},{"line":537,"address":[24740745],"length":1,"stats":{"Line":1}},{"line":540,"address":[24858776,24859488,24859882,24859989,24858512,24858917,24858547,24858447,24858669,24859457],"length":1,"stats":{"Line":5}},{"line":544,"address":[18996562,18996626],"length":1,"stats":{"Line":2}},{"line":553,"address":[24955529],"length":1,"stats":{"Line":1}},{"line":554,"address":[24749367,24749610,24749249,24749174],"length":1,"stats":{"Line":2}},{"line":555,"address":[24817191,24817288,24817377],"length":1,"stats":{"Line":2}},{"line":556,"address":[11333341],"length":1,"stats":{"Line":4}},{"line":558,"address":[24855890],"length":1,"stats":{"Line":1}},{"line":561,"address":[11335085,11335107],"length":1,"stats":{"Line":5}},{"line":571,"address":[24856730,24857190,24856773,24856886],"length":1,"stats":{"Line":2}},{"line":572,"address":[24744304,24744198,24744448],"length":1,"stats":{"Line":2}},{"line":573,"address":[25927284,25927544,25927791,25926689,25927392,25927200],"length":1,"stats":{"Line":4}},{"line":575,"address":[18999344,18999218],"length":1,"stats":{"Line":2}},{"line":576,"address":[24745302,24746209,24746006,24745424,24745216,24745536,24745079,24745908,24746258],"length":1,"stats":{"Line":7}},{"line":577,"address":[24958691,24958409,24958296,24958253],"length":1,"stats":{"Line":2}},{"line":578,"address":[24745353,24745459,24745590],"length":1,"stats":{"Line":2}},{"line":579,"address":[24958869,24956883,24959028,24959233,24958539,24958635],"length":1,"stats":{"Line":4}},{"line":581,"address":[24759860,24760003],"length":1,"stats":{"Line":2}},{"line":584,"address":[24958182],"length":1,"stats":{"Line":0}},{"line":587,"address":[24865557,24864809,24864848,24865082,24864970,24864883,24866099],"length":1,"stats":{"Line":5}},{"line":588,"address":[24959971],"length":1,"stats":{"Line":1}},{"line":596,"address":[24821650],"length":1,"stats":{"Line":1}},{"line":597,"address":[24865354,24865448,24865274,24865535],"length":1,"stats":{"Line":2}},{"line":598,"address":[24761414,24761070,24761230,24760469,24760928,24760982],"length":1,"stats":{"Line":4}},{"line":600,"address":[19001934,19002045],"length":1,"stats":{"Line":2}},{"line":603,"address":[24960896,24960910],"length":1,"stats":{"Line":0}},{"line":606,"address":[11930174],"length":1,"stats":{"Line":8}},{"line":607,"address":[24861243,24861575,24862752,24861350],"length":1,"stats":{"Line":4}},{"line":609,"address":[24867776,24867792],"length":1,"stats":{"Line":2}},{"line":611,"address":[24748792,24748961],"length":1,"stats":{"Line":4}},{"line":626,"address":[24865796,24865683,24865640,24866666],"length":1,"stats":{"Line":4}},{"line":627,"address":[24862000,24862698,24861876],"length":1,"stats":{"Line":4}},{"line":628,"address":[24823966],"length":1,"stats":{"Line":2}},{"line":629,"address":[25932051,25932294,25932102,25932639],"length":1,"stats":{"Line":4}},{"line":630,"address":[19003969,19003890],"length":1,"stats":{"Line":4}},{"line":631,"address":[19003643,19004285,19004214,19004071,19003977,19003929],"length":1,"stats":{"Line":4}},{"line":632,"address":[19592273,19592326],"length":1,"stats":{"Line":10}},{"line":634,"address":[24963597],"length":1,"stats":{"Line":2}},{"line":637,"address":[24765311,24765785,24765524,24765088,24765123,24765031,24765288,24765205],"length":1,"stats":{"Line":12}},{"line":638,"address":[11898583],"length":1,"stats":{"Line":5}},{"line":641,"address":[24864781,24864832,24864867,24865032,24865353,24864949,24865613,24865055],"length":1,"stats":{"Line":5}},{"line":645,"address":[24869127],"length":1,"stats":{"Line":1}},{"line":646,"address":[11911335],"length":1,"stats":{"Line":2}},{"line":649,"address":[24869632,24869583,24869749,24870320,24869855,24869667,24870059,24869832],"length":1,"stats":{"Line":12}},{"line":650,"address":[24966393,24966208,24966523],"length":1,"stats":{"Line":6}},{"line":653,"address":[19008099,19008064,19008264,19008287,19008491,19008015,19008181,19008752],"length":1,"stats":{"Line":13}},{"line":654,"address":[19008393,19008208,19008523],"length":1,"stats":{"Line":5}},{"line":657,"address":[19008783,19009259,19008832,19008949,19009055,19008867,19009520,19009032],"length":1,"stats":{"Line":12}},{"line":658,"address":[25937373,25937184,25937486],"length":1,"stats":{"Line":6}},{"line":661,"address":[24769173,24769091,24769483,24769279,24769056,24769007,24769256,24769744],"length":1,"stats":{"Line":12}},{"line":662,"address":[11924535],"length":1,"stats":{"Line":6}}],"covered":251,"coverable":257},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","bootstrap.rs"],"content":"use crate::application::services::p2p_service::{P2PService, P2PStack};\r\nuse crate::domain::p2p::P2PEvent;\r\nuse crate::infrastructure::p2p::{bootstrap_config, metrics};\r\nuse crate::shared::config::AppConfig;\r\nuse anyhow::Context;\r\nuse base64::prelude::*;\r\nuse rand_core::{OsRng, TryRngCore};\r\nuse std::path::{Path, PathBuf};\r\nuse tauri::Manager;\r\nuse tokio::fs;\r\nuse tokio::sync::broadcast;\r\n\r\npub struct P2PBootstrapper {\r\n    app_data_dir: PathBuf,\r\n    config: AppConfig,\r\n}\r\n\r\nimpl P2PBootstrapper {\r\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\r\n        let app_data_dir = app_handle\r\n            .path()\r\n            .app_data_dir()\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to get app data dir: {}\", e))?;\r\n\r\n        tracing::info!(\"App data directory: {:?}\", app_data_dir);\r\n\r\n        if !app_data_dir.exists() {\r\n            tracing::info!(\"Creating app data directory...\");\r\n            fs::create_dir_all(&app_data_dir)\r\n                .await\r\n                .with_context(|| format!(\"Failed to create app data dir at {app_data_dir:?}\"))?;\r\n            tracing::info!(\"App data directory created successfully\");\r\n        } else {\r\n            tracing::info!(\"App data directory already exists\");\r\n        }\r\n\r\n        let mut config = AppConfig::from_env();\r\n        let selection = bootstrap_config::load_effective_bootstrap_nodes();\r\n        config.network.bootstrap_peers = selection.nodes.clone();\r\n        config.network.bootstrap_source = selection.source;\r\n        tracing::info!(\r\n            \"Bootstrap peers source={:?} count={}\",\r\n            selection.source,\r\n            selection.nodes.len()\r\n        );\r\n\r\n        if let Err(err) = config.validate() {\r\n            return Err(anyhow::anyhow!(\r\n                \"Invalid application configuration: {}\",\r\n                err\r\n            ));\r\n        }\r\n\r\n        Ok(Self {\r\n            app_data_dir,\r\n            config,\r\n        })\r\n    }\r\n\r\n    pub fn app_data_dir(&self) -> &Path {\r\n        &self.app_data_dir\r\n    }\r\n\r\n    pub fn config(&self) -> &AppConfig {\r\n        &self.config\r\n    }\r\n\r\n    fn node_key_path(&self) -> PathBuf {\r\n        self.app_data_dir.join(\"p2p_node_secret.key\")\r\n    }\r\n\r\n    pub async fn build_stack(\r\n        &self,\r\n        event_sender: broadcast::Sender<P2PEvent>,\r\n    ) -> anyhow::Result<P2PStack> {\r\n        metrics::reset_all();\r\n        let secret_key = self.ensure_iroh_secret_key().await?;\r\n        let builder = P2PService::builder(secret_key, self.config.network.clone())\r\n            .with_event_sender(event_sender);\r\n\r\n        builder\r\n            .build()\r\n            .await\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to build P2P stack: {}\", e))\r\n    }\r\n\r\n    async fn ensure_iroh_secret_key(&self) -> anyhow::Result<iroh::SecretKey> {\r\n        let path = self.node_key_path();\r\n        match fs::read_to_string(&path).await {\r\n            Ok(contents) => {\r\n                let trimmed = contents.trim();\r\n                if trimmed.is_empty() {\r\n                    tracing::warn!(\r\n                        \"Persisted iroh secret key at {:?} was empty; regenerating\",\r\n                        path\r\n                    );\r\n                    return self.generate_and_store_secret(&path).await;\r\n                }\r\n\r\n                let bytes = BASE64_STANDARD.decode(trimmed).map_err(|e| {\r\n                    anyhow::anyhow!(\"Failed to decode persisted iroh secret key: {}\", e)\r\n                })?;\r\n                let secret_bytes: [u8; 32] = bytes\r\n                    .try_into()\r\n                    .map_err(|_| anyhow::anyhow!(\"Invalid iroh secret key length\"))?;\r\n                tracing::info!(\"Loaded persisted iroh secret key from {:?}\", path);\r\n                Ok(iroh::SecretKey::from_bytes(&secret_bytes))\r\n            }\r\n            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {\r\n                self.generate_and_store_secret(&path).await\r\n            }\r\n            Err(err) => {\r\n                tracing::warn!(\r\n                    \"Failed to read persisted iroh secret key at {:?}: {}. Regenerating.\",\r\n                    path,\r\n                    err\r\n                );\r\n                self.generate_and_store_secret(&path).await\r\n            }\r\n        }\r\n    }\r\n\r\n    async fn generate_and_store_secret(&self, path: &Path) -> anyhow::Result<iroh::SecretKey> {\r\n        let mut secret_bytes = [0u8; 32];\r\n        OsRng\r\n            .try_fill_bytes(&mut secret_bytes)\r\n            .map_err(|e| anyhow::anyhow!(\"Failed to generate iroh secret key: {:?}\", e))?;\r\n        let encoded = BASE64_STANDARD.encode(secret_bytes);\r\n\r\n        if let Some(parent) = path.parent() {\r\n            fs::create_dir_all(parent).await?;\r\n        }\r\n\r\n        fs::write(path, encoded)\r\n            .await\r\n            .with_context(|| format!(\"Failed to write iroh secret key to {path:?}\"))?;\r\n\r\n        tracing::info!(\"Generated new iroh secret key at {:?}\", path);\r\n        Ok(iroh::SecretKey::from_bytes(&secret_bytes))\r\n    }\r\n\r\n    #[cfg(test)]\r\n    pub fn from_parts(app_data_dir: PathBuf, config: AppConfig) -> Self {\r\n        Self {\r\n            app_data_dir,\r\n            config,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use tempfile::TempDir;\r\n\r\n    fn test_bootstrapper(temp_dir: &TempDir) -> P2PBootstrapper {\r\n        P2PBootstrapper::from_parts(temp_dir.path().to_path_buf(), AppConfig::default())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn generates_secret_if_missing() {\r\n        let dir = TempDir::new().unwrap();\r\n        let bootstrapper = test_bootstrapper(&dir);\r\n        let secret = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n\r\n        let stored = tokio::fs::read_to_string(bootstrapper.node_key_path())\r\n            .await\r\n            .unwrap();\r\n        let stored_bytes = BASE64_STANDARD.decode(stored.trim()).unwrap();\r\n        let stored_secret =\r\n            iroh::SecretKey::from_bytes(&stored_bytes.try_into().expect(\"invalid length\"));\r\n\r\n        assert_eq!(secret.to_bytes(), stored_secret.to_bytes());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn reuses_existing_secret() {\r\n        let dir = TempDir::new().unwrap();\r\n        let bootstrapper = test_bootstrapper(&dir);\r\n        let first = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n        let second = bootstrapper.ensure_iroh_secret_key().await.unwrap();\r\n\r\n        assert_eq!(first.to_bytes(), second.to_bytes());\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[16598264,16598350,16603628,16598479,16607985,16598534,16598288,16598256],"length":1,"stats":{"Line":0}},{"line":20,"address":[16640508,16640637,16640865,16645657],"length":1,"stats":{"Line":0}},{"line":23,"address":[25806183,25796657,25806160],"length":1,"stats":{"Line":0}},{"line":25,"address":[16598773,16728953,16598898,16599415,16729087],"length":1,"stats":{"Line":0}},{"line":27,"address":[16531562,16532690],"length":1,"stats":{"Line":0}},{"line":28,"address":[16739071,16739005,16868063,16739584,16867929],"length":1,"stats":{"Line":0}},{"line":29,"address":[16540564,16536094,16536229,16535982,16534280,16533255],"length":1,"stats":{"Line":0}},{"line":30,"address":[16529222,16527469,16527522,16523917,16529068],"length":1,"stats":{"Line":0}},{"line":31,"address":[16650710,16650688,16646069,16645938],"length":1,"stats":{"Line":0}},{"line":32,"address":[24430329,24304377,24304457,24430463],"length":1,"stats":{"Line":0}},{"line":34,"address":[16602151,16602652,16730441,16600553,16730575],"length":1,"stats":{"Line":0}},{"line":37,"address":[24303007],"length":1,"stats":{"Line":0}},{"line":38,"address":[16605558],"length":1,"stats":{"Line":0}},{"line":39,"address":[16744189,16744114],"length":1,"stats":{"Line":0}},{"line":40,"address":[16612776],"length":1,"stats":{"Line":0}},{"line":41,"address":[16613881,16614208],"length":1,"stats":{"Line":0}},{"line":47,"address":[16607571,16606369],"length":1,"stats":{"Line":0}},{"line":48,"address":[16607731,16607638],"length":1,"stats":{"Line":0}},{"line":54,"address":[16651810],"length":1,"stats":{"Line":0}},{"line":55,"address":[16651690],"length":1,"stats":{"Line":0}},{"line":56,"address":[16614966],"length":1,"stats":{"Line":0}},{"line":60,"address":[16747248],"length":1,"stats":{"Line":0}},{"line":61,"address":[16747253],"length":1,"stats":{"Line":0}},{"line":64,"address":[16547952],"length":1,"stats":{"Line":0}},{"line":65,"address":[16650840],"length":1,"stats":{"Line":0}},{"line":68,"address":[25806544],"length":1,"stats":{"Line":1}},{"line":69,"address":[16650880],"length":1,"stats":{"Line":1}},{"line":72,"address":[16650928],"length":1,"stats":{"Line":0}},{"line":76,"address":[24309486],"length":1,"stats":{"Line":0}},{"line":77,"address":[25806880,25806953,25807025,25807478,25807115],"length":1,"stats":{"Line":0}},{"line":78,"address":[16541901,16542000,16542110,16542288],"length":1,"stats":{"Line":0}},{"line":79,"address":[16616828],"length":1,"stats":{"Line":0}},{"line":81,"address":[16648099,16648591,16648153,16648489],"length":1,"stats":{"Line":0}},{"line":83,"address":[16549236,16549457,16549182,16548326,16549593],"length":1,"stats":{"Line":0}},{"line":84,"address":[16648703,16648688],"length":1,"stats":{"Line":0}},{"line":87,"address":[16617728,16618054,16617760,16617948,16618277,16617822,16621305,16617736],"length":1,"stats":{"Line":4}},{"line":88,"address":[16543183],"length":1,"stats":{"Line":1}},{"line":89,"address":[16611050,16611173,16611381,16611261],"length":1,"stats":{"Line":3}},{"line":90,"address":[16655376],"length":1,"stats":{"Line":1}},{"line":91,"address":[16655400,16655536],"length":1,"stats":{"Line":2}},{"line":92,"address":[16551085],"length":1,"stats":{"Line":1}},{"line":93,"address":[16775129,16775263,16658645,16655682,16658117],"length":1,"stats":{"Line":0}},{"line":97,"address":[11548245],"length":1,"stats":{"Line":0}},{"line":100,"address":[16551488,16544492,16546578,16544152,16544244],"length":1,"stats":{"Line":2}},{"line":101,"address":[16626234],"length":1,"stats":{"Line":0}},{"line":103,"address":[16612370,16612217,16614343,16612550],"length":1,"stats":{"Line":2}},{"line":105,"address":[24319801,24312918,24319792],"length":1,"stats":{"Line":0}},{"line":106,"address":[16770175,16650698,16650618,16770041,16651207],"length":1,"stats":{"Line":3}},{"line":107,"address":[16751538,16752642],"length":1,"stats":{"Line":2}},{"line":109,"address":[25813876,25809394,25813771],"length":1,"stats":{"Line":3}},{"line":110,"address":[11541484],"length":1,"stats":{"Line":3}},{"line":112,"address":[16754686],"length":1,"stats":{"Line":0}},{"line":113,"address":[24432809,24316778,24316618,24317306,24432943],"length":1,"stats":{"Line":0}},{"line":118,"address":[16749593,16756563,16755346,16757454],"length":1,"stats":{"Line":0}},{"line":123,"address":[16657682,16657759,16657994,16657712,16657664,16657930,16659218,16658730],"length":1,"stats":{"Line":4}},{"line":124,"address":[25817317],"length":1,"stats":{"Line":1}},{"line":125,"address":[16626732,16627040,16627490,16626864],"length":1,"stats":{"Line":2}},{"line":126,"address":[16758263],"length":1,"stats":{"Line":1}},{"line":127,"address":[16555355,16552288,16555344],"length":1,"stats":{"Line":0}},{"line":128,"address":[16552372,16552219],"length":1,"stats":{"Line":2}},{"line":130,"address":[16553138,16552384,16552485],"length":1,"stats":{"Line":3}},{"line":131,"address":[16659063,16659193,16657960,16658482,16658583,16658762],"length":1,"stats":{"Line":3}},{"line":134,"address":[16628287,16628422,16628177,16627317,16629997,16627948],"length":1,"stats":{"Line":4}},{"line":135,"address":[16546681,16546523,16546458,16546401,16545277],"length":1,"stats":{"Line":4}},{"line":136,"address":[16659590,16661430,16659459,16661408],"length":1,"stats":{"Line":1}},{"line":138,"address":[24321914,24433305,24322423,24321834,24433439],"length":1,"stats":{"Line":6}},{"line":139,"address":[16660114,16661122],"length":1,"stats":{"Line":4}},{"line":143,"address":[25820880],"length":1,"stats":{"Line":1}}],"covered":27,"coverable":68},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","bootstrap_config.rs"],"content":"//! Bootstrap node configuration helpers\nuse crate::shared::config::BootstrapSource;\nuse crate::shared::error::AppError;\nuse dirs;\nuse iroh::{EndpointAddr, EndpointId};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\nuse std::path::{Path, PathBuf};\nuse std::str::FromStr;\nuse tracing::{debug, info, trace, warn};\n\nfn find_bootstrap_config_path() -> Option<PathBuf> {\n    let primary = PathBuf::from(\"bootstrap_nodes.json\");\n    if primary.exists() {\n        return Some(primary);\n    }\n    let alt = PathBuf::from(\"src-tauri\").join(\"bootstrap_nodes.json\");\n    if alt.exists() {\n        return Some(alt);\n    }\n    None\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfig {\n    pub development: EnvironmentConfig,\n    pub staging: EnvironmentConfig,\n    pub production: EnvironmentConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EnvironmentConfig {\n    pub description: String,\n    pub nodes: Vec<String>,\n}\n\n#[derive(Debug, Clone)]\npub struct BootstrapSelection {\n    pub source: BootstrapSource,\n    pub nodes: Vec<String>,\n}\n\n#[derive(Debug, Clone)]\npub struct CliBootstrapInfo {\n    pub nodes: Vec<String>,\n    pub updated_at_ms: Option<u64>,\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CliBootstrapCacheFile {\n    nodes: Vec<String>,\n    updated_at_ms: Option<u64>,\n}\n\nimpl BootstrapConfig {\n    /// Load configuration from a JSON file\n    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, AppError> {\n        let content = fs::read_to_string(path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to read bootstrap config: {e}\"))\n        })?;\n\n        let config: BootstrapConfig = serde_json::from_str(&content).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to parse bootstrap config: {e}\"))\n        })?;\n\n        Ok(config)\n    }\n\n    /// Default configuration used when no file is available\n    pub fn default_config() -> Self {\n        Self {\n            development: EnvironmentConfig {\n                description: \"Local development bootstrap nodes\".to_string(),\n                nodes: vec![\"localhost:11223\".to_string(), \"localhost:11224\".to_string()],\n            },\n            staging: EnvironmentConfig {\n                description: \"Staging environment bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n            production: EnvironmentConfig {\n                description: \"Production bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n        }\n    }\n\n    /// Get node list for the given environment key\n    pub fn get_nodes(&self, environment: &str) -> Vec<String> {\n        match environment {\n            \"development\" | \"dev\" => self.development.nodes.clone(),\n            \"staging\" | \"stage\" => self.staging.nodes.clone(),\n            \"production\" | \"prod\" => self.production.nodes.clone(),\n            _ => {\n                warn!(\"Unknown environment: {}, using development\", environment);\n                self.development.nodes.clone()\n            }\n        }\n    }\n\n    /// Get SocketAddr list for the environment\n    pub fn get_socket_addrs(&self, environment: &str) -> Vec<SocketAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut addrs = Vec::new();\n\n        for node in nodes {\n            match node.parse::<SocketAddr>() {\n                Ok(addr) => addrs.push(addr),\n                Err(e) => {\n                    debug!(\"Failed to parse address {}: {}\", node, e);\n                }\n            }\n        }\n\n        addrs\n    }\n\n    /// Convert entries in the form \"<node_id>@<host:port>\" into EndpointAddr\n    pub fn get_node_addrs_with_id(&self, environment: &str) -> Vec<EndpointAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut out = Vec::new();\n\n        for node in nodes {\n            if let Some((id_part, addr_part)) = node.split_once('@') {\n                match (\n                    EndpointId::from_str(id_part),\n                    addr_part.parse::<SocketAddr>(),\n                ) {\n                    (Ok(node_id), Ok(sock)) => {\n                        out.push(EndpointAddr::new(node_id).with_ip_addr(sock));\n                    }\n                    (id_res, addr_res) => {\n                        debug!(\n                            \"Invalid node entry '{}': id_ok={}, addr_ok={}\",\n                            node,\n                            id_res.is_ok(),\n                            addr_res.is_ok()\n                        );\n                    }\n                }\n            } else if node.parse::<SocketAddr>().is_ok() {\n                warn!(\n                    \"Bootstrap node '{}' lacks NodeId; expected '<node_id>@<host:port>'. Skipping.\",\n                    node\n                );\n            } else {\n                debug!(\"Unrecognized bootstrap node entry: {}\", node);\n            }\n        }\n\n        out\n    }\n}\n\nfn parse_bootstrap_list(value: &str) -> Vec<String> {\n    value\n        .split(',')\n        .map(|s| s.trim().to_string())\n        .filter(|s| !s.is_empty())\n        .collect()\n}\n\nfn sanitize_bootstrap_node(entry: &str) -> Option<String> {\n    let trimmed = entry.trim();\n    if trimmed.is_empty() {\n        return None;\n    }\n\n    let (node_id, addr_part) = match trimmed.split_once('@') {\n        Some((id, addr)) => (id.trim(), addr.trim()),\n        None => return Some(trimmed.to_string()),\n    };\n\n    let mut socket_addr = match addr_part.parse::<SocketAddr>() {\n        Ok(addr) => addr,\n        Err(err) => {\n            warn!(\"Invalid bootstrap node '{}': {}\", entry, err);\n            return None;\n        }\n    };\n\n    if socket_addr.ip().is_unspecified() {\n        let replacement = match socket_addr {\n            SocketAddr::V4(_) => IpAddr::V4(Ipv4Addr::LOCALHOST),\n            SocketAddr::V6(_) => IpAddr::V6(Ipv6Addr::LOCALHOST),\n        };\n        socket_addr.set_ip(replacement);\n        warn!(\n            original = %entry,\n            normalized = %format!(\"{node_id}@{socket_addr}\"),\n            \"Bootstrap node address was unspecified; replaced with loopback\"\n        );\n    }\n\n    Some(format!(\"{node_id}@{socket_addr}\"))\n}\n\nfn sanitize_bootstrap_nodes(nodes: &[String]) -> Vec<String> {\n    let mut normalized: Vec<String> = nodes\n        .iter()\n        .filter_map(|entry| sanitize_bootstrap_node(entry))\n        .collect();\n    normalized.sort();\n    normalized.dedup();\n    normalized\n}\n\n/// Read bootstrap nodes from environment variable if set\npub fn load_env_bootstrap_nodes() -> Option<Vec<String>> {\n    match std::env::var(\"KUKURI_BOOTSTRAP_PEERS\") {\n        Ok(raw) => {\n            let nodes = parse_bootstrap_list(&raw);\n            if nodes.is_empty() { None } else { Some(nodes) }\n        }\n        Err(_) => None,\n    }\n}\n\nfn format_node_addrs(node_addr: &EndpointAddr) -> Vec<String> {\n    let node_id = node_addr.id.to_string();\n    let direct: Vec<_> = node_addr.ip_addrs().cloned().collect();\n    if direct.is_empty() {\n        vec![node_id]\n    } else {\n        direct\n            .into_iter()\n            .map(|addr| format!(\"{node_id}@{addr}\"))\n            .collect()\n    }\n}\n\nfn load_bundle_bootstrap_strings() -> Vec<String> {\n    match load_bootstrap_node_addrs() {\n        Ok(node_addrs) => node_addrs\n            .iter()\n            .flat_map(format_node_addrs)\n            .collect::<Vec<_>>(),\n        Err(err) => {\n            warn!(\"Failed to load bundled bootstrap nodes: {}\", err);\n            Vec::new()\n        }\n    }\n}\n\n/// Decide effective bootstrap nodes. Priority: env > user config > bundled file (only when ENABLE_P2P_INTEGRATION=1)\npub fn load_effective_bootstrap_nodes() -> BootstrapSelection {\n    let integration_enabled = std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() == \"1\";\n\n    if let Some(nodes) = load_env_bootstrap_nodes() {\n        let nodes = sanitize_bootstrap_nodes(&nodes);\n        trace!(\"Using bootstrap peers from environment variable\");\n        return BootstrapSelection {\n            source: BootstrapSource::Env,\n            nodes,\n        };\n    }\n\n    let user_nodes = sanitize_bootstrap_nodes(&load_user_bootstrap_nodes());\n    if !user_nodes.is_empty() {\n        trace!(\"Using bootstrap peers from user configuration\");\n        return BootstrapSelection {\n            source: BootstrapSource::User,\n            nodes: user_nodes,\n        };\n    }\n\n    if integration_enabled {\n        let bundle_nodes = sanitize_bootstrap_nodes(&load_bundle_bootstrap_strings());\n        if !bundle_nodes.is_empty() {\n            trace!(\"Using bootstrap peers from bundled configuration\");\n            return BootstrapSelection {\n                source: BootstrapSource::Bundle,\n                nodes: bundle_nodes,\n            };\n        }\n    } else {\n        trace!(\"P2P integration disabled; skipping bundled bootstrap nodes\");\n    }\n\n    BootstrapSelection {\n        source: BootstrapSource::None,\n        nodes: Vec::new(),\n    }\n}\n\n/// Resolve current environment string\npub fn get_current_environment() -> String {\n    std::env::var(\"KUKURI_ENV\")\n        .or_else(|_| std::env::var(\"ENVIRONMENT\"))\n        .unwrap_or_else(|_| \"development\".to_string())\n}\n\n/// Load bootstrap nodes as SocketAddr\npub fn load_bootstrap_nodes() -> Result<Vec<SocketAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap nodes for environment: {}\", env);\n\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\"\n        && load_env_bootstrap_nodes().is_none()\n        && load_user_bootstrap_nodes().is_empty()\n    {\n        info!(\"P2P integration disabled; returning empty bootstrap node list\");\n        return Ok(Vec::new());\n    }\n\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_socket_addrs(&env);\n\n    if addrs.is_empty() {\n        warn!(\"No bootstrap nodes configured for environment: {}\", env);\n    } else {\n        info!(\"Loaded {} bootstrap nodes\", addrs.len());\n    }\n\n    Ok(addrs)\n}\n\n/// Load bootstrap nodes as EndpointAddr (requires node id)\npub fn load_bootstrap_node_addrs() -> Result<Vec<EndpointAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap NodeAddrs for environment: {}\", env);\n\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\"\n        && load_env_bootstrap_nodes().is_none()\n        && load_user_bootstrap_nodes().is_empty()\n    {\n        info!(\"P2P integration disabled; returning empty NodeAddr list\");\n        return Ok(Vec::new());\n    }\n\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_node_addrs_with_id(&env);\n    if addrs.is_empty() {\n        warn!(\n            \"No valid NodeId@Addr bootstrap entries for environment: {}\",\n            env\n        );\n    } else {\n        info!(\"Loaded {} NodeId@Addr bootstrap entries\", addrs.len());\n    }\n    Ok(addrs)\n}\n\n/// Validate bootstrap_nodes.json and log counts\npub fn validate_bootstrap_config() -> Result<(), AppError> {\n    let env = get_current_environment();\n    let config = if let Some(path) = find_bootstrap_config_path() {\n        BootstrapConfig::load_from_file(path)?\n    } else {\n        BootstrapConfig::default_config()\n    };\n\n    let nodes = config.get_nodes(&env);\n    let mut with_id = 0usize;\n    let mut socket_only = 0usize;\n    let mut invalid = 0usize;\n\n    for node in nodes {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            if EndpointId::from_str(id_part).is_ok() && addr_part.parse::<SocketAddr>().is_ok() {\n                with_id += 1;\n            } else {\n                invalid += 1;\n            }\n        } else if node.parse::<SocketAddr>().is_ok() {\n            socket_only += 1;\n        } else {\n            invalid += 1;\n        }\n    }\n\n    info!(\n        \"bootstrap_nodes.json validation (env={}): with_id={}, socket_only={}, invalid={}\",\n        env, with_id, socket_only, invalid\n    );\n\n    Ok(())\n}\n\n// =============== user-managed bootstrap config =================\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct UserBootstrapConfig {\n    nodes: Vec<String>,\n}\n\nfn user_config_path() -> PathBuf {\n    let base = dirs::data_dir().unwrap_or_else(|| PathBuf::from(\".\"));\n    let dir = base.join(\"kukuri\");\n    let _ = fs::create_dir_all(&dir);\n    dir.join(\"user_bootstrap_nodes.json\")\n}\n\n/// Persist user-provided bootstrap nodes (node_id@host:port)\npub fn save_user_bootstrap_nodes(nodes: &[String]) -> Result<(), AppError> {\n    let path = user_config_path();\n    let normalized = sanitize_bootstrap_nodes(nodes);\n    let cfg = UserBootstrapConfig { nodes: normalized };\n    let json = serde_json::to_string_pretty(&cfg).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to serialize user bootstrap: {e}\"))\n    })?;\n    fs::write(&path, json).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to write user bootstrap file: {e}\"))\n    })?;\n    info!(\n        \"Saved user bootstrap nodes to {:?} ({} entries)\",\n        path,\n        nodes.len()\n    );\n    Ok(())\n}\n\n/// Remove user bootstrap configuration\npub fn clear_user_bootstrap_nodes() -> Result<(), AppError> {\n    let path = user_config_path();\n    if path.exists() {\n        fs::remove_file(&path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to remove user bootstrap file: {e}\"))\n        })?;\n        info!(\"Removed user bootstrap config at {:?}\", path);\n    }\n    Ok(())\n}\n\n/// Load user bootstrap nodes (raw strings)\npub fn load_user_bootstrap_nodes() -> Vec<String> {\n    let path = user_config_path();\n    if !path.exists() {\n        return vec![];\n    }\n    match fs::read_to_string(&path) {\n        Ok(content) => match serde_json::from_str::<UserBootstrapConfig>(&content) {\n            Ok(cfg) => cfg.nodes,\n            Err(e) => {\n                warn!(\"Invalid user bootstrap json: {}\", e);\n                vec![]\n            }\n        },\n        Err(e) => {\n            debug!(\"Failed to read user bootstrap file: {}\", e);\n            vec![]\n        }\n    }\n}\n\n/// Load user bootstrap nodes as EndpointAddr\npub fn load_user_bootstrap_node_addrs() -> Vec<EndpointAddr> {\n    let mut out = Vec::new();\n    for node in load_user_bootstrap_nodes() {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            match (\n                EndpointId::from_str(id_part),\n                addr_part.parse::<SocketAddr>(),\n            ) {\n                (Ok(node_id), Ok(sock)) => out.push(EndpointAddr::new(node_id).with_ip_addr(sock)),\n                _ => debug!(\"Invalid user bootstrap entry: {}\", node),\n            }\n        } else {\n            debug!(\"Skipping SocketAddr-only user bootstrap entry: {}\", node);\n        }\n    }\n    out\n}\n\nfn cli_bootstrap_path() -> PathBuf {\n    if let Ok(custom) = std::env::var(\"KUKURI_CLI_BOOTSTRAP_PATH\") {\n        return PathBuf::from(custom);\n    }\n    dirs::data_dir()\n        .unwrap_or_else(|| PathBuf::from(\".\"))\n        .join(\"kukuri\")\n        .join(\"cli_bootstrap_nodes.json\")\n}\n\npub fn load_cli_bootstrap_nodes() -> Option<CliBootstrapInfo> {\n    let path = cli_bootstrap_path();\n    if !path.exists() {\n        return None;\n    }\n\n    let content = fs::read_to_string(&path).ok()?;\n    let cache: CliBootstrapCacheFile = serde_json::from_str(&content).ok()?;\n\n    let nodes = sanitize_bootstrap_nodes(\n        &cache\n            .nodes\n            .into_iter()\n            .map(|entry| entry.trim().to_string())\n            .collect::<Vec<_>>(),\n    );\n\n    if nodes.is_empty() {\n        return None;\n    }\n\n    Some(CliBootstrapInfo {\n        nodes,\n        updated_at_ms: cache.updated_at_ms,\n        path,\n    })\n}\n\npub fn apply_cli_bootstrap_nodes() -> Result<Vec<String>, AppError> {\n    let info = load_cli_bootstrap_nodes().ok_or_else(|| {\n        AppError::ConfigurationError(\n            \"CLI bootstrap list is not available. Run cn-cli to export nodes.\".to_string(),\n        )\n    })?;\n    let normalized = sanitize_bootstrap_nodes(&info.nodes);\n    save_user_bootstrap_nodes(&normalized)?;\n    Ok(normalized)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::{Mutex, MutexGuard, OnceLock};\n\n    static CLI_BOOTSTRAP_ENV_GUARD: OnceLock<Mutex<()>> = OnceLock::new();\n\n    fn lock_cli_bootstrap_env() -> MutexGuard<'static, ()> {\n        CLI_BOOTSTRAP_ENV_GUARD\n            .get_or_init(|| Mutex::new(()))\n            .lock()\n            .expect(\"cli bootstrap env guard poisoned\")\n    }\n\n    fn temp_cli_path(suffix: &str) -> PathBuf {\n        let path = std::env::temp_dir().join(format!(\n            \"kukuri_cli_bootstrap_test_{}_{}.json\",\n            std::process::id(),\n            suffix\n        ));\n        if path.exists() {\n            let _ = fs::remove_file(&path);\n        }\n        path\n    }\n\n    #[test]\n    fn sanitize_bootstrap_nodes_rewrites_unspecified_addresses() {\n        let nodes = vec![\n            \"node1@0.0.0.0:11223\".to_string(),\n            \"node2@[::]:11223\".to_string(),\n            \" node3@127.0.0.1:11223 \".to_string(),\n        ];\n\n        let normalized = sanitize_bootstrap_nodes(&nodes);\n\n        assert!(normalized.contains(&\"node1@127.0.0.1:11223\".to_string()));\n        assert!(normalized.contains(&\"node2@[::1]:11223\".to_string()));\n        assert!(normalized.contains(&\"node3@127.0.0.1:11223\".to_string()));\n        assert_eq!(normalized.len(), 3);\n    }\n\n    #[test]\n    fn load_cli_bootstrap_nodes_returns_data_when_file_exists() {\n        let _guard = lock_cli_bootstrap_env();\n        let path = temp_cli_path(\"load\");\n        unsafe {\n            std::env::set_var(\"KUKURI_CLI_BOOTSTRAP_PATH\", &path);\n        }\n        let payload = r#\"{\"nodes\":[\"node1@127.0.0.1:1234\",\"node1@127.0.0.1:1234\",\"node2@[::1]:5678\"],\"updated_at_ms\":12345}\"#;\n        fs::write(&path, payload).expect(\"write cli bootstrap cache\");\n\n        let info = load_cli_bootstrap_nodes().expect(\"cli bootstrap info\");\n        assert_eq!(info.nodes.len(), 2);\n        assert_eq!(info.updated_at_ms, Some(12345));\n        assert_eq!(info.path, path);\n\n        unsafe {\n            std::env::remove_var(\"KUKURI_CLI_BOOTSTRAP_PATH\");\n        }\n        let _ = fs::remove_file(&info.path);\n    }\n\n    #[test]\n    fn load_cli_bootstrap_nodes_returns_none_when_missing() {\n        let _guard = lock_cli_bootstrap_env();\n        let path = temp_cli_path(\"missing\");\n        unsafe {\n            std::env::set_var(\"KUKURI_CLI_BOOTSTRAP_PATH\", &path);\n        }\n        assert!(load_cli_bootstrap_nodes().is_none());\n        unsafe {\n            std::env::remove_var(\"KUKURI_CLI_BOOTSTRAP_PATH\");\n        }\n    }\n}\n","traces":[{"line":13,"address":[23854848,23855550,23855518],"length":1,"stats":{"Line":0}},{"line":14,"address":[23736577],"length":1,"stats":{"Line":0}},{"line":15,"address":[23818149,23818217],"length":1,"stats":{"Line":0}},{"line":16,"address":[23811346],"length":1,"stats":{"Line":0}},{"line":18,"address":[23743502,23743621],"length":1,"stats":{"Line":0}},{"line":19,"address":[23849715],"length":1,"stats":{"Line":0}},{"line":20,"address":[23849805],"length":1,"stats":{"Line":0}},{"line":22,"address":[23950146],"length":1,"stats":{"Line":0}},{"line":59,"address":[23751040,23751580],"length":1,"stats":{"Line":0}},{"line":60,"address":[24734727,24734139,24734496,24733969],"length":1,"stats":{"Line":0}},{"line":61,"address":[24734583,24734518],"length":1,"stats":{"Line":0}},{"line":64,"address":[17991729,17992647,17992072,17992416,17991849],"length":1,"stats":{"Line":0}},{"line":65,"address":[23744983,23744918],"length":1,"stats":{"Line":0}},{"line":68,"address":[23850388],"length":1,"stats":{"Line":0}},{"line":72,"address":[23855008,23855995],"length":1,"stats":{"Line":0}},{"line":74,"address":[17993102],"length":1,"stats":{"Line":0}},{"line":78,"address":[23855613],"length":1,"stats":{"Line":0}},{"line":82,"address":[23851881],"length":1,"stats":{"Line":0}},{"line":90,"address":[23746987,23746176],"length":1,"stats":{"Line":0}},{"line":92,"address":[23753192],"length":1,"stats":{"Line":0}},{"line":93,"address":[23814120],"length":1,"stats":{"Line":0}},{"line":94,"address":[24736252],"length":1,"stats":{"Line":0}},{"line":96,"address":[23894399,23740205,23739728,23740330,23894265],"length":1,"stats":{"Line":0}},{"line":97,"address":[23858596],"length":1,"stats":{"Line":0}},{"line":103,"address":[23859912,23857552],"length":1,"stats":{"Line":0}},{"line":104,"address":[23815551],"length":1,"stats":{"Line":0}},{"line":105,"address":[23822512],"length":1,"stats":{"Line":0}},{"line":107,"address":[24737780,24737915,24737672,24737969],"length":1,"stats":{"Line":0}},{"line":108,"address":[23755149,23755299],"length":1,"stats":{"Line":0}},{"line":109,"address":[23741724,23741584],"length":1,"stats":{"Line":0}},{"line":110,"address":[23748466],"length":1,"stats":{"Line":0}},{"line":111,"address":[23969353,23816288,23969487,23816347],"length":1,"stats":{"Line":0}},{"line":116,"address":[17995732],"length":1,"stats":{"Line":0}},{"line":120,"address":[23863407,23859968,23866547],"length":1,"stats":{"Line":0}},{"line":121,"address":[23750159],"length":1,"stats":{"Line":0}},{"line":122,"address":[17997720],"length":1,"stats":{"Line":0}},{"line":124,"address":[23743773,23743719,23743584,23745168,23743476],"length":1,"stats":{"Line":0}},{"line":125,"address":[23760484,23757573,23757723],"length":1,"stats":{"Line":0}},{"line":126,"address":[23744228],"length":1,"stats":{"Line":0}},{"line":127,"address":[24740700],"length":1,"stats":{"Line":0}},{"line":128,"address":[23744165],"length":1,"stats":{"Line":0}},{"line":130,"address":[23861129],"length":1,"stats":{"Line":0}},{"line":131,"address":[23826073,23826173],"length":1,"stats":{"Line":0}},{"line":133,"address":[23862658],"length":1,"stats":{"Line":0}},{"line":134,"address":[23861810,23863018,23862589,23863087,24011897,23861466,23861946,24012031,23862658,23861098],"length":1,"stats":{"Line":0}},{"line":142,"address":[23957195,23959886],"length":1,"stats":{"Line":0}},{"line":143,"address":[23977407,23829998,23977273,23828420],"length":1,"stats":{"Line":0}},{"line":148,"address":[23753722,23903033,23753656,23903167],"length":1,"stats":{"Line":0}},{"line":152,"address":[23750636],"length":1,"stats":{"Line":0}},{"line":156,"address":[23756736],"length":1,"stats":{"Line":0}},{"line":157,"address":[23831504],"length":1,"stats":{"Line":0}},{"line":159,"address":[23763840,23763893],"length":1,"stats":{"Line":0}},{"line":160,"address":[23866841,23866816],"length":1,"stats":{"Line":0}},{"line":164,"address":[23763984,23766787],"length":1,"stats":{"Line":1}},{"line":165,"address":[23963335],"length":1,"stats":{"Line":1}},{"line":166,"address":[18004626],"length":1,"stats":{"Line":2}},{"line":167,"address":[23831925],"length":1,"stats":{"Line":0}},{"line":170,"address":[23832191,23831867],"length":1,"stats":{"Line":2}},{"line":171,"address":[23825093],"length":1,"stats":{"Line":1}},{"line":172,"address":[23963511],"length":1,"stats":{"Line":0}},{"line":175,"address":[23757519],"length":1,"stats":{"Line":1}},{"line":176,"address":[23963868],"length":1,"stats":{"Line":1}},{"line":177,"address":[23825560],"length":1,"stats":{"Line":0}},{"line":178,"address":[24009583,23863686,24009449,23866048,23866703],"length":1,"stats":{"Line":0}},{"line":179,"address":[18008285],"length":1,"stats":{"Line":0}},{"line":183,"address":[23757708],"length":1,"stats":{"Line":1}},{"line":184,"address":[23869530],"length":1,"stats":{"Line":1}},{"line":185,"address":[23751256],"length":1,"stats":{"Line":1}},{"line":186,"address":[23869567],"length":1,"stats":{"Line":1}},{"line":188,"address":[23832837],"length":1,"stats":{"Line":1}},{"line":189,"address":[23871011,23869672,23871337,24015529,24015663,23870235],"length":1,"stats":{"Line":0}},{"line":196,"address":[23867654],"length":1,"stats":{"Line":1}},{"line":199,"address":[23768616,23768384],"length":1,"stats":{"Line":1}},{"line":200,"address":[23871314],"length":1,"stats":{"Line":1}},{"line":202,"address":[23761699,23761664],"length":1,"stats":{"Line":2}},{"line":204,"address":[23867429,23867492],"length":1,"stats":{"Line":2}},{"line":205,"address":[24751356],"length":1,"stats":{"Line":1}},{"line":206,"address":[23867529],"length":1,"stats":{"Line":1}},{"line":210,"address":[23871584,23872046],"length":1,"stats":{"Line":0}},{"line":211,"address":[23761745],"length":1,"stats":{"Line":0}},{"line":212,"address":[23968072],"length":1,"stats":{"Line":0}},{"line":213,"address":[24751569,24751665],"length":1,"stats":{"Line":0}},{"line":214,"address":[23755198,23755136],"length":1,"stats":{"Line":0}},{"line":216,"address":[23755047],"length":1,"stats":{"Line":0}},{"line":220,"address":[23868176,23868862],"length":1,"stats":{"Line":0}},{"line":221,"address":[23868206],"length":1,"stats":{"Line":0}},{"line":222,"address":[23755545,23755605],"length":1,"stats":{"Line":0}},{"line":223,"address":[23872363,23872298],"length":1,"stats":{"Line":0}},{"line":224,"address":[23755894,23755800],"length":1,"stats":{"Line":0}},{"line":226,"address":[23872452,23872369],"length":1,"stats":{"Line":0}},{"line":228,"address":[23874525,23874496],"length":1,"stats":{"Line":0}},{"line":233,"address":[18010704,18011091],"length":1,"stats":{"Line":0}},{"line":234,"address":[23874711,23875487],"length":1,"stats":{"Line":0}},{"line":235,"address":[23831054,23831260],"length":1,"stats":{"Line":0}},{"line":239,"address":[23874817],"length":1,"stats":{"Line":0}},{"line":240,"address":[23838857,23838097,23838721,23979391,23838377,23979257],"length":1,"stats":{"Line":0}},{"line":241,"address":[23870027],"length":1,"stats":{"Line":0}},{"line":247,"address":[23758336,23759225,23760461],"length":1,"stats":{"Line":0}},{"line":248,"address":[23765143],"length":1,"stats":{"Line":0}},{"line":250,"address":[23833132],"length":1,"stats":{"Line":0}},{"line":251,"address":[23875444,23875261],"length":1,"stats":{"Line":0}},{"line":252,"address":[23766011,23905017,23765667,23766257,23765595,23905151],"length":1,"stats":{"Line":0}},{"line":253,"address":[24755900],"length":1,"stats":{"Line":0}},{"line":254,"address":[23759353],"length":1,"stats":{"Line":0}},{"line":255,"address":[23972433],"length":1,"stats":{"Line":0}},{"line":259,"address":[23842003,23840193],"length":1,"stats":{"Line":0}},{"line":260,"address":[23774386],"length":1,"stats":{"Line":0}},{"line":261,"address":[23973455,23835308,23973321,23835886,23835257],"length":1,"stats":{"Line":0}},{"line":262,"address":[23775004],"length":1,"stats":{"Line":0}},{"line":263,"address":[23767964],"length":1,"stats":{"Line":0}},{"line":264,"address":[23974260],"length":1,"stats":{"Line":0}},{"line":268,"address":[23760696],"length":1,"stats":{"Line":0}},{"line":269,"address":[24758808,24760279],"length":1,"stats":{"Line":0}},{"line":270,"address":[23882249],"length":1,"stats":{"Line":0}},{"line":271,"address":[23876704,24011929,24012063,23877327,23876757],"length":1,"stats":{"Line":0}},{"line":272,"address":[23771357],"length":1,"stats":{"Line":0}},{"line":273,"address":[23764517],"length":1,"stats":{"Line":0}},{"line":274,"address":[23764525],"length":1,"stats":{"Line":0}},{"line":278,"address":[23974313,23974447,23836877,23837412,23836926],"length":1,"stats":{"Line":0}},{"line":283,"address":[23879438],"length":1,"stats":{"Line":0}},{"line":288,"address":[23765600],"length":1,"stats":{"Line":0}},{"line":289,"address":[23882254],"length":1,"stats":{"Line":0}},{"line":290,"address":[18020016,18020000],"length":1,"stats":{"Line":0}},{"line":291,"address":[23882464,23882448],"length":1,"stats":{"Line":0}},{"line":295,"address":[23840512,23848025,23849463],"length":1,"stats":{"Line":0}},{"line":296,"address":[23779715],"length":1,"stats":{"Line":0}},{"line":297,"address":[23914111,23779811,23913977,23780155,23779732,23780303],"length":1,"stats":{"Line":0}},{"line":299,"address":[23879213,23880317],"length":1,"stats":{"Line":0}},{"line":300,"address":[23880486],"length":1,"stats":{"Line":0}},{"line":301,"address":[23980997],"length":1,"stats":{"Line":0}},{"line":303,"address":[23891730,24019135,23892243,24019001],"length":1,"stats":{"Line":0}},{"line":304,"address":[23987005,23987899],"length":1,"stats":{"Line":0}},{"line":307,"address":[23775085,23774556,23774855],"length":1,"stats":{"Line":0}},{"line":308,"address":[24762885,24764787,24764891,24764638,24764683],"length":1,"stats":{"Line":0}},{"line":310,"address":[23768440,23901209,23901343,23768953],"length":1,"stats":{"Line":0}},{"line":311,"address":[18023235,18024225],"length":1,"stats":{"Line":0}},{"line":314,"address":[18022697,18024290],"length":1,"stats":{"Line":0}},{"line":316,"address":[23851533,23851610],"length":1,"stats":{"Line":0}},{"line":317,"address":[24014543,23884574,24014409,23882828],"length":1,"stats":{"Line":0}},{"line":319,"address":[24115407,23983168,24115273,23983779,23983234],"length":1,"stats":{"Line":0}},{"line":322,"address":[23777410],"length":1,"stats":{"Line":0}},{"line":326,"address":[23782409,23774896,23783847],"length":1,"stats":{"Line":0}},{"line":327,"address":[23988003],"length":1,"stats":{"Line":0}},{"line":328,"address":[23892011,23891667,24019337,23891588,24019471,23892159],"length":1,"stats":{"Line":0}},{"line":330,"address":[23857005,23858109],"length":1,"stats":{"Line":0}},{"line":331,"address":[23895046],"length":1,"stats":{"Line":0}},{"line":332,"address":[23989973],"length":1,"stats":{"Line":0}},{"line":334,"address":[24016031,23895122,23895635,24015897],"length":1,"stats":{"Line":0}},{"line":335,"address":[23789693,23790587],"length":1,"stats":{"Line":0}},{"line":338,"address":[18031052,18031351,18031581],"length":1,"stats":{"Line":0}},{"line":339,"address":[23851706,23851755,23851879,23851987,23849961],"length":1,"stats":{"Line":0}},{"line":341,"address":[23777929,23903823,23903689,23777416],"length":1,"stats":{"Line":0}},{"line":342,"address":[23890611,23891601],"length":1,"stats":{"Line":0}},{"line":345,"address":[23784153,23785746],"length":1,"stats":{"Line":0}},{"line":346,"address":[18033293,18033370],"length":1,"stats":{"Line":0}},{"line":347,"address":[24985113,24777239,24985247,24775505],"length":1,"stats":{"Line":0}},{"line":352,"address":[23897426,23897360,23897971,24022969,24023103],"length":1,"stats":{"Line":0}},{"line":354,"address":[23854194],"length":1,"stats":{"Line":0}},{"line":358,"address":[23858464,23861762,23861959],"length":1,"stats":{"Line":0}},{"line":359,"address":[23996967],"length":1,"stats":{"Line":0}},{"line":360,"address":[23900560,23900611,23900841],"length":1,"stats":{"Line":0}},{"line":361,"address":[23902326,23902499,23902375],"length":1,"stats":{"Line":0}},{"line":363,"address":[23865866],"length":1,"stats":{"Line":0}},{"line":366,"address":[23865947,23865813],"length":1,"stats":{"Line":0}},{"line":367,"address":[23902742],"length":1,"stats":{"Line":0}},{"line":368,"address":[24780822],"length":1,"stats":{"Line":0}},{"line":369,"address":[23897182],"length":1,"stats":{"Line":0}},{"line":371,"address":[23897194,23897356,23897410],"length":1,"stats":{"Line":0}},{"line":372,"address":[23800441,23798506],"length":1,"stats":{"Line":0}},{"line":373,"address":[23800568,23800764,23800853,23800910,23800615],"length":1,"stats":{"Line":0}},{"line":374,"address":[23905344,23905430,23905440],"length":1,"stats":{"Line":0}},{"line":376,"address":[23861687,23861562,23861677],"length":1,"stats":{"Line":0}},{"line":378,"address":[23868822,23868355,23868861,23868709],"length":1,"stats":{"Line":0}},{"line":379,"address":[23903973,23903986,23903905],"length":1,"stats":{"Line":0}},{"line":381,"address":[18041598,18041545,18041611],"length":1,"stats":{"Line":0}},{"line":385,"address":[23798532,23919071,23918937,23799058],"length":1,"stats":{"Line":0}},{"line":390,"address":[23785273],"length":1,"stats":{"Line":0}},{"line":400,"address":[23861984,23862343],"length":1,"stats":{"Line":0}},{"line":401,"address":[24000848,24000860,24000481],"length":1,"stats":{"Line":0}},{"line":402,"address":[23862056,23862124],"length":1,"stats":{"Line":0}},{"line":403,"address":[23869081,23869145],"length":1,"stats":{"Line":0}},{"line":404,"address":[23794441],"length":1,"stats":{"Line":0}},{"line":408,"address":[23869344,23871822,23871849],"length":1,"stats":{"Line":0}},{"line":409,"address":[24784215],"length":1,"stats":{"Line":0}},{"line":410,"address":[24000996],"length":1,"stats":{"Line":0}},{"line":411,"address":[23906263],"length":1,"stats":{"Line":0}},{"line":412,"address":[23906992,23905001,23906951,23907223,23904715,23904647],"length":1,"stats":{"Line":0}},{"line":413,"address":[23903143,23903078],"length":1,"stats":{"Line":0}},{"line":415,"address":[23788230,23790608,23790839,23788594,23788439,23790251],"length":1,"stats":{"Line":0}},{"line":416,"address":[23907270,23907335],"length":1,"stats":{"Line":0}},{"line":418,"address":[24027231,23907417,23907956,23906798,23906918,23908259,24027097],"length":1,"stats":{"Line":0}},{"line":423,"address":[23907384],"length":1,"stats":{"Line":0}},{"line":427,"address":[18045168,18047049],"length":1,"stats":{"Line":0}},{"line":428,"address":[23865495],"length":1,"stats":{"Line":0}},{"line":429,"address":[23797783,23797700],"length":1,"stats":{"Line":0}},{"line":430,"address":[18047303,18047072,18045550,18045928,18045360],"length":1,"stats":{"Line":0}},{"line":431,"address":[23874310,23874375],"length":1,"stats":{"Line":0}},{"line":433,"address":[23923199,23804922,23805042,23923065,23805386],"length":1,"stats":{"Line":0}},{"line":435,"address":[23865626],"length":1,"stats":{"Line":0}},{"line":439,"address":[23874544,23876842,23878376],"length":1,"stats":{"Line":0}},{"line":440,"address":[23793063],"length":1,"stats":{"Line":0}},{"line":441,"address":[23867751,23867668],"length":1,"stats":{"Line":0}},{"line":442,"address":[24006266],"length":1,"stats":{"Line":0}},{"line":444,"address":[23911550,23911493],"length":1,"stats":{"Line":0}},{"line":445,"address":[23906171,23906001],"length":1,"stats":{"Line":0}},{"line":446,"address":[23911817],"length":1,"stats":{"Line":0}},{"line":447,"address":[23906318],"length":1,"stats":{"Line":0}},{"line":448,"address":[23912499,23911918,24028223,23912019,24028089],"length":1,"stats":{"Line":0}},{"line":449,"address":[23906901],"length":1,"stats":{"Line":0}},{"line":452,"address":[24006432],"length":1,"stats":{"Line":0}},{"line":453,"address":[23914148,23913670,23911664,24028585,24028719],"length":1,"stats":{"Line":0}},{"line":454,"address":[18050150],"length":1,"stats":{"Line":0}},{"line":460,"address":[23810640,23813424,23814869],"length":1,"stats":{"Line":0}},{"line":461,"address":[23915191],"length":1,"stats":{"Line":0}},{"line":462,"address":[23878503,23878440,23878665,23879969,23878719],"length":1,"stats":{"Line":0}},{"line":463,"address":[23915669,23915527],"length":1,"stats":{"Line":0}},{"line":464,"address":[23797643],"length":1,"stats":{"Line":0}},{"line":465,"address":[23914154],"length":1,"stats":{"Line":0}},{"line":466,"address":[23872172],"length":1,"stats":{"Line":0}},{"line":468,"address":[23811735,23811568],"length":1,"stats":{"Line":0}},{"line":469,"address":[23910811,23911155,24023497,24023631,23910481],"length":1,"stats":{"Line":0}},{"line":472,"address":[23910237,23912384,24024127,24023993],"length":1,"stats":{"Line":0}},{"line":475,"address":[23915566],"length":1,"stats":{"Line":0}},{"line":478,"address":[23919699,23919670,23919424],"length":1,"stats":{"Line":1}},{"line":479,"address":[24014225],"length":1,"stats":{"Line":1}},{"line":480,"address":[23814974],"length":1,"stats":{"Line":1}},{"line":482,"address":[24797723,24797834,24797491],"length":1,"stats":{"Line":0}},{"line":483,"address":[23914352,23914364],"length":1,"stats":{"Line":0}},{"line":488,"address":[23803053,23801696,23803091],"length":1,"stats":{"Line":1}},{"line":489,"address":[23801713],"length":1,"stats":{"Line":1}},{"line":490,"address":[23876417,23876349],"length":1,"stats":{"Line":2}},{"line":491,"address":[24798107],"length":1,"stats":{"Line":1}},{"line":494,"address":[23918548,23918500,23919726,23918725],"length":1,"stats":{"Line":2}},{"line":495,"address":[23914767,23915788,23915133,23914854],"length":1,"stats":{"Line":2}},{"line":498,"address":[24015429,24015556],"length":1,"stats":{"Line":2}},{"line":501,"address":[23921408,23921440],"length":1,"stats":{"Line":2}},{"line":505,"address":[23877291],"length":1,"stats":{"Line":1}},{"line":506,"address":[23802979],"length":1,"stats":{"Line":0}},{"line":509,"address":[24015895],"length":1,"stats":{"Line":1}},{"line":510,"address":[23884261],"length":1,"stats":{"Line":1}},{"line":511,"address":[24799001],"length":1,"stats":{"Line":1}},{"line":512,"address":[23919429],"length":1,"stats":{"Line":1}},{"line":516,"address":[23919936,23920676],"length":1,"stats":{"Line":0}},{"line":517,"address":[24016638,24016385,24017136],"length":1,"stats":{"Line":0}},{"line":518,"address":[23810895],"length":1,"stats":{"Line":0}},{"line":519,"address":[23810862],"length":1,"stats":{"Line":0}},{"line":522,"address":[23885171,23885033],"length":1,"stats":{"Line":0}},{"line":523,"address":[24016989,24016808,24016730],"length":1,"stats":{"Line":0}},{"line":524,"address":[23810596],"length":1,"stats":{"Line":0}}],"covered":35,"coverable":249},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_bootstrap.rs"],"content":"﻿//! DHT基盤のブートストラップ実装\r\n//! irohのビルトインDHTディスカバリーを使用した分散型ピア発見\r\nuse super::utils::parse_node_addr;\r\nuse crate::shared::config::BootstrapSource;\nuse crate::shared::error::AppError;\nuse iroh::{Endpoint, EndpointAddr};\nuse iroh_gossip::{\r\n    api::{GossipSender, GossipTopic},\r\n    net::Gossip,\r\n    proto::TopicId,\r\n};\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse tokio::sync::{Mutex as TokioMutex, RwLock};\r\nuse tracing::{debug, info, warn};\r\n\r\nconst LOG_TARGET: &str = \"kukuri::p2p::dht\";\r\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\r\n\r\n/// DHT統合付きGossipサービス\r\npub struct DhtGossip {\n    gossip: Gossip,\n    senders: Arc<RwLock<HashMap<String, Arc<TokioMutex<GossipSender>>>>>,\n}\n\r\nimpl DhtGossip {\r\n    /// DHT統合付きGossipを作成\r\n    pub async fn new(endpoint: Arc<Endpoint>) -> Result<Self, AppError> {\r\n        info!(target: LOG_TARGET, \"Initializing DHT-integrated Gossip service\");\r\n\r\n        // iroh-gossipを作成\r\n        let gossip = Gossip::builder().spawn(endpoint.as_ref().clone());\r\n\r\n        info!(target: LOG_TARGET, \"DHT-integrated Gossip initialized successfully\");\r\n\r\n        Ok(Self {\n            gossip,\n            senders: Arc::new(RwLock::new(HashMap::new())),\n        })\n    }\r\n\r\n    /// トピックに参加\r\n    pub async fn join_topic(\r\n        &self,\r\n        topic: &[u8],\r\n        neighbors: Vec<EndpointAddr>,\n    ) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n\r\n        // subscribe には EndpointAddrのリストではなく、EndpointIdのリストが必要\n        let peer_ids: Vec<_> = neighbors.iter().map(|addr| addr.id).collect();\n        let topic: GossipTopic = self\r\n            .gossip\r\n            .subscribe(topic_id, peer_ids)\r\n            .await\r\n            .map_err(|e| {\r\n                super::metrics::record_join_failure();\r\n                warn!(\r\n                    target: LOG_TARGET,\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    error = ?e,\r\n                    \"Failed to join DHT topic\"\r\n                );\r\n                AppError::P2PError(format!(\"Failed to join topic: {e:?}\"))\r\n            })?;\r\n\r\n        // Sender を保存（Receiver は破棄しても参加状態は維持される）\r\n        let (sender, _receiver) = topic.split();\r\n        let sender = Arc::new(TokioMutex::new(sender));\r\n        let mut senders = self.senders.write().await;\r\n        senders.insert(topic_key, sender);\r\n\r\n        super::metrics::record_join_success();\r\n        let snap = super::metrics::snapshot();\r\n        info!(\r\n            target: METRICS_TARGET,\r\n            action = \"join\",\r\n            topic = %Self::fmt_topic_id(&topic_id),\r\n            joins = snap.joins,\r\n            join_failures = snap.join_details.failures,\r\n            leaves = snap.leaves,\r\n            broadcasts = snap.broadcasts_sent,\r\n            received = snap.messages_received,\r\n            \"Joined DHT topic\"\r\n        );\r\n        Ok(())\r\n    }\r\n\r\n    /// トピックから離脱\r\n    pub async fn leave_topic(&self, topic: &[u8]) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n        let mut senders = self.senders.write().await;\r\n        if senders.remove(&topic_key).is_some() {\r\n            super::metrics::record_leave_success();\r\n            let snap = super::metrics::snapshot();\r\n            info!(\r\n                target: METRICS_TARGET,\r\n                action = \"leave\",\r\n                topic = %Self::fmt_topic_id(&topic_id),\r\n                leaves = snap.leaves,\r\n                leave_failures = snap.leave_details.failures,\r\n                joins = snap.joins,\r\n                broadcasts = snap.broadcasts_sent,\r\n                received = snap.messages_received,\r\n                \"Left DHT topic\"\r\n            );\r\n            Ok(())\r\n        } else {\r\n            super::metrics::record_leave_failure();\r\n            debug!(\r\n                target: LOG_TARGET,\r\n                topic = %Self::fmt_topic_id(&topic_id),\r\n                \"Leave requested for non-joined topic\"\r\n            );\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /// メッセージをブロードキャスト\r\n    pub async fn broadcast(&self, topic: &[u8], message: Vec<u8>) -> Result<(), AppError> {\r\n        let topic_id = Self::make_topic_id(topic);\r\n        let topic_key = Self::topic_key(&topic_id);\r\n\r\n        // 既存 Sender を探す。なければ参加して作成。\r\n        let sender_opt = {\r\n            let senders = self.senders.read().await;\r\n            senders.get(&topic_key).cloned()\r\n        };\r\n\r\n        let sender = match sender_opt {\r\n            Some(s) => s,\r\n            None => {\r\n                // 近傍指定なしで join（Receiver は破棄）\r\n                let topic: GossipTopic =\r\n                    self.gossip.subscribe(topic_id, vec![]).await.map_err(|e| {\r\n                        super::metrics::record_broadcast_failure();\r\n                        super::metrics::record_mainline_route_failure();\r\n                        warn!(\r\n                            target: LOG_TARGET,\r\n                            topic = %Self::fmt_topic_id(&topic_id),\r\n                            error = ?e,\r\n                            \"Failed to lazily subscribe before broadcast\"\r\n                        );\r\n                        AppError::P2PError(format!(\"Failed to subscribe before broadcast: {e:?}\"))\r\n                    })?;\r\n                let (sender, _receiver) = topic.split();\r\n                let sender = Arc::new(TokioMutex::new(sender));\r\n                let mut senders = self.senders.write().await;\r\n                senders.insert(topic_key.clone(), sender.clone());\r\n                sender\r\n            }\r\n        };\r\n\r\n        // ブロードキャスト\r\n        let guard = sender.lock().await;\r\n        let res = guard.broadcast(message.into()).await;\r\n\r\n        match res {\r\n            Ok(()) => {\r\n                super::metrics::record_broadcast_success();\r\n                super::metrics::record_mainline_route_success();\r\n                let snap = super::metrics::snapshot();\r\n                debug!(\r\n                    target: METRICS_TARGET,\r\n                    action = \"broadcast\",\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    broadcasts = snap.broadcasts_sent,\r\n                    broadcast_failures = snap.broadcast_details.failures,\r\n                    joins = snap.joins,\r\n                    leaves = snap.leaves,\r\n                    received = snap.messages_received,\r\n                    \"Broadcasted message on topic\"\r\n                );\r\n                Ok(())\r\n            }\r\n            Err(e) => {\r\n                super::metrics::record_broadcast_failure();\r\n                super::metrics::record_mainline_route_failure();\r\n                warn!(\r\n                    target: LOG_TARGET,\r\n                    topic = %Self::fmt_topic_id(&topic_id),\r\n                    error = ?e,\r\n                    \"Failed to broadcast gossip message\"\r\n                );\r\n                Err(AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Gossipインスタンスを取得\r\n    pub fn gossip(&self) -> &Gossip {\r\n        &self.gossip\r\n    }\r\n\r\n    fn make_topic_id(topic: &[u8]) -> TopicId {\r\n        let hash = blake3::hash(topic);\r\n        TopicId::from_bytes(*hash.as_bytes())\r\n    }\r\n\r\n    fn topic_key(topic_id: &TopicId) -> String {\r\n        use std::fmt::Write as _;\r\n        let bytes = topic_id.as_bytes();\r\n        let mut s = String::with_capacity(64);\r\n        for b in bytes {\r\n            let _ = write!(&mut s, \"{b:02x}\");\r\n        }\r\n        s\r\n    }\r\n\r\n    fn fmt_topic_id(topic_id: &TopicId) -> String {\r\n        Self::topic_key(topic_id)\r\n    }\r\n}\r\n\r\n/// 共有シークレット管理（シンプル版）\r\npub mod secret {\r\n    use super::*;\r\n    use keyring::Entry;\r\n    use rand::Rng;\r\n\r\n    const SERVICE_NAME: &str = \"kukuri\";\r\n    const SECRET_KEY: &str = \"dht_secret\";\r\n\r\n    /// シークレットを取得または生成\r\n    pub async fn get_or_create_secret() -> Result<Vec<u8>, AppError> {\r\n        // キーリングから取得を試みる\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            if let Ok(secret_str) = entry.get_password() {\r\n                use base64::prelude::*;\r\n                if let Ok(secret) = BASE64_STANDARD.decode(secret_str) {\r\n                    return Ok(secret);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 新しいシークレットを生成\r\n        let mut rng = rand::rng();\n        let mut secret = vec![0u8; 32];\r\n        rng.fill(&mut secret[..]);\r\n\r\n        // キーリングに保存\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            use base64::prelude::*;\r\n            let secret_str = BASE64_STANDARD.encode(&secret);\r\n            let _ = entry.set_password(&secret_str);\r\n        }\r\n\r\n        Ok(secret)\r\n    }\r\n\r\n    /// シークレットをローテーション\r\n    pub async fn rotate_secret() -> Result<Vec<u8>, AppError> {\r\n        let mut rng = rand::rng();\n        let mut secret = vec![0u8; 32];\r\n        rng.fill(&mut secret[..]);\r\n\r\n        // キーリングに保存\r\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\r\n            use base64::prelude::*;\r\n            let secret_str = BASE64_STANDARD.encode(&secret);\r\n            let _ = entry.set_password(&secret_str);\r\n        }\r\n\r\n        info!(\"DHT secret rotated\");\r\n        Ok(secret)\r\n    }\r\n}\r\n\r\n/// フォールバック機構\r\npub mod fallback {\n    use super::*;\n    use crate::infrastructure::p2p::bootstrap_config;\n    use crate::infrastructure::p2p::metrics;\n\n    /// ハードコードされたブートストラップノード（将来的に設定ファイルから読み込み）\r\n    /// 形式: \"NodeId@Address\" (例: \"abc123...@192.168.1.1:11204\")\r\n    const FALLBACK_NODES: &[&str] = &[\r\n        // 本番環境用のブートストラップノードをここに追加\r\n        // 例: \"NodeId@IP:Port\"\r\n    ];\r\n\r\n    /// フォールバックノードに接続\r\n    pub async fn connect_to_fallback(endpoint: &Endpoint) -> Result<Vec<EndpointAddr>, AppError> {\n        let mut connected_nodes = Vec::new();\n\r\n        for node_str in FALLBACK_NODES {\r\n            match parse_node_addr(node_str) {\r\n                Ok(node_addr) => {\r\n                    // ノードに接続を試みる\r\n                    match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\r\n                        Ok(_) => {\r\n                            info!(\"Connected to fallback node: {}\", node_str);\r\n                            metrics::record_mainline_connection_success();\r\n                            connected_nodes.push(node_addr);\r\n                        }\r\n                        Err(e) => {\r\n                            metrics::record_mainline_connection_failure();\r\n                            debug!(\"Failed to connect to fallback node {}: {:?}\", node_str, e);\r\n                        }\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    metrics::record_mainline_connection_failure();\r\n                    debug!(\"Failed to parse node address {}: {:?}\", node_str, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if connected_nodes.is_empty() {\r\n            return Err(AppError::P2PError(\r\n                \"Failed to connect to any fallback nodes\".to_string(),\r\n            ));\r\n        }\r\n\r\n        metrics::record_bootstrap_source(BootstrapSource::Fallback);\r\n\r\n        Ok(connected_nodes)\r\n    }\r\n\r\n    /// ユーザーUI設定 または 設定ファイル（bootstrap_nodes.json）から NodeId@Addr を読み込み接続\r\n    pub async fn connect_from_config(endpoint: &Endpoint) -> Result<Vec<EndpointAddr>, AppError> {\n        // 1) ユーザー設定を優先\r\n        let mut node_addrs = bootstrap_config::load_user_bootstrap_node_addrs();\r\n        // 2) ユーザー設定が空なら、プロジェクト同梱のJSONを利用\r\n        if node_addrs.is_empty() {\r\n            node_addrs = bootstrap_config::load_bootstrap_node_addrs()?;\r\n        }\r\n        let mut connected = Vec::new();\r\n\r\n        for node_addr in node_addrs {\r\n            match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\r\n                Ok(_) => {\r\n                    info!(\"Connected to config bootstrap node: {}\", node_addr.id);\n                    metrics::record_mainline_connection_success();\r\n                    connected.push(node_addr);\r\n                }\r\n                Err(e) => {\r\n                    metrics::record_mainline_connection_failure();\r\n                    debug!(\"Failed to connect to config bootstrap node: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if connected.is_empty() {\r\n            return Err(AppError::P2PError(\r\n                \"Failed to connect to nodes from bootstrap_nodes.json\".to_string(),\r\n            ));\r\n        }\r\n\r\n        metrics::record_bootstrap_source(BootstrapSource::Fallback);\r\n\r\n        Ok(connected)\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[21452250,21448560,21448599,21448705,21448552,21452180,21452079,21448544],"length":1,"stats":{"Line":0}},{"line":29,"address":[21487391,21591599,21486890,21486789,21591465],"length":1,"stats":{"Line":0}},{"line":32,"address":[15628962,15631933,15629948],"length":1,"stats":{"Line":0}},{"line":34,"address":[21375853,21375929,21479257,21479391,21376454],"length":1,"stats":{"Line":0}},{"line":36,"address":[21590500],"length":1,"stats":{"Line":0}},{"line":37,"address":[17092174],"length":1,"stats":{"Line":0}},{"line":38,"address":[21451017,21451957],"length":1,"stats":{"Line":0}},{"line":43,"address":[21495984],"length":1,"stats":{"Line":0}},{"line":48,"address":[21496321],"length":1,"stats":{"Line":0}},{"line":49,"address":[21490872,21490941],"length":1,"stats":{"Line":0}},{"line":52,"address":[21496429,21491074,21496416,21490956],"length":1,"stats":{"Line":0}},{"line":53,"address":[17094666,17094239,17094838,17094478,17094420,17095249],"length":1,"stats":{"Line":0}},{"line":55,"address":[21496880],"length":1,"stats":{"Line":0}},{"line":56,"address":[21495472,21495649,21494726,21495346,21495406],"length":1,"stats":{"Line":0}},{"line":57,"address":[21596832,21597303,21598436,21592149,21599117],"length":1,"stats":{"Line":0}},{"line":58,"address":[21465319],"length":1,"stats":{"Line":0}},{"line":59,"address":[21392261,21486537,21390638,21392165,21391017,21391161,21391768,21486671],"length":1,"stats":{"Line":0}},{"line":61,"address":[21398717,21399210],"length":1,"stats":{"Line":0}},{"line":65,"address":[21391139,21392652],"length":1,"stats":{"Line":0}},{"line":69,"address":[21379351,21379609],"length":1,"stats":{"Line":0}},{"line":70,"address":[21592780,21592911],"length":1,"stats":{"Line":0}},{"line":71,"address":[15634317,15634226,15632411,15634640],"length":1,"stats":{"Line":0}},{"line":72,"address":[17096339,17096276],"length":1,"stats":{"Line":0}},{"line":74,"address":[21387588],"length":1,"stats":{"Line":0}},{"line":75,"address":[21387595],"length":1,"stats":{"Line":0}},{"line":76,"address":[21455501,21554841,21554975,21455422,21456615,21456010,21457349],"length":1,"stats":{"Line":0}},{"line":87,"address":[21395141],"length":1,"stats":{"Line":0}},{"line":91,"address":[21399842,21399919,21399872,21400066,21399824,21400383,21402386,21400109],"length":1,"stats":{"Line":0}},{"line":92,"address":[21498987],"length":1,"stats":{"Line":0}},{"line":93,"address":[21599471],"length":1,"stats":{"Line":0}},{"line":94,"address":[11563975],"length":1,"stats":{"Line":0}},{"line":95,"address":[15641279,15641976,15641200],"length":1,"stats":{"Line":0}},{"line":96,"address":[21602140],"length":1,"stats":{"Line":0}},{"line":97,"address":[15643383],"length":1,"stats":{"Line":0}},{"line":98,"address":[21404020,21404754],"length":1,"stats":{"Line":0}},{"line":109,"address":[21396433],"length":1,"stats":{"Line":0}},{"line":111,"address":[21461738],"length":1,"stats":{"Line":0}},{"line":112,"address":[21501450,21500388,21594079,21593945,21501035,21501347,21499861],"length":1,"stats":{"Line":0}},{"line":117,"address":[21600736],"length":1,"stats":{"Line":0}},{"line":122,"address":[21510080,21510142,21511673,21510016,21510034,21513055,21510387,21510796],"length":1,"stats":{"Line":0}},{"line":123,"address":[21398857],"length":1,"stats":{"Line":0}},{"line":124,"address":[21510562],"length":1,"stats":{"Line":0}},{"line":128,"address":[21399179,21399088,21398913,21399324],"length":1,"stats":{"Line":0}},{"line":129,"address":[17108411,17108348],"length":1,"stats":{"Line":0}},{"line":132,"address":[17108517],"length":1,"stats":{"Line":0}},{"line":133,"address":[21474595],"length":1,"stats":{"Line":0}},{"line":136,"address":[15647348,15648390,15656144,15656626,15658440,15657759,15647464,15647698,15646454],"length":1,"stats":{"Line":0}},{"line":138,"address":[17117239],"length":1,"stats":{"Line":0}},{"line":139,"address":[21408718],"length":1,"stats":{"Line":0}},{"line":140,"address":[21483988,21485088,21484992,21563391,21484595,21563257,21483465,21483844],"length":1,"stats":{"Line":0}},{"line":142,"address":[21477640,21478133],"length":1,"stats":{"Line":0}},{"line":146,"address":[21402446,21403959],"length":1,"stats":{"Line":0}},{"line":148,"address":[21407931,21407673],"length":1,"stats":{"Line":0}},{"line":149,"address":[21401054,21401185],"length":1,"stats":{"Line":0}},{"line":150,"address":[11438774],"length":1,"stats":{"Line":0}},{"line":151,"address":[21511776,21511847,21512439],"length":1,"stats":{"Line":0}},{"line":152,"address":[21476964],"length":1,"stats":{"Line":0}},{"line":157,"address":[11445584],"length":1,"stats":{"Line":0}},{"line":158,"address":[11651898],"length":1,"stats":{"Line":0}},{"line":160,"address":[21471256],"length":1,"stats":{"Line":0}},{"line":162,"address":[21478210],"length":1,"stats":{"Line":0}},{"line":163,"address":[21478283],"length":1,"stats":{"Line":0}},{"line":164,"address":[21471366],"length":1,"stats":{"Line":0}},{"line":165,"address":[21611099,21611854],"length":1,"stats":{"Line":0}},{"line":176,"address":[21471936],"length":1,"stats":{"Line":0}},{"line":178,"address":[15651005],"length":1,"stats":{"Line":0}},{"line":179,"address":[21478269],"length":1,"stats":{"Line":0}},{"line":180,"address":[21512209],"length":1,"stats":{"Line":0}},{"line":181,"address":[21513329,21513817],"length":1,"stats":{"Line":0}},{"line":187,"address":[21519823,21518311],"length":1,"stats":{"Line":0}},{"line":193,"address":[21516864],"length":1,"stats":{"Line":0}},{"line":197,"address":[17119520],"length":1,"stats":{"Line":0}},{"line":198,"address":[21522488],"length":1,"stats":{"Line":0}},{"line":199,"address":[21617283],"length":1,"stats":{"Line":0}},{"line":202,"address":[21411072,21411685],"length":1,"stats":{"Line":0}},{"line":204,"address":[21418086],"length":1,"stats":{"Line":0}},{"line":205,"address":[21617430],"length":1,"stats":{"Line":0}},{"line":206,"address":[21411341,21411152,21411224],"length":1,"stats":{"Line":0}},{"line":207,"address":[15658877],"length":1,"stats":{"Line":0}},{"line":209,"address":[21411307],"length":1,"stats":{"Line":0}},{"line":212,"address":[21618000],"length":1,"stats":{"Line":0}},{"line":213,"address":[21618017],"length":1,"stats":{"Line":0}},{"line":227,"address":[17120320,17120424,17120304,17121284,17122154,17120350],"length":1,"stats":{"Line":0}},{"line":229,"address":[17120489,17120383],"length":1,"stats":{"Line":0}},{"line":230,"address":[20789683,20789773],"length":1,"stats":{"Line":0}},{"line":232,"address":[20826730,20826608],"length":1,"stats":{"Line":0}},{"line":233,"address":[20921601],"length":1,"stats":{"Line":0}},{"line":239,"address":[20722733,20722789],"length":1,"stats":{"Line":0}},{"line":240,"address":[17121381],"length":1,"stats":{"Line":0}},{"line":241,"address":[20827402,20827489],"length":1,"stats":{"Line":0}},{"line":244,"address":[20827515],"length":1,"stats":{"Line":0}},{"line":246,"address":[20922410],"length":1,"stats":{"Line":0}},{"line":247,"address":[20922586,20922518],"length":1,"stats":{"Line":0}},{"line":250,"address":[14964003],"length":1,"stats":{"Line":0}},{"line":254,"address":[20723748,20723648,20724559,20726087,20723632,20723687],"length":1,"stats":{"Line":0}},{"line":255,"address":[20923136,20923041],"length":1,"stats":{"Line":0}},{"line":256,"address":[20784664],"length":1,"stats":{"Line":0}},{"line":257,"address":[20723906,20724005],"length":1,"stats":{"Line":0}},{"line":260,"address":[20822975],"length":1,"stats":{"Line":0}},{"line":262,"address":[20724142],"length":1,"stats":{"Line":0}},{"line":263,"address":[20828858,20828778],"length":1,"stats":{"Line":0}},{"line":266,"address":[17258447,17123879,17123706,17123133,17258313,17123056],"length":1,"stats":{"Line":0}},{"line":267,"address":[20827949],"length":1,"stats":{"Line":0}},{"line":285,"address":[12229075,12228824,12229032,12228816,12229272,12228848,12228910,12235985],"length":1,"stats":{"Line":0}},{"line":286,"address":[16661729],"length":1,"stats":{"Line":0}},{"line":288,"address":[12229125,12229222,12233658,12233595],"length":1,"stats":{"Line":0}},{"line":289,"address":[12233678,12234048],"length":1,"stats":{"Line":0}},{"line":290,"address":[16672350],"length":1,"stats":{"Line":0}},{"line":292,"address":[16666418,16670774,16665960,16665718,16670879],"length":1,"stats":{"Line":0}},{"line":294,"address":[16733551,16624396,16624601,16625094,16733417],"length":1,"stats":{"Line":0}},{"line":295,"address":[16557265],"length":1,"stats":{"Line":0}},{"line":296,"address":[16664273],"length":1,"stats":{"Line":0}},{"line":298,"address":[16549835],"length":1,"stats":{"Line":0}},{"line":299,"address":[24324907],"length":1,"stats":{"Line":0}},{"line":300,"address":[16666239,16559083,16558547,16666105],"length":1,"stats":{"Line":0}},{"line":304,"address":[16767245],"length":1,"stats":{"Line":0}},{"line":305,"address":[16635737],"length":1,"stats":{"Line":0}},{"line":306,"address":[16667092,16772655,16772521,16667628],"length":1,"stats":{"Line":0}},{"line":311,"address":[16666414,16666324],"length":1,"stats":{"Line":0}},{"line":312,"address":[16666638],"length":1,"stats":{"Line":0}},{"line":313,"address":[16553743],"length":1,"stats":{"Line":0}},{"line":317,"address":[16553716],"length":1,"stats":{"Line":0}},{"line":319,"address":[24328753],"length":1,"stats":{"Line":0}},{"line":323,"address":[16674415,16680254,16674336,16674344,16675391,16674552,16674610,16674368],"length":1,"stats":{"Line":0}},{"line":325,"address":[16674529],"length":1,"stats":{"Line":0}},{"line":327,"address":[16637892,16637992,16638383],"length":1,"stats":{"Line":0}},{"line":328,"address":[12237055,12236504],"length":1,"stats":{"Line":0}},{"line":330,"address":[12236470],"length":1,"stats":{"Line":0}},{"line":332,"address":[24336245,24331966,24336282,24331844,24336127],"length":1,"stats":{"Line":0}},{"line":333,"address":[16674582,16679666,16680149,16675881,16675423],"length":1,"stats":{"Line":0}},{"line":335,"address":[16770691,16770896,16873385,16873519,16771389],"length":1,"stats":{"Line":0}},{"line":336,"address":[16671000],"length":1,"stats":{"Line":0}},{"line":337,"address":[16566174],"length":1,"stats":{"Line":0}},{"line":339,"address":[16632242],"length":1,"stats":{"Line":0}},{"line":340,"address":[16674386],"length":1,"stats":{"Line":0}},{"line":341,"address":[16779097,16779231,16678411,16677875],"length":1,"stats":{"Line":0}},{"line":346,"address":[16642940],"length":1,"stats":{"Line":0}},{"line":347,"address":[16774771],"length":1,"stats":{"Line":0}},{"line":348,"address":[16561484],"length":1,"stats":{"Line":0}},{"line":352,"address":[16575217],"length":1,"stats":{"Line":0}},{"line":354,"address":[16678158],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":141},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_integration.rs"],"content":"//! DHT統合モジュール\n//! iroh-gossipとdistributed-topic-trackerの統合\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::{generate_topic_id, topic_id_bytes};\nuse crate::infrastructure::p2p::dht_bootstrap::DhtGossip;\nuse crate::shared::error::AppError;\n// use iroh_gossip::proto::Event as GossipEvent;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{debug, error};\n\n/// DHTイベントハンドラー\npub struct DhtEventHandler {\n    event_tx: mpsc::Sender<Event>,\n}\n\nimpl DhtEventHandler {\n    /// 新しいハンドラーを作成\n    pub fn new(event_tx: mpsc::Sender<Event>) -> Self {\n        Self { event_tx }\n    }\n\n    /// Gossipメッセージを処理\n    pub async fn handle_message(&self, data: &[u8], from: Option<String>) -> Result<(), AppError> {\n        debug!(\"Received message from {:?}\", from);\n\n        // メッセージをデシリアライズ\n        if let Ok(event) = self.deserialize_message(data).await {\n            // イベントチャンネルに送信\n            if let Err(e) = self.event_tx.send(event).await {\n                error!(\"Failed to send event: {:?}\", e);\n            }\n        }\n        Ok(())\n    }\n\n    /// メッセージをデシリアライズ\n    async fn deserialize_message(&self, data: &[u8]) -> Result<Event, AppError> {\n        bincode::serde::decode_from_slice::<Event, _>(data, bincode::config::standard())\n            .map(|(event, _)| event)\n            .map_err(|e| {\n                AppError::DeserializationError(format!(\"failed to deserialize DHT event: {e:?}\"))\n            })\n    }\n}\n\n/// DHT統合マネージャー\npub struct DhtIntegration {\n    dht_gossip: Arc<DhtGossip>,\n    event_handler: Option<DhtEventHandler>,\n}\n\nimpl DhtIntegration {\n    /// 新しい統合マネージャーを作成\n    pub fn new(dht_gossip: Arc<DhtGossip>) -> Self {\n        Self {\n            dht_gossip,\n            event_handler: None,\n        }\n    }\n\n    /// ????????????\n    pub fn set_event_handler(&mut self, event_tx: mpsc::Sender<Event>) {\n        self.event_handler = Some(DhtEventHandler::new(event_tx));\n    }\n\n    /// ???????\n    pub async fn join_topic(&self, topic: &str) -> Result<(), AppError> {\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.join_topic(&topic_bytes, vec![]).await?;\n        Ok(())\n    }\n\n    /// ????????\n    pub async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.leave_topic(&topic_bytes).await?;\n        Ok(())\n    }\n\n    /// ?????????????\n    pub async fn broadcast_event(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        // ???????????\n        let message = bincode::serde::encode_to_vec(event, bincode::config::standard())\n            .map_err(|e| AppError::SerializationError(format!(\"Failed to serialize: {e:?}\")))?;\n\n        // DHT?????????\n        let canonical = generate_topic_id(topic);\n        let topic_bytes = topic_id_bytes(&canonical);\n        self.dht_gossip.broadcast(&topic_bytes, message).await?;\n\n        debug!(\n            \"Event broadcast to topic: {} (canonical: {})\",\n            topic, canonical\n        );\n        Ok(())\n    }\n}\n\n/// NostrとDHTのブリッジ\npub mod bridge {\n    use super::*;\n    use nostr_sdk::{Event as NostrEvent, JsonUtil};\n    use serde_json::json;\n    use std::convert::TryFrom;\n\n    /// NostrイベントをKukuriイベントに変換\n    pub fn nostr_to_kukuri(event: &NostrEvent) -> Result<Event, AppError> {\n        let timestamp_raw = event.created_at.as_secs();\n        let timestamp = i64::try_from(timestamp_raw).map_err(|_| {\n            AppError::DeserializationError(format!(\n                \"timestamp overflow when converting nostr event: {timestamp_raw}\"\n            ))\n        })?;\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(timestamp, 0).ok_or_else(|| {\n                AppError::DeserializationError(format!(\n                    \"invalid timestamp in nostr event: {timestamp}\"\n                ))\n            })?;\n\n        Ok(Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        })\n    }\n\n    /// KukuriイベントをNostrイベントに変換\n    pub fn kukuri_to_nostr(event: &Event) -> Result<NostrEvent, AppError> {\n        let payload = json!({\n            \"id\": event.id,\n            \"pubkey\": event.pubkey,\n            \"created_at\": event.created_at.timestamp(),\n            \"kind\": event.kind,\n            \"tags\": event.tags,\n            \"content\": event.content,\n            \"sig\": event.sig,\n        });\n\n        NostrEvent::from_json(payload.to_string())\n            .map_err(|e| AppError::NostrError(format!(\"Failed to convert event: {e}\")))\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use nostr_sdk::{EventBuilder, Keys, Tag};\n\n        #[test]\n        fn convert_nostr_to_domain_event() {\n            let keys = Keys::generate();\n            let event = EventBuilder::text_note(\"hello nostr to domain\")\n                .tags(vec![Tag::hashtag(\"kukuri\")])\n                .sign_with_keys(&keys)\n                .expect(\"signing succeeds\");\n\n            let converted = nostr_to_kukuri(&event).expect(\"conversion succeeds\");\n            assert_eq!(converted.id, event.id.to_string());\n            assert_eq!(converted.pubkey, event.pubkey.to_string());\n            assert_eq!(converted.kind, event.kind.as_u16() as u32);\n            assert_eq!(converted.content, event.content);\n            assert_eq!(converted.tags.len(), 1);\n            assert_eq!(converted.tags[0][0], \"t\");\n            assert_eq!(converted.sig, event.sig.to_string());\n        }\n\n        #[test]\n        fn convert_domain_to_nostr_event() {\n            let keys = Keys::generate();\n            let nostr_event = EventBuilder::text_note(\"roundtrip conversion\")\n                .tags(vec![Tag::hashtag(\"kukuri\")])\n                .sign_with_keys(&keys)\n                .expect(\"signing succeeds\");\n\n            let domain_event = nostr_to_kukuri(&nostr_event).expect(\"conversion succeeds\");\n\n            let rebuilt = kukuri_to_nostr(&domain_event).expect(\"rebuild succeeds\");\n            assert_eq!(rebuilt.id, nostr_event.id);\n            assert_eq!(rebuilt.pubkey, nostr_event.pubkey);\n            assert_eq!(rebuilt.kind, nostr_event.kind);\n            assert_eq!(rebuilt.content, nostr_event.content);\n            assert_eq!(rebuilt.tags, nostr_event.tags);\n            assert_eq!(rebuilt.sig, nostr_event.sig);\n            assert_eq!(rebuilt.created_at, nostr_event.created_at);\n        }\n    }\n}\n","traces":[{"line":19,"address":[26548112],"length":1,"stats":{"Line":0}},{"line":24,"address":[22191111,22188994,22189267,22193753,22191768,22189040,22189087,22188976],"length":1,"stats":{"Line":0}},{"line":25,"address":[22189915,22328153,22189386,22328287,22189239],"length":1,"stats":{"Line":0}},{"line":28,"address":[16429841,16430418,16431687,16431526],"length":1,"stats":{"Line":0}},{"line":30,"address":[22288262,22290721,22290584,22290457],"length":1,"stats":{"Line":0}},{"line":31,"address":[22294999,22431529,22295601,22295100,22431663],"length":1,"stats":{"Line":0}},{"line":34,"address":[22391046],"length":1,"stats":{"Line":0}},{"line":38,"address":[16434798,16434480,16434432,16434510,16434450,16434610],"length":1,"stats":{"Line":0}},{"line":39,"address":[22292999,22293086],"length":1,"stats":{"Line":0}},{"line":40,"address":[22298828,22298816],"length":1,"stats":{"Line":0}},{"line":41,"address":[16435090,16434864],"length":1,"stats":{"Line":0}},{"line":42,"address":[26554622,26554574],"length":1,"stats":{"Line":0}},{"line":55,"address":[26554800],"length":1,"stats":{"Line":0}},{"line":63,"address":[26554832,26554902],"length":1,"stats":{"Line":0}},{"line":64,"address":[22194638,22194717],"length":1,"stats":{"Line":0}},{"line":68,"address":[22394048,22394131,22394254,22394294,22394613,22394096,22395062,22394066],"length":1,"stats":{"Line":0}},{"line":69,"address":[22394234],"length":1,"stats":{"Line":0}},{"line":70,"address":[22262867,22262789],"length":1,"stats":{"Line":0}},{"line":71,"address":[16435877,16435513,16435676,16436153],"length":1,"stats":{"Line":0}},{"line":72,"address":[22298461],"length":1,"stats":{"Line":0}},{"line":76,"address":[22300371,22301259,22300810,22300494,22300534,22300288,22300336,22300306],"length":1,"stats":{"Line":0}},{"line":77,"address":[22182186],"length":1,"stats":{"Line":0}},{"line":78,"address":[22300659,22300581],"length":1,"stats":{"Line":0}},{"line":79,"address":[16436537,16437134,16436700,16436858],"length":1,"stats":{"Line":0}},{"line":80,"address":[22196562],"length":1,"stats":{"Line":0}},{"line":84,"address":[22183056,22186226,22183015,22184115,22183103,22183292,22183350,22182992],"length":1,"stats":{"Line":0}},{"line":86,"address":[22296380,22296797,22295985,22296112],"length":1,"stats":{"Line":0}},{"line":87,"address":[22302912,22302934,22300268],"length":1,"stats":{"Line":0}},{"line":90,"address":[22183585],"length":1,"stats":{"Line":0}},{"line":91,"address":[16438167,16438065],"length":1,"stats":{"Line":0}},{"line":92,"address":[22190106,22191224,22190681,22190931],"length":1,"stats":{"Line":0}},{"line":94,"address":[22301172,22432025,22432159,22301688,22301052],"length":1,"stats":{"Line":0}},{"line":98,"address":[26559423],"length":1,"stats":{"Line":0}},{"line":110,"address":[23670272,23671402],"length":1,"stats":{"Line":1}},{"line":111,"address":[16108406],"length":1,"stats":{"Line":1}},{"line":112,"address":[16013088,16011991,16012237],"length":1,"stats":{"Line":1}},{"line":113,"address":[15971062],"length":1,"stats":{"Line":0}},{"line":117,"address":[15971232,15970046,15970220,15970330],"length":1,"stats":{"Line":2}},{"line":119,"address":[16009365],"length":1,"stats":{"Line":0}},{"line":124,"address":[15896118],"length":1,"stats":{"Line":1}},{"line":125,"address":[15902442],"length":1,"stats":{"Line":1}},{"line":126,"address":[15977204],"length":1,"stats":{"Line":2}},{"line":128,"address":[16008517,16008587],"length":1,"stats":{"Line":4}},{"line":129,"address":[15902674,15903646,15903600],"length":1,"stats":{"Line":6}},{"line":130,"address":[15970562],"length":1,"stats":{"Line":2}},{"line":131,"address":[16014330],"length":1,"stats":{"Line":1}},{"line":136,"address":[15903696,15905580],"length":1,"stats":{"Line":1}},{"line":137,"address":[15972138,15971534,15973410,15972191],"length":1,"stats":{"Line":2}},{"line":140,"address":[23672503,23672567],"length":1,"stats":{"Line":2}},{"line":147,"address":[16016947,16017009],"length":1,"stats":{"Line":2}},{"line":148,"address":[16015638,16015616],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":51},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","discovery_options.rs"],"content":"use crate::shared::config::NetworkConfig;\nuse iroh::discovery::{\n    dns::DnsDiscovery,\n    mdns::MdnsDiscovery,\n    pkarr::{PkarrPublisher, dht::DhtDiscovery},\n};\n\n/// P2Pネットワークのディスカバリー設定\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct DiscoveryOptions {\n    pub enable_dns: bool,\n    pub enable_mainline: bool,\n    pub enable_local: bool,\n}\n\nimpl DiscoveryOptions {\n    pub fn new(enable_dns: bool, enable_mainline: bool, enable_local: bool) -> Self {\n        Self {\n            enable_dns,\n            enable_mainline,\n            enable_local,\n        }\n    }\n\n    pub fn with_mainline(mut self, enabled: bool) -> Self {\n        self.enable_mainline = enabled;\n        self\n    }\n\n    pub fn enable_mainline(&self) -> bool {\n        self.enable_mainline\n    }\n\n    pub fn apply_to_builder(\n        &self,\n        mut builder: iroh::endpoint::Builder,\n    ) -> iroh::endpoint::Builder {\n        builder = builder.clear_discovery();\n\n        if self.enable_dns {\n            builder = builder.discovery(PkarrPublisher::n0_dns());\n            builder = builder.discovery(DnsDiscovery::n0_dns());\n        }\n        if self.enable_mainline {\n            builder = builder.discovery(\n                DhtDiscovery::builder()\n                    .include_direct_addresses(true)\n                    .n0_dns_pkarr_relay(),\n            );\n        }\n        if self.enable_local {\n            builder = builder.discovery(MdnsDiscovery::builder());\n        }\n        builder\n    }\n}\n\nimpl Default for DiscoveryOptions {\n    fn default() -> Self {\n        Self {\n            enable_dns: true,\n            enable_mainline: true,\n            enable_local: false,\n        }\n    }\n}\n\nimpl From<&NetworkConfig> for DiscoveryOptions {\n    fn from(cfg: &NetworkConfig) -> Self {\n        Self {\n            enable_dns: cfg.enable_dns,\n            enable_mainline: cfg.enable_dht,\n            enable_local: cfg.enable_local,\n        }\n    }\n}\n","traces":[{"line":17,"address":[23810944],"length":1,"stats":{"Line":0}},{"line":25,"address":[15208432],"length":1,"stats":{"Line":0}},{"line":26,"address":[23916973],"length":1,"stats":{"Line":0}},{"line":27,"address":[15208481],"length":1,"stats":{"Line":0}},{"line":30,"address":[23804320],"length":1,"stats":{"Line":2}},{"line":31,"address":[23878917],"length":1,"stats":{"Line":2}},{"line":34,"address":[23811120,23812152,23812120],"length":1,"stats":{"Line":0}},{"line":38,"address":[23818169],"length":1,"stats":{"Line":0}},{"line":40,"address":[23879470,23879095],"length":1,"stats":{"Line":0}},{"line":41,"address":[23812199,23811317],"length":1,"stats":{"Line":0}},{"line":42,"address":[23804726,23805396],"length":1,"stats":{"Line":0}},{"line":44,"address":[23886651,23886033],"length":1,"stats":{"Line":0}},{"line":45,"address":[15209265,15209317,15209116],"length":1,"stats":{"Line":0}},{"line":46,"address":[23917642,23917702],"length":1,"stats":{"Line":0}},{"line":51,"address":[23923619,23923176],"length":1,"stats":{"Line":0}},{"line":52,"address":[15209378,15209549],"length":1,"stats":{"Line":0}},{"line":54,"address":[23811930],"length":1,"stats":{"Line":0}},{"line":69,"address":[23812256],"length":1,"stats":{"Line":0}},{"line":71,"address":[24018552],"length":1,"stats":{"Line":0}},{"line":72,"address":[23880069],"length":1,"stats":{"Line":0}},{"line":73,"address":[23922123],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":21},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","default.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse bincode::serde::encode_to_vec;\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info, warn};\n\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::{DistributionMetrics, DistributionStrategy};\nuse crate::infrastructure::p2p::{GossipService, NetworkService};\nuse crate::shared::error::AppError;\n\nuse super::state::DistributorState;\nuse super::{DynError, EventDistributor, P2PDistributionMetrics};\n\n/// デフォルトの EventDistributor 実装。\npub struct DefaultEventDistributor {\n    state: Arc<RwLock<DistributorState>>,\n    metrics: Arc<dyn DistributionMetrics>,\n    gossip_service: Arc<RwLock<Option<Arc<dyn GossipService>>>>,\n    network_service: Arc<RwLock<Option<Arc<dyn NetworkService>>>>,\n    default_topics: Arc<RwLock<Vec<String>>>,\n}\n\nimpl DefaultEventDistributor {\n    pub fn new() -> Self {\n        Self::with_strategy(DistributionStrategy::Hybrid)\n    }\n\n    pub fn with_strategy(strategy: DistributionStrategy) -> Self {\n        Self::with_strategy_and_metrics(\n            strategy,\n            Arc::new(P2PDistributionMetrics) as Arc<dyn DistributionMetrics>,\n        )\n    }\n\n    pub fn with_strategy_and_metrics(\n        strategy: DistributionStrategy,\n        metrics: Arc<dyn DistributionMetrics>,\n    ) -> Self {\n        Self {\n            state: Arc::new(RwLock::new(DistributorState::new(strategy))),\n            metrics,\n            gossip_service: Arc::new(RwLock::new(None)),\n            network_service: Arc::new(RwLock::new(None)),\n            default_topics: Arc::new(RwLock::new(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])),\n        }\n    }\n\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        let mut guard = self.gossip_service.write().await;\n        *guard = Some(gossip);\n    }\n\n    pub async fn set_network_service(&self, network: Arc<dyn NetworkService>) {\n        let mut guard = self.network_service.write().await;\n        *guard = Some(network);\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        let mut guard = self.default_topics.write().await;\n        guard.clear();\n        guard.extend(\n            topics\n                .into_iter()\n                .filter(|topic| !topic.trim().is_empty())\n                .map(|topic| topic.trim().to_string()),\n        );\n        if guard.is_empty() {\n            guard.push(DEFAULT_PUBLIC_TOPIC_ID.to_string());\n        }\n    }\n\n    async fn resolve_topics(&self, event: &Event) -> Vec<String> {\n        let mut topics: HashSet<String> = event\n            .tags\n            .iter()\n            .filter_map(|tag| {\n                if tag.is_empty() {\n                    return None;\n                }\n                match tag[0].as_str() {\n                    \"topic\" | \"t\" => tag.get(1).cloned(),\n                    _ => None,\n                }\n            })\n            .filter(|topic| !topic.trim().is_empty())\n            .map(|topic| topic.trim().to_string())\n            .collect();\n\n        if topics.is_empty() {\n            let defaults = self.default_topics.read().await;\n            topics.extend(defaults.iter().cloned());\n        }\n\n        let mut resolved: Vec<String> = topics.into_iter().collect();\n        resolved.sort();\n        resolved\n    }\n\n    async fn broadcast_via_gossip(&self, event: &Event, topics: &[String]) -> Result<(), DynError> {\n        if topics.is_empty() {\n            return Ok(());\n        }\n\n        let gossip = {\n            let guard = self.gossip_service.read().await;\n            guard.clone()\n        };\n\n        let Some(gossip) = gossip else {\n            warn!(\"GossipService not configured; skipping gossip broadcast\");\n            return Ok(());\n        };\n\n        for topic in topics {\n            if topic.is_empty() {\n                continue;\n            }\n\n            if let Err(err) = gossip.join_topic(topic, Vec::new()).await {\n                warn!(\"Joining topic {topic} failed before broadcast: {err}\");\n            }\n\n            gossip.broadcast(topic, event).await.map_err(|err| {\n                warn!(\n                    \"Failed to broadcast event {} on topic {} via gossip: {}\",\n                    event.id, topic, err\n                );\n                Box::new(err) as DynError\n            })?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_via_network(\n        &self,\n        event: &Event,\n        topics: &[String],\n    ) -> Result<(), DynError> {\n        if topics.is_empty() {\n            return Ok(());\n        }\n\n        let network = {\n            let guard = self.network_service.read().await;\n            guard.clone()\n        };\n\n        let Some(network) = network else {\n            return Ok(());\n        };\n\n        let payload = encode_to_vec(event, bincode::config::standard()).map_err(|err| {\n            Box::new(AppError::SerializationError(format!(\n                \"Failed to serialize event for DHT broadcast: {err}\"\n            ))) as DynError\n        })?;\n\n        for topic in topics {\n            if topic.is_empty() {\n                continue;\n            }\n\n            if let Err(err) = network.join_dht_topic(topic).await {\n                warn!(\"Failed to join DHT topic {topic} before broadcast: {}\", err);\n            }\n\n            network\n                .broadcast_dht(topic, payload.clone())\n                .await\n                .map_err(|err| Box::new(err) as DynError)?;\n        }\n\n        Ok(())\n    }\n\n    async fn broadcast_p2p(&self, event: &Event, topics: &[String]) -> Result<(), DynError> {\n        self.broadcast_via_gossip(event, topics).await?;\n        self.broadcast_via_network(event, topics).await?;\n        Ok(())\n    }\n\n    async fn broadcast_direct(&self, event: &Event, peer_id: &str) -> Result<(), DynError> {\n        if peer_id.trim().is_empty() {\n            warn!(\n                \"Direct distribution requested with empty peer id; falling back to standard P2P broadcast\"\n            );\n        } else {\n            let network = {\n                let guard = self.network_service.read().await;\n                guard.clone()\n            };\n\n            if let Some(network) = network {\n                if peer_id.contains('@') {\n                    if let Err(err) = network.add_peer(peer_id).await {\n                        warn!(\"Failed to add peer {peer_id} for direct distribution: {err}\");\n                    }\n                } else {\n                    warn!(\n                        \"Peer id \\\"{peer_id}\\\" is not in node_id@address format; skipping add_peer\"\n                    );\n                }\n            } else {\n                warn!(\n                    \"NetworkService not configured; direct distribution cannot target specific peer\"\n                );\n            }\n        }\n\n        let topics = self.resolve_topics(event).await;\n        self.broadcast_p2p(event, &topics).await\n    }\n\n    async fn distribute_internal(\n        &self,\n        event: &Event,\n        strategy: &DistributionStrategy,\n    ) -> Result<(), DynError> {\n        match strategy {\n            DistributionStrategy::Broadcast => {\n                debug!(\"Broadcasting event {} to all peers\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_p2p(event, &topics).await?;\n                info!(\"Event {} broadcasted via gossip/DHT\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Gossip => {\n                debug!(\"Distributing event {} via Gossip protocol\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_via_gossip(event, &topics).await?;\n                info!(\"Event {} distributed via gossip\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Direct(peer_id) => {\n                debug!(\"Sending event {} directly to peer {}\", event.id, peer_id);\n                self.broadcast_direct(event, peer_id).await?;\n                info!(\n                    \"Event {} distributed directly (peer {}) via fallback P2P path\",\n                    event.id, peer_id\n                );\n                Ok(())\n            }\n            DistributionStrategy::Hybrid => {\n                debug!(\"Distributing event {} using hybrid strategy\", event.id);\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::Nostr)).await?;\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::P2P)).await?;\n                Ok(())\n            }\n            DistributionStrategy::Nostr => {\n                debug!(\"Distributing event {} via Nostr relays\", event.id);\n                info!(\n                    \"Event {} marked for Nostr distribution (handled upstream)\",\n                    event.id\n                );\n                Ok(())\n            }\n            DistributionStrategy::P2P => {\n                debug!(\"Distributing event {} via P2P network\", event.id);\n                let topics = self.resolve_topics(event).await;\n                self.broadcast_p2p(event, &topics).await?;\n                info!(\"Event {} distributed via P2P\", event.id);\n                Ok(())\n            }\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) async fn current_strategy(&self) -> DistributionStrategy {\n        self.state.read().await.strategy()\n    }\n}\n\nimpl Default for DefaultEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for DefaultEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        debug!(\n            \"Distributing event {} with strategy {:?}\",\n            event.id, strategy\n        );\n        self.metrics.record_attempt(&strategy);\n\n        match self.distribute_internal(event, &strategy).await {\n            Ok(()) => {\n                info!(\"Event {} distributed successfully\", event.id);\n                self.metrics.record_success(&strategy);\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"Failed to distribute event {}: {}\", event.id, e);\n                self.metrics.record_failure(&strategy);\n\n                let mut state = self.state.write().await;\n                state.record_failure(event.clone(), strategy);\n\n                Err(e)\n            }\n        }\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        let mut state = self.state.write().await;\n        Ok(state.pop_pending())\n    }\n\n    async fn set_strategy(&self, strategy: DistributionStrategy) {\n        let mut state = self.state.write().await;\n        debug!(\"Setting distribution strategy to {:?}\", strategy);\n        state.set_strategy(strategy);\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        let state = self.state.read().await;\n        Ok(state.pending_events_snapshot())\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        let mut state = self.state.write().await;\n        let failed_events = state.drain_failures();\n        let mut retry_count = 0;\n        let mut still_failed = Vec::new();\n\n        for (event, strategy) in failed_events {\n            debug!(\"Retrying distribution for event {}\", event.id);\n            match self.distribute_internal(&event, &strategy).await {\n                Ok(()) => {\n                    info!(\"Event {} successfully distributed on retry\", event.id);\n                    self.metrics.record_success(&strategy);\n                    retry_count += 1;\n                }\n                Err(e) => {\n                    error!(\"Event {} failed again on retry: {}\", event.id, e);\n                    self.metrics.record_failure(&strategy);\n                    still_failed.push((event, strategy));\n                }\n            }\n        }\n\n        state.restore_failures(still_failed);\n\n        Ok(retry_count)\n    }\n}\n","traces":[{"line":28,"address":[23081120],"length":1,"stats":{"Line":1}},{"line":29,"address":[18076748],"length":1,"stats":{"Line":2}},{"line":32,"address":[23176087,23175952,23176113],"length":1,"stats":{"Line":2}},{"line":34,"address":[17217198],"length":1,"stats":{"Line":2}},{"line":35,"address":[23037513],"length":1,"stats":{"Line":3}},{"line":39,"address":[23082281,23082248,23081344],"length":1,"stats":{"Line":3}},{"line":44,"address":[17217459,17217387],"length":1,"stats":{"Line":6}},{"line":46,"address":[22970035,22970133],"length":1,"stats":{"Line":4}},{"line":47,"address":[22977146,22977244],"length":1,"stats":{"Line":4}},{"line":48,"address":[23081819,23081877,23082257],"length":1,"stats":{"Line":4}},{"line":52,"address":[23080720,23080690,23080891,23080745,23081062,23080672,23081658,23081637],"length":1,"stats":{"Line":4}},{"line":53,"address":[22978214,22978038,22977991,22978098],"length":1,"stats":{"Line":2}},{"line":54,"address":[23081301,23081591,23081618],"length":1,"stats":{"Line":1}},{"line":57,"address":[23039664,23040650,23040629,23039682,23040054,23039883,23039737,23039712],"length":1,"stats":{"Line":0}},{"line":58,"address":[17219622,17219575,17219682,17219798],"length":1,"stats":{"Line":0}},{"line":59,"address":[23178773,23179063,23179090],"length":1,"stats":{"Line":0}},{"line":62,"address":[23040752,23041090,23040911,23041786,23040777,23040712,23040704,23041807],"length":1,"stats":{"Line":0}},{"line":63,"address":[11067409],"length":1,"stats":{"Line":0}},{"line":64,"address":[23048332,23048265],"length":1,"stats":{"Line":0}},{"line":65,"address":[23180043,23179895],"length":1,"stats":{"Line":0}},{"line":66,"address":[23048364],"length":1,"stats":{"Line":0}},{"line":68,"address":[23079993,23079968],"length":1,"stats":{"Line":0}},{"line":69,"address":[22981120,22981088],"length":1,"stats":{"Line":0}},{"line":71,"address":[22980909,22980757],"length":1,"stats":{"Line":0}},{"line":72,"address":[23083727,23083690],"length":1,"stats":{"Line":0}},{"line":76,"address":[23085038,23084157,23084239,23084462,23084144,23084404,23084192,23085799],"length":1,"stats":{"Line":4}},{"line":77,"address":[23180805,23180960],"length":1,"stats":{"Line":2}},{"line":80,"address":[23085840],"length":1,"stats":{"Line":0}},{"line":81,"address":[23087525],"length":1,"stats":{"Line":0}},{"line":82,"address":[23043912],"length":1,"stats":{"Line":0}},{"line":84,"address":[23085892],"length":1,"stats":{"Line":0}},{"line":85,"address":[23087632,23087580],"length":1,"stats":{"Line":0}},{"line":86,"address":[23050936],"length":1,"stats":{"Line":0}},{"line":89,"address":[22976224,22976249],"length":1,"stats":{"Line":0}},{"line":90,"address":[23082240,23082208],"length":1,"stats":{"Line":0}},{"line":93,"address":[22974955,22974876],"length":1,"stats":{"Line":2}},{"line":94,"address":[18081929,18081470,18082066],"length":1,"stats":{"Line":1}},{"line":95,"address":[17223076,17222986],"length":1,"stats":{"Line":2}},{"line":98,"address":[22968177,22968903],"length":1,"stats":{"Line":2}},{"line":99,"address":[22968930,22969011],"length":1,"stats":{"Line":3}},{"line":100,"address":[22982798],"length":1,"stats":{"Line":1}},{"line":103,"address":[23183024,23182847,23182752,23183109,23183438,23182775,23182800,23185768],"length":1,"stats":{"Line":6}},{"line":104,"address":[23183163,23182988],"length":1,"stats":{"Line":3}},{"line":105,"address":[23044720],"length":1,"stats":{"Line":0}},{"line":109,"address":[11659217],"length":1,"stats":{"Line":3}},{"line":110,"address":[17225047,17224968],"length":1,"stats":{"Line":3}},{"line":113,"address":[18084408],"length":1,"stats":{"Line":1}},{"line":114,"address":[23083667,23084401,23202118,23083880,23201961],"length":1,"stats":{"Line":0}},{"line":115,"address":[23084377],"length":1,"stats":{"Line":0}},{"line":118,"address":[22984681,22984815,22986989,22986907,22987061],"length":1,"stats":{"Line":8}},{"line":119,"address":[22987131,22987081],"length":1,"stats":{"Line":3}},{"line":123,"address":[11659237],"length":1,"stats":{"Line":3}},{"line":124,"address":[23092417,23092316,23092943,23208073,23208230],"length":1,"stats":{"Line":0}},{"line":127,"address":[11652281],"length":1,"stats":{"Line":3}},{"line":128,"address":[22976175,22976251,22976595,22976836,23090313,23090470],"length":1,"stats":{"Line":0}},{"line":132,"address":[23092799,23093357],"length":1,"stats":{"Line":0}},{"line":136,"address":[18086761],"length":1,"stats":{"Line":1}},{"line":139,"address":[18091392],"length":1,"stats":{"Line":1}},{"line":144,"address":[22985077,22985255],"length":1,"stats":{"Line":3}},{"line":145,"address":[23191580],"length":1,"stats":{"Line":0}},{"line":149,"address":[11861444],"length":1,"stats":{"Line":3}},{"line":150,"address":[18092468,18092405],"length":1,"stats":{"Line":3}},{"line":153,"address":[22979256],"length":1,"stats":{"Line":1}},{"line":154,"address":[23192431],"length":1,"stats":{"Line":2}},{"line":157,"address":[22979678,22979842,22983424,22983664,22979328,22979432],"length":1,"stats":{"Line":0}},{"line":158,"address":[23096143,23096203],"length":1,"stats":{"Line":0}},{"line":163,"address":[18093641,18092904,18093719,18093791,18093072],"length":1,"stats":{"Line":0}},{"line":164,"address":[23055139,23055215],"length":1,"stats":{"Line":0}},{"line":168,"address":[11761099],"length":1,"stats":{"Line":0}},{"line":169,"address":[17345145,17235537,17236164,17345302,17235638],"length":1,"stats":{"Line":0}},{"line":172,"address":[22986898,22987018,22990062,22989837,22987194,22990105,22989997],"length":1,"stats":{"Line":0}},{"line":173,"address":[23196178],"length":1,"stats":{"Line":0}},{"line":174,"address":[23091105,23095953,23096004,23092673,23092866],"length":1,"stats":{"Line":0}},{"line":175,"address":[23196768,23196769,23193450],"length":1,"stats":{"Line":0}},{"line":178,"address":[23093196],"length":1,"stats":{"Line":0}},{"line":181,"address":[23065248,23065552,23065271,23065340,23065296,23065497,23066285,23065684],"length":1,"stats":{"Line":6}},{"line":182,"address":[11732113],"length":1,"stats":{"Line":3}},{"line":183,"address":[23102769,23102872,23103364,23102307,23103062],"length":1,"stats":{"Line":4}},{"line":184,"address":[18098159],"length":1,"stats":{"Line":1}},{"line":187,"address":[22987373,22985448,22985278,22991468,22985168,22985554,22985191,22985216],"length":1,"stats":{"Line":0}},{"line":188,"address":[23098321,23098111,23106280],"length":1,"stats":{"Line":0}},{"line":189,"address":[18099475,18098779,18098962,18345455,18345321],"length":1,"stats":{"Line":0}},{"line":194,"address":[22999517,22999404,23001165,22999238],"length":1,"stats":{"Line":0}},{"line":195,"address":[23100454,23100375],"length":1,"stats":{"Line":0}},{"line":198,"address":[23100563],"length":1,"stats":{"Line":0}},{"line":199,"address":[22987928,22988052],"length":1,"stats":{"Line":0}},{"line":200,"address":[11704834],"length":1,"stats":{"Line":0}},{"line":201,"address":[23304969,23205519,23305126,23204993,23204892],"length":1,"stats":{"Line":0}},{"line":204,"address":[17242969,17242362,17346729,17346886,17242439],"length":1,"stats":{"Line":0}},{"line":209,"address":[23072031,23174473,23071485,23174630,23069486],"length":1,"stats":{"Line":0}},{"line":215,"address":[23106437,23106308,23099075,23098224],"length":1,"stats":{"Line":0}},{"line":216,"address":[11704875],"length":1,"stats":{"Line":0}},{"line":219,"address":[23008256],"length":1,"stats":{"Line":1}},{"line":224,"address":[23111397],"length":1,"stats":{"Line":1}},{"line":226,"address":[23108538,23206185,23107996,23107736,23206342],"length":1,"stats":{"Line":3}},{"line":227,"address":[11072913],"length":1,"stats":{"Line":2}},{"line":228,"address":[11754744],"length":1,"stats":{"Line":2}},{"line":229,"address":[23014925,23100793,23100950,23015571,23015029],"length":1,"stats":{"Line":3}},{"line":230,"address":[23008742],"length":1,"stats":{"Line":1}},{"line":233,"address":[22995063,23094694,22996999,23094537,22997541],"length":1,"stats":{"Line":0}},{"line":234,"address":[23113181,23115784,23128200,23116896],"length":1,"stats":{"Line":0}},{"line":235,"address":[11716678],"length":1,"stats":{"Line":0}},{"line":236,"address":[18123799,18123182,18123282,18348927,18348793],"length":1,"stats":{"Line":0}},{"line":237,"address":[23224395],"length":1,"stats":{"Line":0}},{"line":239,"address":[23076622],"length":1,"stats":{"Line":0}},{"line":240,"address":[23005490,23006056,23102377,23001898,23102534],"length":1,"stats":{"Line":0}},{"line":241,"address":[11855181],"length":1,"stats":{"Line":0}},{"line":242,"address":[18125320,18349785,18125816,18349919,18125220],"length":1,"stats":{"Line":0}},{"line":246,"address":[23087998],"length":1,"stats":{"Line":0}},{"line":249,"address":[18113817,18113297,18350281,18107977,18350415],"length":1,"stats":{"Line":3}},{"line":250,"address":[11754836],"length":1,"stats":{"Line":2}},{"line":251,"address":[11648939],"length":1,"stats":{"Line":2}},{"line":252,"address":[23097022],"length":1,"stats":{"Line":1}},{"line":255,"address":[18350911,18108008,18114983,18115493,18350777],"length":1,"stats":{"Line":3}},{"line":256,"address":[23172454,23077408,23078520,23079041,23172297],"length":1,"stats":{"Line":5}},{"line":260,"address":[23117129],"length":1,"stats":{"Line":2}},{"line":263,"address":[23098233,22995207,23005590,23006132,23098390],"length":1,"stats":{"Line":3}},{"line":264,"address":[11655938],"length":1,"stats":{"Line":4}},{"line":265,"address":[11754905],"length":1,"stats":{"Line":4}},{"line":266,"address":[23098056,23180438,23097952,23180281,23098598],"length":1,"stats":{"Line":6}},{"line":267,"address":[23129737],"length":1,"stats":{"Line":2}},{"line":273,"address":[18130679,18130384,18130392,18131083,18130435,18130513,18130400,18130550],"length":1,"stats":{"Line":4}},{"line":274,"address":[18130540,18130607,18130711,18130501],"length":1,"stats":{"Line":2}},{"line":279,"address":[23018112],"length":1,"stats":{"Line":0}},{"line":280,"address":[23092712],"length":1,"stats":{"Line":0}},{"line":286,"address":[23106409,23110690,23106039,23113054,23106112,23106450,23106297,23108622,23112561,23113173,23106700,23106159],"length":1,"stats":{"Line":5}},{"line":291,"address":[18353413,18353333,18371897,18372031,18353934],"length":1,"stats":{"Line":3}},{"line":295,"address":[23100465,23101691],"length":1,"stats":{"Line":2}},{"line":297,"address":[11328405],"length":1,"stats":{"Line":1}},{"line":299,"address":[23102213,23102763,23102111,23119686,23119529],"length":1,"stats":{"Line":3}},{"line":300,"address":[23220998,23222130],"length":1,"stats":{"Line":2}},{"line":301,"address":[23185382],"length":1,"stats":{"Line":1}},{"line":303,"address":[18355523],"length":1,"stats":{"Line":0}},{"line":304,"address":[23221171,23218815,23236854,23220621,23236697],"length":1,"stats":{"Line":0}},{"line":305,"address":[18357808,18358946],"length":1,"stats":{"Line":0}},{"line":307,"address":[11903276],"length":1,"stats":{"Line":0}},{"line":308,"address":[23187545,23187612],"length":1,"stats":{"Line":0}},{"line":310,"address":[23112974],"length":1,"stats":{"Line":0}},{"line":315,"address":[23224819,23225030,23225249,23225007,23224784,23224918,23224745,23225674],"length":1,"stats":{"Line":0}},{"line":316,"address":[19595492],"length":1,"stats":{"Line":0}},{"line":317,"address":[18360463,18360528],"length":1,"stats":{"Line":0}},{"line":320,"address":[23182268,23182080,23182111,23184414,23182015,23182474,23182311],"length":1,"stats":{"Line":4}},{"line":321,"address":[11838241],"length":1,"stats":{"Line":2}},{"line":322,"address":[23225406,23237225,23237382,23224793,23224872],"length":1,"stats":{"Line":3}},{"line":323,"address":[23227017,23228029],"length":1,"stats":{"Line":2}},{"line":326,"address":[18363379,18363270,18363618,18363171,18363097,18364053,18363403,18363136],"length":1,"stats":{"Line":5}},{"line":327,"address":[23222865,23223087,23223238],"length":1,"stats":{"Line":1}},{"line":328,"address":[23124536,23124615],"length":1,"stats":{"Line":2}},{"line":331,"address":[23324063,23324171,23324437,23324474,23330307,23324112,23324309,23325462,23324732],"length":1,"stats":{"Line":5}},{"line":332,"address":[23228155,23228332,23227907],"length":1,"stats":{"Line":1}},{"line":333,"address":[17366345,17366238],"length":1,"stats":{"Line":2}},{"line":334,"address":[23186652],"length":1,"stats":{"Line":1}},{"line":335,"address":[23230363],"length":1,"stats":{"Line":1}},{"line":337,"address":[23186875,23186747,23191310,23191493,23191425],"length":1,"stats":{"Line":3}},{"line":338,"address":[23334342,23330069,23330319,23330870,23334185],"length":1,"stats":{"Line":0}},{"line":339,"address":[11837666],"length":1,"stats":{"Line":0}},{"line":340,"address":[23327572],"length":1,"stats":{"Line":0}},{"line":341,"address":[23334870,23326424,23325777,23325875,23334713],"length":1,"stats":{"Line":0}},{"line":342,"address":[23227135],"length":1,"stats":{"Line":0}},{"line":343,"address":[23121238,23121286],"length":1,"stats":{"Line":0}},{"line":345,"address":[23231021],"length":1,"stats":{"Line":0}},{"line":346,"address":[23233433,23231053,23240457,23240614,23232884],"length":1,"stats":{"Line":0}},{"line":347,"address":[23234598,23233381],"length":1,"stats":{"Line":0}},{"line":348,"address":[23116333],"length":1,"stats":{"Line":0}},{"line":353,"address":[23130788],"length":1,"stats":{"Line":1}},{"line":355,"address":[23130886],"length":1,"stats":{"Line":1}}],"covered":84,"coverable":166},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","metrics.rs"],"content":"use crate::domain::p2p::distribution::{DistributionMetrics, DistributionStrategy};\nuse crate::infrastructure::p2p::metrics;\n\npub struct P2PDistributionMetrics;\n\nimpl DistributionMetrics for P2PDistributionMetrics {\n    fn record_success(&self, strategy: &DistributionStrategy) {\n        match strategy {\n            DistributionStrategy::Nostr => metrics::record_broadcast_success(),\n            DistributionStrategy::P2P\n            | DistributionStrategy::Broadcast\n            | DistributionStrategy::Gossip\n            | DistributionStrategy::Direct(_)\n            | DistributionStrategy::Hybrid => metrics::record_broadcast_success(),\n        }\n    }\n\n    fn record_failure(&self, strategy: &DistributionStrategy) {\n        match strategy {\n            DistributionStrategy::Nostr => metrics::record_broadcast_failure(),\n            DistributionStrategy::P2P\n            | DistributionStrategy::Broadcast\n            | DistributionStrategy::Gossip\n            | DistributionStrategy::Direct(_)\n            | DistributionStrategy::Hybrid => metrics::record_broadcast_failure(),\n        }\n    }\n}\n","traces":[{"line":7,"address":[20793888],"length":1,"stats":{"Line":1}},{"line":8,"address":[20719166],"length":1,"stats":{"Line":1}},{"line":9,"address":[20726210],"length":1,"stats":{"Line":1}},{"line":10,"address":[20787034],"length":1,"stats":{"Line":1}},{"line":18,"address":[15209840],"length":1,"stats":{"Line":0}},{"line":19,"address":[20712478],"length":1,"stats":{"Line":0}},{"line":20,"address":[20787138],"length":1,"stats":{"Line":0}},{"line":21,"address":[20925610],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","mod.rs"],"content":"use async_trait::async_trait;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\n\nmod default;\nmod metrics;\nmod state;\nmod strategy;\n\npub use default::DefaultEventDistributor;\npub use metrics::P2PDistributionMetrics;\npub use strategy::{NostrEventDistributor, P2PEventDistributor};\n\npub type DynError = Box<dyn std::error::Error + Send + Sync>;\n\n#[async_trait]\npub trait EventDistributor: Send + Sync {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), DynError>;\n    async fn receive(&self) -> Result<Option<Event>, DynError>;\n    async fn set_strategy(&self, strategy: DistributionStrategy);\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError>;\n    async fn retry_failed(&self) -> Result<u32, DynError>;\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","state.rs"],"content":"use std::collections::VecDeque;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\n\npub(crate) struct DistributorState {\n    strategy: DistributionStrategy,\n    pending_events: VecDeque<Event>,\n    failed_events: Vec<(Event, DistributionStrategy)>,\n}\n\nimpl DistributorState {\n    pub(crate) fn new(strategy: DistributionStrategy) -> Self {\n        Self {\n            strategy,\n            pending_events: VecDeque::new(),\n            failed_events: Vec::new(),\n        }\n    }\n\n    #[cfg(test)]\n    pub(crate) fn strategy(&self) -> DistributionStrategy {\n        self.strategy.clone()\n    }\n\n    pub(crate) fn set_strategy(&mut self, strategy: DistributionStrategy) {\n        self.strategy = strategy;\n    }\n\n    pub(crate) fn pop_pending(&mut self) -> Option<Event> {\n        self.pending_events.pop_front()\n    }\n\n    pub(crate) fn pending_events_snapshot(&self) -> Vec<Event> {\n        self.pending_events.iter().cloned().collect()\n    }\n\n    pub(crate) fn record_failure(&mut self, event: Event, strategy: DistributionStrategy) {\n        self.failed_events.push((event, strategy));\n    }\n\n    pub(crate) fn drain_failures(&mut self) -> Vec<(Event, DistributionStrategy)> {\n        std::mem::take(&mut self.failed_events)\n    }\n\n    pub(crate) fn restore_failures(&mut self, still_failed: Vec<(Event, DistributionStrategy)>) {\n        self.failed_events = still_failed;\n    }\n}\n","traces":[{"line":13,"address":[19745632,19745864],"length":1,"stats":{"Line":3}},{"line":16,"address":[19944974],"length":1,"stats":{"Line":3}},{"line":17,"address":[19850241],"length":1,"stats":{"Line":3}},{"line":22,"address":[16450560],"length":1,"stats":{"Line":1}},{"line":23,"address":[16450577],"length":1,"stats":{"Line":1}},{"line":26,"address":[19738912,19738969],"length":1,"stats":{"Line":1}},{"line":27,"address":[19732220,19732146],"length":1,"stats":{"Line":2}},{"line":30,"address":[19844960],"length":1,"stats":{"Line":0}},{"line":31,"address":[19806865],"length":1,"stats":{"Line":0}},{"line":34,"address":[13986608],"length":1,"stats":{"Line":1}},{"line":35,"address":[19845026],"length":1,"stats":{"Line":1}},{"line":38,"address":[16450848],"length":1,"stats":{"Line":0}},{"line":39,"address":[19806995],"length":1,"stats":{"Line":0}},{"line":42,"address":[16450960],"length":1,"stats":{"Line":1}},{"line":43,"address":[19732529],"length":1,"stats":{"Line":1}},{"line":46,"address":[19814080,19814137],"length":1,"stats":{"Line":1}},{"line":47,"address":[19845282,19845356],"length":1,"stats":{"Line":2}}],"covered":13,"coverable":17},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","strategy.rs"],"content":"use std::sync::Arc;\n\nuse async_trait::async_trait;\n\nuse crate::domain::entities::Event;\nuse crate::domain::p2p::distribution::DistributionStrategy;\nuse crate::infrastructure::p2p::{GossipService, NetworkService};\n\nuse super::default::DefaultEventDistributor;\nuse super::{DynError, EventDistributor};\n\n/// P2P 配信専用のディストリビューター。\npub struct P2PEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl P2PEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::P2P),\n        }\n    }\n\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        self.distributor.set_gossip_service(gossip).await;\n    }\n\n    pub async fn set_network_service(&self, network: Arc<dyn NetworkService>) {\n        self.distributor.set_network_service(network).await;\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        self.distributor.set_default_topics(topics).await;\n    }\n}\n\nimpl Default for P2PEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for P2PEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        self.distributor\n            .distribute(event, DistributionStrategy::P2P)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // 固定戦略のため何もしない\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        self.distributor.retry_failed().await\n    }\n}\n\n/// Nostr 配信専用のディストリビューター。\npub struct NostrEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl NostrEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::Nostr),\n        }\n    }\n\n    pub async fn set_default_topics(&self, topics: Vec<String>) {\n        self.distributor.set_default_topics(topics).await;\n    }\n}\n\nimpl Default for NostrEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for NostrEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy,\n    ) -> Result<(), DynError> {\n        self.distributor\n            .distribute(event, DistributionStrategy::Nostr)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, DynError> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // 固定戦略のため何もしない\n    }\n\n    async fn get_pending_events(&self) -> Result<Vec<Event>, DynError> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, DynError> {\n        self.distributor.retry_failed().await\n    }\n}\n","traces":[{"line":18,"address":[21043280],"length":1,"stats":{"Line":1}},{"line":20,"address":[16825613],"length":1,"stats":{"Line":1}},{"line":24,"address":[16839787,16839458,16839488,16839440,16839667,16840005,16839630,16839513],"length":1,"stats":{"Line":4}},{"line":25,"address":[16839819,16839714,16839611,16839657],"length":1,"stats":{"Line":2}},{"line":28,"address":[17039401,17039893,17039328,17039346,17039555,17039675,17039376,17039518],"length":1,"stats":{"Line":0}},{"line":29,"address":[16833419,16833257,16833211,16833314],"length":1,"stats":{"Line":0}},{"line":32,"address":[16833962,16833842,16833805,16833664,16833689,16834180,16833616,16833624],"length":1,"stats":{"Line":0}},{"line":33,"address":[21044658,21044762,21044692,21044846],"length":1,"stats":{"Line":0}},{"line":38,"address":[17040480],"length":1,"stats":{"Line":0}},{"line":39,"address":[16944056],"length":1,"stats":{"Line":0}},{"line":45,"address":[16974530,16974048,16974170,16974654,16973982,16974083,16974252,16974287,16974896],"length":1,"stats":{"Line":4}},{"line":50,"address":[16906856,16906741,16907014],"length":1,"stats":{"Line":3}},{"line":51,"address":[16892954],"length":1,"stats":{"Line":1}},{"line":52,"address":[11902158],"length":1,"stats":{"Line":3}},{"line":55,"address":[16975142,16975043,16975454,16975231,16975714,16974969,16975254,16975008],"length":1,"stats":{"Line":0}},{"line":56,"address":[16900433,16900750,16900618],"length":1,"stats":{"Line":0}},{"line":59,"address":[16968809,16968864,16968878],"length":1,"stats":{"Line":0}},{"line":63,"address":[16976083,16976009,16976325,16976821,16976537,16976048,16976297,16976182],"length":1,"stats":{"Line":0}},{"line":64,"address":[16901701,16901833,16901473],"length":1,"stats":{"Line":0}},{"line":67,"address":[16977086,16976931,16977000,16976857,16977321,16976896,16977536,16977114],"length":1,"stats":{"Line":0}},{"line":68,"address":[21180473,21180163,21180354],"length":1,"stats":{"Line":0}},{"line":78,"address":[16945728],"length":1,"stats":{"Line":1}},{"line":80,"address":[16945741],"length":1,"stats":{"Line":1}},{"line":84,"address":[16940224,16940788,16940232,16940272,16940297,16940413,16940450,16940570],"length":1,"stats":{"Line":0}},{"line":85,"address":[16902328,16902490,16902277,16902385],"length":1,"stats":{"Line":0}},{"line":90,"address":[16841856],"length":1,"stats":{"Line":0}},{"line":91,"address":[16834888],"length":1,"stats":{"Line":0}},{"line":97,"address":[21180874,21180787,21180686,21180956,21181222,21181334,21180983,21181564,21180752],"length":1,"stats":{"Line":4}},{"line":102,"address":[16978200,16978085,16978358],"length":1,"stats":{"Line":3}},{"line":103,"address":[16978058],"length":1,"stats":{"Line":1}},{"line":104,"address":[16896649,16896750,16896880,16896261,16896693],"length":1,"stats":{"Line":3}},{"line":107,"address":[11151376,11152082,11151337,11151510,11151622,11151599,11151822,11151411],"length":1,"stats":{"Line":0}},{"line":108,"address":[11899300],"length":1,"stats":{"Line":0}},{"line":111,"address":[16979321,16979376,16979390],"length":1,"stats":{"Line":0}},{"line":115,"address":[16904896,16905173,16905030,16905145,16905669,16905385,16904857,16904931],"length":1,"stats":{"Line":0}},{"line":116,"address":[11955940],"length":1,"stats":{"Line":0}},{"line":119,"address":[17015561,17015600,17015704,17015635,17016025,17015818,17016240,17015790],"length":1,"stats":{"Line":0}},{"line":120,"address":[17011990,17011795,17012121],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor","tests.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse tokio::sync::{Mutex, mpsc};\n\nuse crate::domain::entities::{Event, EventKind};\nuse crate::domain::p2p::distribution::DistributionStrategy;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\n\nuse super::EventDistributor;\nuse super::default::DefaultEventDistributor;\nuse super::strategy::{NostrEventDistributor, P2PEventDistributor};\n\n#[derive(Clone, Default)]\nstruct DummyGossipService {\n    broadcasts: Arc<Mutex<Vec<(String, String)>>>,\n    joined: Arc<Mutex<HashSet<String>>>,\n}\n\nimpl DummyGossipService {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    async fn broadcast_count(&self) -> usize {\n        let guard = self.broadcasts.lock().await;\n        guard.len()\n    }\n}\n\n#[async_trait]\nimpl GossipService for DummyGossipService {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        let mut guard = self.joined.lock().await;\n        guard.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        let mut guard = self.joined.lock().await;\n        guard.remove(topic);\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        let mut guard = self.broadcasts.lock().await;\n        guard.push((topic.to_string(), event.id.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(&self, _topic: &str) -> Result<mpsc::Receiver<Event>, AppError> {\n        let (_tx, rx) = mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        let guard = self.joined.lock().await;\n        Ok(guard.iter().cloned().collect())\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(Vec::new())\n    }\n\n    async fn get_topic_stats(\n        &self,\n        topic: &str,\n    ) -> Result<Option<crate::domain::p2p::TopicStats>, AppError> {\n        let guard = self.joined.lock().await;\n        if guard.contains(topic) {\n            Ok(Some(crate::domain::p2p::TopicStats {\n                peer_count: 0,\n                message_count: 0,\n                last_activity: 0,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    async fn broadcast_message(&self, topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        let mut guard = self.broadcasts.lock().await;\n        guard.push((topic.to_string(), \"<raw>\".into()));\n        Ok(())\n    }\n}\n\nfn create_test_event() -> Event {\n    Event {\n        id: \"test_event_123\".to_string(),\n        pubkey: \"test_pubkey\".to_string(),\n        created_at: chrono::Utc::now(),\n        kind: EventKind::TextNote.into(),\n        tags: vec![],\n        content: \"Test event content\".to_string(),\n        sig: \"test_signature\".to_string(),\n    }\n}\n\n#[tokio::test]\nasync fn test_default_distributor_creation() {\n    let distributor = DefaultEventDistributor::new();\n    let strategy = distributor.current_strategy().await;\n    assert!(matches!(strategy, DistributionStrategy::Hybrid));\n}\n\n#[tokio::test]\nasync fn test_set_strategy() {\n    let distributor = DefaultEventDistributor::new();\n    distributor.set_strategy(DistributionStrategy::P2P).await;\n\n    let strategy = distributor.current_strategy().await;\n    assert!(matches!(strategy, DistributionStrategy::P2P));\n}\n\n#[tokio::test]\nasync fn test_distribute_event() {\n    let distributor = DefaultEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Broadcast)\n        .await;\n    assert!(result.is_ok());\n\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_hybrid_distribution() {\n    let distributor = DefaultEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Hybrid)\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_get_pending_events_empty() {\n    let distributor = DefaultEventDistributor::new();\n    let events = distributor.get_pending_events().await.unwrap();\n    assert_eq!(events.len(), 0);\n}\n\n#[tokio::test]\nasync fn test_p2p_distributor() {\n    let distributor = P2PEventDistributor::new();\n    let gossip = DummyGossipService::new();\n    distributor\n        .set_gossip_service(Arc::new(gossip.clone()))\n        .await;\n\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::Broadcast)\n        .await;\n    assert!(result.is_ok());\n    assert_eq!(gossip.broadcast_count().await, 1);\n}\n\n#[tokio::test]\nasync fn test_nostr_distributor() {\n    let distributor = NostrEventDistributor::new();\n    let event = create_test_event();\n\n    let result = distributor\n        .distribute(&event, DistributionStrategy::P2P)\n        .await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_retry_failed_with_no_failures() {\n    let distributor = DefaultEventDistributor::new();\n    let retry_count = distributor.retry_failed().await.unwrap();\n    assert_eq!(retry_count, 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","gossip_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::p2p::TopicStats;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait GossipService: Send + Sync {\n    fn local_peer_hint(&self) -> Option<String> {\n        None\n    }\n\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError>;\r\n    async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError>;\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n}\n","traces":[{"line":8,"address":[13321248],"length":1,"stats":{"Line":0}},{"line":9,"address":[13321256],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_gossip_service.rs"],"content":"use super::GossipService;\r\nuse crate::domain::entities::Event;\r\nuse crate::infrastructure::p2p::utils::{ParsedPeer, parse_peer_hint};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\nuse futures::StreamExt;\r\nuse iroh::{discovery::static_provider::StaticProvider, protocol::Router};\r\nuse iroh_gossip::{\r\n    ALPN as GOSSIP_ALPN,\r\n    api::{Event as GossipApiEvent, GossipSender, GossipTopic},\r\n    net::Gossip,\r\n    proto::TopicId,\r\n};\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse std::time::Duration;\r\nuse tokio::sync::{Mutex as TokioMutex, RwLock, broadcast, mpsc};\r\nuse tokio::time::timeout;\r\n\r\nuse crate::domain::p2p::events::P2PEvent;\r\nuse crate::domain::p2p::message::{GossipMessage, MessageType};\r\nuse crate::domain::p2p::{TopicMesh, TopicStats, generate_topic_id, topic_id_bytes};\n\r\nconst LOG_TARGET: &str = \"kukuri::p2p::gossip\";\r\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\r\n\r\npub struct IrohGossipService {\r\n    endpoint: Arc<iroh::Endpoint>,\r\n    static_discovery: Arc<StaticProvider>,\r\n    gossip: Arc<Gossip>,\r\n    _router: Arc<Router>,\r\n    topics: Arc<RwLock<HashMap<String, TopicHandle>>>,\r\n    event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n}\r\n\r\nstruct TopicHandle {\r\n    sender: Arc<TokioMutex<GossipSender>>, // GossipSenderでbroadcast可能\r\n    receiver_task: tokio::task::JoinHandle<()>,\r\n    mesh: Arc<TopicMesh>,\r\n}\r\n\r\nimpl IrohGossipService {\r\n    pub fn new(\r\n        endpoint: Arc<iroh::Endpoint>,\r\n        static_discovery: Arc<StaticProvider>,\r\n    ) -> Result<Self, AppError> {\r\n        // Gossipインスタンスの作成\r\n        let gossip = Gossip::builder().spawn((*endpoint).clone());\r\n\r\n        // Routerの作成とGossipプロトコルの登録\r\n        let router = Router::builder((*endpoint).clone())\r\n            .accept(GOSSIP_ALPN, gossip.clone())\r\n            .spawn();\r\n\r\n        Ok(Self {\r\n            endpoint,\r\n            static_discovery,\r\n            gossip: Arc::new(gossip),\r\n            _router: Arc::new(router),\r\n            topics: Arc::new(RwLock::new(HashMap::new())),\r\n            event_tx: None,\r\n        })\r\n    }\r\n\r\n    pub fn set_event_sender(&mut self, tx: broadcast::Sender<P2PEvent>) {\r\n        self.event_tx = Some(tx);\r\n    }\r\n\r\n    pub fn local_peer_hint(&self) -> Option<String> {\r\n        let node_addr = self.endpoint.addr();\r\n        let node_id = node_addr.id.to_string();\r\n        node_addr\r\n            .ip_addrs()\r\n            .next()\r\n            .map(|addr| format!(\"{node_id}@{addr}\"))\r\n    }\r\n\r\n    fn create_topic_id(topic: &str) -> TopicId {\r\n        let bytes = topic_id_bytes(topic);\r\n        TopicId::from_bytes(bytes)\r\n    }\r\n\r\n    async fn apply_initial_peers(\r\n        &self,\r\n        topic: &str,\r\n        parsed_peers: &[ParsedPeer],\r\n    ) -> Result<(), AppError> {\r\n        if parsed_peers.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] applying {} initial peers to existing topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        for peer in parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] re-applying node addr {} for topic {}\",\r\n                    addr.id, topic\r\n                );\r\n                self.static_discovery.add_endpoint_info(addr.clone());\r\n            }\r\n        }\r\n\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        if peer_ids.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        let topics = self.topics.read().await;\r\n        if let Some(handle) = topics.get(topic) {\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n            if let Err(e) = sender.lock().await.join_peers(peer_ids).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            }\r\n        } else {\r\n            tracing::debug!(\"Topic {} not found when applying initial peers\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl GossipService for IrohGossipService {\r\n    fn local_peer_hint(&self) -> Option<String> {\r\n        IrohGossipService::local_peer_hint(self)\r\n    }\r\n\r\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\r\n        eprintln!(\r\n            \"[iroh_gossip_service] join_topic start: {} (initial peers: {:?})\",\r\n            topic, initial_peers\r\n        );\r\n        let parsed_peers: Vec<ParsedPeer> = initial_peers\r\n            .into_iter()\r\n            .filter_map(|entry| match parse_peer_hint(&entry) {\r\n                Ok(parsed) => Some(parsed),\r\n                Err(e) => {\r\n                    tracing::warn!(\"Failed to parse initial peer '{}': {:?}\", entry, e);\r\n                    None\r\n                }\r\n            })\r\n            .collect();\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] parsed {} peers for topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        {\r\n            let topics = self.topics.read().await;\r\n            if topics.contains_key(topic) {\r\n                drop(topics);\r\n                self.apply_initial_peers(topic, &parsed_peers).await?;\r\n                return Ok(());\r\n            }\r\n            drop(topics);\r\n        }\r\n\r\n        for peer in &parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                self.static_discovery.add_endpoint_info(addr.clone());\r\n            }\r\n        }\r\n\r\n        let canonical_topic = generate_topic_id(topic);\r\n        let topic_id = Self::create_topic_id(&canonical_topic);\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        eprintln!(\r\n            \"[iroh_gossip_service] subscribing topic {} (canonical {}) with {} peer hints\",\r\n            topic,\r\n            canonical_topic,\r\n            peer_ids.len()\r\n        );\r\n\r\n        let gossip_topic: GossipTopic = self\r\n            .gossip\r\n            .subscribe(topic_id, peer_ids.clone())\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to subscribe to topic: {e:?}\")))?;\r\n\r\n        let (sender_handle, mut receiver) = gossip_topic.split();\r\n\r\n        if !peer_ids.is_empty() {\r\n            if let Err(e) = sender_handle.join_peers(peer_ids.clone()).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            } else {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] join_peers issued for topic {} ({} peers)\",\r\n                    topic,\r\n                    peer_ids.len()\r\n                );\r\n            }\r\n        }\r\n\r\n        let wait_duration = Duration::from_secs(12);\r\n        match timeout(wait_duration, receiver.joined()).await {\r\n            Ok(Ok(peer)) => {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] first neighbor joined for topic {topic} ({peer:?})\"\r\n                );\r\n            }\r\n            Ok(Err(e)) => {\r\n                tracing::debug!(\"Waiting for neighbor on {} returned error: {:?}\", topic, e);\r\n            }\r\n            Err(_) => {\r\n                tracing::warn!(\r\n                    \"Timed out ({:?}) waiting for neighbor on {}\",\r\n                    wait_duration,\r\n                    topic\r\n                );\r\n            }\r\n        }\r\n\r\n        let sender = Arc::new(TokioMutex::new(sender_handle));\r\n        let mesh = Arc::new(TopicMesh::new(topic.to_string()));\r\n\r\n        // 受信タスクを起動（UI配信用にサブスクライバへ配布 & 任意でP2PEventを送出）\r\n        let topic_clone = topic.to_string();\r\n        let event_tx_clone = self.event_tx.clone();\r\n        let mesh_for_task = mesh.clone();\r\n        let receiver_task = tokio::spawn(async move {\r\n            while let Some(event) = receiver.next().await {\r\n                match event {\r\n                    Ok(GossipApiEvent::Received(msg)) => {\r\n                        let decoded_message = match GossipMessage::from_bytes(&msg.content) {\r\n                            Ok(message) => Some(message),\r\n                            Err(e) => {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload into GossipMessage\"\r\n                                );\r\n                                None\r\n                            }\r\n                        };\r\n\r\n                        if let Some(message) = decoded_message.as_ref() {\r\n                            if let Err(e) = mesh_for_task.handle_message(message.clone()).await {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to record gossip message in TopicMesh\"\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if let (Some(tx), Some(message)) =\r\n                            (event_tx_clone.as_ref(), decoded_message.clone())\r\n                        {\r\n                            let _ = tx.send(P2PEvent::MessageReceived {\r\n                                topic_id: topic_clone.clone(),\r\n                                message,\r\n                                _from_peer: msg.delivered_from.as_bytes().to_vec(),\r\n                            });\r\n                        }\r\n\r\n                        let event_result = if let Some(message) = decoded_message\r\n                            .as_ref()\r\n                            .filter(|m| matches!(m.msg_type, MessageType::NostrEvent))\r\n                        {\r\n                            serde_json::from_slice::<Event>(&message.payload)\r\n                        } else {\r\n                            // 後方互換のため、生バイト列をそのまま JSON として扱う\r\n                            serde_json::from_slice::<Event>(&msg.content)\r\n                        };\r\n\r\n                        match event_result {\r\n                            Ok(domain_event) => {\r\n                                match domain_event\r\n                                    .validate_nip01()\r\n                                    .and_then(|_| domain_event.validate_nip10_19())\r\n                                {\r\n                                    Ok(_) => {\r\n                                        super::metrics::record_receive_success();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::trace!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive\",\r\n                                            topic = %topic_clone,\r\n                                            received = snap.messages_received,\r\n                                            receive_failures = snap.receive_details.failures,\r\n                                            \"Validated gossip payload\"\r\n                                        );\r\n                                    }\r\n                                    Err(e) => {\r\n                                        super::metrics::record_receive_failure();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::warn!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive_failure\",\r\n                                            topic = %topic_clone,\r\n                                            failures = snap.receive_details.failures,\r\n                                            error = %e,\r\n                                            \"Dropped invalid Nostr event after validation\"\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                            Err(e) => {\r\n                                super::metrics::record_receive_failure();\r\n                                let snap = super::metrics::snapshot();\r\n                                tracing::warn!(\r\n                                    target: METRICS_TARGET,\r\n                                    action = \"receive_failure\",\r\n                                    topic = %topic_clone,\r\n                                    failures = snap.receive_details.failures,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload as Nostr event\"\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborUp(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.send(P2PEvent::PeerJoined {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor up on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, true).await;\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborDown(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.send(P2PEvent::PeerLeft {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor down on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, false).await;\r\n                    }\r\n                    Ok(GossipApiEvent::Lagged) => {\r\n                        tracing::warn!(\"Receiver lagged on topic {}\", topic_clone);\r\n                    }\r\n                    Err(e) => {\r\n                        tracing::error!(\"Gossip receiver error on {}: {:?}\", topic_clone, e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let handle = TopicHandle {\r\n            sender,\r\n            receiver_task,\r\n            mesh,\r\n        };\r\n\r\n        let mut topics = self.topics.write().await;\r\n        topics.insert(topic.to_string(), handle);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        let mut topics = self.topics.write().await;\r\n\r\n        if let Some(handle) = topics.remove(topic) {\r\n            // レシーバータスクをキャンセルし、Senderをドロップ\r\n            handle.receiver_task.abort();\r\n            drop(handle.sender);\r\n\r\n            tracing::info!(\"Left gossip topic: {}\", topic);\r\n        } else {\r\n            tracing::debug!(\"Topic not found: {}\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(handle) = topics.get(topic) {\r\n            // イベントをシリアライズ\r\n            let payload = serde_json::to_vec(event)?;\r\n            let sender_id = self.endpoint.addr().id.to_string().into_bytes();\r\n            let gossip_message = GossipMessage::new(MessageType::NostrEvent, payload, sender_id);\r\n            let message_bytes = gossip_message.to_bytes().map_err(|e| {\r\n                AppError::P2PError(format!(\"Failed to serialize gossip message: {e}\"))\r\n            })?;\r\n\r\n            // Senderを取得してブロードキャスト\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n\r\n            let guard = sender.lock().await;\r\n            guard\r\n                .broadcast(message_bytes.into())\r\n                .await\r\n                .map_err(|e| AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))?;\r\n\r\n            tracing::debug!(\"Broadcasted event to topic {}\", topic);\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn subscribe(&self, topic: &str) -> Result<mpsc::Receiver<Event>, AppError> {\r\n        // トピックに参加していることを確認\r\n        self.join_topic(topic, vec![]).await?;\r\n\r\n        let mesh = {\r\n            let topics = self.topics.read().await;\r\n            topics.get(topic).map(|handle| handle.mesh.clone())\r\n        };\r\n\r\n        if let Some(mesh) = mesh {\r\n            let topic_name = topic.to_string();\r\n            let subscription = mesh.subscribe().await;\r\n            let subscription_id = subscription.id;\r\n            let mut message_rx = subscription.receiver;\r\n            let mesh_clone = mesh.clone();\r\n            let (tx, rx) = mpsc::channel(100);\r\n\r\n            tokio::spawn(async move {\r\n                while let Some(message) = message_rx.recv().await {\r\n                    if !matches!(message.msg_type, MessageType::NostrEvent) {\r\n                        continue;\r\n                    }\r\n\r\n                    match serde_json::from_slice::<Event>(&message.payload) {\r\n                        Ok(domain_event) => {\r\n                            match domain_event\r\n                                .validate_nip01()\r\n                                .and_then(|_| domain_event.validate_nip10_19())\r\n                            {\r\n                                Ok(_) => {\r\n                                    if tx.send(domain_event.clone()).await.is_err() {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                Err(e) => {\r\n                                    tracing::debug!(\r\n                                        target: LOG_TARGET,\r\n                                        topic = %topic_name,\r\n                                        error = %e,\r\n                                        \"Dropped invalid domain event in subscription bridge\"\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                        Err(e) => {\r\n                            tracing::debug!(\r\n                                target: LOG_TARGET,\r\n                                topic = %topic_name,\r\n                                error = ?e,\r\n                                \"Failed to decode gossip payload into Event for subscription\"\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                mesh_clone.unsubscribe(subscription_id).await;\r\n            });\r\n\r\n            Ok(rx)\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n        Ok(topics.keys().cloned().collect())\r\n    }\r\n\r\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // iroh-gossipのAPIでピアリストを取得\r\n            // Note: iroh-gossip doesn't expose a direct way to get topic peers\r\n            // Return empty list for now\r\n            Ok(Vec::new())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError> {\r\n        let mesh = {\r\n            let topics = self.topics.read().await;\r\n            topics.get(topic).map(|handle| handle.mesh.clone())\r\n        };\r\n\r\n        if let Some(mesh) = mesh {\r\n            Ok(Some(mesh.get_stats().await))\r\n        } else {\r\n            Ok(None)\r\n        }\r\n    }\r\n\r\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // メッセージをブロードキャスト\r\n            // Simplified - actual implementation needs proper API\r\n            tracing::debug!(\r\n                \"Broadcasting raw message to topic {}: {} bytes\",\r\n                topic,\r\n                message.len()\r\n            );\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::domain::entities::Event;\r\n    use iroh::Endpoint;\r\n\r\n    fn should_run_p2p_tests(test_name: &str) -> bool {\r\n        if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\r\n            eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\r\n            false\r\n        } else {\r\n            true\r\n        }\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_broadcast_without_peers() {\r\n        if !should_run_p2p_tests(\"test_join_and_broadcast_without_peers\") {\r\n            return;\r\n        }\r\n        // エンドポイント作成（ローカル、ディスカバリ無し）\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Arc::new(\r\n            Endpoint::builder()\r\n                .discovery(static_discovery.clone())\r\n                .bind()\r\n                .await\r\n                .unwrap(),\r\n        );\r\n        let service = IrohGossipService::new(endpoint, static_discovery).unwrap();\r\n\r\n        // トピック参加\r\n        let topic = \"test-topic-ig\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n\r\n        // ダミーイベントでブロードキャスト（ピア不在でもエラーにならない）\r\n        let event = Event::new(1, \"hello igossip\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(topic, &event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_leave_topic() {\r\n        if !should_run_p2p_tests(\"test_join_and_leave_topic\") {\r\n            return;\r\n        }\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let endpoint = Arc::new(\r\n            Endpoint::builder()\r\n                .discovery(static_discovery.clone())\r\n                .bind()\r\n                .await\r\n                .unwrap(),\r\n        );\r\n        let service = IrohGossipService::new(endpoint, static_discovery).unwrap();\r\n\r\n        let topic = \"test-topic-leave\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n        let result = service.leave_topic(topic).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[20829200,20830292,20830444],"length":1,"stats":{"Line":0}},{"line":48,"address":[20826461,20825291,20825412],"length":1,"stats":{"Line":0}},{"line":51,"address":[20829498,20829573,20829733,20829678],"length":1,"stats":{"Line":0}},{"line":52,"address":[20712980,20713085,20713716],"length":1,"stats":{"Line":0}},{"line":55,"address":[20926589],"length":1,"stats":{"Line":0}},{"line":56,"address":[20719912],"length":1,"stats":{"Line":0}},{"line":57,"address":[20713149],"length":1,"stats":{"Line":0}},{"line":58,"address":[20719954,20720032],"length":1,"stats":{"Line":0}},{"line":59,"address":[20727016,20727129],"length":1,"stats":{"Line":0}},{"line":60,"address":[20830017,20830077],"length":1,"stats":{"Line":0}},{"line":61,"address":[20720289],"length":1,"stats":{"Line":0}},{"line":65,"address":[20727600,20727653],"length":1,"stats":{"Line":0}},{"line":66,"address":[19311939,19312000],"length":1,"stats":{"Line":0}},{"line":69,"address":[20788544,20788819],"length":1,"stats":{"Line":0}},{"line":70,"address":[20713990],"length":1,"stats":{"Line":0}},{"line":71,"address":[20788618],"length":1,"stats":{"Line":0}},{"line":72,"address":[19312143,19312202],"length":1,"stats":{"Line":0}},{"line":75,"address":[20728016,20728042],"length":1,"stats":{"Line":0}},{"line":78,"address":[20721232],"length":1,"stats":{"Line":0}},{"line":79,"address":[20714472],"length":1,"stats":{"Line":0}},{"line":80,"address":[20927560],"length":1,"stats":{"Line":0}},{"line":83,"address":[20789152],"length":1,"stats":{"Line":0}},{"line":88,"address":[20831496,20831656],"length":1,"stats":{"Line":0}},{"line":89,"address":[19313125],"length":1,"stats":{"Line":0}},{"line":92,"address":[20796598,20796558],"length":1,"stats":{"Line":0}},{"line":98,"address":[20928278,20928452],"length":1,"stats":{"Line":0}},{"line":99,"address":[20833692,20834224],"length":1,"stats":{"Line":0}},{"line":100,"address":[14970260],"length":1,"stats":{"Line":0}},{"line":104,"address":[14970399],"length":1,"stats":{"Line":0}},{"line":108,"address":[20721248,20715474,20721261,20715353],"length":1,"stats":{"Line":0}},{"line":109,"address":[20928706,20928624],"length":1,"stats":{"Line":0}},{"line":110,"address":[20832311],"length":1,"stats":{"Line":0}},{"line":113,"address":[11661759],"length":1,"stats":{"Line":0}},{"line":114,"address":[20797999,20798083],"length":1,"stats":{"Line":0}},{"line":115,"address":[20716658,20716744],"length":1,"stats":{"Line":0}},{"line":116,"address":[14971051],"length":1,"stats":{"Line":0}},{"line":117,"address":[11698546],"length":1,"stats":{"Line":0}},{"line":118,"address":[20726759,20726157,20764777,20764911,20726258],"length":1,"stats":{"Line":0}},{"line":121,"address":[19314954,19314685,19471641,19315489,19471798],"length":1,"stats":{"Line":0}},{"line":124,"address":[20835750],"length":1,"stats":{"Line":0}},{"line":130,"address":[20765712],"length":1,"stats":{"Line":0}},{"line":131,"address":[19472129],"length":1,"stats":{"Line":0}},{"line":134,"address":[11897783],"length":1,"stats":{"Line":0}},{"line":135,"address":[20972967,20972888],"length":1,"stats":{"Line":0}},{"line":139,"address":[20834603],"length":1,"stats":{"Line":0}},{"line":141,"address":[20773250,20773200,20773333,20775144,20773931],"length":1,"stats":{"Line":0}},{"line":142,"address":[20891666],"length":1,"stats":{"Line":0}},{"line":143,"address":[20854952],"length":1,"stats":{"Line":0}},{"line":144,"address":[20939785,20886293,20939919,20886184,20886637,20886788],"length":1,"stats":{"Line":0}},{"line":145,"address":[15028359],"length":1,"stats":{"Line":0}},{"line":150,"address":[20773990,20773903],"length":1,"stats":{"Line":0}},{"line":157,"address":[20972554,20973453,20973683,20973538],"length":1,"stats":{"Line":0}},{"line":158,"address":[20835489,20835576],"length":1,"stats":{"Line":0}},{"line":159,"address":[20877713],"length":1,"stats":{"Line":0}},{"line":160,"address":[20841023,20843873,20844395,20844106,20844494],"length":1,"stats":{"Line":0}},{"line":161,"address":[19475873],"length":1,"stats":{"Line":0}},{"line":163,"address":[20835623],"length":1,"stats":{"Line":0}},{"line":166,"address":[20842827,20842653],"length":1,"stats":{"Line":0}},{"line":167,"address":[20879619,20880531],"length":1,"stats":{"Line":0}},{"line":168,"address":[20769047],"length":1,"stats":{"Line":0}},{"line":172,"address":[20873980],"length":1,"stats":{"Line":0}},{"line":173,"address":[20775213,20775106],"length":1,"stats":{"Line":0}},{"line":174,"address":[20856688,20856701,20842980],"length":1,"stats":{"Line":0}},{"line":175,"address":[20843260],"length":1,"stats":{"Line":0}},{"line":182,"address":[20879913,20880348,20878711,20878805,20879765,20878558,20878643],"length":1,"stats":{"Line":0}},{"line":184,"address":[20874726],"length":1,"stats":{"Line":0}},{"line":185,"address":[11865761],"length":1,"stats":{"Line":0}},{"line":186,"address":[20838252,20849830,20849808],"length":1,"stats":{"Line":0}},{"line":188,"address":[20880433,20880175],"length":1,"stats":{"Line":0}},{"line":190,"address":[20838506,20838594],"length":1,"stats":{"Line":0}},{"line":191,"address":[20880766,20876185,20880648,20881103],"length":1,"stats":{"Line":0}},{"line":192,"address":[20945999,20883202,20883703,20883101,20945865],"length":1,"stats":{"Line":0}},{"line":194,"address":[20841187],"length":1,"stats":{"Line":0}},{"line":202,"address":[20977138,20979857],"length":1,"stats":{"Line":0}},{"line":203,"address":[11858883],"length":1,"stats":{"Line":0}},{"line":205,"address":[19480434,19480281],"length":1,"stats":{"Line":0}},{"line":209,"address":[20841959],"length":1,"stats":{"Line":0}},{"line":210,"address":[21041145,20980745,20980487,21041279,20981246],"length":1,"stats":{"Line":0}},{"line":213,"address":[20835353,20835487,20774089,20776114],"length":1,"stats":{"Line":0}},{"line":221,"address":[20984130,20984016],"length":1,"stats":{"Line":0}},{"line":222,"address":[20845702,20845800],"length":1,"stats":{"Line":0}},{"line":225,"address":[15025610,15025708],"length":1,"stats":{"Line":0}},{"line":226,"address":[15025823,15025723],"length":1,"stats":{"Line":0}},{"line":227,"address":[20853062,20853146],"length":1,"stats":{"Line":0}},{"line":228,"address":[20856992,20857328,20857188,20859200,20880034,20857068,20853154],"length":1,"stats":{"Line":0}},{"line":229,"address":[20850290,20850888,20850366,20850205,20850949,20850432],"length":1,"stats":{"Line":0}},{"line":230,"address":[20783432,20783493],"length":1,"stats":{"Line":0}},{"line":231,"address":[20790764],"length":1,"stats":{"Line":0}},{"line":232,"address":[20893730,20898749],"length":1,"stats":{"Line":0}},{"line":233,"address":[20795923],"length":1,"stats":{"Line":0}},{"line":234,"address":[19495065],"length":1,"stats":{"Line":0}},{"line":235,"address":[20842825,20842959,20796132,20796016,20796658],"length":1,"stats":{"Line":0}},{"line":241,"address":[20864364],"length":1,"stats":{"Line":0}},{"line":245,"address":[20782284,20784334],"length":1,"stats":{"Line":0}},{"line":246,"address":[20865915,20857397,20865996,20857239],"length":1,"stats":{"Line":0}},{"line":247,"address":[20998529,21042633,21042767,20997927,20998028],"length":1,"stats":{"Line":0}},{"line":256,"address":[20861592,20861564,20861529],"length":1,"stats":{"Line":0}},{"line":257,"address":[20868463,20865946,20868354],"length":1,"stats":{"Line":0}},{"line":259,"address":[20869002],"length":1,"stats":{"Line":0}},{"line":260,"address":[21000232],"length":1,"stats":{"Line":0}},{"line":261,"address":[20794012],"length":1,"stats":{"Line":0}},{"line":262,"address":[20900068,20900154],"length":1,"stats":{"Line":0}},{"line":266,"address":[19500551,19500639],"length":1,"stats":{"Line":0}},{"line":268,"address":[20915381,20915376],"length":1,"stats":{"Line":0}},{"line":270,"address":[20794688,20794769],"length":1,"stats":{"Line":0}},{"line":273,"address":[20869451,20869579],"length":1,"stats":{"Line":0}},{"line":276,"address":[19500813],"length":1,"stats":{"Line":0}},{"line":277,"address":[20904756],"length":1,"stats":{"Line":0}},{"line":278,"address":[20904766,20904859],"length":1,"stats":{"Line":0}},{"line":280,"address":[19511568,19511584],"length":1,"stats":{"Line":0}},{"line":283,"address":[20904929],"length":1,"stats":{"Line":0}},{"line":284,"address":[21001418],"length":1,"stats":{"Line":0}},{"line":285,"address":[19501140,19542486,19501733,19501211,19542329],"length":1,"stats":{"Line":0}},{"line":294,"address":[19501083],"length":1,"stats":{"Line":0}},{"line":295,"address":[20795116],"length":1,"stats":{"Line":0}},{"line":296,"address":[20908822],"length":1,"stats":{"Line":0}},{"line":297,"address":[20837337,20797914,20797413,20837471,20797337],"length":1,"stats":{"Line":0}},{"line":308,"address":[20900849],"length":1,"stats":{"Line":0}},{"line":309,"address":[20862753],"length":1,"stats":{"Line":0}},{"line":310,"address":[20867444],"length":1,"stats":{"Line":0}},{"line":311,"address":[21044255,21006520,21005943,21044121,21006019],"length":1,"stats":{"Line":0}},{"line":322,"address":[19489721],"length":1,"stats":{"Line":0}},{"line":323,"address":[20895500,20895182],"length":1,"stats":{"Line":0}},{"line":324,"address":[20990330],"length":1,"stats":{"Line":0}},{"line":325,"address":[20894158],"length":1,"stats":{"Line":0}},{"line":326,"address":[20791082],"length":1,"stats":{"Line":0}},{"line":327,"address":[20852020],"length":1,"stats":{"Line":0}},{"line":330,"address":[20890053,20890400,20944249,20944383],"length":1,"stats":{"Line":0}},{"line":332,"address":[20895984,20892380,20894286,20892554],"length":1,"stats":{"Line":0}},{"line":334,"address":[20858451],"length":1,"stats":{"Line":0}},{"line":335,"address":[15034121,15031271],"length":1,"stats":{"Line":0}},{"line":336,"address":[20786647],"length":1,"stats":{"Line":0}},{"line":337,"address":[20896718],"length":1,"stats":{"Line":0}},{"line":338,"address":[19492775],"length":1,"stats":{"Line":0}},{"line":339,"address":[20896625],"length":1,"stats":{"Line":0}},{"line":342,"address":[20944745,20892658,20892951,20944879],"length":1,"stats":{"Line":0}},{"line":344,"address":[11923799],"length":1,"stats":{"Line":0}},{"line":347,"address":[20893771,20949177,20911798,20949311],"length":1,"stats":{"Line":0}},{"line":349,"address":[15031078],"length":1,"stats":{"Line":0}},{"line":350,"address":[20945871,20909453,20945737,20889531,20909954],"length":1,"stats":{"Line":0}},{"line":362,"address":[15026333,15013891,15026248],"length":1,"stats":{"Line":0}},{"line":363,"address":[20890671,20890739],"length":1,"stats":{"Line":0}},{"line":365,"address":[20847190],"length":1,"stats":{"Line":0}},{"line":368,"address":[20805680,20805631,20810082,20805832,20805927,20805727,20808500,20806206,20805956],"length":1,"stats":{"Line":0}},{"line":369,"address":[21012356,21012526,21012150],"length":1,"stats":{"Line":0}},{"line":371,"address":[15054075,15053996],"length":1,"stats":{"Line":0}},{"line":373,"address":[20806659],"length":1,"stats":{"Line":0}},{"line":374,"address":[20874549],"length":1,"stats":{"Line":0}},{"line":376,"address":[15054824,15087833,15054288,15087967],"length":1,"stats":{"Line":0}},{"line":378,"address":[20808569,20840943,20840809],"length":1,"stats":{"Line":0}},{"line":381,"address":[20808470],"length":1,"stats":{"Line":0}},{"line":384,"address":[20817560,20819878,20817111,20817184,20817231,20817394,20817873,20822689],"length":1,"stats":{"Line":0}},{"line":385,"address":[20878256,20878737,20878592,20878510],"length":1,"stats":{"Line":0}},{"line":387,"address":[15063187,15058734,15058817],"length":1,"stats":{"Line":0}},{"line":389,"address":[15058921,15059031,15060431,15059203],"length":1,"stats":{"Line":0}},{"line":390,"address":[21017940,21018087],"length":1,"stats":{"Line":0}},{"line":391,"address":[20923498],"length":1,"stats":{"Line":0}},{"line":392,"address":[20809394,20805359,20805453,20806075,20805721,20809168],"length":1,"stats":{"Line":0}},{"line":393,"address":[20816034,20815974],"length":1,"stats":{"Line":0}},{"line":397,"address":[20819389,20819582],"length":1,"stats":{"Line":0}},{"line":398,"address":[21018897],"length":1,"stats":{"Line":0}},{"line":400,"address":[19555387],"length":1,"stats":{"Line":0}},{"line":401,"address":[20924874,20925054,20925287,20925108,20925403,20925558],"length":1,"stats":{"Line":0}},{"line":402,"address":[15060975],"length":1,"stats":{"Line":0}},{"line":403,"address":[19516458,19519410,19519664,19519470],"length":1,"stats":{"Line":0}},{"line":404,"address":[15061526,15063728,15063750],"length":1,"stats":{"Line":0}},{"line":406,"address":[19547238,19519803,19519919,19520456,19547081],"length":1,"stats":{"Line":0}},{"line":407,"address":[20821546],"length":1,"stats":{"Line":0}},{"line":409,"address":[20879243,20880762],"length":1,"stats":{"Line":0}},{"line":413,"address":[20922659,20925694,20922825,20922415,20922511,20923742,20922464,20923161],"length":1,"stats":{"Line":0}},{"line":415,"address":[11897617],"length":1,"stats":{"Line":0}},{"line":418,"address":[20892279,20891526,20892446,20892567],"length":1,"stats":{"Line":0}},{"line":419,"address":[20819968,20818087,20819977,20818160],"length":1,"stats":{"Line":0}},{"line":422,"address":[20929777],"length":1,"stats":{"Line":0}},{"line":423,"address":[20825310,20825430],"length":1,"stats":{"Line":0}},{"line":424,"address":[11787801],"length":1,"stats":{"Line":0}},{"line":425,"address":[20925085],"length":1,"stats":{"Line":0}},{"line":426,"address":[20930677],"length":1,"stats":{"Line":0}},{"line":427,"address":[20893925,20894007],"length":1,"stats":{"Line":0}},{"line":428,"address":[19525053,19524971],"length":1,"stats":{"Line":0}},{"line":430,"address":[20938033,20931535,20931602,20935571,20931504,20931113,20930901,20931709],"length":1,"stats":{"Line":0}},{"line":431,"address":[15068426,15067691,15067616,15067642,15067757],"length":1,"stats":{"Line":0}},{"line":432,"address":[20933011],"length":1,"stats":{"Line":0}},{"line":436,"address":[15069076,15069163],"length":1,"stats":{"Line":0}},{"line":437,"address":[20821711],"length":1,"stats":{"Line":0}},{"line":438,"address":[20931712,20931606],"length":1,"stats":{"Line":0}},{"line":440,"address":[20894512,20889646,20894496],"length":1,"stats":{"Line":0}},{"line":443,"address":[20929996,20931902,20930490,20930130,20931780],"length":1,"stats":{"Line":0}},{"line":447,"address":[19527521],"length":1,"stats":{"Line":0}},{"line":448,"address":[19547766,19527729,19547609,19527559,19528251],"length":1,"stats":{"Line":0}},{"line":457,"address":[20821784],"length":1,"stats":{"Line":0}},{"line":458,"address":[20835647,20817844,20817343,20815023,20835513],"length":1,"stats":{"Line":0}},{"line":468,"address":[20900663,20894894,20900748],"length":1,"stats":{"Line":0}},{"line":471,"address":[20819636],"length":1,"stats":{"Line":0}},{"line":473,"address":[20928568,20928220],"length":1,"stats":{"Line":0}},{"line":477,"address":[20826987,20826784,20826898,20826745,20827233,20826819,20827010,20827728],"length":1,"stats":{"Line":0}},{"line":478,"address":[11916532],"length":1,"stats":{"Line":0}},{"line":479,"address":[20933490,20933417],"length":1,"stats":{"Line":0}},{"line":482,"address":[20896081,20895835,20895667,20896821,20895632,20895858,20895746,20895583],"length":1,"stats":{"Line":0}},{"line":483,"address":[20821366,20821521,20821181],"length":1,"stats":{"Line":0}},{"line":485,"address":[20940114,20940041,20940486],"length":1,"stats":{"Line":0}},{"line":489,"address":[19534172,19534125],"length":1,"stats":{"Line":0}},{"line":491,"address":[21035004,21035110],"length":1,"stats":{"Line":0}},{"line":495,"address":[20935040,20935075,20935270,20934991,20935550,20936346,20935293,20935163,20936677],"length":1,"stats":{"Line":0}},{"line":497,"address":[19568847],"length":1,"stats":{"Line":0}},{"line":498,"address":[21036182,21037072,21036255,21037081],"length":1,"stats":{"Line":0}},{"line":501,"address":[20897879,20898043],"length":1,"stats":{"Line":0}},{"line":502,"address":[20905026,20905171,20904859,20904024],"length":1,"stats":{"Line":0}},{"line":504,"address":[20941655],"length":1,"stats":{"Line":0}},{"line":508,"address":[20940831,20940931,20941311,20940719,20940784,20941055,20943642,20941026],"length":1,"stats":{"Line":0}},{"line":509,"address":[11798135],"length":1,"stats":{"Line":0}},{"line":511,"address":[21038040,21038119,21038764,21040043],"length":1,"stats":{"Line":0}},{"line":514,"address":[20906732,20907224,20906663,20907750,20908060,20917529,20917663],"length":1,"stats":{"Line":0}},{"line":519,"address":[20900276],"length":1,"stats":{"Line":0}},{"line":521,"address":[20941811,20943451],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":215},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_network_service.rs"],"content":"use super::{\r\n    DiscoveryOptions, NetworkService, NetworkStats, Peer,\r\n    dht_bootstrap::{DhtGossip, secret},\r\n};\r\nuse crate::domain::p2p::{P2PEvent, generate_topic_id, topic_id_bytes};\r\nuse crate::shared::config::{BootstrapSource, NetworkConfig as AppNetworkConfig};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\nuse iroh::{Endpoint, EndpointAddr, discovery::static_provider::StaticProvider, protocol::Router};\r\nuse std::sync::Arc;\r\nuse tokio::sync::{RwLock, broadcast};\r\nuse tracing;\r\n\r\npub struct IrohNetworkService {\r\n    endpoint: Arc<Endpoint>,\r\n    router: Arc<Router>,\r\n    static_discovery: Arc<StaticProvider>,\r\n    connected: Arc<RwLock<bool>>,\r\n    peers: Arc<RwLock<Vec<Peer>>>,\r\n    stats: Arc<RwLock<NetworkStats>>,\r\n    dht_gossip: Option<Arc<DhtGossip>>,\r\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\r\n    network_config: Arc<RwLock<AppNetworkConfig>>,\r\n    bootstrap_peers: Arc<RwLock<Vec<String>>>,\r\n    bootstrap_source: Arc<RwLock<BootstrapSource>>,\r\n    p2p_event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n}\r\n\r\nimpl IrohNetworkService {\r\n    pub async fn new(\r\n        secret_key: iroh::SecretKey,\r\n        net_cfg: AppNetworkConfig,\r\n        discovery_options: DiscoveryOptions,\r\n        event_tx: Option<broadcast::Sender<P2PEvent>>,\r\n    ) -> Result<Self, AppError> {\r\n        // Endpointの作成（設定に応じてディスカバリーを有効化）\r\n        let static_discovery = Arc::new(StaticProvider::new());\r\n        let builder = Endpoint::builder().secret_key(secret_key);\r\n        let builder = discovery_options.apply_to_builder(builder);\r\n        let builder = builder.discovery(static_discovery.clone());\r\n        let endpoint = builder\r\n            .bind()\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to bind endpoint: {e:?}\")))?;\r\n\r\n        // Routerの作成（Gossipプロトコルは別で設定）\r\n        let router = Router::builder(endpoint.clone()).spawn();\r\n\r\n        // ブートストラップ設定の検証（警告/件数ログのみ）\r\n        if let Err(e) = super::bootstrap_config::validate_bootstrap_config() {\r\n            tracing::warn!(\"bootstrap_nodes.json validation failed: {:?}\", e);\r\n        }\r\n\r\n        // DhtGossipの初期化\r\n        let dht_gossip = match DhtGossip::new(Arc::new(endpoint.clone())).await {\r\n            Ok(service) => Some(Arc::new(service)),\r\n            Err(e) => {\r\n                tracing::warn!(\"Failed to initialize DhtGossip: {:?}\", e);\r\n                None\r\n            }\r\n        };\r\n\r\n        let network_config = Arc::new(RwLock::new(net_cfg.clone()));\r\n        let endpoint = Arc::new(endpoint);\r\n        let service = Self {\r\n            endpoint: Arc::clone(&endpoint),\r\n            router: Arc::new(router),\r\n            static_discovery,\r\n            connected: Arc::new(RwLock::new(false)),\r\n            peers: Arc::new(RwLock::new(Vec::new())),\r\n            stats: Arc::new(RwLock::new(NetworkStats {\r\n                connected_peers: 0,\r\n                total_messages_sent: 0,\r\n                total_messages_received: 0,\r\n                bandwidth_up: 0,\r\n                bandwidth_down: 0,\r\n            })),\r\n            dht_gossip,\r\n            discovery_options: Arc::new(RwLock::new(discovery_options)),\r\n            network_config: Arc::clone(&network_config),\r\n            bootstrap_peers: Arc::new(RwLock::new(net_cfg.bootstrap_peers.clone())),\r\n            bootstrap_source: Arc::new(RwLock::new(net_cfg.bootstrap_source)),\r\n            p2p_event_tx: event_tx,\r\n        };\r\n\r\n        service.apply_bootstrap_peers_from_config().await;\r\n\r\n        Ok(service)\r\n    }\r\n\r\n    pub fn endpoint(&self) -> &Arc<Endpoint> {\r\n        &self.endpoint\r\n    }\r\n\r\n    pub fn static_discovery(&self) -> Arc<StaticProvider> {\r\n        Arc::clone(&self.static_discovery)\r\n    }\r\n\r\n    pub fn router(&self) -> &Arc<Router> {\r\n        &self.router\r\n    }\r\n\r\n    fn emit_event(&self, event: P2PEvent) {\r\n        if let Some(tx) = &self.p2p_event_tx {\r\n            let _ = tx.send(event);\r\n        }\r\n    }\r\n\r\n    async fn apply_bootstrap_peers_from_config(&self) {\r\n        let peers = { self.bootstrap_peers.read().await.clone() };\r\n        if peers.is_empty() {\r\n            return;\r\n        }\r\n        let source = *self.bootstrap_source.read().await;\r\n        let success_count = self.connect_bootstrap_nodes(&peers).await;\r\n        if success_count > 0 {\r\n            super::metrics::record_bootstrap_source(source);\r\n        }\r\n    }\r\n\r\n    async fn connect_bootstrap_nodes(&self, nodes: &[String]) -> usize {\r\n        let mut success_count = 0usize;\r\n        for peer in nodes {\r\n            let trimmed = peer.trim();\r\n            if trimmed.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            match self.add_peer(trimmed).await {\r\n                Ok(_) => {\r\n                    success_count += 1;\r\n                    tracing::info!(\"Connected to bootstrap peer from config: {}\", trimmed);\r\n                }\r\n                Err(err) => {\r\n                    tracing::warn!(\"Failed to connect to bootstrap peer '{}': {}\", trimmed, err);\r\n                }\r\n            }\r\n        }\r\n        success_count\r\n    }\r\n\r\n    pub fn node_id(&self) -> String {\r\n        self.endpoint.id().to_string()\r\n    }\r\n\r\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\r\n        *self.discovery_options.read().await\r\n    }\r\n\r\n    pub async fn node_addr(&self) -> Result<Vec<String>, AppError> {\r\n        // 直接アドレスを解決し、`node_id@ip:port` 形式で返却\r\n        self.endpoint.online().await;\r\n        let node_addr = self.endpoint.addr();\r\n        let node_id = node_addr.id.to_string();\r\n        let mut out = Vec::new();\r\n        for addr in node_addr.ip_addrs() {\r\n            out.push(format!(\"{node_id}@{addr}\"));\r\n        }\r\n        if out.is_empty() {\r\n            out.push(node_id);\r\n        }\r\n        Ok(out)\r\n    }\r\n\r\n    /// DHT????????????\r\n    pub async fn join_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.join_topic(&topic_bytes, vec![]).await?;\r\n            tracing::info!(\r\n                \"Joined DHT topic: {} (requested: {})\",\r\n                canonical,\r\n                topic_name\r\n            );\r\n        } else {\r\n            tracing::warn!(\"DHT service not available, using fallback\");\r\n            // ?????????????\r\n            self.connect_fallback().await?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// DHT?????????????\r\n    pub async fn leave_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.leave_topic(&topic_bytes).await?;\r\n            tracing::info!(\"Left DHT topic: {} (requested: {})\", canonical, topic_name);\r\n        }\r\n        Ok(())\r\n    }\r\n    /// DHT???????????????????\r\n    pub async fn broadcast_dht(&self, topic_name: &str, message: Vec<u8>) -> Result<(), AppError> {\r\n        let canonical = generate_topic_id(topic_name);\r\n        let topic_bytes = topic_id_bytes(&canonical);\r\n        if let Some(ref dht_gossip) = self.dht_gossip {\r\n            dht_gossip.broadcast(&topic_bytes, message).await?;\r\n        } else {\r\n            return Err(AppError::P2PError(\"DHT service not available\".to_string()));\r\n        }\r\n        Ok(())\r\n    }\r\n    /// フォールバックモードでピアに接続\r\n    async fn connect_fallback(&self) -> Result<(), AppError> {\r\n        // 1) 設定ファイルからのブートストラップ接続を優先\r\n        let fallback_peers =\r\n            match super::dht_bootstrap::fallback::connect_from_config(&self.endpoint).await {\r\n                Ok(peers) => peers,\r\n                Err(_) => {\r\n                    // 2) ハードコードされたフォールバックに接続（なければ失敗）\r\n                    match super::dht_bootstrap::fallback::connect_to_fallback(&self.endpoint).await\r\n                    {\r\n                        Ok(peers) => peers,\r\n                        Err(err) => {\r\n                            super::metrics::record_mainline_reconnect_failure();\r\n                            return Err(err);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n        super::metrics::record_mainline_reconnect_success();\r\n\r\n        // フォールバックピアをピアリストに追加\r\n        let mut peers = self.peers.write().await;\r\n        let now = chrono::Utc::now().timestamp();\r\n\r\n        for node_addr in fallback_peers {\r\n            peers.push(Peer {\r\n                id: node_addr.id.to_string(),\r\n                address: format!(\"{}@fallback\", node_addr.id),\r\n                connected_at: now,\r\n                last_seen: now,\r\n            });\r\n            self.static_discovery.add_endpoint_info(node_addr);\r\n        }\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 共有シークレットをローテーション\r\n    pub async fn rotate_dht_secret(&self) -> Result<(), AppError> {\r\n        secret::rotate_secret()\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to rotate secret: {e:?}\")))?;\r\n        tracing::info!(\"DHT shared secret rotated\");\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl NetworkService for IrohNetworkService {\r\n    fn as_any(&self) -> &dyn std::any::Any {\r\n        self\r\n    }\r\n\r\n    async fn connect(&self) -> Result<(), AppError> {\r\n        let mut connected = self.connected.write().await;\r\n        let was_connected = *connected;\r\n        *connected = true;\r\n        drop(connected);\r\n        if !was_connected {\r\n            let node_id = self.endpoint.id().to_string();\r\n            let addresses = match self.node_addr().await {\r\n                Ok(addresses) => addresses,\r\n                Err(err) => {\r\n                    tracing::warn!(\"Failed to resolve node addresses on connect: {}\", err);\r\n                    Vec::new()\r\n                }\r\n            };\r\n            self.emit_event(P2PEvent::NetworkConnected { node_id, addresses });\r\n        }\r\n        tracing::info!(\"Network service connected\");\r\n        Ok(())\r\n    }\r\n\r\n    async fn disconnect(&self) -> Result<(), AppError> {\r\n        let mut connected = self.connected.write().await;\r\n        let was_connected = *connected;\r\n        *connected = false;\r\n        drop(connected);\r\n\r\n        // ピアリストをクリア\r\n        let mut peers = self.peers.write().await;\r\n        peers.clear();\r\n        super::metrics::set_mainline_connected_peers(0);\r\n\r\n        tracing::info!(\"Network service disconnected\");\r\n        if was_connected {\r\n            let node_id = self.endpoint.id().to_string();\r\n            self.emit_event(P2PEvent::NetworkDisconnected { node_id });\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError> {\r\n        let peers = self.peers.read().await;\r\n        Ok(peers.clone())\r\n    }\r\n\r\n    async fn add_peer(&self, address: &str) -> Result<(), AppError> {\r\n        // アドレスからNodeIdを抽出（例: \"node_id@socket_addr\"）\r\n        use iroh::EndpointId;\r\n        use std::net::SocketAddr;\r\n        use std::str::FromStr;\r\n\r\n        let parts: Vec<&str> = address.split('@').collect();\r\n        if parts.len() != 2 {\r\n            super::metrics::record_mainline_connection_failure();\r\n            return Err(\"Invalid address format: expected 'node_id@socket_addr'\".into());\r\n        }\r\n\r\n        let node_id = EndpointId::from_str(parts[0]).map_err(|e| {\r\n            super::metrics::record_mainline_connection_failure();\r\n            AppError::from(format!(\"Failed to parse node ID: {e}\"))\r\n        })?;\r\n        let socket_addr: SocketAddr = parts[1].parse().map_err(|e| {\r\n            super::metrics::record_mainline_connection_failure();\r\n            AppError::from(format!(\"Failed to parse socket address: {e}\"))\r\n        })?;\r\n\r\n        // NodeAddrを構築\r\n        let node_addr = EndpointAddr::new(node_id).with_ip_addr(socket_addr);\r\n        self.static_discovery.add_endpoint_info(node_addr.clone());\r\n\r\n        // ピアに接続\r\n        self.endpoint\r\n            .connect(node_addr.clone(), iroh_gossip::ALPN)\r\n            .await\r\n            .map_err(|e| {\r\n                super::metrics::record_mainline_connection_failure();\r\n                AppError::from(format!(\"Failed to connect to peer: {e}\"))\r\n            })?;\r\n\r\n        // ピアリストに追加\r\n        let mut peers = self.peers.write().await;\r\n        let now = chrono::Utc::now().timestamp();\r\n        peers.push(Peer {\r\n            id: node_addr.id.to_string(),\r\n            address: address.to_string(),\r\n            connected_at: now,\r\n            last_seen: now,\r\n        });\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::record_mainline_connection_success();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        tracing::info!(\"Added peer: {}\", address);\r\n        Ok(())\r\n    }\r\n\r\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError> {\r\n        let mut peers = self.peers.write().await;\r\n        peers.retain(|p| p.id != peer_id);\r\n\r\n        // 統計を更新\r\n        let mut stats = self.stats.write().await;\r\n        stats.connected_peers = peers.len();\r\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\r\n\r\n        tracing::info!(\"Removed peer: {}\", peer_id);\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_stats(&self) -> Result<NetworkStats, AppError> {\r\n        let stats = self.stats.read().await;\r\n        Ok(stats.clone())\r\n    }\r\n\r\n    async fn is_connected(&self) -> bool {\r\n        let connected = self.connected.read().await;\r\n        *connected\r\n    }\r\n\r\n    async fn get_node_id(&self) -> Result<String, AppError> {\r\n        Ok(self.endpoint.id().to_string())\r\n    }\r\n\r\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\r\n        self.node_addr().await\r\n    }\r\n\r\n    async fn join_dht_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        IrohNetworkService::join_dht_topic(self, topic).await\r\n    }\r\n\r\n    async fn leave_dht_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        IrohNetworkService::leave_dht_topic(self, topic).await\r\n    }\r\n\r\n    async fn broadcast_dht(&self, topic: &str, message: Vec<u8>) -> Result<(), AppError> {\r\n        IrohNetworkService::broadcast_dht(self, topic, message).await\r\n    }\r\n\r\n    async fn apply_bootstrap_nodes(\r\n        &self,\r\n        nodes: Vec<String>,\r\n        source: BootstrapSource,\r\n    ) -> Result<(), AppError> {\r\n        let mut normalized: Vec<String> = nodes\r\n            .into_iter()\r\n            .map(|entry| entry.trim().to_string())\r\n            .filter(|entry| !entry.is_empty())\r\n            .collect();\r\n        normalized.sort();\r\n        normalized.dedup();\r\n\r\n        {\r\n            let mut cfg = self.network_config.write().await;\r\n            cfg.bootstrap_peers = normalized.clone();\r\n            cfg.bootstrap_source = source;\r\n        }\r\n        {\r\n            let mut peers = self.bootstrap_peers.write().await;\r\n            *peers = normalized.clone();\r\n        }\r\n        {\r\n            let mut stored_source = self.bootstrap_source.write().await;\r\n            *stored_source = source;\r\n        }\r\n\r\n        if normalized.is_empty() {\r\n            tracing::warn!(\"Bootstrap nodes list is empty; skipping connections\");\r\n            return Ok(());\r\n        }\r\n\r\n        let success = self.connect_bootstrap_nodes(&normalized).await;\r\n        if success > 0 {\r\n            super::metrics::record_bootstrap_source(source);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[16562064],"length":1,"stats":{"Line":0}},{"line":37,"address":[16569438,16569608],"length":1,"stats":{"Line":0}},{"line":38,"address":[16675611,16675678],"length":1,"stats":{"Line":0}},{"line":39,"address":[16679702],"length":1,"stats":{"Line":0}},{"line":40,"address":[16563431,16563104],"length":1,"stats":{"Line":0}},{"line":41,"address":[16776677,16776436,16776340,16776877,16777324],"length":1,"stats":{"Line":0}},{"line":43,"address":[19293376],"length":1,"stats":{"Line":0}},{"line":44,"address":[16653360,16645724,16653382],"length":1,"stats":{"Line":0}},{"line":47,"address":[24339147,24339328],"length":1,"stats":{"Line":0}},{"line":50,"address":[16682716,16682783],"length":1,"stats":{"Line":0}},{"line":51,"address":[16571954,16571453,16571352,16668089,16668223],"length":1,"stats":{"Line":0}},{"line":55,"address":[11532185],"length":1,"stats":{"Line":0}},{"line":56,"address":[16683813,16683678],"length":1,"stats":{"Line":0}},{"line":57,"address":[16641681],"length":1,"stats":{"Line":0}},{"line":58,"address":[16648657,16743455,16743321,16649328,16648800],"length":1,"stats":{"Line":0}},{"line":59,"address":[16649272],"length":1,"stats":{"Line":0}},{"line":63,"address":[16648716,16650435],"length":1,"stats":{"Line":0}},{"line":64,"address":[16650789,16650537],"length":1,"stats":{"Line":0}},{"line":66,"address":[16782344,16782428],"length":1,"stats":{"Line":0}},{"line":67,"address":[16782563,16782436],"length":1,"stats":{"Line":0}},{"line":69,"address":[16682241,16682313],"length":1,"stats":{"Line":0}},{"line":70,"address":[24344682,24344622],"length":1,"stats":{"Line":0}},{"line":71,"address":[16583537,16583675],"length":1,"stats":{"Line":0}},{"line":79,"address":[16688428,16688271],"length":1,"stats":{"Line":0}},{"line":80,"address":[16688545,16688465],"length":1,"stats":{"Line":0}},{"line":81,"address":[16570265,16570347],"length":1,"stats":{"Line":0}},{"line":82,"address":[24345479,24345394],"length":1,"stats":{"Line":0}},{"line":86,"address":[24346066,24337724,24345792,24345707],"length":1,"stats":{"Line":0}},{"line":88,"address":[16578056],"length":1,"stats":{"Line":0}},{"line":91,"address":[16578880],"length":1,"stats":{"Line":0}},{"line":95,"address":[16684816],"length":1,"stats":{"Line":0}},{"line":96,"address":[16572117],"length":1,"stats":{"Line":0}},{"line":99,"address":[16785216],"length":1,"stats":{"Line":0}},{"line":100,"address":[16646744],"length":1,"stats":{"Line":0}},{"line":103,"address":[16684864],"length":1,"stats":{"Line":0}},{"line":104,"address":[16572179],"length":1,"stats":{"Line":0}},{"line":105,"address":[16586009],"length":1,"stats":{"Line":0}},{"line":109,"address":[16654034,16653888,16654969,16653880,16653919,16654119,16653872,16654281],"length":1,"stats":{"Line":0}},{"line":110,"address":[11763839],"length":1,"stats":{"Line":0}},{"line":111,"address":[16786235,16786314],"length":1,"stats":{"Line":0}},{"line":114,"address":[11657938],"length":1,"stats":{"Line":0}},{"line":115,"address":[16686512,16685290],"length":1,"stats":{"Line":0}},{"line":116,"address":[16587932,16587988],"length":1,"stats":{"Line":0}},{"line":117,"address":[16648772],"length":1,"stats":{"Line":0}},{"line":121,"address":[16588000,16588018,16588274,16588231,16588048,16592476,16588079,16588387],"length":1,"stats":{"Line":0}},{"line":122,"address":[16692716],"length":1,"stats":{"Line":0}},{"line":123,"address":[16649169,16653065,16649036,16652960],"length":1,"stats":{"Line":0}},{"line":124,"address":[16691193],"length":1,"stats":{"Line":0}},{"line":125,"address":[16578572],"length":1,"stats":{"Line":0}},{"line":129,"address":[16687363,16687205,16691317],"length":1,"stats":{"Line":0}},{"line":131,"address":[16588866,16588702,16588826],"length":1,"stats":{"Line":0}},{"line":132,"address":[16780719,16693366,16693421,16780585],"length":1,"stats":{"Line":0}},{"line":134,"address":[16693267],"length":1,"stats":{"Line":0}},{"line":135,"address":[16737519,16651829,16651328,16649619,16737385],"length":1,"stats":{"Line":0}},{"line":139,"address":[16791477],"length":1,"stats":{"Line":0}},{"line":142,"address":[16578736],"length":1,"stats":{"Line":0}},{"line":143,"address":[16585552],"length":1,"stats":{"Line":0}},{"line":146,"address":[16691536,16692248,16691528,16691561,16691825,16691520,16691647,16691684],"length":1,"stats":{"Line":0}},{"line":147,"address":[16697258,16697211,16697317,16697441],"length":1,"stats":{"Line":0}},{"line":150,"address":[16696216,16696208,16696240,16696554,16697673,16696410,16696373,16696275],"length":1,"stats":{"Line":0}},{"line":152,"address":[11663609],"length":1,"stats":{"Line":0}},{"line":153,"address":[16793175],"length":1,"stats":{"Line":0}},{"line":154,"address":[24355207,24355128],"length":1,"stats":{"Line":0}},{"line":155,"address":[16580239],"length":1,"stats":{"Line":0}},{"line":156,"address":[16594124,16594056,16594266],"length":1,"stats":{"Line":0}},{"line":157,"address":[16655114,16655443],"length":1,"stats":{"Line":0}},{"line":159,"address":[16793628,16793555],"length":1,"stats":{"Line":0}},{"line":160,"address":[16655270],"length":1,"stats":{"Line":0}},{"line":162,"address":[16698850],"length":1,"stats":{"Line":0}},{"line":166,"address":[24356366,24356096,24360405,24356048,24356302,24358377,24356066,24356158],"length":1,"stats":{"Line":0}},{"line":167,"address":[16794367],"length":1,"stats":{"Line":0}},{"line":168,"address":[16662957,16663053],"length":1,"stats":{"Line":0}},{"line":169,"address":[16663084,16667228],"length":1,"stats":{"Line":0}},{"line":170,"address":[11568225],"length":1,"stats":{"Line":0}},{"line":171,"address":[16738015,16658295,16658928,16658415,16737881],"length":1,"stats":{"Line":0}},{"line":177,"address":[16794700,16876991,16795425,16876857,16794916],"length":1,"stats":{"Line":0}},{"line":179,"address":[24360689,24357300,24360414,24360825,24356353,24358286],"length":1,"stats":{"Line":0}},{"line":181,"address":[24359271],"length":1,"stats":{"Line":0}},{"line":185,"address":[16702738,16702514,16705235,16703188,16702591,16702781,16702544,16702496],"length":1,"stats":{"Line":0}},{"line":186,"address":[16667587],"length":1,"stats":{"Line":0}},{"line":187,"address":[16660783,16660879],"length":1,"stats":{"Line":0}},{"line":188,"address":[16799390],"length":1,"stats":{"Line":0}},{"line":189,"address":[16704712,16704868,16704651,16704416,16705169],"length":1,"stats":{"Line":0}},{"line":190,"address":[16745801,16668373,16745935,16668493],"length":1,"stats":{"Line":0}},{"line":192,"address":[16600142],"length":1,"stats":{"Line":0}},{"line":195,"address":[24363584,24363683,24363853,24364401,24364906,24363648,24363602],"length":1,"stats":{"Line":0}},{"line":196,"address":[16663449],"length":1,"stats":{"Line":0}},{"line":197,"address":[16670482,16670560],"length":1,"stats":{"Line":0}},{"line":198,"address":[16589065],"length":1,"stats":{"Line":0}},{"line":199,"address":[10952340],"length":1,"stats":{"Line":0}},{"line":201,"address":[17151207,17151392],"length":1,"stats":{"Line":0}},{"line":203,"address":[24364681],"length":1,"stats":{"Line":0}},{"line":206,"address":[16590016,16590024,16590355,16591167,16590511,16590110,16590237,16590048],"length":1,"stats":{"Line":0}},{"line":208,"address":[10973041],"length":1,"stats":{"Line":0}},{"line":210,"address":[16709119],"length":1,"stats":{"Line":0}},{"line":213,"address":[16597717,16597960,16597072,16597847],"length":1,"stats":{"Line":0}},{"line":215,"address":[24366392],"length":1,"stats":{"Line":0}},{"line":216,"address":[16591525],"length":1,"stats":{"Line":0}},{"line":217,"address":[16704277],"length":1,"stats":{"Line":0}},{"line":218,"address":[16710141],"length":1,"stats":{"Line":0}},{"line":224,"address":[16708227],"length":1,"stats":{"Line":0}},{"line":227,"address":[16664901,16666258,16666643],"length":1,"stats":{"Line":0}},{"line":228,"address":[16673873,16673806],"length":1,"stats":{"Line":0}},{"line":230,"address":[16592596,16592626,16592390,16593359],"length":1,"stats":{"Line":0}},{"line":231,"address":[16667290,16667710],"length":1,"stats":{"Line":0}},{"line":232,"address":[16711201],"length":1,"stats":{"Line":0}},{"line":233,"address":[24367984,24367916],"length":1,"stats":{"Line":0}},{"line":237,"address":[16709864],"length":1,"stats":{"Line":0}},{"line":241,"address":[11583888],"length":1,"stats":{"Line":0}},{"line":242,"address":[16710271,16710348],"length":1,"stats":{"Line":0}},{"line":243,"address":[16668353],"length":1,"stats":{"Line":0}},{"line":245,"address":[16710444],"length":1,"stats":{"Line":0}},{"line":249,"address":[16600893,16600696,16600688,16603026,16600850,16601085,16600704,16600751],"length":1,"stats":{"Line":0}},{"line":250,"address":[16712729,16712540,16712839,16713049,16714528,16712336,16712451],"length":1,"stats":{"Line":0}},{"line":251,"address":[16675616,16675704,16675790,16675853,16676009],"length":1,"stats":{"Line":0}},{"line":252,"address":[16608454,16610016,16610038],"length":1,"stats":{"Line":0}},{"line":253,"address":[24369774,24439887,24370301,24439753],"length":1,"stats":{"Line":0}},{"line":254,"address":[16609065],"length":1,"stats":{"Line":0}},{"line":260,"address":[24440192],"length":1,"stats":{"Line":0}},{"line":264,"address":[16786245,16781936,16782228,16782550,16781983,16783393,16782257,16781887,16782112],"length":1,"stats":{"Line":0}},{"line":265,"address":[11903103],"length":1,"stats":{"Line":0}},{"line":266,"address":[16747712,16747796],"length":1,"stats":{"Line":0}},{"line":267,"address":[16740886],"length":1,"stats":{"Line":0}},{"line":268,"address":[16784624],"length":1,"stats":{"Line":0}},{"line":269,"address":[16783046,16785715],"length":1,"stats":{"Line":0}},{"line":270,"address":[16741004,16741112],"length":1,"stats":{"Line":0}},{"line":271,"address":[16673449,16672307,16673366,16673546],"length":1,"stats":{"Line":0}},{"line":272,"address":[16748525],"length":1,"stats":{"Line":0}},{"line":273,"address":[16680871],"length":1,"stats":{"Line":0}},{"line":274,"address":[16881001,16908393,16908527,16880231,16880500],"length":1,"stats":{"Line":0}},{"line":275,"address":[16674684],"length":1,"stats":{"Line":0}},{"line":278,"address":[16680950],"length":1,"stats":{"Line":0}},{"line":280,"address":[16673226,16702735,16702601,16675871,16676401],"length":1,"stats":{"Line":0}},{"line":281,"address":[24444535],"length":1,"stats":{"Line":0}},{"line":284,"address":[16677693,16677664,16678622,16677343,16677439,16677392,16680601,16677986,16677548],"length":1,"stats":{"Line":0}},{"line":285,"address":[16883866,16884167,16884089,16884306],"length":1,"stats":{"Line":0}},{"line":286,"address":[16685244,16685328],"length":1,"stats":{"Line":0}},{"line":287,"address":[16671584],"length":1,"stats":{"Line":0}},{"line":288,"address":[17269330],"length":1,"stats":{"Line":0}},{"line":291,"address":[11873794],"length":1,"stats":{"Line":0}},{"line":292,"address":[16746677,16746756],"length":1,"stats":{"Line":0}},{"line":293,"address":[16685935],"length":1,"stats":{"Line":0}},{"line":295,"address":[16788830,16812953,16813087,16789367],"length":1,"stats":{"Line":0}},{"line":296,"address":[16754217],"length":1,"stats":{"Line":0}},{"line":297,"address":[16680404],"length":1,"stats":{"Line":0}},{"line":298,"address":[16687458],"length":1,"stats":{"Line":0}},{"line":300,"address":[24448566],"length":1,"stats":{"Line":0}},{"line":303,"address":[16681585,16680802,16681137,16680723,16680914,16680891,16680688,16680649],"length":1,"stats":{"Line":0}},{"line":304,"address":[16792673,16792518,16792333],"length":1,"stats":{"Line":0}},{"line":305,"address":[16681474,16681401],"length":1,"stats":{"Line":0}},{"line":308,"address":[16682027,16681758,16681696,16681631,16681861,16683430,16687094,16684245],"length":1,"stats":{"Line":0}},{"line":314,"address":[16788061],"length":1,"stats":{"Line":0}},{"line":315,"address":[16788132,16788219],"length":1,"stats":{"Line":0}},{"line":316,"address":[16682347],"length":1,"stats":{"Line":0}},{"line":317,"address":[16676580],"length":1,"stats":{"Line":0}},{"line":320,"address":[16683362,16682597,16687332,16682305,16682369,16687104],"length":1,"stats":{"Line":0}},{"line":321,"address":[24455318],"length":1,"stats":{"Line":0}},{"line":322,"address":[16754991],"length":1,"stats":{"Line":0}},{"line":324,"address":[16793280,16788806,16788562,16788426,16789254],"length":1,"stats":{"Line":0}},{"line":325,"address":[17278024],"length":1,"stats":{"Line":0}},{"line":326,"address":[16793310],"length":1,"stats":{"Line":0}},{"line":330,"address":[16675995,16676139],"length":1,"stats":{"Line":0}},{"line":331,"address":[16683077,16682994],"length":1,"stats":{"Line":0}},{"line":334,"address":[16793430,16793120,16792987,16793594,16793882,16793053],"length":1,"stats":{"Line":0}},{"line":335,"address":[16750970],"length":1,"stats":{"Line":0}},{"line":336,"address":[16676678,16676513,16676886,16675107,16676453],"length":1,"stats":{"Line":0}},{"line":337,"address":[16799040,16799268],"length":1,"stats":{"Line":0}},{"line":338,"address":[17278198],"length":1,"stats":{"Line":0}},{"line":339,"address":[16797471],"length":1,"stats":{"Line":0}},{"line":343,"address":[11905259],"length":1,"stats":{"Line":0}},{"line":344,"address":[16677720,16677787],"length":1,"stats":{"Line":0}},{"line":345,"address":[16677830,16677987],"length":1,"stats":{"Line":0}},{"line":346,"address":[24452837],"length":1,"stats":{"Line":0}},{"line":347,"address":[16794532],"length":1,"stats":{"Line":0}},{"line":353,"address":[11906930],"length":1,"stats":{"Line":0}},{"line":354,"address":[16760099,16760016],"length":1,"stats":{"Line":0}},{"line":355,"address":[24453620],"length":1,"stats":{"Line":0}},{"line":356,"address":[16760175],"length":1,"stats":{"Line":0}},{"line":358,"address":[16791408,16791952,16809513,16809647],"length":1,"stats":{"Line":0}},{"line":359,"address":[24454187],"length":1,"stats":{"Line":0}},{"line":362,"address":[16695395,16694799,16695137,16694992,16694895,16695108,16697921,16694848,16695925],"length":1,"stats":{"Line":0}},{"line":363,"address":[16695427,16695245,16695022],"length":1,"stats":{"Line":0}},{"line":364,"address":[16697961,16695752,16695665,16697936],"length":1,"stats":{"Line":0}},{"line":367,"address":[11285822],"length":1,"stats":{"Line":0}},{"line":368,"address":[16689196,16689279],"length":1,"stats":{"Line":0}},{"line":369,"address":[16895632],"length":1,"stats":{"Line":0}},{"line":371,"address":[16771897,16757201,16772031,16757745],"length":1,"stats":{"Line":0}},{"line":372,"address":[16757708],"length":1,"stats":{"Line":0}},{"line":375,"address":[16800947,16801120,16801143,16801827,16800873,16800912,16801031,16801366],"length":1,"stats":{"Line":0}},{"line":376,"address":[16897490,16897830,16897675],"length":1,"stats":{"Line":0}},{"line":377,"address":[16766595,16766514],"length":1,"stats":{"Line":0}},{"line":380,"address":[16801904,16802073,16802651,16801865,16802286,16801929,16802111,16802008],"length":1,"stats":{"Line":0}},{"line":381,"address":[24460427,24460530,24460371,24460654],"length":1,"stats":{"Line":0}},{"line":382,"address":[16685900,16685967],"length":1,"stats":{"Line":0}},{"line":385,"address":[16686080,16686110,16686238,16686510,16686261,16686041,16686173],"length":1,"stats":{"Line":0}},{"line":386,"address":[16693145],"length":1,"stats":{"Line":0}},{"line":389,"address":[16768095,16768144,16768179,16768832,16768261,16768344,16768367,16768571],"length":1,"stats":{"Line":0}},{"line":390,"address":[16805371,16805056,16805241],"length":1,"stats":{"Line":0}},{"line":393,"address":[16768928,16769045,16769368,16769128,16768879,16769151,16768963,16769629],"length":1,"stats":{"Line":0}},{"line":394,"address":[16769072,16769257,16769400],"length":1,"stats":{"Line":0}},{"line":397,"address":[16805048,16805071,16805549,16804799,16805288,16804883,16804848,16804965],"length":1,"stats":{"Line":0}},{"line":398,"address":[16763272,16762944,16763129],"length":1,"stats":{"Line":0}},{"line":401,"address":[24464623,24464275,24463935,24464884,24464310,24464016,24464160,24464051],"length":1,"stats":{"Line":0}},{"line":402,"address":[17286815,17286676,17286363],"length":1,"stats":{"Line":0}},{"line":405,"address":[16771496,16771934,16776526,16772474,16771755,16771568,16773342,16776118,16771615],"length":1,"stats":{"Line":0}},{"line":410,"address":[16807195],"length":1,"stats":{"Line":0}},{"line":412,"address":[16776560,16776592],"length":1,"stats":{"Line":0}},{"line":413,"address":[16695241,16695216],"length":1,"stats":{"Line":0}},{"line":415,"address":[16765259,16765362],"length":1,"stats":{"Line":0}},{"line":416,"address":[16772301],"length":1,"stats":{"Line":0}},{"line":419,"address":[16697588,16697049,16697770],"length":1,"stats":{"Line":0}},{"line":420,"address":[16766382,16765816],"length":1,"stats":{"Line":0}},{"line":421,"address":[16773034,16773138],"length":1,"stats":{"Line":0}},{"line":424,"address":[11936220],"length":1,"stats":{"Line":0}},{"line":425,"address":[16692528,16692069],"length":1,"stats":{"Line":0}},{"line":428,"address":[16692378,16692579,16690307],"length":1,"stats":{"Line":0}},{"line":429,"address":[16811105,16811209],"length":1,"stats":{"Line":0}},{"line":432,"address":[16811230],"length":1,"stats":{"Line":0}},{"line":433,"address":[16779321,16775241,16779455,16774556,16774728],"length":1,"stats":{"Line":0}},{"line":434,"address":[16810320],"length":1,"stats":{"Line":0}},{"line":437,"address":[16803032,16807414,16805795,16805689],"length":1,"stats":{"Line":0}},{"line":438,"address":[16701702],"length":1,"stats":{"Line":0}},{"line":439,"address":[16908027],"length":1,"stats":{"Line":0}},{"line":441,"address":[17291882],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":224},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","metrics.rs"],"content":"use crate::shared::config::BootstrapSource;\nuse crate::shared::metrics::{AtomicMetric, UNSET_TS, current_unix_ms, timestamp_to_option};\nuse crate::shared::validation::ValidationFailureKind;\nuse once_cell::sync::Lazy;\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::sync::Mutex;\nuse std::sync::atomic::{AtomicU64, Ordering};\n\nstatic JOIN_METRIC: AtomicMetric = AtomicMetric::new();\nstatic LEAVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic BROADCAST_METRIC: AtomicMetric = AtomicMetric::new();\nstatic RECEIVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic RECEIVE_FAILURES_BY_REASON: Lazy<Mutex<HashMap<ValidationFailureKind, u64>>> =\n    Lazy::new(|| Mutex::new(HashMap::new()));\nstatic MAINLINE_CONNECTION_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_ROUTING_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_RECONNECT_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_CONNECTED_PEERS: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_ENV_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_USER_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_BUNDLE_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_FALLBACK_COUNT: AtomicU64 = AtomicU64::new(0);\nstatic BOOTSTRAP_LAST_SOURCE: AtomicU64 = AtomicU64::new(BootstrapSource::None as u8 as u64);\nstatic BOOTSTRAP_LAST_MS: AtomicU64 = AtomicU64::new(UNSET_TS);\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricDetails {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\nfn to_gossip_details(metric: &AtomicMetric) -> GossipMetricDetails {\n    let snapshot = metric.snapshot();\n    GossipMetricDetails {\n        total: snapshot.successes,\n        failures: snapshot.failures,\n        last_success_ms: snapshot.last_success_ms,\n        last_failure_ms: snapshot.last_failure_ms,\n    }\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct ReceiveFailureBreakdown {\n    pub reason: String,\n    pub count: u64,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricsSnapshot {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetails,\n    pub leave_details: GossipMetricDetails,\n    pub broadcast_details: GossipMetricDetails,\n    pub receive_details: GossipMetricDetails,\n    pub receive_failures_by_reason: Vec<ReceiveFailureBreakdown>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct MainlineMetricsSnapshot {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n    pub bootstrap: BootstrapMetricsSnapshot,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct P2PMetricsSnapshot {\n    pub gossip: GossipMetricsSnapshot,\n    pub mainline: MainlineMetricsSnapshot,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct BootstrapMetricsSnapshot {\n    pub env_uses: u64,\n    pub user_uses: u64,\n    pub bundle_uses: u64,\n    pub fallback_uses: u64,\n    pub last_source: Option<String>,\n    pub last_applied_ms: Option<u64>,\n}\n\n#[inline]\npub fn record_join_success() {\n    JOIN_METRIC.record_success();\n}\n\npub fn record_join_failure() {\n    JOIN_METRIC.record_failure();\n}\n\npub fn record_leave_success() {\n    LEAVE_METRIC.record_success();\n}\n\npub fn record_leave_failure() {\n    LEAVE_METRIC.record_failure();\n}\n\npub fn record_broadcast_success() {\n    BROADCAST_METRIC.record_success();\n}\n\npub fn record_broadcast_failure() {\n    BROADCAST_METRIC.record_failure();\n}\n\npub fn record_receive_success() {\n    RECEIVE_METRIC.record_success();\n}\n\npub fn record_receive_failure() {\n    record_receive_failure_with_reason(ValidationFailureKind::Generic);\n}\n\npub fn record_receive_failure_with_reason(kind: ValidationFailureKind) {\n    RECEIVE_METRIC.record_failure();\n    if let Ok(mut map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        *map.entry(kind).or_insert(0) += 1;\n    }\n}\n\npub fn record_mainline_connection_success() {\n    MAINLINE_CONNECTION_METRIC.record_success();\n}\n\npub fn record_mainline_connection_failure() {\n    MAINLINE_CONNECTION_METRIC.record_failure();\n}\n\npub fn set_mainline_connected_peers(count: u64) {\n    MAINLINE_CONNECTED_PEERS.store(count, Ordering::Relaxed);\n}\n\npub fn record_mainline_route_success() {\n    MAINLINE_ROUTING_METRIC.record_success();\n}\n\npub fn record_mainline_route_failure() {\n    MAINLINE_ROUTING_METRIC.record_failure();\n}\n\npub fn record_mainline_reconnect_success() {\n    MAINLINE_RECONNECT_METRIC.record_success();\n}\n\npub fn record_mainline_reconnect_failure() {\n    MAINLINE_RECONNECT_METRIC.record_failure();\n}\n\npub fn record_bootstrap_source(source: BootstrapSource) {\n    match source {\n        BootstrapSource::Env => {\n            BOOTSTRAP_ENV_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::User => {\n            BOOTSTRAP_USER_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::Bundle => {\n            BOOTSTRAP_BUNDLE_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::Fallback => {\n            BOOTSTRAP_FALLBACK_COUNT.fetch_add(1, Ordering::Relaxed);\n        }\n        BootstrapSource::None => {}\n    }\n    BOOTSTRAP_LAST_SOURCE.store(source as u8 as u64, Ordering::Relaxed);\n    BOOTSTRAP_LAST_MS.store(current_unix_ms(), Ordering::Relaxed);\n}\n\npub fn reset_all() {\n    JOIN_METRIC.reset();\n    LEAVE_METRIC.reset();\n    BROADCAST_METRIC.reset();\n    RECEIVE_METRIC.reset();\n    if let Ok(mut map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        map.clear();\n    }\n    MAINLINE_CONNECTION_METRIC.reset();\n    MAINLINE_ROUTING_METRIC.reset();\n    MAINLINE_RECONNECT_METRIC.reset();\n    MAINLINE_CONNECTED_PEERS.store(0, Ordering::Relaxed);\n    BOOTSTRAP_ENV_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_USER_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_BUNDLE_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_FALLBACK_COUNT.store(0, Ordering::Relaxed);\n    BOOTSTRAP_LAST_SOURCE.store(BootstrapSource::None as u8 as u64, Ordering::Relaxed);\n    BOOTSTRAP_LAST_MS.store(UNSET_TS, Ordering::Relaxed);\n}\n\npub fn snapshot() -> GossipMetricsSnapshot {\n    let join_details = to_gossip_details(&JOIN_METRIC);\n    let leave_details = to_gossip_details(&LEAVE_METRIC);\n    let broadcast_details = to_gossip_details(&BROADCAST_METRIC);\n    let receive_details = to_gossip_details(&RECEIVE_METRIC);\n    let receive_failures_by_reason = if let Ok(map) = RECEIVE_FAILURES_BY_REASON.lock() {\n        map.iter()\n            .map(|(kind, count)| ReceiveFailureBreakdown {\n                reason: kind.as_str().to_string(),\n                count: *count,\n            })\n            .collect()\n    } else {\n        Vec::new()\n    };\n\n    GossipMetricsSnapshot {\n        joins: join_details.total,\n        leaves: leave_details.total,\n        broadcasts_sent: broadcast_details.total,\n        messages_received: receive_details.total,\n        join_details,\n        leave_details,\n        broadcast_details,\n        receive_details,\n        receive_failures_by_reason,\n    }\n}\n\npub fn mainline_snapshot() -> MainlineMetricsSnapshot {\n    let connection_details = MAINLINE_CONNECTION_METRIC.snapshot();\n    let routing_details = MAINLINE_ROUTING_METRIC.snapshot();\n    let reconnect_details = MAINLINE_RECONNECT_METRIC.snapshot();\n    let connected_peers = MAINLINE_CONNECTED_PEERS.load(Ordering::Relaxed);\n    let bootstrap = bootstrap_snapshot();\n\n    let connection_attempts = connection_details.successes + connection_details.failures;\n    let routing_attempts = routing_details.successes + routing_details.failures;\n    let routing_success_rate = if routing_attempts == 0 {\n        0.0\n    } else {\n        routing_details.successes as f64 / routing_attempts as f64\n    };\n    let reconnect_attempts = reconnect_details.successes + reconnect_details.failures;\n\n    MainlineMetricsSnapshot {\n        connected_peers,\n        connection_attempts,\n        connection_successes: connection_details.successes,\n        connection_failures: connection_details.failures,\n        connection_last_success_ms: connection_details.last_success_ms,\n        connection_last_failure_ms: connection_details.last_failure_ms,\n        routing_attempts,\n        routing_successes: routing_details.successes,\n        routing_failures: routing_details.failures,\n        routing_success_rate,\n        routing_last_success_ms: routing_details.last_success_ms,\n        routing_last_failure_ms: routing_details.last_failure_ms,\n        reconnect_attempts,\n        reconnect_successes: reconnect_details.successes,\n        reconnect_failures: reconnect_details.failures,\n        last_reconnect_success_ms: reconnect_details.last_success_ms,\n        last_reconnect_failure_ms: reconnect_details.last_failure_ms,\n        bootstrap,\n    }\n}\n\npub fn snapshot_full() -> P2PMetricsSnapshot {\n    P2PMetricsSnapshot {\n        gossip: snapshot(),\n        mainline: mainline_snapshot(),\n    }\n}\n\nfn bootstrap_snapshot() -> BootstrapMetricsSnapshot {\n    let last_source_code = BOOTSTRAP_LAST_SOURCE.load(Ordering::Relaxed);\n    let last_source = match last_source_code as u8 {\n        x if x == BootstrapSource::Env as u8 => Some(\"env\".to_string()),\n        x if x == BootstrapSource::User as u8 => Some(\"user\".to_string()),\n        x if x == BootstrapSource::Bundle as u8 => Some(\"bundle\".to_string()),\n        x if x == BootstrapSource::Fallback as u8 => Some(\"fallback\".to_string()),\n        _ => None,\n    };\n\n    BootstrapMetricsSnapshot {\n        env_uses: BOOTSTRAP_ENV_COUNT.load(Ordering::Relaxed),\n        user_uses: BOOTSTRAP_USER_COUNT.load(Ordering::Relaxed),\n        bundle_uses: BOOTSTRAP_BUNDLE_COUNT.load(Ordering::Relaxed),\n        fallback_uses: BOOTSTRAP_FALLBACK_COUNT.load(Ordering::Relaxed),\n        last_source,\n        last_applied_ms: timestamp_to_option(BOOTSTRAP_LAST_MS.load(Ordering::Relaxed)),\n    }\n}\n","traces":[{"line":15,"address":[15366178,15366160],"length":1,"stats":{"Line":2}},{"line":35,"address":[15269792],"length":1,"stats":{"Line":1}},{"line":36,"address":[22928146],"length":1,"stats":{"Line":1}},{"line":38,"address":[15269829],"length":1,"stats":{"Line":2}},{"line":39,"address":[22928170],"length":1,"stats":{"Line":2}},{"line":40,"address":[15159983],"length":1,"stats":{"Line":2}},{"line":41,"address":[15153209],"length":1,"stats":{"Line":2}},{"line":103,"address":[15234768],"length":1,"stats":{"Line":0}},{"line":104,"address":[15269889],"length":1,"stats":{"Line":0}},{"line":107,"address":[15227856],"length":1,"stats":{"Line":0}},{"line":108,"address":[15265969],"length":1,"stats":{"Line":0}},{"line":111,"address":[15153280],"length":1,"stats":{"Line":0}},{"line":112,"address":[15227873],"length":1,"stats":{"Line":0}},{"line":115,"address":[15153296],"length":1,"stats":{"Line":0}},{"line":116,"address":[15160081],"length":1,"stats":{"Line":0}},{"line":119,"address":[15266016],"length":1,"stats":{"Line":1}},{"line":120,"address":[15153313],"length":1,"stats":{"Line":1}},{"line":123,"address":[15227920],"length":1,"stats":{"Line":1}},{"line":124,"address":[15266033],"length":1,"stats":{"Line":1}},{"line":127,"address":[15160128],"length":1,"stats":{"Line":1}},{"line":128,"address":[15271633],"length":1,"stats":{"Line":1}},{"line":131,"address":[15153360],"length":1,"stats":{"Line":1}},{"line":132,"address":[15167121],"length":1,"stats":{"Line":1}},{"line":135,"address":[15272008,15271680],"length":1,"stats":{"Line":1}},{"line":136,"address":[21046063],"length":1,"stats":{"Line":1}},{"line":137,"address":[15160203],"length":1,"stats":{"Line":1}},{"line":138,"address":[15366627,15366546,15366720],"length":1,"stats":{"Line":2}},{"line":142,"address":[15167520],"length":1,"stats":{"Line":0}},{"line":143,"address":[15366833],"length":1,"stats":{"Line":0}},{"line":146,"address":[15167536],"length":1,"stats":{"Line":0}},{"line":147,"address":[21046401],"length":1,"stats":{"Line":0}},{"line":150,"address":[15272080],"length":1,"stats":{"Line":0}},{"line":151,"address":[15366876],"length":1,"stats":{"Line":0}},{"line":154,"address":[15366912],"length":1,"stats":{"Line":0}},{"line":155,"address":[15270481],"length":1,"stats":{"Line":0}},{"line":158,"address":[21046480],"length":1,"stats":{"Line":0}},{"line":159,"address":[15272145],"length":1,"stats":{"Line":0}},{"line":162,"address":[15266576],"length":1,"stats":{"Line":0}},{"line":163,"address":[15153873],"length":1,"stats":{"Line":0}},{"line":166,"address":[15160672],"length":1,"stats":{"Line":0}},{"line":167,"address":[15167649],"length":1,"stats":{"Line":0}},{"line":170,"address":[15160688],"length":1,"stats":{"Line":0}},{"line":171,"address":[15167675],"length":1,"stats":{"Line":0}},{"line":173,"address":[15235468],"length":1,"stats":{"Line":0}},{"line":176,"address":[15270617],"length":1,"stats":{"Line":0}},{"line":179,"address":[15367078],"length":1,"stats":{"Line":0}},{"line":182,"address":[15270675],"length":1,"stats":{"Line":0}},{"line":186,"address":[22929038],"length":1,"stats":{"Line":0}},{"line":187,"address":[22929069],"length":1,"stats":{"Line":0}},{"line":190,"address":[15236136,15235648],"length":1,"stats":{"Line":1}},{"line":191,"address":[15235652],"length":1,"stats":{"Line":1}},{"line":192,"address":[22929120],"length":1,"stats":{"Line":1}},{"line":193,"address":[21046780],"length":1,"stats":{"Line":1}},{"line":194,"address":[15167928],"length":1,"stats":{"Line":1}},{"line":195,"address":[21046804],"length":1,"stats":{"Line":1}},{"line":196,"address":[15367376,15367307],"length":1,"stats":{"Line":2}},{"line":198,"address":[15161160],"length":1,"stats":{"Line":2}},{"line":199,"address":[22929364],"length":1,"stats":{"Line":2}},{"line":200,"address":[15271040],"length":1,"stats":{"Line":2}},{"line":201,"address":[15229004],"length":1,"stats":{"Line":2}},{"line":202,"address":[21047043],"length":1,"stats":{"Line":2}},{"line":203,"address":[15267168],"length":1,"stats":{"Line":2}},{"line":204,"address":[15272778],"length":1,"stats":{"Line":2}},{"line":205,"address":[15229108],"length":1,"stats":{"Line":2}},{"line":206,"address":[15168302],"length":1,"stats":{"Line":2}},{"line":207,"address":[15271209],"length":1,"stats":{"Line":2}},{"line":210,"address":[15272944,15273645],"length":1,"stats":{"Line":1}},{"line":211,"address":[15267377],"length":1,"stats":{"Line":1}},{"line":212,"address":[21047298],"length":1,"stats":{"Line":2}},{"line":213,"address":[22929683],"length":1,"stats":{"Line":2}},{"line":214,"address":[15267431],"length":1,"stats":{"Line":2}},{"line":215,"address":[15168507],"length":1,"stats":{"Line":2}},{"line":216,"address":[15273211,15273108],"length":1,"stats":{"Line":2}},{"line":217,"address":[21047984,21048031,21048078],"length":1,"stats":{"Line":0}},{"line":218,"address":[15230057],"length":1,"stats":{"Line":0}},{"line":219,"address":[21048075],"length":1,"stats":{"Line":0}},{"line":223,"address":[15154858],"length":1,"stats":{"Line":0}},{"line":227,"address":[15368149],"length":1,"stats":{"Line":2}},{"line":228,"address":[15368154],"length":1,"stats":{"Line":2}},{"line":229,"address":[21047667],"length":1,"stats":{"Line":2}},{"line":230,"address":[15236615],"length":1,"stats":{"Line":2}},{"line":239,"address":[15268256,15269255],"length":1,"stats":{"Line":0}},{"line":240,"address":[15169342],"length":1,"stats":{"Line":0}},{"line":241,"address":[15155602],"length":1,"stats":{"Line":0}},{"line":242,"address":[15368694],"length":1,"stats":{"Line":0}},{"line":243,"address":[15162426],"length":1,"stats":{"Line":0}},{"line":244,"address":[15368758],"length":1,"stats":{"Line":0}},{"line":246,"address":[15169459,15169532],"length":1,"stats":{"Line":0}},{"line":247,"address":[15268545,15268561,15268448],"length":1,"stats":{"Line":0}},{"line":248,"address":[21048459,21048421],"length":1,"stats":{"Line":0}},{"line":249,"address":[15237395],"length":1,"stats":{"Line":0}},{"line":251,"address":[15169654],"length":1,"stats":{"Line":0}},{"line":253,"address":[15230566,15231122],"length":1,"stats":{"Line":0}},{"line":258,"address":[15369089],"length":1,"stats":{"Line":0}},{"line":259,"address":[21048602],"length":1,"stats":{"Line":0}},{"line":260,"address":[22931019],"length":1,"stats":{"Line":0}},{"line":261,"address":[15162853],"length":1,"stats":{"Line":0}},{"line":263,"address":[15272729],"length":1,"stats":{"Line":0}},{"line":264,"address":[15169857],"length":1,"stats":{"Line":0}},{"line":266,"address":[15237640],"length":1,"stats":{"Line":0}},{"line":267,"address":[15272776],"length":1,"stats":{"Line":0}},{"line":269,"address":[22931133],"length":1,"stats":{"Line":0}},{"line":270,"address":[15237690],"length":1,"stats":{"Line":0}},{"line":271,"address":[15230775],"length":1,"stats":{"Line":0}},{"line":272,"address":[15156209],"length":1,"stats":{"Line":0}},{"line":277,"address":[15269280,15269428],"length":1,"stats":{"Line":0}},{"line":279,"address":[15269296],"length":1,"stats":{"Line":0}},{"line":280,"address":[15170366],"length":1,"stats":{"Line":0}},{"line":284,"address":[22931728,22932631],"length":1,"stats":{"Line":0}},{"line":285,"address":[15275057],"length":1,"stats":{"Line":0}},{"line":286,"address":[15269511],"length":1,"stats":{"Line":0}},{"line":287,"address":[15269515],"length":1,"stats":{"Line":0}},{"line":288,"address":[15273600,15273540],"length":1,"stats":{"Line":0}},{"line":289,"address":[15170795],"length":1,"stats":{"Line":0}},{"line":290,"address":[15273773],"length":1,"stats":{"Line":0}},{"line":291,"address":[15269935],"length":1,"stats":{"Line":0}},{"line":295,"address":[15269626],"length":1,"stats":{"Line":0}},{"line":296,"address":[15270004],"length":1,"stats":{"Line":0}},{"line":297,"address":[22932311],"length":1,"stats":{"Line":0}},{"line":298,"address":[15231962],"length":1,"stats":{"Line":0}},{"line":300,"address":[15274079,15274163],"length":1,"stats":{"Line":0}}],"covered":47,"coverable":121},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","mod.rs"],"content":"pub mod bootstrap;\npub mod bootstrap_config;\npub mod dht_bootstrap;\npub mod dht_integration;\npub mod discovery_options;\npub mod event_distributor;\npub mod gossip_service;\npub mod iroh_gossip_service;\npub mod iroh_network_service;\npub mod metrics;\npub mod network_service;\npub mod utils;\n\npub use discovery_options::DiscoveryOptions;\npub use event_distributor::EventDistributor;\npub use gossip_service::GossipService;\npub use network_service::{NetworkService, NetworkStats, Peer};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","network_service.rs"],"content":"use crate::shared::{AppError, config::BootstrapSource};\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Peer {\n    pub id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkStats {\n    pub connected_peers: usize,\n    pub total_messages_sent: u64,\n    pub total_messages_received: u64,\n    pub bandwidth_up: u64,\n    pub bandwidth_down: u64,\n}\n\n#[async_trait]\npub trait NetworkService: Send + Sync {\n    // Type conversion helper for downcasting\n    fn as_any(&self) -> &dyn std::any::Any;\n\n    async fn connect(&self) -> Result<(), AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError>;\n    async fn add_peer(&self, address: &str) -> Result<(), AppError>;\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError>;\n    async fn get_stats(&self) -> Result<NetworkStats, AppError>;\n    async fn is_connected(&self) -> bool;\n    async fn get_node_id(&self) -> Result<String, AppError>;\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError>;\n\n    async fn join_dht_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn leave_dht_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast_dht(&self, _topic: &str, _message: Vec<u8>) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn apply_bootstrap_nodes(\n        &self,\n        _nodes: Vec<String>,\n        _source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","utils.rs"],"content":"use crate::shared::error::AppError;\nuse iroh::{EndpointAddr, EndpointId};\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\n#[derive(Debug, Clone)]\npub struct ParsedPeer {\n    pub node_id: EndpointId,\n    pub node_addr: Option<EndpointAddr>,\n}\n\npub fn parse_node_addr(value: &str) -> Result<EndpointAddr, AppError> {\n    let (node_part, addr_part) = value\n        .split_once('@')\n        .ok_or_else(|| AppError::P2PError(format!(\"Invalid node address format: {value}\")))?;\n\n    let node_id = EndpointId::from_str(node_part)\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n\n    let socket_addr: SocketAddr = addr_part\n        .parse()\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse socket address: {e}\")))?;\n\n    Ok(EndpointAddr::new(node_id).with_ip_addr(socket_addr))\n}\n\npub fn parse_peer_hint(value: &str) -> Result<ParsedPeer, AppError> {\n    if value.contains('@') {\n        let node_addr = parse_node_addr(value)?;\n        Ok(ParsedPeer {\n            node_id: node_addr.id,\n            node_addr: Some(node_addr),\n        })\n    } else {\n        let node_id = EndpointId::from_str(value)\n            .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n        Ok(ParsedPeer {\n            node_id,\n            node_addr: None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_parse_node_addr() {\n        let addr = parse_node_addr(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef@127.0.0.1:1234\",\n        )\n        .unwrap();\n        assert_eq!(addr.ip_addrs().count(), 1);\n    }\n\n    #[test]\n    fn test_parse_peer_hint_node_id() {\n        let node_id = EndpointId::from_str(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\",\n        )\n        .unwrap();\n        let parsed =\n            parse_peer_hint(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n                .unwrap();\n        assert_eq!(parsed.node_id, node_id);\n        assert!(parsed.node_addr.is_none());\n    }\n}\n","traces":[{"line":12,"address":[23136432],"length":1,"stats":{"Line":1}},{"line":13,"address":[23131212,23130875],"length":1,"stats":{"Line":1}},{"line":15,"address":[23950412,23951040,23951061],"length":1,"stats":{"Line":0}},{"line":17,"address":[23950475,23950656,23950326],"length":1,"stats":{"Line":2}},{"line":18,"address":[23131984,23132006,23131400],"length":1,"stats":{"Line":0}},{"line":20,"address":[23100128,23100273,23100589],"length":1,"stats":{"Line":2}},{"line":22,"address":[17273342,17273840,17273864],"length":1,"stats":{"Line":0}},{"line":24,"address":[23032577],"length":1,"stats":{"Line":1}},{"line":27,"address":[23138016],"length":1,"stats":{"Line":1}},{"line":28,"address":[23095048,23094379,23094735],"length":1,"stats":{"Line":2}},{"line":29,"address":[23095053,23094502,23094802],"length":1,"stats":{"Line":0}},{"line":30,"address":[23094935],"length":1,"stats":{"Line":0}},{"line":31,"address":[23027021],"length":1,"stats":{"Line":0}},{"line":32,"address":[23027085],"length":1,"stats":{"Line":0}},{"line":35,"address":[23101474,23101332,23101696],"length":1,"stats":{"Line":2}},{"line":36,"address":[23095120,23095142,23094737],"length":1,"stats":{"Line":0}},{"line":37,"address":[23951962],"length":1,"stats":{"Line":1}},{"line":39,"address":[23138306],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","cache_storage.rs"],"content":"use async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CacheEntry<T> {\n    pub data: T,\n    pub created_at: i64,\n    pub expires_at: Option<i64>,\n}\n\n#[async_trait]\npub trait CacheStorage: Send + Sync {\n    async fn set<T: Serialize + Send + Sync>(\n        &self,\n        key: &str,\n        value: T,\n        ttl: Option<Duration>,\n    ) -> Result<(), Box<dyn std::error::Error>>;\n    async fn get<T: for<'de> Deserialize<'de>>(\n        &self,\n        key: &str,\n    ) -> Result<Option<T>, Box<dyn std::error::Error>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn cleanup_expired(&self) -> Result<u32, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","file_storage.rs"],"content":"use async_trait::async_trait;\nuse std::path::{Path, PathBuf};\n\n#[async_trait]\npub trait FileStorage: Send + Sync {\n    async fn save_file(&self, path: &Path, data: &[u8]) -> Result<(), Box<dyn std::error::Error>>;\n    async fn read_file(&self, path: &Path) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn delete_file(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n    async fn file_exists(&self, path: &Path) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn list_files(\n        &self,\n        directory: &Path,\n    ) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>>;\n    async fn create_directory(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","group_key_store.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord, GroupKeyStore};\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nconst GROUP_KEY_INDEX_KEY: &str = \"group_key_index_v1\";\n\n#[derive(Debug, Serialize, Deserialize, Default)]\nstruct GroupKeyIndex {\n    version: u32,\n    entries: Vec<GroupKeyEntry>,\n}\n\npub struct SecureGroupKeyStore {\n    secure_storage: Arc<dyn SecureStorage>,\n}\n\nimpl SecureGroupKeyStore {\n    pub fn new(secure_storage: Arc<dyn SecureStorage>) -> Self {\n        Self { secure_storage }\n    }\n\n    fn storage_key(topic_id: &str, scope: &str, epoch: i64) -> String {\n        format!(\"group_key:{topic_id}:{scope}:{epoch}\")\n    }\n\n    async fn load_index(&self) -> Result<GroupKeyIndex, AppError> {\n        let Some(raw) = self.secure_storage.retrieve(GROUP_KEY_INDEX_KEY).await? else {\n            return Ok(GroupKeyIndex::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_index(&self, index: &GroupKeyIndex) -> Result<(), AppError> {\n        let json = serde_json::to_string(index)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(GROUP_KEY_INDEX_KEY, &json)\n            .await?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl GroupKeyStore for SecureGroupKeyStore {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n        let key = Self::storage_key(&record.topic_id, &record.scope, record.epoch);\n        self.secure_storage.store(&key, &record.key_b64).await?;\n\n        let mut index = self.load_index().await?;\n        let now = Utc::now().timestamp();\n        let mut updated = false;\n        for entry in index.entries.iter_mut() {\n            if entry.topic_id == record.topic_id\n                && entry.scope == record.scope\n                && entry.epoch == record.epoch\n            {\n                entry.stored_at = now;\n                updated = true;\n                break;\n            }\n        }\n        if !updated {\n            index.entries.push(GroupKeyEntry {\n                topic_id: record.topic_id.clone(),\n                scope: record.scope.clone(),\n                epoch: record.epoch,\n                stored_at: now,\n            });\n        }\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(&index).await?;\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let key = Self::storage_key(topic_id, scope, epoch);\n        let Some(value) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let stored_at = Utc::now().timestamp();\n        Ok(Some(GroupKeyRecord {\n            topic_id: topic_id.to_string(),\n            scope: scope.to_string(),\n            epoch,\n            key_b64: value,\n            stored_at,\n        }))\n    }\n\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let index = self.load_index().await?;\n        let mut latest_epoch = None;\n        for entry in index.entries.iter() {\n            if entry.topic_id == topic_id && entry.scope == scope {\n                latest_epoch = match latest_epoch {\n                    Some(epoch) if epoch >= entry.epoch => Some(epoch),\n                    _ => Some(entry.epoch),\n                };\n            }\n        }\n        let Some(epoch) = latest_epoch else {\n            return Ok(None);\n        };\n        self.get_key(topic_id, scope, epoch).await\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        let index = self.load_index().await?;\n        Ok(index.entries)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::storage::secure_storage::DefaultSecureStorage;\n\n    #[tokio::test]\n    async fn store_and_load_group_key_index() {\n        let secure = Arc::new(DefaultSecureStorage::new());\n        let store = SecureGroupKeyStore::new(secure);\n        let record = GroupKeyRecord {\n            topic_id: \"kukuri:topic1\".to_string(),\n            scope: \"friend\".to_string(),\n            epoch: 3,\n            key_b64: \"dGVzdGtleQ==\".to_string(),\n            stored_at: Utc::now().timestamp(),\n        };\n\n        store.store_key(record.clone()).await.expect(\"store key\");\n\n        let loaded = store\n            .get_key(&record.topic_id, &record.scope, record.epoch)\n            .await\n            .expect(\"load key\");\n        assert!(loaded.is_some());\n        let index = store.list_keys().await.expect(\"list keys\");\n        assert_eq!(index.len(), 1);\n        assert_eq!(index[0].epoch, 3);\n    }\n}\n","traces":[{"line":22,"address":[18985696],"length":1,"stats":{"Line":1}},{"line":26,"address":[18978800],"length":1,"stats":{"Line":1}},{"line":27,"address":[19022538],"length":1,"stats":{"Line":1}},{"line":30,"address":[18918291,18918240,18918581,18918256,18918248,18919308,18918378,18918418],"length":1,"stats":{"Line":4}},{"line":31,"address":[11666468],"length":1,"stats":{"Line":2}},{"line":32,"address":[19023850],"length":1,"stats":{"Line":1}},{"line":34,"address":[18905347,18905666,18905438,18905648],"length":1,"stats":{"Line":2}},{"line":37,"address":[18987360,18987341,18988599,18987575,18988170,18987407,18987328,18987532],"length":1,"stats":{"Line":4}},{"line":38,"address":[18912886,18912777,18913378,18913106],"length":1,"stats":{"Line":2}},{"line":39,"address":[18906274,18907106,18907088],"length":1,"stats":{"Line":0}},{"line":40,"address":[19022890,19023413,19023667,19023187,19023116,19023527],"length":1,"stats":{"Line":5}},{"line":41,"address":[18906427],"length":1,"stats":{"Line":1}},{"line":42,"address":[13161299,13161119,13160346,13160867,13160986,13160820],"length":1,"stats":{"Line":3}},{"line":43,"address":[18988481],"length":1,"stats":{"Line":1}},{"line":49,"address":[11868676],"length":1,"stats":{"Line":4}},{"line":50,"address":[19091817,19091702],"length":1,"stats":{"Line":2}},{"line":51,"address":[19056116,19055145,19055594,19054626,19055267,19055932],"length":1,"stats":{"Line":2}},{"line":53,"address":[11275758],"length":1,"stats":{"Line":2}},{"line":54,"address":[19056660,19056502],"length":1,"stats":{"Line":2}},{"line":55,"address":[19091817],"length":1,"stats":{"Line":1}},{"line":56,"address":[13229489,13229698],"length":1,"stats":{"Line":1}},{"line":57,"address":[18975415],"length":1,"stats":{"Line":0}},{"line":58,"address":[18982240],"length":1,"stats":{"Line":0}},{"line":59,"address":[18982285],"length":1,"stats":{"Line":0}},{"line":61,"address":[19188608],"length":1,"stats":{"Line":0}},{"line":62,"address":[18982324],"length":1,"stats":{"Line":0}},{"line":66,"address":[24085051],"length":1,"stats":{"Line":1}},{"line":67,"address":[19050145,19050316],"length":1,"stats":{"Line":2}},{"line":68,"address":[19092215],"length":1,"stats":{"Line":1}},{"line":69,"address":[18989384],"length":1,"stats":{"Line":1}},{"line":70,"address":[19188781],"length":1,"stats":{"Line":1}},{"line":74,"address":[19050190],"length":1,"stats":{"Line":1}},{"line":75,"address":[19057355],"length":1,"stats":{"Line":1}},{"line":77,"address":[11899632],"length":1,"stats":{"Line":1}},{"line":78,"address":[18976259],"length":1,"stats":{"Line":1}},{"line":81,"address":[19095022,19095088,19095358,19095773,19096945,19095240,19095126],"length":1,"stats":{"Line":5}},{"line":87,"address":[19093840],"length":1,"stats":{"Line":1}},{"line":88,"address":[11795156],"length":1,"stats":{"Line":2}},{"line":89,"address":[18978671],"length":1,"stats":{"Line":0}},{"line":91,"address":[19096395,19096310],"length":1,"stats":{"Line":2}},{"line":92,"address":[19191376],"length":1,"stats":{"Line":1}},{"line":93,"address":[19090846],"length":1,"stats":{"Line":1}},{"line":94,"address":[19052769],"length":1,"stats":{"Line":1}},{"line":95,"address":[19191332],"length":1,"stats":{"Line":1}},{"line":96,"address":[18978272],"length":1,"stats":{"Line":1}},{"line":101,"address":[18992671,18992788,18993182,18992559,18992624,18992933,18994489,18994830],"length":1,"stats":{"Line":0}},{"line":106,"address":[18986238,18986634,18985842,18986065,18987508],"length":1,"stats":{"Line":0}},{"line":107,"address":[19061318],"length":1,"stats":{"Line":0}},{"line":108,"address":[19192886,19193065,19193226],"length":1,"stats":{"Line":0}},{"line":109,"address":[19054767,19055097,19055311],"length":1,"stats":{"Line":0}},{"line":110,"address":[19093391,19093263],"length":1,"stats":{"Line":0}},{"line":111,"address":[18980579,18980647],"length":1,"stats":{"Line":0}},{"line":112,"address":[13234925],"length":1,"stats":{"Line":0}},{"line":116,"address":[18980201,18980137],"length":1,"stats":{"Line":0}},{"line":117,"address":[19193355],"length":1,"stats":{"Line":0}},{"line":119,"address":[12009426],"length":1,"stats":{"Line":0}},{"line":122,"address":[19097890,19097737,19097996,19097776,19097811,19098790,19098698,19098216],"length":1,"stats":{"Line":5}},{"line":123,"address":[19194536,19194349,19195135,19194680],"length":1,"stats":{"Line":1}},{"line":124,"address":[13236232],"length":1,"stats":{"Line":1}}],"covered":41,"coverable":59},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","join_request_store.rs"],"content":"use crate::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nconst JOIN_REQUEST_INDEX_PREFIX: &str = \"join_request_index_v1\";\nconst INVITE_USAGE_PREFIX: &str = \"invite_usage_v1\";\n\n#[derive(Debug, Serialize, Deserialize, Default)]\nstruct JoinRequestIndex {\n    version: u32,\n    event_ids: Vec<String>,\n}\n\npub struct SecureJoinRequestStore {\n    secure_storage: Arc<dyn SecureStorage>,\n}\n\nimpl SecureJoinRequestStore {\n    pub fn new(secure_storage: Arc<dyn SecureStorage>) -> Self {\n        Self { secure_storage }\n    }\n\n    fn index_key(owner_pubkey: &str) -> String {\n        format!(\"{JOIN_REQUEST_INDEX_PREFIX}:{owner_pubkey}\")\n    }\n\n    fn storage_key(owner_pubkey: &str, event_id: &str) -> String {\n        format!(\"join_request:{owner_pubkey}:{event_id}\")\n    }\n\n    fn invite_usage_key(owner_pubkey: &str, invite_event_id: &str) -> String {\n        format!(\"{INVITE_USAGE_PREFIX}:{owner_pubkey}:{invite_event_id}\")\n    }\n\n    async fn load_index(&self, owner_pubkey: &str) -> Result<JoinRequestIndex, AppError> {\n        let key = Self::index_key(owner_pubkey);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(JoinRequestIndex::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_index(\n        &self,\n        owner_pubkey: &str,\n        index: &JoinRequestIndex,\n    ) -> Result<(), AppError> {\n        let key = Self::index_key(owner_pubkey);\n        let json = serde_json::to_string(index)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl JoinRequestStore for SecureJoinRequestStore {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError> {\n        let key = Self::storage_key(owner_pubkey, &record.event.id);\n        let json = serde_json::to_string(&record)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n\n        let mut index = self.load_index(owner_pubkey).await?;\n        if !index.event_ids.iter().any(|id| id == &record.event.id) {\n            index.event_ids.push(record.event.id.clone());\n        }\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(owner_pubkey, &index).await?;\n        Ok(())\n    }\n\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let mut index = self.load_index(owner_pubkey).await?;\n        let mut records = Vec::with_capacity(index.event_ids.len());\n        let mut retained_ids = Vec::with_capacity(index.event_ids.len());\n\n        for event_id in index.event_ids.iter() {\n            let key = Self::storage_key(owner_pubkey, event_id);\n            if let Some(raw) = self.secure_storage.retrieve(&key).await? {\n                match serde_json::from_str::<JoinRequestRecord>(&raw) {\n                    Ok(record) => {\n                        retained_ids.push(event_id.clone());\n                        records.push(record);\n                    }\n                    Err(_) => {\n                        let _ = self.secure_storage.delete(&key).await;\n                    }\n                }\n            }\n        }\n\n        if retained_ids.len() != index.event_ids.len() {\n            index.event_ids = retained_ids;\n            if index.version == 0 {\n                index.version = 1;\n            }\n            self.save_index(owner_pubkey, &index).await?;\n        }\n\n        records.sort_by(|a, b| b.received_at.cmp(&a.received_at));\n        Ok(records)\n    }\n\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError> {\n        let key = Self::storage_key(owner_pubkey, event_id);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let record: JoinRequestRecord = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(record))\n    }\n\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n        let key = Self::storage_key(owner_pubkey, event_id);\n        let _ = self.secure_storage.delete(&key).await;\n\n        let mut index = self.load_index(owner_pubkey).await?;\n        index.event_ids.retain(|id| id != event_id);\n        if index.version == 0 {\n            index.version = 1;\n        }\n        self.save_index(owner_pubkey, &index).await?;\n        Ok(())\n    }\n\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError> {\n        let key = Self::invite_usage_key(owner_pubkey, invite_event_id);\n        let Some(raw) = self.secure_storage.retrieve(&key).await? else {\n            return Ok(None);\n        };\n        let record: InviteUsageRecord = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(record))\n    }\n\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError> {\n        let key = Self::invite_usage_key(owner_pubkey, &record.invite_event_id);\n        let json = serde_json::to_string(&record)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage.store(&key, &json).await?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::Event;\n    use crate::infrastructure::storage::secure_storage::DefaultSecureStorage;\n    use chrono::Utc;\n\n    #[tokio::test]\n    async fn store_and_load_join_request() {\n        let storage = Arc::new(DefaultSecureStorage::new());\n        let store = SecureJoinRequestStore::new(storage);\n\n        let event = Event {\n            id: \"event-1\".to_string(),\n            pubkey: \"pubkey-req\".to_string(),\n            created_at: Utc::now(),\n            kind: 39022,\n            tags: vec![],\n            content: \"{}\".to_string(),\n            sig: \"sig\".to_string(),\n        };\n        let record = JoinRequestRecord {\n            event: event.clone(),\n            topic_id: \"kukuri:topic1\".to_string(),\n            scope: \"friend\".to_string(),\n            requester_pubkey: \"pubkey-req\".to_string(),\n            target_pubkey: None,\n            requested_at: Some(100),\n            received_at: Utc::now().timestamp(),\n            invite_event_json: None,\n        };\n\n        store\n            .upsert_request(\"owner\", record.clone())\n            .await\n            .expect(\"store\");\n\n        let loaded = store.get_request(\"owner\", &event.id).await.expect(\"get\");\n        assert!(loaded.is_some());\n        assert_eq!(loaded.unwrap().event.id, event.id);\n\n        let list = store.list_requests(\"owner\").await.expect(\"list\");\n        assert_eq!(list.len(), 1);\n\n        store\n            .delete_request(\"owner\", &event.id)\n            .await\n            .expect(\"delete\");\n        let list = store.list_requests(\"owner\").await.expect(\"list empty\");\n        assert!(list.is_empty());\n    }\n\n    #[tokio::test]\n    async fn store_and_load_invite_usage() {\n        let storage = Arc::new(DefaultSecureStorage::new());\n        let store = SecureJoinRequestStore::new(storage);\n        let record = InviteUsageRecord {\n            invite_event_id: \"invite-1\".to_string(),\n            max_uses: 2,\n            used_count: 1,\n            last_used_at: Utc::now().timestamp(),\n        };\n\n        store\n            .upsert_invite_usage(\"owner\", record.clone())\n            .await\n            .expect(\"store\");\n\n        let loaded = store\n            .get_invite_usage(\"owner\", \"invite-1\")\n            .await\n            .expect(\"get\");\n        assert!(loaded.is_some());\n        assert_eq!(loaded.unwrap().used_count, 1);\n    }\n}\n","traces":[{"line":24,"address":[24662016],"length":1,"stats":{"Line":1}},{"line":28,"address":[24722880],"length":1,"stats":{"Line":1}},{"line":29,"address":[24766602],"length":1,"stats":{"Line":1}},{"line":32,"address":[19319456],"length":1,"stats":{"Line":1}},{"line":33,"address":[24723108],"length":1,"stats":{"Line":1}},{"line":36,"address":[24766976],"length":1,"stats":{"Line":1}},{"line":37,"address":[24648724],"length":1,"stats":{"Line":1}},{"line":40,"address":[24649214,24649174,24650280,24648992,24648962,24648944,24649036,24649504],"length":1,"stats":{"Line":4}},{"line":41,"address":[24761855],"length":1,"stats":{"Line":1}},{"line":42,"address":[11790660],"length":1,"stats":{"Line":2}},{"line":43,"address":[24657081],"length":1,"stats":{"Line":1}},{"line":45,"address":[24768704,24768333,24768426,24768722],"length":1,"stats":{"Line":2}},{"line":48,"address":[19321504],"length":1,"stats":{"Line":1}},{"line":53,"address":[24657604],"length":1,"stats":{"Line":1}},{"line":54,"address":[24763709,24763645,24764272,24763938],"length":1,"stats":{"Line":2}},{"line":55,"address":[24651186,24652112,24652130],"length":1,"stats":{"Line":0}},{"line":56,"address":[11577782],"length":1,"stats":{"Line":2}},{"line":57,"address":[24864981],"length":1,"stats":{"Line":1}},{"line":63,"address":[19600386],"length":1,"stats":{"Line":4}},{"line":68,"address":[24879857,24880008],"length":1,"stats":{"Line":2}},{"line":69,"address":[24768526,24769247,24768853,24768611],"length":1,"stats":{"Line":2}},{"line":70,"address":[24880309,24882960,24882978],"length":1,"stats":{"Line":0}},{"line":71,"address":[11825071],"length":1,"stats":{"Line":2}},{"line":73,"address":[11838854],"length":1,"stats":{"Line":2}},{"line":74,"address":[24976652,24977917,24976467,24977904],"length":1,"stats":{"Line":2}},{"line":75,"address":[24777435,24777507],"length":1,"stats":{"Line":2}},{"line":77,"address":[24845243],"length":1,"stats":{"Line":1}},{"line":78,"address":[19556055],"length":1,"stats":{"Line":1}},{"line":80,"address":[11906640],"length":1,"stats":{"Line":1}},{"line":81,"address":[24777974],"length":1,"stats":{"Line":1}},{"line":84,"address":[24846496,24851439,24846684,24846871,24846431,24847118,24846543,24848102],"length":1,"stats":{"Line":5}},{"line":85,"address":[24771978,24772414,24772786,24772253,24773361],"length":1,"stats":{"Line":1}},{"line":86,"address":[24766154,24765972],"length":1,"stats":{"Line":2}},{"line":87,"address":[24847817,24847719],"length":1,"stats":{"Line":2}},{"line":89,"address":[24882982,24883881,24883081,24883813],"length":1,"stats":{"Line":4}},{"line":90,"address":[19559913,19559401],"length":1,"stats":{"Line":2}},{"line":91,"address":[19597032],"length":1,"stats":{"Line":2}},{"line":92,"address":[24981746,24981675],"length":1,"stats":{"Line":2}},{"line":93,"address":[24850253],"length":1,"stats":{"Line":1}},{"line":94,"address":[24850423,24850298],"length":1,"stats":{"Line":2}},{"line":95,"address":[24843521],"length":1,"stats":{"Line":1}},{"line":98,"address":[24766939,24769082,24766628,24765236,24768821],"length":1,"stats":{"Line":0}},{"line":104,"address":[19021627,19023876,19021514],"length":1,"stats":{"Line":2}},{"line":105,"address":[24781173],"length":1,"stats":{"Line":0}},{"line":106,"address":[24767592],"length":1,"stats":{"Line":0}},{"line":107,"address":[24884246],"length":1,"stats":{"Line":0}},{"line":109,"address":[19597079],"length":1,"stats":{"Line":0}},{"line":112,"address":[24844704,24841963,24844270,24844672],"length":1,"stats":{"Line":2}},{"line":113,"address":[24776473],"length":1,"stats":{"Line":1}},{"line":116,"address":[24887153,24888556,24886819,24886927,24887569,24887029,24888606,24886880],"length":1,"stats":{"Line":5}},{"line":121,"address":[24887273],"length":1,"stats":{"Line":1}},{"line":122,"address":[19562993,19564011,19562467,19562720,19562817],"length":1,"stats":{"Line":2}},{"line":123,"address":[24884679],"length":1,"stats":{"Line":0}},{"line":125,"address":[24778258,24778617,24778351],"length":1,"stats":{"Line":2}},{"line":126,"address":[24853305,24853552,24853570],"length":1,"stats":{"Line":0}},{"line":127,"address":[24771739],"length":1,"stats":{"Line":1}},{"line":130,"address":[24888879,24891118,24888944,24889233,24889626,24888982,24889992,24889079],"length":1,"stats":{"Line":5}},{"line":131,"address":[24854218],"length":1,"stats":{"Line":1}},{"line":132,"address":[24885437,24885538,24885170,24885722],"length":1,"stats":{"Line":2}},{"line":134,"address":[11831525],"length":1,"stats":{"Line":1}},{"line":135,"address":[24773692,24774526,24774512],"length":1,"stats":{"Line":3}},{"line":136,"address":[24787624],"length":1,"stats":{"Line":1}},{"line":137,"address":[24890521],"length":1,"stats":{"Line":0}},{"line":139,"address":[19564486,19566239,19565819,19565965],"length":1,"stats":{"Line":1}},{"line":140,"address":[24887017],"length":1,"stats":{"Line":1}},{"line":143,"address":[24891340,24891454,24891575,24891296,24891235,24891973,24893073,24893023],"length":1,"stats":{"Line":5}},{"line":148,"address":[19029356],"length":1,"stats":{"Line":1}},{"line":149,"address":[11911636],"length":1,"stats":{"Line":2}},{"line":150,"address":[19030746],"length":1,"stats":{"Line":0}},{"line":152,"address":[24892524,24892940,24892617],"length":1,"stats":{"Line":2}},{"line":153,"address":[24783280,24783036,24783298],"length":1,"stats":{"Line":0}},{"line":154,"address":[19567977],"length":1,"stats":{"Line":1}},{"line":157,"address":[11847904],"length":1,"stats":{"Line":4}},{"line":162,"address":[19569045,19569180],"length":1,"stats":{"Line":2}},{"line":163,"address":[24990753,24990439,24991102,24990518],"length":1,"stats":{"Line":2}},{"line":164,"address":[24860304,24860322,24859153],"length":1,"stats":{"Line":0}},{"line":165,"address":[24852195,24852682,24851567,24852387,24853006],"length":1,"stats":{"Line":2}},{"line":166,"address":[24891084],"length":1,"stats":{"Line":1}}],"covered":65,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","mod.rs"],"content":"pub mod cache_storage;\npub mod file_storage;\npub mod group_key_store;\npub mod join_request_store;\npub mod profile_avatar_store;\npub mod secure_storage;\n\npub use group_key_store::SecureGroupKeyStore;\npub use join_request_store::SecureJoinRequestStore;\npub use secure_storage::SecureStorage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","profile_avatar_store.rs"],"content":"use std::{\n    collections::HashMap,\n    path::{Path, PathBuf},\n};\n\nuse serde::{Deserialize, Serialize};\nuse tokio::{fs, sync::Mutex};\n\nuse crate::{domain::entities::ProfileAvatarDocEntry, shared::AppError};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct ProfileAvatarDocument {\n    next_version: u64,\n    entries: HashMap<String, ProfileAvatarDocEntry>,\n}\n\nimpl Default for ProfileAvatarDocument {\n    fn default() -> Self {\n        Self {\n            next_version: 1,\n            entries: HashMap::new(),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProfileAvatarSyncPackage {\n    pub entry: ProfileAvatarDocEntry,\n    pub encrypted_blob: Vec<u8>,\n}\n\npub struct ProfileAvatarStore {\n    root_dir: PathBuf,\n    blobs_dir: PathBuf,\n    doc_path: PathBuf,\n    document: Mutex<ProfileAvatarDocument>,\n}\n\nimpl ProfileAvatarStore {\n    pub async fn new(root_dir: PathBuf) -> Result<Self, AppError> {\n        fs::create_dir_all(&root_dir).await.map_err(|err| {\n            AppError::Storage(format!(\"Failed to create profile avatar dir: {err}\"))\n        })?;\n\n        let blobs_dir = root_dir.join(\"blobs\");\n        fs::create_dir_all(&blobs_dir)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to create blobs dir: {err}\")))?;\n\n        let doc_path = root_dir.join(\"doc.json\");\n        let document = if fs::metadata(&doc_path).await.is_ok() {\n            let bytes = fs::read(&doc_path)\n                .await\n                .map_err(|err| AppError::Storage(format!(\"Failed to read avatar doc: {err}\")))?;\n            if bytes.is_empty() {\n                ProfileAvatarDocument::default()\n            } else {\n                serde_json::from_slice(&bytes).map_err(|err| {\n                    AppError::DeserializationError(format!(\"Failed to parse avatar doc: {err}\"))\n                })?\n            }\n        } else {\n            ProfileAvatarDocument::default()\n        };\n\n        Ok(Self {\n            root_dir,\n            blobs_dir,\n            doc_path,\n            document: Mutex::new(document),\n        })\n    }\n\n    pub fn root_dir(&self) -> &Path {\n        &self.root_dir\n    }\n\n    pub async fn write_encrypted_blob(\n        &self,\n        blob_hash: &str,\n        data: &[u8],\n    ) -> Result<PathBuf, AppError> {\n        let path = self.blobs_dir.join(blob_hash);\n        fs::write(&path, data)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to write encrypted blob: {err}\")))?;\n        Ok(path)\n    }\n\n    pub async fn read_encrypted_blob(&self, blob_hash: &str) -> Result<Vec<u8>, AppError> {\n        let path = self.blobs_dir.join(blob_hash);\n        fs::read(&path)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to read encrypted blob: {err}\")))\n    }\n\n    pub async fn encrypted_blob_exists(&self, blob_hash: &str) -> bool {\n        fs::metadata(self.blobs_dir.join(blob_hash)).await.is_ok()\n    }\n\n    pub async fn upsert_entry(\n        &self,\n        mut entry: ProfileAvatarDocEntry,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        let mut document = self.document.lock().await;\n        let version = document.next_version;\n        document.next_version += 1;\n        entry.version = version;\n        document.entries.insert(entry.npub.clone(), entry.clone());\n        self.persist(&document).await?;\n        Ok(entry)\n    }\n\n    pub async fn get_entry(&self, npub: &str) -> Result<Option<ProfileAvatarDocEntry>, AppError> {\n        let document = self.document.lock().await;\n        Ok(document.entries.get(npub).cloned())\n    }\n\n    pub async fn export_sync_package(\n        &self,\n        npub: &str,\n    ) -> Result<Option<ProfileAvatarSyncPackage>, AppError> {\n        let entry = {\n            let document = self.document.lock().await;\n            match document.entries.get(npub) {\n                Some(entry) => entry.clone(),\n                None => return Ok(None),\n            }\n        };\n        let blob = self.read_encrypted_blob(&entry.blob_hash).await?;\n        Ok(Some(ProfileAvatarSyncPackage {\n            entry,\n            encrypted_blob: blob,\n        }))\n    }\n\n    pub async fn import_sync_package(\n        &self,\n        package: ProfileAvatarSyncPackage,\n    ) -> Result<ProfileAvatarDocEntry, AppError> {\n        let ProfileAvatarSyncPackage {\n            entry,\n            encrypted_blob,\n        } = package;\n\n        // 既存エントリのバージョンより新しい場合のみ更新\n        let mut document = self.document.lock().await;\n        let should_update = match document.entries.get(&entry.npub) {\n            Some(current) => entry.version > current.version,\n            None => true,\n        };\n\n        if !should_update {\n            return Ok(document\n                .entries\n                .get(&entry.npub)\n                .cloned()\n                .expect(\"entry must exist\"));\n        }\n\n        self.write_encrypted_blob(&entry.blob_hash, &encrypted_blob)\n            .await?;\n        document.entries.insert(entry.npub.clone(), entry.clone());\n        document.next_version = document.next_version.max(entry.version + 1);\n        self.persist(&document).await?;\n        Ok(entry)\n    }\n\n    pub async fn entries_snapshot(&self) -> Vec<ProfileAvatarDocEntry> {\n        let document = self.document.lock().await;\n        document.entries.values().cloned().collect()\n    }\n\n    async fn persist(&self, document: &ProfileAvatarDocument) -> Result<(), AppError> {\n        let json = serde_json::to_vec_pretty(document).map_err(|err| {\n            AppError::SerializationError(format!(\"Failed to serialize avatar doc: {err}\"))\n        })?;\n        fs::write(&self.doc_path, json)\n            .await\n            .map_err(|err| AppError::Storage(format!(\"Failed to persist avatar doc: {err}\")))\n    }\n}\n","traces":[{"line":18,"address":[13986992],"length":1,"stats":{"Line":2}},{"line":21,"address":[19739486],"length":1,"stats":{"Line":2}},{"line":40,"address":[19807829,19807347,19808576,19807344,19807376,19807590,19811328,19807423],"length":1,"stats":{"Line":8}},{"line":41,"address":[19949952,19947028,19946341,19946221,19946730,19946036,19946100,19950183],"length":1,"stats":{"Line":5}},{"line":42,"address":[19743751,19743686],"length":1,"stats":{"Line":0}},{"line":45,"address":[12980666,12980831],"length":1,"stats":{"Line":4}},{"line":46,"address":[19815878,19815315,19815730,19816173,19815632,19815418],"length":1,"stats":{"Line":8}},{"line":47,"address":[19733049,19733871,19733993,19733928,19734133],"length":1,"stats":{"Line":8}},{"line":48,"address":[19811728,19808902,19811750],"length":1,"stats":{"Line":0}},{"line":50,"address":[19852569,19852732],"length":1,"stats":{"Line":4}},{"line":51,"address":[11618839],"length":1,"stats":{"Line":6}},{"line":52,"address":[19852276,19851941,19853325,19852172,19851999,19852493],"length":1,"stats":{"Line":0}},{"line":53,"address":[11618862],"length":1,"stats":{"Line":0}},{"line":54,"address":[19818912,19817325,19818934],"length":1,"stats":{"Line":0}},{"line":55,"address":[13990461,13990083,13990242],"length":1,"stats":{"Line":0}},{"line":56,"address":[19810564,19810900],"length":1,"stats":{"Line":0}},{"line":58,"address":[13991952,13990248,13992183,13990511,13990307],"length":1,"stats":{"Line":0}},{"line":59,"address":[19950807,19950742],"length":1,"stats":{"Line":0}},{"line":63,"address":[12982079],"length":1,"stats":{"Line":2}},{"line":66,"address":[19810946],"length":1,"stats":{"Line":2}},{"line":67,"address":[19809660],"length":1,"stats":{"Line":2}},{"line":68,"address":[19748872],"length":1,"stats":{"Line":2}},{"line":69,"address":[13989460],"length":1,"stats":{"Line":2}},{"line":70,"address":[19948272],"length":1,"stats":{"Line":2}},{"line":74,"address":[19950976],"length":1,"stats":{"Line":0}},{"line":75,"address":[19812501],"length":1,"stats":{"Line":0}},{"line":78,"address":[19850624],"length":1,"stats":{"Line":2}},{"line":83,"address":[19856454,19856582],"length":1,"stats":{"Line":4}},{"line":84,"address":[19851407,19851625,19851328,19851028,19851128],"length":1,"stats":{"Line":8}},{"line":85,"address":[19388953],"length":1,"stats":{"Line":8}},{"line":86,"address":[19739062,19739040,19738873],"length":1,"stats":{"Line":0}},{"line":87,"address":[19745558],"length":1,"stats":{"Line":2}},{"line":90,"address":[19852000,19852018,19852083,19852479,19852048,19852249,19852797,19852209],"length":1,"stats":{"Line":8}},{"line":91,"address":[19952681,19952556],"length":1,"stats":{"Line":4}},{"line":92,"address":[13994030,13993933,13994305,13994223],"length":1,"stats":{"Line":8}},{"line":93,"address":[11608068],"length":1,"stats":{"Line":8}},{"line":94,"address":[19821632,19821654],"length":1,"stats":{"Line":0}},{"line":97,"address":[19822087,19822672,19821888,19821961,19822316,19821936,19821906,19822127],"length":1,"stats":{"Line":0}},{"line":98,"address":[19953666,19953900,19953618,19953743],"length":1,"stats":{"Line":0}},{"line":101,"address":[19954240],"length":1,"stats":{"Line":2}},{"line":105,"address":[19741581,19741440,19741505,19741704],"length":1,"stats":{"Line":4}},{"line":106,"address":[19955001,19955088],"length":1,"stats":{"Line":4}},{"line":107,"address":[19860321,19860440],"length":1,"stats":{"Line":2}},{"line":108,"address":[19748890],"length":1,"stats":{"Line":2}},{"line":109,"address":[19860409,19860843,19860460],"length":1,"stats":{"Line":4}},{"line":110,"address":[19741520,19742392,19742982,19742586],"length":1,"stats":{"Line":4}},{"line":111,"address":[19855570],"length":1,"stats":{"Line":2}},{"line":114,"address":[19861632,19861602,19861817,19861584,19861780,19862381,19861667,19861937],"length":1,"stats":{"Line":8}},{"line":115,"address":[19338343],"length":1,"stats":{"Line":4}},{"line":116,"address":[13998185,13998252],"length":1,"stats":{"Line":4}},{"line":119,"address":[12990848],"length":1,"stats":{"Line":1}},{"line":124,"address":[19857113,19856982,19857041,19857218],"length":1,"stats":{"Line":2}},{"line":125,"address":[19751495,19751562],"length":1,"stats":{"Line":2}},{"line":126,"address":[19819505],"length":1,"stats":{"Line":1}},{"line":127,"address":[19744859],"length":1,"stats":{"Line":0}},{"line":130,"address":[11724034],"length":1,"stats":{"Line":2}},{"line":131,"address":[19863849],"length":1,"stats":{"Line":1}},{"line":132,"address":[19863819],"length":1,"stats":{"Line":1}},{"line":137,"address":[19759568],"length":1,"stats":{"Line":1}},{"line":142,"address":[19862747],"length":1,"stats":{"Line":1}},{"line":143,"address":[19746144],"length":1,"stats":{"Line":1}},{"line":147,"address":[11820684],"length":1,"stats":{"Line":2}},{"line":148,"address":[19760578,19760485],"length":1,"stats":{"Line":2}},{"line":149,"address":[14001211],"length":1,"stats":{"Line":0}},{"line":150,"address":[19959969],"length":1,"stats":{"Line":1}},{"line":153,"address":[19865245],"length":1,"stats":{"Line":1}},{"line":154,"address":[19828600,19828487],"length":1,"stats":{"Line":0}},{"line":156,"address":[12993681],"length":1,"stats":{"Line":0}},{"line":161,"address":[19863893,19864322,19863641,19864196,19864505,19865143,19864015],"length":1,"stats":{"Line":5}},{"line":162,"address":[19746274,19747448,19747604,19747348,19747798,19747408],"length":1,"stats":{"Line":5}},{"line":163,"address":[19864542,19865121],"length":1,"stats":{"Line":1}},{"line":164,"address":[19829673],"length":1,"stats":{"Line":1}},{"line":165,"address":[19823735,19823504,19822910,19820887,19823100],"length":1,"stats":{"Line":2}},{"line":166,"address":[19823386],"length":1,"stats":{"Line":1}},{"line":169,"address":[12995856,12996128,12996016,12995832,12995979,12995824,12995891,12996543],"length":1,"stats":{"Line":0}},{"line":170,"address":[11001815],"length":1,"stats":{"Line":0}},{"line":171,"address":[19862564,19862629],"length":1,"stats":{"Line":0}},{"line":174,"address":[19868432,19868596,19869168,19868397,19868648,19868467,19869421,19868384],"length":1,"stats":{"Line":8}},{"line":175,"address":[19963479,19964471,19964240,19963739,19963361],"length":1,"stats":{"Line":4}},{"line":176,"address":[19867895,19867830],"length":1,"stats":{"Line":0}},{"line":178,"address":[19832544,19832617,19832076,19832293],"length":1,"stats":{"Line":8}},{"line":179,"address":[19824927,19825388,19825338,19825636,19825504],"length":1,"stats":{"Line":8}},{"line":180,"address":[19765184,19765206],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":83},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","secure_storage.rs"],"content":"use crate::application::ports::{\n    key_manager::{KeyMaterialStore, KeyPair},\n    secure_storage::SecureAccountStore,\n};\nuse crate::domain::entities::{\n    AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret,\n};\nuse crate::domain::value_objects::keychain::{KeyMaterialLedger, KeyMaterialRecord};\nuse crate::shared::error::AppError;\nuse anyhow::{Context, Result, anyhow};\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse keyring::Entry;\nuse nostr_sdk::{\n    FromBech32,\n    prelude::{Keys, PublicKey, SecretKey},\n};\nuse once_cell::sync::Lazy;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::sync::Mutex;\nuse tracing::{debug, error, warn};\n\nconst SERVICE_NAME: &str = \"kukuri\";\nconst ACCOUNTS_KEY: &str = \"accounts_metadata\";\nconst KEY_MANAGER_LEDGER_KEY: &str = \"key_manager_ledger\";\n\nstatic FALLBACK_STORE: Lazy<Mutex<HashMap<String, String>>> =\n    Lazy::new(|| Mutex::new(HashMap::new()));\n\nfn fallback_store(key: &str, value: &str) -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.insert(key.to_string(), value.to_string());\n    Ok(())\n}\n\nfn fallback_get(key: &str) -> Option<String> {\n    FALLBACK_STORE\n        .lock()\n        .ok()\n        .and_then(|guard| guard.get(key).cloned())\n}\n\nfn fallback_delete(key: &str) -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.remove(key);\n    Ok(())\n}\n\nfn fallback_has(key: &str) -> bool {\n    FALLBACK_STORE\n        .lock()\n        .ok()\n        .map(|guard| guard.contains_key(key))\n        .unwrap_or(false)\n}\n\nfn fallback_clear() -> Result<()> {\n    let mut guard = FALLBACK_STORE\n        .lock()\n        .map_err(|_| anyhow!(\"Failed to lock fallback store\"))?;\n    guard.clear();\n    Ok(())\n}\n\nfn store_with_fallback(key: &str, value: &str) -> Result<()> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => {\n            if let Err(err) = entry.set_password(value) {\n                warn!(\n                    \"SecureStorage: keyring set_password failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        }\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    fallback_store(key, value)\n}\n\nfn retrieve_with_fallback(key: &str) -> Result<Option<String>> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.get_password() {\n            Ok(password) => {\n                let _ = fallback_store(key, &password);\n                return Ok(Some(password));\n            }\n            Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring get_password failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    Ok(fallback_get(key))\n}\n\nfn delete_with_fallback(key: &str) -> Result<()> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.delete_credential() {\n            Ok(()) | Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring delete failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    fallback_delete(key)\n}\n\nfn exists_with_fallback(key: &str) -> Result<bool> {\n    match Entry::new(SERVICE_NAME, key) {\n        Ok(entry) => match entry.get_password() {\n            Ok(_) => return Ok(true),\n            Err(keyring::Error::NoEntry) => {}\n            Err(err) => {\n                warn!(\n                    \"SecureStorage: keyring exists check failed for key {}: {err:?}\",\n                    key\n                );\n            }\n        },\n        Err(err) => {\n            warn!(\n                \"SecureStorage: keyring entry creation failed for key {}: {err:?}\",\n                key\n            );\n        }\n    }\n    Ok(fallback_has(key))\n}\n\n#[derive(Debug)]\nstruct SecureStorageError(String);\n\nimpl fmt::Display for SecureStorageError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::error::Error for SecureStorageError {}\n\nfn boxed_error(e: anyhow::Error) -> Box<dyn std::error::Error + Send + Sync + 'static> {\n    Box::new(SecureStorageError(e.to_string()))\n}\n\n/// Secure storage trait used by the app and Tauri bridge.\n#[async_trait]\npub trait SecureStorage: Send + Sync {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n}\n\n/// Default SecureStorage implementation backed by keyring with in-memory fallback.\npub struct DefaultSecureStorage;\n\nimpl DefaultSecureStorage {\n    pub fn new() -> Self {\n        Self\n    }\n\n    /// Save private key by npub.\n    pub fn save_private_key(npub: &str, nsec: &str) -> Result<()> {\n        debug!(\"SecureStorage: Saving private key for npub={npub}\");\n        store_with_fallback(npub, nsec)\n    }\n\n    /// Get private key by npub.\n    pub fn get_private_key(npub: &str) -> Result<Option<String>> {\n        retrieve_with_fallback(npub)\n    }\n\n    /// Delete private key by npub.\n    pub fn delete_private_key(npub: &str) -> Result<()> {\n        delete_with_fallback(npub)\n    }\n\n    /// Save accounts metadata (includes current npub).\n    pub fn save_accounts_metadata(metadata: &AccountsMetadata) -> Result<()> {\n        let json =\n            serde_json::to_string(metadata).context(\"Failed to serialize accounts metadata\")?;\n        debug!(\"SecureStorage: Saving metadata JSON: {json}\");\n        store_with_fallback(ACCOUNTS_KEY, &json)?;\n\n        // Read-back check to ensure fallback has the latest value.\n        match retrieve_with_fallback(ACCOUNTS_KEY) {\n            Ok(Some(test_json)) => {\n                debug!(\n                    \"SecureStorage: Immediate read test succeeded, data length: {}\",\n                    test_json.len()\n                );\n            }\n            Ok(None) => {\n                warn!(\"SecureStorage: Metadata read-after-write returned empty result\");\n            }\n            Err(err) => {\n                error!(\"SecureStorage: Immediate metadata read failed: {err:?}\");\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Fetch accounts metadata or default.\n    pub fn get_accounts_metadata() -> Result<AccountsMetadata> {\n        debug!(\"SecureStorage: Getting accounts metadata...\");\n        match retrieve_with_fallback(ACCOUNTS_KEY) {\n            Ok(Some(json)) => {\n                debug!(\"SecureStorage: Retrieved metadata JSON: {json}\");\n                let metadata: AccountsMetadata = serde_json::from_str(&json)\n                    .context(\"Failed to deserialize accounts metadata\")?;\n                debug!(\n                    \"SecureStorage: Deserialized metadata - current_npub: {:?}, accounts: {}\",\n                    metadata.current_npub,\n                    metadata.accounts.len()\n                );\n                Ok(metadata)\n            }\n            Ok(None) => {\n                debug!(\"SecureStorage: No metadata entry found, returning default\");\n                Ok(AccountsMetadata::default())\n            }\n            Err(err) => {\n                error!(\"SecureStorage: Failed to get metadata: {err:?}\");\n                Err(err)\n            }\n        }\n    }\n\n    fn get_key_material_ledger() -> Result<KeyMaterialLedger> {\n        match retrieve_with_fallback(KEY_MANAGER_LEDGER_KEY) {\n            Ok(Some(json)) => {\n                debug!(\"SecureStorage: Retrieved key ledger JSON\");\n                serde_json::from_str(&json).context(\"Failed to deserialize key material ledger\")\n            }\n            Ok(None) => Ok(KeyMaterialLedger::default()),\n            Err(err) => Err(err),\n        }\n    }\n\n    fn save_key_material_ledger(ledger: &KeyMaterialLedger) -> Result<()> {\n        let json = serde_json::to_string(ledger).context(\"Failed to serialize key ledger\")?;\n        store_with_fallback(KEY_MANAGER_LEDGER_KEY, &json)\n    }\n}\n\nimpl Default for DefaultSecureStorage {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SecureStorage for DefaultSecureStorage {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        store_with_fallback(key, value).map_err(boxed_error)\n    }\n\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n        retrieve_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        delete_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        exists_with_fallback(key).map_err(boxed_error)\n    }\n\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n        // keyring does not support listing; derive from stored metadata.\n        let metadata = Self::get_accounts_metadata().map_err(boxed_error)?;\n        Ok(metadata.accounts.keys().cloned().collect())\n    }\n\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // Remove all stored keys and metadata.\n        let metadata = Self::get_accounts_metadata().map_err(boxed_error)?;\n        for npub in metadata.accounts.keys() {\n            Self::delete_private_key(npub).map_err(boxed_error)?;\n        }\n        Self::save_accounts_metadata(&AccountsMetadata::default()).map_err(boxed_error)?;\n        delete_with_fallback(KEY_MANAGER_LEDGER_KEY).map_err(boxed_error)?;\n        fallback_clear().map_err(boxed_error)?;\n        Ok(())\n    }\n}\n\nfn to_storage_error(err: anyhow::Error) -> AppError {\n    AppError::Storage(err.to_string())\n}\n\nfn build_keypair_from_record(\n    record: &KeyMaterialRecord,\n    nsec: String,\n) -> Result<KeyPair, AppError> {\n    let secret_key = SecretKey::from_bech32(&nsec)\n        .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e}\")))?;\n    Ok(KeyPair {\n        public_key: record.public_key.clone(),\n        private_key: secret_key.display_secret().to_string(),\n        npub: record.npub.clone(),\n        nsec,\n    })\n}\n\n#[async_trait]\nimpl SecureAccountStore for DefaultSecureStorage {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError> {\n        let (mut metadata, nsec) = registration.into_metadata();\n        debug!(\"SecureStorage: Adding account npub={}\", metadata.npub);\n\n        Self::save_private_key(&metadata.npub, &nsec).map_err(to_storage_error)?;\n\n        let mut accounts = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.mark_used(Utc::now());\n        accounts\n            .accounts\n            .insert(metadata.npub.clone(), metadata.clone());\n        accounts.current_npub = Some(metadata.npub.clone());\n        Self::save_accounts_metadata(&accounts).map_err(to_storage_error)?;\n        {\n            let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n            let entry = ledger\n                .records\n                .entry(metadata.npub.clone())\n                .or_insert_with(|| {\n                    KeyMaterialRecord::new(metadata.npub.clone(), metadata.pubkey.clone())\n                });\n            entry.public_key = metadata.pubkey.clone();\n            entry.touch();\n            ledger.touch_current(&metadata.npub);\n            Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n        }\n\n        Ok(metadata)\n    }\n\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let mut accounts: Vec<AccountMetadata> = metadata.accounts.values().cloned().collect();\n        accounts.sort_by(|a, b| b.last_used.cmp(&a.last_used));\n        Ok(accounts)\n    }\n\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError> {\n        Self::delete_private_key(npub).map_err(to_storage_error)?;\n\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.accounts.remove(npub);\n        if metadata.current_npub.as_deref() == Some(npub) {\n            metadata.current_npub = metadata.accounts.keys().next().cloned();\n        }\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.remove(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n\n        Ok(())\n    }\n\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError> {\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let account = metadata\n            .accounts\n            .get_mut(npub)\n            .ok_or_else(|| AppError::NotFound(format!(\"Account not found: {npub}\")))?;\n        account.mark_used(Utc::now());\n        let updated = account.clone();\n        metadata.current_npub = Some(npub.to_string());\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.touch_current(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)?;\n\n        Ok(updated)\n    }\n\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError> {\n        Self::get_private_key(npub).map_err(to_storage_error)\n    }\n\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        if let Some(current) = metadata.current_npub.as_ref() {\n            if let Some(account) = metadata.accounts.get(current) {\n                if let Some(nsec) = Self::get_private_key(current).map_err(to_storage_error)? {\n                    return Ok(Some(CurrentAccountSecret {\n                        metadata: account.clone(),\n                        nsec,\n                    }));\n                }\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[async_trait]\nimpl KeyMaterialStore for DefaultSecureStorage {\n    async fn save_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        Self::save_private_key(&keypair.npub, &keypair.nsec).map_err(to_storage_error)?;\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        let entry = ledger\n            .records\n            .entry(keypair.npub.clone())\n            .or_insert_with(|| {\n                KeyMaterialRecord::new(keypair.npub.clone(), keypair.public_key.clone())\n            });\n        entry.public_key = keypair.public_key.clone();\n        entry.touch();\n        ledger.touch_current(&keypair.npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        ledger.remove(npub);\n        Self::delete_private_key(npub).map_err(to_storage_error)?;\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn get_keypair(&self, npub: &str) -> Result<Option<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        match ledger.records.get(npub) {\n            Some(record) => {\n                let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n                if let Some(nsec) = nsec {\n                    build_keypair_from_record(record, nsec)\n                } else {\n                    Err(AppError::NotFound(format!(\n                        \"Private key not found for {}\",\n                        record.npub\n                    )))\n                }\n                .map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    async fn list_keypairs(&self) -> Result<Vec<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        let mut pairs = Vec::with_capacity(ledger.records.len());\n        for record in ledger.records.values() {\n            let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n            if let Some(nsec) = nsec {\n                pairs.push(build_keypair_from_record(record, nsec)?);\n            }\n        }\n        Ok(pairs)\n    }\n\n    async fn set_current(&self, npub: &str) -> Result<(), AppError> {\n        let mut ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        if !ledger.records.contains_key(npub) {\n            let public_key = match Self::get_private_key(npub).map_err(to_storage_error)? {\n                Some(nsec) => {\n                    let secret_key = SecretKey::from_bech32(&nsec).map_err(|e| {\n                        AppError::Crypto(format!(\"Invalid nsec stored for npub {npub}: {e:?}\"))\n                    })?;\n                    Keys::new(secret_key).public_key()\n                }\n                None => PublicKey::from_bech32(npub).map_err(|e| {\n                    AppError::Crypto(format!(\"Failed to decode npub {npub}: {e:?}\"))\n                })?,\n            };\n            let public_key_hex = public_key.to_hex();\n            ledger.upsert(KeyMaterialRecord::new(npub.to_string(), public_key_hex));\n        }\n        ledger.touch_current(npub);\n        Self::save_key_material_ledger(&ledger).map_err(to_storage_error)\n    }\n\n    async fn current_keypair(&self) -> Result<Option<KeyPair>, AppError> {\n        let ledger = Self::get_key_material_ledger().map_err(to_storage_error)?;\n        if let Some(npub) = ledger.current_npub.as_deref() {\n            if let Some(record) = ledger.records.get(npub) {\n                let nsec = Self::get_private_key(&record.npub).map_err(to_storage_error)?;\n                if let Some(nsec) = nsec {\n                    return build_keypair_from_record(record, nsec).map(Some);\n                }\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[cfg(all(test, target_os = \"windows\"))]\nmod tests {\n    use super::*;\n    use crate::application::ports::secure_storage::SecureAccountStore;\n    use crate::domain::entities::AccountRegistration;\n\n    #[tokio::test]\n    async fn test_secure_storage_store_retrieve() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let result = storage.store(\"test_key\", \"test_value\").await;\n        assert!(result.is_ok());\n\n        // Retrieve the value\n        let result = storage.retrieve(\"test_key\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Some(\"test_value\".to_string()));\n\n        // Clean up\n        let _ = storage.delete(\"test_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_delete() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let _ = storage.store(\"test_delete_key\", \"test_value\").await;\n\n        // Delete it\n        let result = storage.delete(\"test_delete_key\").await;\n        assert!(result.is_ok());\n\n        // Verify it's deleted\n        let result = storage.retrieve(\"test_delete_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n\n        // Clean up\n        let _ = storage.delete(\"test_delete_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_exists() {\n        let storage = DefaultSecureStorage::new();\n\n        // Check non-existent key\n        let result = storage.exists(\"non_existent_key\").await;\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n\n        // Store a value\n        let _ = storage.store(\"test_exists_key\", \"test_value\").await;\n\n        // Check it exists\n        let result = storage.exists(\"test_exists_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n\n        // Clean up\n        let _ = storage.delete(\"test_exists_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_add_account() {\n        let storage = DefaultSecureStorage::new();\n        let registration = AccountRegistration {\n            npub: \"npub1test\".to_string(),\n            nsec: \"nsec1test\".to_string(),\n            pubkey: \"pubkey_test\".to_string(),\n            name: \"test_user\".to_string(),\n            display_name: \"Test User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let result = SecureAccountStore::add_account(&storage, registration).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_list_accounts() {\n        let storage = DefaultSecureStorage::new();\n        // Add an account\n        let registration = AccountRegistration {\n            npub: \"npub1list\".to_string(),\n            nsec: \"nsec1list\".to_string(),\n            pubkey: \"pubkey_list\".to_string(),\n            name: \"list_user\".to_string(),\n            display_name: \"List User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let _ = SecureAccountStore::add_account(&storage, registration).await;\n\n        let result = SecureAccountStore::list_accounts(&storage).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n        let accounts = result.unwrap();\n        assert!(accounts.iter().any(|a| a.npub == \"npub1list\"));\n    }\n}\n","traces":[{"line":29,"address":[22304834,22304816],"length":1,"stats":{"Line":2}},{"line":31,"address":[22186592,22187107],"length":1,"stats":{"Line":1}},{"line":32,"address":[22268171,22268329],"length":1,"stats":{"Line":1}},{"line":34,"address":[22261388,22261728,22261746],"length":1,"stats":{"Line":0}},{"line":35,"address":[22193667,22193869,22193559],"length":1,"stats":{"Line":2}},{"line":36,"address":[22299756],"length":1,"stats":{"Line":1}},{"line":39,"address":[22300000],"length":1,"stats":{"Line":2}},{"line":40,"address":[22400401],"length":1,"stats":{"Line":2}},{"line":43,"address":[22201168,22201206],"length":1,"stats":{"Line":2}},{"line":46,"address":[26562269,26561968],"length":1,"stats":{"Line":1}},{"line":47,"address":[26562001,26562142],"length":1,"stats":{"Line":1}},{"line":49,"address":[16442256,16442274,16442073],"length":1,"stats":{"Line":0}},{"line":50,"address":[22194533,22194638],"length":1,"stats":{"Line":2}},{"line":51,"address":[22300590],"length":1,"stats":{"Line":1}},{"line":54,"address":[22304752],"length":1,"stats":{"Line":0}},{"line":55,"address":[16442439],"length":1,"stats":{"Line":0}},{"line":58,"address":[22304864,22304891],"length":1,"stats":{"Line":0}},{"line":62,"address":[22301340,22301088],"length":1,"stats":{"Line":0}},{"line":63,"address":[22195175,22195319],"length":1,"stats":{"Line":0}},{"line":65,"address":[22202434,22202282,22202416],"length":1,"stats":{"Line":0}},{"line":66,"address":[22263093,22263184],"length":1,"stats":{"Line":0}},{"line":67,"address":[26562922],"length":1,"stats":{"Line":0}},{"line":70,"address":[22190982,22191036,22188816],"length":1,"stats":{"Line":1}},{"line":71,"address":[22307159,22307960],"length":1,"stats":{"Line":1}},{"line":72,"address":[22305604],"length":1,"stats":{"Line":1}},{"line":73,"address":[22263588,22263738],"length":1,"stats":{"Line":2}},{"line":74,"address":[22271194,22270749,22270850,22271330,22397401,22397535],"length":1,"stats":{"Line":0}},{"line":80,"address":[26563346],"length":1,"stats":{"Line":0}},{"line":81,"address":[22205332,22204857,22330137,22330271,22202831],"length":1,"stats":{"Line":0}},{"line":87,"address":[22191007],"length":1,"stats":{"Line":1}},{"line":90,"address":[22200188,22202142,22199424],"length":1,"stats":{"Line":2}},{"line":91,"address":[22267271],"length":1,"stats":{"Line":2}},{"line":92,"address":[16447356,16447068,16447250],"length":1,"stats":{"Line":6}},{"line":93,"address":[22309629],"length":1,"stats":{"Line":0}},{"line":94,"address":[22199813,22199945],"length":1,"stats":{"Line":0}},{"line":95,"address":[16447539],"length":1,"stats":{"Line":0}},{"line":98,"address":[22193457],"length":1,"stats":{"Line":0}},{"line":99,"address":[22207352,22207832,22330633,22207273,22330767],"length":1,"stats":{"Line":0}},{"line":105,"address":[22192823],"length":1,"stats":{"Line":0}},{"line":106,"address":[26791407,26572391,26571797,26791273,26571996,26571464],"length":1,"stats":{"Line":0}},{"line":112,"address":[22195281],"length":1,"stats":{"Line":2}},{"line":115,"address":[22313600,22315870],"length":1,"stats":{"Line":1}},{"line":116,"address":[22278503],"length":1,"stats":{"Line":1}},{"line":117,"address":[22315538,22315625,22315356],"length":1,"stats":{"Line":3}},{"line":119,"address":[22314017],"length":1,"stats":{"Line":0}},{"line":120,"address":[22411064,22531071,22410584,22530937,22410505],"length":1,"stats":{"Line":0}},{"line":126,"address":[22278647],"length":1,"stats":{"Line":0}},{"line":127,"address":[22206084,22325279,22206559,22325145,22203959],"length":1,"stats":{"Line":0}},{"line":133,"address":[22205985],"length":1,"stats":{"Line":1}},{"line":136,"address":[22210165,22207632,22210134],"length":1,"stats":{"Line":0}},{"line":137,"address":[22282407],"length":1,"stats":{"Line":0}},{"line":138,"address":[22214914,22214732,22215009],"length":1,"stats":{"Line":0}},{"line":139,"address":[22317845],"length":1,"stats":{"Line":0}},{"line":141,"address":[22215154],"length":1,"stats":{"Line":0}},{"line":142,"address":[22415081,22532063,22414522,22414601,22531929],"length":1,"stats":{"Line":0}},{"line":148,"address":[16455335],"length":1,"stats":{"Line":0}},{"line":149,"address":[22282599,22401007,22284962,22400873,22285437],"length":1,"stats":{"Line":0}},{"line":155,"address":[22284825],"length":1,"stats":{"Line":0}},{"line":162,"address":[22279584],"length":1,"stats":{"Line":0}},{"line":163,"address":[22418088],"length":1,"stats":{"Line":0}},{"line":169,"address":[22211888,22212133],"length":1,"stats":{"Line":0}},{"line":170,"address":[22418185,22418261],"length":1,"stats":{"Line":0}},{"line":200,"address":[22279984,22280496],"length":1,"stats":{"Line":0}},{"line":201,"address":[22432767,22318610,22318139,22318736,22432633],"length":1,"stats":{"Line":0}},{"line":202,"address":[16460313],"length":1,"stats":{"Line":0}},{"line":206,"address":[22213392],"length":1,"stats":{"Line":0}},{"line":207,"address":[22324917],"length":1,"stats":{"Line":0}},{"line":211,"address":[22206656],"length":1,"stats":{"Line":0}},{"line":212,"address":[22324958],"length":1,"stats":{"Line":0}},{"line":216,"address":[22295242,22288208,22293654],"length":1,"stats":{"Line":0}},{"line":217,"address":[22324994,22325191],"length":1,"stats":{"Line":0}},{"line":219,"address":[22437065,22323515,22323636,22324128,22437199],"length":1,"stats":{"Line":0}},{"line":220,"address":[22222460,22221222,22222334,22227458],"length":1,"stats":{"Line":0}},{"line":223,"address":[22325313,22325385],"length":1,"stats":{"Line":0}},{"line":224,"address":[22215676],"length":1,"stats":{"Line":0}},{"line":225,"address":[22323690,22433759,22323212,22321628,22324303,22433625,22324601],"length":1,"stats":{"Line":0}},{"line":231,"address":[26589555,26589975,26589023,26589356,26795321,26795455],"length":1,"stats":{"Line":0}},{"line":233,"address":[22321521],"length":1,"stats":{"Line":0}},{"line":234,"address":[22328834,22329312,22438553,22438687,22325473],"length":1,"stats":{"Line":0}},{"line":238,"address":[22220432],"length":1,"stats":{"Line":0}},{"line":242,"address":[22433221,22426816,22433143],"length":1,"stats":{"Line":0}},{"line":243,"address":[26595749,26596302,26796447,26796313,26595277,26595583],"length":1,"stats":{"Line":0}},{"line":244,"address":[22214317,22214934],"length":1,"stats":{"Line":0}},{"line":245,"address":[22215043],"length":1,"stats":{"Line":0}},{"line":246,"address":[22329512,22327779,22435743,22329022,22435609],"length":1,"stats":{"Line":0}},{"line":247,"address":[22330934,22329486,22330598],"length":1,"stats":{"Line":0}},{"line":249,"address":[22219430,22219775],"length":1,"stats":{"Line":0}},{"line":254,"address":[22335398],"length":1,"stats":{"Line":0}},{"line":257,"address":[22215106,22215018,22323897,22324031,22215675],"length":1,"stats":{"Line":0}},{"line":258,"address":[22332271],"length":1,"stats":{"Line":0}},{"line":260,"address":[22333259],"length":1,"stats":{"Line":0}},{"line":261,"address":[16578831,16474514,16475008,16469291,16578697],"length":1,"stats":{"Line":0}},{"line":262,"address":[22338962],"length":1,"stats":{"Line":0}},{"line":267,"address":[22296288,22298097],"length":1,"stats":{"Line":0}},{"line":268,"address":[22340007,22340686],"length":1,"stats":{"Line":0}},{"line":269,"address":[22303421],"length":1,"stats":{"Line":0}},{"line":270,"address":[22437593,22335104,22334637,22335252,22334760,22437727],"length":1,"stats":{"Line":0}},{"line":271,"address":[22223428,22222522],"length":1,"stats":{"Line":0}},{"line":273,"address":[22228643],"length":1,"stats":{"Line":0}},{"line":274,"address":[22296416],"length":1,"stats":{"Line":0}},{"line":278,"address":[22340508,22340192],"length":1,"stats":{"Line":0}},{"line":279,"address":[22230354,22230515],"length":1,"stats":{"Line":0}},{"line":280,"address":[26608416,26608319],"length":1,"stats":{"Line":0}},{"line":285,"address":[22223904],"length":1,"stats":{"Line":0}},{"line":286,"address":[22436977],"length":1,"stats":{"Line":0}},{"line":292,"address":[22407184,22407381,22407051,22407156,22407024,22406877,22407104],"length":1,"stats":{"Line":7}},{"line":297,"address":[22339526],"length":1,"stats":{"Line":1}},{"line":300,"address":[22400886,22400515,22401083,22400656,22400768,22400859,22400685],"length":1,"stats":{"Line":10}},{"line":304,"address":[22340166],"length":1,"stats":{"Line":2}},{"line":307,"address":[22333331,22333472,22333604,22333821,22333499,22333552,22333632],"length":1,"stats":{"Line":5}},{"line":308,"address":[22540022],"length":1,"stats":{"Line":1}},{"line":311,"address":[22327416,22327584,22327248,22327274,22327107,22327389,22327327],"length":1,"stats":{"Line":0}},{"line":312,"address":[26801018],"length":1,"stats":{"Line":0}},{"line":315,"address":[22446942,22446160,22446278,22446048,22446077,22445929,22446923],"length":1,"stats":{"Line":0}},{"line":317,"address":[22441102,22440806,22441353],"length":1,"stats":{"Line":0}},{"line":318,"address":[22335284,22335155],"length":1,"stats":{"Line":0}},{"line":321,"address":[22328923,22330931,22328855,22330515,22329030,22330647,22328816,22328697],"length":1,"stats":{"Line":0}},{"line":323,"address":[22330910,22329147,22329446],"length":1,"stats":{"Line":0}},{"line":324,"address":[22404151,22405392,22404291,22404011],"length":1,"stats":{"Line":0}},{"line":325,"address":[22447312,22446355,22447445],"length":1,"stats":{"Line":0}},{"line":327,"address":[22329741,22329692,22330612],"length":1,"stats":{"Line":0}},{"line":328,"address":[22446679,22446857,22447218],"length":1,"stats":{"Line":0}},{"line":329,"address":[16584727,16584509,16584834,16584589],"length":1,"stats":{"Line":0}},{"line":330,"address":[22447032],"length":1,"stats":{"Line":0}},{"line":334,"address":[22298640,22298512],"length":1,"stats":{"Line":0}},{"line":335,"address":[22237757,22237699],"length":1,"stats":{"Line":0}},{"line":338,"address":[22238702,22237840,22238724],"length":1,"stats":{"Line":0}},{"line":342,"address":[22337130,22336827,22336911],"length":1,"stats":{"Line":0}},{"line":343,"address":[22337734,22337712,22337088],"length":1,"stats":{"Line":0}},{"line":344,"address":[22437786],"length":1,"stats":{"Line":0}},{"line":345,"address":[22342644],"length":1,"stats":{"Line":0}},{"line":346,"address":[22437568,22437643],"length":1,"stats":{"Line":0}},{"line":347,"address":[22231394],"length":1,"stats":{"Line":0}},{"line":348,"address":[26609240],"length":1,"stats":{"Line":0}},{"line":354,"address":[22331207,22331168,22330991,22336023,22335804,22331340,22335717,22331435,22335929],"length":1,"stats":{"Line":0}},{"line":358,"address":[16585876],"length":1,"stats":{"Line":0}},{"line":359,"address":[16586044,16586557,16599535,16585965,16599401],"length":1,"stats":{"Line":0}},{"line":361,"address":[22413740,22414856,22415004,22417380],"length":1,"stats":{"Line":0}},{"line":363,"address":[22448562,22446169,22446548,22446273],"length":1,"stats":{"Line":0}},{"line":364,"address":[22547045,22546894],"length":1,"stats":{"Line":0}},{"line":365,"address":[22340930,22340784],"length":1,"stats":{"Line":0}},{"line":367,"address":[22335836,22334189,22334013],"length":1,"stats":{"Line":0}},{"line":368,"address":[22547288],"length":1,"stats":{"Line":0}},{"line":369,"address":[22452455,22451156,22451041],"length":1,"stats":{"Line":0}},{"line":371,"address":[22416029,22416417,22417333,22416121],"length":1,"stats":{"Line":0}},{"line":372,"address":[22453142,22453354,22453319],"length":1,"stats":{"Line":0}},{"line":374,"address":[22547939],"length":1,"stats":{"Line":0}},{"line":375,"address":[22448958,22448784,22447762,22448932],"length":1,"stats":{"Line":0}},{"line":376,"address":[22342888,22343022],"length":1,"stats":{"Line":0}},{"line":378,"address":[16589415],"length":1,"stats":{"Line":0}},{"line":379,"address":[22409847],"length":1,"stats":{"Line":0}},{"line":380,"address":[22335274],"length":1,"stats":{"Line":0}},{"line":381,"address":[22448139,22448032],"length":1,"stats":{"Line":0}},{"line":384,"address":[22342304],"length":1,"stats":{"Line":0}},{"line":387,"address":[16590797,16590885,16590585,16591681,16590734,16591700,16590704],"length":1,"stats":{"Line":0}},{"line":388,"address":[26810125,26810773,26810400],"length":1,"stats":{"Line":0}},{"line":389,"address":[22455400,22455241],"length":1,"stats":{"Line":0}},{"line":390,"address":[22412032,22411758,22412064,22411841],"length":1,"stats":{"Line":0}},{"line":391,"address":[22411852],"length":1,"stats":{"Line":0}},{"line":394,"address":[22552960,22550595,22550829,22550766,22552937,22550736,22550923,22552891],"length":1,"stats":{"Line":0}},{"line":395,"address":[22456523,22454591,22454715],"length":1,"stats":{"Line":0}},{"line":397,"address":[22458166,22456344,22456744,22456448],"length":1,"stats":{"Line":0}},{"line":398,"address":[22419933,22420105],"length":1,"stats":{"Line":0}},{"line":399,"address":[22420124,22420493],"length":1,"stats":{"Line":0}},{"line":400,"address":[22457044],"length":1,"stats":{"Line":0}},{"line":402,"address":[26811966,26813030,26812208,26812278],"length":1,"stats":{"Line":0}},{"line":403,"address":[22451766,22452578,22452146,22451858],"length":1,"stats":{"Line":0}},{"line":404,"address":[22452111],"length":1,"stats":{"Line":0}},{"line":405,"address":[22353452,22353339],"length":1,"stats":{"Line":0}},{"line":407,"address":[22353425],"length":1,"stats":{"Line":0}},{"line":410,"address":[22458368,22458489,22458398,22460592,22458583,22458227,22460707,22460635],"length":1,"stats":{"Line":0}},{"line":411,"address":[22415299,22417006,22414987],"length":1,"stats":{"Line":0}},{"line":412,"address":[22422529,22422208,22423932,22422370,22422187],"length":1,"stats":{"Line":0}},{"line":414,"address":[22457315],"length":1,"stats":{"Line":0}},{"line":415,"address":[16595145,16596768,16595265,16596789],"length":1,"stats":{"Line":0}},{"line":416,"address":[22354702,22354811],"length":1,"stats":{"Line":0}},{"line":417,"address":[22341083,22341125],"length":1,"stats":{"Line":0}},{"line":418,"address":[22415795,22415725],"length":1,"stats":{"Line":0}},{"line":419,"address":[22554433,22555430,22554548],"length":1,"stats":{"Line":0}},{"line":420,"address":[22416061,22416441,22416153,22416948],"length":1,"stats":{"Line":0}},{"line":421,"address":[22423334],"length":1,"stats":{"Line":0}},{"line":422,"address":[22348953,22348770],"length":1,"stats":{"Line":0}},{"line":424,"address":[22423594],"length":1,"stats":{"Line":0}},{"line":427,"address":[26815805,26815823,26815740,26815994,26815648,26815603,26815677],"length":1,"stats":{"Line":0}},{"line":428,"address":[22556151],"length":1,"stats":{"Line":0}},{"line":431,"address":[22463238,22463285,22461497,22461729,22461823,22461616,22463275,22461646],"length":1,"stats":{"Line":0}},{"line":432,"address":[22460275,22461632,22460574],"length":1,"stats":{"Line":0}},{"line":433,"address":[22456611,22456772],"length":1,"stats":{"Line":0}},{"line":434,"address":[22344225,22344126],"length":1,"stats":{"Line":0}},{"line":435,"address":[22461599,22460927],"length":1,"stats":{"Line":0}},{"line":436,"address":[22463090],"length":1,"stats":{"Line":0}},{"line":437,"address":[22462969],"length":1,"stats":{"Line":0}},{"line":438,"address":[16599058],"length":1,"stats":{"Line":0}},{"line":443,"address":[22418752],"length":1,"stats":{"Line":0}},{"line":449,"address":[22353924,22353900,22352497,22352464,22352334,22352569,22352669],"length":1,"stats":{"Line":0}},{"line":450,"address":[16600298,16600511,16601439],"length":1,"stats":{"Line":0}},{"line":451,"address":[22427720,22427812,22428650,22428116],"length":1,"stats":{"Line":0}},{"line":452,"address":[22360490,22360529,22360305],"length":1,"stats":{"Line":0}},{"line":454,"address":[22421150],"length":1,"stats":{"Line":0}},{"line":455,"address":[22428849,22428277,22428875,22428704],"length":1,"stats":{"Line":0}},{"line":456,"address":[22347339,22347202],"length":1,"stats":{"Line":0}},{"line":458,"address":[22421398],"length":1,"stats":{"Line":0}},{"line":459,"address":[22560026],"length":1,"stats":{"Line":0}},{"line":460,"address":[22465253],"length":1,"stats":{"Line":0}},{"line":461,"address":[22459739],"length":1,"stats":{"Line":0}},{"line":464,"address":[22465683,22466813,22466005,22466840,22465824,22465917,22466854,22465854],"length":1,"stats":{"Line":0}},{"line":465,"address":[22461265,22460824,22460529],"length":1,"stats":{"Line":0}},{"line":466,"address":[22466373],"length":1,"stats":{"Line":0}},{"line":467,"address":[22460953,22461078],"length":1,"stats":{"Line":0}},{"line":468,"address":[22561533,22561434],"length":1,"stats":{"Line":0}},{"line":471,"address":[22466915,22467086,22467177,22467056,22467271,22468831,22468872,22468916],"length":1,"stats":{"Line":0}},{"line":472,"address":[16603695,16604927,16603395],"length":1,"stats":{"Line":0}},{"line":473,"address":[22363285,22363111],"length":1,"stats":{"Line":0}},{"line":474,"address":[22467896],"length":1,"stats":{"Line":0}},{"line":475,"address":[22431478,22431232,22431148],"length":1,"stats":{"Line":0}},{"line":476,"address":[22468206,22468723,22468489,22468335],"length":1,"stats":{"Line":0}},{"line":477,"address":[22350199,22350103],"length":1,"stats":{"Line":0}},{"line":479,"address":[22466754,22466871],"length":1,"stats":{"Line":0}},{"line":486,"address":[22424154],"length":1,"stats":{"Line":0}},{"line":490,"address":[22366631,22364749,22364441,22364661,22366551,22364560,22364590,22365645],"length":1,"stats":{"Line":0}},{"line":491,"address":[22464088,22465570,22463801],"length":1,"stats":{"Line":0}},{"line":492,"address":[22464061,22464222],"length":1,"stats":{"Line":0}},{"line":493,"address":[22469832,22471106,22469900,22470110],"length":1,"stats":{"Line":0}},{"line":494,"address":[22470130,22470223,22470469,22471130],"length":1,"stats":{"Line":0}},{"line":495,"address":[22565213,22565342],"length":1,"stats":{"Line":0}},{"line":496,"address":[22366086,22366203],"length":1,"stats":{"Line":0}},{"line":499,"address":[26823796],"length":1,"stats":{"Line":0}},{"line":502,"address":[22468078,22468233,22468243,22465885,22465806,22465973,22465776,22465635],"length":1,"stats":{"Line":0}},{"line":503,"address":[22353377,22355534,22353676],"length":1,"stats":{"Line":0}},{"line":504,"address":[22353637,22353809,22355347],"length":1,"stats":{"Line":0}},{"line":505,"address":[22430027,22428474,22428407],"length":1,"stats":{"Line":0}},{"line":506,"address":[26826036],"length":1,"stats":{"Line":0}},{"line":507,"address":[22470843,22471573,22471279,22472496,22472224],"length":1,"stats":{"Line":0}},{"line":508,"address":[22468314,22468382],"length":1,"stats":{"Line":0}},{"line":510,"address":[22567894,22568099],"length":1,"stats":{"Line":0}},{"line":512,"address":[22472419,22472511,22474176,22472781,22474448,22472841],"length":1,"stats":{"Line":0}},{"line":513,"address":[22430574,22430506],"length":1,"stats":{"Line":0}},{"line":516,"address":[22355159,22354543],"length":1,"stats":{"Line":0}},{"line":517,"address":[22568239,22568309],"length":1,"stats":{"Line":0}},{"line":519,"address":[22435367],"length":1,"stats":{"Line":0}},{"line":520,"address":[26827285],"length":1,"stats":{"Line":0}},{"line":523,"address":[22473081,22472990,22474709,22472960,22472841,22473175,22474659,22474719],"length":1,"stats":{"Line":0}},{"line":524,"address":[22474714,22473575,22473283],"length":1,"stats":{"Line":0}},{"line":525,"address":[22570146,22569975],"length":1,"stats":{"Line":0}},{"line":526,"address":[22364820,22363935,22364103],"length":1,"stats":{"Line":0}},{"line":527,"address":[22364825,22364164,22364472,22364226],"length":1,"stats":{"Line":0}},{"line":528,"address":[22439168,22439297],"length":1,"stats":{"Line":0}},{"line":529,"address":[22570905,22570996],"length":1,"stats":{"Line":0}},{"line":533,"address":[22363972],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":249},{"path":["/","app","kukuri-tauri","src-tauri","src","lib.rs"],"content":"use std::sync::Arc;\n\nuse tauri::{Emitter, Manager};\nuse tokio::sync::broadcast;\nuse tracing::info;\n\n// モジュール定義\nmod application;\npub mod domain;\nmod infrastructure;\nmod presentation;\nmod shared;\nmod state;\n\npub use application::ports::repositories::TopicMetricsRepository;\npub use domain::entities::{TopicMetricsRecord, TopicMetricsSnapshot};\npub use infrastructure::database::{\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\n};\npub use shared::config::AppConfig;\n\npub mod ops {\n    pub mod p2p {\n        pub use crate::infrastructure::p2p::metrics;\n    }\n}\n\n#[doc(hidden)]\npub mod test_support {\n    pub mod application {\n        pub use crate::application::ports;\n        pub use crate::application::services;\n        pub use crate::application::shared;\n    }\n    pub mod domain {\n        pub use crate::domain::entities;\n        pub use crate::domain::p2p;\n        pub use crate::domain::value_objects;\n    }\n    pub mod infrastructure {\n        pub use crate::infrastructure::crypto;\n        pub use crate::infrastructure::database;\n        pub use crate::infrastructure::event;\n        pub use crate::infrastructure::offline;\n        pub use crate::infrastructure::p2p;\n        pub use crate::infrastructure::storage;\n    }\n    pub mod presentation {\n        pub use crate::presentation::dto;\n    }\n    pub mod shared {\n        pub use crate::shared::{config, error};\n    }\n}\n\n#[doc(hidden)]\npub mod contract_testing;\n\n// Tauriコマンドのインポート\n// v2アーキテクチャへの移行完了につき、旧コマンドのインポートは削除\nuse state::AppState;\n\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\n/// Run the Tauri application\n///\n/// # Panics\n///\n/// Panics if the Tauri application fails to run\npub fn run() {\n    // ログ設定の初期化\n    init_logging();\n\n    info!(\"Kukuri Tauri application starting...\");\n\n    tauri::Builder::default()\n        .plugin(tauri_plugin_opener::init())\n        .plugin(tauri_plugin_dialog::init())\n        .plugin(tauri_plugin_fs::init())\n        .invoke_handler(tauri::generate_handler![\n            // 認証関連コマンド\n            presentation::commands::generate_keypair,\n            presentation::commands::login,\n            presentation::commands::logout,\n            presentation::commands::export_private_key,\n            // セキュアストレージ関連コマンド\n            presentation::commands::add_account,\n            presentation::commands::list_accounts,\n            presentation::commands::switch_account,\n            presentation::commands::remove_account,\n            presentation::commands::get_current_account,\n            presentation::commands::secure_login,\n            // ユーザー関連コマンド\n            presentation::commands::get_user,\n            presentation::commands::get_user_by_pubkey,\n            presentation::commands::search_users,\n            presentation::commands::update_privacy_settings,\n            presentation::commands::follow_user,\n            presentation::commands::unfollow_user,\n            presentation::commands::get_followers,\n            presentation::commands::get_following,\n            presentation::commands::send_direct_message,\n            presentation::commands::list_direct_messages,\n            presentation::commands::list_direct_message_conversations,\n            presentation::commands::mark_direct_message_conversation_read,\n            presentation::commands::seed_direct_message_for_e2e,\n            presentation::commands::upload_profile_avatar,\n            presentation::commands::fetch_profile_avatar,\n            presentation::commands::profile_avatar_sync,\n            // トピック関連コマンド\n            presentation::commands::create_topic,\n            presentation::commands::enqueue_topic_creation,\n            presentation::commands::list_pending_topics,\n            presentation::commands::mark_pending_topic_synced,\n            presentation::commands::mark_pending_topic_failed,\n            presentation::commands::get_topics,\n            presentation::commands::update_topic,\n            presentation::commands::delete_topic,\n            presentation::commands::join_topic,\n            presentation::commands::leave_topic,\n            presentation::commands::get_topic_stats,\n            presentation::commands::list_trending_topics,\n            // ポスト関連コマンド\n            presentation::commands::create_post,\n            presentation::commands::get_posts,\n            presentation::commands::list_trending_posts,\n            presentation::commands::delete_post,\n            presentation::commands::bookmark_post,\n            presentation::commands::unbookmark_post,\n            presentation::commands::like_post,\n            presentation::commands::boost_post,\n            presentation::commands::get_bookmarked_post_ids,\n            presentation::commands::list_following_feed,\n            // Nostr関連コマンド\n            presentation::commands::initialize_nostr,\n            presentation::commands::publish_text_note,\n            presentation::commands::publish_topic_post,\n            presentation::commands::send_reaction,\n            presentation::commands::update_nostr_metadata,\n            presentation::commands::subscribe_to_topic,\n            presentation::commands::subscribe_to_user,\n            presentation::commands::disconnect_nostr,\n            presentation::commands::list_nostr_subscriptions,\n            // P2P関連コマンド\n            presentation::commands::initialize_p2p,\n            presentation::commands::join_p2p_topic,\n            presentation::commands::leave_p2p_topic,\n            presentation::commands::broadcast_to_topic,\n            presentation::commands::get_p2p_status,\n            presentation::commands::get_node_address,\n            presentation::commands::get_p2p_metrics,\n            // オフライン関連コマンド\n            presentation::commands::save_offline_action,\n            presentation::commands::get_offline_actions,\n            presentation::commands::sync_offline_actions,\n            presentation::commands::get_cache_status,\n            presentation::commands::list_sync_queue_items,\n            presentation::commands::add_to_sync_queue,\n            presentation::commands::update_cache_metadata,\n            presentation::commands::save_optimistic_update,\n            presentation::commands::confirm_optimistic_update,\n            presentation::commands::rollback_optimistic_update,\n            presentation::commands::cleanup_expired_cache,\n            presentation::commands::update_sync_status,\n            presentation::commands::record_offline_retry_outcome,\n            presentation::commands::get_offline_retry_metrics,\n            // Community Node commands\n            presentation::commands::set_community_node_config,\n            presentation::commands::get_community_node_config,\n            presentation::commands::clear_community_node_config,\n            presentation::commands::community_node_authenticate,\n            presentation::commands::community_node_clear_token,\n            presentation::commands::community_node_get_trust_anchor,\n            presentation::commands::community_node_set_trust_anchor,\n            presentation::commands::community_node_clear_trust_anchor,\n            presentation::commands::community_node_list_group_keys,\n            presentation::commands::community_node_list_labels,\n            presentation::commands::community_node_submit_report,\n            presentation::commands::community_node_trust_report_based,\n            presentation::commands::community_node_trust_communication_density,\n            presentation::commands::community_node_search,\n            presentation::commands::community_node_list_bootstrap_nodes,\n            presentation::commands::community_node_list_bootstrap_services,\n            presentation::commands::community_node_get_consent_status,\n            presentation::commands::community_node_accept_consents,\n            // Access Control (P2P join)\n            presentation::commands::access_control_issue_invite,\n            presentation::commands::access_control_request_join,\n            presentation::commands::access_control_list_join_requests,\n            presentation::commands::access_control_approve_join_request,\n            presentation::commands::access_control_reject_join_request,\n            // ユーティリティコマンド\n            presentation::commands::pubkey_to_npub,\n            presentation::commands::npub_to_pubkey,\n            // Bootstrap UI commands\n            presentation::commands::get_bootstrap_config,\n            presentation::commands::set_bootstrap_nodes,\n            presentation::commands::clear_bootstrap_nodes,\n            presentation::commands::apply_cli_bootstrap_nodes,\n            presentation::commands::get_relay_status,\n        ])\n        .setup(|app| {\n            // アプリケーション初期化処理\n            let app_handle = app.handle();\n\n            tauri::async_runtime::block_on(async move {\n                let app_state = AppState::new(app_handle)\n                    .await\n                    .expect(\"Failed to initialize app state\");\n                let offline_reindex_job = Arc::clone(&app_state.offline_reindex_job);\n                let user_service = Arc::clone(&app_state.user_service);\n                let user_search_service = Arc::clone(&app_state.user_search_service);\n                let event_service = Arc::clone(&app_state.event_service);\n                let p2p_service = Arc::clone(&app_state.p2p_service);\n                let offline_service = Arc::clone(&app_state.offline_service);\n                let profile_avatar_service = Arc::clone(&app_state.profile_avatar_service);\n\n                // P2P機能を初期化\n                if let Err(e) = app_state.initialize_p2p().await {\n                    tracing::warn!(\"Failed to initialize P2P: {}\", e);\n                }\n\n                // P2Pイベントハンドラーを起動\n                spawn_p2p_event_handler(app_handle.clone(), app_state.clone());\n\n                app_handle.manage(app_state.clone());\n                app_handle.manage(offline_reindex_job);\n                app_handle.manage(user_service);\n                app_handle.manage(user_search_service);\n                app_handle.manage(event_service);\n                app_handle.manage(p2p_service);\n                app_handle.manage(offline_service);\n                app_handle.manage(profile_avatar_service);\n            });\n\n            info!(\"Application setup complete\");\n            Ok(())\n        })\n        .run(tauri::generate_context!())\n        .expect(\"error while running tauri application\");\n}\n\nfn init_logging() {\n    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n    const DEFAULT_DIRECTIVES: &str = \"info,kukuri=debug\";\n    const MAINLINE_SUPPRESS_DIRECTIVE: &str = \"mainline::rpc::socket=error\";\n\n    let mut env_filter = tracing_subscriber::EnvFilter::try_from_default_env()\n        .unwrap_or_else(|_| DEFAULT_DIRECTIVES.into());\n\n    let suppress_mainline = std::env::var(\"RUST_LOG\")\n        .map(|value| !value.contains(\"mainline::rpc::socket\"))\n        .unwrap_or(true);\n\n    if suppress_mainline {\n        if let Ok(directive) = MAINLINE_SUPPRESS_DIRECTIVE.parse() {\n            env_filter = env_filter.add_directive(directive);\n        } else {\n            tracing::warn!(\n                \"Failed to parse mainline log suppression directive: {}\",\n                MAINLINE_SUPPRESS_DIRECTIVE\n            );\n        }\n    }\n\n    tracing_subscriber::registry()\n        .with(env_filter)\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n}\n\n/// P2Pイベントハンドラーを起動\nfn spawn_p2p_event_handler(app_handle: tauri::AppHandle, app_state: AppState) {\n    use serde::Serialize;\n\n    #[derive(Debug, Clone, Serialize)]\n    struct P2PMessageEvent {\n        topic_id: String,\n        message_type: String,\n        payload: Vec<u8>,\n        sender: Vec<u8>,\n        timestamp: i64,\n    }\n\n    #[derive(Debug, Clone, Serialize)]\n    struct P2PPeerEvent {\n        topic_id: String,\n        peer_id: Vec<u8>,\n        event_type: String, // \"joined\" or \"left\"\n    }\n\n    tauri::async_runtime::spawn(async move {\n        // event_rxを取得してRwLockを即座に解放\n        let rx = {\n            let p2p_state = app_state.p2p_state.read().await;\n            let mut event_rx = p2p_state.event_rx.write().await;\n            event_rx.take()\n        };\n\n        if let Some(mut rx) = rx {\n            loop {\n                match rx.recv().await {\n                    Ok(event) => match event {\n                        crate::domain::p2p::P2PEvent::MessageReceived {\n                            topic_id,\n                            message,\n                            _from_peer: _,\n                        } => {\n                            // 旧GossipMessage経路はUIの期待ペイロードと形状が異なるため、\n                            // 衝突回避のためイベント名を変更（デバッグ用途）\n                            let event_data = P2PMessageEvent {\n                                topic_id,\n                                message_type: format!(\"{:?}\", message.msg_type),\n                                payload: message.payload,\n                                sender: message.sender,\n                                timestamp: message.timestamp,\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://message/raw\", event_data) {\n                                tracing::error!(\"Failed to emit P2P raw message event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::PeerJoined { topic_id, peer_id } => {\n                            let event_data = P2PPeerEvent {\n                                topic_id,\n                                peer_id,\n                                event_type: \"joined\".to_string(),\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\n                                tracing::error!(\"Failed to emit P2P peer joined event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::PeerLeft { topic_id, peer_id } => {\n                            let event_data = P2PPeerEvent {\n                                topic_id,\n                                peer_id,\n                                event_type: \"left\".to_string(),\n                            };\n\n                            if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\n                                tracing::error!(\"Failed to emit P2P peer left event: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::NetworkConnected { node_id, addresses } => {\n                            if let Err(e) = app_handle.emit(\n                                \"p2p://network\",\n                                serde_json::json!({\n                                    \"event\": \"connected\",\n                                    \"nodeId\": node_id,\n                                    \"addresses\": addresses,\n                                }),\n                            ) {\n                                tracing::error!(\"Failed to emit P2P network connected: {}\", e);\n                            }\n                        }\n                        crate::domain::p2p::P2PEvent::NetworkDisconnected { node_id } => {\n                            if let Err(e) = app_handle.emit(\n                                \"p2p://network\",\n                                serde_json::json!({\n                                    \"event\": \"disconnected\",\n                                    \"nodeId\": node_id,\n                                }),\n                            ) {\n                                tracing::error!(\"Failed to emit P2P network disconnected: {}\", e);\n                            }\n                        }\n                    },\n                    Err(broadcast::error::RecvError::Closed) => break,\n                    Err(broadcast::error::RecvError::Lagged(skipped)) => {\n                        tracing::warn!(\"P2P event handler lagged and skipped {} events\", skipped);\n                        continue;\n                    }\n                }\n            }\n\n            tracing::info!(\"P2P event handler terminated\");\n        }\n    });\n}\n","traces":[{"line":69,"address":[44387438],"length":1,"stats":{"Line":0}},{"line":71,"address":[16969782],"length":1,"stats":{"Line":8}},{"line":73,"address":[16866939,16913567,16913433,16867345,16867485],"length":1,"stats":{"Line":1}},{"line":75,"address":[87655276,87655404,87654636,87654764,87654252,87655020,87655148,87655532,87654508,87654892,87655660,87654380,87655788],"length":1,"stats":{"Line":0}},{"line":76,"address":[75895060,75894589],"length":1,"stats":{"Line":0}},{"line":77,"address":[105827962,105826917],"length":1,"stats":{"Line":0}},{"line":78,"address":[39999178],"length":1,"stats":{"Line":0}},{"line":79,"address":[110298088,110298304,110298168,110298624,110299024,110298784,110298888,110298568,110298224,110298464,110298704,110298064,110298648,110298808,110298864,110298728,110298968,110299128,110298248,110298408,110298544,110298944,110299048,110298144,110299104,110298488,110298328,110298384],"length":1,"stats":{"Line":8}},{"line":81,"address":[109616475,109615835,109616635,109617035,109615515,109616715,109617115,109616315,109617275,109616555,109616875,109615915,109615755,109615595,109615995,109616075,109615675,109616155,109616235,109616795,109616955,109616395,109617195],"length":1,"stats":{"Line":8}},{"line":82,"address":[54514178],"length":1,"stats":{"Line":0}},{"line":83,"address":[115262144],"length":1,"stats":{"Line":0}},{"line":84,"address":[92275088],"length":1,"stats":{"Line":0}},{"line":86,"address":[69984288],"length":1,"stats":{"Line":1}},{"line":87,"address":[125172672],"length":1,"stats":{"Line":1}},{"line":88,"address":[105134640],"length":1,"stats":{"Line":0}},{"line":89,"address":[44269411],"length":1,"stats":{"Line":0}},{"line":90,"address":[65078439],"length":1,"stats":{"Line":0}},{"line":91,"address":[68504544,68504896,68504192],"length":1,"stats":{"Line":0}},{"line":93,"address":[73384208],"length":1,"stats":{"Line":16}},{"line":94,"address":[95188384,95188272,95188424,95188611,95188347,95188544,95188528,95188533],"length":1,"stats":{"Line":8}},{"line":95,"address":[50256842],"length":1,"stats":{"Line":8}},{"line":96,"address":[105860627,105860307,105860371,105853475,105860563,105860819,105860883,105861075,105861139,105853411,105853731,105853667],"length":1,"stats":{"Line":1}},{"line":97,"address":[76965983],"length":1,"stats":{"Line":9}},{"line":98,"address":[35704896],"length":1,"stats":{"Line":2}},{"line":99,"address":[44283244],"length":1,"stats":{"Line":9}},{"line":100,"address":[96657589],"length":1,"stats":{"Line":1}},{"line":101,"address":[112992776],"length":1,"stats":{"Line":1}},{"line":102,"address":[90894608],"length":1,"stats":{"Line":0}},{"line":103,"address":[112576436,112576252],"length":1,"stats":{"Line":2}},{"line":104,"address":[105380011,105380267,105372603,105372859,105379499,105379755],"length":1,"stats":{"Line":1}},{"line":105,"address":[71663810],"length":1,"stats":{"Line":9}},{"line":106,"address":[52362702,52362410,52363308],"length":1,"stats":{"Line":12}},{"line":107,"address":[83827423],"length":1,"stats":{"Line":10}},{"line":108,"address":[35663084],"length":1,"stats":{"Line":21}},{"line":110,"address":[81456341],"length":1,"stats":{"Line":19}},{"line":111,"address":[52224857,52224281],"length":1,"stats":{"Line":1}},{"line":112,"address":[115197026,115197515,115196704,115197792,115197386,115196846,115197768,115199285,115197086,115196786,115196906,115197760,115196737,115197644,115197825,115197146,115197449,115197266,115199280,115196966,115197206,115197707,115197581,115197326],"length":1,"stats":{"Line":9}},{"line":113,"address":[112564960],"length":1,"stats":{"Line":1}},{"line":114,"address":[52230865,52231268,52231806],"length":1,"stats":{"Line":10}},{"line":115,"address":[92714289,92714027,92714196,92714272],"length":1,"stats":{"Line":2}},{"line":116,"address":[117729200],"length":1,"stats":{"Line":8}},{"line":117,"address":[77437006],"length":1,"stats":{"Line":10}},{"line":118,"address":[49720030],"length":1,"stats":{"Line":10}},{"line":119,"address":[105836350,105836247],"length":1,"stats":{"Line":8}},{"line":120,"address":[112167080],"length":1,"stats":{"Line":2}},{"line":121,"address":[40879600],"length":1,"stats":{"Line":1}},{"line":123,"address":[59591732],"length":1,"stats":{"Line":9}},{"line":124,"address":[31041360],"length":1,"stats":{"Line":8}},{"line":125,"address":[121631792,121632080],"length":1,"stats":{"Line":9}},{"line":126,"address":[70059248],"length":1,"stats":{"Line":2}},{"line":127,"address":[77541792],"length":1,"stats":{"Line":2}},{"line":128,"address":[81985945,81985889,81986336,81986000,81986027,81985783,81985833,81985760,81986341],"length":1,"stats":{"Line":10}},{"line":129,"address":[123682803],"length":1,"stats":{"Line":9}},{"line":130,"address":[82239530,82239715],"length":1,"stats":{"Line":1}},{"line":131,"address":[71688656,71688608,71688576,71688675,71688688,71688693],"length":1,"stats":{"Line":4}},{"line":132,"address":[77061334],"length":1,"stats":{"Line":7}},{"line":134,"address":[108378104],"length":1,"stats":{"Line":0}},{"line":135,"address":[65084459],"length":1,"stats":{"Line":0}},{"line":136,"address":[81756626],"length":1,"stats":{"Line":4}},{"line":137,"address":[30604342],"length":1,"stats":{"Line":3}},{"line":138,"address":[88427989],"length":1,"stats":{"Line":1}},{"line":139,"address":[40098960],"length":1,"stats":{"Line":5}},{"line":140,"address":[115737243,115737298],"length":1,"stats":{"Line":3}},{"line":141,"address":[58769312,58769389],"length":1,"stats":{"Line":1}},{"line":142,"address":[81474320],"length":1,"stats":{"Line":4}},{"line":144,"address":[102468222],"length":1,"stats":{"Line":0}},{"line":145,"address":[30966968],"length":1,"stats":{"Line":8}},{"line":146,"address":[124296545,124296621],"length":1,"stats":{"Line":7}},{"line":147,"address":[71284656,71284640,71284672,71284624],"length":1,"stats":{"Line":8}},{"line":148,"address":[108419617],"length":1,"stats":{"Line":14}},{"line":149,"address":[35801646],"length":1,"stats":{"Line":11}},{"line":150,"address":[71793776],"length":1,"stats":{"Line":14}},{"line":152,"address":[95149573],"length":1,"stats":{"Line":145}},{"line":153,"address":[85023494],"length":1,"stats":{"Line":178}},{"line":154,"address":[62790148],"length":1,"stats":{"Line":145}},{"line":155,"address":[94536647,94536486],"length":1,"stats":{"Line":1}},{"line":156,"address":[71789881,71789907],"length":1,"stats":{"Line":15}},{"line":157,"address":[66895449,66894503,66896559],"length":1,"stats":{"Line":8}},{"line":158,"address":[67073272],"length":1,"stats":{"Line":19}},{"line":159,"address":[88346403],"length":1,"stats":{"Line":19}},{"line":160,"address":[125502695,125502471,125502530,125502080,125502327],"length":1,"stats":{"Line":180}},{"line":161,"address":[82041240],"length":1,"stats":{"Line":5}},{"line":162,"address":[95288221],"length":1,"stats":{"Line":2}},{"line":163,"address":[111112614],"length":1,"stats":{"Line":2}},{"line":164,"address":[125082068,125082273,125082347,125082568,125082890,125082146],"length":1,"stats":{"Line":83}},{"line":165,"address":[105267129],"length":1,"stats":{"Line":83}},{"line":167,"address":[122152536,122152696,122152768,122152712,122152648,122152680,122152600,122152568,122152728,122152584,122152616,122152632,122152664,122152552,122152744,122152512],"length":1,"stats":{"Line":2}},{"line":168,"address":[62832859],"length":1,"stats":{"Line":2}},{"line":169,"address":[11519184],"length":1,"stats":{"Line":3}},{"line":170,"address":[71928176],"length":1,"stats":{"Line":0}},{"line":171,"address":[111639746],"length":1,"stats":{"Line":1}},{"line":172,"address":[94430219],"length":1,"stats":{"Line":84}},{"line":173,"address":[124484544],"length":1,"stats":{"Line":2}},{"line":174,"address":[126840215],"length":1,"stats":{"Line":1}},{"line":175,"address":[105190682],"length":1,"stats":{"Line":3}},{"line":176,"address":[116149204],"length":1,"stats":{"Line":0}},{"line":177,"address":[117479068,117479225,117478867],"length":1,"stats":{"Line":4}},{"line":178,"address":[31543690],"length":1,"stats":{"Line":4}},{"line":179,"address":[81543377],"length":1,"stats":{"Line":7}},{"line":180,"address":[105267238],"length":1,"stats":{"Line":0}},{"line":181,"address":[49695458],"length":1,"stats":{"Line":0}},{"line":182,"address":[121445036,121445104,121444897],"length":1,"stats":{"Line":1}},{"line":183,"address":[83824245],"length":1,"stats":{"Line":1}},{"line":184,"address":[103732780,103733081],"length":1,"stats":{"Line":7}},{"line":186,"address":[81508293],"length":1,"stats":{"Line":0}},{"line":187,"address":[117575022,117574664,117574865],"length":1,"stats":{"Line":0}},{"line":188,"address":[76725126,76725286,76724913],"length":1,"stats":{"Line":4}},{"line":189,"address":[53813392],"length":1,"stats":{"Line":0}},{"line":190,"address":[124678275,124678199],"length":1,"stats":{"Line":6}},{"line":192,"address":[65064133],"length":1,"stats":{"Line":9}},{"line":193,"address":[74046899],"length":1,"stats":{"Line":5}},{"line":195,"address":[87689067,87688746],"length":1,"stats":{"Line":14}},{"line":196,"address":[51019484],"length":1,"stats":{"Line":5}},{"line":197,"address":[81394115],"length":1,"stats":{"Line":14}},{"line":198,"address":[57579304],"length":1,"stats":{"Line":2}},{"line":199,"address":[40231196],"length":1,"stats":{"Line":1}},{"line":201,"address":[53437168],"length":1,"stats":{"Line":6}},{"line":203,"address":[71711626],"length":1,"stats":{"Line":0}},{"line":205,"address":[71742864],"length":1,"stats":{"Line":0}},{"line":206,"address":[123579022],"length":1,"stats":{"Line":11}},{"line":207,"address":[69439461],"length":1,"stats":{"Line":2}},{"line":208,"address":[87277568],"length":1,"stats":{"Line":2}},{"line":209,"address":[84825742,84825816,84825649],"length":1,"stats":{"Line":2}},{"line":210,"address":[71794646,71794573],"length":1,"stats":{"Line":2}},{"line":211,"address":[71790752],"length":1,"stats":{"Line":2}},{"line":212,"address":[96651351],"length":1,"stats":{"Line":3}},{"line":213,"address":[50344339],"length":1,"stats":{"Line":2}},{"line":214,"address":[47634948,47635123],"length":1,"stats":{"Line":4}},{"line":215,"address":[66103412,66105460,66109556,66107892,66106228,66105588,66109300,66109940,66108020,66105972,66110068,66108788,66107252,66105844,66105332,66104052,66107508,66104180,66106484,66107764,66108404,66105204,66106100,66107380,66110196,66109044,66104564,66109172,66109428,66104820,66103028,66106612,66108276,66106356,66106996,66104692,66104948,66103156,66105076,66103540,66103284,66103796,66108532,66103924,66103668,66108148,66107636,66104308,66107124,66109812,66106740,66108660,66108916,66104436,66106868,66105716,66109684],"length":1,"stats":{"Line":2}},{"line":218,"address":[52687961],"length":1,"stats":{"Line":2}},{"line":219,"address":[110983146],"length":1,"stats":{"Line":3}},{"line":223,"address":[33030336],"length":1,"stats":{"Line":0}},{"line":225,"address":[21064830],"length":1,"stats":{"Line":3}},{"line":226,"address":[71685212,71685243],"length":1,"stats":{"Line":0}},{"line":227,"address":[124300883,124300739],"length":1,"stats":{"Line":1}},{"line":228,"address":[117439368],"length":1,"stats":{"Line":14}},{"line":229,"address":[44469560],"length":1,"stats":{"Line":14}},{"line":230,"address":[73452565],"length":1,"stats":{"Line":24}},{"line":231,"address":[71753040],"length":1,"stats":{"Line":28}},{"line":232,"address":[71770048],"length":1,"stats":{"Line":23}},{"line":235,"address":[62833541,62834260],"length":1,"stats":{"Line":3}},{"line":236,"address":[52787716,52787283,52787696,52787221],"length":1,"stats":{"Line":0}},{"line":238,"address":[87695636,87695605],"length":1,"stats":{"Line":27}},{"line":242,"address":[35833408,35835260,35835443],"length":1,"stats":{"Line":16}},{"line":248,"address":[123246748],"length":1,"stats":{"Line":4}},{"line":249,"address":[122461584],"length":1,"stats":{"Line":8}},{"line":251,"address":[116828001],"length":1,"stats":{"Line":8}},{"line":252,"address":[94843290],"length":1,"stats":{"Line":10}},{"line":255,"address":[70191169],"length":1,"stats":{"Line":12}},{"line":256,"address":[123863997],"length":1,"stats":{"Line":4}},{"line":257,"address":[77784072,77783971],"length":1,"stats":{"Line":4}},{"line":259,"address":[81425978],"length":1,"stats":{"Line":17}},{"line":266,"address":[121314990,121314750],"length":1,"stats":{"Line":13}},{"line":267,"address":[88265776],"length":1,"stats":{"Line":23}},{"line":268,"address":[65087582],"length":1,"stats":{"Line":17}},{"line":273,"address":[33535715,33535919,33536007],"length":1,"stats":{"Line":20}},{"line":292,"address":[82040414,82040146],"length":1,"stats":{"Line":19}},{"line":294,"address":[35228448],"length":1,"stats":{"Line":32}},{"line":295,"address":[52067898],"length":1,"stats":{"Line":30}},{"line":296,"address":[87694626,87694608],"length":1,"stats":{"Line":10}},{"line":297,"address":[30117593],"length":1,"stats":{"Line":3}},{"line":300,"address":[17080144,17080241],"length":1,"stats":{"Line":1}},{"line":301,"address":[121892035,121887147,121889593,121894422],"length":1,"stats":{"Line":11}},{"line":302,"address":[49787820,49787888,49787444],"length":1,"stats":{"Line":4}},{"line":303,"address":[65088407],"length":1,"stats":{"Line":0}},{"line":304,"address":[121316345],"length":1,"stats":{"Line":17}},{"line":305,"address":[40332256],"length":1,"stats":{"Line":12}},{"line":306,"address":[70800314],"length":1,"stats":{"Line":19}},{"line":307,"address":[123199649],"length":1,"stats":{"Line":14}},{"line":308,"address":[116106723],"length":1,"stats":{"Line":15}},{"line":311,"address":[111886609,111888955,111886352,111886565,111886768,111888232,111888733,111888689,111887181,111886146,111888025,111888999,111885733,111887387,111886969,111887814,111887616,111889388,111889176,111888444,111885942],"length":1,"stats":{"Line":5}},{"line":312,"address":[124050027],"length":1,"stats":{"Line":5}},{"line":313,"address":[25347177,25346876],"length":1,"stats":{"Line":4}},{"line":314,"address":[35732072,35731923],"length":1,"stats":{"Line":6}},{"line":315,"address":[70842653],"length":1,"stats":{"Line":18}},{"line":316,"address":[72691616,72691568,72691585,72691621,72691632,72691701],"length":1,"stats":{"Line":18}},{"line":319,"address":[36720924],"length":1,"stats":{"Line":1}},{"line":320,"address":[33510400],"length":1,"stats":{"Line":9}},{"line":323,"address":[16867957],"length":1,"stats":{"Line":10}},{"line":324,"address":[41018208,41018225],"length":1,"stats":{"Line":7}},{"line":325,"address":[74189329,74185464],"length":1,"stats":{"Line":8}},{"line":326,"address":[70974256],"length":1,"stats":{"Line":10}},{"line":327,"address":[99802052],"length":1,"stats":{"Line":0}},{"line":330,"address":[74049467,74049400],"length":1,"stats":{"Line":7}},{"line":331,"address":[120885427],"length":1,"stats":{"Line":7}},{"line":334,"address":[49336703],"length":1,"stats":{"Line":7}},{"line":335,"address":[76690386,76690835,76690705,76690819,76690495],"length":1,"stats":{"Line":9}},{"line":336,"address":[76725963],"length":1,"stats":{"Line":1}},{"line":337,"address":[40148160],"length":1,"stats":{"Line":8}},{"line":338,"address":[121913168],"length":1,"stats":{"Line":7}},{"line":341,"address":[72590067],"length":1,"stats":{"Line":2}},{"line":342,"address":[72590128],"length":1,"stats":{"Line":8}},{"line":345,"address":[82084429],"length":1,"stats":{"Line":0}},{"line":346,"address":[77898544],"length":1,"stats":{"Line":1}},{"line":347,"address":[84827808],"length":1,"stats":{"Line":7}},{"line":348,"address":[33763399,33763228],"length":1,"stats":{"Line":6}},{"line":349,"address":[87432250,87432215],"length":1,"stats":{"Line":6}},{"line":350,"address":[124208653],"length":1,"stats":{"Line":3}},{"line":351,"address":[87282152],"length":1,"stats":{"Line":0}},{"line":354,"address":[116150690],"length":1,"stats":{"Line":2}},{"line":357,"address":[77898807],"length":1,"stats":{"Line":3}},{"line":358,"address":[124116544,124116430],"length":1,"stats":{"Line":0}},{"line":359,"address":[71793177],"length":1,"stats":{"Line":0}},{"line":360,"address":[87282262],"length":1,"stats":{"Line":0}},{"line":361,"address":[71318015,71318024,71317923],"length":1,"stats":{"Line":0}},{"line":362,"address":[122278288,122278176,122277968,122278400],"length":1,"stats":{"Line":4}},{"line":365,"address":[121369904],"length":1,"stats":{"Line":2}},{"line":369,"address":[124738484,124738622,124738537],"length":1,"stats":{"Line":4}},{"line":370,"address":[66980498],"length":1,"stats":{"Line":2}},{"line":371,"address":[52888681],"length":1,"stats":{"Line":2}},{"line":372,"address":[49547166,49547117,49547240],"length":1,"stats":{"Line":3}},{"line":377,"address":[120843593],"length":1,"stats":{"Line":4}}],"covered":176,"coverable":212},{"path":["/","app","kukuri-tauri","src-tauri","src","main.rs"],"content":"// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n    kukuri_lib::run();\n}\n","traces":[{"line":4,"address":[10959600],"length":1,"stats":{"Line":0}},{"line":5,"address":[10959601],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","access_control_commands.rs"],"content":"use crate::application::ports::join_request_store::JoinRequestRecord;\nuse crate::application::services::JoinRequestInput;\nuse crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::access_control_dto::{\n    AccessControlApproveJoinRequest, AccessControlApproveJoinResponse,\n    AccessControlIssueInviteRequest, AccessControlIssueInviteResponse, AccessControlJoinRequest,\n    AccessControlJoinResponse, AccessControlListJoinRequestsResponse,\n    AccessControlPendingJoinRequest, AccessControlRejectJoinRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse tauri::State;\n\n#[tauri::command]\npub async fn access_control_issue_invite(\n    state: State<'_, AppState>,\n    request: AccessControlIssueInviteRequest,\n) -> Result<ApiResponse<AccessControlIssueInviteResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let invite_event_json = state\n        .access_control_service\n        .issue_invite(\n            request.topic_id.trim(),\n            request.expires_in,\n            request.max_uses,\n            request.nonce,\n        )\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlIssueInviteResponse {\n        invite_event_json,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_request_join(\n    state: State<'_, AppState>,\n    request: AccessControlJoinRequest,\n) -> Result<ApiResponse<AccessControlJoinResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let result = state\n        .access_control_service\n        .request_join(JoinRequestInput {\n            topic_id: request.topic_id,\n            scope: request.scope,\n            invite_event_json: request.invite_event_json,\n            target_pubkey: request.target_pubkey,\n            broadcast_to_topic: request.broadcast_to_topic.unwrap_or(false),\n        })\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlJoinResponse {\n        event_id: result.event_id,\n        sent_topics: result.sent_topics,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_list_join_requests(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<AccessControlListJoinRequestsResponse>, AppError> {\n    let records = state\n        .access_control_service\n        .list_pending_join_requests()\n        .await?;\n    let items = records\n        .into_iter()\n        .map(map_pending_join_request)\n        .collect::<Vec<_>>();\n    Ok(ApiResponse::success(\n        AccessControlListJoinRequestsResponse { items },\n    ))\n}\n\n#[tauri::command]\npub async fn access_control_approve_join_request(\n    state: State<'_, AppState>,\n    request: AccessControlApproveJoinRequest,\n) -> Result<ApiResponse<AccessControlApproveJoinResponse>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n\n    let result = state\n        .access_control_service\n        .approve_join_request(&request.event_id)\n        .await?;\n\n    Ok(ApiResponse::success(AccessControlApproveJoinResponse {\n        event_id: result.event_id,\n        key_envelope_event_id: result.key_envelope_event_id,\n    }))\n}\n\n#[tauri::command]\npub async fn access_control_reject_join_request(\n    state: State<'_, AppState>,\n    request: AccessControlRejectJoinRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    request\n        .validate()\n        .map_err(|err| AppError::validation(crate::shared::ValidationFailureKind::Generic, err))?;\n    state\n        .access_control_service\n        .reject_join_request(&request.event_id)\n        .await?;\n    Ok(ApiResponse::success(()))\n}\n\nfn map_pending_join_request(record: JoinRequestRecord) -> AccessControlPendingJoinRequest {\n    AccessControlPendingJoinRequest {\n        event_id: record.event.id,\n        topic_id: record.topic_id,\n        scope: record.scope,\n        requester_pubkey: record.requester_pubkey,\n        target_pubkey: record.target_pubkey,\n        requested_at: record.requested_at,\n        received_at: record.received_at,\n        invite_event_json: record.invite_event_json,\n    }\n}\n","traces":[{"line":16,"address":[22358112],"length":1,"stats":{"Line":0}},{"line":20,"address":[22432993,22433639,22433267,22433112],"length":1,"stats":{"Line":0}},{"line":22,"address":[22358627,22360208,22360223],"length":1,"stats":{"Line":0}},{"line":24,"address":[25017489,25017429,25017115,25017709,25017841,25017270,25018092],"length":1,"stats":{"Line":0}},{"line":27,"address":[22571847],"length":1,"stats":{"Line":0}},{"line":28,"address":[22475486],"length":1,"stats":{"Line":0}},{"line":29,"address":[22571934],"length":1,"stats":{"Line":0}},{"line":30,"address":[25017384],"length":1,"stats":{"Line":0}},{"line":32,"address":[22358459,22359016,22358956,22359107,22359562,22359263],"length":1,"stats":{"Line":0}},{"line":34,"address":[22477791,22477976],"length":1,"stats":{"Line":0}},{"line":35,"address":[22434055],"length":1,"stats":{"Line":0}},{"line":40,"address":[25018736],"length":1,"stats":{"Line":0}},{"line":44,"address":[22435227,22435340,22435477,22436175],"length":1,"stats":{"Line":0}},{"line":46,"address":[22475904,22475919,22473550],"length":1,"stats":{"Line":0}},{"line":48,"address":[22368183,22367605,22368237,22367754,22368539,22368653,22369050],"length":1,"stats":{"Line":0}},{"line":50,"address":[25019728],"length":1,"stats":{"Line":0}},{"line":51,"address":[22367777],"length":1,"stats":{"Line":0}},{"line":52,"address":[25019506],"length":1,"stats":{"Line":0}},{"line":53,"address":[22473791],"length":1,"stats":{"Line":0}},{"line":54,"address":[22374894],"length":1,"stats":{"Line":0}},{"line":55,"address":[22477821],"length":1,"stats":{"Line":0}},{"line":57,"address":[22361803,22360690,22361483,22361426,22361640,22362218],"length":1,"stats":{"Line":0}},{"line":59,"address":[22478767,22478984],"length":1,"stats":{"Line":0}},{"line":60,"address":[22443567],"length":1,"stats":{"Line":0}},{"line":61,"address":[25020525],"length":1,"stats":{"Line":0}},{"line":66,"address":[22444768],"length":1,"stats":{"Line":0}},{"line":69,"address":[22445291,22445402,22445107,22445611,22445033,22444908],"length":1,"stats":{"Line":0}},{"line":72,"address":[11708647],"length":1,"stats":{"Line":0}},{"line":73,"address":[16618292,16618473],"length":1,"stats":{"Line":0}},{"line":77,"address":[22371039],"length":1,"stats":{"Line":0}},{"line":78,"address":[22577295],"length":1,"stats":{"Line":0}},{"line":83,"address":[22445936],"length":1,"stats":{"Line":0}},{"line":87,"address":[25023000,25023240,25023467,25023121],"length":1,"stats":{"Line":0}},{"line":89,"address":[22481467,22483215,22483200],"length":1,"stats":{"Line":0}},{"line":91,"address":[22371586,22371799,22372818,22371845,22372070,22372261,22371735],"length":1,"stats":{"Line":0}},{"line":93,"address":[22477678],"length":1,"stats":{"Line":0}},{"line":94,"address":[16619474,16619718,16618975,16619338,16619392,16620290],"length":1,"stats":{"Line":0}},{"line":96,"address":[22447660,22447415],"length":1,"stats":{"Line":0}},{"line":97,"address":[22447335],"length":1,"stats":{"Line":0}},{"line":98,"address":[16620159],"length":1,"stats":{"Line":0}},{"line":103,"address":[22380368],"length":1,"stats":{"Line":0}},{"line":107,"address":[22366777,22366890,22367027,22367231],"length":1,"stats":{"Line":0}},{"line":109,"address":[22485276,22486191,22486176],"length":1,"stats":{"Line":0}},{"line":110,"address":[25025668,25025791,25025473,25025267,25026126,25025886,25025443,25025375],"length":1,"stats":{"Line":0}},{"line":112,"address":[22367092],"length":1,"stats":{"Line":0}},{"line":113,"address":[22580360,22580510,22580224,22580278,22580644,22579904],"length":1,"stats":{"Line":0}},{"line":114,"address":[25025919,25025831],"length":1,"stats":{"Line":0}},{"line":117,"address":[22343552,22344117],"length":1,"stats":{"Line":0}},{"line":119,"address":[22438369],"length":1,"stats":{"Line":0}},{"line":120,"address":[16479619],"length":1,"stats":{"Line":0}},{"line":121,"address":[22438411],"length":1,"stats":{"Line":0}},{"line":122,"address":[16479667],"length":1,"stats":{"Line":0}},{"line":123,"address":[22438465],"length":1,"stats":{"Line":0}},{"line":124,"address":[22343711],"length":1,"stats":{"Line":0}},{"line":125,"address":[22338134],"length":1,"stats":{"Line":0}},{"line":126,"address":[22342077],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","auth_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse, Validate,\n            auth_dto::{\n                ExportPrivateKeyRequest, ExportPrivateKeyResponse, LoginResponse,\n                LoginWithNsecRequest,\n            },\n        },\n        handlers::AuthHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse serde::{Deserialize, Serialize};\nuse tauri::State;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GenerateKeypairResponse {\n    pub public_key: String,\n    pub nsec: String,\n    pub npub: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginRequest {\n    pub nsec: String,\n}\n\n/// 新しいキーペアを生成する\n#[tauri::command]\npub async fn generate_keypair(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<GenerateKeypairResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let response = handler.create_account().await?;\n\n    Ok(ApiResponse::success(GenerateKeypairResponse {\n        public_key: response.pubkey,\n        nsec: response.nsec,\n        npub: response.npub,\n    }))\n}\n\n/// nsecで既存アカウントにログイン\n#[tauri::command]\npub async fn login(\n    state: State<'_, AppState>,\n    request: LoginRequest,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let login_request = LoginWithNsecRequest { nsec: request.nsec };\n\n    let result = handler.login_with_nsec(login_request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ログアウト\n#[tauri::command]\npub async fn logout(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let current_user = handler.get_current_user().await?;\n\n    if let Some(user) = current_user {\n        handler.logout(user.npub).await?;\n    }\n\n    Ok(ApiResponse::success(()))\n}\n\n/// 秘寁E��をエクスポ�E��する\n#[tauri::command]\npub async fn export_private_key(\n    state: State<'_, AppState>,\n    request: ExportPrivateKeyRequest,\n) -> Result<ApiResponse<ExportPrivateKeyResponse>, AppError> {\n    request.validate().map_err(AppError::InvalidInput)?;\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let nsec = handler.export_private_key(&request.npub).await?;\n\n    Ok(ApiResponse::success(ExportPrivateKeyResponse { nsec }))\n}\n","traces":[{"line":32,"address":[15741216],"length":1,"stats":{"Line":0}},{"line":35,"address":[21500828,21500945],"length":1,"stats":{"Line":0}},{"line":36,"address":[21569709,21568640,21568776,21568983,21568873],"length":1,"stats":{"Line":0}},{"line":38,"address":[21495127,21494850],"length":1,"stats":{"Line":0}},{"line":39,"address":[21494742],"length":1,"stats":{"Line":0}},{"line":40,"address":[21562590],"length":1,"stats":{"Line":0}},{"line":41,"address":[15507076],"length":1,"stats":{"Line":0}},{"line":47,"address":[21605216],"length":1,"stats":{"Line":0}},{"line":51,"address":[15507920,15507809],"length":1,"stats":{"Line":0}},{"line":52,"address":[21605595],"length":1,"stats":{"Line":0}},{"line":54,"address":[11411777],"length":1,"stats":{"Line":0}},{"line":55,"address":[21702514],"length":1,"stats":{"Line":0}},{"line":60,"address":[21564272,21564248,21565543,21564399,21564738,21564240,21564457,21564307],"length":1,"stats":{"Line":0}},{"line":61,"address":[21503674,21503546],"length":1,"stats":{"Line":0}},{"line":62,"address":[21503594,21503938,21504677,21504330,21503827,21503745],"length":1,"stats":{"Line":0}},{"line":64,"address":[21608937,21608817],"length":1,"stats":{"Line":0}},{"line":65,"address":[15509785,15508840,15509647,15510158,15509884],"length":1,"stats":{"Line":0}},{"line":68,"address":[21565358,21565994],"length":1,"stats":{"Line":0}},{"line":73,"address":[21608272],"length":1,"stats":{"Line":0}},{"line":77,"address":[21573442,21573898,21573329,21573540],"length":1,"stats":{"Line":0}},{"line":78,"address":[21505755,21505864],"length":1,"stats":{"Line":0}},{"line":79,"address":[11554964],"length":1,"stats":{"Line":0}},{"line":81,"address":[21499784,21499559],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","community_node_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::community_node_dto::{\n    CommunityNodeAuthRequest, CommunityNodeAuthResponse, CommunityNodeBootstrapServicesRequest,\n    CommunityNodeConfigRequest, CommunityNodeConfigResponse, CommunityNodeConsentRequest,\n    CommunityNodeLabelsRequest, CommunityNodeReportRequest, CommunityNodeSearchRequest,\n    CommunityNodeTokenRequest, CommunityNodeTrustAnchorRequest, CommunityNodeTrustAnchorState,\n    CommunityNodeTrustRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse tauri::State;\n\n#[tauri::command]\npub async fn set_community_node_config(\n    state: State<'_, AppState>,\n    request: CommunityNodeConfigRequest,\n) -> Result<ApiResponse<CommunityNodeConfigResponse>, AppError> {\n    let result = state.community_node_handler.set_config(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_community_node_config(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<CommunityNodeConfigResponse>>, AppError> {\n    let result = state.community_node_handler.get_config().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn clear_community_node_config(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_config().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_authenticate(\n    state: State<'_, AppState>,\n    request: CommunityNodeAuthRequest,\n) -> Result<ApiResponse<CommunityNodeAuthResponse>, AppError> {\n    let result = state.community_node_handler.authenticate(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_clear_token(\n    state: State<'_, AppState>,\n    request: CommunityNodeTokenRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_token(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_get_trust_anchor(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<CommunityNodeTrustAnchorState>>, AppError> {\n    let result = state.community_node_handler.get_trust_anchor().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_set_trust_anchor(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustAnchorRequest,\n) -> Result<ApiResponse<CommunityNodeTrustAnchorState>, AppError> {\n    let result = state.community_node_handler.set_trust_anchor(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_clear_trust_anchor(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = state.community_node_handler.clear_trust_anchor().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_group_keys(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<crate::application::ports::group_key_store::GroupKeyEntry>>, AppError> {\n    let result = state.community_node_handler.list_group_keys().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_labels(\n    state: State<'_, AppState>,\n    request: CommunityNodeLabelsRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.list_labels(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_submit_report(\n    state: State<'_, AppState>,\n    request: CommunityNodeReportRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.submit_report(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_trust_report_based(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .trust_report_based(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_trust_communication_density(\n    state: State<'_, AppState>,\n    request: CommunityNodeTrustRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .trust_communication_density(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_search(\n    state: State<'_, AppState>,\n    request: CommunityNodeSearchRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.search(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_bootstrap_nodes(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.list_bootstrap_nodes().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_list_bootstrap_services(\n    state: State<'_, AppState>,\n    request: CommunityNodeBootstrapServicesRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .list_bootstrap_services(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_get_consent_status(\n    state: State<'_, AppState>,\n    request: CommunityNodeTokenRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state\n        .community_node_handler\n        .get_consent_status(request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn community_node_accept_consents(\n    state: State<'_, AppState>,\n    request: CommunityNodeConsentRequest,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.community_node_handler.accept_consents(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":14,"address":[22480640],"length":1,"stats":{"Line":0}},{"line":18,"address":[11667921],"length":1,"stats":{"Line":0}},{"line":19,"address":[22481359],"length":1,"stats":{"Line":0}},{"line":23,"address":[22450352],"length":1,"stats":{"Line":0}},{"line":26,"address":[22369081,22368964,22369016,22369233],"length":1,"stats":{"Line":0}},{"line":27,"address":[16623750],"length":1,"stats":{"Line":0}},{"line":31,"address":[22369568],"length":1,"stats":{"Line":0}},{"line":34,"address":[11676676],"length":1,"stats":{"Line":0}},{"line":35,"address":[22482855],"length":1,"stats":{"Line":0}},{"line":39,"address":[22486912],"length":1,"stats":{"Line":0}},{"line":43,"address":[11682385],"length":1,"stats":{"Line":0}},{"line":44,"address":[16625310],"length":1,"stats":{"Line":0}},{"line":48,"address":[22452704],"length":1,"stats":{"Line":0}},{"line":52,"address":[11633521],"length":1,"stats":{"Line":0}},{"line":53,"address":[22378687],"length":1,"stats":{"Line":0}},{"line":57,"address":[22385840],"length":1,"stats":{"Line":0}},{"line":60,"address":[22379029,22379091,22378977,22379254],"length":1,"stats":{"Line":0}},{"line":61,"address":[22491062],"length":1,"stats":{"Line":0}},{"line":65,"address":[22379680],"length":1,"stats":{"Line":0}},{"line":69,"address":[22386977,22386925,22387301,22387040],"length":1,"stats":{"Line":0}},{"line":70,"address":[22380631],"length":1,"stats":{"Line":0}},{"line":74,"address":[22374032],"length":1,"stats":{"Line":0}},{"line":77,"address":[22387957,22388182,22388019,22387905],"length":1,"stats":{"Line":0}},{"line":78,"address":[22374632],"length":1,"stats":{"Line":0}},{"line":82,"address":[22491392],"length":1,"stats":{"Line":0}},{"line":85,"address":[12347855,12347745,12348002,12347793],"length":1,"stats":{"Line":0}},{"line":86,"address":[22488056],"length":1,"stats":{"Line":0}},{"line":90,"address":[22375472],"length":1,"stats":{"Line":0}},{"line":94,"address":[12348600,12348648,12348975,12348711],"length":1,"stats":{"Line":0}},{"line":95,"address":[22489079],"length":1,"stats":{"Line":0}},{"line":99,"address":[22589632],"length":1,"stats":{"Line":0}},{"line":103,"address":[10959853],"length":1,"stats":{"Line":0}},{"line":104,"address":[12350222],"length":1,"stats":{"Line":0}},{"line":108,"address":[22391392],"length":1,"stats":{"Line":0}},{"line":112,"address":[22377998,22378309,22377883,22378077,22378128],"length":1,"stats":{"Line":0}},{"line":114,"address":[22459546],"length":1,"stats":{"Line":0}},{"line":115,"address":[11672273],"length":1,"stats":{"Line":0}},{"line":116,"address":[16632724],"length":1,"stats":{"Line":0}},{"line":120,"address":[22453200],"length":1,"stats":{"Line":0}},{"line":124,"address":[22592176,22592357,22591931,22592046,22592125],"length":1,"stats":{"Line":0}},{"line":126,"address":[22385786],"length":1,"stats":{"Line":0}},{"line":127,"address":[12351868,12351816,12351785,12352009,12351611],"length":1,"stats":{"Line":0}},{"line":128,"address":[22379396],"length":1,"stats":{"Line":0}},{"line":132,"address":[16633888],"length":1,"stats":{"Line":0}},{"line":136,"address":[22498283,22498220,22498563,22498168],"length":1,"stats":{"Line":0}},{"line":137,"address":[22455079],"length":1,"stats":{"Line":0}},{"line":141,"address":[22462192],"length":1,"stats":{"Line":0}},{"line":144,"address":[11710999],"length":1,"stats":{"Line":0}},{"line":145,"address":[22497941],"length":1,"stats":{"Line":0}},{"line":149,"address":[22594496],"length":1,"stats":{"Line":0}},{"line":153,"address":[22498509,22498315,22498741,22498430,22498560],"length":1,"stats":{"Line":0}},{"line":155,"address":[16636122],"length":1,"stats":{"Line":0}},{"line":156,"address":[22395656,22395760,22395487,22395909,22395704],"length":1,"stats":{"Line":0}},{"line":157,"address":[22382212],"length":1,"stats":{"Line":0}},{"line":161,"address":[22495104],"length":1,"stats":{"Line":0}},{"line":165,"address":[22499235,22499416,22499467,22499350,22499648],"length":1,"stats":{"Line":0}},{"line":167,"address":[22499378],"length":1,"stats":{"Line":0}},{"line":168,"address":[11590593],"length":1,"stats":{"Line":0}},{"line":169,"address":[22596191],"length":1,"stats":{"Line":0}},{"line":173,"address":[22501584],"length":1,"stats":{"Line":0}},{"line":177,"address":[11592145],"length":1,"stats":{"Line":0}},{"line":178,"address":[22500737],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","direct_message_commands.rs"],"content":"use crate::{\n    presentation::dto::{\n        ApiResponse,\n        direct_message_dto::{\n            DirectMessageConversationListDto, DirectMessagePage,\n            ListDirectMessageConversationsRequest, ListDirectMessagesRequest,\n            MarkDirectMessageConversationReadRequest, SeedDirectMessageRequest,\n            SeedDirectMessageResponse, SendDirectMessageRequest, SendDirectMessageResponse,\n        },\n    },\n    presentation::handlers::DirectMessageHandler,\n    shared::AppError,\n    state::AppState,\n};\nuse nostr_sdk::prelude::{FromBech32, Keys, SecretKey, ToBech32};\nuse tauri::State;\nuse tracing::warn;\n\nasync fn ensure_authenticated(\n    state: &State<'_, AppState>,\n    fallback_nsec: Option<&str>,\n) -> Result<String, AppError> {\n    if let Ok(pair) = state.key_manager.current_keypair().await {\n        return Ok(pair.npub.clone());\n    }\n\n    if let Some(user) = state.auth_service.get_current_user().await? {\n        if let Ok(nsec) = state.key_manager.export_private_key(&user.npub).await {\n            let restored = state.key_manager.import_private_key(&nsec).await?;\n            return Ok(restored.npub);\n        }\n    }\n\n    if let Some(nsec) = fallback_nsec {\n        if let Ok(secret_key) = SecretKey::from_bech32(nsec) {\n            let keys = Keys::new(secret_key);\n            if let Err(err) = state.key_manager.import_private_key(nsec).await {\n                warn!(\n                    error = %err,\n                    \"Failed to import fallback nsec during authentication; continuing with derived npub\"\n                );\n            }\n            return keys\n                .public_key()\n                .to_bech32()\n                .map_err(|err| AppError::Crypto(format!(\"Failed to convert npub: {err}\")));\n        }\n    }\n\n    Err(AppError::Unauthorized(\n        \"Authentication required: failed to load key material\".to_string(),\n    ))\n}\n\nfn is_e2e_allowed() -> bool {\n    cfg!(debug_assertions)\n        || tauri::is_dev()\n        || matches!(std::env::var(\"TAURI_ENV_DEBUG\"), Ok(value) if value == \"true\")\n}\n\n#[tauri::command]\npub async fn send_direct_message(\n    state: State<'_, AppState>,\n    request: SendDirectMessageRequest,\n) -> Result<ApiResponse<SendDirectMessageResponse>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler.send_direct_message(&owner_npub, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn list_direct_messages(\n    state: State<'_, AppState>,\n    request: ListDirectMessagesRequest,\n) -> Result<ApiResponse<DirectMessagePage>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler.list_direct_messages(&owner_npub, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn list_direct_message_conversations(\n    state: State<'_, AppState>,\n    request: ListDirectMessageConversationsRequest,\n) -> Result<ApiResponse<DirectMessageConversationListDto>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler\n        .list_direct_message_conversations(&owner_npub, request)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn mark_direct_message_conversation_read(\n    state: State<'_, AppState>,\n    request: MarkDirectMessageConversationReadRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let owner_npub = ensure_authenticated(&state, None).await?;\n    let handler = DirectMessageHandler::new(state.direct_message_service.clone());\n    let result = handler\n        .mark_conversation_as_read(&owner_npub, request)\n        .await\n        .map(|_| ());\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn seed_direct_message_for_e2e(\n    state: State<'_, AppState>,\n    request: SeedDirectMessageRequest,\n) -> Result<ApiResponse<SeedDirectMessageResponse>, AppError> {\n    if !is_e2e_allowed() {\n        return Err(AppError::Unauthorized(\n            \"E2E direct message seeding is disabled\".to_string(),\n        ));\n    }\n\n    let owner_nsec = request.recipient_nsec.as_deref();\n    let owner_npub = ensure_authenticated(&state, owner_nsec).await?;\n    let content = request\n        .content\n        .unwrap_or_else(|| \"Seeded direct message for E2E\".to_string());\n    let created_at = request\n        .created_at\n        .unwrap_or_else(|| chrono::Utc::now().timestamp_millis());\n\n    let message = state\n        .direct_message_service\n        .seed_incoming_message_for_e2e(&owner_npub, &content, Some(created_at), owner_nsec)\n        .await?;\n\n    let response = SeedDirectMessageResponse {\n        conversation_npub: message.conversation_npub.clone(),\n        created_at: message.created_at_millis(),\n        content: message\n            .decrypted_content\n            .clone()\n            .unwrap_or_else(String::new),\n    };\n\n    Ok(ApiResponse::from_result(Ok(response)))\n}\n","traces":[{"line":19,"address":[24865344],"length":1,"stats":{"Line":0}},{"line":23,"address":[23956142,23955987,23955927,23956351],"length":1,"stats":{"Line":0}},{"line":24,"address":[24735037,24734955],"length":1,"stats":{"Line":0}},{"line":27,"address":[24771571,24769196,24770424],"length":1,"stats":{"Line":0}},{"line":28,"address":[24767318,24767202,24767640,24765281],"length":1,"stats":{"Line":0}},{"line":29,"address":[11614655],"length":1,"stats":{"Line":0}},{"line":30,"address":[24656921],"length":1,"stats":{"Line":0}},{"line":34,"address":[24662494,24661673],"length":1,"stats":{"Line":0}},{"line":35,"address":[24737278,24737338],"length":1,"stats":{"Line":0}},{"line":36,"address":[24868953],"length":1,"stats":{"Line":0}},{"line":37,"address":[24656083,24655996,24652619,24657424],"length":1,"stats":{"Line":0}},{"line":38,"address":[24665278,24785785,24664676,24664777,24785919],"length":1,"stats":{"Line":0}},{"line":43,"address":[24659728,24659657],"length":1,"stats":{"Line":0}},{"line":46,"address":[24659921,24659904],"length":1,"stats":{"Line":0}},{"line":50,"address":[24774579],"length":1,"stats":{"Line":0}},{"line":51,"address":[24868856],"length":1,"stats":{"Line":0}},{"line":62,"address":[24779440],"length":1,"stats":{"Line":0}},{"line":66,"address":[19034646,19034019,19034172,19034289,19034102],"length":1,"stats":{"Line":0}},{"line":67,"address":[24993386,24993549],"length":1,"stats":{"Line":0}},{"line":68,"address":[24854405,24855140,24855238,24855575],"length":1,"stats":{"Line":0}},{"line":69,"address":[24787977],"length":1,"stats":{"Line":0}},{"line":73,"address":[24899728],"length":1,"stats":{"Line":0}},{"line":77,"address":[24863377,24863488,24863224,24863307,24863839],"length":1,"stats":{"Line":0}},{"line":78,"address":[24094839,24094991],"length":1,"stats":{"Line":0}},{"line":79,"address":[11646780],"length":1,"stats":{"Line":0}},{"line":80,"address":[24857773],"length":1,"stats":{"Line":0}},{"line":84,"address":[24797088],"length":1,"stats":{"Line":0}},{"line":88,"address":[19037831,19037914,19037984,19038095,19038434],"length":1,"stats":{"Line":0}},{"line":89,"address":[24096706,24096557],"length":1,"stats":{"Line":0}},{"line":90,"address":[24997405,24997896,24997595,24997541],"length":1,"stats":{"Line":0}},{"line":91,"address":[24784350,24784431],"length":1,"stats":{"Line":0}},{"line":92,"address":[24865145,24866016,24866070,24866408,24866233],"length":1,"stats":{"Line":0}},{"line":93,"address":[24859540],"length":1,"stats":{"Line":0}},{"line":97,"address":[24901728],"length":1,"stats":{"Line":0}},{"line":101,"address":[24785355,24785272,24785536,24785425,24785875],"length":1,"stats":{"Line":0}},{"line":102,"address":[24904295,24904138],"length":1,"stats":{"Line":0}},{"line":103,"address":[24867788,24867598,24867734,24868187,24868079],"length":1,"stats":{"Line":0}},{"line":104,"address":[24860687,24860768],"length":1,"stats":{"Line":0}},{"line":105,"address":[24861050,24861199,24859962,24860833,24860887],"length":1,"stats":{"Line":0}},{"line":106,"address":[19041200],"length":1,"stats":{"Line":0}},{"line":107,"address":[24999766],"length":1,"stats":{"Line":0}},{"line":111,"address":[24868432],"length":1,"stats":{"Line":0}},{"line":115,"address":[24905519,24905656],"length":1,"stats":{"Line":0}},{"line":116,"address":[24794248],"length":1,"stats":{"Line":0}},{"line":117,"address":[24905662],"length":1,"stats":{"Line":0}},{"line":121,"address":[25000477,25000690],"length":1,"stats":{"Line":0}},{"line":122,"address":[24904265,24904439,24903919,24904894,24905507],"length":1,"stats":{"Line":0}},{"line":123,"address":[24900867],"length":1,"stats":{"Line":0}},{"line":125,"address":[24871708,24871696],"length":1,"stats":{"Line":0}},{"line":126,"address":[24788390,24788488],"length":1,"stats":{"Line":0}},{"line":128,"address":[24797012,24797008],"length":1,"stats":{"Line":0}},{"line":130,"address":[24901812,24901200,24901427,24901731,24901507,24902022],"length":1,"stats":{"Line":0}},{"line":132,"address":[24795345],"length":1,"stats":{"Line":0}},{"line":133,"address":[11638882],"length":1,"stats":{"Line":0}},{"line":136,"address":[24863832],"length":1,"stats":{"Line":0}},{"line":137,"address":[24789399],"length":1,"stats":{"Line":0}},{"line":138,"address":[24907752],"length":1,"stats":{"Line":0}},{"line":144,"address":[24871122],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","event_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::event::{\n    EventResponse, NostrMetadataDto, PublishTextNoteRequest, PublishTopicPostRequest,\n    SendReactionRequest, SubscribeRequest, UpdateMetadataRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// Nostrクライアントを初期化（ログイン時に呼び出す）\n#[tauri::command]\npub async fn initialize_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.initialize_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// テキストノートを投稿\n#[tauri::command]\npub async fn publish_text_note(\n    content: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTextNoteRequest { content };\n\n    let result = state.event_handler.publish_text_note(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピック投稿を作成\n#[tauri::command]\npub async fn publish_topic_post(\n    topic_id: String,\n    content: String,\n    reply_to: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTopicPostRequest {\n        topic_id,\n        content,\n        reply_to,\n    };\n\n    let result = state.event_handler.publish_topic_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// リアクションを送信\n#[tauri::command]\npub async fn send_reaction(\n    event_id: String,\n    reaction: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = SendReactionRequest { event_id, reaction };\n\n    let result = state.event_handler.send_reaction(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// メタデータを更新\n#[tauri::command]\npub async fn update_nostr_metadata(\n    metadata: NostrMetadataDto,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = UpdateMetadataRequest { metadata };\n\n    let result = state.event_handler.update_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_topic(\n    topic_id: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let request = SubscribeRequest { topic_id };\n\n    let result = state.event_handler.subscribe_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ユーザーをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_user(\n    pubkey: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.subscribe_to_user(pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のNostr購読状態を取得\n#[tauri::command]\npub async fn list_nostr_subscriptions(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.list_subscriptions().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// Nostrクライアントを切断\n#[tauri::command]\npub async fn disconnect_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.disconnect_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":13,"address":[20014416],"length":1,"stats":{"Line":0}},{"line":16,"address":[11552500],"length":1,"stats":{"Line":0}},{"line":17,"address":[19902295],"length":1,"stats":{"Line":0}},{"line":22,"address":[20115488],"length":1,"stats":{"Line":0}},{"line":26,"address":[19984113],"length":1,"stats":{"Line":0}},{"line":28,"address":[11442526],"length":1,"stats":{"Line":0}},{"line":29,"address":[14157473],"length":1,"stats":{"Line":0}},{"line":34,"address":[20019984],"length":1,"stats":{"Line":0}},{"line":46,"address":[11459633],"length":1,"stats":{"Line":0}},{"line":47,"address":[20117405],"length":1,"stats":{"Line":0}},{"line":52,"address":[20021152],"length":1,"stats":{"Line":0}},{"line":57,"address":[19979342],"length":1,"stats":{"Line":0}},{"line":59,"address":[19918689,19918574,19918914,19918626],"length":1,"stats":{"Line":0}},{"line":60,"address":[19919152],"length":1,"stats":{"Line":0}},{"line":65,"address":[19912368],"length":1,"stats":{"Line":0}},{"line":69,"address":[14160141],"length":1,"stats":{"Line":0}},{"line":71,"address":[11465937],"length":1,"stats":{"Line":0}},{"line":72,"address":[19981030],"length":1,"stats":{"Line":0}},{"line":77,"address":[14160928],"length":1,"stats":{"Line":0}},{"line":81,"address":[19906801],"length":1,"stats":{"Line":0}},{"line":83,"address":[11527678],"length":1,"stats":{"Line":0}},{"line":84,"address":[19914135],"length":1,"stats":{"Line":0}},{"line":89,"address":[20025808],"length":1,"stats":{"Line":0}},{"line":93,"address":[10799774],"length":1,"stats":{"Line":0}},{"line":94,"address":[20709485],"length":1,"stats":{"Line":0}},{"line":99,"address":[19915168],"length":1,"stats":{"Line":0}},{"line":102,"address":[19983089,19983366,19983203,19983141],"length":1,"stats":{"Line":0}},{"line":103,"address":[20025624],"length":1,"stats":{"Line":0}},{"line":108,"address":[20027392],"length":1,"stats":{"Line":0}},{"line":111,"address":[11557972],"length":1,"stats":{"Line":0}},{"line":112,"address":[20026344],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","mod.rs"],"content":"#![allow(unused_imports)]\r\n\r\npub mod access_control_commands;\npub mod auth_commands;\npub mod community_node_commands;\npub mod direct_message_commands;\npub mod event_commands;\npub mod offline_commands;\npub mod p2p_commands;\npub mod post_commands;\npub mod secure_storage_commands;\npub mod topic_commands;\npub mod user_commands;\npub mod utils_commands;\n\npub use access_control_commands::*;\npub use auth_commands::*;\npub use community_node_commands::*;\npub use direct_message_commands::*;\npub use event_commands::*;\npub use offline_commands::*;\npub use p2p_commands::*;\npub use post_commands::*;\npub use secure_storage_commands::*;\npub use topic_commands::*;\npub use user_commands::*;\npub use utils_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","offline_commands.rs"],"content":"use crate::infrastructure::offline::metrics::{\n    self, OfflineRetryMetricsSnapshot, RetryOutcomeMetadata, RetryOutcomeStatus,\n};\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, GetOfflineActionsRequest,\n    ListSyncQueueItemsRequest, OfflineAction, OfflineRetryMetricsResponse, OptimisticUpdateRequest,\n    RecordOfflineRetryOutcomeRequest, SaveOfflineActionRequest, SaveOfflineActionResponse,\n    SyncOfflineActionsRequest, SyncOfflineActionsResponse, SyncQueueItemResponse,\n    UpdateCacheMetadataRequest, UpdateSyncStatusRequest,\n};\nuse crate::presentation::dto::{ApiResponse, Validate};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// オフラインアクションを保存\n#[tauri::command]\npub async fn save_offline_action(\n    state: State<'_, AppState>,\n    request: SaveOfflineActionRequest,\n) -> Result<ApiResponse<SaveOfflineActionResponse>, AppError> {\n    let result = state.offline_handler.save_offline_action(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを取得\n#[tauri::command]\npub async fn get_offline_actions(\n    state: State<'_, AppState>,\n    request: GetOfflineActionsRequest,\n) -> Result<ApiResponse<Vec<OfflineAction>>, AppError> {\n    let result = state.offline_handler.get_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを同期\n#[tauri::command]\npub async fn sync_offline_actions(\n    state: State<'_, AppState>,\n    request: SyncOfflineActionsRequest,\n) -> Result<ApiResponse<SyncOfflineActionsResponse>, AppError> {\n    let result = state.offline_handler.sync_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュステータスを取得\n#[tauri::command]\npub async fn get_cache_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<CacheStatusResponse>, AppError> {\n    let result = state.offline_handler.get_cache_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期キューの状態を取得\n#[tauri::command]\npub async fn list_sync_queue_items(\n    state: State<'_, AppState>,\n    request: ListSyncQueueItemsRequest,\n) -> Result<ApiResponse<Vec<SyncQueueItemResponse>>, AppError> {\n    let result = state.offline_handler.list_sync_queue_items(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期キューに追加\n#[tauri::command]\npub async fn add_to_sync_queue(\n    state: State<'_, AppState>,\n    request: AddToSyncQueueRequest,\n) -> Result<ApiResponse<i64>, AppError> {\n    let result = state.offline_handler.add_to_sync_queue(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュメタデータを更新\n#[tauri::command]\npub async fn update_cache_metadata(\n    state: State<'_, AppState>,\n    request: UpdateCacheMetadataRequest,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state.offline_handler.update_cache_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を保存\n#[tauri::command]\npub async fn save_optimistic_update(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    original_data: Option<String>,\n    updated_data: String,\n) -> Result<ApiResponse<String>, AppError> {\n    let request = OptimisticUpdateRequest {\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n    };\n\n    let result = state.offline_handler.save_optimistic_update(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を確定\n#[tauri::command]\npub async fn confirm_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state\n        .offline_handler\n        .confirm_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新をロールバック\n#[tauri::command]\npub async fn rollback_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Option<String>>, AppError> {\n    let result = state\n        .offline_handler\n        .rollback_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 期限切れキャッシュをクリーンアップ\n#[tauri::command]\npub async fn cleanup_expired_cache(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<i32>, AppError> {\n    let result = state.offline_handler.cleanup_expired_cache().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期ステータスを更新\n#[tauri::command]\npub async fn update_sync_status(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    sync_status: String,\n    conflict_data: Option<String>,\n) -> Result<ApiResponse<Value>, AppError> {\n    let request = UpdateSyncStatusRequest {\n        entity_type,\n        entity_id,\n        sync_status,\n        conflict_data,\n    };\n\n    let result = state.offline_handler.update_sync_status(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn record_offline_retry_outcome(\n    request: RecordOfflineRetryOutcomeRequest,\n) -> Result<ApiResponse<OfflineRetryMetricsResponse>, AppError> {\n    request.validate()?;\n    let status = match request.status.as_str() {\n        \"success\" => RetryOutcomeStatus::Success,\n        _ => RetryOutcomeStatus::Failure,\n    };\n\n    let metadata = RetryOutcomeMetadata {\n        job_id: request.job_id.clone(),\n        job_reason: request.job_reason.clone(),\n        trigger: request.trigger.clone(),\n        user_pubkey: request.user_pubkey.clone(),\n        retry_count: request.retry_count.map(|value| value as u32),\n        max_retries: request.max_retries.map(|value| value as u32),\n        backoff_ms: request.backoff_ms,\n        duration_ms: request.duration_ms,\n        success_count: request.success_count.map(|value| value as u32),\n        failure_count: request.failure_count.map(|value| value as u32),\n        timestamp_ms: request.timestamp_ms,\n    };\n\n    let snapshot = metrics::record_outcome(status, &metadata);\n    Ok(ApiResponse::success(snapshot.into()))\n}\n\n#[tauri::command]\npub async fn get_offline_retry_metrics()\n-> Result<ApiResponse<OfflineRetryMetricsResponse>, AppError> {\n    let snapshot = metrics::snapshot();\n    Ok(ApiResponse::success(snapshot.into()))\n}\n\nimpl From<OfflineRetryMetricsSnapshot> for OfflineRetryMetricsResponse {\n    fn from(value: OfflineRetryMetricsSnapshot) -> Self {\n        Self {\n            total_success: value.total_success,\n            total_failure: value.total_failure,\n            consecutive_failure: value.consecutive_failure,\n            last_success_ms: value.last_success_ms,\n            last_failure_ms: value.last_failure_ms,\n            last_outcome: value.last_outcome.map(|status| match status {\n                RetryOutcomeStatus::Success => \"success\".to_string(),\n                RetryOutcomeStatus::Failure => \"failure\".to_string(),\n            }),\n            last_job_id: value.last_job_id,\n            last_job_reason: value.last_job_reason,\n            last_trigger: value.last_trigger,\n            last_user_pubkey: value.last_user_pubkey,\n            last_retry_count: value.last_retry_count.map(|v| v as i32),\n            last_max_retries: value.last_max_retries.map(|v| v as i32),\n            last_backoff_ms: value.last_backoff_ms,\n            last_duration_ms: value.last_duration_ms,\n            last_success_count: value.last_success_count.map(|v| v as i32),\n            last_failure_count: value.last_failure_count.map(|v| v as i32),\n            last_timestamp_ms: value.last_timestamp_ms,\n        }\n    }\n}\n","traces":[{"line":19,"address":[24864848],"length":1,"stats":{"Line":0}},{"line":23,"address":[24865152,24865204,24865267,24865570],"length":1,"stats":{"Line":0}},{"line":24,"address":[24791174],"length":1,"stats":{"Line":0}},{"line":29,"address":[24908000],"length":1,"stats":{"Line":0}},{"line":33,"address":[24904625,24904352,24904300,24904415],"length":1,"stats":{"Line":0}},{"line":34,"address":[23247141],"length":1,"stats":{"Line":0}},{"line":39,"address":[24910608],"length":1,"stats":{"Line":0}},{"line":43,"address":[11710286],"length":1,"stats":{"Line":0}},{"line":44,"address":[24911309],"length":1,"stats":{"Line":0}},{"line":49,"address":[25006256],"length":1,"stats":{"Line":0}},{"line":52,"address":[19221284],"length":1,"stats":{"Line":0}},{"line":53,"address":[24910423],"length":1,"stats":{"Line":0}},{"line":58,"address":[19048208],"length":1,"stats":{"Line":0}},{"line":62,"address":[10867076],"length":1,"stats":{"Line":0}},{"line":63,"address":[23249422],"length":1,"stats":{"Line":0}},{"line":68,"address":[24869248],"length":1,"stats":{"Line":0}},{"line":72,"address":[19049320,19049549,19049257,19049205],"length":1,"stats":{"Line":0}},{"line":73,"address":[24913739],"length":1,"stats":{"Line":0}},{"line":78,"address":[25008704],"length":1,"stats":{"Line":0}},{"line":82,"address":[24912837,24912507,24912625,24912562],"length":1,"stats":{"Line":0}},{"line":83,"address":[24871007],"length":1,"stats":{"Line":0}},{"line":88,"address":[24871184],"length":1,"stats":{"Line":0}},{"line":102,"address":[11720977],"length":1,"stats":{"Line":0}},{"line":103,"address":[24872240],"length":1,"stats":{"Line":0}},{"line":108,"address":[24804624],"length":1,"stats":{"Line":0}},{"line":112,"address":[25011098,25011210,25011324,25011505,25011273],"length":1,"stats":{"Line":0}},{"line":114,"address":[25011238],"length":1,"stats":{"Line":0}},{"line":115,"address":[11734702],"length":1,"stats":{"Line":0}},{"line":116,"address":[24880061],"length":1,"stats":{"Line":0}},{"line":121,"address":[24911408],"length":1,"stats":{"Line":0}},{"line":125,"address":[25012137,25012369,25011962,25012074,25012188],"length":1,"stats":{"Line":0}},{"line":127,"address":[24873622],"length":1,"stats":{"Line":0}},{"line":128,"address":[24873534,24873732,24873788,24873684,24873937],"length":1,"stats":{"Line":0}},{"line":129,"address":[24873997],"length":1,"stats":{"Line":0}},{"line":134,"address":[23254256],"length":1,"stats":{"Line":0}},{"line":137,"address":[11716740],"length":1,"stats":{"Line":0}},{"line":138,"address":[25013240],"length":1,"stats":{"Line":0}},{"line":143,"address":[24881808],"length":1,"stats":{"Line":0}},{"line":157,"address":[24917772,24917436,24917384,24917499],"length":1,"stats":{"Line":0}},{"line":158,"address":[24808128],"length":1,"stats":{"Line":0}},{"line":162,"address":[24883056],"length":1,"stats":{"Line":0}},{"line":165,"address":[25014976,25014889,25014804],"length":1,"stats":{"Line":0}},{"line":166,"address":[23256463],"length":1,"stats":{"Line":0}},{"line":167,"address":[24815786,24815743],"length":1,"stats":{"Line":0}},{"line":168,"address":[24883536],"length":1,"stats":{"Line":0}},{"line":172,"address":[24808818],"length":1,"stats":{"Line":0}},{"line":173,"address":[24883581],"length":1,"stats":{"Line":0}},{"line":174,"address":[24918772],"length":1,"stats":{"Line":0}},{"line":175,"address":[24802200],"length":1,"stats":{"Line":0}},{"line":176,"address":[24803232,24802268,24803238],"length":1,"stats":{"Line":0}},{"line":177,"address":[24915952,24915958,24915062],"length":1,"stats":{"Line":0}},{"line":178,"address":[24809191],"length":1,"stats":{"Line":0}},{"line":179,"address":[24877025],"length":1,"stats":{"Line":0}},{"line":180,"address":[24919904,24919099,24919910],"length":1,"stats":{"Line":0}},{"line":181,"address":[24803280,24802507,24803286],"length":1,"stats":{"Line":0}},{"line":182,"address":[24919235],"length":1,"stats":{"Line":0}},{"line":185,"address":[24919487],"length":1,"stats":{"Line":0}},{"line":186,"address":[24919569],"length":1,"stats":{"Line":0}},{"line":192,"address":[24916078],"length":1,"stats":{"Line":0}},{"line":193,"address":[24921743],"length":1,"stats":{"Line":0}},{"line":197,"address":[15209936,15211226,15211042],"length":1,"stats":{"Line":0}},{"line":199,"address":[23805568],"length":1,"stats":{"Line":0}},{"line":200,"address":[15210044],"length":1,"stats":{"Line":0}},{"line":201,"address":[24018728],"length":1,"stats":{"Line":0}},{"line":202,"address":[23819431],"length":1,"stats":{"Line":0}},{"line":203,"address":[23887214],"length":1,"stats":{"Line":0}},{"line":204,"address":[24660096,24660118],"length":1,"stats":{"Line":0}},{"line":208,"address":[24018861],"length":1,"stats":{"Line":0}},{"line":209,"address":[23924109],"length":1,"stats":{"Line":0}},{"line":210,"address":[15210249],"length":1,"stats":{"Line":0}},{"line":211,"address":[15210287],"length":1,"stats":{"Line":0}},{"line":212,"address":[24660198,24660192],"length":1,"stats":{"Line":0}},{"line":213,"address":[18914518,18914512],"length":1,"stats":{"Line":0}},{"line":214,"address":[24019149],"length":1,"stats":{"Line":0}},{"line":215,"address":[23922735],"length":1,"stats":{"Line":0}},{"line":216,"address":[23880705],"length":1,"stats":{"Line":0}},{"line":217,"address":[23819924],"length":1,"stats":{"Line":0}},{"line":218,"address":[23918966],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","p2p_commands.rs"],"content":"use crate::{\n    infrastructure::p2p::{bootstrap_config, metrics::GossipMetricDetails},\n    presentation::dto::{\n        ApiResponse,\n        p2p::{\n            BootstrapConfigResponse, BootstrapMetricsResponse, BroadcastRequest,\n            GossipMetricDetailsResponse, GossipMetricsResponse, JoinTopicRequest,\n            LeaveTopicRequest, MainlineMetricsResponse, NodeAddressResponse, P2PMetricsResponse,\n            P2PStatusResponse, RelayStatusResponse,\n        },\n    },\n    shared::AppError,\n    shared::config::BootstrapSource,\n    state::AppState,\n};\nuse std::collections::HashSet;\nuse tauri::State;\n\n/// P2P機能を初期化\n#[tauri::command]\npub async fn initialize_p2p(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let result = state.p2p_handler.initialize_p2p().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pトピックに参加\n#[tauri::command]\npub async fn join_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    #[allow(non_snake_case)] initialPeers: Vec<String>,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = JoinTopicRequest {\n        topic_id: topicId.clone(),\n        initial_peers: initialPeers,\n    };\n    let topic_id = request.topic_id.clone();\n\n    match state.p2p_handler.join_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.ensure_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to ensure UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// P2Pトピックから離脱\n#[tauri::command]\npub async fn leave_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = LeaveTopicRequest {\n        topic_id: topicId.clone(),\n    };\n    match state.p2p_handler.leave_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.stop_ui_subscription(&topicId).await {\n                tracing::warn!(\"Failed to stop UI subscription for {}: {}\", topicId, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックにメッセージをブロードキャスト\n#[tauri::command]\npub async fn broadcast_to_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    content: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = BroadcastRequest {\n        topic_id: topicId,\n        content,\n    };\n    let result = state.p2p_handler.broadcast_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pステータスを取得\n#[tauri::command]\npub async fn get_p2p_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<P2PStatusResponse>, AppError> {\n    let result = state.p2p_handler.get_p2p_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ノードアドレスを取得\n#[tauri::command]\npub async fn get_node_address(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<NodeAddressResponse>, AppError> {\n    let result = state.p2p_handler.get_node_address().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n// ================= Bootstrap UI コマンド =================\n\n#[tauri::command]\npub async fn get_bootstrap_config() -> Result<ApiResponse<BootstrapConfigResponse>, AppError> {\n    let user_nodes = bootstrap_config::load_user_bootstrap_nodes();\n    let selection = bootstrap_config::load_effective_bootstrap_nodes();\n    let env_locked = bootstrap_config::load_env_bootstrap_nodes().is_some();\n    let cli_info = bootstrap_config::load_cli_bootstrap_nodes();\n    let cli_nodes = cli_info\n        .as_ref()\n        .map(|info| info.nodes.clone())\n        .unwrap_or_default();\n    let cli_updated_at_ms = cli_info.and_then(|info| info.updated_at_ms);\n    let mode = if env_locked {\n        \"custom\".to_string()\n    } else if user_nodes.is_empty() {\n        \"default\".to_string()\n    } else {\n        \"custom\".to_string()\n    };\n    let source = match selection.source {\n        crate::shared::config::BootstrapSource::Env => \"env\",\n        crate::shared::config::BootstrapSource::User => \"user\",\n        crate::shared::config::BootstrapSource::Bundle => \"bundle\",\n        crate::shared::config::BootstrapSource::Fallback => \"fallback\",\n        crate::shared::config::BootstrapSource::None => \"none\",\n    }\n    .to_string();\n\n    Ok(ApiResponse::success(BootstrapConfigResponse {\n        mode,\n        nodes: user_nodes,\n        effective_nodes: selection.nodes,\n        source,\n        env_locked,\n        cli_nodes,\n        cli_updated_at_ms,\n    }))\n}\n\n#[tauri::command]\npub async fn set_bootstrap_nodes(nodes: Vec<String>) -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; bootstrap nodes are read-only\".to_string(),\n        ));\n    }\n\n    for node in &nodes {\n        if !node.contains('@') {\n            return Err(AppError::ConfigurationError(format!(\n                \"Invalid bootstrap node format (expected node_id@host:port): {node}\"\n            )));\n        }\n    }\n\n    bootstrap_config::save_user_bootstrap_nodes(&nodes)\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n#[tauri::command]\npub async fn clear_bootstrap_nodes() -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; bootstrap nodes are read-only\".to_string(),\n        ));\n    }\n\n    bootstrap_config::clear_user_bootstrap_nodes()\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n#[tauri::command]\npub async fn apply_cli_bootstrap_nodes(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<BootstrapConfigResponse>, AppError> {\n    if bootstrap_config::load_env_bootstrap_nodes().is_some() {\n        return Err(AppError::ConfigurationError(\n            \"Environment override is enabled; CLI bootstrap list cannot be applied\".to_string(),\n        ));\n    }\n\n    let nodes = bootstrap_config::apply_cli_bootstrap_nodes()?;\n    state\n        .p2p_handler\n        .apply_bootstrap_nodes(nodes, BootstrapSource::User)\n        .await?;\n\n    get_bootstrap_config().await\n}\n\n#[tauri::command]\npub async fn get_relay_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<RelayStatusResponse>>, AppError> {\n    let p2p_status = state.p2p_handler.get_p2p_status().await?;\n    let selection = bootstrap_config::load_effective_bootstrap_nodes();\n    let default_status = match p2p_status.connection_status {\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Connected\n        | crate::presentation::dto::p2p::ConnectionStatusResponse::Disconnected => \"disconnected\",\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Connecting => \"connecting\",\n        crate::presentation::dto::p2p::ConnectionStatusResponse::Error => \"error\",\n    };\n\n    let mut statuses = Vec::new();\n    let mut seen: HashSet<String> = HashSet::new();\n\n    for node in selection.nodes.iter() {\n        if seen.insert(node.clone()) {\n            statuses.push(RelayStatusResponse {\n                url: node.clone(),\n                status: default_status.to_string(),\n            });\n        }\n    }\n\n    for peer in p2p_status.peers {\n        let mut matched = None;\n        for candidate in selection.nodes.iter() {\n            if let Some((node_id, _)) = candidate.split_once('@') {\n                if node_id == peer.node_id {\n                    matched = Some(candidate.clone());\n                    break;\n                }\n            } else if candidate == &peer.address || candidate == &peer.node_id {\n                matched = Some(candidate.clone());\n                break;\n            }\n        }\n\n        if let Some(url) = matched {\n            if let Some(index) = statuses.iter().position(|entry| entry.url == url) {\n                statuses[index].status = \"connected\".to_string();\n                continue;\n            }\n        }\n\n        if seen.insert(peer.address.clone()) {\n            statuses.push(RelayStatusResponse {\n                url: peer.address,\n                status: \"connected\".to_string(),\n            });\n        }\n    }\n\n    Ok(ApiResponse::success(statuses))\n}\n\n/// Gossipメトリクスを取得\n#[tauri::command]\npub async fn get_p2p_metrics() -> Result<ApiResponse<P2PMetricsResponse>, AppError> {\n    use crate::infrastructure::p2p::metrics;\n    let snap = metrics::snapshot_full();\n    let response = P2PMetricsResponse {\n        gossip: GossipMetricsResponse {\n            joins: snap.gossip.joins,\n            leaves: snap.gossip.leaves,\n            broadcasts_sent: snap.gossip.broadcasts_sent,\n            messages_received: snap.gossip.messages_received,\n            join_details: to_response_details(&snap.gossip.join_details),\n            leave_details: to_response_details(&snap.gossip.leave_details),\n            broadcast_details: to_response_details(&snap.gossip.broadcast_details),\n            receive_details: to_response_details(&snap.gossip.receive_details),\n        },\n        mainline: MainlineMetricsResponse {\n            connected_peers: snap.mainline.connected_peers,\n            connection_attempts: snap.mainline.connection_attempts,\n            connection_successes: snap.mainline.connection_successes,\n            connection_failures: snap.mainline.connection_failures,\n            connection_last_success_ms: snap.mainline.connection_last_success_ms,\n            connection_last_failure_ms: snap.mainline.connection_last_failure_ms,\n            routing_attempts: snap.mainline.routing_attempts,\n            routing_successes: snap.mainline.routing_successes,\n            routing_failures: snap.mainline.routing_failures,\n            routing_success_rate: snap.mainline.routing_success_rate,\n            routing_last_success_ms: snap.mainline.routing_last_success_ms,\n            routing_last_failure_ms: snap.mainline.routing_last_failure_ms,\n            reconnect_attempts: snap.mainline.reconnect_attempts,\n            reconnect_successes: snap.mainline.reconnect_successes,\n            reconnect_failures: snap.mainline.reconnect_failures,\n            last_reconnect_success_ms: snap.mainline.last_reconnect_success_ms,\n            last_reconnect_failure_ms: snap.mainline.last_reconnect_failure_ms,\n            bootstrap: BootstrapMetricsResponse {\n                env_uses: snap.mainline.bootstrap.env_uses,\n                user_uses: snap.mainline.bootstrap.user_uses,\n                bundle_uses: snap.mainline.bootstrap.bundle_uses,\n                fallback_uses: snap.mainline.bootstrap.fallback_uses,\n                last_source: snap.mainline.bootstrap.last_source,\n                last_applied_ms: snap.mainline.bootstrap.last_applied_ms,\n            },\n        },\n    };\n    Ok(ApiResponse::success(response))\n}\n\nfn to_response_details(details: &GossipMetricDetails) -> GossipMetricDetailsResponse {\n    GossipMetricDetailsResponse {\n        total: details.total,\n        failures: details.failures,\n        last_success_ms: details.last_success_ms,\n        last_failure_ms: details.last_failure_ms,\n    }\n}\n","traces":[{"line":21,"address":[24030400,24030562,24030384,24030522,24030435,24031082,24030742,24030392],"length":1,"stats":{"Line":0}},{"line":22,"address":[18166790,18166565,18166627,18166513],"length":1,"stats":{"Line":0}},{"line":23,"address":[23912696],"length":1,"stats":{"Line":0}},{"line":28,"address":[23987408],"length":1,"stats":{"Line":0}},{"line":34,"address":[18167428],"length":1,"stats":{"Line":0}},{"line":37,"address":[24126475],"length":1,"stats":{"Line":0}},{"line":39,"address":[11639500],"length":1,"stats":{"Line":0}},{"line":41,"address":[23995773,23996012,23994726,23995659],"length":1,"stats":{"Line":0}},{"line":42,"address":[23930553,23928637,23928536,23930687,23929138],"length":1,"stats":{"Line":0}},{"line":44,"address":[23997953],"length":1,"stats":{"Line":0}},{"line":46,"address":[24030810,24031068],"length":1,"stats":{"Line":0}},{"line":52,"address":[23998752],"length":1,"stats":{"Line":0}},{"line":57,"address":[20716192],"length":1,"stats":{"Line":0}},{"line":59,"address":[24034363,24034588,24034141,24034279],"length":1,"stats":{"Line":0}},{"line":61,"address":[20716274,20716969,20717066,20717293],"length":1,"stats":{"Line":0}},{"line":62,"address":[18175065,18175199,18173273,18173172,18173774],"length":1,"stats":{"Line":0}},{"line":64,"address":[23934279],"length":1,"stats":{"Line":0}},{"line":66,"address":[24030984,24031224],"length":1,"stats":{"Line":0}},{"line":72,"address":[24033904],"length":1,"stats":{"Line":0}},{"line":81,"address":[11558209],"length":1,"stats":{"Line":0}},{"line":82,"address":[23922054],"length":1,"stats":{"Line":0}},{"line":87,"address":[24038880],"length":1,"stats":{"Line":0}},{"line":90,"address":[18176709,18176934,18176771,18176657],"length":1,"stats":{"Line":0}},{"line":91,"address":[24035638],"length":1,"stats":{"Line":0}},{"line":96,"address":[20721632],"length":1,"stats":{"Line":0}},{"line":99,"address":[24035987,24035873,24035925,24036150],"length":1,"stats":{"Line":0}},{"line":100,"address":[23937416],"length":1,"stats":{"Line":0}},{"line":106,"address":[18178245,18179924,18178096,18178080,18178215,18178126,18179833],"length":1,"stats":{"Line":0}},{"line":107,"address":[24036559],"length":1,"stats":{"Line":0}},{"line":108,"address":[23998576],"length":1,"stats":{"Line":0}},{"line":109,"address":[23924119,23924054],"length":1,"stats":{"Line":0}},{"line":110,"address":[24036919],"length":1,"stats":{"Line":0}},{"line":111,"address":[20722781,20722868],"length":1,"stats":{"Line":0}},{"line":113,"address":[24042304,24042320],"length":1,"stats":{"Line":0}},{"line":115,"address":[24037266,24038416,24038420,24037110],"length":1,"stats":{"Line":0}},{"line":116,"address":[23938561,23938338],"length":1,"stats":{"Line":0}},{"line":117,"address":[24041433,24041242],"length":1,"stats":{"Line":0}},{"line":118,"address":[20723082,20723175,20723291],"length":1,"stats":{"Line":0}},{"line":119,"address":[24043071,24043000],"length":1,"stats":{"Line":0}},{"line":121,"address":[24041321,24041383],"length":1,"stats":{"Line":0}},{"line":123,"address":[24037455,24037650],"length":1,"stats":{"Line":0}},{"line":124,"address":[20723303],"length":1,"stats":{"Line":0}},{"line":125,"address":[23999424],"length":1,"stats":{"Line":0}},{"line":126,"address":[18179165],"length":1,"stats":{"Line":0}},{"line":127,"address":[24006410],"length":1,"stats":{"Line":0}},{"line":128,"address":[23938679],"length":1,"stats":{"Line":0}},{"line":132,"address":[23931968],"length":1,"stats":{"Line":0}},{"line":133,"address":[24041676],"length":1,"stats":{"Line":0}},{"line":134,"address":[23999668],"length":1,"stats":{"Line":0}},{"line":135,"address":[23999702],"length":1,"stats":{"Line":0}},{"line":138,"address":[23938904],"length":1,"stats":{"Line":0}},{"line":144,"address":[23939520,23939523,23939552,23939660,23940877,23940350,23939582],"length":1,"stats":{"Line":0}},{"line":147,"address":[23932665,23932747],"length":1,"stats":{"Line":0}},{"line":148,"address":[24045296],"length":1,"stats":{"Line":0}},{"line":149,"address":[18181281],"length":1,"stats":{"Line":0}},{"line":153,"address":[24139294,24139150],"length":1,"stats":{"Line":0}},{"line":154,"address":[24044526,24044995],"length":1,"stats":{"Line":0}},{"line":155,"address":[24043381],"length":1,"stats":{"Line":0}},{"line":161,"address":[23932980,23933225,23933060,23933463],"length":1,"stats":{"Line":0}},{"line":162,"address":[18180697,18181472,18181490],"length":1,"stats":{"Line":0}},{"line":163,"address":[20724934,20724846],"length":1,"stats":{"Line":0}},{"line":167,"address":[24001920,24001904,24001999,24001950,24002554],"length":1,"stats":{"Line":0}},{"line":170,"address":[24044031,24044112],"length":1,"stats":{"Line":0}},{"line":171,"address":[23934658],"length":1,"stats":{"Line":0}},{"line":172,"address":[23941606],"length":1,"stats":{"Line":0}},{"line":176,"address":[20726268,20726168,20726027],"length":1,"stats":{"Line":0}},{"line":177,"address":[23934818,23934476,23934800],"length":1,"stats":{"Line":0}},{"line":178,"address":[24002366,24002265],"length":1,"stats":{"Line":0}},{"line":182,"address":[24046448],"length":1,"stats":{"Line":0}},{"line":185,"address":[24009818,24009936],"length":1,"stats":{"Line":0}},{"line":186,"address":[23929093],"length":1,"stats":{"Line":0}},{"line":187,"address":[23929062],"length":1,"stats":{"Line":0}},{"line":191,"address":[23935358,23935504,23935303,23935830],"length":1,"stats":{"Line":0}},{"line":192,"address":[18183003,18183900,18183295,18183683,18183233,18183785,18184061,18183156],"length":1,"stats":{"Line":0}},{"line":194,"address":[24045520],"length":1,"stats":{"Line":0}},{"line":195,"address":[11517825],"length":1,"stats":{"Line":0}},{"line":197,"address":[11517845],"length":1,"stats":{"Line":0}},{"line":201,"address":[24048320],"length":1,"stats":{"Line":0}},{"line":204,"address":[20728605,20729515,20728681,20728548,20728864],"length":1,"stats":{"Line":0}},{"line":205,"address":[24005792],"length":1,"stats":{"Line":0}},{"line":206,"address":[23938135],"length":1,"stats":{"Line":0}},{"line":207,"address":[23945151],"length":1,"stats":{"Line":0}},{"line":209,"address":[23938204],"length":1,"stats":{"Line":0}},{"line":210,"address":[24144521],"length":1,"stats":{"Line":0}},{"line":213,"address":[23945236],"length":1,"stats":{"Line":0}},{"line":214,"address":[24013067],"length":1,"stats":{"Line":0}},{"line":216,"address":[20729985,20729893,20730222],"length":1,"stats":{"Line":0}},{"line":217,"address":[24050257,24053317],"length":1,"stats":{"Line":0}},{"line":218,"address":[24051819],"length":1,"stats":{"Line":0}},{"line":219,"address":[20733306],"length":1,"stats":{"Line":0}},{"line":220,"address":[23948860],"length":1,"stats":{"Line":0}},{"line":225,"address":[20730395,20730159,20730448,20733136,20730268],"length":1,"stats":{"Line":0}},{"line":226,"address":[23932255],"length":1,"stats":{"Line":0}},{"line":227,"address":[24051067,24050569,24051261],"length":1,"stats":{"Line":0}},{"line":228,"address":[23939773],"length":1,"stats":{"Line":0}},{"line":229,"address":[24146262,24146197],"length":1,"stats":{"Line":0}},{"line":230,"address":[24049839],"length":1,"stats":{"Line":0}},{"line":233,"address":[24146497,24146581,24146208],"length":1,"stats":{"Line":0}},{"line":234,"address":[23933478,23933518],"length":1,"stats":{"Line":0}},{"line":239,"address":[23947473,23946689],"length":1,"stats":{"Line":0}},{"line":240,"address":[20732010,20733609,20732111,20733584],"length":1,"stats":{"Line":0}},{"line":241,"address":[20732642,20732245,20732298],"length":1,"stats":{"Line":0}},{"line":246,"address":[23934445,23933782],"length":1,"stats":{"Line":0}},{"line":247,"address":[24009237],"length":1,"stats":{"Line":0}},{"line":248,"address":[20732759],"length":1,"stats":{"Line":0}},{"line":249,"address":[24051210],"length":1,"stats":{"Line":0}},{"line":254,"address":[24145391],"length":1,"stats":{"Line":0}},{"line":259,"address":[23935489,23935588,23935558,23935440,23937090,23937135,23935424],"length":1,"stats":{"Line":0}},{"line":261,"address":[24017051],"length":1,"stats":{"Line":0}},{"line":263,"address":[24052530],"length":1,"stats":{"Line":0}},{"line":273,"address":[24054860],"length":1,"stats":{"Line":0}},{"line":301,"address":[24055239],"length":1,"stats":{"Line":0}},{"line":304,"address":[24019968],"length":1,"stats":{"Line":0}},{"line":306,"address":[23919611],"length":1,"stats":{"Line":0}},{"line":307,"address":[18061215],"length":1,"stats":{"Line":0}},{"line":308,"address":[23813699],"length":1,"stats":{"Line":0}},{"line":309,"address":[23881514],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":117},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","post_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            post_dto::{\n                BookmarkPostRequest, CreatePostRequest, DeletePostRequest,\n                FollowingFeedPageResponse, GetPostsRequest, ListFollowingFeedRequest,\n                ListTrendingPostsRequest, ListTrendingPostsResponse, PostResponse,\n                ReactToPostRequest,\n            },\n        },\n        handlers::PostHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// 投稿を作成する\n#[tauri::command]\npub async fn create_post(\n    state: State<'_, AppState>,\n    request: CreatePostRequest,\n) -> Result<ApiResponse<PostResponse>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.create_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を取得する\n#[tauri::command]\npub async fn get_posts(\n    state: State<'_, AppState>,\n    request: GetPostsRequest,\n) -> Result<ApiResponse<Vec<PostResponse>>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.get_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トレンドトピックごとの投稿を取得する\n#[tauri::command]\npub async fn list_trending_posts(\n    state: State<'_, AppState>,\n    request: ListTrendingPostsRequest,\n) -> Result<ApiResponse<ListTrendingPostsResponse>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.list_trending_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を削除する\n#[tauri::command]\npub async fn delete_post(\n    state: State<'_, AppState>,\n    request: DeletePostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.delete_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にリアクションする（内部ヘルパー）\nasync fn react_to_post(\n    state: &State<'_, AppState>,\n    request: ReactToPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.react_to_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブックマークする\n#[tauri::command]\npub async fn bookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.bookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ブックマークを解除する\n#[tauri::command]\npub async fn unbookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.unbookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にいいねする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn like_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"+\".to_string(),\n    };\n\n    react_to_post(&state, request).await\n}\n\n/// ブックマーク済み投稿IDを取得する\n#[tauri::command]\npub async fn get_bookmarked_post_ids(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<String>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.get_bookmarked_post_ids(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// フォロー中フィードを取得する\n#[tauri::command]\npub async fn list_following_feed(\n    state: State<'_, AppState>,\n    request: ListFollowingFeedRequest,\n) -> Result<ApiResponse<FollowingFeedPageResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(\n        state.post_service.clone(),\n        state.auth_service.clone(),\n        state.topic_service.clone(),\n    );\n    let result = handler.list_following_feed(&user_pubkey, request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブーストする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn boost_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"boost\".to_string(),\n    };\n\n    react_to_post(&state, request).await\n}\n","traces":[{"line":19,"address":[23139428,23139080,23139245,23139072,23139205,23139123,23139088,23139810],"length":1,"stats":{"Line":0}},{"line":20,"address":[15211739,15211571,15211381,15211894,15211482],"length":1,"stats":{"Line":0}},{"line":23,"address":[17275376,17275420,17275248,17275476,17275683],"length":1,"stats":{"Line":0}},{"line":24,"address":[23139840,23139824],"length":1,"stats":{"Line":0}},{"line":25,"address":[23035408,23035430],"length":1,"stats":{"Line":0}},{"line":30,"address":[23197520],"length":1,"stats":{"Line":0}},{"line":35,"address":[23235938,23236043],"length":1,"stats":{"Line":0}},{"line":36,"address":[23236169,23236087],"length":1,"stats":{"Line":0}},{"line":37,"address":[23236284,23236213],"length":1,"stats":{"Line":0}},{"line":39,"address":[11420145],"length":1,"stats":{"Line":0}},{"line":40,"address":[23124281],"length":1,"stats":{"Line":0}},{"line":45,"address":[23242784],"length":1,"stats":{"Line":0}},{"line":50,"address":[15513999,15513898],"length":1,"stats":{"Line":0}},{"line":51,"address":[23199519,23199601],"length":1,"stats":{"Line":0}},{"line":52,"address":[23338125,23338196],"length":1,"stats":{"Line":0}},{"line":54,"address":[23237534,23238296,23237924,23238073],"length":1,"stats":{"Line":0}},{"line":55,"address":[23244092],"length":1,"stats":{"Line":0}},{"line":60,"address":[23339184],"length":1,"stats":{"Line":0}},{"line":65,"address":[23201051,23200946],"length":1,"stats":{"Line":0}},{"line":66,"address":[23133287,23133369],"length":1,"stats":{"Line":0}},{"line":67,"address":[23243269,23243340],"length":1,"stats":{"Line":0}},{"line":69,"address":[23201505,23201728,23200998,23201388],"length":1,"stats":{"Line":0}},{"line":70,"address":[15516336],"length":1,"stats":{"Line":0}},{"line":75,"address":[23244304],"length":1,"stats":{"Line":0}},{"line":80,"address":[23240728,23240623],"length":1,"stats":{"Line":0}},{"line":81,"address":[23128150,23128068],"length":1,"stats":{"Line":0}},{"line":82,"address":[23240898,23240969],"length":1,"stats":{"Line":0}},{"line":84,"address":[23246649,23247005,23246782,23246259],"length":1,"stats":{"Line":0}},{"line":85,"address":[23245569],"length":1,"stats":{"Line":0}},{"line":89,"address":[23028688],"length":1,"stats":{"Line":0}},{"line":93,"address":[23022147,23022202,23022275,23022427],"length":1,"stats":{"Line":0}},{"line":95,"address":[15213302,15213241],"length":1,"stats":{"Line":0}},{"line":96,"address":[23029750,23029832],"length":1,"stats":{"Line":0}},{"line":97,"address":[23036852,23036923],"length":1,"stats":{"Line":0}},{"line":99,"address":[23022220,23023693,23023391,23023259],"length":1,"stats":{"Line":0}},{"line":100,"address":[23236975],"length":1,"stats":{"Line":0}},{"line":105,"address":[23342288],"length":1,"stats":{"Line":0}},{"line":109,"address":[11545225],"length":1,"stats":{"Line":0}},{"line":111,"address":[23343243,23343093],"length":1,"stats":{"Line":0}},{"line":112,"address":[23243001,23242919],"length":1,"stats":{"Line":0}},{"line":113,"address":[23243045,23243116],"length":1,"stats":{"Line":0}},{"line":115,"address":[23247148,23247403,23246137,23247723],"length":1,"stats":{"Line":0}},{"line":116,"address":[17385596],"length":1,"stats":{"Line":0}},{"line":121,"address":[23145280],"length":1,"stats":{"Line":0}},{"line":125,"address":[11515513],"length":1,"stats":{"Line":0}},{"line":127,"address":[23250763,23250613],"length":1,"stats":{"Line":0}},{"line":128,"address":[23250889,23250807],"length":1,"stats":{"Line":0}},{"line":129,"address":[23132645,23132716],"length":1,"stats":{"Line":0}},{"line":131,"address":[19208988],"length":1,"stats":{"Line":0}},{"line":132,"address":[23147356],"length":1,"stats":{"Line":0}},{"line":137,"address":[23250464],"length":1,"stats":{"Line":0}},{"line":143,"address":[23208613],"length":1,"stats":{"Line":0}},{"line":146,"address":[11427697],"length":1,"stats":{"Line":0}},{"line":151,"address":[23216224],"length":1,"stats":{"Line":0}},{"line":154,"address":[23253251,23253121,23253736,23254506,23253176,23253388],"length":1,"stats":{"Line":0}},{"line":156,"address":[23348495,23348645],"length":1,"stats":{"Line":0}},{"line":157,"address":[23217219,23217137],"length":1,"stats":{"Line":0}},{"line":158,"address":[23248447,23248518],"length":1,"stats":{"Line":0}},{"line":160,"address":[23254198,23254553,23253194,23254296],"length":1,"stats":{"Line":0}},{"line":161,"address":[23211066],"length":1,"stats":{"Line":0}},{"line":166,"address":[23218208],"length":1,"stats":{"Line":0}},{"line":170,"address":[23253869,23254223,23253717,23253589,23253644],"length":1,"stats":{"Line":0}},{"line":172,"address":[23254198,23254348],"length":1,"stats":{"Line":0}},{"line":173,"address":[23256040,23256122],"length":1,"stats":{"Line":0}},{"line":174,"address":[23254518,23254589],"length":1,"stats":{"Line":0}},{"line":176,"address":[17392447,17392848,17392349,17391326],"length":1,"stats":{"Line":0}},{"line":177,"address":[23145563],"length":1,"stats":{"Line":0}},{"line":182,"address":[23145728],"length":1,"stats":{"Line":0}},{"line":188,"address":[23220661],"length":1,"stats":{"Line":0}},{"line":191,"address":[15527615,15527908,15527721,15527813],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":70},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","secure_storage_commands.rs"],"content":"use crate::{\n    domain::entities::AccountMetadata,\n    presentation::{\n        dto::{ApiResponse, auth_dto::LoginResponse},\n        handlers::secure_storage_handler::{\n            AddAccountRequest, AddAccountResponse, GetCurrentAccountResponse, SecureStorageHandler,\n            SwitchAccountResponse,\n        },\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\n/// アカウントを追加\n#[tauri::command]\npub async fn add_account(\n    state: State<'_, AppState>,\n    request: AddAccountRequest,\n) -> Result<ApiResponse<AddAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.add_account(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウント一覧を取得\n#[tauri::command]\npub async fn list_accounts(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<AccountMetadata>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.list_accounts().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを切り替え\n#[tauri::command]\npub async fn switch_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<SwitchAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.switch_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを削除\n#[tauri::command]\npub async fn remove_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.remove_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のアカウントを取得\n#[tauri::command]\npub async fn get_current_account(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<GetCurrentAccountResponse>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.get_current_account().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// セキュアログイン\n#[tauri::command]\npub async fn secure_login(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.secure_login(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":17,"address":[23214416],"length":1,"stats":{"Line":0}},{"line":21,"address":[23258384,23258499],"length":1,"stats":{"Line":0}},{"line":22,"address":[11665937],"length":1,"stats":{"Line":0}},{"line":23,"address":[23154554],"length":1,"stats":{"Line":0}},{"line":28,"address":[23354080],"length":1,"stats":{"Line":0}},{"line":31,"address":[23253825,23253939],"length":1,"stats":{"Line":0}},{"line":32,"address":[19272612],"length":1,"stats":{"Line":0}},{"line":33,"address":[23254409],"length":1,"stats":{"Line":0}},{"line":38,"address":[23148704],"length":1,"stats":{"Line":0}},{"line":42,"address":[23260403,23260518],"length":1,"stats":{"Line":0}},{"line":43,"address":[11622753],"length":1,"stats":{"Line":0}},{"line":44,"address":[23156506],"length":1,"stats":{"Line":0}},{"line":49,"address":[15531200],"length":1,"stats":{"Line":0}},{"line":53,"address":[23259795,23259910],"length":1,"stats":{"Line":0}},{"line":54,"address":[15531443,15531619,15531776,15531552],"length":1,"stats":{"Line":0}},{"line":55,"address":[23150560],"length":1,"stats":{"Line":0}},{"line":60,"address":[15532240],"length":1,"stats":{"Line":0}},{"line":63,"address":[23257001,23256884],"length":1,"stats":{"Line":0}},{"line":64,"address":[11644407],"length":1,"stats":{"Line":0}},{"line":65,"address":[23257455],"length":1,"stats":{"Line":0}},{"line":70,"address":[23357968],"length":1,"stats":{"Line":0}},{"line":74,"address":[23257910,23257795],"length":1,"stats":{"Line":0}},{"line":75,"address":[11466417],"length":1,"stats":{"Line":0}},{"line":76,"address":[23262378],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","topic_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            topic_dto::{\n                CreateTopicRequest, DeleteTopicRequest, EnqueueTopicCreationRequest,\n                EnqueueTopicCreationResponse, GetTopicStatsRequest, JoinTopicRequest,\n                ListTrendingTopicsRequest, ListTrendingTopicsResponse,\n                MarkPendingTopicFailedRequest, MarkPendingTopicSyncedRequest, PendingTopicResponse,\n                TopicResponse, TopicStatsResponse, UpdateTopicRequest,\n            },\n        },\n        handlers::TopicHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// トピックを作成する\n#[tauri::command]\npub async fn create_topic(\n    state: State<'_, AppState>,\n    request: CreateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.create_topic(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフライン用のトピック作成をキューに登録する\n#[tauri::command]\npub async fn enqueue_topic_creation(\n    state: State<'_, AppState>,\n    request: EnqueueTopicCreationRequest,\n) -> Result<ApiResponse<EnqueueTopicCreationResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.enqueue_topic_creation(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピック作成を取得する\n#[tauri::command]\npub async fn list_pending_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<PendingTopicResponse>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.list_pending_topics(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピックを同期済みに更新する\n#[tauri::command]\npub async fn mark_pending_topic_synced(\n    state: State<'_, AppState>,\n    request: MarkPendingTopicSyncedRequest,\n) -> Result<ApiResponse<PendingTopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler\n        .mark_pending_topic_synced(request, &user_pubkey)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 保留中のトピックを失敗としてマークする\n#[tauri::command]\npub async fn mark_pending_topic_failed(\n    state: State<'_, AppState>,\n    request: MarkPendingTopicFailedRequest,\n) -> Result<ApiResponse<PendingTopicResponse>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler\n        .mark_pending_topic_failed(request, &user_pubkey)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// すべてのトピックを取得する\n#[tauri::command]\npub async fn get_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<TopicResponse>>, AppError> {\n    let user_pubkey = state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key)\n        .ok();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_all_topics(user_pubkey.as_deref()).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを更新する\n#[tauri::command]\npub async fn update_topic(\n    state: State<'_, AppState>,\n    request: UpdateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.update_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを削除する\n#[tauri::command]\npub async fn delete_topic(\n    state: State<'_, AppState>,\n    request: DeleteTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.delete_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックに参加する\n#[tauri::command]\npub async fn join_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let topic_id = request.topic_id.clone();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    match handler.join_topic(request, &user_pubkey).await {\n        Ok(_) => {\n            if let Err(e) = state.ensure_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to ensure UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックから離脱する\n#[tauri::command]\npub async fn leave_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let topic_id = request.topic_id.clone();\n    let handler = TopicHandler::new(state.topic_service.clone());\n    match handler.leave_topic(request, &user_pubkey).await {\n        Ok(_) => {\n            if let Err(e) = state.stop_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to stop UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックの統計情報を取得する\n#[tauri::command]\npub async fn get_topic_stats(\n    state: State<'_, AppState>,\n    request: GetTopicStatsRequest,\n) -> Result<ApiResponse<TopicStatsResponse>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_topic_stats(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トレンドトピック一覧を取得する\n#[tauri::command]\npub async fn list_trending_topics(\n    state: State<'_, AppState>,\n    request: Option<ListTrendingTopicsRequest>,\n) -> Result<ApiResponse<ListTrendingTopicsResponse>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let payload = request.unwrap_or_default();\n    let result = handler.list_trending_topics(payload).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":20,"address":[19023939,19024244,19024061,19023896,19023888,19023904,19024021,19024626],"length":1,"stats":{"Line":0}},{"line":21,"address":[18989267,18989087,18988885,18988990,18989413],"length":1,"stats":{"Line":0}},{"line":24,"address":[19228052],"length":1,"stats":{"Line":0}},{"line":25,"address":[13162304,13162320],"length":1,"stats":{"Line":0}},{"line":26,"address":[18989632,18989654],"length":1,"stats":{"Line":0}},{"line":31,"address":[18982160],"length":1,"stats":{"Line":0}},{"line":35,"address":[11546028],"length":1,"stats":{"Line":0}},{"line":36,"address":[19101354,19101517],"length":1,"stats":{"Line":0}},{"line":37,"address":[19058224,19057894,19057113,19058465],"length":1,"stats":{"Line":0}},{"line":38,"address":[19100724],"length":1,"stats":{"Line":0}},{"line":43,"address":[18991024],"length":1,"stats":{"Line":0}},{"line":47,"address":[19102851,19102796,19103076,19103427,19102924],"length":1,"stats":{"Line":0}},{"line":48,"address":[19101751,19101914],"length":1,"stats":{"Line":0}},{"line":49,"address":[11572447],"length":1,"stats":{"Line":0}},{"line":50,"address":[18999821],"length":1,"stats":{"Line":0}},{"line":55,"address":[19104496],"length":1,"stats":{"Line":0}},{"line":58,"address":[11566319],"length":1,"stats":{"Line":0}},{"line":59,"address":[19103542,19103699],"length":1,"stats":{"Line":0}},{"line":60,"address":[19200453,19199466,19200202,19200300],"length":1,"stats":{"Line":0}},{"line":61,"address":[18987590],"length":1,"stats":{"Line":0}},{"line":66,"address":[19069296],"length":1,"stats":{"Line":0}},{"line":70,"address":[19069531,19069659,19070156,19069811,19069586],"length":1,"stats":{"Line":0}},{"line":71,"address":[19063203,19063360],"length":1,"stats":{"Line":0}},{"line":72,"address":[24108843,24108998,24109439,24109101],"length":1,"stats":{"Line":0}},{"line":73,"address":[13243160,13243333,13243467],"length":1,"stats":{"Line":0}},{"line":74,"address":[19003088,19002896,19003229,19002797,19001844],"length":1,"stats":{"Line":0}},{"line":75,"address":[18989529],"length":1,"stats":{"Line":0}},{"line":80,"address":[19064256],"length":1,"stats":{"Line":0}},{"line":84,"address":[13244483,13244828,13244331,13244203,13244258],"length":1,"stats":{"Line":0}},{"line":85,"address":[19072176,19072019],"length":1,"stats":{"Line":0}},{"line":86,"address":[19107367,19107522,19107995,19107637],"length":1,"stats":{"Line":0}},{"line":87,"address":[19109205,19109032,19109339],"length":1,"stats":{"Line":0}},{"line":88,"address":[11527247],"length":1,"stats":{"Line":0}},{"line":89,"address":[13245721],"length":1,"stats":{"Line":0}},{"line":94,"address":[13245856],"length":1,"stats":{"Line":0}},{"line":97,"address":[19108764,19108932,19108476,19108332,19108573],"length":1,"stats":{"Line":0}},{"line":100,"address":[11420591],"length":1,"stats":{"Line":0}},{"line":101,"address":[19109840,19109863],"length":1,"stats":{"Line":0}},{"line":103,"address":[24112202,24112279],"length":1,"stats":{"Line":0}},{"line":104,"address":[11434370],"length":1,"stats":{"Line":0}},{"line":105,"address":[19206021],"length":1,"stats":{"Line":0}},{"line":110,"address":[19106096],"length":1,"stats":{"Line":0}},{"line":114,"address":[11503248,11503177],"length":1,"stats":{"Line":0}},{"line":115,"address":[19075890],"length":1,"stats":{"Line":0}},{"line":116,"address":[19107175,19106440,19107578,19107358],"length":1,"stats":{"Line":0}},{"line":117,"address":[19008835],"length":1,"stats":{"Line":0}},{"line":122,"address":[13249504],"length":1,"stats":{"Line":0}},{"line":126,"address":[11428269,11428201],"length":1,"stats":{"Line":0}},{"line":127,"address":[19002854],"length":1,"stats":{"Line":0}},{"line":128,"address":[11428220],"length":1,"stats":{"Line":0}},{"line":129,"address":[19071308],"length":1,"stats":{"Line":0}},{"line":134,"address":[24116512],"length":1,"stats":{"Line":0}},{"line":138,"address":[11533583],"length":1,"stats":{"Line":0}},{"line":139,"address":[19004598],"length":1,"stats":{"Line":0}},{"line":140,"address":[19004764,19004848],"length":1,"stats":{"Line":0}},{"line":141,"address":[19210290,19211516,19211784,19211228],"length":1,"stats":{"Line":0}},{"line":143,"address":[13253667,13253332,13253443,13251543],"length":1,"stats":{"Line":0}},{"line":144,"address":[19214569,19212820,19212719,19214703,19213321],"length":1,"stats":{"Line":0}},{"line":146,"address":[13255602],"length":1,"stats":{"Line":0}},{"line":148,"address":[19212383,19212131],"length":1,"stats":{"Line":0}},{"line":154,"address":[19001936],"length":1,"stats":{"Line":0}},{"line":158,"address":[19215245,19215309,19215412,19215573,19215959],"length":1,"stats":{"Line":0}},{"line":159,"address":[24122314],"length":1,"stats":{"Line":0}},{"line":160,"address":[13257324,13257408],"length":1,"stats":{"Line":0}},{"line":161,"address":[19198870],"length":1,"stats":{"Line":0}},{"line":163,"address":[19004179,19004068,19004403,19002279],"length":1,"stats":{"Line":0}},{"line":164,"address":[19018548,19019049,19020297,19018447,19020431],"length":1,"stats":{"Line":0}},{"line":166,"address":[19087858],"length":1,"stats":{"Line":0}},{"line":168,"address":[19078691,19078943],"length":1,"stats":{"Line":0}},{"line":174,"address":[19119680],"length":1,"stats":{"Line":0}},{"line":178,"address":[19013955,19014070],"length":1,"stats":{"Line":0}},{"line":179,"address":[19081815,19081949,19082170,19082066],"length":1,"stats":{"Line":0}},{"line":180,"address":[19124440],"length":1,"stats":{"Line":0}},{"line":185,"address":[19120704],"length":1,"stats":{"Line":0}},{"line":189,"address":[19221253,19221370],"length":1,"stats":{"Line":0}},{"line":190,"address":[19082969,19083041],"length":1,"stats":{"Line":0}},{"line":191,"address":[24127876,24127541,24127755],"length":1,"stats":{"Line":0}},{"line":192,"address":[24128093],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","user_commands.rs"],"content":"use crate::application::ports::repositories::FollowListSort;\nuse crate::application::services::offline_service::OfflineServiceTrait;\nuse crate::application::services::user_search_service::{\n    DEFAULT_LIMIT as SEARCH_DEFAULT_LIMIT, MAX_LIMIT as SEARCH_MAX_LIMIT, SearchSort,\n    SearchUsersParams,\n};\nuse crate::application::services::{\n    OfflineService, ProfileAvatarService, UploadProfileAvatarInput, UserSearchService, UserService,\n};\nuse crate::domain::entities::offline::CacheMetadataUpdate;\nuse crate::domain::value_objects::offline::{CacheKey, CacheType};\nuse crate::presentation::dto::{\n    ApiResponse, Validate,\n    profile_avatar_dto::{\n        FetchProfileAvatarRequest, FetchProfileAvatarResponse, ProfileAvatarSyncRequest,\n        ProfileAvatarSyncResponse, UploadProfileAvatarRequest, UploadProfileAvatarResponse,\n    },\n    user_dto::{\n        GetFollowersRequest, GetFollowingRequest, PaginatedUserProfiles, SearchUsersRequest,\n        SearchUsersResponse, UpdatePrivacySettingsRequest, UserProfile as UserProfileDto,\n    },\n};\nuse crate::shared::AppError;\nuse chrono::{Duration, Utc};\nuse nostr_sdk::prelude::{FromBech32, PublicKey};\nuse serde_json::{Value, json};\nuse std::sync::Arc;\nuse tauri::State;\n\nfn map_user_to_profile(user: crate::domain::entities::User) -> UserProfileDto {\n    UserProfileDto {\n        npub: user.npub,\n        pubkey: user.pubkey,\n        name: user.name,\n        display_name: Some(user.profile.display_name),\n        about: Some(user.profile.bio),\n        picture: user.profile.avatar_url,\n        banner: None,\n        website: None,\n        nip05: user.nip05,\n        is_profile_public: Some(user.public_profile),\n        show_online_status: Some(user.show_online_status),\n    }\n}\n\n#[tauri::command]\npub async fn get_user(\n    npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service.get_user(&npub).await.and_then(|user| {\n        user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n            .transpose()\n    });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_user_by_pubkey(\n    pubkey: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service\n        .get_user_by_pubkey(&pubkey)\n        .await\n        .and_then(|user| {\n            user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .transpose()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn search_users(\n    request: SearchUsersRequest,\n    user_search_service: State<'_, Arc<UserSearchService>>,\n) -> Result<ApiResponse<SearchUsersResponse>, AppError> {\n    request.validate()?;\n\n    let trimmed_query = request.query.trim().to_string();\n    let limit = request\n        .limit\n        .map(|value| value as usize)\n        .unwrap_or(SEARCH_DEFAULT_LIMIT)\n        .clamp(1, SEARCH_MAX_LIMIT);\n    let sort = SearchSort::try_from_str(request.sort.as_deref())?;\n    let viewer_pubkey = if let Some(npub) = request.viewer_npub.as_deref() {\n        Some(\n            PublicKey::from_bech32(npub)\n                .map_err(|_| AppError::InvalidInput(\"Invalid viewer npub\".into()))?\n                .to_hex(),\n        )\n    } else {\n        None\n    };\n\n    let params = SearchUsersParams {\n        query: trimmed_query,\n        cursor: request.cursor.clone(),\n        limit,\n        sort,\n        allow_incomplete: request.allow_incomplete.unwrap_or(false),\n        viewer_pubkey,\n    };\n\n    let result = user_search_service.search(params).await?;\n    let response = SearchUsersResponse {\n        items: result.users.into_iter().map(map_user_to_profile).collect(),\n        next_cursor: result.next_cursor,\n        has_more: result.has_more,\n        total_count: result.total_count as u64,\n        took_ms: result.took_ms.min(u64::MAX as u128) as u64,\n    };\n\n    Ok(ApiResponse::success(response))\n}\n\n#[tauri::command]\npub async fn update_privacy_settings(\n    request: UpdatePrivacySettingsRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    request.validate()?;\n\n    let result = user_service\n        .update_privacy_settings(\n            &request.npub,\n            request.public_profile,\n            request.show_online_status,\n        )\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn follow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service.follow_user(&follower_npub, &target_npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn unfollow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service\n        .unfollow_user(&follower_npub, &target_npub)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_followers(\n    request: GetFollowersRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<PaginatedUserProfiles>, AppError> {\n    let limit = request.limit.unwrap_or(25).min(100) as usize;\n    let sort = match request.sort.as_deref() {\n        Some(value) => FollowListSort::try_from(value)\n            .map_err(|_| AppError::InvalidInput(format!(\"Unsupported followers sort: {value}\")))?,\n        None => FollowListSort::Recent,\n    };\n    let search = request\n        .search\n        .as_ref()\n        .map(|s| s.trim())\n        .filter(|s| !s.is_empty());\n    let result = user_service\n        .get_followers_paginated(\n            &request.npub,\n            request.cursor.as_deref(),\n            limit,\n            sort,\n            search,\n            request.viewer_npub.as_deref(),\n        )\n        .await\n        .map(|page| PaginatedUserProfiles {\n            items: page.users.into_iter().map(map_user_to_profile).collect(),\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            total_count: page.total_count,\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_following(\n    request: GetFollowingRequest,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<PaginatedUserProfiles>, AppError> {\n    let limit = request.limit.unwrap_or(25).min(100) as usize;\n    let sort = match request.sort.as_deref() {\n        Some(value) => FollowListSort::try_from(value)\n            .map_err(|_| AppError::InvalidInput(format!(\"Unsupported following sort: {value}\")))?,\n        None => FollowListSort::Recent,\n    };\n    let search = request\n        .search\n        .as_ref()\n        .map(|s| s.trim())\n        .filter(|s| !s.is_empty());\n    let result = user_service\n        .get_following_paginated(\n            &request.npub,\n            request.cursor.as_deref(),\n            limit,\n            sort,\n            search,\n            request.viewer_npub.as_deref(),\n        )\n        .await\n        .map(|page| PaginatedUserProfiles {\n            items: page.users.into_iter().map(map_user_to_profile).collect(),\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n            total_count: page.total_count,\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn upload_profile_avatar(\n    request: UploadProfileAvatarRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n) -> Result<ApiResponse<UploadProfileAvatarResponse>, AppError> {\n    let input = UploadProfileAvatarInput {\n        npub: request.npub,\n        bytes: request.bytes,\n        format: request.format,\n        access_level: request.access_level,\n    };\n    let result = avatar_service\n        .upload_avatar(input)\n        .await\n        .map(UploadProfileAvatarResponse::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn fetch_profile_avatar(\n    request: FetchProfileAvatarRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n) -> Result<ApiResponse<FetchProfileAvatarResponse>, AppError> {\n    let result = avatar_service\n        .fetch_avatar(&request.npub)\n        .await\n        .map(FetchProfileAvatarResponse::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn profile_avatar_sync(\n    request: ProfileAvatarSyncRequest,\n    avatar_service: State<'_, Arc<ProfileAvatarService>>,\n    offline_service: State<'_, Arc<OfflineService>>,\n) -> Result<ApiResponse<ProfileAvatarSyncResponse>, AppError> {\n    let npub = request.npub.clone();\n    let response = match avatar_service.fetch_avatar(&request.npub).await {\n        Ok(result) => {\n            let current_version = result.metadata.version;\n            let fetch_response = FetchProfileAvatarResponse::from(result);\n\n            if let Some(known) = request.known_doc_version {\n                if known >= current_version {\n                    ProfileAvatarSyncResponse {\n                        npub,\n                        current_version: Some(current_version),\n                        updated: false,\n                        avatar: None,\n                    }\n                } else {\n                    ProfileAvatarSyncResponse {\n                        npub,\n                        current_version: Some(current_version),\n                        updated: true,\n                        avatar: Some(fetch_response),\n                    }\n                }\n            } else {\n                ProfileAvatarSyncResponse {\n                    npub,\n                    current_version: Some(current_version),\n                    updated: true,\n                    avatar: Some(fetch_response),\n                }\n            }\n        }\n        Err(AppError::NotFound(_)) => ProfileAvatarSyncResponse {\n            npub,\n            current_version: None,\n            updated: false,\n            avatar: None,\n        },\n        Err(err) => return Err(err),\n    };\n\n    record_profile_avatar_sync_metadata(offline_service.as_ref(), &request, &response).await?;\n\n    Ok(ApiResponse::success(response))\n}\n\nasync fn record_profile_avatar_sync_metadata(\n    offline_service: &OfflineService,\n    request: &ProfileAvatarSyncRequest,\n    response: &ProfileAvatarSyncResponse,\n) -> Result<(), AppError> {\n    let cache_key = CacheKey::new(format!(\"doc::profile_avatar::{}\", request.npub))\n        .map_err(AppError::InvalidInput)?;\n    let cache_type =\n        CacheType::new(\"profile_avatar\".to_string()).map_err(AppError::InvalidInput)?;\n\n    let payload_bytes = response\n        .avatar\n        .as_ref()\n        .and_then(|avatar| i64::try_from(avatar.size_bytes).ok());\n\n    let metadata = json!({\n        \"npub\": request.npub,\n        \"source\": request.source,\n        \"requestedAt\": request.requested_at,\n        \"retryCount\": request.retry_count,\n        \"jobId\": request.job_id,\n        \"knownDocVersion\": request.known_doc_version,\n        \"result\": {\n            \"updated\": response.updated,\n            \"currentVersion\": response.current_version,\n            \"avatar\": response.avatar.as_ref().map(|avatar| {\n                json!({\n                    \"blobHash\": avatar.blob_hash,\n                    \"docVersion\": avatar.doc_version,\n                    \"sizeBytes\": avatar.size_bytes,\n                })\n            }),\n        },\n        \"loggedAt\": Utc::now().to_rfc3339(),\n    });\n\n    let update = CacheMetadataUpdate {\n        cache_key,\n        cache_type,\n        metadata: Some(metadata),\n        expiry: Some(Utc::now() + Duration::minutes(30)),\n        is_stale: Some(false),\n        doc_version: response.current_version.map(|version| version as i64),\n        blob_hash: response\n            .avatar\n            .as_ref()\n            .map(|avatar| avatar.blob_hash.clone()),\n        payload_bytes,\n    };\n\n    offline_service.upsert_cache_metadata(update).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::services::OfflineService;\n    use crate::domain::entities::ProfileAvatarAccessLevel;\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    #[tokio::test]\n    async fn record_profile_avatar_sync_metadata_persists_cache_entry() {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .expect(\"sqlite memory pool\");\n        sqlx::migrate!(\"./migrations\")\n            .run(&pool)\n            .await\n            .expect(\"migrations\");\n\n        let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n        let offline_service = OfflineService::new(persistence);\n\n        let request = ProfileAvatarSyncRequest {\n            npub: \"npub1test\".to_string(),\n            known_doc_version: Some(2),\n            source: Some(\"profile-avatar-sync-worker:interval\".to_string()),\n            requested_at: Some(\"2025-11-12T00:00:00Z\".to_string()),\n            retry_count: Some(1),\n            job_id: Some(\"job-42\".to_string()),\n        };\n\n        let response = ProfileAvatarSyncResponse {\n            npub: \"npub1test\".to_string(),\n            current_version: Some(4),\n            updated: true,\n            avatar: Some(FetchProfileAvatarResponse {\n                npub: \"npub1test\".to_string(),\n                blob_hash: \"bafy-avatar\".to_string(),\n                format: \"image/png\".to_string(),\n                size_bytes: 1_024,\n                access_level: ProfileAvatarAccessLevel::ContactsOnly,\n                share_ticket: \"ticket\".to_string(),\n                doc_version: 4,\n                updated_at: \"2025-11-12T00:00:00Z\".to_string(),\n                content_sha256: \"abcd\".to_string(),\n                data_base64: \"AAECAw==\".to_string(),\n            }),\n        };\n\n        record_profile_avatar_sync_metadata(&offline_service, &request, &response)\n            .await\n            .expect(\"metadata recorded\");\n\n        let row: (String, Option<i64>, Option<String>, Option<i64>) = sqlx::query_as(\n            \"SELECT cache_key, doc_version, blob_hash, payload_bytes FROM cache_metadata WHERE cache_key = ?1\",\n        )\n        .bind(\"doc::profile_avatar::npub1test\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"metadata row\");\n\n        assert_eq!(row.0, \"doc::profile_avatar::npub1test\");\n        assert_eq!(row.1, Some(4));\n        assert_eq!(row.2.as_deref(), Some(\"bafy-avatar\"));\n        assert_eq!(row.3, Some(1_024));\n    }\n}\n","traces":[{"line":30,"address":[15912992],"length":1,"stats":{"Line":0}},{"line":32,"address":[15913020],"length":1,"stats":{"Line":0}},{"line":33,"address":[16112358],"length":1,"stats":{"Line":0}},{"line":34,"address":[16012017],"length":1,"stats":{"Line":0}},{"line":35,"address":[23674322],"length":1,"stats":{"Line":0}},{"line":36,"address":[15980935],"length":1,"stats":{"Line":0}},{"line":37,"address":[15913259],"length":1,"stats":{"Line":0}},{"line":40,"address":[23674547],"length":1,"stats":{"Line":0}},{"line":41,"address":[15981136],"length":1,"stats":{"Line":0}},{"line":42,"address":[15974224],"length":1,"stats":{"Line":0}},{"line":47,"address":[23714864],"length":1,"stats":{"Line":0}},{"line":51,"address":[11425630],"length":1,"stats":{"Line":0}},{"line":52,"address":[16015517,16015454,16015504],"length":1,"stats":{"Line":0}},{"line":55,"address":[16057214],"length":1,"stats":{"Line":0}},{"line":59,"address":[16053680],"length":1,"stats":{"Line":0}},{"line":63,"address":[16022662,16023096,16022834,16023158,16022877,16022777],"length":1,"stats":{"Line":0}},{"line":64,"address":[16154345],"length":1,"stats":{"Line":0}},{"line":65,"address":[16058021,16057834,16057973,16058077,16058218],"length":1,"stats":{"Line":0}},{"line":66,"address":[16023456],"length":1,"stats":{"Line":0}},{"line":67,"address":[16054704,16054717,16054654],"length":1,"stats":{"Line":0}},{"line":70,"address":[15941662],"length":1,"stats":{"Line":0}},{"line":74,"address":[21190720],"length":1,"stats":{"Line":0}},{"line":78,"address":[16062902,16060713,16060835,16060932],"length":1,"stats":{"Line":0}},{"line":80,"address":[21191257,21191415],"length":1,"stats":{"Line":0}},{"line":81,"address":[16024364,16024463],"length":1,"stats":{"Line":0}},{"line":83,"address":[21194708,21194704],"length":1,"stats":{"Line":0}},{"line":86,"address":[16017600,16017773,16019178],"length":1,"stats":{"Line":0}},{"line":87,"address":[16061433,16061735,16061606],"length":1,"stats":{"Line":0}},{"line":89,"address":[21192286,21192023,21192463,21192096],"length":1,"stats":{"Line":0}},{"line":90,"address":[16058898,16058880,16056322],"length":1,"stats":{"Line":0}},{"line":94,"address":[21192042],"length":1,"stats":{"Line":0}},{"line":99,"address":[23718789],"length":1,"stats":{"Line":0}},{"line":102,"address":[16060553],"length":1,"stats":{"Line":0}},{"line":106,"address":[16018775,16019266,16018875,16019851,16017078],"length":1,"stats":{"Line":0}},{"line":108,"address":[16019784,16019977],"length":1,"stats":{"Line":0}},{"line":109,"address":[15959199],"length":1,"stats":{"Line":0}},{"line":110,"address":[16026999],"length":1,"stats":{"Line":0}},{"line":111,"address":[15945490],"length":1,"stats":{"Line":0}},{"line":112,"address":[15945503],"length":1,"stats":{"Line":0}},{"line":115,"address":[16063980],"length":1,"stats":{"Line":0}},{"line":119,"address":[16062976],"length":1,"stats":{"Line":0}},{"line":123,"address":[16021301,16021113,16021223],"length":1,"stats":{"Line":0}},{"line":125,"address":[16028297,16028725,16028423,16028204,16028359],"length":1,"stats":{"Line":0}},{"line":127,"address":[16021385],"length":1,"stats":{"Line":0}},{"line":128,"address":[16063474],"length":1,"stats":{"Line":0}},{"line":131,"address":[19273236],"length":1,"stats":{"Line":0}},{"line":132,"address":[16063956],"length":1,"stats":{"Line":0}},{"line":136,"address":[16022064],"length":1,"stats":{"Line":0}},{"line":141,"address":[16064334,16064386,16064686,16064449],"length":1,"stats":{"Line":0}},{"line":142,"address":[16161331],"length":1,"stats":{"Line":0}},{"line":146,"address":[23723552],"length":1,"stats":{"Line":0}},{"line":151,"address":[16030589,16030433,16030318,16030546,16030772],"length":1,"stats":{"Line":0}},{"line":152,"address":[15948929],"length":1,"stats":{"Line":0}},{"line":153,"address":[11503969],"length":1,"stats":{"Line":0}},{"line":154,"address":[15949363],"length":1,"stats":{"Line":0}},{"line":158,"address":[16066320],"length":1,"stats":{"Line":0}},{"line":162,"address":[16163074,16163218],"length":1,"stats":{"Line":0}},{"line":163,"address":[23725170],"length":1,"stats":{"Line":0}},{"line":164,"address":[16031827,16032093,16031937],"length":1,"stats":{"Line":0}},{"line":165,"address":[16068406,16067160,16068384],"length":1,"stats":{"Line":0}},{"line":166,"address":[16024889],"length":1,"stats":{"Line":0}},{"line":168,"address":[16063077,16063322],"length":1,"stats":{"Line":0}},{"line":171,"address":[23726921,23726912],"length":1,"stats":{"Line":0}},{"line":172,"address":[16064684,16064672],"length":1,"stats":{"Line":0}},{"line":173,"address":[16063817,16064319,16064172,16063446,16063741],"length":1,"stats":{"Line":0}},{"line":175,"address":[21199199],"length":1,"stats":{"Line":0}},{"line":176,"address":[15964627],"length":1,"stats":{"Line":0}},{"line":178,"address":[15950923],"length":1,"stats":{"Line":0}},{"line":180,"address":[16032454],"length":1,"stats":{"Line":0}},{"line":182,"address":[11547249],"length":1,"stats":{"Line":0}},{"line":183,"address":[23727198,23726992,23727280],"length":1,"stats":{"Line":0}},{"line":184,"address":[15952122,15952037],"length":1,"stats":{"Line":0}},{"line":185,"address":[16033698],"length":1,"stats":{"Line":0}},{"line":186,"address":[16033734],"length":1,"stats":{"Line":0}},{"line":187,"address":[21200558],"length":1,"stats":{"Line":0}},{"line":189,"address":[16026234],"length":1,"stats":{"Line":0}},{"line":193,"address":[21200672],"length":1,"stats":{"Line":0}},{"line":197,"address":[16065362,16065506],"length":1,"stats":{"Line":0}},{"line":198,"address":[16034370],"length":1,"stats":{"Line":0}},{"line":199,"address":[16065667,16065777,16065933],"length":1,"stats":{"Line":0}},{"line":200,"address":[15959960,15961184,15961206],"length":1,"stats":{"Line":0}},{"line":201,"address":[15959737],"length":1,"stats":{"Line":0}},{"line":203,"address":[16027866,16027621],"length":1,"stats":{"Line":0}},{"line":206,"address":[16072889,16072880],"length":1,"stats":{"Line":0}},{"line":207,"address":[15954624,15954636],"length":1,"stats":{"Line":0}},{"line":208,"address":[16167343,16167196,16166470,16166841,16166765],"length":1,"stats":{"Line":0}},{"line":210,"address":[23728435],"length":1,"stats":{"Line":0}},{"line":211,"address":[16166595],"length":1,"stats":{"Line":0}},{"line":213,"address":[16070219],"length":1,"stats":{"Line":0}},{"line":215,"address":[15953590],"length":1,"stats":{"Line":0}},{"line":217,"address":[16071019,16072090,16072294,16072030,16072476],"length":1,"stats":{"Line":0}},{"line":218,"address":[21203122,21202928,21203204],"length":1,"stats":{"Line":0}},{"line":219,"address":[23729754,23729669],"length":1,"stats":{"Line":0}},{"line":220,"address":[16029426],"length":1,"stats":{"Line":0}},{"line":221,"address":[16067574],"length":1,"stats":{"Line":0}},{"line":222,"address":[16029466],"length":1,"stats":{"Line":0}},{"line":224,"address":[16070938],"length":1,"stats":{"Line":0}},{"line":228,"address":[15961776],"length":1,"stats":{"Line":0}},{"line":233,"address":[16029829],"length":1,"stats":{"Line":0}},{"line":234,"address":[16036783],"length":1,"stats":{"Line":0}},{"line":235,"address":[23730265],"length":1,"stats":{"Line":0}},{"line":236,"address":[16071958],"length":1,"stats":{"Line":0}},{"line":238,"address":[16073843,16073956,16074010,16074297,16074232,16073728],"length":1,"stats":{"Line":0}},{"line":239,"address":[16037096],"length":1,"stats":{"Line":0}},{"line":240,"address":[16072132,16072389,16072445,16072335,16072586],"length":1,"stats":{"Line":0}},{"line":242,"address":[15956036],"length":1,"stats":{"Line":0}},{"line":246,"address":[15956224],"length":1,"stats":{"Line":0}},{"line":250,"address":[16073475,16073251,16073205,16073148,16073540,16073033],"length":1,"stats":{"Line":0}},{"line":251,"address":[16038044],"length":1,"stats":{"Line":0}},{"line":252,"address":[11463713],"length":1,"stats":{"Line":0}},{"line":254,"address":[16069628],"length":1,"stats":{"Line":0}},{"line":258,"address":[15957104],"length":1,"stats":{"Line":0}},{"line":263,"address":[16039203,16039034],"length":1,"stats":{"Line":0}},{"line":264,"address":[11453903],"length":1,"stats":{"Line":0}},{"line":265,"address":[15972070],"length":1,"stats":{"Line":0}},{"line":266,"address":[23733293],"length":1,"stats":{"Line":0}},{"line":267,"address":[16075055,16074978],"length":1,"stats":{"Line":0}},{"line":269,"address":[16171495],"length":1,"stats":{"Line":0}},{"line":270,"address":[16040588,16039989],"length":1,"stats":{"Line":0}},{"line":273,"address":[16075786],"length":1,"stats":{"Line":0}},{"line":280,"address":[23733827],"length":1,"stats":{"Line":0}},{"line":282,"address":[16075511],"length":1,"stats":{"Line":0}},{"line":288,"address":[16076844],"length":1,"stats":{"Line":0}},{"line":290,"address":[16171648],"length":1,"stats":{"Line":0}},{"line":300,"address":[16172716],"length":1,"stats":{"Line":0}},{"line":303,"address":[10805630],"length":1,"stats":{"Line":0}},{"line":305,"address":[16041940,16042134],"length":1,"stats":{"Line":0}},{"line":308,"address":[16012736],"length":1,"stats":{"Line":1}},{"line":313,"address":[15905841,15900510,15900385,15900874],"length":1,"stats":{"Line":2}},{"line":314,"address":[15914586],"length":1,"stats":{"Line":0}},{"line":315,"address":[16013888,16013672,16013496],"length":1,"stats":{"Line":2}},{"line":318,"address":[16017962,16017798],"length":1,"stats":{"Line":2}},{"line":321,"address":[15987776,15987785],"length":1,"stats":{"Line":2}},{"line":323,"address":[21052380,21054827,21055292,21054747,21056413,21055375],"length":1,"stats":{"Line":3}},{"line":333,"address":[15985359,16043352,15985290,16042496,16043402],"length":1,"stats":{"Line":3}},{"line":334,"address":[16079294,16080098,16080129],"length":1,"stats":{"Line":1}},{"line":341,"address":[23679300,23679363],"length":1,"stats":{"Line":2}},{"line":347,"address":[15979405],"length":1,"stats":{"Line":1}},{"line":348,"address":[16021485,16021553],"length":1,"stats":{"Line":2}},{"line":349,"address":[16118075],"length":1,"stats":{"Line":1}},{"line":350,"address":[16017715,16019008,16019016],"length":1,"stats":{"Line":3}},{"line":351,"address":[15911851],"length":1,"stats":{"Line":1}},{"line":358,"address":[11673652],"length":1,"stats":{"Line":2}}],"covered":15,"coverable":143},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","utils_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::shared::AppError;\nuse nostr_sdk::prelude::*;\n\n/// 16進数の公開鍵をnpub（Bech32形式）に変換\n#[tauri::command]\npub fn pubkey_to_npub(pubkey: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_hex(&pubkey)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効な公開鍵: {e}\")))?;\n\n    let npub = public_key\n        .to_bech32()\n        .map_err(|e| AppError::InvalidInput(format!(\"Bech32変換エラー: {e}\")))?;\n\n    Ok(ApiResponse::success(npub))\n}\n\n/// npub（Bech32形式）を16進数の公開鍵に変換\n#[tauri::command]\npub fn npub_to_pubkey(npub: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_bech32(&npub)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効なnpub: {e}\")))?;\n\n    Ok(ApiResponse::success(public_key.to_hex()))\n}\n","traces":[{"line":7,"address":[12913290,12913258,12912496],"length":1,"stats":{"Line":0}},{"line":8,"address":[12838078,12837790,12838552,12837866],"length":1,"stats":{"Line":0}},{"line":9,"address":[12943959,12944496,12944512],"length":1,"stats":{"Line":0}},{"line":11,"address":[12845358,12845083,12844986],"length":1,"stats":{"Line":0}},{"line":13,"address":[13045041,13044622,13045024],"length":1,"stats":{"Line":0}},{"line":15,"address":[12949766,12949954],"length":1,"stats":{"Line":0}},{"line":20,"address":[13045619,13045200],"length":1,"stats":{"Line":0}},{"line":21,"address":[12948798,12948866,12949074],"length":1,"stats":{"Line":0}},{"line":22,"address":[12945099,12945280,12945302],"length":1,"stats":{"Line":0}},{"line":24,"address":[12945087,12945164],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","access_control_dto.rs"],"content":"use crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlIssueInviteRequest {\n    pub topic_id: String,\n    pub expires_in: Option<i64>,\n    pub max_uses: Option<i64>,\n    pub nonce: Option<String>,\n}\n\nimpl Validate for AccessControlIssueInviteRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.trim().is_empty() {\n            return Err(\"topic_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlIssueInviteResponse {\n    pub invite_event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlJoinRequest {\n    pub topic_id: Option<String>,\n    pub scope: Option<String>,\n    pub invite_event_json: Option<serde_json::Value>,\n    pub target_pubkey: Option<String>,\n    pub broadcast_to_topic: Option<bool>,\n}\n\nimpl Validate for AccessControlJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.invite_event_json.is_none() {\n            let topic = self.topic_id.as_ref().map(|v| v.trim()).unwrap_or(\"\");\n            if topic.is_empty() {\n                return Err(\"topic_id is required when invite_event_json is absent\".to_string());\n            }\n            if let Some(scope) = self.scope.as_ref() {\n                if scope.trim().is_empty() {\n                    return Err(\"scope must not be empty when provided\".to_string());\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlJoinResponse {\n    pub event_id: String,\n    pub sent_topics: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlPendingJoinRequest {\n    pub event_id: String,\n    pub topic_id: String,\n    pub scope: String,\n    pub requester_pubkey: String,\n    pub target_pubkey: Option<String>,\n    pub requested_at: Option<i64>,\n    pub received_at: i64,\n    pub invite_event_json: Option<serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlListJoinRequestsResponse {\n    pub items: Vec<AccessControlPendingJoinRequest>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlApproveJoinRequest {\n    pub event_id: String,\n}\n\nimpl Validate for AccessControlApproveJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.event_id.trim().is_empty() {\n            return Err(\"event_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlApproveJoinResponse {\n    pub event_id: String,\n    pub key_envelope_event_id: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccessControlRejectJoinRequest {\n    pub event_id: String,\n}\n\nimpl Validate for AccessControlRejectJoinRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.event_id.trim().is_empty() {\n            return Err(\"event_id is required\".to_string());\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[14258512],"length":1,"stats":{"Line":0}},{"line":14,"address":[16451166],"length":1,"stats":{"Line":0}},{"line":15,"address":[14364517],"length":1,"stats":{"Line":0}},{"line":17,"address":[16451206],"length":1,"stats":{"Line":0}},{"line":36,"address":[14251888],"length":1,"stats":{"Line":0}},{"line":37,"address":[14326512],"length":1,"stats":{"Line":0}},{"line":38,"address":[14258746,14259033,14259024],"length":1,"stats":{"Line":0}},{"line":39,"address":[14265774],"length":1,"stats":{"Line":0}},{"line":40,"address":[14326666],"length":1,"stats":{"Line":0}},{"line":42,"address":[14258914,14258812],"length":1,"stats":{"Line":0}},{"line":43,"address":[14252140],"length":1,"stats":{"Line":0}},{"line":44,"address":[14333696],"length":1,"stats":{"Line":0}},{"line":48,"address":[16451346],"length":1,"stats":{"Line":0}},{"line":81,"address":[14364976],"length":1,"stats":{"Line":0}},{"line":82,"address":[14370590],"length":1,"stats":{"Line":0}},{"line":83,"address":[16451761],"length":1,"stats":{"Line":0}},{"line":85,"address":[14259122],"length":1,"stats":{"Line":0}},{"line":101,"address":[14259216],"length":1,"stats":{"Line":0}},{"line":102,"address":[14465534],"length":1,"stats":{"Line":0}},{"line":103,"address":[14327105],"length":1,"stats":{"Line":0}},{"line":105,"address":[14369138],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","auth_dto.rs"],"content":"use super::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginResponse {\n    pub success: bool,\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginWithNsecRequest {\n    pub nsec: String,\n}\n\nimpl Validate for LoginWithNsecRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.trim().is_empty() {\n            return Err(\"秘密鍵が必要です\".to_string());\n        }\n        if !self.nsec.starts_with(\"nsec1\") {\n            return Err(\"無効な秘密鍵形式です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ExportPrivateKeyRequest {\n    pub npub: String,\n}\n\nimpl Validate for ExportPrivateKeyRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.npub.trim().is_empty() {\n            return Err(\"npub is required\".to_string());\n        }\n        if !self.npub.starts_with(\"npub1\") {\n            return Err(\"npub must start with npub1\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ExportPrivateKeyResponse {\n    pub nsec: String,\n}\n","traces":[{"line":17,"address":[13162672],"length":1,"stats":{"Line":0}},{"line":18,"address":[13162704],"length":1,"stats":{"Line":0}},{"line":19,"address":[18908471],"length":1,"stats":{"Line":0}},{"line":21,"address":[13162740],"length":1,"stats":{"Line":0}},{"line":22,"address":[14395615],"length":1,"stats":{"Line":0}},{"line":24,"address":[19026876],"length":1,"stats":{"Line":0}},{"line":41,"address":[18915408],"length":1,"stats":{"Line":0}},{"line":42,"address":[18915440],"length":1,"stats":{"Line":0}},{"line":43,"address":[18983319],"length":1,"stats":{"Line":0}},{"line":45,"address":[14395780],"length":1,"stats":{"Line":0}},{"line":46,"address":[14395871],"length":1,"stats":{"Line":0}},{"line":48,"address":[18922604],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","community_node_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeRoleConfig {\n    pub labels: bool,\n    pub trust: bool,\n    pub search: bool,\n    pub bootstrap: bool,\n}\n\nimpl Default for CommunityNodeRoleConfig {\n    fn default() -> Self {\n        Self {\n            labels: true,\n            trust: true,\n            search: false,\n            bootstrap: true,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigNodeRequest {\n    pub base_url: String,\n    pub roles: Option<CommunityNodeRoleConfig>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigRequest {\n    pub nodes: Vec<CommunityNodeConfigNodeRequest>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigNodeResponse {\n    pub base_url: String,\n    pub roles: CommunityNodeRoleConfig,\n    pub has_token: bool,\n    pub token_expires_at: Option<i64>,\n    pub pubkey: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConfigResponse {\n    pub nodes: Vec<CommunityNodeConfigNodeResponse>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeAuthResponse {\n    pub expires_at: i64,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeLabelsRequest {\n    pub base_url: Option<String>,\n    pub target: String,\n    pub topic: Option<String>,\n    pub limit: Option<usize>,\n    pub cursor: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustRequest {\n    pub base_url: Option<String>,\n    pub subject: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustAnchorRequest {\n    pub attester: String,\n    pub claim: Option<String>,\n    pub topic: Option<String>,\n    pub weight: Option<f64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTrustAnchorState {\n    pub attester: String,\n    pub claim: Option<String>,\n    pub topic: Option<String>,\n    pub weight: f64,\n    pub issued_at: i64,\n    pub event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeSearchRequest {\n    pub base_url: Option<String>,\n    pub topic: String,\n    pub q: Option<String>,\n    pub limit: Option<usize>,\n    pub cursor: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeConsentRequest {\n    pub base_url: Option<String>,\n    pub policy_ids: Option<Vec<String>>,\n    pub accept_all_current: Option<bool>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeReportRequest {\n    pub base_url: Option<String>,\n    pub report_event_json: Option<serde_json::Value>,\n    pub target: Option<String>,\n    pub reason: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeAuthRequest {\n    pub base_url: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeTokenRequest {\n    pub base_url: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommunityNodeBootstrapServicesRequest {\n    pub base_url: Option<String>,\n    pub topic_id: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","direct_message_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// 送信要求。暗号化や署名はサービス側で処理する想定。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SendDirectMessageRequest {\n    pub recipient_npub: String,\n    pub content: String,\n    pub client_message_id: Option<String>,\n}\n\n/// 送信結果。最小限のメタデータのみ保持。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SendDirectMessageResponse {\n    pub event_id: Option<String>,\n    pub queued: bool,\n}\n\n/// 単一メッセージの DTO。UI 側では `client_message_id` で楽観更新を照合する。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageDto {\n    pub event_id: Option<String>,\n    pub client_message_id: Option<String>,\n    pub sender_npub: String,\n    pub recipient_npub: String,\n    pub content: String,\n    pub created_at: i64,\n    pub delivered: bool,\n}\n\n/// カーソル付きメッセージ取得リクエスト。\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct ListDirectMessagesRequest {\n    pub conversation_npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub direction: Option<MessagePageDirection>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Default)]\npub struct ListDirectMessageConversationsRequest {\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n}\n\n/// 取得方向。将来的な前方/後方スクロールを想定。\n#[derive(Debug, Serialize, Deserialize, Clone, Copy, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum MessagePageDirection {\n    #[default]\n    Backward,\n    Forward,\n}\n\n/// カーソルページ。`has_more` は UI のロード制御用。\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessagePage {\n    pub items: Vec<DirectMessageDto>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageConversationSummaryDto {\n    pub conversation_npub: String,\n    pub unread_count: u64,\n    pub last_read_at: i64,\n    pub last_message: Option<DirectMessageDto>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct DirectMessageConversationListDto {\n    pub items: Vec<DirectMessageConversationSummaryDto>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct MarkDirectMessageConversationReadRequest {\n    pub conversation_npub: String,\n    pub last_read_at: i64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SeedDirectMessageRequest {\n    pub content: Option<String>,\n    pub created_at: Option<i64>,\n    pub recipient_nsec: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SeedDirectMessageResponse {\n    pub conversation_npub: String,\n    pub created_at: i64,\n    pub content: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\nuse crate::presentation::dto::Validate;\nuse nostr_sdk::prelude::Url;\nuse serde::{Deserialize, Serialize};\n\r\nfn default_true() -> bool {\n    true\n}\n\nconst MAX_NIP65_RELAYS: usize = 64;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Nip65RelayDto {\n    pub url: String,\n    #[serde(default = \"default_true\")]\n    pub read: bool,\n    #[serde(default = \"default_true\")]\n    pub write: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NostrMetadataDto {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub website: Option<String>,\n    pub relays: Option<Vec<Nip65RelayDto>>,\n    #[serde(rename = \"kukuri_privacy\")]\n    pub privacy: Option<PrivacyPreferencesDto>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct PrivacyPreferencesDto {\n    pub public_profile: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTextNoteRequest {\r\n    pub content: String,\r\n}\r\n\r\nimpl Validate for PublishTextNoteRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTopicPostRequest {\r\n    pub topic_id: String,\r\n    pub content: String,\r\n    pub reply_to: Option<String>,\r\n}\r\n\r\nimpl Validate for PublishTopicPostRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SendReactionRequest {\r\n    pub event_id: String,\r\n    pub reaction: String,\r\n}\r\n\r\nimpl Validate for SendReactionRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.event_id.is_empty() {\r\n            return Err(\"Event ID is required\".to_string());\r\n        }\r\n        if self.reaction.is_empty() {\r\n            return Err(\"Reaction cannot be empty\".to_string());\r\n        }\r\n        if self.reaction.len() > 20 {\r\n            return Err(\"Reaction is too long (max 20 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct UpdateMetadataRequest {\r\n    pub metadata: NostrMetadataDto,\r\n}\r\n\r\nimpl Validate for UpdateMetadataRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        // 各フィールドの長さチェック\r\n        if let Some(name) = &self.metadata.name {\r\n            if name.len() > 100 {\r\n                return Err(\"Name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(display_name) = &self.metadata.display_name {\r\n            if display_name.len() > 100 {\r\n                return Err(\"Display name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(about) = &self.metadata.about {\n            if about.len() > 1000 {\n                return Err(\"About is too long (max 1000 characters)\".to_string());\n            }\n        }\n        if let Some(relays) = &self.metadata.relays {\n            if relays.len() > MAX_NIP65_RELAYS {\n                return Err(format!(\n                    \"Relay list is too long (max {MAX_NIP65_RELAYS} entries)\"\n                ));\n            }\n            for relay in relays {\n                if relay.url.trim().is_empty() {\n                    return Err(\"Relay URL cannot be empty\".to_string());\n                }\n                let parsed = Url::parse(relay.url.as_str())\n                    .map_err(|_| \"Relay URL must be a valid websocket URL\".to_string())?;\n                match parsed.scheme() {\n                    \"ws\" | \"wss\" => {}\n                    _ => {\n                        return Err(\"Relay URL must use ws:// or wss://\".to_string());\n                    }\n                }\n            }\n        }\n        // URLの検証は省略（実際の実装では必要に応じて追加）\n        Ok(())\n    }\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SubscribeRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for SubscribeRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct EventResponse {\r\n    pub event_id: String,\r\n    pub success: bool,\r\n    pub message: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct NostrSubscriptionStateDto {\r\n    pub target: String,\r\n    pub target_type: String,\r\n    pub status: String,\r\n    pub last_synced_at: Option<i64>,\r\n    pub last_attempt_at: Option<i64>,\r\n    pub failure_count: i64,\r\n    pub error_message: Option<String>,\r\n}\r\n\r\nimpl From<SubscriptionRecord> for NostrSubscriptionStateDto {\r\n    fn from(record: SubscriptionRecord) -> Self {\r\n        let (target_type, target_value) = match record.target {\r\n            SubscriptionTarget::Topic(id) => (\"topic\".to_string(), id),\r\n            SubscriptionTarget::User(id) => (\"user\".to_string(), id),\r\n        };\r\n        Self {\r\n            target: target_value,\r\n            target_type,\r\n            status: record.status.as_str().to_string(),\r\n            last_synced_at: record.last_synced_at,\r\n            last_attempt_at: record.last_attempt_at,\r\n            failure_count: record.failure_count,\r\n            error_message: record.error_message,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":49,"address":[21404992],"length":1,"stats":{"Line":0}},{"line":50,"address":[21517728],"length":1,"stats":{"Line":0}},{"line":51,"address":[21411837],"length":1,"stats":{"Line":0}},{"line":53,"address":[21523326],"length":1,"stats":{"Line":0}},{"line":54,"address":[15659433],"length":1,"stats":{"Line":0}},{"line":56,"address":[21486634],"length":1,"stats":{"Line":0}},{"line":68,"address":[21521840],"length":1,"stats":{"Line":0}},{"line":69,"address":[21418990],"length":1,"stats":{"Line":0}},{"line":70,"address":[21521898],"length":1,"stats":{"Line":0}},{"line":72,"address":[12242315],"length":1,"stats":{"Line":0}},{"line":73,"address":[21412124],"length":1,"stats":{"Line":0}},{"line":75,"address":[12242393],"length":1,"stats":{"Line":0}},{"line":76,"address":[15659720],"length":1,"stats":{"Line":0}},{"line":78,"address":[15659705],"length":1,"stats":{"Line":0}},{"line":89,"address":[21518192],"length":1,"stats":{"Line":0}},{"line":90,"address":[21487038],"length":1,"stats":{"Line":0}},{"line":91,"address":[21618618],"length":1,"stats":{"Line":0}},{"line":93,"address":[21412315],"length":1,"stats":{"Line":0}},{"line":94,"address":[21618698],"length":1,"stats":{"Line":0}},{"line":96,"address":[21522249],"length":1,"stats":{"Line":0}},{"line":97,"address":[21405702],"length":1,"stats":{"Line":0}},{"line":99,"address":[21523975],"length":1,"stats":{"Line":0}},{"line":109,"address":[21480368,21481957],"length":1,"stats":{"Line":0}},{"line":111,"address":[12242878],"length":1,"stats":{"Line":0}},{"line":112,"address":[21524137],"length":1,"stats":{"Line":0}},{"line":113,"address":[21487430],"length":1,"stats":{"Line":0}},{"line":116,"address":[21405865,21405982],"length":1,"stats":{"Line":0}},{"line":117,"address":[21619062],"length":1,"stats":{"Line":0}},{"line":118,"address":[21619123],"length":1,"stats":{"Line":0}},{"line":121,"address":[21406006,21406127],"length":1,"stats":{"Line":0}},{"line":122,"address":[21480727],"length":1,"stats":{"Line":0}},{"line":123,"address":[21619275],"length":1,"stats":{"Line":0}},{"line":126,"address":[21487673,21487799],"length":1,"stats":{"Line":0}},{"line":127,"address":[21413071],"length":1,"stats":{"Line":0}},{"line":128,"address":[21420116],"length":1,"stats":{"Line":0}},{"line":132,"address":[21420286,21420089],"length":1,"stats":{"Line":0}},{"line":133,"address":[21481194],"length":1,"stats":{"Line":0}},{"line":134,"address":[15661047],"length":1,"stats":{"Line":0}},{"line":136,"address":[21413422,21413598,21413868],"length":1,"stats":{"Line":0}},{"line":137,"address":[15661340,15661696,15661715],"length":1,"stats":{"Line":0}},{"line":138,"address":[21413948,21413798],"length":1,"stats":{"Line":0}},{"line":139,"address":[21407269,21407180],"length":1,"stats":{"Line":0}},{"line":141,"address":[21519979],"length":1,"stats":{"Line":0}},{"line":147,"address":[21480898],"length":1,"stats":{"Line":0}},{"line":157,"address":[21520144],"length":1,"stats":{"Line":0}},{"line":158,"address":[21482062],"length":1,"stats":{"Line":0}},{"line":159,"address":[21525787],"length":1,"stats":{"Line":0}},{"line":161,"address":[21407484],"length":1,"stats":{"Line":0}},{"line":184,"address":[21621784,21620640,21621155],"length":1,"stats":{"Line":0}},{"line":185,"address":[21525878,21526210],"length":1,"stats":{"Line":0}},{"line":186,"address":[21414519,21414401],"length":1,"stats":{"Line":0}},{"line":187,"address":[21525965,21526403],"length":1,"stats":{"Line":0}},{"line":192,"address":[21421815,21422113],"length":1,"stats":{"Line":0}},{"line":193,"address":[21521091],"length":1,"stats":{"Line":0}},{"line":194,"address":[21422155],"length":1,"stats":{"Line":0}},{"line":195,"address":[15662707],"length":1,"stats":{"Line":0}},{"line":196,"address":[12245475],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct EventResponse {\n    pub id: String,\n    pub kind: u32,\n    pub pubkey: String,\n    pub content: String,\n    pub tags: Vec<Vec<String>>,\n    pub created_at: i64,\n    pub sig: String,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","mod.rs"],"content":"// DTOモジュール\npub mod access_control_dto;\npub mod auth_dto;\npub mod community_node_dto;\npub mod direct_message_dto;\npub mod event;\npub mod offline;\npub mod p2p;\npub mod post_dto;\npub mod profile_avatar_dto;\npub mod topic_dto;\npub mod user_dto;\n\n// 共通のレスポンス型\nuse crate::shared::AppError;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ApiResponse<T> {\n    pub success: bool,\n    pub data: Option<T>,\n    pub error: Option<String>,\n    pub error_code: Option<String>,\n    pub error_details: Option<serde_json::Value>,\n}\n\nimpl<T> ApiResponse<T> {\n    pub fn success(data: T) -> Self {\n        Self {\n            success: true,\n            data: Some(data),\n            error: None,\n            error_code: None,\n            error_details: None,\n        }\n    }\n\n    pub fn from_app_error(error: AppError) -> Self {\n        let error_details = match error {\n            AppError::RateLimited {\n                retry_after_seconds,\n                ..\n            } => Some(json!({ \"retry_after_seconds\": retry_after_seconds })),\n            _ => None,\n        };\n\n        Self {\n            success: false,\n            data: None,\n            error: Some(error.user_message()),\n            error_code: Some(error.code().to_string()),\n            error_details,\n        }\n    }\n\n    pub fn from_result(result: crate::shared::Result<T>) -> Self {\n        match result {\n            Ok(data) => Self::success(data),\n            Err(err) => Self::from_app_error(err),\n        }\n    }\n}\n\n// ページネーション\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PaginationRequest {\n    pub limit: Option<u32>,\n    pub offset: Option<u32>,\n}\n\nimpl Default for PaginationRequest {\n    fn default() -> Self {\n        Self {\n            limit: Some(50),\n            offset: Some(0),\n        }\n    }\n}\n\n// バリデーショントレイト\npub trait Validate {\n    fn validate(&self) -> Result<(), String>;\n}\n","traces":[{"line":29,"address":[18139984,18142976,18136224,18137600,18138288,18132624,18142496,18139520,18135840,18143248,18136704,18137360,18141104,18138096,18141664,18133248,18142304,18133664,18140256,18143984,18136976,18131792,18135568,18135120,18133056,18132208,18138816,18143632,18140464,18143824,18140704,18141840,18141312,18132432,18139792,18133440,18136432,18141488,18144256,18132864,18138560,18140896,18136032,18137168,18142704,18142080,18133888,18137824,18135344,18139296,18134592,18132016,18143440,18134160,18139088,18134848,18134368],"length":1,"stats":{"Line":0}},{"line":32,"address":[15379456,15379907,15377459,15382496,15375491,15383344,15376592,15375299,15376321,15374723,15371537,15376995,15382887,15376099,15382225,15375139,15375697,15372707,15373843,15380305,15381504,15373136,15372273,15380752,15373633,15381024,15378528,15378755,15383936,15381232,15377680,15375907,15372912,15379185,15383731,15372515,15376803,15380099,15374931,15374531,15381952,15374323,15374064,15383073,15372049,15377891,15373409,15378323,15383555,15378961,15379715,15380531,15382712,15377200,15371808,15378097,15381747],"length":1,"stats":{"Line":0}},{"line":39,"address":[15210800,15194634,15205408,15189301,15186070,15187728,15190400,15195722,15190960,15202149,15177526,15182902,15174304,15208597,15185584,15192504,15183952,15179696,15198918,15212928,15185024,15171680,15204886,15218219,15208143,15180250,15200032,15207563,15177552,15181340,15209190,15213980,15200592,15211872,15178598,15209690,15176480,15206496,15172166,15173264,15194160,15199510,15208624,15178112,15210272,15175392,15214000,15191414,15214550,15181856,15207584,15201088,15213488,15186652,15195222,15176459,15177040,15186096,15174320,15175366,15179184,15184998,15193579,15196800,15196304,15178624,15217136,15189328,15212912,15197872,15174880,15182928,15214991,15188214,15202736,15182416,15202176,15217152,15204320,15173824,15207056,15184512,15201642,15190373,15203814,15206474,15194656,15211846,15187152,15217712,15172758,15172192,15205395,15210776,15191440,15209712,15197846,15193094,15216074,15192000,15171120,15197360,15196784,15192528,15198944,15219285,15204299,15211360,15198432,15218806,15180757,15218240,15180784,15205974,15212432,15175952,15173237,15215008,15201072,15183929,15216096,15188794,15216656,15200004,15203248,15187168,15183481,15188240,15203222,15195744,15181840,15189894,15193600,15215574,15179670],"length":1,"stats":{"Line":0}},{"line":40,"address":[15245734,15265014,15269270,15256470,15277862,15281110,15270358,15292854,15258566,15260710,15262854,15275702,15283238,15288614,15282198,15255398,15266054,15267142,15274646,15290710,15252166,15268214,15247878,15286486,15263942,15289622,15278934,15261782,15276790,15254310,15257542,15291766,15251094,15259638,15250006,15253238,15272486,15271414,15273558,15284326,15280022,15285414,15287542,15246806,15248934],"length":1,"stats":{"Line":0}},{"line":41,"address":[22979415,22968048,22979357,22972314,22980503,22985837,22957370,22953661,22974039,22980928,22956951,22953719,22985895,22953066,22981533,22983661,22985226,22958023,22954138,22950429,22975127,22991610,22968695,22981591,22951994,22962263,22988023,22971258,22978768,22986967,22972967,22962205,22987386,22952647,22983097,22993760,22947229,22970781,22948359,22977690,22983719,22988442,22956294,22946215,22966535,22969114,22948778,22960119,22979840,22956893,22966954,22957965,22965495,22974464,22984807,22955879,22954733,22987965,22972909,22958435,22959466,22948301,22971837,22951517,22949357,22964423,22976125,22989095,22955821,22986909,22969693,22954791,22965437,22947287,22960538,22962682,22964848,22989037,22989504,22992666,22971895,22961133,22975069,22978285,22982679,22993335,22963748,22980445,22946157,22968637,22958989,22991133,22969751,22952589,22977271,22990528,22961606,22993277,22947712,22992189,22966477,22977213,22982010,22973981,22961191,22978343,22967565,22955204,22963277,22951575,22967623,22976183,22991191,22950487,22959047,22976596,22950906,22946634,22965914,22973386,22970839,22964365,22975546,22963335,22990103,22992247,22984144,22970176,22949415,22949834,22986314,22990045,22982621,22984749,22960061],"length":1,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[15312452,15316740,15311364,15328580,15299636,15300660,15315652,15288900,15293188,15289972,15310308,15319956,15322116,15295332,15301732,15321028,15324292,15292100,15309236,15302804,15326420,15332804,15333860,15334948,15303876,15307108,15294260,15327508,15287828,15317796,15325332,15291028,15314580,15297492,15296404,15308148,15318884,15298564,15330708,15304948,15306036,15323204,15313508,15329636,15331716],"length":1,"stats":{"Line":0}},{"line":51,"address":[15299114,15317191,15335504,15293738,15329031,15294810,15318340,15323655,15316109,15333354,15313959,15325789,15334311,15311821,15313002,15322672,15324742,15320512,15311920,15315031,15332173,15321584,15306592,15308599,15302183,15303251,15310858,15322573,15324838,15316208,15295783,15308698,15291578,15309693,15309792,15302282,15288378,15326871,15331245,15289456,15292650,15321485,15294711,15312903,15323754,15326970,15327959,15328058,15305492,15315130,15304327,15300080,15297939,15301111,15291479,15305393,15310759,15306493,15332272,15288279,15296948,15296849,15314058,15329130,15331149,15300176,15289357,15330087,15298038,15299015,15307655,15304426,15293639,15325888,15334410,15335405,15292551,15307559,15319434,15317290,15303350,15318241,15330186,15295882,15333255,15290423,15290522,15301210,15319335,15320413],"length":1,"stats":{"Line":0}},{"line":52,"address":[22962864,22983278,22980024,22952106,22989613,22954250,22978880,22965032,22981112,22968160,22961718,22984328,22987568,22972426,22989683,22976708,22991792,22952176,22957552,22967066,22981040,22986496,22990712,22960720,22962794,22983206,22987498,22948960,22956406,22973568,22951088,22977802,22985338,22988554,22971370,22992848,22993872,22974576,22960650,22975658,22958614,22946816,22954320,22978952,22950016,22986426,22956478,22958544,22955386,22974648,22966095,22976778,22947824,22963930,22967136,22969226,22971440,22984256,22992778,22955316,22948890,22951018,22963860,22966023,22969296,22970288,22972496,22947896,22988624,22990640,22991722,22973498,22993944,22959578,22949946,22979952,22957482,22977872,22953178,22985408,22968232,22946746,22961790,22964960,22975728,22970360,22959648,22982122,22953248,22982192],"length":1,"stats":{"Line":0}},{"line":57,"address":[15227504,15227648,15229616,15229776,15231104,15227216,15226096,15229472,15231696,15231984,15231408,15228928,15226784,15228512,15226528,15226240,15230960,15228224,15232272,15227952,15228784,15229328,15230224,15230832,15231552,15230384,15231840,15232416,15226640,15227072,15232128,15227792,15231248,15226928,15229072,15228064,15230080,15229232,15227360,15228640,15226384,15229920,15228368,15230688,15230528],"length":1,"stats":{"Line":0}},{"line":58,"address":[15305286,15305442,15301826,15301541,15302821,15303122,15303538,15305586,15304082,15303394,15302258,15304373,15304677,15305859,15306005,15301282,15306307,15302978,15304981,15301395,15306450,15306738,15306882,15303830,15301682,15306594,15303986,15303267,15302706,15303685,15305139,15305715,15307170,15301971,15302549,15306166,15301139,15304534,15300994,15307026,15302402,15300851,15302117,15304227,15304834],"length":1,"stats":{"Line":0}},{"line":59,"address":[15294932,15295927,15296495,15296782,15295655,15297329,15298246,15294241,15295214,15293953,15296223,15298543,15298961,15295073,15299273,15299700,15300271,15298817,15299839,15299551,15295359,15295807,15297641,15296084,15299414,15294783,15296644,15297188,15297479,15297935,15299111,15294502,15297783,15298393,15298668,15294383,15294638,15296369,15296937,15297083,15299983,15294095,15298087,15295503,15300127],"length":1,"stats":{"Line":0}},{"line":60,"address":[15437932,15438075,15433307,15435863,15438795,15433607,15434172,15437067,15433883,15433449,15434747,15434883,15435575,15435161,15436459,15435299,15436764,15436911,15435705,15435996,15432619,15437189,15436604,15438363,15432884,15437791,15433020,15433155,15434027,15434444,15435019,15435455,15437351,15434306,15437628,15434601,15438217,15437495,15438507,15432487,15433731,15436159,15432775,15436300,15438651],"length":1,"stats":{"Line":0}},{"line":73,"address":[15225776],"length":1,"stats":{"Line":0}},{"line":75,"address":[15232563],"length":1,"stats":{"Line":0}},{"line":76,"address":[15338499],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline.rs"],"content":"use crate::domain::value_objects::offline::SyncStatus;\nuse crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct OfflineAction {\r\n    pub id: i64,\r\n    pub user_pubkey: String,\r\n    pub action_type: String,\r\n    pub target_id: Option<String>,\r\n    pub action_data: String,\r\n    pub local_id: String,\r\n    pub remote_id: Option<String>,\r\n    pub is_synced: bool,\r\n    pub created_at: i64,\r\n    pub synced_at: Option<i64>,\r\n    #[serde(skip_serializing_if = \"Option::is_none\")]\r\n    pub error_message: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SaveOfflineActionRequest {\r\n    pub user_pubkey: String,\r\n    pub action_type: String,\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub data: String,\r\n}\r\n\r\nimpl Validate for SaveOfflineActionRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.user_pubkey.is_empty() {\r\n            return Err(\"User pubkey is required\".to_string());\r\n        }\r\n        if self.action_type.is_empty() {\r\n            return Err(\"Action type is required\".to_string());\r\n        }\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.data.is_empty() {\r\n            return Err(\"Data is required\".to_string());\r\n        }\r\n        if self.data.len() > 200_000 {\r\n            return Err(\"Data is too large (max 200KB)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SaveOfflineActionResponse {\r\n    pub local_id: String,\r\n    pub action: OfflineAction,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct GetOfflineActionsRequest {\r\n    pub user_pubkey: Option<String>,\r\n    pub is_synced: Option<bool>,\r\n    pub limit: Option<i32>,\r\n}\r\n\r\nimpl Validate for GetOfflineActionsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if let Some(limit) = self.limit {\r\n            if limit <= 0 || limit > 1000 {\r\n                return Err(\"Limit must be between 1 and 1000\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SyncOfflineActionsRequest {\r\n    pub user_pubkey: String,\r\n}\r\n\r\nimpl Validate for SyncOfflineActionsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.user_pubkey.is_empty() {\r\n            return Err(\"User pubkey is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct SyncOfflineActionsResponse {\r\n    pub synced_count: i32,\r\n    pub failed_count: i32,\r\n    pub pending_count: i32,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CacheTypeStatus {\n    pub cache_type: String,\n    pub item_count: i64,\n    pub last_synced_at: Option<i64>,\n    pub is_stale: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub metadata: Option<Value>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_version: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub blob_hash: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payload_bytes: Option<i64>,\n}\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct CacheStatusResponse {\n    pub total_items: i64,\n    pub stale_items: i64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct ListSyncQueueItemsRequest {\n    pub limit: Option<i32>,\n}\n\nimpl Validate for ListSyncQueueItemsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if let Some(limit) = self.limit {\n            if !(1..=200).contains(&limit) {\n                return Err(\"Limit must be between 1 and 200\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncQueueItemResponse {\n    pub id: i64,\n    pub action_type: String,\n    pub status: String,\n    pub retry_count: i32,\n    pub max_retries: i32,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub synced_at: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error_message: Option<String>,\n    pub payload: Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddToSyncQueueRequest {\n    pub action_type: String,\r\n    pub payload: serde_json::Value,\r\n    pub priority: Option<i32>,\r\n}\r\n\r\nimpl Validate for AddToSyncQueueRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.action_type.is_empty() {\r\n            return Err(\"Action type is required\".to_string());\r\n        }\r\n        if let Some(priority) = self.priority {\r\n            if !(0..=10).contains(&priority) {\r\n                return Err(\"Priority must be between 0 and 10\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UpdateCacheMetadataRequest {\n    pub cache_key: String,\n    pub cache_type: String,\n    pub metadata: Option<serde_json::Value>,\n    pub expiry_seconds: Option<i64>,\n    pub is_stale: Option<bool>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_version: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub blob_hash: Option<String>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub payload_bytes: Option<i64>,\n}\n\r\nimpl Validate for UpdateCacheMetadataRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.cache_key.is_empty() {\r\n            return Err(\"Cache key is required\".to_string());\r\n        }\r\n        if self.cache_type.is_empty() {\r\n            return Err(\"Cache type is required\".to_string());\r\n        }\r\n        if let Some(ttl) = self.expiry_seconds {\r\n            if ttl <= 0 {\r\n                return Err(\"Expiry seconds must be positive\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct OptimisticUpdateRequest {\r\n    pub entity_type: String,\r\n    pub entity_id: String,\r\n    pub original_data: Option<String>,\r\n    pub updated_data: String,\r\n}\r\n\r\nimpl Validate for OptimisticUpdateRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.updated_data.is_empty() {\r\n            return Err(\"Updated data is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct UpdateSyncStatusRequest {\n    pub entity_type: String,\n    pub entity_id: String,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n\nimpl Validate for UpdateSyncStatusRequest {\n    fn validate(&self) -> Result<(), String> {\r\n        if self.entity_type.is_empty() {\r\n            return Err(\"Entity type is required\".to_string());\r\n        }\r\n        if self.entity_id.is_empty() {\r\n            return Err(\"Entity ID is required\".to_string());\r\n        }\r\n        if self.sync_status.is_empty() {\n            return Err(\"Sync status is required\".to_string());\n        }\n        let status = self.sync_status.as_str();\n        let parsed = SyncStatus::from(status);\n        let legacy_allowed = matches!(status, \"syncing\" | \"synced\");\n        if matches!(parsed, SyncStatus::Unknown(_)) && !legacy_allowed {\n            return Err(\"Invalid sync status. Supported values include pending, sent_to_nostr, sent_to_p2p, fully_synced, failed, conflict, invalid:<reason>\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OfflineRetryMetricsResponse {\n    pub total_success: u64,\n    pub total_failure: u64,\n    pub consecutive_failure: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n    pub last_outcome: Option<String>,\n    pub last_job_id: Option<String>,\n    pub last_job_reason: Option<String>,\n    pub last_trigger: Option<String>,\n    pub last_user_pubkey: Option<String>,\n    pub last_retry_count: Option<i32>,\n    pub last_max_retries: Option<i32>,\n    pub last_backoff_ms: Option<u64>,\n    pub last_duration_ms: Option<u64>,\n    pub last_success_count: Option<i32>,\n    pub last_failure_count: Option<i32>,\n    pub last_timestamp_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct RecordOfflineRetryOutcomeRequest {\n    pub job_id: Option<String>,\n    pub status: String,\n    pub job_reason: Option<String>,\n    pub trigger: Option<String>,\n    pub user_pubkey: Option<String>,\n    pub retry_count: Option<i32>,\n    pub max_retries: Option<i32>,\n    pub backoff_ms: Option<u64>,\n    pub duration_ms: Option<u64>,\n    pub success_count: Option<i32>,\n    pub failure_count: Option<i32>,\n    pub timestamp_ms: Option<u64>,\n}\n\nimpl Validate for RecordOfflineRetryOutcomeRequest {\n    fn validate(&self) -> Result<(), String> {\n        match self.status.as_str() {\n            \"success\" | \"failure\" => {}\n            other => return Err(format!(\"Unsupported status: {other}\")),\n        }\n        if let Some(value) = self.retry_count {\n            if value < 0 {\n                return Err(\"retry_count must be >= 0\".to_string());\n            }\n        }\n        if let Some(value) = self.max_retries {\n            if value <= 0 {\n                return Err(\"max_retries must be > 0\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":34,"address":[23888480],"length":1,"stats":{"Line":0}},{"line":35,"address":[23923638],"length":1,"stats":{"Line":0}},{"line":36,"address":[23881619],"length":1,"stats":{"Line":0}},{"line":38,"address":[23807012],"length":1,"stats":{"Line":0}},{"line":39,"address":[23807106],"length":1,"stats":{"Line":0}},{"line":41,"address":[23888611],"length":1,"stats":{"Line":0}},{"line":42,"address":[23925473],"length":1,"stats":{"Line":0}},{"line":44,"address":[15214594],"length":1,"stats":{"Line":0}},{"line":45,"address":[23925552],"length":1,"stats":{"Line":0}},{"line":47,"address":[23923889],"length":1,"stats":{"Line":0}},{"line":48,"address":[18061651],"length":1,"stats":{"Line":0}},{"line":50,"address":[15214752],"length":1,"stats":{"Line":0}},{"line":51,"address":[23814219],"length":1,"stats":{"Line":0}},{"line":53,"address":[23814204],"length":1,"stats":{"Line":0}},{"line":73,"address":[23924160],"length":1,"stats":{"Line":0}},{"line":74,"address":[18061848],"length":1,"stats":{"Line":0}},{"line":75,"address":[23924209,23924240],"length":1,"stats":{"Line":0}},{"line":76,"address":[18061911],"length":1,"stats":{"Line":0}},{"line":79,"address":[23814365],"length":1,"stats":{"Line":0}},{"line":90,"address":[23920384],"length":1,"stats":{"Line":0}},{"line":91,"address":[15215134],"length":1,"stats":{"Line":0}},{"line":92,"address":[23814523],"length":1,"stats":{"Line":0}},{"line":94,"address":[23926012],"length":1,"stats":{"Line":0}},{"line":138,"address":[18062112],"length":1,"stats":{"Line":1}},{"line":139,"address":[15215256],"length":1,"stats":{"Line":1}},{"line":140,"address":[23889372],"length":1,"stats":{"Line":1}},{"line":141,"address":[24020968],"length":1,"stats":{"Line":0}},{"line":144,"address":[23924521],"length":1,"stats":{"Line":1}},{"line":173,"address":[23882560],"length":1,"stats":{"Line":1}},{"line":174,"address":[23882590],"length":1,"stats":{"Line":1}},{"line":175,"address":[23920726],"length":1,"stats":{"Line":0}},{"line":177,"address":[23821771,23821842],"length":1,"stats":{"Line":2}},{"line":178,"address":[23882681],"length":1,"stats":{"Line":1}},{"line":179,"address":[23808133],"length":1,"stats":{"Line":0}},{"line":182,"address":[23920822],"length":1,"stats":{"Line":1}},{"line":203,"address":[23814992],"length":1,"stats":{"Line":1}},{"line":204,"address":[24021312],"length":1,"stats":{"Line":1}},{"line":205,"address":[23889793],"length":1,"stats":{"Line":0}},{"line":207,"address":[15215682],"length":1,"stats":{"Line":1}},{"line":208,"address":[23808345],"length":1,"stats":{"Line":0}},{"line":210,"address":[24021478,24021409],"length":1,"stats":{"Line":2}},{"line":211,"address":[24021487],"length":1,"stats":{"Line":1}},{"line":212,"address":[15215865],"length":1,"stats":{"Line":0}},{"line":215,"address":[23883018],"length":1,"stats":{"Line":1}},{"line":229,"address":[18062816],"length":1,"stats":{"Line":0}},{"line":230,"address":[23921246],"length":1,"stats":{"Line":0}},{"line":231,"address":[23883162],"length":1,"stats":{"Line":0}},{"line":233,"address":[24021627],"length":1,"stats":{"Line":0}},{"line":234,"address":[23926936],"length":1,"stats":{"Line":0}},{"line":236,"address":[23926921],"length":1,"stats":{"Line":0}},{"line":237,"address":[23815508],"length":1,"stats":{"Line":0}},{"line":239,"address":[23808709],"length":1,"stats":{"Line":0}},{"line":253,"address":[24021872,24022553],"length":1,"stats":{"Line":0}},{"line":254,"address":[23815622],"length":1,"stats":{"Line":0}},{"line":255,"address":[23927155],"length":1,"stats":{"Line":0}},{"line":257,"address":[18063156],"length":1,"stats":{"Line":0}},{"line":258,"address":[23890470],"length":1,"stats":{"Line":0}},{"line":260,"address":[18063235],"length":1,"stats":{"Line":0}},{"line":261,"address":[23815902],"length":1,"stats":{"Line":0}},{"line":263,"address":[15216438],"length":1,"stats":{"Line":0}},{"line":264,"address":[23925708],"length":1,"stats":{"Line":0}},{"line":265,"address":[23809237,23809095],"length":1,"stats":{"Line":0}},{"line":266,"address":[23823059],"length":1,"stats":{"Line":0}},{"line":267,"address":[23816167],"length":1,"stats":{"Line":0}},{"line":269,"address":[23823114],"length":1,"stats":{"Line":0}},{"line":313,"address":[23809504],"length":1,"stats":{"Line":0}},{"line":314,"address":[23927828],"length":1,"stats":{"Line":0}},{"line":315,"address":[24022637],"length":1,"stats":{"Line":0}},{"line":316,"address":[23927942],"length":1,"stats":{"Line":0}},{"line":318,"address":[24022695,24022892],"length":1,"stats":{"Line":0}},{"line":319,"address":[23928121],"length":1,"stats":{"Line":0}},{"line":320,"address":[23891376],"length":1,"stats":{"Line":0}},{"line":323,"address":[23823688,23823602],"length":1,"stats":{"Line":0}},{"line":324,"address":[23809941],"length":1,"stats":{"Line":0}},{"line":325,"address":[23928257],"length":1,"stats":{"Line":0}},{"line":328,"address":[23922655],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":76},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OfflineActionResponse {\n    pub id: String,\n    pub action_type: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub payload: serde_json::Value,\n    pub created_at: i64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p.rs"],"content":"use crate::application::services::p2p_service::{\n    ConnectionStatus as ServiceConnectionStatus, PeerStatus as ServicePeerStatus,\n};\nuse crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ConnectionStatusResponse {\n    Connected,\n    Connecting,\n    Disconnected,\n    Error,\n}\n\nimpl From<ServiceConnectionStatus> for ConnectionStatusResponse {\n    fn from(value: ServiceConnectionStatus) -> Self {\n        match value {\n            ServiceConnectionStatus::Connected => ConnectionStatusResponse::Connected,\n            ServiceConnectionStatus::Connecting => ConnectionStatusResponse::Connecting,\n            ServiceConnectionStatus::Disconnected => ConnectionStatusResponse::Disconnected,\n            ServiceConnectionStatus::Error => ConnectionStatusResponse::Error,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeerStatusResponse {\n    pub node_id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\nimpl From<ServicePeerStatus> for PeerStatusResponse {\n    fn from(value: ServicePeerStatus) -> Self {\n        Self {\n            node_id: value.node_id,\n            address: value.address,\n            connected_at: value.connected_at,\n            last_seen: value.last_seen,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub connected: bool,\n    pub connection_status: ConnectionStatusResponse,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicStatus>,\n    pub peer_count: usize,\n    pub peers: Vec<PeerStatusResponse>,\n    pub metrics_summary: GossipMetricsSummaryResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStatus {\n    pub topic_id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinTopicRequest {\n    pub topic_id: String,\n    pub initial_peers: Vec<String>,\n}\n\nimpl Validate for JoinTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        // 初期ピアのフォーマット検証は省略（実際には必要に応じて追加）\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LeaveTopicRequest {\n    pub topic_id: String,\n}\n\nimpl Validate for LeaveTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BroadcastRequest {\n    pub topic_id: String,\n    pub content: String,\n}\n\nimpl Validate for BroadcastRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        if self.content.is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if self.content.len() > 50000 {\n            return Err(\"Content is too large (max 50000 bytes)\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NodeAddressResponse {\n    pub addresses: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfigResponse {\n    pub mode: String,\n    pub nodes: Vec<String>,\n    pub effective_nodes: Vec<String>,\n    pub source: String,\n    pub env_locked: bool,\n    #[serde(default)]\n    pub cli_nodes: Vec<String>,\n    #[serde(default)]\n    pub cli_updated_at_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RelayStatusResponse {\n    pub url: String,\n    pub status: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetailsResponse,\n    pub leave_details: GossipMetricDetailsResponse,\n    pub broadcast_details: GossipMetricDetailsResponse,\n    pub receive_details: GossipMetricDetailsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricDetailsResponse {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MainlineMetricsResponse {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n    pub bootstrap: BootstrapMetricsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PMetricsResponse {\n    pub gossip: GossipMetricsResponse,\n    pub mainline: MainlineMetricsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapMetricsResponse {\n    pub env_uses: u64,\n    pub user_uses: u64,\n    pub bundle_uses: u64,\n    pub fallback_uses: u64,\n    pub last_source: Option<String>,\n    pub last_applied_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummaryResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n","traces":[{"line":17,"address":[15270400],"length":1,"stats":{"Line":0}},{"line":18,"address":[15171463],"length":1,"stats":{"Line":0}},{"line":19,"address":[15164520],"length":1,"stats":{"Line":0}},{"line":20,"address":[15239263],"length":1,"stats":{"Line":0}},{"line":21,"address":[15239270],"length":1,"stats":{"Line":0}},{"line":22,"address":[15370829],"length":1,"stats":{"Line":0}},{"line":36,"address":[15232368],"length":1,"stats":{"Line":0}},{"line":38,"address":[22932755],"length":1,"stats":{"Line":0}},{"line":39,"address":[15232397],"length":1,"stats":{"Line":0}},{"line":40,"address":[15270536],"length":1,"stats":{"Line":0}},{"line":41,"address":[15164620],"length":1,"stats":{"Line":0}},{"line":72,"address":[15232496],"length":1,"stats":{"Line":0}},{"line":73,"address":[15232526],"length":1,"stats":{"Line":0}},{"line":74,"address":[23093707],"length":1,"stats":{"Line":0}},{"line":77,"address":[15171708],"length":1,"stats":{"Line":0}},{"line":87,"address":[15171792],"length":1,"stats":{"Line":0}},{"line":88,"address":[15158062],"length":1,"stats":{"Line":0}},{"line":89,"address":[15239611],"length":1,"stats":{"Line":0}},{"line":91,"address":[15276364],"length":1,"stats":{"Line":0}},{"line":102,"address":[15164944],"length":1,"stats":{"Line":0}},{"line":103,"address":[15164974],"length":1,"stats":{"Line":0}},{"line":104,"address":[23093962],"length":1,"stats":{"Line":0}},{"line":106,"address":[15171963],"length":1,"stats":{"Line":0}},{"line":107,"address":[23094044],"length":1,"stats":{"Line":0}},{"line":109,"address":[15232873],"length":1,"stats":{"Line":0}},{"line":110,"address":[15165160],"length":1,"stats":{"Line":0}},{"line":112,"address":[15165145],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub node_id: String,\n    pub connected_peers: Vec<String>,\n    pub subscribed_topics: Vec<String>,\n    pub stats: P2PStats,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStats {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub bytes_sent: u64,\n    pub bytes_received: u64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","post_dto.rs"],"content":"use super::{PaginationRequest, Validate};\nuse serde::{Deserialize, Serialize};\n\n// レスポンスDTO\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PostResponse {\n    pub id: String,\n    pub content: String,\n    pub author_pubkey: String,\n    pub author_npub: String,\n    pub topic_id: String,\n    pub scope: Option<String>,\n    pub epoch: Option<i64>,\n    pub is_encrypted: bool,\n    pub created_at: i64,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: u32,\n    pub is_synced: bool,\n}\n\n// リクエストDTO\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreatePostRequest {\n    pub content: String,\n    pub topic_id: String,\n    pub media_urls: Option<Vec<String>>,\n    pub scope: Option<String>,\n}\n\nimpl Validate for CreatePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.content.trim().is_empty() {\n            return Err(\"投稿内容が空です\".to_string());\n        }\n        if self.content.len() > 5000 {\n            return Err(\"投稿内容が長すぎます（最大5000文字）\".to_string());\n        }\n        if self.topic_id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        if let Some(scope) = &self.scope {\n            let normalized = scope.trim();\n            if !normalized.is_empty()\n                && normalized != \"public\"\n                && normalized != \"friend_plus\"\n                && normalized != \"friend\"\n                && normalized != \"invite\"\n            {\n                return Err(\"スコープが不正です\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetPostsRequest {\n    pub topic_id: Option<String>,\n    pub author_pubkey: Option<String>,\n    pub pagination: Option<PaginationRequest>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DeletePostRequest {\n    pub post_id: String,\n    pub reason: Option<String>,\n}\n\nimpl Validate for DeletePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ReactToPostRequest {\n    pub post_id: String,\n    pub reaction: String,\n}\n\nimpl Validate for ReactToPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        if self.reaction.trim().is_empty() {\n            return Err(\"リアクションが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BookmarkPostRequest {\n    pub post_id: String,\n}\n\nimpl Validate for BookmarkPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListTrendingPostsRequest {\n    pub topic_ids: Vec<String>,\n    pub per_topic: Option<u32>,\n}\n\nimpl Validate for ListTrendingPostsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_ids.is_empty() {\n            return Err(\"トピックIDを少なくとも1つ指定してください\".to_string());\n        }\n        if let Some(per_topic) = self.per_topic {\n            if per_topic == 0 {\n                return Err(\"トピックごとの取得件数は1以上を指定してください\".to_string());\n            }\n            if per_topic > 20 {\n                return Err(\"トピックごとの取得件数は最大20件までです\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TrendingTopicPostsResponse {\n    pub topic_id: String,\n    pub topic_name: String,\n    pub relative_rank: u32,\n    pub posts: Vec<PostResponse>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListTrendingPostsResponse {\n    pub generated_at: i64,\n    pub topics: Vec<TrendingTopicPostsResponse>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListFollowingFeedRequest {\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub include_reactions: Option<bool>,\n}\n\nimpl Validate for ListFollowingFeedRequest {\n    fn validate(&self) -> Result<(), String> {\n        if let Some(limit) = self.limit {\n            if limit == 0 {\n                return Err(\"取得件数は1以上で指定してください\".to_string());\n            }\n            if limit > 100 {\n                return Err(\"取得件数は最大100件までです\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct FollowingFeedPageResponse {\n    pub items: Vec<PostResponse>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub server_time: i64,\n}\n","traces":[{"line":32,"address":[24741776],"length":1,"stats":{"Line":0}},{"line":33,"address":[24674054],"length":1,"stats":{"Line":0}},{"line":34,"address":[24873417],"length":1,"stats":{"Line":0}},{"line":36,"address":[18914634],"length":1,"stats":{"Line":0}},{"line":37,"address":[24660446],"length":1,"stats":{"Line":0}},{"line":39,"address":[24741929],"length":1,"stats":{"Line":0}},{"line":40,"address":[24773259],"length":1,"stats":{"Line":0}},{"line":42,"address":[24773214,24773323],"length":1,"stats":{"Line":0}},{"line":43,"address":[24735219],"length":1,"stats":{"Line":0}},{"line":44,"address":[24667437],"length":1,"stats":{"Line":0}},{"line":45,"address":[19323593],"length":1,"stats":{"Line":0}},{"line":46,"address":[24667505],"length":1,"stats":{"Line":0}},{"line":47,"address":[24773449],"length":1,"stats":{"Line":0}},{"line":48,"address":[24777409],"length":1,"stats":{"Line":0}},{"line":50,"address":[24674553],"length":1,"stats":{"Line":0}},{"line":53,"address":[24773383],"length":1,"stats":{"Line":0}},{"line":71,"address":[24742400],"length":1,"stats":{"Line":0}},{"line":72,"address":[18915214],"length":1,"stats":{"Line":0}},{"line":73,"address":[24735553],"length":1,"stats":{"Line":0}},{"line":75,"address":[24735538],"length":1,"stats":{"Line":0}},{"line":86,"address":[19323936],"length":1,"stats":{"Line":0}},{"line":87,"address":[24773776],"length":1,"stats":{"Line":0}},{"line":88,"address":[24779433],"length":1,"stats":{"Line":0}},{"line":90,"address":[24779396],"length":1,"stats":{"Line":0}},{"line":91,"address":[24674981],"length":1,"stats":{"Line":0}},{"line":93,"address":[24735798],"length":1,"stats":{"Line":0}},{"line":103,"address":[18915600],"length":1,"stats":{"Line":0}},{"line":104,"address":[24874398],"length":1,"stats":{"Line":0}},{"line":105,"address":[24675137],"length":1,"stats":{"Line":0}},{"line":107,"address":[24675122],"length":1,"stats":{"Line":0}},{"line":118,"address":[24668240],"length":1,"stats":{"Line":0}},{"line":119,"address":[24774192],"length":1,"stats":{"Line":0}},{"line":120,"address":[24743034],"length":1,"stats":{"Line":0}},{"line":122,"address":[24675335,24675263],"length":1,"stats":{"Line":0}},{"line":123,"address":[24743106],"length":1,"stats":{"Line":0}},{"line":124,"address":[24779901],"length":1,"stats":{"Line":0}},{"line":126,"address":[24661673],"length":1,"stats":{"Line":0}},{"line":127,"address":[24668474],"length":1,"stats":{"Line":0}},{"line":130,"address":[24874670],"length":1,"stats":{"Line":0}},{"line":156,"address":[24743280],"length":1,"stats":{"Line":0}},{"line":157,"address":[24675544],"length":1,"stats":{"Line":0}},{"line":158,"address":[24780097],"length":1,"stats":{"Line":0}},{"line":159,"address":[24668620],"length":1,"stats":{"Line":0}},{"line":161,"address":[24874968],"length":1,"stats":{"Line":0}},{"line":162,"address":[24743433],"length":1,"stats":{"Line":0}},{"line":165,"address":[24780109],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","profile_avatar_dto.rs"],"content":"use base64::Engine as _;\nuse base64::engine::general_purpose::STANDARD as BASE64_STANDARD;\nuse serde::{Deserialize, Serialize};\n\nuse crate::application::services::ProfileAvatarFetchResult;\nuse crate::domain::entities::{ProfileAvatarAccessLevel, ProfileAvatarDocEntry};\n\n#[derive(Debug, Deserialize)]\npub struct UploadProfileAvatarRequest {\n    pub npub: String,\n    pub bytes: Vec<u8>,\n    pub format: String,\n    pub access_level: ProfileAvatarAccessLevel,\n}\n\n#[derive(Debug, Serialize)]\npub struct UploadProfileAvatarResponse {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub doc_version: u64,\n    pub updated_at: String,\n    pub content_sha256: String,\n}\n\nimpl From<ProfileAvatarDocEntry> for UploadProfileAvatarResponse {\n    fn from(value: ProfileAvatarDocEntry) -> Self {\n        Self {\n            npub: value.npub,\n            blob_hash: value.blob_hash,\n            format: value.format,\n            size_bytes: value.size_bytes,\n            access_level: value.access_level,\n            share_ticket: value.share_ticket,\n            doc_version: value.version,\n            updated_at: value.updated_at.to_rfc3339(),\n            content_sha256: value.content_sha256,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct FetchProfileAvatarRequest {\n    pub npub: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct FetchProfileAvatarResponse {\n    pub npub: String,\n    pub blob_hash: String,\n    pub format: String,\n    pub size_bytes: u64,\n    pub access_level: ProfileAvatarAccessLevel,\n    pub share_ticket: String,\n    pub doc_version: u64,\n    pub updated_at: String,\n    pub content_sha256: String,\n    pub data_base64: String,\n}\n\nimpl From<ProfileAvatarFetchResult> for FetchProfileAvatarResponse {\n    fn from(value: ProfileAvatarFetchResult) -> Self {\n        let metadata = value.metadata;\n        Self {\n            npub: metadata.npub,\n            blob_hash: metadata.blob_hash,\n            format: metadata.format,\n            size_bytes: metadata.size_bytes,\n            access_level: metadata.access_level,\n            share_ticket: metadata.share_ticket,\n            doc_version: metadata.version,\n            updated_at: metadata.updated_at.to_rfc3339(),\n            content_sha256: metadata.content_sha256,\n            data_base64: BASE64_STANDARD.encode(value.bytes),\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\npub struct ProfileAvatarSyncRequest {\n    pub npub: String,\n    pub known_doc_version: Option<u64>,\n    #[serde(default)]\n    pub source: Option<String>,\n    #[serde(default)]\n    pub requested_at: Option<String>,\n    #[serde(default)]\n    pub retry_count: Option<u32>,\n    #[serde(default)]\n    pub job_id: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ProfileAvatarSyncResponse {\n    pub npub: String,\n    pub current_version: Option<u64>,\n    pub updated: bool,\n    pub avatar: Option<FetchProfileAvatarResponse>,\n}\n","traces":[{"line":30,"address":[21525934,21525376],"length":1,"stats":{"Line":0}},{"line":32,"address":[21408757],"length":1,"stats":{"Line":0}},{"line":33,"address":[21527062],"length":1,"stats":{"Line":0}},{"line":34,"address":[23964424],"length":1,"stats":{"Line":0}},{"line":35,"address":[21483405],"length":1,"stats":{"Line":0}},{"line":36,"address":[21527113],"length":1,"stats":{"Line":0}},{"line":37,"address":[15663139],"length":1,"stats":{"Line":0}},{"line":38,"address":[21621931],"length":1,"stats":{"Line":0}},{"line":39,"address":[21525511],"length":1,"stats":{"Line":0}},{"line":40,"address":[21622036],"length":1,"stats":{"Line":0}},{"line":65,"address":[21484048,21484908,21485089],"length":1,"stats":{"Line":0}},{"line":66,"address":[21522181],"length":1,"stats":{"Line":0}},{"line":68,"address":[21484124],"length":1,"stats":{"Line":0}},{"line":69,"address":[21522262],"length":1,"stats":{"Line":0}},{"line":70,"address":[21526224],"length":1,"stats":{"Line":0}},{"line":71,"address":[21416394],"length":1,"stats":{"Line":0}},{"line":72,"address":[21622695],"length":1,"stats":{"Line":0}},{"line":73,"address":[21527922],"length":1,"stats":{"Line":0}},{"line":74,"address":[21527951],"length":1,"stats":{"Line":0}},{"line":75,"address":[23965308],"length":1,"stats":{"Line":0}},{"line":76,"address":[21528039],"length":1,"stats":{"Line":0}},{"line":77,"address":[21416575],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","topic_dto.rs"],"content":"use super::{Validate, offline::OfflineAction};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n// レスポンスDTO\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct TopicResponse {\r\n    pub id: String,\r\n    pub name: String,\r\n    pub description: String,\r\n    pub image_url: Option<String>,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub is_joined: bool,\r\n    pub visibility: String,\r\n    pub created_at: i64,\r\n    pub updated_at: i64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct PendingTopicResponse {\r\n    pub pending_id: String,\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub status: String,\r\n    pub offline_action_id: String,\r\n    pub synced_topic_id: Option<String>,\r\n    pub error_message: Option<String>,\r\n    pub created_at: i64,\r\n    pub updated_at: i64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct EnqueueTopicCreationRequest {\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub visibility: Option<String>,\r\n}\r\n\r\nimpl Validate for EnqueueTopicCreationRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.name.trim().is_empty() {\r\n            return Err(\"トピック名が必要です\".to_string());\r\n        }\r\n        if self.name.len() > 100 {\r\n            return Err(\"トピック名は100文字以内で入力してください\".to_string());\r\n        }\r\n        if let Some(description) = &self.description {\r\n            if description.len() > 500 {\r\n                return Err(\"説明は500文字以内で入力してください\".to_string());\r\n            }\r\n        }\r\n        if let Some(visibility) = &self.visibility {\r\n            if visibility != \"public\" && visibility != \"private\" {\r\n                return Err(\"visibility must be 'public' or 'private'\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct EnqueueTopicCreationResponse {\r\n    pub pending_topic: PendingTopicResponse,\r\n    pub offline_action: OfflineAction,\r\n}\r\n\r\n// リクエストDTO\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct CreateTopicRequest {\r\n    pub name: String,\r\n    pub description: String,\r\n    pub image_url: Option<String>,\r\n    pub visibility: Option<String>,\r\n}\r\n\r\nimpl Validate for CreateTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.name.trim().is_empty() {\r\n            return Err(\"トピック名が必要です\".to_string());\r\n        }\r\n        if self.name.len() > 100 {\r\n            return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\r\n        }\r\n        if self.description.len() > 500 {\r\n            return Err(\"説明が長すぎます（最大500文字）\".to_string());\r\n        }\r\n\r\n        // URLのバリデーション（もし提供されている場合）\r\n        if let Some(visibility) = &self.visibility {\r\n            if visibility != \"public\" && visibility != \"private\" {\r\n                return Err(\"visibility must be 'public' or 'private'\".to_string());\r\n            }\r\n        }\r\n\r\n        if let Some(url) = &self.image_url {\r\n            if !url.is_empty() && !url.starts_with(\"http\") {\r\n                return Err(\"無効な画像URLです\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct UpdateTopicRequest {\r\n    pub id: String,\r\n    pub name: Option<String>,\r\n    pub description: Option<String>,\r\n    pub image_url: Option<String>,\r\n}\r\n\r\nimpl Validate for UpdateTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n\r\n        if let Some(name) = &self.name {\r\n            if name.len() > 100 {\r\n                return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\r\n            }\r\n        }\r\n\r\n        if let Some(desc) = &self.description {\r\n            if desc.len() > 500 {\r\n                return Err(\"説明が長すぎます（最大500文字）\".to_string());\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct JoinTopicRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for JoinTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct GetTopicStatsRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for GetTopicStatsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct DeleteTopicRequest {\r\n    pub id: String,\r\n}\r\n\r\nimpl Validate for DeleteTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.id.trim().is_empty() {\r\n            return Err(\"トピックIDが必要です\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct MarkPendingTopicSyncedRequest {\r\n    pub pending_id: String,\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for MarkPendingTopicSyncedRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.pending_id.trim().is_empty() {\r\n            return Err(\"pending_id is required\".to_string());\r\n        }\r\n        if self.topic_id.trim().is_empty() {\r\n            return Err(\"topic_id is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct MarkPendingTopicFailedRequest {\r\n    pub pending_id: String,\r\n    pub error_message: Option<String>,\r\n}\r\n\r\nimpl Validate for MarkPendingTopicFailedRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.pending_id.trim().is_empty() {\r\n            return Err(\"pending_id is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct TopicStatsResponse {\r\n    pub topic_id: String,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub active_users_24h: u32,\r\n    pub trending_score: f64,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Default)]\r\npub struct ListTrendingTopicsRequest {\r\n    pub limit: Option<u32>,\r\n}\r\n\r\nimpl Validate for ListTrendingTopicsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if let Some(limit) = self.limit {\r\n            if limit == 0 {\r\n                return Err(\"取得件数は1以上で指定してください\".to_string());\r\n            }\r\n            if limit > 100 {\r\n                return Err(\"取得件数は最大100件までです\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\npub struct TrendingTopicDto {\r\n    pub topic_id: String,\r\n    pub name: String,\r\n    pub description: Option<String>,\r\n    pub member_count: u32,\r\n    pub post_count: u32,\r\n    pub trending_score: f64,\r\n    pub rank: u32,\r\n    pub score_change: Option<f64>,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct ListTrendingTopicsResponse {\r\n    pub generated_at: i64,\r\n    pub topics: Vec<TrendingTopicDto>,\r\n}\r\n","traces":[{"line":40,"address":[23030912],"length":1,"stats":{"Line":0}},{"line":41,"address":[23037926],"length":1,"stats":{"Line":0}},{"line":42,"address":[17278519],"length":1,"stats":{"Line":0}},{"line":44,"address":[23140842],"length":1,"stats":{"Line":0}},{"line":45,"address":[23105844],"length":1,"stats":{"Line":0}},{"line":47,"address":[23024388,23024279],"length":1,"stats":{"Line":0}},{"line":48,"address":[23038156],"length":1,"stats":{"Line":0}},{"line":49,"address":[23038219],"length":1,"stats":{"Line":0}},{"line":52,"address":[23099006,23099123],"length":1,"stats":{"Line":0}},{"line":53,"address":[23142824,23142866],"length":1,"stats":{"Line":0}},{"line":54,"address":[23106122],"length":1,"stats":{"Line":0}},{"line":58,"address":[23099155],"length":1,"stats":{"Line":0}},{"line":78,"address":[23142976],"length":1,"stats":{"Line":0}},{"line":79,"address":[23237798],"length":1,"stats":{"Line":0}},{"line":80,"address":[23137479],"length":1,"stats":{"Line":0}},{"line":82,"address":[23143050],"length":1,"stats":{"Line":0}},{"line":83,"address":[19325610],"length":1,"stats":{"Line":0}},{"line":85,"address":[23099431],"length":1,"stats":{"Line":0}},{"line":86,"address":[23143255],"length":1,"stats":{"Line":0}},{"line":90,"address":[23141671,23141562],"length":1,"stats":{"Line":0}},{"line":91,"address":[23143395,23143324],"length":1,"stats":{"Line":0}},{"line":92,"address":[23106651],"length":1,"stats":{"Line":0}},{"line":96,"address":[23038823,23038968],"length":1,"stats":{"Line":0}},{"line":97,"address":[23143539,23143504],"length":1,"stats":{"Line":0}},{"line":98,"address":[17279588],"length":1,"stats":{"Line":0}},{"line":102,"address":[23106752],"length":1,"stats":{"Line":0}},{"line":115,"address":[23025360],"length":1,"stats":{"Line":0}},{"line":116,"address":[19326147],"length":1,"stats":{"Line":0}},{"line":117,"address":[23032260],"length":1,"stats":{"Line":0}},{"line":120,"address":[19326183,19326289],"length":1,"stats":{"Line":0}},{"line":121,"address":[23143830],"length":1,"stats":{"Line":0}},{"line":122,"address":[23100194],"length":1,"stats":{"Line":0}},{"line":126,"address":[19326310,19326425],"length":1,"stats":{"Line":0}},{"line":127,"address":[23025681],"length":1,"stats":{"Line":0}},{"line":128,"address":[23138418],"length":1,"stats":{"Line":0}},{"line":132,"address":[19326451],"length":1,"stats":{"Line":0}},{"line":142,"address":[19326528],"length":1,"stats":{"Line":0}},{"line":143,"address":[23100398],"length":1,"stats":{"Line":0}},{"line":144,"address":[23107377],"length":1,"stats":{"Line":0}},{"line":146,"address":[23142482],"length":1,"stats":{"Line":0}},{"line":156,"address":[23032720],"length":1,"stats":{"Line":0}},{"line":157,"address":[23138670],"length":1,"stats":{"Line":0}},{"line":158,"address":[23032801],"length":1,"stats":{"Line":0}},{"line":160,"address":[23142642],"length":1,"stats":{"Line":0}},{"line":170,"address":[23138800],"length":1,"stats":{"Line":0}},{"line":171,"address":[23026126],"length":1,"stats":{"Line":0}},{"line":172,"address":[23032961],"length":1,"stats":{"Line":0}},{"line":174,"address":[23039922],"length":1,"stats":{"Line":0}},{"line":185,"address":[23033040],"length":1,"stats":{"Line":0}},{"line":186,"address":[23144576],"length":1,"stats":{"Line":0}},{"line":187,"address":[23144649],"length":1,"stats":{"Line":0}},{"line":189,"address":[23100916],"length":1,"stats":{"Line":0}},{"line":190,"address":[23139141],"length":1,"stats":{"Line":0}},{"line":192,"address":[23107942],"length":1,"stats":{"Line":0}},{"line":203,"address":[23108032],"length":1,"stats":{"Line":0}},{"line":204,"address":[23144830],"length":1,"stats":{"Line":0}},{"line":205,"address":[23108113],"length":1,"stats":{"Line":0}},{"line":207,"address":[23101170],"length":1,"stats":{"Line":0}},{"line":226,"address":[23144960],"length":1,"stats":{"Line":0}},{"line":227,"address":[23139400],"length":1,"stats":{"Line":0}},{"line":228,"address":[23139424],"length":1,"stats":{"Line":0}},{"line":229,"address":[17281051],"length":1,"stats":{"Line":0}},{"line":231,"address":[23026807],"length":1,"stats":{"Line":0}},{"line":232,"address":[23145112],"length":1,"stats":{"Line":0}},{"line":235,"address":[23239804],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","user_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UserProfile {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub website: Option<String>,\n    pub nip05: Option<String>,\n    pub is_profile_public: Option<bool>,\n    pub show_online_status: Option<bool>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PaginatedUserProfiles {\n    pub items: Vec<UserProfile>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SearchUsersRequest {\n    pub query: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub allow_incomplete: Option<bool>,\n    pub viewer_npub: Option<String>,\n}\n\nimpl crate::presentation::dto::Validate for SearchUsersRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.query.trim().is_empty() {\n            return Err(\"検索キーワードを入力してください\".to_string());\n        }\n        if let Some(limit) = self.limit {\n            if limit == 0 || limit > 50 {\n                return Err(\"limit は 1〜50 の範囲で指定してください\".to_string());\n            }\n        }\n        if let Some(sort) = self.sort.as_deref() {\n            if sort != \"relevance\" && sort != \"recency\" {\n                return Err(\"sort は relevance または recency を指定してください\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SearchUsersResponse {\n    pub items: Vec<UserProfile>,\n    pub next_cursor: Option<String>,\n    pub has_more: bool,\n    pub total_count: u64,\n    pub took_ms: u64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GetFollowersRequest {\n    pub npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub search: Option<String>,\n    pub viewer_npub: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct GetFollowingRequest {\n    pub npub: String,\n    pub cursor: Option<String>,\n    pub limit: Option<u32>,\n    pub sort: Option<String>,\n    pub search: Option<String>,\n    pub viewer_npub: Option<String>,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UpdatePrivacySettingsRequest {\n    pub npub: String,\n    pub public_profile: bool,\n    pub show_online_status: bool,\n}\n\nimpl crate::presentation::dto::Validate for UpdatePrivacySettingsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.npub.trim().is_empty() {\n            return Err(\"npub is required\".to_string());\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[16019072],"length":1,"stats":{"Line":0}},{"line":38,"address":[16119478],"length":1,"stats":{"Line":0}},{"line":39,"address":[16019157],"length":1,"stats":{"Line":0}},{"line":41,"address":[16023082,16023157],"length":1,"stats":{"Line":0}},{"line":42,"address":[16019355,16019235],"length":1,"stats":{"Line":0}},{"line":43,"address":[15981183],"length":1,"stats":{"Line":0}},{"line":46,"address":[16019247,16019375],"length":1,"stats":{"Line":0}},{"line":47,"address":[23681709,23681667],"length":1,"stats":{"Line":0}},{"line":48,"address":[16019461],"length":1,"stats":{"Line":0}},{"line":51,"address":[15913502],"length":1,"stats":{"Line":0}},{"line":92,"address":[16119904],"length":1,"stats":{"Line":0}},{"line":93,"address":[15906862],"length":1,"stats":{"Line":0}},{"line":94,"address":[16019617],"length":1,"stats":{"Line":0}},{"line":96,"address":[18131698],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","auth_handler.rs"],"content":"use crate::{\n    application::services::AuthService,\n    presentation::dto::{\n        Validate,\n        auth_dto::{CreateAccountResponse, LoginResponse, LoginWithNsecRequest},\n    },\n    shared::error::AppError,\n};\nuse std::sync::Arc;\n\npub struct AuthHandler {\n    auth_service: Arc<AuthService>,\n}\n\nimpl AuthHandler {\n    pub fn new(auth_service: Arc<AuthService>) -> Self {\n        Self { auth_service }\n    }\n\n    pub async fn create_account(&self) -> Result<CreateAccountResponse, AppError> {\n        let (user, keypair) = self.auth_service.create_account_with_keys().await?;\n\n        Ok(CreateAccountResponse {\n            npub: user.npub.clone(),\n            nsec: keypair.nsec.clone(),\n            pubkey: user.pubkey.clone(),\n        })\n    }\n\n    pub async fn login_with_nsec(\n        &self,\n        request: LoginWithNsecRequest,\n    ) -> Result<LoginResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let user = self.auth_service.login_with_nsec(&request.nsec).await?;\n\n        Ok(LoginResponse {\n            success: true,\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn logout(&self, npub: String) -> Result<(), AppError> {\n        let _ = npub;\n        self.auth_service.logout().await?;\n        Ok(())\n    }\n\n    pub async fn get_current_user(&self) -> Result<Option<LoginResponse>, AppError> {\n        match self.auth_service.get_current_user().await? {\n            Some(user) => Ok(Some(LoginResponse {\n                success: true,\n                npub: user.npub,\n                pubkey: user.pubkey,\n            })),\n            None => Ok(None),\n        }\n    }\n\n    pub async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.auth_service.export_private_key(npub).await\n    }\n}\n","traces":[{"line":16,"address":[15981584],"length":1,"stats":{"Line":0}},{"line":20,"address":[15913944,15913981,15915184,15914131,15913792,15913824,15913800,15913859],"length":1,"stats":{"Line":0}},{"line":21,"address":[19289287],"length":1,"stats":{"Line":0}},{"line":23,"address":[16026388],"length":1,"stats":{"Line":0}},{"line":24,"address":[15921576],"length":1,"stats":{"Line":0}},{"line":25,"address":[16020671],"length":1,"stats":{"Line":0}},{"line":26,"address":[15989555],"length":1,"stats":{"Line":0}},{"line":30,"address":[16025056],"length":1,"stats":{"Line":0}},{"line":34,"address":[15915491,15915803,15915585,15915378],"length":1,"stats":{"Line":0}},{"line":36,"address":[19294516],"length":1,"stats":{"Line":0}},{"line":38,"address":[15984071],"length":1,"stats":{"Line":0}},{"line":40,"address":[20562620],"length":1,"stats":{"Line":0}},{"line":41,"address":[23684423],"length":1,"stats":{"Line":0}},{"line":45,"address":[15910032,15910799,15910908,15910080,15910040,15910420,15910218,15910115],"length":1,"stats":{"Line":0}},{"line":47,"address":[19218113],"length":1,"stats":{"Line":0}},{"line":48,"address":[20563866],"length":1,"stats":{"Line":0}},{"line":51,"address":[16029386,16029232,16029533,16029349,16029216,16030552,16029267,16029224],"length":1,"stats":{"Line":0}},{"line":52,"address":[11596388],"length":1,"stats":{"Line":0}},{"line":53,"address":[20564880,20564946],"length":1,"stats":{"Line":0}},{"line":55,"address":[16028390],"length":1,"stats":{"Line":0}},{"line":56,"address":[15993302],"length":1,"stats":{"Line":0}},{"line":58,"address":[16028311],"length":1,"stats":{"Line":0}},{"line":62,"address":[16125564,16125360,16125378,16125601,16125745,16125443,16125408,16126021],"length":1,"stats":{"Line":0}},{"line":63,"address":[11653204],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","community_node_handler.rs"],"content":"use crate::application::ports::group_key_store::{GroupKeyEntry, GroupKeyStore};\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::presentation::dto::community_node_dto::{\n    CommunityNodeAuthRequest, CommunityNodeAuthResponse, CommunityNodeBootstrapServicesRequest,\n    CommunityNodeConfigRequest, CommunityNodeConfigResponse, CommunityNodeConsentRequest,\n    CommunityNodeLabelsRequest, CommunityNodeReportRequest, CommunityNodeRoleConfig,\n    CommunityNodeSearchRequest, CommunityNodeTokenRequest, CommunityNodeTrustAnchorRequest,\n    CommunityNodeTrustAnchorState, CommunityNodeTrustRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::Utc;\nuse nostr_sdk::prelude::{\n    Event as NostrEvent, EventBuilder, FromBech32, Keys, Kind, PublicKey, SecretKey, Tag,\n};\nuse reqwest::{Client, Method, StatusCode, Url};\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nconst COMMUNITY_NODE_CONFIG_KEY: &str = \"community_node_config_v2\";\nconst COMMUNITY_NODE_CONFIG_LEGACY_KEY: &str = \"community_node_config_v1\";\nconst COMMUNITY_NODE_TRUST_ANCHOR_KEY: &str = \"community_node_trust_anchor_v1\";\nconst COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY: &str = \"community_node_bootstrap_cache_v1\";\nconst AUTH_KIND: u16 = 22242;\nconst NODE_DESCRIPTOR_KIND: u16 = 39000;\nconst TOPIC_SERVICE_KIND: u16 = 39001;\nconst LABEL_KIND: u16 = 39006;\nconst ATTESTATION_KIND: u16 = 39010;\nconst TRUST_ANCHOR_KIND: u16 = 39011;\nconst KIP_NAMESPACE: &str = \"kukuri\";\nconst KIP_VERSION: &str = \"1\";\nconst KIP_NODE_DESCRIPTOR_SCHEMA: &str = \"kukuri-node-desc-v1\";\nconst KIP_TOPIC_SERVICE_SCHEMA: &str = \"kukuri-topic-service-v1\";\nconst KIP_ATTESTATION_SCHEMA: &str = \"kukuri-attest-v1\";\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct CommunityNodeConfig {\n    #[serde(default)]\n    nodes: Vec<CommunityNodeConfigNode>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CommunityNodeConfigNode {\n    base_url: String,\n    #[serde(default)]\n    roles: CommunityNodeRoleConfig,\n    access_token: Option<String>,\n    token_expires_at: Option<i64>,\n    pubkey: Option<String>,\n}\n\nimpl CommunityNodeConfigNode {\n    fn new(base_url: String, roles: CommunityNodeRoleConfig) -> Self {\n        Self {\n            base_url,\n            roles,\n            access_token: None,\n            token_expires_at: None,\n            pubkey: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct LegacyCommunityNodeConfig {\n    base_url: String,\n    access_token: Option<String>,\n    token_expires_at: Option<i64>,\n    pubkey: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct StoredTrustAnchor {\n    attester: String,\n    claim: Option<String>,\n    topic: Option<String>,\n    weight: f64,\n    issued_at: i64,\n    event_json: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct BootstrapCache {\n    #[serde(default)]\n    nodes: BootstrapCacheEntry,\n    #[serde(default)]\n    services: HashMap<String, BootstrapCacheEntry>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\nstruct BootstrapCacheEntry {\n    #[serde(default)]\n    items: Vec<serde_json::Value>,\n    #[serde(default)]\n    next_refresh_at: Option<i64>,\n    #[serde(default)]\n    updated_at: Option<i64>,\n    #[serde(default)]\n    stale: bool,\n}\n\nimpl From<StoredTrustAnchor> for CommunityNodeTrustAnchorState {\n    fn from(anchor: StoredTrustAnchor) -> Self {\n        Self {\n            attester: anchor.attester,\n            claim: anchor.claim,\n            topic: anchor.topic,\n            weight: anchor.weight,\n            issued_at: anchor.issued_at,\n            event_json: anchor.event_json,\n        }\n    }\n}\n\n#[derive(Debug, Deserialize)]\nstruct AuthChallengeResponse {\n    challenge: String,\n    #[serde(rename = \"expires_at\")]\n    _expires_at: i64,\n}\n\n#[derive(Debug, Deserialize)]\nstruct AuthVerifyResponse {\n    access_token: String,\n    #[serde(rename = \"token_type\")]\n    _token_type: String,\n    expires_at: i64,\n    pubkey: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CommunityNodeSearchPayload {\n    items: Vec<serde_json::Value>,\n    next_cursor: Option<String>,\n    total: Option<i64>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct BootstrapHttpResponse {\n    items: Vec<serde_json::Value>,\n    #[serde(default)]\n    next_refresh_at: Option<i64>,\n}\n\n#[derive(Debug, Clone)]\nstruct BootstrapAggregateResult {\n    items: Vec<serde_json::Value>,\n    next_refresh_at: Option<i64>,\n}\n\npub struct CommunityNodeHandler {\n    key_manager: Arc<dyn KeyManager>,\n    secure_storage: Arc<dyn SecureStorage>,\n    group_key_store: Arc<dyn GroupKeyStore>,\n    client: Client,\n}\n\nimpl CommunityNodeHandler {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        secure_storage: Arc<dyn SecureStorage>,\n        group_key_store: Arc<dyn GroupKeyStore>,\n    ) -> Self {\n        Self {\n            key_manager,\n            secure_storage,\n            group_key_store,\n            client: Client::new(),\n        }\n    }\n\n    pub async fn set_config(\n        &self,\n        request: CommunityNodeConfigRequest,\n    ) -> Result<CommunityNodeConfigResponse, AppError> {\n        let mut config = self.load_config().await?.unwrap_or_default();\n        let mut existing = HashMap::new();\n        for node in config.nodes.drain(..) {\n            existing.insert(node.base_url.clone(), node);\n        }\n\n        let mut next_nodes = Vec::new();\n        let mut seen = HashMap::new();\n        for node_request in request.nodes {\n            let base_url = normalize_base_url(&node_request.base_url)?;\n            if seen.contains_key(&base_url) {\n                continue;\n            }\n            seen.insert(base_url.clone(), true);\n            let roles = node_request.roles.unwrap_or_default();\n            let mut node = existing\n                .remove(&base_url)\n                .unwrap_or_else(|| CommunityNodeConfigNode::new(base_url.clone(), roles.clone()));\n            if node.base_url != base_url {\n                node.access_token = None;\n                node.token_expires_at = None;\n                node.pubkey = None;\n            }\n            node.base_url = base_url;\n            node.roles = roles;\n            next_nodes.push(node);\n        }\n        config.nodes = next_nodes;\n        self.save_config(&config).await?;\n        Ok(config_response(&config))\n    }\n\n    pub async fn get_config(&self) -> Result<Option<CommunityNodeConfigResponse>, AppError> {\n        let Some(config) = self.load_config().await? else {\n            return Ok(None);\n        };\n        if config.nodes.is_empty() {\n            return Ok(None);\n        }\n        Ok(Some(config_response(&config)))\n    }\n\n    pub async fn clear_config(&self) -> Result<(), AppError> {\n        self.secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let _ = self\n            .secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await;\n        Ok(())\n    }\n\n    pub async fn clear_token(&self, request: CommunityNodeTokenRequest) -> Result<(), AppError> {\n        let base_url = normalize_base_url(&request.base_url)?;\n        let mut config = self.require_config().await?;\n        let node = find_node_mut(&mut config, &base_url)?;\n        node.access_token = None;\n        node.token_expires_at = None;\n        node.pubkey = None;\n        self.save_config(&config).await\n    }\n\n    pub async fn get_trust_anchor(\n        &self,\n    ) -> Result<Option<CommunityNodeTrustAnchorState>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_TRUST_ANCHOR_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(None);\n        };\n        let stored: StoredTrustAnchor = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(stored.into()))\n    }\n\n    pub async fn set_trust_anchor(\n        &self,\n        request: CommunityNodeTrustAnchorRequest,\n    ) -> Result<CommunityNodeTrustAnchorState, AppError> {\n        let attester = request.attester.trim().to_string();\n        if attester.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Attester is required\",\n            ));\n        }\n        PublicKey::from_hex(&attester).map_err(|err| {\n            AppError::validation(\n                ValidationFailureKind::Generic,\n                format!(\"Invalid attester pubkey: {err}\"),\n            )\n        })?;\n\n        let weight = request.weight.unwrap_or(1.0);\n        if !weight.is_finite() || !(0.0..=1.0).contains(&weight) {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Weight must be between 0 and 1\",\n            ));\n        }\n\n        let claim = normalize_optional_value(request.claim);\n        let topic = normalize_optional_value(request.topic);\n\n        let keypair = self.key_manager.current_keypair().await?;\n        let secret_key = SecretKey::from_bech32(&keypair.nsec)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid nsec: {err}\")))?;\n        let keys = Keys::new(secret_key);\n        let mut tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"ver\", KIP_VERSION])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"attester\", &attester])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n            Tag::parse([\"weight\", &weight.to_string()])\n                .map_err(|err| AppError::NostrError(err.to_string()))?,\n        ];\n        if let Some(value) = claim.as_ref() {\n            tags.push(\n                Tag::parse([\"claim\", value])\n                    .map_err(|err| AppError::NostrError(err.to_string()))?,\n            );\n        }\n        if let Some(value) = topic.as_ref() {\n            tags.push(\n                Tag::parse([\"t\", value]).map_err(|err| AppError::NostrError(err.to_string()))?,\n            );\n        }\n\n        let event = EventBuilder::new(Kind::Custom(TRUST_ANCHOR_KIND), \"\")\n            .tags(tags)\n            .sign_with_keys(&keys)?;\n        let event_json = serde_json::to_value(&event)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        let issued_at = event.created_at.as_secs() as i64;\n\n        let stored = StoredTrustAnchor {\n            attester,\n            claim,\n            topic,\n            weight,\n            issued_at,\n            event_json,\n        };\n        let raw = serde_json::to_string(&stored)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_TRUST_ANCHOR_KEY, &raw)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n\n        Ok(stored.into())\n    }\n\n    pub async fn clear_trust_anchor(&self) -> Result<(), AppError> {\n        self.secure_storage\n            .delete(COMMUNITY_NODE_TRUST_ANCHOR_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    pub async fn authenticate(\n        &self,\n        request: CommunityNodeAuthRequest,\n    ) -> Result<CommunityNodeAuthResponse, AppError> {\n        let base_url = normalize_base_url(&request.base_url)?;\n        let mut config = self.require_config().await?;\n        let node = find_node_mut(&mut config, &base_url)?;\n        let keypair = self.key_manager.current_keypair().await?;\n        let challenge = self\n            .request_auth_challenge(&node.base_url, &keypair.public_key)\n            .await?;\n        let auth_event = build_auth_event(&node.base_url, &challenge.challenge, &keypair.nsec)?;\n        let verified = self.verify_auth(&node.base_url, &auth_event).await?;\n        node.access_token = Some(verified.access_token.clone());\n        node.token_expires_at = Some(verified.expires_at);\n        node.pubkey = Some(verified.pubkey.clone());\n        self.save_config(&config).await?;\n\n        Ok(CommunityNodeAuthResponse {\n            expires_at: verified.expires_at,\n            pubkey: verified.pubkey,\n        })\n    }\n\n    pub async fn list_group_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        self.group_key_store.list_keys().await\n    }\n\n    pub async fn list_labels(\n        &self,\n        request: CommunityNodeLabelsRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Labels,\n        )?;\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut last_error: Option<AppError> = None;\n        let now = Utc::now().timestamp();\n        let current_pubkey = self\n            .key_manager\n            .current_keypair()\n            .await\n            .ok()\n            .map(|pair| pair.public_key);\n\n        for node in nodes {\n            let expected_pubkey =\n                resolve_expected_pubkey(node.pubkey.as_deref(), current_pubkey.as_deref());\n\n            let url = build_url(&node.base_url, \"/v1/labels\");\n            let mut builder = self\n                .authorized_request(node, Method::GET, url, true)\n                .await?;\n            builder = builder.query(&[\n                (\"target\", request.target.clone()),\n                (\"limit\", request.limit.unwrap_or(50).to_string()),\n            ]);\n            if let Some(topic) = request.topic.clone() {\n                builder = builder.query(&[(\"topic\", topic)]);\n            }\n            if let Some(cursor) = request.cursor.clone() {\n                builder = builder.query(&[(\"cursor\", cursor)]);\n            }\n            match request_json::<serde_json::Value>(builder).await {\n                Ok(response) => {\n                    if let Some(list) = response.get(\"items\").and_then(|value| value.as_array()) {\n                        for item in list {\n                            if validate_kip_event_json(item, LABEL_KIND, expected_pubkey, now)\n                                .is_some()\n                            {\n                                items.push(item.clone());\n                            }\n                        }\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node labels are unavailable\".to_string())\n            }));\n        }\n\n        Ok(json!({ \"items\": items }))\n    }\n\n    pub async fn submit_report(\n        &self,\n        request: CommunityNodeReportRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, request.base_url.as_deref())?;\n        let url = build_url(&node.base_url, \"/v1/reports\");\n        let builder = self\n            .authorized_request(node, Method::POST, url, true)\n            .await?\n            .json(&request);\n        request_json(builder).await\n    }\n\n    pub async fn trust_report_based(\n        &self,\n        request: CommunityNodeTrustRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Trust,\n        )?;\n        self.aggregate_trust_scores(nodes, \"/v1/trust/report-based\", &request.subject)\n            .await\n    }\n\n    pub async fn trust_communication_density(\n        &self,\n        request: CommunityNodeTrustRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Trust,\n        )?;\n        self.aggregate_trust_scores(nodes, \"/v1/trust/communication-density\", &request.subject)\n            .await\n    }\n\n    pub async fn search(\n        &self,\n        request: CommunityNodeSearchRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let nodes = select_nodes_for_role(\n            &config,\n            request.base_url.as_deref(),\n            CommunityNodeRole::Search,\n        )?;\n        self.aggregate_search(nodes, request).await\n    }\n\n    pub async fn list_bootstrap_nodes(&self) -> Result<serde_json::Value, AppError> {\n        let config = self.load_config().await?.unwrap_or_default();\n        let nodes =\n            select_nodes_for_role(&config, None, CommunityNodeRole::Bootstrap).unwrap_or_default();\n        let now = Utc::now().timestamp();\n        let mut cache = self.load_bootstrap_cache().await?;\n        let mut entry = cache.nodes.clone();\n        let mut items = sanitize_bootstrap_items(NODE_DESCRIPTOR_KIND, &entry.items, now, None);\n        entry.items = items.clone();\n        let mut last_error: Option<AppError> = None;\n\n        if !nodes.is_empty() && (items.is_empty() || should_refresh_bootstrap(&entry, now)) {\n            match self.aggregate_bootstrap(nodes, \"/v1/bootstrap/nodes\").await {\n                Ok(result) => {\n                    let fetched =\n                        sanitize_bootstrap_items(NODE_DESCRIPTOR_KIND, &result.items, now, None);\n                    entry.items = fetched.clone();\n                    entry.next_refresh_at = result.next_refresh_at;\n                    entry.updated_at = Some(now);\n                    entry.stale = false;\n                    items = fetched;\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        entry.updated_at = entry.updated_at.or(Some(now));\n        cache.nodes = entry;\n        self.save_bootstrap_cache(&cache).await?;\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n            return Err(AppError::NotFound(\n                \"Community node bootstrap data is unavailable\".to_string(),\n            ));\n        }\n\n        Ok(json!({\n            \"items\": items,\n            \"next_refresh_at\": cache.nodes.next_refresh_at\n        }))\n    }\n\n    pub async fn list_bootstrap_services(\n        &self,\n        request: CommunityNodeBootstrapServicesRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.load_config().await?.unwrap_or_default();\n        let nodes = if request.base_url.is_some() {\n            select_nodes_for_role(\n                &config,\n                request.base_url.as_deref(),\n                CommunityNodeRole::Bootstrap,\n            )?\n        } else {\n            select_nodes_for_role(&config, None, CommunityNodeRole::Bootstrap).unwrap_or_default()\n        };\n\n        let topic_id = request.topic_id;\n        let path = format!(\"/v1/bootstrap/topics/{}/services\", topic_id);\n        let now = Utc::now().timestamp();\n        let mut cache = self.load_bootstrap_cache().await?;\n        let mut entry = cache.services.get(&topic_id).cloned().unwrap_or_default();\n        let mut items =\n            sanitize_bootstrap_items(TOPIC_SERVICE_KIND, &entry.items, now, Some(&topic_id));\n        entry.items = items.clone();\n        let mut last_error: Option<AppError> = None;\n\n        if !nodes.is_empty() && (items.is_empty() || should_refresh_bootstrap(&entry, now)) {\n            match self.aggregate_bootstrap(nodes, &path).await {\n                Ok(result) => {\n                    let fetched = sanitize_bootstrap_items(\n                        TOPIC_SERVICE_KIND,\n                        &result.items,\n                        now,\n                        Some(&topic_id),\n                    );\n                    entry.items = fetched.clone();\n                    entry.next_refresh_at = result.next_refresh_at;\n                    entry.updated_at = Some(now);\n                    entry.stale = false;\n                    items = fetched;\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        entry.updated_at = entry.updated_at.or(Some(now));\n        cache.services.insert(topic_id.clone(), entry);\n        self.save_bootstrap_cache(&cache).await?;\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n            return Err(AppError::NotFound(\n                \"Community node bootstrap data is unavailable\".to_string(),\n            ));\n        }\n\n        Ok(json!({\n            \"items\": items,\n            \"next_refresh_at\": cache\n                .services\n                .get(&topic_id)\n                .and_then(|entry| entry.next_refresh_at)\n        }))\n    }\n\n    pub async fn ingest_bootstrap_event(\n        &self,\n        event: &crate::domain::entities::Event,\n    ) -> Result<(), AppError> {\n        let kind = match u16::try_from(event.kind) {\n            Ok(kind) => kind,\n            Err(_) => return Ok(()),\n        };\n        if kind != NODE_DESCRIPTOR_KIND && kind != TOPIC_SERVICE_KIND {\n            return Ok(());\n        }\n\n        let event_json = json!({\n            \"id\": event.id,\n            \"pubkey\": event.pubkey,\n            \"created_at\": event.created_at.timestamp(),\n            \"kind\": event.kind,\n            \"tags\": event.tags,\n            \"content\": event.content,\n            \"sig\": event.sig,\n        });\n\n        let now = Utc::now().timestamp();\n        let Some(nostr_event) = validate_kip_event_json(&event_json, kind, None, now) else {\n            return Ok(());\n        };\n\n        let mut cache = self.load_bootstrap_cache().await?;\n        let exp = event_tag_value(&nostr_event, \"exp\").and_then(|value| value.parse::<i64>().ok());\n\n        if kind == NODE_DESCRIPTOR_KIND {\n            merge_bootstrap_entry(\n                &mut cache.nodes,\n                kind,\n                &nostr_event,\n                event_json,\n                exp,\n                now,\n                None,\n            );\n        } else {\n            let Some(topic_id) = event_tag_value(&nostr_event, \"t\").map(|value| value.to_string())\n            else {\n                return Ok(());\n            };\n            let entry = cache.services.entry(topic_id.clone()).or_default();\n            merge_bootstrap_entry(\n                entry,\n                kind,\n                &nostr_event,\n                event_json,\n                exp,\n                now,\n                Some(topic_id.as_str()),\n            );\n        }\n\n        self.save_bootstrap_cache(&cache).await?;\n        Ok(())\n    }\n\n    pub async fn get_consent_status(\n        &self,\n        request: CommunityNodeTokenRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, Some(&request.base_url))?;\n        let url = build_url(&node.base_url, \"/v1/consents/status\");\n        let builder = self\n            .authorized_request(node, Method::GET, url, true)\n            .await?;\n        request_json(builder).await\n    }\n\n    pub async fn accept_consents(\n        &self,\n        request: CommunityNodeConsentRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let config = self.require_config().await?;\n        let node = select_node(&config, request.base_url.as_deref())?;\n        let url = build_url(&node.base_url, \"/v1/consents\");\n        let builder = self\n            .authorized_request(node, Method::POST, url, true)\n            .await?\n            .json(&request);\n        request_json(builder).await\n    }\n\n    async fn require_config(&self) -> Result<CommunityNodeConfig, AppError> {\n        self.load_config()\n            .await?\n            .filter(|cfg| !cfg.nodes.is_empty())\n            .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n    }\n\n    async fn load_config(&self) -> Result<Option<CommunityNodeConfig>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_CONFIG_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return self.load_legacy_config().await;\n        };\n        let parsed = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        Ok(Some(parsed))\n    }\n\n    async fn load_legacy_config(&self) -> Result<Option<CommunityNodeConfig>, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(None);\n        };\n        let legacy: LegacyCommunityNodeConfig = serde_json::from_str(&raw)\n            .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n        if legacy.base_url.trim().is_empty() {\n            return Ok(None);\n        }\n        let base_url = normalize_base_url(&legacy.base_url)?;\n        let mut node = CommunityNodeConfigNode::new(base_url, CommunityNodeRoleConfig::default());\n        node.access_token = legacy.access_token;\n        node.token_expires_at = legacy.token_expires_at;\n        node.pubkey = legacy.pubkey;\n        let config = CommunityNodeConfig { nodes: vec![node] };\n        self.save_config(&config).await?;\n        let _ = self\n            .secure_storage\n            .delete(COMMUNITY_NODE_CONFIG_LEGACY_KEY)\n            .await;\n        Ok(Some(config))\n    }\n\n    async fn save_config(&self, config: &CommunityNodeConfig) -> Result<(), AppError> {\n        let json = serde_json::to_string(config)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_CONFIG_KEY, &json)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    async fn load_bootstrap_cache(&self) -> Result<BootstrapCache, AppError> {\n        let raw = self\n            .secure_storage\n            .retrieve(COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        let Some(raw) = raw else {\n            return Ok(BootstrapCache::default());\n        };\n        serde_json::from_str(&raw).map_err(|err| AppError::DeserializationError(err.to_string()))\n    }\n\n    async fn save_bootstrap_cache(&self, cache: &BootstrapCache) -> Result<(), AppError> {\n        let json = serde_json::to_string(cache)\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        self.secure_storage\n            .store(COMMUNITY_NODE_BOOTSTRAP_CACHE_KEY, &json)\n            .await\n            .map_err(|err| AppError::Storage(err.to_string()))?;\n        Ok(())\n    }\n\n    async fn authorized_request(\n        &self,\n        node: &CommunityNodeConfigNode,\n        method: Method,\n        url: String,\n        require_auth: bool,\n    ) -> Result<reqwest::RequestBuilder, AppError> {\n        let builder = self.client.request(method, url);\n        let Some(token) = node.access_token.as_ref() else {\n            if require_auth {\n                return Err(AppError::Unauthorized(\n                    \"Community node token is missing\".to_string(),\n                ));\n            }\n            return Ok(builder);\n        };\n        if let Some(exp) = node.token_expires_at {\n            if exp <= Utc::now().timestamp() {\n                if !require_auth {\n                    return Ok(builder);\n                }\n                return Err(AppError::Unauthorized(\n                    \"Community node token has expired\".to_string(),\n                ));\n            }\n        }\n        Ok(builder.bearer_auth(token))\n    }\n\n    async fn aggregate_trust_scores(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        path: &str,\n        subject: &str,\n    ) -> Result<serde_json::Value, AppError> {\n        let mut scores: Vec<f64> = Vec::new();\n        let mut sources: Vec<serde_json::Value> = Vec::new();\n        let mut last_error: Option<AppError> = None;\n        let now = Utc::now().timestamp();\n        let current_pubkey = self\n            .key_manager\n            .current_keypair()\n            .await\n            .ok()\n            .map(|pair| pair.public_key);\n\n        for node in nodes {\n            let expected_pubkey =\n                resolve_expected_pubkey(node.pubkey.as_deref(), current_pubkey.as_deref());\n            let url = build_url(&node.base_url, path);\n            let builder = match self.authorized_request(node, Method::GET, url, true).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n            let builder = builder.query(&[(\"subject\", subject.to_string())]);\n            match request_json::<serde_json::Value>(builder).await {\n                Ok(response) => {\n                    if let Some(score) = response.get(\"score\").and_then(|value| value.as_f64()) {\n                        if !validate_attestation_payload(&response, expected_pubkey, now) {\n                            last_error = Some(AppError::validation(\n                                ValidationFailureKind::Generic,\n                                \"Community node attestation is invalid\",\n                            ));\n                            continue;\n                        }\n                        scores.push(score);\n                        sources.push(json!({\n                            \"base_url\": node.base_url.clone(),\n                            \"score\": score,\n                        }));\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if scores.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node trust score is unavailable\".to_string())\n            }));\n        }\n\n        let sum: f64 = scores.iter().sum();\n        let avg = sum / scores.len() as f64;\n\n        Ok(json!({\n            \"score\": avg,\n            \"sources\": sources,\n        }))\n    }\n\n    async fn aggregate_search(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        request: CommunityNodeSearchRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        let use_composite_cursor = nodes.len() > 1;\n        let cursor_map = request\n            .cursor\n            .as_ref()\n            .and_then(|raw| parse_cursor_map(raw, use_composite_cursor));\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut next_cursor_map: HashMap<String, String> = HashMap::new();\n        let mut total: i64 = 0;\n        let mut last_error: Option<AppError> = None;\n\n        for node in nodes {\n            let url = build_url(&node.base_url, \"/v1/search\");\n            let builder = match self.authorized_request(node, Method::GET, url, true).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n\n            let mut builder = builder.query(&[(\"topic\", request.topic.clone())]);\n            if let Some(query) = request.q.clone() {\n                builder = builder.query(&[(\"q\", query)]);\n            }\n            if let Some(limit) = request.limit {\n                builder = builder.query(&[(\"limit\", limit.to_string())]);\n            }\n            let node_cursor = if use_composite_cursor {\n                cursor_map\n                    .as_ref()\n                    .and_then(|map| map.get(&node.base_url).cloned())\n            } else {\n                request.cursor.clone()\n            };\n            if let Some(cursor) = node_cursor {\n                builder = builder.query(&[(\"cursor\", cursor)]);\n            }\n\n            match request_json::<CommunityNodeSearchPayload>(builder).await {\n                Ok(response) => {\n                    total += response.total.unwrap_or(response.items.len() as i64);\n                    if let Some(next_cursor) = response.next_cursor {\n                        next_cursor_map.insert(node.base_url.clone(), next_cursor);\n                    }\n                    items.extend(response.items);\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            if let Some(err) = last_error {\n                return Err(err);\n            }\n        }\n\n        let next_cursor = if next_cursor_map.is_empty() {\n            None\n        } else {\n            Some(\n                serde_json::to_string(&next_cursor_map)\n                    .map_err(|err| AppError::SerializationError(err.to_string()))?,\n            )\n        };\n\n        Ok(json!({\n            \"topic\": request.topic,\n            \"query\": request.q,\n            \"items\": items,\n            \"next_cursor\": next_cursor,\n            \"total\": total,\n        }))\n    }\n\n    async fn aggregate_bootstrap(\n        &self,\n        nodes: Vec<&CommunityNodeConfigNode>,\n        path: &str,\n    ) -> Result<BootstrapAggregateResult, AppError> {\n        let mut items: Vec<serde_json::Value> = Vec::new();\n        let mut next_refresh_at: Option<i64> = None;\n        let mut last_error: Option<AppError> = None;\n\n        for node in nodes {\n            let url = build_url(&node.base_url, path);\n            let builder = match self.authorized_request(node, Method::GET, url, false).await {\n                Ok(builder) => builder,\n                Err(err) => {\n                    last_error = Some(err);\n                    continue;\n                }\n            };\n            match request_json::<BootstrapHttpResponse>(builder).await {\n                Ok(response) => {\n                    items.extend(response.items);\n                    if let Some(refresh) = response.next_refresh_at {\n                        next_refresh_at = Some(match next_refresh_at {\n                            Some(current) => current.min(refresh),\n                            None => refresh,\n                        });\n                    }\n                }\n                Err(err) => {\n                    last_error = Some(err);\n                }\n            }\n        }\n\n        if items.is_empty() {\n            return Err(last_error.unwrap_or_else(|| {\n                AppError::NotFound(\"Community node bootstrap data is unavailable\".to_string())\n            }));\n        }\n\n        Ok(BootstrapAggregateResult {\n            items,\n            next_refresh_at,\n        })\n    }\n\n    async fn request_auth_challenge(\n        &self,\n        base_url: &str,\n        pubkey: &str,\n    ) -> Result<AuthChallengeResponse, AppError> {\n        let url = build_url(base_url, \"/v1/auth/challenge\");\n        let builder = self.client.post(url).json(&json!({ \"pubkey\": pubkey }));\n        request_json(builder).await\n    }\n\n    async fn verify_auth(\n        &self,\n        base_url: &str,\n        auth_event: &NostrEvent,\n    ) -> Result<AuthVerifyResponse, AppError> {\n        let url = build_url(base_url, \"/v1/auth/verify\");\n        let payload = json!({ \"auth_event_json\": auth_event });\n        let builder = self.client.post(url).json(&payload);\n        request_json(builder).await\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum CommunityNodeRole {\n    Labels,\n    Trust,\n    Search,\n    Bootstrap,\n}\n\nfn role_enabled(roles: &CommunityNodeRoleConfig, role: CommunityNodeRole) -> bool {\n    match role {\n        CommunityNodeRole::Labels => roles.labels,\n        CommunityNodeRole::Trust => roles.trust,\n        CommunityNodeRole::Search => roles.search,\n        CommunityNodeRole::Bootstrap => roles.bootstrap,\n    }\n}\n\nfn find_node<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: &str,\n) -> Result<&'a CommunityNodeConfigNode, AppError> {\n    config\n        .nodes\n        .iter()\n        .find(|node| node.base_url == base_url)\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn find_node_mut<'a>(\n    config: &'a mut CommunityNodeConfig,\n    base_url: &str,\n) -> Result<&'a mut CommunityNodeConfigNode, AppError> {\n    config\n        .nodes\n        .iter_mut()\n        .find(|node| node.base_url == base_url)\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn select_node<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: Option<&str>,\n) -> Result<&'a CommunityNodeConfigNode, AppError> {\n    if let Some(raw) = base_url {\n        let base_url = normalize_base_url(raw)?;\n        return find_node(config, &base_url);\n    }\n    config\n        .nodes\n        .first()\n        .ok_or_else(|| AppError::NotFound(\"Community node is not configured\".to_string()))\n}\n\nfn select_nodes_for_role<'a>(\n    config: &'a CommunityNodeConfig,\n    base_url: Option<&str>,\n    role: CommunityNodeRole,\n) -> Result<Vec<&'a CommunityNodeConfigNode>, AppError> {\n    if let Some(raw) = base_url {\n        let base_url = normalize_base_url(raw)?;\n        let node = find_node(config, &base_url)?;\n        return Ok(vec![node]);\n    }\n\n    let nodes: Vec<_> = config\n        .nodes\n        .iter()\n        .filter(|node| role_enabled(&node.roles, role))\n        .collect();\n    if nodes.is_empty() {\n        return Err(AppError::NotFound(\n            \"Community node role is not configured\".to_string(),\n        ));\n    }\n    Ok(nodes)\n}\n\nfn parse_cursor_map(raw: &str, enable: bool) -> Option<HashMap<String, String>> {\n    if !enable {\n        return None;\n    }\n    serde_json::from_str::<HashMap<String, String>>(raw).ok()\n}\n\nfn normalize_base_url(raw: &str) -> Result<String, AppError> {\n    let trimmed = raw.trim().trim_end_matches('/').to_string();\n    let url = Url::parse(&trimmed).map_err(|err| {\n        AppError::validation(\n            ValidationFailureKind::Generic,\n            format!(\"Invalid URL: {err}\"),\n        )\n    })?;\n    match url.scheme() {\n        \"http\" | \"https\" => Ok(trimmed),\n        _ => Err(AppError::validation(\n            ValidationFailureKind::Generic,\n            \"URL scheme must be http or https\",\n        )),\n    }\n}\n\nfn normalize_optional_value(value: Option<String>) -> Option<String> {\n    value\n        .map(|val| val.trim().to_string())\n        .filter(|val| !val.is_empty())\n}\n\nfn build_url(base_url: &str, path: &str) -> String {\n    let base = base_url.trim_end_matches('/');\n    let path = path.trim_start_matches('/');\n    format!(\"{base}/{path}\")\n}\n\nfn validate_kip_event_json(\n    event_json: &serde_json::Value,\n    expected_kind: u16,\n    expected_pubkey: Option<&str>,\n    now: i64,\n) -> Option<NostrEvent> {\n    let event: NostrEvent = serde_json::from_value(event_json.clone()).ok()?;\n    if event.kind.as_u16() != expected_kind {\n        return None;\n    }\n    if let Some(expected_pubkey) = expected_pubkey {\n        let expected_pubkey = expected_pubkey.trim();\n        if expected_pubkey.is_empty() {\n            return None;\n        }\n        if event.pubkey.to_string() != expected_pubkey {\n            return None;\n        }\n    }\n    if event.verify().is_err() {\n        return None;\n    }\n    if !validate_kip_tags(&event) {\n        return None;\n    }\n    if !validate_kip_requirements(&event, expected_kind, now) {\n        return None;\n    }\n    Some(event)\n}\n\nfn validate_attestation_payload(\n    response: &serde_json::Value,\n    expected_pubkey: Option<&str>,\n    now: i64,\n) -> bool {\n    let Some(attestation) = response.get(\"attestation\") else {\n        return false;\n    };\n    if attestation.is_null() {\n        return false;\n    }\n    let exp = match attestation.get(\"exp\").and_then(|value| value.as_i64()) {\n        Some(exp) => exp,\n        None => return false,\n    };\n    if exp <= now {\n        return false;\n    }\n    let Some(event_json) = attestation.get(\"event_json\") else {\n        return false;\n    };\n    validate_kip_event_json(event_json, ATTESTATION_KIND, expected_pubkey, now).is_some()\n}\n\nfn resolve_expected_pubkey<'a>(\n    node_pubkey: Option<&'a str>,\n    current_pubkey: Option<&str>,\n) -> Option<&'a str> {\n    let node_pubkey = node_pubkey\n        .map(str::trim)\n        .filter(|value| !value.is_empty())?;\n    if let Some(current_pubkey) = current_pubkey {\n        if node_pubkey.eq_ignore_ascii_case(current_pubkey) {\n            return None;\n        }\n    }\n    Some(node_pubkey)\n}\n\nfn event_tag_value<'a>(event: &'a NostrEvent, name: &str) -> Option<&'a str> {\n    event.tags.iter().find_map(|tag| {\n        let values = tag.as_slice();\n        if values.first().map(|value| value.as_str()) == Some(name) {\n            values.get(1).map(|value| value.as_str())\n        } else {\n            None\n        }\n    })\n}\n\nfn event_tag(event: &NostrEvent, name: &str) -> Option<Vec<String>> {\n    event.tags.iter().find_map(|tag| {\n        let values = tag.as_slice();\n        if values.first().map(|value| value.as_str()) == Some(name) {\n            Some(values.to_vec())\n        } else {\n            None\n        }\n    })\n}\n\nfn has_tag(event: &NostrEvent, name: &str) -> bool {\n    event\n        .tags\n        .iter()\n        .any(|tag| tag.as_slice().first().map(|value| value.as_str()) == Some(name))\n}\n\nfn require_tag_value<'a>(event: &'a NostrEvent, name: &str) -> Option<&'a str> {\n    let value = event_tag_value(event, name)?;\n    if value.trim().is_empty() {\n        return None;\n    }\n    Some(value)\n}\n\nfn require_exp_tag(event: &NostrEvent, now: i64) -> Option<i64> {\n    let exp = require_tag_value(event, \"exp\")?\n        .trim()\n        .parse::<i64>()\n        .ok()?;\n    if exp <= now {\n        return None;\n    }\n    Some(exp)\n}\n\nfn validate_schema(event: &NostrEvent, expected: &str) -> bool {\n    let content = event.content.trim();\n    let parsed: serde_json::Value = match serde_json::from_str(content) {\n        Ok(value) => value,\n        Err(_) => return false,\n    };\n    let schema = match parsed.get(\"schema\").and_then(|value| value.as_str()) {\n        Some(value) => value,\n        None => return false,\n    };\n    schema == expected\n}\n\nfn validate_scope(scope: &str, allow_public: bool) -> bool {\n    match scope {\n        \"friend_plus\" | \"friend\" | \"invite\" => true,\n        \"public\" => allow_public,\n        _ => false,\n    }\n}\n\nfn validate_kip_tags(event: &NostrEvent) -> bool {\n    let namespace = match require_tag_value(event, \"k\") {\n        Some(value) => value.trim(),\n        None => return false,\n    };\n    if namespace != KIP_NAMESPACE {\n        return false;\n    }\n    let version = match require_tag_value(event, \"ver\") {\n        Some(value) => value.trim(),\n        None => return false,\n    };\n    if version != KIP_VERSION {\n        return false;\n    }\n    true\n}\n\nfn validate_kip_requirements(event: &NostrEvent, expected_kind: u16, now: i64) -> bool {\n    match expected_kind {\n        NODE_DESCRIPTOR_KIND => {\n            if require_tag_value(event, \"d\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_NODE_DESCRIPTOR_SCHEMA) {\n                return false;\n            }\n        }\n        TOPIC_SERVICE_KIND => {\n            if require_tag_value(event, \"d\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"t\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"role\").is_none() {\n                return false;\n            }\n            let scope = match require_tag_value(event, \"scope\") {\n                Some(value) => value.trim(),\n                None => return false,\n            };\n            if !validate_scope(scope.trim(), true) {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_TOPIC_SERVICE_SCHEMA) {\n                return false;\n            }\n        }\n        LABEL_KIND => {\n            if require_tag_value(event, \"target\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"label\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"policy_url\").is_none()\n                && require_tag_value(event, \"policy\").is_none()\n            {\n                return false;\n            }\n            if has_tag(event, \"policy_ref\") && require_tag_value(event, \"policy_ref\").is_none() {\n                return false;\n            }\n        }\n        ATTESTATION_KIND => {\n            let sub_tag = match event_tag(event, \"sub\") {\n                Some(tag) => tag,\n                None => return false,\n            };\n            if sub_tag.len() < 3 {\n                return false;\n            }\n            if sub_tag\n                .get(1)\n                .map(|value| value.trim().is_empty())\n                .unwrap_or(true)\n                || sub_tag\n                    .get(2)\n                    .map(|value| value.trim().is_empty())\n                    .unwrap_or(true)\n            {\n                return false;\n            }\n            if require_tag_value(event, \"claim\").is_none() {\n                return false;\n            }\n            if require_exp_tag(event, now).is_none() {\n                return false;\n            }\n            if !validate_schema(event, KIP_ATTESTATION_SCHEMA) {\n                return false;\n            }\n        }\n        TRUST_ANCHOR_KIND => {\n            if require_tag_value(event, \"attester\").is_none() {\n                return false;\n            }\n            if require_tag_value(event, \"weight\").is_none() {\n                return false;\n            }\n        }\n        _ => return false,\n    }\n    true\n}\n\nfn should_refresh_bootstrap(entry: &BootstrapCacheEntry, now: i64) -> bool {\n    if entry.stale {\n        return true;\n    }\n    if let Some(next_refresh_at) = entry.next_refresh_at {\n        if next_refresh_at <= now {\n            return true;\n        }\n    }\n    false\n}\n\nfn sanitize_bootstrap_items(\n    expected_kind: u16,\n    items: &[serde_json::Value],\n    now: i64,\n    topic_filter: Option<&str>,\n) -> Vec<serde_json::Value> {\n    let mut map: HashMap<String, (NostrEvent, serde_json::Value)> = HashMap::new();\n\n    for item in items {\n        let Some(event) = validate_kip_event_json(item, expected_kind, None, now) else {\n            continue;\n        };\n        if let Some(topic) = topic_filter {\n            if event_tag_value(&event, \"t\") != Some(topic) {\n                continue;\n            }\n        }\n        let Some(key) = addressable_key(&event) else {\n            continue;\n        };\n        let replace = match map.get(&key) {\n            Some((existing, _)) => is_newer_addressable(&event, existing),\n            None => true,\n        };\n        if replace {\n            map.insert(key, (event, item.clone()));\n        }\n    }\n\n    let mut entries: Vec<(NostrEvent, serde_json::Value)> = map.into_values().collect();\n    entries.sort_by(|(left, _), (right, _)| {\n        let left_ts = left.created_at.as_secs();\n        let right_ts = right.created_at.as_secs();\n        match right_ts.cmp(&left_ts) {\n            Ordering::Equal => left.id.to_string().cmp(&right.id.to_string()),\n            other => other,\n        }\n    });\n\n    entries.into_iter().map(|(_, value)| value).collect()\n}\n\nfn merge_bootstrap_entry(\n    entry: &mut BootstrapCacheEntry,\n    expected_kind: u16,\n    event: &NostrEvent,\n    event_json: serde_json::Value,\n    exp: Option<i64>,\n    now: i64,\n    topic_filter: Option<&str>,\n) {\n    let mut items = sanitize_bootstrap_items(expected_kind, &entry.items, now, topic_filter);\n    insert_or_replace_addressable(&mut items, event, event_json);\n    entry.items = items;\n    entry.updated_at = Some(now);\n    entry.stale = true;\n    if let Some(exp) = exp {\n        entry.next_refresh_at = Some(match entry.next_refresh_at {\n            Some(current) => current.min(exp),\n            None => exp,\n        });\n    }\n}\n\nfn insert_or_replace_addressable(\n    items: &mut Vec<serde_json::Value>,\n    event: &NostrEvent,\n    event_json: serde_json::Value,\n) {\n    let Some(key) = addressable_key(event) else {\n        return;\n    };\n\n    for item in items.iter_mut() {\n        let Ok(existing) = serde_json::from_value::<NostrEvent>(item.clone()) else {\n            continue;\n        };\n        if addressable_key(&existing).as_deref() != Some(&key) {\n            continue;\n        }\n        if is_newer_addressable(event, &existing) {\n            *item = event_json;\n        }\n        return;\n    }\n\n    items.push(event_json);\n}\n\nfn addressable_key(event: &NostrEvent) -> Option<String> {\n    let d_tag = event_tag_value(event, \"d\")?;\n    Some(format!(\n        \"{}:{}:{}\",\n        event.kind.as_u16(),\n        event.pubkey,\n        d_tag\n    ))\n}\n\nfn is_newer_addressable(candidate: &NostrEvent, existing: &NostrEvent) -> bool {\n    let candidate_ts = candidate.created_at.as_secs();\n    let existing_ts = existing.created_at.as_secs();\n    match candidate_ts.cmp(&existing_ts) {\n        Ordering::Greater => true,\n        Ordering::Less => false,\n        Ordering::Equal => candidate.id.to_string() < existing.id.to_string(),\n    }\n}\n\nfn config_response(config: &CommunityNodeConfig) -> CommunityNodeConfigResponse {\n    CommunityNodeConfigResponse {\n        nodes: config\n            .nodes\n            .iter()\n            .map(|node| {\n                crate::presentation::dto::community_node_dto::CommunityNodeConfigNodeResponse {\n                    base_url: node.base_url.clone(),\n                    roles: node.roles.clone(),\n                    has_token: node.access_token.is_some(),\n                    token_expires_at: node.token_expires_at,\n                    pubkey: node.pubkey.clone(),\n                }\n            })\n            .collect(),\n    }\n}\n\nfn build_auth_event(base_url: &str, challenge: &str, nsec: &str) -> Result<NostrEvent, AppError> {\n    let secret_key =\n        SecretKey::from_bech32(nsec).map_err(|err| AppError::Crypto(err.to_string()))?;\n    let keys = Keys::new(secret_key);\n    let tags = vec![\n        Tag::parse([\"relay\", base_url]).map_err(|err| AppError::NostrError(err.to_string()))?,\n        Tag::parse([\"challenge\", challenge])\n            .map_err(|err| AppError::NostrError(err.to_string()))?,\n    ];\n    let event = EventBuilder::new(Kind::Custom(AUTH_KIND), \"\")\n        .tags(tags)\n        .sign_with_keys(&keys)?;\n    Ok(event)\n}\n\nasync fn request_json<T: DeserializeOwned>(\n    builder: reqwest::RequestBuilder,\n) -> Result<T, AppError> {\n    let response = builder\n        .send()\n        .await\n        .map_err(|err| AppError::Network(err.to_string()))?;\n    let status = response.status();\n    let headers = response.headers().clone();\n    let body = response\n        .text()\n        .await\n        .map_err(|err| AppError::Network(err.to_string()))?;\n    if !status.is_success() {\n        if status == StatusCode::TOO_MANY_REQUESTS {\n            let retry_after = headers\n                .get(\"Retry-After\")\n                .and_then(|value| value.to_str().ok())\n                .and_then(|value| value.parse::<u64>().ok())\n                .unwrap_or(60);\n            return Err(AppError::rate_limited(\n                \"Community node rate limited\",\n                retry_after,\n            ));\n        }\n        return Err(AppError::Network(format!(\n            \"Community node error ({status}): {body}\"\n        )));\n    }\n    serde_json::from_str(&body).map_err(|err| AppError::DeserializationError(err.to_string()))\n}\n\n#[cfg(test)]\nmod community_node_validation_tests {\n    use super::*;\n    use nostr_sdk::prelude::{EventBuilder, Keys, Kind, Tag};\n\n    fn build_event_json(\n        keys: &Keys,\n        kind: u16,\n        tags: Vec<Tag>,\n        content: &str,\n    ) -> serde_json::Value {\n        let event = EventBuilder::new(Kind::Custom(kind), content)\n            .tags(tags)\n            .sign_with_keys(keys)\n            .expect(\"signed\");\n        serde_json::to_value(event).expect(\"event json\")\n    }\n\n    fn build_label_tags(exp: i64) -> Vec<Tag> {\n        let exp_str = exp.to_string();\n        vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n            Tag::parse([\"target\", \"event:deadbeef\"]).expect(\"target\"),\n            Tag::parse([\"label\", \"spam\"]).expect(\"label\"),\n            Tag::parse([\"policy_url\", \"https://example.com/policy\"]).expect(\"policy_url\"),\n        ]\n    }\n\n    fn build_label_event_json(keys: &Keys, exp: i64) -> serde_json::Value {\n        build_event_json(keys, LABEL_KIND, build_label_tags(exp), \"\")\n    }\n\n    fn build_node_descriptor_event_json(keys: &Keys, exp: i64, schema: &str) -> serde_json::Value {\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"d\", \"descriptor\"]).expect(\"d\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({ \"schema\": schema }).to_string();\n        build_event_json(keys, NODE_DESCRIPTOR_KIND, tags, content.as_str())\n    }\n\n    #[test]\n    fn validate_kip_event_json_accepts_valid_label() {\n        let keys = Keys::generate();\n        let pubkey = keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(pubkey.as_str()), now);\n        assert!(validated.is_some());\n    }\n\n    #[test]\n    fn validate_kip_event_json_accepts_without_expected_pubkey() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_some());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_expired_event() {\n        let keys = Keys::generate();\n        let pubkey = keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now - 1);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(pubkey.as_str()), now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_wrong_pubkey() {\n        let keys = Keys::generate();\n        let other_keys = Keys::generate();\n        let other_pubkey = other_keys.public_key().to_string();\n        let now = 1000;\n        let event_json = build_label_event_json(&keys, now + 60);\n        let validated =\n            validate_kip_event_json(&event_json, LABEL_KIND, Some(other_pubkey.as_str()), now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_k_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"k\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_ver_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"ver\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_missing_policy_tag() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let mut tags = build_label_tags(now + 60);\n        tags.retain(|tag| tag.as_slice().first().map(|value| value.as_str()) != Some(\"policy_url\"));\n        let event_json = build_event_json(&keys, LABEL_KIND, tags, \"\");\n        let validated = validate_kip_event_json(&event_json, LABEL_KIND, None, now);\n        assert!(validated.is_none());\n    }\n\n    #[test]\n    fn validate_kip_event_json_rejects_invalid_schema() {\n        let keys = Keys::generate();\n        let now = 1000;\n        let event_json = build_node_descriptor_event_json(&keys, now + 60, \"invalid-schema\");\n        let validated = validate_kip_event_json(&event_json, NODE_DESCRIPTOR_KIND, None, now);\n        assert!(validated.is_none());\n    }\n}\n\n#[cfg(test)]\nmod community_node_handler_tests {\n    use super::*;\n    use crate::application::ports::group_key_store::GroupKeyStore;\n    use crate::infrastructure::crypto::DefaultKeyManager;\n    use crate::infrastructure::storage::{SecureGroupKeyStore, SecureStorage};\n    use crate::presentation::dto::community_node_dto::CommunityNodeConfigNodeRequest;\n    use async_trait::async_trait;\n    use chrono::Utc;\n    use std::collections::HashMap;\n    use std::sync::mpsc;\n    use std::thread;\n    use std::time::Duration;\n    use tiny_http::{Header, Response, Server};\n    use tokio::sync::Mutex;\n\n    #[derive(Default)]\n    struct InMemorySecureStorage {\n        entries: Mutex<HashMap<String, String>>,\n    }\n\n    #[async_trait]\n    impl SecureStorage for InMemorySecureStorage {\n        async fn store(\n            &self,\n            key: &str,\n            value: &str,\n        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries\n                .lock()\n                .await\n                .insert(key.to_string(), value.to_string());\n            Ok(())\n        }\n\n        async fn retrieve(\n            &self,\n            key: &str,\n        ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.get(key).cloned())\n        }\n\n        async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries.lock().await.remove(key);\n            Ok(())\n        }\n\n        async fn exists(\n            &self,\n            key: &str,\n        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.contains_key(key))\n        }\n\n        async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(self.entries.lock().await.keys().cloned().collect())\n        }\n\n        async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            self.entries.lock().await.clear();\n            Ok(())\n        }\n    }\n\n    fn test_handler() -> CommunityNodeHandler {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        CommunityNodeHandler::new(key_manager, secure_storage, group_key_store)\n    }\n\n    fn to_domain_event(event: &NostrEvent) -> crate::domain::entities::Event {\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(event.created_at.as_secs() as i64, 0)\n                .expect(\"timestamp\");\n        crate::domain::entities::Event {\n            id: event.id.to_string(),\n            pubkey: event.pubkey.to_string(),\n            created_at,\n            kind: event.kind.as_u16() as u32,\n            tags: event\n                .tags\n                .iter()\n                .map(|tag| tag.as_slice().to_vec())\n                .collect(),\n            content: event.content.clone(),\n            sig: event.sig.to_string(),\n        }\n    }\n\n    #[derive(Debug)]\n    struct CapturedRequest {\n        path: String,\n        params: HashMap<String, String>,\n    }\n\n    fn spawn_json_server(\n        response_body: serde_json::Value,\n    ) -> (\n        String,\n        mpsc::Receiver<CapturedRequest>,\n        thread::JoinHandle<()>,\n    ) {\n        let server = Server::http(\"127.0.0.1:0\").expect(\"server\");\n        let base_url = format!(\"http://{}\", server.server_addr());\n        let (tx, rx) = mpsc::channel();\n        let handle = thread::spawn(move || {\n            for request in server.incoming_requests().take(1) {\n                let url = request.url();\n                let parsed = Url::parse(&format!(\"http://localhost{url}\")).expect(\"request url\");\n                let params = parsed\n                    .query_pairs()\n                    .map(|(key, value)| (key.to_string(), value.to_string()))\n                    .collect();\n                let captured = CapturedRequest {\n                    path: parsed.path().to_string(),\n                    params,\n                };\n                let _ = tx.send(captured);\n\n                let mut response = Response::from_string(response_body.to_string());\n                response.add_header(\n                    Header::from_bytes(\"Content-Type\", \"application/json\").expect(\"header\"),\n                );\n                let _ = request.respond(response);\n            }\n        });\n        (base_url, rx, handle)\n    }\n\n    fn build_config_node(\n        base_url: String,\n        roles: CommunityNodeRoleConfig,\n    ) -> CommunityNodeConfigNode {\n        let mut node = CommunityNodeConfigNode::new(base_url, roles);\n        node.access_token = Some(\"test-token\".to_string());\n        node.token_expires_at = Some(Utc::now().timestamp() + 600);\n        node\n    }\n\n    fn build_attestation_event(exp: i64) -> serde_json::Value {\n        let keys = Keys::generate();\n        let exp_str = exp.to_string();\n        let subject = keys.public_key().to_string();\n        let tags = vec![\n            Tag::parse([\"k\", KIP_NAMESPACE]).expect(\"k\"),\n            Tag::parse([\"ver\", KIP_VERSION]).expect(\"ver\"),\n            Tag::parse([\"sub\", \"pubkey\", subject.as_str()]).expect(\"sub\"),\n            Tag::parse([\"claim\", \"reputation\"]).expect(\"claim\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({\n            \"schema\": KIP_ATTESTATION_SCHEMA,\n            \"subject\": format!(\"pubkey:{subject}\"),\n            \"claim\": \"reputation\",\n            \"value\": { \"score\": 0.5 },\n            \"expires\": exp\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(ATTESTATION_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        serde_json::to_value(event).expect(\"event json\")\n    }\n\n    #[tokio::test]\n    async fn set_config_normalizes_and_deduplicates_nodes() {\n        let handler = test_handler();\n        let request = CommunityNodeConfigRequest {\n            nodes: vec![\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://example.com/\".to_string(),\n                    roles: Some(CommunityNodeRoleConfig {\n                        labels: true,\n                        trust: false,\n                        search: true,\n                        bootstrap: false,\n                    }),\n                },\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://example.com\".to_string(),\n                    roles: None,\n                },\n                CommunityNodeConfigNodeRequest {\n                    base_url: \"https://node2.example.com\".to_string(),\n                    roles: None,\n                },\n            ],\n        };\n\n        let response = handler.set_config(request).await.expect(\"set config\");\n        assert_eq!(response.nodes.len(), 2);\n        assert_eq!(response.nodes[0].base_url, \"https://example.com\");\n        assert_eq!(response.nodes[1].base_url, \"https://node2.example.com\");\n        assert!(response.nodes[0].roles.search);\n        assert!(!response.nodes[0].roles.bootstrap);\n\n        let loaded = handler.get_config().await.expect(\"get config\");\n        assert!(loaded.is_some());\n    }\n\n    #[tokio::test]\n    async fn trust_anchor_roundtrip() {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let keypair = key_manager.generate_keypair().await.expect(\"keypair\");\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        let handler = CommunityNodeHandler::new(key_manager, secure_storage, group_key_store);\n\n        let request = CommunityNodeTrustAnchorRequest {\n            attester: keypair.public_key.clone(),\n            claim: Some(\"trust:v1\".to_string()),\n            topic: Some(\"kukuri:topic1\".to_string()),\n            weight: Some(0.6),\n        };\n        let stored = handler.set_trust_anchor(request).await.expect(\"set\");\n        let loaded = handler\n            .get_trust_anchor()\n            .await\n            .expect(\"get\")\n            .expect(\"stored\");\n        assert_eq!(loaded.attester, stored.attester);\n        assert_eq!(loaded.weight, 0.6);\n        assert_eq!(loaded.claim, Some(\"trust:v1\".to_string()));\n        assert_eq!(loaded.topic, Some(\"kukuri:topic1\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn trust_anchor_rejects_invalid_weight() {\n        let key_manager = Arc::new(DefaultKeyManager::new());\n        let keypair = key_manager.generate_keypair().await.expect(\"keypair\");\n        let secure_storage = Arc::new(InMemorySecureStorage::default());\n        let group_key_store =\n            Arc::new(SecureGroupKeyStore::new(secure_storage.clone())) as Arc<dyn GroupKeyStore>;\n        let handler = CommunityNodeHandler::new(key_manager, secure_storage, group_key_store);\n\n        let request = CommunityNodeTrustAnchorRequest {\n            attester: keypair.public_key.clone(),\n            claim: None,\n            topic: None,\n            weight: Some(1.5),\n        };\n        assert!(handler.set_trust_anchor(request).await.is_err());\n    }\n\n    #[tokio::test]\n    async fn ingest_bootstrap_descriptor_populates_cache() {\n        let handler = test_handler();\n        let keys = Keys::generate();\n        let now = Utc::now().timestamp();\n        let exp = now + 600;\n\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"d\", \"descriptor\"]).expect(\"d\"),\n            Tag::parse([\"k\", \"kukuri\"]).expect(\"k\"),\n            Tag::parse([\"ver\", \"1\"]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n            Tag::parse([\"role\", \"bootstrap\"]).expect(\"role\"),\n        ];\n        let content = json!({\n            \"schema\": \"kukuri-node-desc-v1\",\n            \"name\": \"Test Node\",\n            \"roles\": [\"bootstrap\"],\n            \"endpoints\": { \"http\": \"https://node.example\" }\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(NODE_DESCRIPTOR_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        let domain_event = to_domain_event(&event);\n\n        handler\n            .ingest_bootstrap_event(&domain_event)\n            .await\n            .expect(\"ingest\");\n\n        let response = handler.list_bootstrap_nodes().await.expect(\"list\");\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items array\");\n        assert!(!items.is_empty());\n    }\n\n    #[tokio::test]\n    async fn ingest_bootstrap_topic_service_populates_cache() {\n        let handler = test_handler();\n        let keys = Keys::generate();\n        let now = Utc::now().timestamp();\n        let exp = now + 600;\n        let topic_id = \"kukuri:topic1\";\n        let d_tag = format!(\"topic_service:{topic_id}:bootstrap:public\");\n\n        let exp_str = exp.to_string();\n        let tags = vec![\n            Tag::parse([\"d\", d_tag.as_str()]).expect(\"d\"),\n            Tag::parse([\"t\", topic_id]).expect(\"t\"),\n            Tag::parse([\"role\", \"bootstrap\"]).expect(\"role\"),\n            Tag::parse([\"scope\", \"public\"]).expect(\"scope\"),\n            Tag::parse([\"k\", \"kukuri\"]).expect(\"k\"),\n            Tag::parse([\"ver\", \"1\"]).expect(\"ver\"),\n            Tag::parse([\"exp\", exp_str.as_str()]).expect(\"exp\"),\n        ];\n        let content = json!({\n            \"schema\": \"kukuri-topic-service-v1\",\n            \"topic\": topic_id,\n            \"role\": \"bootstrap\",\n            \"scope\": \"public\"\n        })\n        .to_string();\n        let event = EventBuilder::new(Kind::Custom(TOPIC_SERVICE_KIND), content)\n            .tags(tags)\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        let domain_event = to_domain_event(&event);\n\n        handler\n            .ingest_bootstrap_event(&domain_event)\n            .await\n            .expect(\"ingest\");\n\n        let response = handler\n            .list_bootstrap_services(CommunityNodeBootstrapServicesRequest {\n                base_url: None,\n                topic_id: topic_id.to_string(),\n            })\n            .await\n            .expect(\"list services\");\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items array\");\n        assert!(!items.is_empty());\n    }\n\n    #[tokio::test]\n    async fn trust_report_based_aggregates_scores_across_nodes() {\n        let exp = Utc::now().timestamp() + 600;\n        let event_json = build_attestation_event(exp);\n        let response1 = json!({\n            \"score\": 0.2,\n            \"attestation\": { \"exp\": exp, \"event_json\": event_json.clone() }\n        });\n        let response2 = json!({\n            \"score\": 0.6,\n            \"attestation\": { \"exp\": exp, \"event_json\": event_json }\n        });\n\n        let (base_url1, rx1, handle1) = spawn_json_server(response1);\n        let (base_url2, rx2, handle2) = spawn_json_server(response2);\n\n        let handler = test_handler();\n        let roles = CommunityNodeRoleConfig {\n            labels: false,\n            trust: true,\n            search: false,\n            bootstrap: false,\n        };\n        let config = CommunityNodeConfig {\n            nodes: vec![\n                build_config_node(base_url1.clone(), roles.clone()),\n                build_config_node(base_url2.clone(), roles),\n            ],\n        };\n        handler.save_config(&config).await.expect(\"save config\");\n\n        let response = handler\n            .trust_report_based(CommunityNodeTrustRequest {\n                base_url: None,\n                subject: \"npub1testsubject\".to_string(),\n            })\n            .await\n            .expect(\"trust response\");\n\n        let score = response\n            .get(\"score\")\n            .and_then(|value| value.as_f64())\n            .expect(\"score\");\n        assert!((score - 0.4).abs() < 1e-9);\n\n        let sources = response\n            .get(\"sources\")\n            .and_then(|value| value.as_array())\n            .expect(\"sources\");\n        assert_eq!(sources.len(), 2);\n        assert!(sources.iter().any(|value| {\n            value.get(\"base_url\") == Some(&serde_json::Value::String(base_url1.clone()))\n                && value.get(\"score\") == Some(&serde_json::Value::from(0.2))\n        }));\n        assert!(sources.iter().any(|value| {\n            value.get(\"base_url\") == Some(&serde_json::Value::String(base_url2.clone()))\n                && value.get(\"score\") == Some(&serde_json::Value::from(0.6))\n        }));\n\n        let req1 = rx1.recv_timeout(Duration::from_secs(2)).expect(\"request 1\");\n        assert_eq!(req1.path, \"/v1/trust/report-based\");\n        assert_eq!(\n            req1.params.get(\"subject\"),\n            Some(&\"npub1testsubject\".to_string())\n        );\n\n        let req2 = rx2.recv_timeout(Duration::from_secs(2)).expect(\"request 2\");\n        assert_eq!(req2.path, \"/v1/trust/report-based\");\n        assert_eq!(\n            req2.params.get(\"subject\"),\n            Some(&\"npub1testsubject\".to_string())\n        );\n\n        handle1.join().expect(\"server1\");\n        handle2.join().expect(\"server2\");\n    }\n\n    #[tokio::test]\n    async fn search_aggregates_items_and_composes_cursor_for_multiple_nodes() {\n        let response1 = json!({\n            \"items\": [ { \"id\": \"a\" } ],\n            \"next_cursor\": \"next-1\",\n            \"total\": 2\n        });\n        let response2 = json!({\n            \"items\": [ { \"id\": \"b\" }, { \"id\": \"c\" } ],\n            \"next_cursor\": \"next-2\",\n            \"total\": 3\n        });\n\n        let (base_url1, rx1, handle1) = spawn_json_server(response1);\n        let (base_url2, rx2, handle2) = spawn_json_server(response2);\n\n        let handler = test_handler();\n        let roles = CommunityNodeRoleConfig {\n            labels: false,\n            trust: false,\n            search: true,\n            bootstrap: false,\n        };\n        let config = CommunityNodeConfig {\n            nodes: vec![\n                build_config_node(base_url1.clone(), roles.clone()),\n                build_config_node(base_url2.clone(), roles),\n            ],\n        };\n        handler.save_config(&config).await.expect(\"save config\");\n\n        let mut cursor_map = HashMap::new();\n        cursor_map.insert(base_url1.clone(), \"cursor-1\".to_string());\n        cursor_map.insert(base_url2.clone(), \"cursor-2\".to_string());\n        let cursor = serde_json::to_string(&cursor_map).expect(\"cursor map\");\n        let response = handler\n            .search(CommunityNodeSearchRequest {\n                base_url: None,\n                topic: \"kukuri:topic1\".to_string(),\n                q: Some(\"rust\".to_string()),\n                limit: Some(5),\n                cursor: Some(cursor),\n            })\n            .await\n            .expect(\"search\");\n\n        let items = response\n            .get(\"items\")\n            .and_then(|value| value.as_array())\n            .expect(\"items\");\n        assert_eq!(items.len(), 3);\n\n        let total = response\n            .get(\"total\")\n            .and_then(|value| value.as_i64())\n            .expect(\"total\");\n        assert_eq!(total, 5);\n\n        assert_eq!(\n            response.get(\"topic\"),\n            Some(&serde_json::Value::String(\"kukuri:topic1\".to_string()))\n        );\n        assert_eq!(\n            response.get(\"query\"),\n            Some(&serde_json::Value::String(\"rust\".to_string()))\n        );\n\n        let next_cursor = response\n            .get(\"next_cursor\")\n            .and_then(|value| value.as_str())\n            .expect(\"next_cursor\");\n        let cursor_map: HashMap<String, String> =\n            serde_json::from_str(next_cursor).expect(\"cursor map\");\n        assert_eq!(cursor_map.get(&base_url1), Some(&\"next-1\".to_string()));\n        assert_eq!(cursor_map.get(&base_url2), Some(&\"next-2\".to_string()));\n\n        let req1 = rx1.recv_timeout(Duration::from_secs(2)).expect(\"request 1\");\n        assert_eq!(req1.path, \"/v1/search\");\n        assert_eq!(req1.params.get(\"topic\"), Some(&\"kukuri:topic1\".to_string()));\n        assert_eq!(req1.params.get(\"q\"), Some(&\"rust\".to_string()));\n        assert_eq!(req1.params.get(\"limit\"), Some(&\"5\".to_string()));\n        assert_eq!(req1.params.get(\"cursor\"), Some(&\"cursor-1\".to_string()));\n\n        let req2 = rx2.recv_timeout(Duration::from_secs(2)).expect(\"request 2\");\n        assert_eq!(req2.path, \"/v1/search\");\n        assert_eq!(req2.params.get(\"topic\"), Some(&\"kukuri:topic1\".to_string()));\n        assert_eq!(req2.params.get(\"q\"), Some(&\"rust\".to_string()));\n        assert_eq!(req2.params.get(\"limit\"), Some(&\"5\".to_string()));\n        assert_eq!(req2.params.get(\"cursor\"), Some(&\"cursor-2\".to_string()));\n\n        handle1.join().expect(\"server1\");\n        handle2.join().expect(\"server2\");\n    }\n}\n","traces":[{"line":57,"address":[12651840],"length":1,"stats":{"Line":1}},{"line":107,"address":[23139584],"length":1,"stats":{"Line":1}},{"line":109,"address":[23026883],"length":1,"stats":{"Line":1}},{"line":110,"address":[23040669],"length":1,"stats":{"Line":1}},{"line":111,"address":[23033720],"length":1,"stats":{"Line":1}},{"line":112,"address":[17281267],"length":1,"stats":{"Line":1}},{"line":113,"address":[23143608],"length":1,"stats":{"Line":1}},{"line":114,"address":[17281276],"length":1,"stats":{"Line":1}},{"line":163,"address":[12713087,12712832,12713046],"length":1,"stats":{"Line":1}},{"line":172,"address":[12719844],"length":1,"stats":{"Line":1}},{"line":176,"address":[12645296],"length":1,"stats":{"Line":1}},{"line":180,"address":[11699388,11699460],"length":1,"stats":{"Line":2}},{"line":181,"address":[12639366],"length":1,"stats":{"Line":1}},{"line":182,"address":[12756071,12756313,12756265,12756141,12759235],"length":1,"stats":{"Line":3}},{"line":183,"address":[20417405,20414761],"length":1,"stats":{"Line":0}},{"line":186,"address":[12756461],"length":1,"stats":{"Line":1}},{"line":187,"address":[12646661],"length":1,"stats":{"Line":1}},{"line":188,"address":[12714650,12714839,12714785,12714540],"length":1,"stats":{"Line":4}},{"line":189,"address":[12853894,12853359,12853716],"length":1,"stats":{"Line":2}},{"line":190,"address":[15220193,15220036],"length":1,"stats":{"Line":2}},{"line":193,"address":[20416004,20415934],"length":1,"stats":{"Line":2}},{"line":194,"address":[12854124],"length":1,"stats":{"Line":1}},{"line":195,"address":[12641127,12641214],"length":1,"stats":{"Line":2}},{"line":197,"address":[12854336,12856496,12856520],"length":1,"stats":{"Line":3}},{"line":198,"address":[12648596,12648072,12648148],"length":1,"stats":{"Line":2}},{"line":199,"address":[12655202],"length":1,"stats":{"Line":0}},{"line":200,"address":[12641592],"length":1,"stats":{"Line":0}},{"line":201,"address":[12648430],"length":1,"stats":{"Line":0}},{"line":203,"address":[12723337,12722890],"length":1,"stats":{"Line":1}},{"line":204,"address":[12641940],"length":1,"stats":{"Line":1}},{"line":205,"address":[12754658],"length":1,"stats":{"Line":1}},{"line":207,"address":[12756947],"length":1,"stats":{"Line":1}},{"line":208,"address":[12761479,12757103,12758750,12761228,12760942],"length":1,"stats":{"Line":1}},{"line":209,"address":[12724545,12724432],"length":1,"stats":{"Line":2}},{"line":212,"address":[12757491,12756528,12756336,12756344,12756491,12756654,12756403,12756368],"length":1,"stats":{"Line":4}},{"line":213,"address":[12650655,12650598,12651644,12650552,12650766],"length":1,"stats":{"Line":2}},{"line":214,"address":[12719388],"length":1,"stats":{"Line":0}},{"line":216,"address":[12725983,12726067],"length":1,"stats":{"Line":2}},{"line":217,"address":[12857659],"length":1,"stats":{"Line":0}},{"line":219,"address":[12726073,12726171],"length":1,"stats":{"Line":2}},{"line":222,"address":[15223952,15223936,15224109,15224173,15223944,15224337,15224908,15223999],"length":1,"stats":{"Line":0}},{"line":223,"address":[12726524,12726753,12727034,12727348,12727190,12726682,12726920],"length":1,"stats":{"Line":0}},{"line":225,"address":[12658831,12659202,12659009,12658962,12659069],"length":1,"stats":{"Line":0}},{"line":226,"address":[12652406,12652912,12652936],"length":1,"stats":{"Line":0}},{"line":227,"address":[12762225,12762354,12762425,12762623],"length":1,"stats":{"Line":0}},{"line":230,"address":[12645801,12646031,12645754,12645893,12645092],"length":1,"stats":{"Line":0}},{"line":231,"address":[12758816],"length":1,"stats":{"Line":0}},{"line":234,"address":[12655010,12653155,12654921,12653072,12653264,12653756,12653080,12653120],"length":1,"stats":{"Line":0}},{"line":235,"address":[12721185,12721046,12721336,12721539],"length":1,"stats":{"Line":0}},{"line":236,"address":[20421483,20421692,20422334,20423111,20421980,20421844],"length":1,"stats":{"Line":0}},{"line":237,"address":[12721909,12722095,12722223],"length":1,"stats":{"Line":0}},{"line":238,"address":[12729241,12729125],"length":1,"stats":{"Line":0}},{"line":239,"address":[12760517],"length":1,"stats":{"Line":0}},{"line":240,"address":[12760562],"length":1,"stats":{"Line":0}},{"line":241,"address":[11592444],"length":1,"stats":{"Line":0}},{"line":244,"address":[20423536],"length":1,"stats":{"Line":1}},{"line":247,"address":[12765333,12765805,12765460,12765531,12765713,12766071,12767514],"length":1,"stats":{"Line":5}},{"line":250,"address":[11024948],"length":1,"stats":{"Line":3}},{"line":251,"address":[12663143,12664640,12664664],"length":1,"stats":{"Line":0}},{"line":252,"address":[12762172,12762050],"length":1,"stats":{"Line":2}},{"line":253,"address":[12767817],"length":1,"stats":{"Line":0}},{"line":255,"address":[12862711,12863305,12862585],"length":1,"stats":{"Line":2}},{"line":256,"address":[12762889,12763744,12763762],"length":1,"stats":{"Line":0}},{"line":257,"address":[12768303,12768599],"length":1,"stats":{"Line":2}},{"line":260,"address":[12732720],"length":1,"stats":{"Line":1}},{"line":264,"address":[12658640,12658462],"length":1,"stats":{"Line":2}},{"line":265,"address":[12768660,12768576],"length":1,"stats":{"Line":2}},{"line":266,"address":[12771492,12770360],"length":1,"stats":{"Line":0}},{"line":267,"address":[12665824],"length":1,"stats":{"Line":0}},{"line":271,"address":[12659983,12658810,12658914,12659151,12669264],"length":1,"stats":{"Line":2}},{"line":272,"address":[12744130],"length":1,"stats":{"Line":0}},{"line":273,"address":[20437473],"length":1,"stats":{"Line":0}},{"line":274,"address":[12780790],"length":1,"stats":{"Line":0}},{"line":278,"address":[20427236,20427397],"length":1,"stats":{"Line":2}},{"line":279,"address":[12727017,12727110],"length":1,"stats":{"Line":2}},{"line":280,"address":[12765180,12765362],"length":1,"stats":{"Line":2}},{"line":281,"address":[12666228],"length":1,"stats":{"Line":1}},{"line":286,"address":[15231594,15231395],"length":1,"stats":{"Line":2}},{"line":287,"address":[12659573,12659723],"length":1,"stats":{"Line":2}},{"line":289,"address":[12660669,12667301,12660073,12658527,12659738,12659841],"length":1,"stats":{"Line":2}},{"line":290,"address":[12772132,12772340,12778762,12772649],"length":1,"stats":{"Line":2}},{"line":291,"address":[12654313,12662640,12662662],"length":1,"stats":{"Line":0}},{"line":292,"address":[12728825],"length":1,"stats":{"Line":1}},{"line":293,"address":[15233224,15238174,15233403,15234583,15233766,15234933,15234098,15234508,15234816,15235250,15233310,15238478],"length":1,"stats":{"Line":5}},{"line":294,"address":[12767254,12767692,12767379],"length":1,"stats":{"Line":2}},{"line":295,"address":[12971888,12971906,12729532],"length":1,"stats":{"Line":0}},{"line":296,"address":[12729661,12729448,12729931],"length":1,"stats":{"Line":2}},{"line":297,"address":[13014080,12771931,13014098],"length":1,"stats":{"Line":0}},{"line":298,"address":[12655436,12655250,12655768],"length":1,"stats":{"Line":2}},{"line":299,"address":[12979122,12979104,12737240],"length":1,"stats":{"Line":0}},{"line":300,"address":[12737203,12737377,12737721,12737460],"length":1,"stats":{"Line":3}},{"line":301,"address":[12911506,12911488,12669913],"length":1,"stats":{"Line":0}},{"line":303,"address":[12769349],"length":1,"stats":{"Line":1}},{"line":304,"address":[12663935,12663524,12663835],"length":1,"stats":{"Line":3}},{"line":305,"address":[12738676,12738358,12738637,12738282],"length":1,"stats":{"Line":2}},{"line":306,"address":[12775600,12769773,12775618],"length":1,"stats":{"Line":0}},{"line":309,"address":[12773425,12773832],"length":1,"stats":{"Line":2}},{"line":310,"address":[12664371,12664029,12664471],"length":1,"stats":{"Line":3}},{"line":311,"address":[12870446,12870677,12870339,12870764,12876112,12876130],"length":1,"stats":{"Line":2}},{"line":315,"address":[12775578,12776104,12776357,12776038,12777854],"length":1,"stats":{"Line":3}},{"line":316,"address":[12657697],"length":1,"stats":{"Line":1}},{"line":317,"address":[12671781,12671545],"length":1,"stats":{"Line":1}},{"line":318,"address":[12732576,12734112,12732764,12733000],"length":1,"stats":{"Line":2}},{"line":319,"address":[20438178,20433336,20438160],"length":1,"stats":{"Line":0}},{"line":320,"address":[12871402,12871570],"length":1,"stats":{"Line":2}},{"line":330,"address":[12733475,12733557,12733794,12734081],"length":1,"stats":{"Line":2}},{"line":331,"address":[12777442,12781632,12781650],"length":1,"stats":{"Line":0}},{"line":332,"address":[12773473,12771818,12772137,12773343,12773777,12772066],"length":1,"stats":{"Line":5}},{"line":333,"address":[12740830],"length":1,"stats":{"Line":1}},{"line":334,"address":[11823286],"length":1,"stats":{"Line":3}},{"line":335,"address":[12661025,12663504,12663528],"length":1,"stats":{"Line":0}},{"line":337,"address":[12667894,12667628],"length":1,"stats":{"Line":2}},{"line":340,"address":[15242208,15242330,15242192,15242200,15242243,15242370,15242525,15242924],"length":1,"stats":{"Line":0}},{"line":341,"address":[20439207,20439327,20439105,20438757,20438876,20438947,20439406],"length":1,"stats":{"Line":0}},{"line":343,"address":[11703158],"length":1,"stats":{"Line":0}},{"line":344,"address":[12781088,12780946,12781112],"length":1,"stats":{"Line":0}},{"line":345,"address":[12745816],"length":1,"stats":{"Line":0}},{"line":348,"address":[12877680],"length":1,"stats":{"Line":0}},{"line":352,"address":[12671621,12672019,12672246,12671850],"length":1,"stats":{"Line":0}},{"line":353,"address":[12672702,12672152,12672306,12673262,12671689,12671985],"length":1,"stats":{"Line":0}},{"line":354,"address":[12680213,12679625,12679973,12679835],"length":1,"stats":{"Line":0}},{"line":355,"address":[11709660],"length":1,"stats":{"Line":0}},{"line":356,"address":[20442327,20442556,20442033,20442672,20442884,20442373,20443637],"length":1,"stats":{"Line":0}},{"line":357,"address":[12673861,12674060],"length":1,"stats":{"Line":0}},{"line":358,"address":[11704102],"length":1,"stats":{"Line":0}},{"line":359,"address":[15246955,15246368,15246172,15246695],"length":1,"stats":{"Line":0}},{"line":360,"address":[12739560,12743100,12742904,12743281,12743813,12744519],"length":1,"stats":{"Line":0}},{"line":361,"address":[15247647,15247482],"length":1,"stats":{"Line":0}},{"line":362,"address":[20444503],"length":1,"stats":{"Line":0}},{"line":363,"address":[12683357],"length":1,"stats":{"Line":0}},{"line":364,"address":[11672970],"length":1,"stats":{"Line":0}},{"line":366,"address":[12684043],"length":1,"stats":{"Line":0}},{"line":367,"address":[15248500],"length":1,"stats":{"Line":0}},{"line":368,"address":[12744845],"length":1,"stats":{"Line":0}},{"line":372,"address":[12677640,12677774,12677811,12677962,12678227,12677683,12677632,12677648],"length":1,"stats":{"Line":0}},{"line":373,"address":[12684777,12684970,12684841,12684725],"length":1,"stats":{"Line":0}},{"line":376,"address":[12789744],"length":1,"stats":{"Line":0}},{"line":380,"address":[12788667,12790123,12788793,12788479,12789208,12788543],"length":1,"stats":{"Line":0}},{"line":382,"address":[12790794],"length":1,"stats":{"Line":0}},{"line":383,"address":[12672531],"length":1,"stats":{"Line":0}},{"line":384,"address":[12754263],"length":1,"stats":{"Line":0}},{"line":386,"address":[12791204],"length":1,"stats":{"Line":0}},{"line":387,"address":[12754598],"length":1,"stats":{"Line":0}},{"line":388,"address":[12747700,12747767],"length":1,"stats":{"Line":0}},{"line":389,"address":[12792093,12791929,12791531,12791669],"length":1,"stats":{"Line":0}},{"line":392,"address":[12886475,12886592,12884996,12886809,12886410],"length":1,"stats":{"Line":0}},{"line":394,"address":[12760768,12760791],"length":1,"stats":{"Line":0}},{"line":396,"address":[12689209,12689017,12687626,12687757,12689272],"length":1,"stats":{"Line":0}},{"line":397,"address":[20451562,20450512],"length":1,"stats":{"Line":0}},{"line":400,"address":[12889796],"length":1,"stats":{"Line":0}},{"line":401,"address":[12795480,12795752,12795410,12795232,12795083],"length":1,"stats":{"Line":0}},{"line":403,"address":[11704352],"length":1,"stats":{"Line":0}},{"line":404,"address":[12795642,12796078,12796253],"length":1,"stats":{"Line":0}},{"line":405,"address":[12794185,12794019],"length":1,"stats":{"Line":0}},{"line":406,"address":[12684480,12684388],"length":1,"stats":{"Line":0}},{"line":408,"address":[12796317],"length":1,"stats":{"Line":0}},{"line":409,"address":[15256121,15256333],"length":1,"stats":{"Line":0}},{"line":411,"address":[15256425],"length":1,"stats":{"Line":0}},{"line":412,"address":[12760075,12760283],"length":1,"stats":{"Line":0}},{"line":414,"address":[12687899,12688208,12692631,12685726],"length":1,"stats":{"Line":0}},{"line":415,"address":[12749065],"length":1,"stats":{"Line":0}},{"line":416,"address":[12674724,12679440,12674505,12679449],"length":1,"stats":{"Line":0}},{"line":417,"address":[12793157,12793092],"length":1,"stats":{"Line":0}},{"line":418,"address":[12688741,12688871],"length":1,"stats":{"Line":0}},{"line":421,"address":[15253235],"length":1,"stats":{"Line":0}},{"line":426,"address":[12749139],"length":1,"stats":{"Line":0}},{"line":427,"address":[12791235,12791902],"length":1,"stats":{"Line":0}},{"line":432,"address":[12689330],"length":1,"stats":{"Line":0}},{"line":433,"address":[15257408,15253692,15254546],"length":1,"stats":{"Line":0}},{"line":434,"address":[12792190],"length":1,"stats":{"Line":0}},{"line":438,"address":[12794771,12793912,12794024],"length":1,"stats":{"Line":0}},{"line":441,"address":[12892640],"length":1,"stats":{"Line":0}},{"line":445,"address":[12761555,12761458,12761400,12762068,12761678,12762705],"length":1,"stats":{"Line":0}},{"line":446,"address":[12755749,12755404,12755090,12755291],"length":1,"stats":{"Line":0}},{"line":447,"address":[15258791,15258679],"length":1,"stats":{"Line":0}},{"line":448,"address":[12688143,12688379,12687728,12688207,12688312,12687877],"length":1,"stats":{"Line":0}},{"line":450,"address":[11601526],"length":1,"stats":{"Line":0}},{"line":451,"address":[12799804,12799920],"length":1,"stats":{"Line":0}},{"line":452,"address":[12756239,12756576,12754566,12756361],"length":1,"stats":{"Line":0}},{"line":455,"address":[12682352],"length":1,"stats":{"Line":1}},{"line":459,"address":[11629545],"length":1,"stats":{"Line":2}},{"line":461,"address":[12801424],"length":1,"stats":{"Line":1}},{"line":462,"address":[12683153],"length":1,"stats":{"Line":1}},{"line":463,"address":[12764852],"length":1,"stats":{"Line":1}},{"line":465,"address":[12683914,12683853,12683497,12683666,12684197],"length":1,"stats":{"Line":3}},{"line":466,"address":[12698053,12697544,12696420,12697643,12697852],"length":1,"stats":{"Line":4}},{"line":469,"address":[12759024],"length":1,"stats":{"Line":0}},{"line":473,"address":[12686081,12684798,12684670,12684909,12685261,12684725],"length":1,"stats":{"Line":0}},{"line":475,"address":[12692000],"length":1,"stats":{"Line":0}},{"line":476,"address":[12797937],"length":1,"stats":{"Line":0}},{"line":477,"address":[12699172],"length":1,"stats":{"Line":0}},{"line":479,"address":[12898649,12898818,12899349,12899005,12899066],"length":1,"stats":{"Line":0}},{"line":480,"address":[11728396],"length":1,"stats":{"Line":0}},{"line":483,"address":[12693296],"length":1,"stats":{"Line":1}},{"line":487,"address":[11778108],"length":1,"stats":{"Line":2}},{"line":489,"address":[12804031],"length":1,"stats":{"Line":1}},{"line":490,"address":[12701170],"length":1,"stats":{"Line":1}},{"line":491,"address":[20462571],"length":1,"stats":{"Line":1}},{"line":493,"address":[12695158,12694885,12694547,12693684],"length":1,"stats":{"Line":3}},{"line":496,"address":[12702496,12702528,12702889,12702590,12704031,12702504,12703033,12702783],"length":1,"stats":{"Line":4}},{"line":497,"address":[11637698,11637788],"length":1,"stats":{"Line":2}},{"line":498,"address":[20464711,20464856],"length":1,"stats":{"Line":2}},{"line":500,"address":[12696780,12696713],"length":1,"stats":{"Line":2}},{"line":501,"address":[12764872,12763666,12764644,12765460,12766520],"length":1,"stats":{"Line":1}},{"line":502,"address":[12690843,12691016],"length":1,"stats":{"Line":2}},{"line":503,"address":[12691031,12691122],"length":1,"stats":{"Line":2}},{"line":504,"address":[12772814,12772722],"length":1,"stats":{"Line":2}},{"line":505,"address":[12904522],"length":1,"stats":{"Line":1}},{"line":507,"address":[20466664,20466456,20466541,20466804],"length":1,"stats":{"Line":2}},{"line":508,"address":[11705550],"length":1,"stats":{"Line":0}},{"line":509,"address":[12773712],"length":1,"stats":{"Line":0}},{"line":510,"address":[12773768,12773979],"length":1,"stats":{"Line":0}},{"line":512,"address":[15269951,15269876],"length":1,"stats":{"Line":0}},{"line":513,"address":[12811056],"length":1,"stats":{"Line":0}},{"line":514,"address":[12706559],"length":1,"stats":{"Line":0}},{"line":515,"address":[12805570],"length":1,"stats":{"Line":0}},{"line":516,"address":[12692878],"length":1,"stats":{"Line":0}},{"line":518,"address":[12766864],"length":1,"stats":{"Line":0}},{"line":519,"address":[12810608,12811402],"length":1,"stats":{"Line":0}},{"line":524,"address":[12698385,12700036],"length":1,"stats":{"Line":2}},{"line":525,"address":[12906340],"length":1,"stats":{"Line":1}},{"line":526,"address":[19405959],"length":1,"stats":{"Line":1}},{"line":528,"address":[12812286,12812167],"length":1,"stats":{"Line":2}},{"line":529,"address":[12806723,12807714],"length":1,"stats":{"Line":0}},{"line":530,"address":[20470034],"length":1,"stats":{"Line":0}},{"line":532,"address":[12776671],"length":1,"stats":{"Line":0}},{"line":533,"address":[12708846],"length":1,"stats":{"Line":0}},{"line":537,"address":[12768652,12769558,12768604],"length":1,"stats":{"Line":2}},{"line":543,"address":[12812128],"length":1,"stats":{"Line":1}},{"line":547,"address":[11717740,11717867],"length":1,"stats":{"Line":2}},{"line":548,"address":[20471566,20471666,20472164],"length":1,"stats":{"Line":2}},{"line":550,"address":[12771364],"length":1,"stats":{"Line":0}},{"line":551,"address":[12771387],"length":1,"stats":{"Line":0}},{"line":552,"address":[20471960],"length":1,"stats":{"Line":0}},{"line":555,"address":[12696696,12696829],"length":1,"stats":{"Line":2}},{"line":558,"address":[12809582],"length":1,"stats":{"Line":1}},{"line":559,"address":[12909995,12910401],"length":1,"stats":{"Line":2}},{"line":560,"address":[12772028,12772098],"length":1,"stats":{"Line":2}},{"line":561,"address":[11724693],"length":1,"stats":{"Line":1}},{"line":562,"address":[12698392,12698598],"length":1,"stats":{"Line":2}},{"line":563,"address":[12705450,12705572],"length":1,"stats":{"Line":2}},{"line":565,"address":[15276092,15276184],"length":1,"stats":{"Line":2}},{"line":566,"address":[12815856],"length":1,"stats":{"Line":1}},{"line":568,"address":[12817534,12817766,12817933,12817625],"length":1,"stats":{"Line":2}},{"line":569,"address":[15276657,15276784,15273215,15277030],"length":1,"stats":{"Line":0}},{"line":570,"address":[12913224],"length":1,"stats":{"Line":0}},{"line":573,"address":[12713968],"length":1,"stats":{"Line":0}},{"line":574,"address":[12813133],"length":1,"stats":{"Line":0}},{"line":575,"address":[15277543],"length":1,"stats":{"Line":0}},{"line":577,"address":[12817283,12817208],"length":1,"stats":{"Line":0}},{"line":578,"address":[15277907],"length":1,"stats":{"Line":0}},{"line":579,"address":[12913927],"length":1,"stats":{"Line":0}},{"line":580,"address":[12775520],"length":1,"stats":{"Line":0}},{"line":581,"address":[12707727],"length":1,"stats":{"Line":0}},{"line":583,"address":[20475208],"length":1,"stats":{"Line":0}},{"line":584,"address":[12707963,12707064],"length":1,"stats":{"Line":0}},{"line":589,"address":[12816016,12817963],"length":1,"stats":{"Line":2}},{"line":590,"address":[15278431],"length":1,"stats":{"Line":1}},{"line":591,"address":[11656983],"length":1,"stats":{"Line":1}},{"line":593,"address":[12715700,12715819],"length":1,"stats":{"Line":2}},{"line":594,"address":[12784950,12783600],"length":1,"stats":{"Line":0}},{"line":595,"address":[12821766],"length":1,"stats":{"Line":0}},{"line":597,"address":[12816275],"length":1,"stats":{"Line":0}},{"line":598,"address":[15280520],"length":1,"stats":{"Line":0}},{"line":602,"address":[12814825,12815249,12815342,12816080,12814777],"length":1,"stats":{"Line":3}},{"line":604,"address":[12820879,12820792,12820817],"length":1,"stats":{"Line":3}},{"line":606,"address":[12777114],"length":1,"stats":{"Line":1}},{"line":607,"address":[12979392,12979397],"length":1,"stats":{"Line":2}},{"line":611,"address":[12710880],"length":1,"stats":{"Line":2}},{"line":615,"address":[12704388,12704547],"length":1,"stats":{"Line":4}},{"line":616,"address":[12917649],"length":1,"stats":{"Line":2}},{"line":617,"address":[15281637],"length":1,"stats":{"Line":0}},{"line":619,"address":[12779249,12779200],"length":1,"stats":{"Line":3}},{"line":620,"address":[15281684],"length":1,"stats":{"Line":0}},{"line":623,"address":[12780045,12781847,12779988,12781878,12779323,12779242],"length":1,"stats":{"Line":3}},{"line":626,"address":[12705445,12705373],"length":1,"stats":{"Line":2}},{"line":633,"address":[12819409,12819476],"length":1,"stats":{"Line":3}},{"line":634,"address":[12825128],"length":1,"stats":{"Line":2}},{"line":635,"address":[12823861],"length":1,"stats":{"Line":0}},{"line":638,"address":[12820853,12817151,12819689,12819793,12820221,12822061],"length":1,"stats":{"Line":4}},{"line":639,"address":[20483277,20484884,20483071,20484864],"length":1,"stats":{"Line":8}},{"line":641,"address":[12782940],"length":1,"stats":{"Line":2}},{"line":643,"address":[12722185],"length":1,"stats":{"Line":1}},{"line":645,"address":[12783035],"length":1,"stats":{"Line":1}},{"line":646,"address":[12825096],"length":1,"stats":{"Line":1}},{"line":648,"address":[20483470],"length":1,"stats":{"Line":1}},{"line":649,"address":[12783101],"length":1,"stats":{"Line":1}},{"line":652,"address":[12923024,12921439,12921655,12923046],"length":1,"stats":{"Line":4}},{"line":654,"address":[12783822],"length":1,"stats":{"Line":0}},{"line":656,"address":[20483762,20483645],"length":1,"stats":{"Line":2}},{"line":659,"address":[12921922],"length":1,"stats":{"Line":1}},{"line":660,"address":[12790390],"length":1,"stats":{"Line":1}},{"line":661,"address":[12715666],"length":1,"stats":{"Line":1}},{"line":663,"address":[12825568],"length":1,"stats":{"Line":1}},{"line":664,"address":[12790476,12790574],"length":1,"stats":{"Line":2}},{"line":668,"address":[15286688,15286277,15281476,15286182,15286065,15286567],"length":1,"stats":{"Line":4}},{"line":669,"address":[12822365],"length":1,"stats":{"Line":1}},{"line":672,"address":[12826640],"length":1,"stats":{"Line":0}},{"line":676,"address":[11703289],"length":1,"stats":{"Line":0}},{"line":677,"address":[12792532,12792340,12792677,12793013],"length":1,"stats":{"Line":0}},{"line":678,"address":[15287965,15288077],"length":1,"stats":{"Line":0}},{"line":679,"address":[12718537,12718073,12718219,12718473,12718798],"length":1,"stats":{"Line":0}},{"line":681,"address":[12829753,12829696,12829843,12830254,12829979,12828581],"length":1,"stats":{"Line":0}},{"line":682,"address":[11635570],"length":1,"stats":{"Line":0}},{"line":685,"address":[12830944],"length":1,"stats":{"Line":0}},{"line":689,"address":[11722559],"length":1,"stats":{"Line":0}},{"line":690,"address":[12788445,12788332,12788790,12788136],"length":1,"stats":{"Line":0}},{"line":691,"address":[12830588,12830472],"length":1,"stats":{"Line":0}},{"line":692,"address":[12827165,12826689,12826838,12827101,12827270,12827337],"length":1,"stats":{"Line":0}},{"line":694,"address":[19379270],"length":1,"stats":{"Line":0}},{"line":695,"address":[11721078],"length":1,"stats":{"Line":0}},{"line":696,"address":[15291643,15291318,15291452,15289752],"length":1,"stats":{"Line":0}},{"line":699,"address":[12832016,12832808,12832328,12832024,12832048,12832083,12832208,12832171],"length":1,"stats":{"Line":4}},{"line":700,"address":[12833800,12834211,12834346,12834454,12834110,12833927],"length":1,"stats":{"Line":4}},{"line":701,"address":[12715870,12716019,12715720,12715663,12715615,12715558],"length":1,"stats":{"Line":3}},{"line":702,"address":[12797712,12797721],"length":1,"stats":{"Line":2}},{"line":703,"address":[11716710,11716746],"length":1,"stats":{"Line":0}},{"line":706,"address":[12797872,12797848,12797907,12798078,12799400,12797840,12798011,12798241],"length":1,"stats":{"Line":4}},{"line":707,"address":[12833505,12833848,12833587,12833252,12834607,12833323,12833098],"length":1,"stats":{"Line":5}},{"line":710,"address":[11661455],"length":1,"stats":{"Line":3}},{"line":711,"address":[12931416,12930235,12931392],"length":1,"stats":{"Line":0}},{"line":712,"address":[20492221,20492098],"length":1,"stats":{"Line":2}},{"line":713,"address":[12791900,12792575,12791128,12792481],"length":1,"stats":{"Line":2}},{"line":715,"address":[12717392,12717664,12717291],"length":1,"stats":{"Line":2}},{"line":716,"address":[12718480,12718498,12717616],"length":1,"stats":{"Line":0}},{"line":717,"address":[12731282],"length":1,"stats":{"Line":1}},{"line":720,"address":[12835702,12835312,12835359,12835919,12838970,12835602,12835288,12835280],"length":1,"stats":{"Line":4}},{"line":721,"address":[12835863,12836072,12839196,12835556,12835768,12836172,12836454],"length":1,"stats":{"Line":5}},{"line":724,"address":[20494287,20494221,20494156,20493968,20494440],"length":1,"stats":{"Line":3}},{"line":725,"address":[12832470,12837112,12837088],"length":1,"stats":{"Line":0}},{"line":726,"address":[12838139,12838010],"length":1,"stats":{"Line":1}},{"line":727,"address":[12832638],"length":1,"stats":{"Line":1}},{"line":729,"address":[12722456,12720520,12719896,12720107],"length":1,"stats":{"Line":0}},{"line":730,"address":[12795064,12799136,12799154],"length":1,"stats":{"Line":0}},{"line":731,"address":[12838909,12838722],"length":1,"stats":{"Line":0}},{"line":732,"address":[15297129],"length":1,"stats":{"Line":0}},{"line":734,"address":[12839120,12838957,12839344,12840698],"length":1,"stats":{"Line":0}},{"line":735,"address":[15297406,15298689,15297553],"length":1,"stats":{"Line":0}},{"line":736,"address":[12802836],"length":1,"stats":{"Line":0}},{"line":737,"address":[12803045],"length":1,"stats":{"Line":0}},{"line":738,"address":[12735314],"length":1,"stats":{"Line":0}},{"line":739,"address":[12796362,12796422],"length":1,"stats":{"Line":0}},{"line":740,"address":[12840495,12837301,12840866,12841179,12840406],"length":1,"stats":{"Line":0}},{"line":741,"address":[20497962,20497830,20498676,20498033],"length":1,"stats":{"Line":0}},{"line":744,"address":[15299959,15300092,15299390,15299439,15295510],"length":1,"stats":{"Line":0}},{"line":745,"address":[12836539],"length":1,"stats":{"Line":0}},{"line":748,"address":[12799309,12799531,12799491,12800127,12799328,12799296,12799369,12800572],"length":1,"stats":{"Line":4}},{"line":749,"address":[12806730,12806400,12806506,12807002],"length":1,"stats":{"Line":2}},{"line":750,"address":[20500976,20500994,20500138],"length":1,"stats":{"Line":0}},{"line":751,"address":[12938436,12938730,12938992,12938206,12938507,12938839],"length":1,"stats":{"Line":5}},{"line":752,"address":[12739075],"length":1,"stats":{"Line":1}},{"line":753,"address":[12807219,12806924,12807087,12806971,12806446],"length":1,"stats":{"Line":3}},{"line":754,"address":[12800464,12800752,12800776],"length":1,"stats":{"Line":0}},{"line":755,"address":[15302126],"length":1,"stats":{"Line":1}},{"line":758,"address":[12726328,12726470,12726336,12726320,12726371,12726518,12726681,12727524],"length":1,"stats":{"Line":8}},{"line":759,"address":[15302733,15302856,15303191,15302923,15303433,15303093,15303951],"length":1,"stats":{"Line":10}},{"line":762,"address":[11749988],"length":1,"stats":{"Line":6}},{"line":763,"address":[20502105,20502712,20502688],"length":1,"stats":{"Line":0}},{"line":764,"address":[12727092,12727214],"length":1,"stats":{"Line":3}},{"line":765,"address":[12727283,12727533],"length":1,"stats":{"Line":4}},{"line":767,"address":[12940944,12940962,12940331,12940415],"length":1,"stats":{"Line":2}},{"line":770,"address":[12802637,12802624,12803900,12802656,12802859,12803455,12802697,12802819],"length":1,"stats":{"Line":8}},{"line":771,"address":[12802800,12802906,12803402,12803130],"length":1,"stats":{"Line":3}},{"line":772,"address":[12941562,12942418,12942400],"length":1,"stats":{"Line":0}},{"line":773,"address":[20503739,20503438,20504071,20503962,20504224,20503668],"length":1,"stats":{"Line":9}},{"line":774,"address":[12803235],"length":1,"stats":{"Line":2}},{"line":775,"address":[12844894,12845667,12845419,12845535,12845372],"length":1,"stats":{"Line":6}},{"line":776,"address":[12736296,12736272,12735984],"length":1,"stats":{"Line":0}},{"line":777,"address":[12735950],"length":1,"stats":{"Line":2}},{"line":780,"address":[12804240],"length":1,"stats":{"Line":1}},{"line":787,"address":[12736865,12736750],"length":1,"stats":{"Line":2}},{"line":788,"address":[12804744,12804681],"length":1,"stats":{"Line":2}},{"line":789,"address":[12846867],"length":1,"stats":{"Line":0}},{"line":790,"address":[12843496],"length":1,"stats":{"Line":0}},{"line":791,"address":[12812281],"length":1,"stats":{"Line":0}},{"line":794,"address":[12943768],"length":1,"stats":{"Line":0}},{"line":796,"address":[12842919,12842949],"length":1,"stats":{"Line":2}},{"line":797,"address":[12943334,12943428],"length":1,"stats":{"Line":2}},{"line":798,"address":[12943471],"length":1,"stats":{"Line":0}},{"line":799,"address":[12843109],"length":1,"stats":{"Line":0}},{"line":801,"address":[12744277],"length":1,"stats":{"Line":0}},{"line":802,"address":[12847107],"length":1,"stats":{"Line":0}},{"line":806,"address":[12811801,12812137],"length":1,"stats":{"Line":2}},{"line":809,"address":[12812512],"length":1,"stats":{"Line":1}},{"line":815,"address":[12806023],"length":1,"stats":{"Line":1}},{"line":816,"address":[12848230],"length":1,"stats":{"Line":1}},{"line":817,"address":[12731658],"length":1,"stats":{"Line":1}},{"line":818,"address":[20506731,20506664],"length":1,"stats":{"Line":2}},{"line":819,"address":[12848810,12848601,12848463,12848974],"length":1,"stats":{"Line":4}},{"line":822,"address":[12813569,12813007,12813786,12813438,12813503],"length":1,"stats":{"Line":3}},{"line":824,"address":[12850944,12850967],"length":1,"stats":{"Line":0}},{"line":826,"address":[12853283,12853220,12850814,12850683,12853028],"length":1,"stats":{"Line":5}},{"line":827,"address":[20511574,20509994],"length":1,"stats":{"Line":2}},{"line":829,"address":[20511692],"length":1,"stats":{"Line":1}},{"line":830,"address":[12738292,12739424,12743581,12743710],"length":1,"stats":{"Line":3}},{"line":831,"address":[12853914],"length":1,"stats":{"Line":1}},{"line":832,"address":[15313460],"length":1,"stats":{"Line":0}},{"line":833,"address":[12854683,12854087,12854608],"length":1,"stats":{"Line":0}},{"line":837,"address":[12737524,12737336],"length":1,"stats":{"Line":1}},{"line":838,"address":[20507962,20507653,20506505,20512764],"length":1,"stats":{"Line":4}},{"line":839,"address":[12851299],"length":1,"stats":{"Line":1}},{"line":840,"address":[15314473,15314464,15309191,15309406],"length":1,"stats":{"Line":4}},{"line":841,"address":[20508413,20508329],"length":1,"stats":{"Line":2}},{"line":842,"address":[20508427,20508508],"length":1,"stats":{"Line":0}},{"line":843,"address":[12851731],"length":1,"stats":{"Line":0}},{"line":848,"address":[12815010],"length":1,"stats":{"Line":1}},{"line":849,"address":[20508779,20508933],"length":1,"stats":{"Line":1}},{"line":850,"address":[12846623],"length":1,"stats":{"Line":1}},{"line":855,"address":[15309233],"length":1,"stats":{"Line":0}},{"line":856,"address":[12946205,12947817],"length":1,"stats":{"Line":0}},{"line":861,"address":[15311179],"length":1,"stats":{"Line":1}},{"line":862,"address":[12738464,12735149,12736417],"length":1,"stats":{"Line":0}},{"line":863,"address":[12738478],"length":1,"stats":{"Line":0}},{"line":867,"address":[12749030,12748870],"length":1,"stats":{"Line":2}},{"line":868,"address":[12816871],"length":1,"stats":{"Line":1}},{"line":870,"address":[12854661,12853741],"length":1,"stats":{"Line":1}},{"line":876,"address":[12820080],"length":1,"stats":{"Line":1}},{"line":881,"address":[12820635,12820792],"length":1,"stats":{"Line":2}},{"line":882,"address":[12851995,12852055],"length":1,"stats":{"Line":2}},{"line":885,"address":[12820853,12829027,12828992],"length":1,"stats":{"Line":3}},{"line":886,"address":[12952441],"length":1,"stats":{"Line":1}},{"line":887,"address":[20514422],"length":1,"stats":{"Line":1}},{"line":888,"address":[20514496],"length":1,"stats":{"Line":1}},{"line":889,"address":[20514515],"length":1,"stats":{"Line":1}},{"line":891,"address":[20514676,20516648,20516711,20514545,20516516],"length":1,"stats":{"Line":5}},{"line":892,"address":[12741758,12744513],"length":1,"stats":{"Line":2}},{"line":893,"address":[12820699,12821357,12826065,12826197],"length":1,"stats":{"Line":3}},{"line":894,"address":[12751809],"length":1,"stats":{"Line":1}},{"line":895,"address":[12819741],"length":1,"stats":{"Line":0}},{"line":896,"address":[12828678,12828753,12826717],"length":1,"stats":{"Line":0}},{"line":901,"address":[15320984,15321167],"length":1,"stats":{"Line":1}},{"line":902,"address":[12820178],"length":1,"stats":{"Line":1}},{"line":903,"address":[12827419,12827211],"length":1,"stats":{"Line":1}},{"line":905,"address":[12752791],"length":1,"stats":{"Line":1}},{"line":906,"address":[12746048,12746146],"length":1,"stats":{"Line":1}},{"line":908,"address":[12827640,12828145],"length":1,"stats":{"Line":2}},{"line":909,"address":[12827999,12828112],"length":1,"stats":{"Line":2}},{"line":911,"address":[15322459,15323376,15323411,15322430],"length":1,"stats":{"Line":4}},{"line":913,"address":[12760270,12760203],"length":1,"stats":{"Line":0}},{"line":915,"address":[12859331,12859229],"length":1,"stats":{"Line":2}},{"line":916,"address":[12959752,12960013],"length":1,"stats":{"Line":1}},{"line":919,"address":[12760812,12752960,12753985,12760629,12753634],"length":1,"stats":{"Line":5}},{"line":920,"address":[12858543],"length":1,"stats":{"Line":1}},{"line":921,"address":[12953647,12953752,12953415],"length":1,"stats":{"Line":2}},{"line":922,"address":[12740643,12741033,12740700],"length":1,"stats":{"Line":3}},{"line":923,"address":[12822451,12822268],"length":1,"stats":{"Line":2}},{"line":925,"address":[12754561],"length":1,"stats":{"Line":1}},{"line":927,"address":[12858679],"length":1,"stats":{"Line":0}},{"line":928,"address":[15317330,15316427],"length":1,"stats":{"Line":0}},{"line":933,"address":[12954869],"length":1,"stats":{"Line":1}},{"line":934,"address":[12748654],"length":1,"stats":{"Line":0}},{"line":935,"address":[12816542],"length":1,"stats":{"Line":0}},{"line":939,"address":[12955093,12955151,12955331,12954909],"length":1,"stats":{"Line":3}},{"line":940,"address":[12854765],"length":1,"stats":{"Line":0}},{"line":943,"address":[20517285,20517337,20517003,20517060],"length":1,"stats":{"Line":2}},{"line":944,"address":[12865938,12860549,12865920],"length":1,"stats":{"Line":0}},{"line":948,"address":[12823871,12824278,12825913],"length":1,"stats":{"Line":2}},{"line":957,"address":[12866080],"length":1,"stats":{"Line":0}},{"line":962,"address":[20523099],"length":1,"stats":{"Line":0}},{"line":963,"address":[20523243],"length":1,"stats":{"Line":0}},{"line":964,"address":[12755082],"length":1,"stats":{"Line":0}},{"line":966,"address":[15325341,15325026,15324267,15325400,15324149],"length":1,"stats":{"Line":0}},{"line":967,"address":[12862345,12863017],"length":1,"stats":{"Line":0}},{"line":968,"address":[12830101,12829693,12831992,12831873],"length":1,"stats":{"Line":0}},{"line":969,"address":[12825413],"length":1,"stats":{"Line":0}},{"line":970,"address":[12750937],"length":1,"stats":{"Line":0}},{"line":971,"address":[12757980,12757908,12757769],"length":1,"stats":{"Line":0}},{"line":975,"address":[12866479,12866903,12867211,12869171,12869347],"length":1,"stats":{"Line":0}},{"line":976,"address":[12865574],"length":1,"stats":{"Line":0}},{"line":977,"address":[12962054],"length":1,"stats":{"Line":0}},{"line":978,"address":[12762934,12763119],"length":1,"stats":{"Line":0}},{"line":979,"address":[12862003,12861910],"length":1,"stats":{"Line":0}},{"line":980,"address":[12865903,12866009],"length":1,"stats":{"Line":0}},{"line":981,"address":[12830768],"length":1,"stats":{"Line":0}},{"line":985,"address":[12823644],"length":1,"stats":{"Line":0}},{"line":986,"address":[15324892,15325167],"length":1,"stats":{"Line":0}},{"line":991,"address":[15325445],"length":1,"stats":{"Line":0}},{"line":992,"address":[12831423,12831690,12832928],"length":1,"stats":{"Line":0}},{"line":993,"address":[20526398],"length":1,"stats":{"Line":0}},{"line":997,"address":[12962841],"length":1,"stats":{"Line":0}},{"line":998,"address":[12862410],"length":1,"stats":{"Line":0}},{"line":999,"address":[20524729],"length":1,"stats":{"Line":0}},{"line":1003,"address":[20526480],"length":1,"stats":{"Line":0}},{"line":1008,"address":[12833282],"length":1,"stats":{"Line":0}},{"line":1009,"address":[15327675,15328382,15327607],"length":1,"stats":{"Line":0}},{"line":1010,"address":[12766282,12766492,12765578],"length":1,"stats":{"Line":0}},{"line":1013,"address":[12753024],"length":1,"stats":{"Line":0}},{"line":1018,"address":[12827858,12827986],"length":1,"stats":{"Line":0}},{"line":1019,"address":[12767220,12767814,12767171],"length":1,"stats":{"Line":0}},{"line":1020,"address":[12966879,12966989],"length":1,"stats":{"Line":0}},{"line":1021,"address":[12967021,12966394,12967189],"length":1,"stats":{"Line":0}},{"line":1033,"address":[12872768],"length":1,"stats":{"Line":1}},{"line":1034,"address":[12761281],"length":1,"stats":{"Line":1}},{"line":1035,"address":[12761319],"length":1,"stats":{"Line":0}},{"line":1036,"address":[12754550],"length":1,"stats":{"Line":1}},{"line":1037,"address":[12871206],"length":1,"stats":{"Line":1}},{"line":1038,"address":[12867286],"length":1,"stats":{"Line":0}},{"line":1042,"address":[12754608],"length":1,"stats":{"Line":0}},{"line":1046,"address":[12754650],"length":1,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[12754720,12754737],"length":1,"stats":{"Line":0}},{"line":1050,"address":[12871408,12871422],"length":1,"stats":{"Line":0}},{"line":1053,"address":[12873152],"length":1,"stats":{"Line":0}},{"line":1057,"address":[12754906],"length":1,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[12761777,12761760],"length":1,"stats":{"Line":0}},{"line":1061,"address":[12829616,12829630],"length":1,"stats":{"Line":0}},{"line":1064,"address":[12968597,12968192],"length":1,"stats":{"Line":0}},{"line":1068,"address":[12755160],"length":1,"stats":{"Line":0}},{"line":1069,"address":[20530361,20530287,20530188],"length":1,"stats":{"Line":0}},{"line":1070,"address":[12873656,12873782],"length":1,"stats":{"Line":0}},{"line":1072,"address":[12755274],"length":1,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[12830144,12830158],"length":1,"stats":{"Line":0}},{"line":1078,"address":[12830240,12831088],"length":1,"stats":{"Line":1}},{"line":1083,"address":[12837215],"length":1,"stats":{"Line":1}},{"line":1084,"address":[12762789,12762706,12762531],"length":1,"stats":{"Line":0}},{"line":1085,"address":[20530964,20531457,20531102,20531207],"length":1,"stats":{"Line":0}},{"line":1086,"address":[12837833,12837731],"length":1,"stats":{"Line":0}},{"line":1089,"address":[12762602],"length":1,"stats":{"Line":1}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[12756800,12756817],"length":1,"stats":{"Line":2}},{"line":1094,"address":[12837424,12838083],"length":1,"stats":{"Line":2}},{"line":1095,"address":[12874990],"length":1,"stats":{"Line":1}},{"line":1096,"address":[12756666],"length":1,"stats":{"Line":1}},{"line":1099,"address":[12756574],"length":1,"stats":{"Line":1}},{"line":1102,"address":[12873488],"length":1,"stats":{"Line":1}},{"line":1103,"address":[12756892],"length":1,"stats":{"Line":1}},{"line":1104,"address":[12756901],"length":1,"stats":{"Line":0}},{"line":1106,"address":[12838439],"length":1,"stats":{"Line":1}},{"line":1109,"address":[12869664,12870640,12870670],"length":1,"stats":{"Line":1}},{"line":1110,"address":[15332635],"length":1,"stats":{"Line":1}},{"line":1111,"address":[12874173,12873727,12873803,12874640],"length":1,"stats":{"Line":2}},{"line":1112,"address":[20533118],"length":1,"stats":{"Line":0}},{"line":1113,"address":[12971096],"length":1,"stats":{"Line":0}},{"line":1114,"address":[12758029],"length":1,"stats":{"Line":0}},{"line":1117,"address":[12970535,12970688],"length":1,"stats":{"Line":2}},{"line":1118,"address":[20532608],"length":1,"stats":{"Line":1}},{"line":1119,"address":[12771569],"length":1,"stats":{"Line":0}},{"line":1120,"address":[12832393],"length":1,"stats":{"Line":0}},{"line":1126,"address":[20533152],"length":1,"stats":{"Line":1}},{"line":1127,"address":[12874829],"length":1,"stats":{"Line":1}},{"line":1128,"address":[20533216,20533243],"length":1,"stats":{"Line":2}},{"line":1129,"address":[12833017,12833008],"length":1,"stats":{"Line":2}},{"line":1132,"address":[20533424],"length":1,"stats":{"Line":1}},{"line":1133,"address":[12833123],"length":1,"stats":{"Line":1}},{"line":1134,"address":[12840082],"length":1,"stats":{"Line":1}},{"line":1135,"address":[12772343],"length":1,"stats":{"Line":1}},{"line":1138,"address":[12875408,12876131,12876451],"length":1,"stats":{"Line":2}},{"line":1144,"address":[12871536,12871742],"length":1,"stats":{"Line":2}},{"line":1145,"address":[12759013,12759100],"length":1,"stats":{"Line":4}},{"line":1146,"address":[12875778],"length":1,"stats":{"Line":0}},{"line":1148,"address":[12871860,12871809],"length":1,"stats":{"Line":3}},{"line":1149,"address":[12772992,12772942],"length":1,"stats":{"Line":2}},{"line":1150,"address":[12833840],"length":1,"stats":{"Line":1}},{"line":1151,"address":[20534293],"length":1,"stats":{"Line":0}},{"line":1153,"address":[12875925,12875991],"length":1,"stats":{"Line":2}},{"line":1154,"address":[12759462],"length":1,"stats":{"Line":1}},{"line":1157,"address":[12877500,12877788],"length":1,"stats":{"Line":4}},{"line":1158,"address":[12972865],"length":1,"stats":{"Line":0}},{"line":1160,"address":[12972695],"length":1,"stats":{"Line":2}},{"line":1161,"address":[12876289],"length":1,"stats":{"Line":1}},{"line":1163,"address":[12766461],"length":1,"stats":{"Line":2}},{"line":1164,"address":[12766495],"length":1,"stats":{"Line":1}},{"line":1166,"address":[20534705],"length":1,"stats":{"Line":2}},{"line":1169,"address":[12841798,12841344],"length":1,"stats":{"Line":1}},{"line":1174,"address":[12841398],"length":1,"stats":{"Line":1}},{"line":1175,"address":[20534933],"length":1,"stats":{"Line":0}},{"line":1177,"address":[12872649],"length":1,"stats":{"Line":1}},{"line":1178,"address":[12876656],"length":1,"stats":{"Line":0}},{"line":1180,"address":[12841824,12841833,12841489],"length":1,"stats":{"Line":3}},{"line":1181,"address":[12760035],"length":1,"stats":{"Line":1}},{"line":1182,"address":[12973095],"length":1,"stats":{"Line":0}},{"line":1184,"address":[12834640],"length":1,"stats":{"Line":1}},{"line":1185,"address":[12766909],"length":1,"stats":{"Line":0}},{"line":1187,"address":[12773834,12773907],"length":1,"stats":{"Line":2}},{"line":1188,"address":[12876844],"length":1,"stats":{"Line":0}},{"line":1190,"address":[15335742,15335773],"length":1,"stats":{"Line":1}},{"line":1193,"address":[12760336],"length":1,"stats":{"Line":1}},{"line":1197,"address":[15335928,15336049],"length":1,"stats":{"Line":2}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[12873308,12873296],"length":1,"stats":{"Line":0}},{"line":1200,"address":[12767294,12767239],"length":1,"stats":{"Line":0}},{"line":1201,"address":[12877170],"length":1,"stats":{"Line":0}},{"line":1202,"address":[15336126],"length":1,"stats":{"Line":0}},{"line":1205,"address":[12760548],"length":1,"stats":{"Line":0}},{"line":1208,"address":[20535616],"length":1,"stats":{"Line":2}},{"line":1209,"address":[12873372,12873424],"length":1,"stats":{"Line":4}},{"line":1210,"address":[12873456],"length":1,"stats":{"Line":2}},{"line":1211,"address":[12760859,12760783,12760928,12760937],"length":1,"stats":{"Line":7}},{"line":1212,"address":[12760960,12760969,12760871],"length":1,"stats":{"Line":5}},{"line":1214,"address":[12760850],"length":1,"stats":{"Line":1}},{"line":1219,"address":[12835584],"length":1,"stats":{"Line":1}},{"line":1220,"address":[20536020,20536080],"length":1,"stats":{"Line":2}},{"line":1221,"address":[12842667],"length":1,"stats":{"Line":1}},{"line":1222,"address":[15336833,15336921,15336912,15336749],"length":1,"stats":{"Line":4}},{"line":1223,"address":[12879566],"length":1,"stats":{"Line":1}},{"line":1225,"address":[12775013],"length":1,"stats":{"Line":1}},{"line":1230,"address":[12835968],"length":1,"stats":{"Line":1}},{"line":1231,"address":[12761404],"length":1,"stats":{"Line":1}},{"line":1234,"address":[12843113,12843008,12843104,12842976],"length":1,"stats":{"Line":4}},{"line":1237,"address":[12836208],"length":1,"stats":{"Line":2}},{"line":1238,"address":[15337187,15337292],"length":1,"stats":{"Line":3}},{"line":1239,"address":[12761719],"length":1,"stats":{"Line":1}},{"line":1240,"address":[12836373],"length":1,"stats":{"Line":0}},{"line":1242,"address":[12768553],"length":1,"stats":{"Line":2}},{"line":1245,"address":[12878448],"length":1,"stats":{"Line":1}},{"line":1246,"address":[12836422,12836617],"length":1,"stats":{"Line":1}},{"line":1250,"address":[12874722],"length":1,"stats":{"Line":1}},{"line":1251,"address":[12768848],"length":1,"stats":{"Line":1}},{"line":1253,"address":[12880336],"length":1,"stats":{"Line":1}},{"line":1256,"address":[12769447,12768880],"length":1,"stats":{"Line":1}},{"line":1257,"address":[15337673],"length":1,"stats":{"Line":1}},{"line":1258,"address":[15337712],"length":1,"stats":{"Line":1}},{"line":1259,"address":[12775957],"length":1,"stats":{"Line":1}},{"line":1260,"address":[15337877],"length":1,"stats":{"Line":0}},{"line":1262,"address":[12975785,12975433,12975776,12975528],"length":1,"stats":{"Line":7}},{"line":1263,"address":[12837142],"length":1,"stats":{"Line":2}},{"line":1264,"address":[12880820],"length":1,"stats":{"Line":0}},{"line":1266,"address":[12762598,12762644],"length":1,"stats":{"Line":4}},{"line":1269,"address":[12875440],"length":1,"stats":{"Line":1}},{"line":1271,"address":[12975844],"length":1,"stats":{"Line":1}},{"line":1272,"address":[12879546,12879514],"length":1,"stats":{"Line":2}},{"line":1273,"address":[12776655],"length":1,"stats":{"Line":0}},{"line":1277,"address":[12762928],"length":1,"stats":{"Line":2}},{"line":1278,"address":[15338493],"length":1,"stats":{"Line":2}},{"line":1279,"address":[15338553],"length":1,"stats":{"Line":2}},{"line":1280,"address":[12837586],"length":1,"stats":{"Line":1}},{"line":1282,"address":[12769820],"length":1,"stats":{"Line":2}},{"line":1283,"address":[20538106],"length":1,"stats":{"Line":0}},{"line":1285,"address":[12776835],"length":1,"stats":{"Line":2}},{"line":1286,"address":[12881432],"length":1,"stats":{"Line":2}},{"line":1287,"address":[12875841],"length":1,"stats":{"Line":1}},{"line":1289,"address":[15338731],"length":1,"stats":{"Line":2}},{"line":1295,"address":[12770000,12772159],"length":1,"stats":{"Line":2}},{"line":1296,"address":[12837861],"length":1,"stats":{"Line":2}},{"line":1298,"address":[15338888],"length":1,"stats":{"Line":1}},{"line":1299,"address":[12882022],"length":1,"stats":{"Line":0}},{"line":1301,"address":[12881981],"length":1,"stats":{"Line":1}},{"line":1302,"address":[12976852],"length":1,"stats":{"Line":0}},{"line":1304,"address":[12976824],"length":1,"stats":{"Line":1}},{"line":1309,"address":[12770188],"length":1,"stats":{"Line":1}},{"line":1310,"address":[12763866],"length":1,"stats":{"Line":0}},{"line":1312,"address":[12880453],"length":1,"stats":{"Line":1}},{"line":1313,"address":[12977009],"length":1,"stats":{"Line":0}},{"line":1315,"address":[20538860],"length":1,"stats":{"Line":1}},{"line":1316,"address":[12777782],"length":1,"stats":{"Line":0}},{"line":1318,"address":[12977030],"length":1,"stats":{"Line":1}},{"line":1319,"address":[12882336],"length":1,"stats":{"Line":1}},{"line":1320,"address":[15339586],"length":1,"stats":{"Line":0}},{"line":1322,"address":[15339658],"length":1,"stats":{"Line":1}},{"line":1323,"address":[20539108],"length":1,"stats":{"Line":0}},{"line":1325,"address":[12838753],"length":1,"stats":{"Line":1}},{"line":1326,"address":[12838831],"length":1,"stats":{"Line":0}},{"line":1328,"address":[12777968],"length":1,"stats":{"Line":1}},{"line":1333,"address":[15339024],"length":1,"stats":{"Line":1}},{"line":1334,"address":[12880953],"length":1,"stats":{"Line":0}},{"line":1336,"address":[20539236],"length":1,"stats":{"Line":1}},{"line":1337,"address":[12838975],"length":1,"stats":{"Line":0}},{"line":1339,"address":[15339892],"length":1,"stats":{"Line":1}},{"line":1340,"address":[12764457],"length":1,"stats":{"Line":1}},{"line":1342,"address":[12881044],"length":1,"stats":{"Line":1}},{"line":1343,"address":[12839101],"length":1,"stats":{"Line":1}},{"line":1345,"address":[15340111],"length":1,"stats":{"Line":1}},{"line":1347,"address":[20539572,20539454],"length":1,"stats":{"Line":1}},{"line":1352,"address":[12976612],"length":1,"stats":{"Line":1}},{"line":1353,"address":[12977744],"length":1,"stats":{"Line":1}},{"line":1354,"address":[12977731],"length":1,"stats":{"Line":0}},{"line":1356,"address":[12778569,12778496],"length":1,"stats":{"Line":2}},{"line":1357,"address":[15340393],"length":1,"stats":{"Line":0}},{"line":1359,"address":[12977887,12977939],"length":1,"stats":{"Line":2}},{"line":1361,"address":[12847008,12847017],"length":1,"stats":{"Line":2}},{"line":1363,"address":[12877701,12877649],"length":1,"stats":{"Line":2}},{"line":1365,"address":[12882176,12882185],"length":1,"stats":{"Line":2}},{"line":1368,"address":[12883262],"length":1,"stats":{"Line":0}},{"line":1370,"address":[12883371],"length":1,"stats":{"Line":1}},{"line":1371,"address":[12846724],"length":1,"stats":{"Line":0}},{"line":1373,"address":[12778947,12778987],"length":1,"stats":{"Line":2}},{"line":1374,"address":[12878011],"length":1,"stats":{"Line":0}},{"line":1376,"address":[12772105,12772068],"length":1,"stats":{"Line":2}},{"line":1377,"address":[12978399],"length":1,"stats":{"Line":0}},{"line":1381,"address":[15339169],"length":1,"stats":{"Line":0}},{"line":1382,"address":[12840060],"length":1,"stats":{"Line":0}},{"line":1384,"address":[12765405],"length":1,"stats":{"Line":0}},{"line":1388,"address":[12876019],"length":1,"stats":{"Line":0}},{"line":1390,"address":[12877279],"length":1,"stats":{"Line":1}},{"line":1393,"address":[12882224],"length":1,"stats":{"Line":0}},{"line":1394,"address":[12765604],"length":1,"stats":{"Line":0}},{"line":1395,"address":[12978695],"length":1,"stats":{"Line":0}},{"line":1397,"address":[15341176,15341151],"length":1,"stats":{"Line":0}},{"line":1398,"address":[12765649],"length":1,"stats":{"Line":0}},{"line":1402,"address":[12847183],"length":1,"stats":{"Line":0}},{"line":1405,"address":[12849231,12848017,12847200],"length":1,"stats":{"Line":1}},{"line":1411,"address":[12884073],"length":1,"stats":{"Line":1}},{"line":1413,"address":[12779626,12781466,12781342,12781418,12779710,12779885],"length":1,"stats":{"Line":4}},{"line":1414,"address":[12878850,12879210],"length":1,"stats":{"Line":2}},{"line":1417,"address":[12884916,12884863],"length":1,"stats":{"Line":2}},{"line":1418,"address":[12883310,12883438],"length":1,"stats":{"Line":2}},{"line":1422,"address":[12885015,12885184],"length":1,"stats":{"Line":2}},{"line":1425,"address":[15342475,15342555],"length":1,"stats":{"Line":2}},{"line":1426,"address":[12841710,12841761],"length":1,"stats":{"Line":0}},{"line":1427,"address":[12841700],"length":1,"stats":{"Line":1}},{"line":1429,"address":[15342637],"length":1,"stats":{"Line":1}},{"line":1430,"address":[12980271,12980678],"length":1,"stats":{"Line":1}},{"line":1434,"address":[12882672,12882839],"length":1,"stats":{"Line":4}},{"line":1435,"address":[12840826,12842336,12842682,12840906,12842390],"length":1,"stats":{"Line":4}},{"line":1436,"address":[12842406],"length":1,"stats":{"Line":0}},{"line":1437,"address":[12774620],"length":1,"stats":{"Line":0}},{"line":1438,"address":[12767853],"length":1,"stats":{"Line":0}},{"line":1439,"address":[15343350,15343398],"length":1,"stats":{"Line":0}},{"line":1440,"address":[15343385],"length":1,"stats":{"Line":0}},{"line":1444,"address":[12774896,12774924,12773109],"length":1,"stats":{"Line":4}},{"line":1447,"address":[12886496,12887286],"length":1,"stats":{"Line":1}},{"line":1456,"address":[12768324,12768444],"length":1,"stats":{"Line":2}},{"line":1457,"address":[20543463],"length":1,"stats":{"Line":2}},{"line":1458,"address":[12881288],"length":1,"stats":{"Line":2}},{"line":1459,"address":[12887038],"length":1,"stats":{"Line":2}},{"line":1460,"address":[12850314],"length":1,"stats":{"Line":2}},{"line":1461,"address":[12775582,12775746],"length":1,"stats":{"Line":4}},{"line":1462,"address":[12782671,12782589],"length":1,"stats":{"Line":4}},{"line":1463,"address":[12885609,12885518],"length":1,"stats":{"Line":0}},{"line":1464,"address":[20543834],"length":1,"stats":{"Line":2}},{"line":1469,"address":[12777164,12775824,12777139],"length":1,"stats":{"Line":2}},{"line":1474,"address":[12885718,12885790],"length":1,"stats":{"Line":4}},{"line":1478,"address":[12769319,12769222,12769530],"length":1,"stats":{"Line":4}},{"line":1479,"address":[12886199,12886233],"length":1,"stats":{"Line":0}},{"line":1482,"address":[15345262,15345196],"length":1,"stats":{"Line":0}},{"line":1485,"address":[20545270,20545044],"length":1,"stats":{"Line":0}},{"line":1486,"address":[20545097],"length":1,"stats":{"Line":0}},{"line":1491,"address":[12982545],"length":1,"stats":{"Line":2}},{"line":1494,"address":[12845008],"length":1,"stats":{"Line":2}},{"line":1495,"address":[12883158,12883544],"length":1,"stats":{"Line":2}},{"line":1496,"address":[15346024],"length":1,"stats":{"Line":2}},{"line":1498,"address":[12770565],"length":1,"stats":{"Line":2}},{"line":1504,"address":[12777987,12777648],"length":1,"stats":{"Line":0}},{"line":1505,"address":[12777678],"length":1,"stats":{"Line":0}},{"line":1506,"address":[12887556],"length":1,"stats":{"Line":0}},{"line":1507,"address":[12883647],"length":1,"stats":{"Line":0}},{"line":1508,"address":[15346464],"length":1,"stats":{"Line":0}},{"line":1509,"address":[20545956],"length":1,"stats":{"Line":0}},{"line":1510,"address":[12770992,12771057],"length":1,"stats":{"Line":0}},{"line":1514,"address":[12784992],"length":1,"stats":{"Line":1}},{"line":1516,"address":[12883966],"length":1,"stats":{"Line":1}},{"line":1532,"address":[12853232,12855213,12855440],"length":1,"stats":{"Line":0}},{"line":1533,"address":[12785610],"length":1,"stats":{"Line":0}},{"line":1535,"address":[12853545],"length":1,"stats":{"Line":0}},{"line":1536,"address":[12847586,12847471,12846859,12846937,12847312,12848502,12848294,12846791],"length":1,"stats":{"Line":0}},{"line":1537,"address":[12911858,12911840,12786035,12786149,12786403],"length":1,"stats":{"Line":0}},{"line":1538,"address":[12786322,12786524,12786720],"length":1,"stats":{"Line":0}},{"line":1539,"address":[12854432,12979762,12979744],"length":1,"stats":{"Line":0}},{"line":1541,"address":[12780092,12780373,12779946,12780423],"length":1,"stats":{"Line":0}},{"line":1542,"address":[12854788],"length":1,"stats":{"Line":0}},{"line":1543,"address":[12890181],"length":1,"stats":{"Line":0}},{"line":1544,"address":[20548480],"length":1,"stats":{"Line":0}},{"line":1547,"address":[12890800,12890928,12890992,12890736,12890864],"length":1,"stats":{"Line":2}},{"line":1550,"address":[12893323,12904596,12904978,12893393,12896368,12898503,12892877,12901844,12903805,12904251,12899464,12898731,12898285,12902226,12893664,12901053,12895799,12904325,12894046,12901499,12901271,12893095,12895581,12899082,12901573,12896097,12904023,12898811,12896750,12896027],"length":1,"stats":{"Line":8}},{"line":1552,"address":[12898460,12898525,12895887,12898591,12898345,12901293,12901228,12904045,12893325,12901359,12901113,12895756,12903865,12893183,12903980,12893117,12904111,12892937,12895641,12898733,12904253,12896029,12893052,12901501,12895821],"length":1,"stats":{"Line":8}},{"line":1553,"address":[12905216,12891968,12900148,12904914,12897386,12894672,12905056,12902900,12905234,12905074,12904736,12905394,12904896,12904754,12905376],"length":1,"stats":{"Line":0}},{"line":1554,"address":[12780699,12775474,12786406,12778178,12783461,12786213,12775281,12780892,12783654,12777985],"length":1,"stats":{"Line":4}},{"line":1555,"address":[12899113,12890885,12893599,12888181,12896361],"length":1,"stats":{"Line":2}},{"line":1556,"address":[20556301,20559387,20553587,20558691,20562139,20561443,20559063,20561815,20553374,20556631,20550670,20556411,20556088,20558850,20554759,20560271,20553215,20553687,20552055,20563023,20553907,20559167,20550511,20551203,20561602,20550883,20557527,20550983,20561919,20555929],"length":1,"stats":{"Line":8}},{"line":1558,"address":[12775667,12785598,12778431,12786721,12786871,12778371,12780078,12782846,12781357,12786599,12783847,12781085,12783907,12778643,12774670,12777374,12786659,12775789,12775727,12775939,12778493,12781145,12781207,12783969,12784119],"length":1,"stats":{"Line":6}},{"line":1559,"address":[12802976,12803154,12803296,12802656,12789939,12802834,12792643,12803136,12795367,12800875,12802816,12798123,12802674,12803314,12802994],"length":1,"stats":{"Line":0}},{"line":1560,"address":[12861678,12853446,12853608,12850904,12856170,12850742,12856332,12859088,12861840,12858926],"length":1,"stats":{"Line":4}},{"line":1561,"address":[12779022,12776383,12781811,12776318,12787254,12779087,12781746,12784502,12784567,12787319],"length":1,"stats":{"Line":0}},{"line":1562,"address":[12853719,12854017,12859513,12851015,12859199,12862265,12856443,12851313,12861951,12856763],"length":1,"stats":{"Line":0}},{"line":1564,"address":[12871321,12871417,12871216,12871312,12871408,12871369,12871264,12871225,12871273,12871360],"length":1,"stats":{"Line":0}},{"line":1565,"address":[12906640,12906596,12906788,12906832,12906576,12906704,12906724,12906852,12906768,12906660],"length":1,"stats":{"Line":0}},{"line":1567,"address":[12782265,12787767,12785015,12776815,12779519],"length":1,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1572,"address":[12794189,12791357,12788601,12791437,12785957,12788681,12783253,12785877,12794109,12783173],"length":1,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[12903600,12892324,12903618,12894491,12903138,12895092,12903280,12897247,12897836,12900588,12891767,12902960,12889063,12889620,12899999,12902978,12903120,12903298,12903440,12903458],"length":1,"stats":{"Line":4}}],"covered":413,"coverable":774},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","direct_message_handler.rs"],"content":"use crate::application::services::{\n    DirectMessageConversationPageResult, DirectMessagePageResult, DirectMessageService,\n    DirectMessageServiceDirection, SendDirectMessageResult,\n};\nuse crate::domain::entities::DirectMessage;\nuse crate::presentation::dto::direct_message_dto::{\n    DirectMessageConversationListDto, DirectMessageConversationSummaryDto, DirectMessageDto,\n    DirectMessagePage, ListDirectMessageConversationsRequest, ListDirectMessagesRequest,\n    MarkDirectMessageConversationReadRequest, MessagePageDirection as RequestDirection,\n    SendDirectMessageRequest, SendDirectMessageResponse,\n};\nuse crate::shared::AppError;\nuse std::sync::Arc;\n\npub struct DirectMessageHandler {\n    service: Arc<DirectMessageService>,\n}\n\nimpl DirectMessageHandler {\n    pub fn new(service: Arc<DirectMessageService>) -> Self {\n        Self { service }\n    }\n\n    pub async fn send_direct_message(\n        &self,\n        owner_npub: &str,\n        request: SendDirectMessageRequest,\n    ) -> Result<SendDirectMessageResponse, AppError> {\n        let result = self\n            .service\n            .send_direct_message(\n                owner_npub,\n                &request.recipient_npub,\n                &request.content,\n                request.client_message_id.clone(),\n            )\n            .await?;\n\n        Ok(to_send_response(result))\n    }\n\n    pub async fn list_direct_messages(\n        &self,\n        owner_npub: &str,\n        request: ListDirectMessagesRequest,\n    ) -> Result<DirectMessagePage, AppError> {\n        let limit = request.limit.map(|value| value as usize);\n        let direction = request\n            .direction\n            .map(map_direction)\n            .unwrap_or(DirectMessageServiceDirection::Backward);\n\n        let page = self\n            .service\n            .list_direct_messages(\n                owner_npub,\n                &request.conversation_npub,\n                request.cursor.as_deref(),\n                limit,\n                direction,\n            )\n            .await?;\n\n        Ok(to_page_dto(page))\n    }\n\n    pub async fn list_direct_message_conversations(\n        &self,\n        owner_npub: &str,\n        request: ListDirectMessageConversationsRequest,\n    ) -> Result<DirectMessageConversationListDto, AppError> {\n        let limit = request.limit.map(|value| value as usize);\n        let page: DirectMessageConversationPageResult = self\n            .service\n            .list_direct_message_conversations(owner_npub, request.cursor.as_deref(), limit)\n            .await?;\n\n        let items = page\n            .items\n            .into_iter()\n            .map(|summary| DirectMessageConversationSummaryDto {\n                conversation_npub: summary.conversation_npub,\n                unread_count: summary.unread_count,\n                last_read_at: summary.last_read_at,\n                last_message: summary.last_message.map(map_direct_message_to_dto),\n            })\n            .collect();\n\n        Ok(DirectMessageConversationListDto {\n            items,\n            next_cursor: page.next_cursor,\n            has_more: page.has_more,\n        })\n    }\n\n    pub async fn mark_conversation_as_read(\n        &self,\n        owner_npub: &str,\n        request: MarkDirectMessageConversationReadRequest,\n    ) -> Result<(), AppError> {\n        self.service\n            .mark_conversation_as_read(owner_npub, &request.conversation_npub, request.last_read_at)\n            .await\n    }\n}\n\nfn to_send_response(result: SendDirectMessageResult) -> SendDirectMessageResponse {\n    SendDirectMessageResponse {\n        event_id: result.event_id,\n        queued: result.queued,\n    }\n}\n\nfn to_page_dto(page: DirectMessagePageResult) -> DirectMessagePage {\n    let items = page\n        .items\n        .into_iter()\n        .map(map_direct_message_to_dto)\n        .collect();\n\n    DirectMessagePage {\n        items,\n        next_cursor: page.next_cursor,\n        has_more: page.has_more,\n    }\n}\n\nfn map_direction(direction: RequestDirection) -> DirectMessageServiceDirection {\n    match direction {\n        RequestDirection::Backward => DirectMessageServiceDirection::Backward,\n        RequestDirection::Forward => DirectMessageServiceDirection::Forward,\n    }\n}\n\nfn map_direct_message_to_dto(message: DirectMessage) -> DirectMessageDto {\n    let content = message.decrypted_content.clone().unwrap_or_default();\n    DirectMessageDto {\n        event_id: message.event_id.clone(),\n        client_message_id: message.client_message_id.clone(),\n        sender_npub: message.sender_npub.clone(),\n        recipient_npub: message.recipient_npub.clone(),\n        content,\n        created_at: message.created_at_millis(),\n        delivered: message.delivered,\n    }\n}\n","traces":[{"line":20,"address":[15344128],"length":1,"stats":{"Line":0}},{"line":24,"address":[15438928],"length":1,"stats":{"Line":0}},{"line":29,"address":[26610172,26610842,26610470,26610530,26610760,26611077],"length":1,"stats":{"Line":0}},{"line":33,"address":[15439394],"length":1,"stats":{"Line":0}},{"line":34,"address":[23001359],"length":1,"stats":{"Line":0}},{"line":35,"address":[15343072],"length":1,"stats":{"Line":0}},{"line":37,"address":[11627217],"length":1,"stats":{"Line":0}},{"line":39,"address":[15343694,15343867],"length":1,"stats":{"Line":0}},{"line":42,"address":[15302064],"length":1,"stats":{"Line":0}},{"line":47,"address":[15241730,15243184,15243188,15241576],"length":1,"stats":{"Line":0}},{"line":48,"address":[15346293,15346340],"length":1,"stats":{"Line":0}},{"line":51,"address":[15346332],"length":1,"stats":{"Line":0}},{"line":53,"address":[15347012,15346654,15346390,15347361,15346868,15346581],"length":1,"stats":{"Line":0}},{"line":57,"address":[15346441],"length":1,"stats":{"Line":0}},{"line":58,"address":[15302794],"length":1,"stats":{"Line":0}},{"line":62,"address":[15242222,15242404,15242785,15241653,15242099,15242159],"length":1,"stats":{"Line":0}},{"line":64,"address":[15345566,15345791],"length":1,"stats":{"Line":0}},{"line":67,"address":[15346080],"length":1,"stats":{"Line":0}},{"line":72,"address":[15349540,15349536,15348006,15348144],"length":1,"stats":{"Line":0}},{"line":73,"address":[15343419,15343102,15342764,15342592,15342708,15342969],"length":1,"stats":{"Line":0}},{"line":75,"address":[15443008],"length":1,"stats":{"Line":0}},{"line":76,"address":[23005066,23005305,23005009,23005126,23005643,23004756],"length":1,"stats":{"Line":0}},{"line":78,"address":[26614416,26614617],"length":1,"stats":{"Line":0}},{"line":81,"address":[15306038,15305856,15306110],"length":1,"stats":{"Line":0}},{"line":82,"address":[15245060],"length":1,"stats":{"Line":0}},{"line":83,"address":[15347957],"length":1,"stats":{"Line":0}},{"line":84,"address":[15349617],"length":1,"stats":{"Line":0}},{"line":85,"address":[15231341],"length":1,"stats":{"Line":0}},{"line":89,"address":[23005862],"length":1,"stats":{"Line":0}},{"line":91,"address":[15230847],"length":1,"stats":{"Line":0}},{"line":92,"address":[23005855],"length":1,"stats":{"Line":0}},{"line":96,"address":[26615312],"length":1,"stats":{"Line":0}},{"line":101,"address":[23007165,23006772,23006982,23006933],"length":1,"stats":{"Line":0}},{"line":102,"address":[15245657],"length":1,"stats":{"Line":0}},{"line":103,"address":[11086061],"length":1,"stats":{"Line":0}},{"line":107,"address":[15239200],"length":1,"stats":{"Line":0}},{"line":109,"address":[15232439],"length":1,"stats":{"Line":0}},{"line":110,"address":[15349115],"length":1,"stats":{"Line":0}},{"line":114,"address":[15349461,15349184],"length":1,"stats":{"Line":0}},{"line":115,"address":[15232650,15232565],"length":1,"stats":{"Line":0}},{"line":123,"address":[15445778],"length":1,"stats":{"Line":0}},{"line":124,"address":[15314262],"length":1,"stats":{"Line":0}},{"line":128,"address":[23007824],"length":1,"stats":{"Line":0}},{"line":129,"address":[26616553],"length":1,"stats":{"Line":0}},{"line":130,"address":[15232872],"length":1,"stats":{"Line":0}},{"line":131,"address":[15349519],"length":1,"stats":{"Line":0}},{"line":135,"address":[15351890,15351184,15351940],"length":1,"stats":{"Line":0}},{"line":136,"address":[15314510,15314438],"length":1,"stats":{"Line":0}},{"line":138,"address":[15349664],"length":1,"stats":{"Line":0}},{"line":139,"address":[15314607],"length":1,"stats":{"Line":0}},{"line":140,"address":[15246913],"length":1,"stats":{"Line":0}},{"line":141,"address":[15351507],"length":1,"stats":{"Line":0}},{"line":143,"address":[15240106],"length":1,"stats":{"Line":0}},{"line":144,"address":[23008371],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","event_handler.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::application::services::event_service::EventServiceTrait;\nuse crate::infrastructure::event::EventManagerHandle;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::event::{\n    EventResponse, NostrMetadataDto, NostrSubscriptionStateDto, PublishTextNoteRequest,\n    PublishTopicPostRequest, SendReactionRequest, SubscribeRequest, UpdateMetadataRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse serde_json::json;\nuse std::sync::Arc;\n\npub struct EventHandler {\n    event_service: Arc<dyn EventServiceTrait>,\n    key_manager: Arc<dyn KeyManager>,\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl EventHandler {\n    pub fn new(\n        event_service: Arc<dyn EventServiceTrait>,\n        key_manager: Arc<dyn KeyManager>,\n        event_manager: Arc<dyn EventManagerHandle>,\n    ) -> Self {\n        Self {\n            event_service,\n            key_manager,\n            event_manager,\n        }\n    }\n\n    /// Nostrクライアントを初期化\n    pub async fn initialize_nostr(&self) -> Result<serde_json::Value, AppError> {\n        let keypair = self\n            .key_manager\n            .current_keypair()\n            .await\n            .map_err(|err| match err {\n                AppError::NotFound(_) | AppError::Unauthorized(_) => {\n                    AppError::Unauthorized(format!(\"No active account: {err}\"))\n                }\n                other => other,\n            })?;\n\n        self.event_manager\n            .initialize_with_keypair(keypair)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))?;\n\n        self.event_service.initialize().await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// テキストノートを投稿\n    pub async fn publish_text_note(\n        &self,\n        request: PublishTextNoteRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_text_note(&request.content)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Text note published successfully\".to_string()),\n        })\n    }\n\n    /// トピック投稿を作成\n    pub async fn publish_topic_post(\n        &self,\n        request: PublishTopicPostRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_topic_post(\n                &request.topic_id,\n                &request.content,\n                request.reply_to.as_deref(),\n                None,\n                None,\n            )\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Topic post published successfully\".to_string()),\n        })\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(\n        &self,\n        request: SendReactionRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .send_reaction(&request.event_id, &request.reaction)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Reaction sent successfully\".to_string()),\n        })\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(\n        &self,\n        request: UpdateMetadataRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let metadata = NostrMetadataDto {\n            name: request.metadata.name,\n            display_name: request.metadata.display_name,\n            about: request.metadata.about,\n            picture: request.metadata.picture,\n            banner: request.metadata.banner,\n            nip05: request.metadata.nip05,\n            lud16: request.metadata.lud16,\n            website: request.metadata.website,\n            relays: request.metadata.relays,\n            privacy: request.metadata.privacy,\n        };\n\n        let event_id = self.event_service.update_metadata(metadata).await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Metadata updated successfully\".to_string()),\n        })\n    }\n\n    /// トピックをサブスクライブ\n    pub async fn subscribe_to_topic(\n        &self,\n        request: SubscribeRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        request.validate()?;\n\n        self.event_service\n            .subscribe_to_topic(&request.topic_id)\n            .await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// ユーザーをサブスクライブ\n    pub async fn subscribe_to_user(&self, pubkey: String) -> Result<serde_json::Value, AppError> {\n        if pubkey.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Public key is required\".to_string(),\n            ));\n        }\n\n        self.event_service.subscribe_to_user(&pubkey).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// Nostrクライアントを切断\n    pub async fn disconnect_nostr(&self) -> Result<serde_json::Value, AppError> {\n        self.event_service.disconnect().await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// 現在のNostr購読状態一覧を取得\n    pub async fn list_subscriptions(&self) -> Result<serde_json::Value, AppError> {\n        let records = self.event_service.list_subscriptions().await?;\n        let subscriptions: Vec<NostrSubscriptionStateDto> =\n            records.into_iter().map(Into::into).collect();\n        Ok(json!({ \"subscriptions\": subscriptions }))\n    }\n}\n","traces":[{"line":20,"address":[23040896],"length":1,"stats":{"Line":0}},{"line":33,"address":[15370064,15370072,15370143,15370273,15370555,15371553,15370096,15370370],"length":1,"stats":{"Line":0}},{"line":34,"address":[23109125,23109405,23109563,23108920,23109208,23109953,23110273],"length":1,"stats":{"Line":0}},{"line":37,"address":[11748225],"length":1,"stats":{"Line":0}},{"line":38,"address":[23104710,23104997,23104688],"length":1,"stats":{"Line":0}},{"line":40,"address":[15372985,15372941],"length":1,"stats":{"Line":0}},{"line":42,"address":[23148442],"length":1,"stats":{"Line":0}},{"line":45,"address":[23145349,23145628,23145926,23144980,23145779,23145540,23145279],"length":1,"stats":{"Line":0}},{"line":46,"address":[23146819],"length":1,"stats":{"Line":0}},{"line":47,"address":[10909505],"length":1,"stats":{"Line":0}},{"line":48,"address":[23035875,23037266,23037248],"length":1,"stats":{"Line":0}},{"line":50,"address":[11541977],"length":1,"stats":{"Line":0}},{"line":51,"address":[23104158,23104250],"length":1,"stats":{"Line":0}},{"line":55,"address":[23044384],"length":1,"stats":{"Line":0}},{"line":59,"address":[23031265,23030936,23031024,23030817],"length":1,"stats":{"Line":0}},{"line":61,"address":[23149450,23149718,23149291,23149832,23149509,23150026,23150493],"length":1,"stats":{"Line":0}},{"line":63,"address":[15373785],"length":1,"stats":{"Line":0}},{"line":64,"address":[11650753],"length":1,"stats":{"Line":0}},{"line":66,"address":[23150211],"length":1,"stats":{"Line":0}},{"line":67,"address":[23244732],"length":1,"stats":{"Line":0}},{"line":69,"address":[23244891,23244963],"length":1,"stats":{"Line":0}},{"line":74,"address":[23032224],"length":1,"stats":{"Line":0}},{"line":78,"address":[23040013,23039418,23039515,23039296],"length":1,"stats":{"Line":0}},{"line":80,"address":[23107296,23107655,23108316,23108802,23108122,23107768,23107989],"length":1,"stats":{"Line":0}},{"line":83,"address":[23039616],"length":1,"stats":{"Line":0}},{"line":84,"address":[23107488],"length":1,"stats":{"Line":0}},{"line":85,"address":[23149597],"length":1,"stats":{"Line":0}},{"line":86,"address":[23246111],"length":1,"stats":{"Line":0}},{"line":87,"address":[15375643],"length":1,"stats":{"Line":0}},{"line":89,"address":[11659300],"length":1,"stats":{"Line":0}},{"line":91,"address":[23115429],"length":1,"stats":{"Line":0}},{"line":92,"address":[23146350],"length":1,"stats":{"Line":0}},{"line":94,"address":[23115325,23115397],"length":1,"stats":{"Line":0}},{"line":99,"address":[23047984],"length":1,"stats":{"Line":0}},{"line":103,"address":[23147176,23147298,23147689,23147389],"length":1,"stats":{"Line":0}},{"line":105,"address":[23151910,23151522,23151304,23152577,23151581,23151790,23152104],"length":1,"stats":{"Line":0}},{"line":107,"address":[23247846],"length":1,"stats":{"Line":0}},{"line":108,"address":[11732817],"length":1,"stats":{"Line":0}},{"line":110,"address":[23049409],"length":1,"stats":{"Line":0}},{"line":111,"address":[23148090],"length":1,"stats":{"Line":0}},{"line":113,"address":[23049305,23049377],"length":1,"stats":{"Line":0}},{"line":118,"address":[23249024],"length":1,"stats":{"Line":0}},{"line":122,"address":[17290822,17291935,17290706,17291657],"length":1,"stats":{"Line":0}},{"line":125,"address":[23249655],"length":1,"stats":{"Line":0}},{"line":126,"address":[23154918],"length":1,"stats":{"Line":0}},{"line":127,"address":[23149381],"length":1,"stats":{"Line":0}},{"line":128,"address":[23050484],"length":1,"stats":{"Line":0}},{"line":129,"address":[23118291],"length":1,"stats":{"Line":0}},{"line":130,"address":[23249890],"length":1,"stats":{"Line":0}},{"line":131,"address":[23036865],"length":1,"stats":{"Line":0}},{"line":132,"address":[23111504],"length":1,"stats":{"Line":0}},{"line":133,"address":[23149663],"length":1,"stats":{"Line":0}},{"line":134,"address":[17291310],"length":1,"stats":{"Line":0}},{"line":137,"address":[23155752,23156340,23154748,23155976,23155620],"length":1,"stats":{"Line":0}},{"line":139,"address":[23154925],"length":1,"stats":{"Line":0}},{"line":140,"address":[23150726],"length":1,"stats":{"Line":0}},{"line":142,"address":[23051941,23052013],"length":1,"stats":{"Line":0}},{"line":147,"address":[23156816],"length":1,"stats":{"Line":0}},{"line":151,"address":[17295121,17294673,17294792,17294880],"length":1,"stats":{"Line":0}},{"line":153,"address":[23122293,23122502,23122234,23123153,23122075,23122721,23122606],"length":1,"stats":{"Line":0}},{"line":154,"address":[23158953],"length":1,"stats":{"Line":0}},{"line":155,"address":[23159441,23159030,23159077,23158715,23159165,23159318],"length":1,"stats":{"Line":0}},{"line":157,"address":[23115738,23115830],"length":1,"stats":{"Line":0}},{"line":161,"address":[23041648,23041867,23043080,23042982,23041696,23041656,23041737,23042295],"length":1,"stats":{"Line":0}},{"line":162,"address":[23160132,23160247],"length":1,"stats":{"Line":0}},{"line":163,"address":[23158848],"length":1,"stats":{"Line":0}},{"line":164,"address":[17296295],"length":1,"stats":{"Line":0}},{"line":165,"address":[23055759],"length":1,"stats":{"Line":0}},{"line":169,"address":[23042327,23042053,23041894,23042606,23041970,23043089],"length":1,"stats":{"Line":0}},{"line":171,"address":[23160979,23160887],"length":1,"stats":{"Line":0}},{"line":175,"address":[23124632,23124799,23124762,23125697,23124624,23124675,23124949,23124640],"length":1,"stats":{"Line":0}},{"line":176,"address":[15386029,15385557,15385665,15386490,15385785,15385601],"length":1,"stats":{"Line":0}},{"line":178,"address":[23050498,23050584],"length":1,"stats":{"Line":0}},{"line":182,"address":[23120289,23118835,23118800,23118792,23119136,23118784,23118986,23118938],"length":1,"stats":{"Line":0}},{"line":183,"address":[11617124],"length":1,"stats":{"Line":0}},{"line":184,"address":[23163181,23163368],"length":1,"stats":{"Line":0}},{"line":186,"address":[23258265,23258747,23258214],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","mod.rs"],"content":"pub mod auth_handler;\npub mod community_node_handler;\npub mod direct_message_handler;\npub mod event_handler;\npub mod offline_handler;\npub mod p2p_handler;\npub mod post_handler;\npub mod secure_storage_handler;\npub mod topic_handler;\n\npub use auth_handler::AuthHandler;\npub use community_node_handler::CommunityNodeHandler;\npub use direct_message_handler::DirectMessageHandler;\npub use event_handler::EventHandler;\npub use offline_handler::OfflineHandler;\npub use p2p_handler::P2PHandler;\npub use post_handler::PostHandler;\npub use secure_storage_handler::SecureStorageHandler;\npub use topic_handler::TopicHandler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","offline_handler.rs"],"content":"use crate::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateDraft,\n    SyncQueueItem, SyncQueueItemDraft, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, SyncQueueId, SyncStatus,\n};\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, CacheTypeStatus, GetOfflineActionsRequest,\n    ListSyncQueueItemsRequest, OfflineAction, OptimisticUpdateRequest, SaveOfflineActionRequest,\n    SaveOfflineActionResponse, SyncOfflineActionsRequest, SyncOfflineActionsResponse,\n    SyncQueueItemResponse, UpdateCacheMetadataRequest, UpdateSyncStatusRequest,\n};\nuse crate::shared::{AppError, ValidationFailureKind};\nuse chrono::{Duration, Utc};\nuse serde_json::{Value, json};\nuse std::convert::{TryFrom, TryInto};\nuse std::sync::Arc;\n\npub struct OfflineHandler {\n    offline_service: Arc<dyn OfflineServiceTrait>,\n}\n\nimpl OfflineHandler {\n    pub fn new(offline_service: Arc<dyn OfflineServiceTrait>) -> Self {\n        Self { offline_service }\n    }\n    pub async fn save_offline_action(\n        &self,\n        request: SaveOfflineActionRequest,\n    ) -> Result<SaveOfflineActionResponse, AppError> {\n        request.validate()?;\n\n        let params = SaveOfflineActionParams {\n            user_pubkey: parse_public_key(&request.user_pubkey)?,\n            action_type: parse_action_type(&request.action_type)?,\n            entity_type: parse_entity_type(&request.entity_type)?,\n            entity_id: parse_entity_id(&request.entity_id)?,\n            payload: parse_payload(&request.data)?,\n        };\n\n        let saved = self.offline_service.save_action(params).await?;\n        let action = map_action_record(&saved.action)?;\n\n        Ok(SaveOfflineActionResponse {\n            local_id: saved.local_id.to_string(),\n            action,\n        })\n    }\n\n    pub async fn get_offline_actions(\n        &self,\n        request: GetOfflineActionsRequest,\n    ) -> Result<Vec<OfflineAction>, AppError> {\n        request.validate()?;\n\n        let query = OfflineActionsQuery {\n            user_pubkey: match request.user_pubkey.as_deref() {\n                Some(value) => Some(parse_public_key(value)?),\n                None => None,\n            },\n            include_synced: request.is_synced,\n            limit: request.limit.map(|value| value as u32),\n        };\n\n        let actions = self.offline_service.list_actions(query).await?;\n        actions\n            .iter()\n            .map(map_action_record)\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub async fn sync_offline_actions(\n        &self,\n        request: SyncOfflineActionsRequest,\n    ) -> Result<SyncOfflineActionsResponse, AppError> {\n        request.validate()?;\n\n        let pubkey = parse_public_key(&request.user_pubkey)?;\n        let result = self.offline_service.sync_actions(pubkey).await?;\n\n        Ok(SyncOfflineActionsResponse {\n            synced_count: i32::try_from(result.synced_count)\n                .map_err(|_| AppError::Internal(\"Synced count overflowed i32\".to_string()))?,\n            failed_count: i32::try_from(result.failed_count)\n                .map_err(|_| AppError::Internal(\"Failed count overflowed i32\".to_string()))?,\n            pending_count: i32::try_from(result.pending_count)\n                .map_err(|_| AppError::Internal(\"Pending count overflowed i32\".to_string()))?,\n        })\n    }\n\n    pub async fn get_cache_status(&self) -> Result<CacheStatusResponse, AppError> {\n        let snapshot = self.offline_service.cache_status().await?;\n        map_cache_status(snapshot)\n    }\n\n    pub async fn add_to_sync_queue(&self, request: AddToSyncQueueRequest) -> Result<i64, AppError> {\n        request.validate()?;\n\n        let draft = SyncQueueItemDraft::new(\n            parse_action_type(&request.action_type)?,\n            OfflinePayload::new(request.payload.clone())\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            request\n                .priority\n                .map(|value| {\n                    u8::try_from(value).map_err(|_| {\n                        AppError::validation(\n                            ValidationFailureKind::Generic,\n                            \"Priority must fit in u8\",\n                        )\n                    })\n                })\n                .transpose()?,\n        );\n        let queue_id = self.offline_service.enqueue_sync(draft).await?;\n\n        if let Some(cache_type) = request\n            .payload\n            .get(\"cacheType\")\n            .and_then(|value| value.as_str())\n        {\n            if let Err(err) = self\n                .record_sync_queue_metadata(cache_type, &request.payload, queue_id)\n                .await\n            {\n                tracing::warn!(\n                    target: \"offline::handler\",\n                    error = %err,\n                    \"failed to update sync_queue metadata for {cache_type}\"\n                );\n            }\n        }\n        Ok(queue_id.value())\n    }\n\n    pub async fn list_sync_queue_items(\n        &self,\n        request: ListSyncQueueItemsRequest,\n    ) -> Result<Vec<SyncQueueItemResponse>, AppError> {\n        request.validate()?;\n        let limit = request\n            .limit\n            .map(|value| {\n                u32::try_from(value).map_err(|_| {\n                    AppError::validation(\n                        ValidationFailureKind::Generic,\n                        \"Limit must fit in u32\".to_string(),\n                    )\n                })\n            })\n            .transpose()?;\n\n        let items = self.offline_service.recent_sync_queue_items(limit).await?;\n\n        items\n            .iter()\n            .map(map_sync_queue_item)\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub async fn update_cache_metadata(\n        &self,\n        request: UpdateCacheMetadataRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = CacheMetadataUpdate {\n            cache_key: CacheKey::new(request.cache_key)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            cache_type: CacheType::new(request.cache_type)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?,\n            metadata: request.metadata,\n            is_stale: request.is_stale,\n            expiry: request\n                .expiry_seconds\n                .map(|seconds| {\n                    if seconds <= 0 {\n                        return Err(AppError::validation(\n                            ValidationFailureKind::Generic,\n                            \"Expiry seconds must be positive\".to_string(),\n                        ));\n                    }\n                    Ok(Utc::now() + Duration::seconds(seconds))\n                })\n                .transpose()?,\n            doc_version: request.doc_version,\n            blob_hash: request.blob_hash,\n            payload_bytes: request.payload_bytes,\n        };\n\n        self.offline_service.upsert_cache_metadata(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn save_optimistic_update(\n        &self,\n        request: OptimisticUpdateRequest,\n    ) -> Result<String, AppError> {\n        request.validate()?;\n\n        let draft = OptimisticUpdateDraft::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            match request.original_data {\n                Some(ref data) => Some(parse_payload(data)?),\n                None => None,\n            },\n            parse_payload(&request.updated_data)?,\n        );\n\n        let update_id = self.offline_service.save_optimistic_update(draft).await?;\n        Ok(update_id.to_string())\n    }\n\n    pub async fn confirm_optimistic_update(&self, update_id: String) -> Result<Value, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id)\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        self.offline_service.confirm_optimistic_update(id).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn rollback_optimistic_update(\n        &self,\n        update_id: String,\n    ) -> Result<Option<String>, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::validation(\n                ValidationFailureKind::Generic,\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id)\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let original = self.offline_service.rollback_optimistic_update(id).await?;\n\n        let serialized = original\n            .map(|payload| serde_json::to_string(&payload.into_inner()))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n\n        Ok(serialized)\n    }\n\n    pub async fn cleanup_expired_cache(&self) -> Result<i32, AppError> {\n        let cleaned = self.offline_service.cleanup_expired_cache().await?;\n        cleaned\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed i32\".to_string()))\n    }\n\n    pub async fn update_sync_status(\n        &self,\n        request: UpdateSyncStatusRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = SyncStatusUpdate::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            map_sync_status(&request.sync_status),\n            parse_optional_payload(request.conflict_data)?,\n            Utc::now(),\n        );\n\n        self.offline_service.update_sync_status(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n}\n\nfn parse_public_key(value: &str) -> Result<PublicKey, AppError> {\n    PublicKey::from_hex_str(value)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_action_type(value: &str) -> Result<OfflineActionType, AppError> {\n    OfflineActionType::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_entity_type(value: &str) -> Result<EntityType, AppError> {\n    EntityType::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_entity_id(value: &str) -> Result<EntityId, AppError> {\n    EntityId::new(value.to_string())\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_payload(data: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(data)\n        .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n}\n\nfn parse_optional_payload(data: Option<String>) -> Result<Option<OfflinePayload>, AppError> {\n    match data {\n        Some(raw) => {\n            let parsed =\n                serde_json::from_str::<Value>(&raw).unwrap_or_else(|_| Value::String(raw.clone()));\n            OfflinePayload::new(parsed)\n                .map(Some)\n                .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))\n        }\n        None => Ok(None),\n    }\n}\n\nimpl OfflineHandler {\n    async fn record_sync_queue_metadata(\n        &self,\n        cache_type_str: &str,\n        payload: &Value,\n        queue_id: SyncQueueId,\n    ) -> Result<(), AppError> {\n        let cache_key = CacheKey::new(format!(\"sync_queue::{cache_type_str}\"))\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        let cache_type = CacheType::new(\"sync_queue\".to_string())\n            .map_err(AppError::validation_mapper(ValidationFailureKind::Generic))?;\n        // NOTE: 現状は sync_queue を仮想的なキャッシュ種別としてまとめている。\n        // 将来的にキャッシュ種類ごとのキュー状況を分離する場合はここで cache_type を切り替える。\n\n        let requested_at = payload\n            .get(\"requestedAt\")\n            .and_then(|value| value.as_str())\n            .map(|value| value.to_string())\n            .unwrap_or_else(|| Utc::now().to_rfc3339());\n\n        let metadata = json!({\n            \"cacheType\": cache_type_str,\n            \"requestedAt\": requested_at,\n            \"requestedBy\": payload.get(\"userPubkey\").and_then(|value| value.as_str()),\n            \"source\": payload.get(\"source\").and_then(|value| value.as_str()).unwrap_or(\"unknown\"),\n            \"queueItemId\": queue_id.value(),\n        });\n\n        let doc_version = payload\n            .get(\"docVersion\")\n            .or_else(|| payload.get(\"doc_version\"))\n            .and_then(|value| value.as_i64());\n        let blob_hash = payload\n            .get(\"blobHash\")\n            .or_else(|| payload.get(\"blob_hash\"))\n            .and_then(|value| value.as_str())\n            .map(|value| value.to_string());\n        let payload_bytes = payload\n            .get(\"payloadBytes\")\n            .or_else(|| payload.get(\"payload_bytes\"))\n            .or_else(|| payload.get(\"sizeBytes\"))\n            .and_then(|value| value.as_i64());\n\n        let update = CacheMetadataUpdate {\n            cache_key,\n            cache_type,\n            metadata: Some(metadata),\n            expiry: Some(Utc::now() + Duration::minutes(30)),\n            is_stale: Some(true),\n            doc_version,\n            blob_hash,\n            payload_bytes,\n        };\n\n        self.offline_service.upsert_cache_metadata(update).await\n    }\n}\n\npub(crate) fn map_action_record(record: &OfflineActionRecord) -> Result<OfflineAction, AppError> {\n    Ok(OfflineAction {\n        id: record.record_id.unwrap_or_default(),\n        user_pubkey: record.user_pubkey.as_hex().to_string(),\n        action_type: record.action_type.as_str().to_string(),\n        target_id: record.target_id.as_ref().map(ToString::to_string),\n        action_data: serde_json::to_string(record.payload.as_json())\n            .map_err(|err| AppError::SerializationError(err.to_string()))?,\n        local_id: record.action_id.to_string(),\n        remote_id: record.remote_id.as_ref().map(ToString::to_string),\n        is_synced: matches!(record.sync_status, SyncStatus::FullySynced),\n        created_at: record.created_at.timestamp(),\n        synced_at: record.synced_at.map(|ts| ts.timestamp()),\n        error_message: record.error_message.clone(),\n    })\n}\n\nfn map_sync_queue_item(item: &SyncQueueItem) -> Result<SyncQueueItemResponse, AppError> {\n    Ok(SyncQueueItemResponse {\n        id: item.id.value(),\n        action_type: item.action_type.as_str().to_string(),\n        status: item.status.as_str().to_string(),\n        retry_count: i32::try_from(item.retry_count)\n            .map_err(|_| AppError::Internal(\"retry_count overflowed i32\".to_string()))?,\n        max_retries: i32::try_from(item.max_retries)\n            .map_err(|_| AppError::Internal(\"max_retries overflowed i32\".to_string()))?,\n        created_at: item.created_at.timestamp(),\n        updated_at: item.updated_at.timestamp(),\n        synced_at: item.synced_at.map(|ts| ts.timestamp()),\n        error_message: item.error_message.clone(),\n        payload: item.payload.as_json().clone(),\n    })\n}\n\nfn map_cache_status(snapshot: CacheStatusSnapshot) -> Result<CacheStatusResponse, AppError> {\n    let cache_types = snapshot\n        .cache_types\n        .into_iter()\n        .map(|status| {\n            Ok(CacheTypeStatus {\n                cache_type: status.cache_type.to_string(),\n                item_count: status.item_count.try_into().map_err(|_| {\n                    AppError::Internal(\"Cache item count overflowed i64\".to_string())\n                })?,\n                last_synced_at: status.last_synced_at.map(|dt| dt.timestamp()),\n                is_stale: status.is_stale,\n                metadata: status.metadata,\n                doc_version: status.doc_version,\n                blob_hash: status.blob_hash.clone(),\n                payload_bytes: status.payload_bytes,\n            })\n        })\n        .collect::<Result<Vec<_>, AppError>>()?;\n\n    Ok(CacheStatusResponse {\n        total_items: snapshot\n            .total_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Total items overflowed i64\".to_string()))?,\n        stale_items: snapshot\n            .stale_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Stale items overflowed i64\".to_string()))?,\n        cache_types,\n    })\n}\n\nfn map_sync_status(value: &str) -> SyncStatus {\n    match value {\n        \"pending\" => SyncStatus::Pending,\n        \"syncing\" => SyncStatus::SentToP2P,\n        \"synced\" => SyncStatus::FullySynced,\n        \"failed\" => SyncStatus::Failed,\n        \"conflict\" => SyncStatus::Conflict,\n        other => SyncStatus::from(other),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::application::ports::offline_store::OfflinePersistence;\n    use crate::application::services::offline_service::OfflineService;\n    use crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\n    use sqlx::sqlite::SqlitePoolOptions;\n    use sqlx::{Pool, Sqlite};\n    use std::sync::Arc;\n\n    async fn setup_handler() -> (OfflineHandler, Pool<Sqlite>) {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"in-memory sqlite\");\n        sqlx::migrate!(\"./migrations\")\n            .run(&pool)\n            .await\n            .expect(\"migrations\");\n\n        let persistence: Arc<dyn OfflinePersistence> =\n            Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n        let service = OfflineService::new(persistence);\n        (OfflineHandler::new(Arc::new(service)), pool)\n    }\n\n    #[tokio::test]\n    async fn add_to_sync_queue_records_metadata_entry() {\n        let (handler, pool) = setup_handler().await;\n        let request = AddToSyncQueueRequest {\n            action_type: \"manual_sync_refresh\".to_string(),\n            payload: serde_json::json!({\n                \"cacheType\": \"offline_actions\",\n                \"requestedAt\": \"2025-11-09T00:00:00Z\",\n                \"source\": \"sync_status_indicator\",\n                \"userPubkey\": \"npub1testexample\",\n                \"docVersion\": 7,\n                \"blobHash\": \"bafy-doc-test\",\n                \"payloadBytes\": 5120\n            }),\n            priority: Some(5),\n        };\n\n        let queue_id = handler.add_to_sync_queue(request).await.expect(\"queue id\");\n\n        let (cache_key, cache_type, metadata, doc_version, blob_hash, payload_bytes): (\n            String,\n            String,\n            Option<String>,\n            Option<i64>,\n            Option<String>,\n            Option<i64>,\n        ) = sqlx::query_as(\n            r#\"\n                SELECT cache_key, cache_type, metadata, doc_version, blob_hash, payload_bytes\n                FROM cache_metadata\n                WHERE cache_key = 'sync_queue::offline_actions'\n                \"#,\n        )\n        .fetch_one(&pool)\n        .await\n        .expect(\"metadata row\");\n\n        assert_eq!(cache_key, \"sync_queue::offline_actions\");\n        assert_eq!(cache_type, \"sync_queue\");\n\n        let json = metadata.expect(\"metadata json\");\n        let parsed: serde_json::Value = serde_json::from_str(&json).expect(\"parse metadata\");\n        assert_eq!(\n            parsed.get(\"queueItemId\").and_then(|value| value.as_i64()),\n            Some(queue_id)\n        );\n        assert_eq!(\n            parsed.get(\"requestedBy\").and_then(|value| value.as_str()),\n            Some(\"npub1testexample\")\n        );\n        assert_eq!(\n            parsed.get(\"source\").and_then(|value| value.as_str()),\n            Some(\"sync_status_indicator\")\n        );\n        assert_eq!(doc_version, Some(7));\n        assert_eq!(blob_hash.as_deref(), Some(\"bafy-doc-test\"));\n        assert_eq!(payload_bytes, Some(5120));\n    }\n\n    #[tokio::test]\n    async fn cache_status_includes_doc_fields() {\n        let (handler, _) = setup_handler().await;\n        handler\n            .update_cache_metadata(UpdateCacheMetadataRequest {\n                cache_key: \"doc::profile_avatar::npub1\".to_string(),\n                cache_type: \"profile_avatar\".to_string(),\n                metadata: Some(json!({ \"cacheType\": \"profile_avatar\" })),\n                expiry_seconds: Some(1800),\n                is_stale: Some(true),\n                doc_version: Some(12),\n                blob_hash: Some(\"bafy-test-hash\".to_string()),\n                payload_bytes: Some(10_240),\n            })\n            .await\n            .expect(\"metadata write\");\n\n        let snapshot = handler.get_cache_status().await.expect(\"cache status\");\n        let entry = snapshot\n            .cache_types\n            .into_iter()\n            .find(|value| value.cache_type == \"profile_avatar\")\n            .expect(\"profile avatar cache\");\n\n        assert_eq!(entry.doc_version, Some(12));\n        assert_eq!(entry.blob_hash.as_deref(), Some(\"bafy-test-hash\"));\n        assert_eq!(entry.payload_bytes, Some(10_240));\n    }\n\n    #[tokio::test]\n    async fn list_sync_queue_items_returns_recent_rows() {\n        let (handler, pool) = setup_handler().await;\n\n        let first_id = handler\n            .add_to_sync_queue(AddToSyncQueueRequest {\n                action_type: \"manual_sync_refresh\".to_string(),\n                payload: serde_json::json!({\n                    \"cacheType\": \"offline_actions\",\n                    \"source\": \"sync_status_indicator\"\n                }),\n                priority: Some(3),\n            })\n            .await\n            .expect(\"first queue id\");\n\n        let second_id = handler\n            .add_to_sync_queue(AddToSyncQueueRequest {\n                action_type: \"manual_sync_refresh\".to_string(),\n                payload: serde_json::json!({\n                    \"cacheType\": \"cache_metadata\",\n                    \"source\": \"sync_status_indicator\"\n                }),\n                priority: Some(2),\n            })\n            .await\n            .expect(\"second queue id\");\n\n        sqlx::query(\n            r#\"\n            UPDATE sync_queue\n            SET status = 'failed',\n                error_message = 'timeout',\n                updated_at = strftime('%s','now')\n            WHERE id = ?1\n            \"#,\n        )\n        .bind(first_id)\n        .execute(&pool)\n        .await\n        .expect(\"update queue row\");\n\n        let items = handler\n            .list_sync_queue_items(ListSyncQueueItemsRequest { limit: Some(10) })\n            .await\n            .expect(\"queue items\");\n\n        assert!(\n            items.len() >= 2,\n            \"expected at least two queue items, got {}\",\n            items.len()\n        );\n\n        let failed = items\n            .iter()\n            .find(|item| item.id == first_id)\n            .expect(\"failed queue item present\");\n        assert_eq!(failed.status, \"failed\");\n        assert_eq!(failed.error_message.as_deref(), Some(\"timeout\"));\n\n        assert!(\n            items.iter().any(|item| item.id == second_id),\n            \"second queue id should be present\"\n        );\n    }\n}\n","traces":[{"line":31,"address":[13616128],"length":1,"stats":{"Line":1}},{"line":34,"address":[13534640],"length":1,"stats":{"Line":0}},{"line":38,"address":[13647916,13647819,13647697,13650844],"length":1,"stats":{"Line":0}},{"line":41,"address":[13542123,13542299,13544919,13541961],"length":1,"stats":{"Line":0}},{"line":42,"address":[13549420,13549596,13549234],"length":1,"stats":{"Line":0}},{"line":43,"address":[19329120,19328963,19328780],"length":1,"stats":{"Line":0}},{"line":44,"address":[13617636,13617822,13617998],"length":1,"stats":{"Line":0}},{"line":45,"address":[13536623,13536943,13536437],"length":1,"stats":{"Line":0}},{"line":48,"address":[11647156],"length":1,"stats":{"Line":0}},{"line":49,"address":[13538695,13538544,13538848],"length":1,"stats":{"Line":0}},{"line":51,"address":[13545821],"length":1,"stats":{"Line":0}},{"line":52,"address":[13655458],"length":1,"stats":{"Line":0}},{"line":53,"address":[13651724],"length":1,"stats":{"Line":0}},{"line":57,"address":[13546112],"length":1,"stats":{"Line":0}},{"line":61,"address":[13546595,13546494,13547519,13546372],"length":1,"stats":{"Line":0}},{"line":64,"address":[13546556,13546719],"length":1,"stats":{"Line":0}},{"line":68,"address":[21315027],"length":1,"stats":{"Line":0}},{"line":69,"address":[13659856,13659862,13658354],"length":1,"stats":{"Line":0}},{"line":72,"address":[11678129],"length":1,"stats":{"Line":0}},{"line":73,"address":[13615889,13615718],"length":1,"stats":{"Line":0}},{"line":79,"address":[13548368],"length":1,"stats":{"Line":0}},{"line":83,"address":[21316890,21316771,21316981,21317585],"length":1,"stats":{"Line":0}},{"line":85,"address":[13616715,13617185,13616891,13616568],"length":1,"stats":{"Line":0}},{"line":86,"address":[11582817],"length":1,"stats":{"Line":0}},{"line":88,"address":[13618174],"length":1,"stats":{"Line":0}},{"line":89,"address":[13655785,13656576,13655944,13655670],"length":1,"stats":{"Line":0}},{"line":90,"address":[13550718,13550704,13549976],"length":1,"stats":{"Line":0}},{"line":91,"address":[19335724,19336386,19335843,19335986],"length":1,"stats":{"Line":0}},{"line":92,"address":[13624916,13625550,13625536],"length":1,"stats":{"Line":0}},{"line":93,"address":[13660367,13660014,13660129,13660502],"length":1,"stats":{"Line":0}},{"line":94,"address":[13625199,13625632,13625646],"length":1,"stats":{"Line":0}},{"line":98,"address":[13557976,13557984,13558114,13558311,13558955,13558019,13557968,13558162],"length":1,"stats":{"Line":4}},{"line":99,"address":[13660973,13661096,13661644,13661021,13661223],"length":1,"stats":{"Line":3}},{"line":100,"address":[13657631],"length":1,"stats":{"Line":1}},{"line":103,"address":[13547497,13545544,13548617,13547817,13545296,13545343,13545251,13545216],"length":1,"stats":{"Line":4}},{"line":104,"address":[13658217,13658360,13660493,13658457],"length":1,"stats":{"Line":2}},{"line":107,"address":[13759115,13758790,13758945],"length":1,"stats":{"Line":2}},{"line":108,"address":[13627683,13627843,13627536,13627797,13628103,13627922],"length":1,"stats":{"Line":5}},{"line":109,"address":[13760778,13759200,13759387,13759270,13759607],"length":1,"stats":{"Line":2}},{"line":110,"address":[21321727,21321738,21321640,21321475,21321860],"length":1,"stats":{"Line":4}},{"line":112,"address":[13667600],"length":1,"stats":{"Line":1}},{"line":113,"address":[19343328,19343293],"length":1,"stats":{"Line":1}},{"line":114,"address":[13551057],"length":1,"stats":{"Line":0}},{"line":115,"address":[13632572],"length":1,"stats":{"Line":0}},{"line":120,"address":[13621428],"length":1,"stats":{"Line":0}},{"line":122,"address":[11569743],"length":1,"stats":{"Line":3}},{"line":124,"address":[13629679,13629815],"length":1,"stats":{"Line":2}},{"line":127,"address":[13632633,13632624],"length":1,"stats":{"Line":2}},{"line":129,"address":[13761616,13761522,13761533,13761907,13762071,13761493],"length":1,"stats":{"Line":6}},{"line":130,"address":[13666717,13666742],"length":1,"stats":{"Line":2}},{"line":131,"address":[11668710],"length":1,"stats":{"Line":4}},{"line":133,"address":[13562933,13659231,13659097,13563434,13562832],"length":1,"stats":{"Line":0}},{"line":140,"address":[19340811,19343181],"length":1,"stats":{"Line":2}},{"line":143,"address":[13557920],"length":1,"stats":{"Line":1}},{"line":147,"address":[13551433,13551315,13551528,13551999],"length":1,"stats":{"Line":2}},{"line":148,"address":[13626378,13626189,13626087,13626535],"length":1,"stats":{"Line":2}},{"line":150,"address":[13559440],"length":1,"stats":{"Line":1}},{"line":151,"address":[13669360,13669325],"length":1,"stats":{"Line":1}},{"line":152,"address":[13765837],"length":1,"stats":{"Line":0}},{"line":153,"address":[13669373],"length":1,"stats":{"Line":0}},{"line":154,"address":[13669378],"length":1,"stats":{"Line":0}},{"line":160,"address":[21326693,21326814,21327009,21327621,21326349,21327372],"length":1,"stats":{"Line":3}},{"line":162,"address":[13665239,13665068],"length":1,"stats":{"Line":2}},{"line":168,"address":[13552800],"length":1,"stats":{"Line":1}},{"line":172,"address":[13559930,13562383,13560182,13560046],"length":1,"stats":{"Line":2}},{"line":175,"address":[13560108,13560367,13560413,13560286,13560479,13560694,13562356],"length":1,"stats":{"Line":5}},{"line":177,"address":[13666492,13666813,13667123,13666686,13666884,13666767],"length":1,"stats":{"Line":5}},{"line":179,"address":[13672561],"length":1,"stats":{"Line":1}},{"line":180,"address":[13667024],"length":1,"stats":{"Line":1}},{"line":181,"address":[13635855,13636503,13636020],"length":1,"stats":{"Line":2}},{"line":193,"address":[13671263],"length":1,"stats":{"Line":1}},{"line":194,"address":[13767714],"length":1,"stats":{"Line":1}},{"line":195,"address":[21329660],"length":1,"stats":{"Line":1}},{"line":198,"address":[13637176,13634724,13637977,13636431,13636585,13637452],"length":1,"stats":{"Line":3}},{"line":199,"address":[13668721,13668629],"length":1,"stats":{"Line":2}},{"line":202,"address":[13770416],"length":1,"stats":{"Line":0}},{"line":206,"address":[13674315,13674437,13677054,13674528],"length":1,"stats":{"Line":0}},{"line":209,"address":[13676290,13676465,13676147],"length":1,"stats":{"Line":0}},{"line":210,"address":[13571905,13572307,13572084,13574063],"length":1,"stats":{"Line":0}},{"line":211,"address":[13565287],"length":1,"stats":{"Line":0}},{"line":212,"address":[21333763,21333626],"length":1,"stats":{"Line":0}},{"line":213,"address":[13640152],"length":1,"stats":{"Line":0}},{"line":215,"address":[13676978,13677430,13677608],"length":1,"stats":{"Line":0}},{"line":218,"address":[13677483,13676209,13677816,13676130,13674376,13677114],"length":1,"stats":{"Line":0}},{"line":219,"address":[13673676,13673517],"length":1,"stats":{"Line":0}},{"line":222,"address":[19353302,19354214,19354134,19353072,19353080,19353155,19355017,19353120],"length":1,"stats":{"Line":0}},{"line":223,"address":[13642946,13643052],"length":1,"stats":{"Line":0}},{"line":224,"address":[13643842],"length":1,"stats":{"Line":0}},{"line":225,"address":[21336579],"length":1,"stats":{"Line":0}},{"line":226,"address":[13643131],"length":1,"stats":{"Line":0}},{"line":230,"address":[19353878,19354103,19353609,19353532,19353394,19353667,19353710],"length":1,"stats":{"Line":0}},{"line":231,"address":[13576051,13575559,13575405,13575448,13575754],"length":1,"stats":{"Line":0}},{"line":232,"address":[11666881],"length":1,"stats":{"Line":0}},{"line":234,"address":[13775760,13775852],"length":1,"stats":{"Line":0}},{"line":237,"address":[13563312],"length":1,"stats":{"Line":0}},{"line":241,"address":[13681818,13681924],"length":1,"stats":{"Line":0}},{"line":242,"address":[13677141],"length":1,"stats":{"Line":0}},{"line":243,"address":[13563707],"length":1,"stats":{"Line":0}},{"line":244,"address":[13776787],"length":1,"stats":{"Line":0}},{"line":248,"address":[13638234,13638503,13638985,13638376,13638566,13638457,13638741],"length":1,"stats":{"Line":0}},{"line":249,"address":[13776821,13776864,13777173,13776975,13777478],"length":1,"stats":{"Line":0}},{"line":250,"address":[11602142],"length":1,"stats":{"Line":0}},{"line":252,"address":[13683159,13683352,13683642,13683721],"length":1,"stats":{"Line":0}},{"line":253,"address":[13778686,13778672],"length":1,"stats":{"Line":0}},{"line":255,"address":[13678450,13678432,13678010],"length":1,"stats":{"Line":0}},{"line":257,"address":[13778294],"length":1,"stats":{"Line":0}},{"line":260,"address":[13684314,13684964,13684184,13684227,13684192,13684176,13684501,13684351],"length":1,"stats":{"Line":0}},{"line":261,"address":[11690564],"length":1,"stats":{"Line":0}},{"line":262,"address":[13573392,13573286],"length":1,"stats":{"Line":0}},{"line":264,"address":[13573472,13573486],"length":1,"stats":{"Line":0}},{"line":267,"address":[21341760],"length":1,"stats":{"Line":0}},{"line":271,"address":[13576488,13573928,13574047,13574138],"length":1,"stats":{"Line":0}},{"line":274,"address":[13567325,13567468,13567643],"length":1,"stats":{"Line":0}},{"line":275,"address":[13642382,13642560,13642203],"length":1,"stats":{"Line":0}},{"line":276,"address":[13567933,13568115],"length":1,"stats":{"Line":0}},{"line":277,"address":[13575058,13575201,13574926],"length":1,"stats":{"Line":0}},{"line":278,"address":[13781470],"length":1,"stats":{"Line":0}},{"line":281,"address":[13687053,13685490,13689012,13688052,13686974,13688342],"length":1,"stats":{"Line":0}},{"line":282,"address":[13583807,13583899],"length":1,"stats":{"Line":0}},{"line":286,"address":[13683840,13684012,13683986],"length":1,"stats":{"Line":0}},{"line":287,"address":[13645752,13645835],"length":1,"stats":{"Line":0}},{"line":288,"address":[13784344,13784364,13784256],"length":1,"stats":{"Line":0}},{"line":291,"address":[19363015,19363037,19362848],"length":1,"stats":{"Line":1}},{"line":292,"address":[13687995,13688105],"length":1,"stats":{"Line":2}},{"line":293,"address":[13653037,13652923,13653014],"length":1,"stats":{"Line":2}},{"line":296,"address":[13578336,13578515,13578541],"length":1,"stats":{"Line":0}},{"line":297,"address":[13578363,13578473],"length":1,"stats":{"Line":0}},{"line":298,"address":[13784699,13784790,13784813],"length":1,"stats":{"Line":0}},{"line":301,"address":[13578765,13578560,13578739],"length":1,"stats":{"Line":0}},{"line":302,"address":[13578587,13578697],"length":1,"stats":{"Line":0}},{"line":303,"address":[13578726,13578749,13578635],"length":1,"stats":{"Line":0}},{"line":306,"address":[13578784,13578930,13578956],"length":1,"stats":{"Line":0}},{"line":307,"address":[21347000,21347083],"length":1,"stats":{"Line":0}},{"line":308,"address":[13684860,13684752,13684840],"length":1,"stats":{"Line":0}},{"line":311,"address":[13654207,13653712],"length":1,"stats":{"Line":0}},{"line":312,"address":[21347190],"length":1,"stats":{"Line":0}},{"line":313,"address":[13653843],"length":1,"stats":{"Line":0}},{"line":314,"address":[13689383,13688985,13689360,13689066],"length":1,"stats":{"Line":0}},{"line":316,"address":[13653995,13654131],"length":1,"stats":{"Line":0}},{"line":317,"address":[13647118],"length":1,"stats":{"Line":0}},{"line":318,"address":[13690929,13690953,13690822],"length":1,"stats":{"Line":0}},{"line":320,"address":[13688897],"length":1,"stats":{"Line":0}},{"line":325,"address":[19364304],"length":1,"stats":{"Line":1}},{"line":331,"address":[19365306,19369481,19365002,19365126,19364793,19365060,19364688],"length":1,"stats":{"Line":5}},{"line":332,"address":[13691622,13692138,13691912,13696543,13691792],"length":1,"stats":{"Line":2}},{"line":333,"address":[13573819,13573970,13574084,13574405,13574130,13574214],"length":1,"stats":{"Line":5}},{"line":334,"address":[21348981,21349333,21349098,21348911,21353153],"length":1,"stats":{"Line":2}},{"line":338,"address":[13655843,13656015],"length":1,"stats":{"Line":2}},{"line":340,"address":[13585568,13585577],"length":1,"stats":{"Line":2}},{"line":341,"address":[13578838,13578816],"length":1,"stats":{"Line":2}},{"line":342,"address":[19370112,19370126],"length":1,"stats":{"Line":2}},{"line":344,"address":[19366708,19366039,19367509,19367582,19367193,19369269,19367063,19367266,19365972,19366828],"length":1,"stats":{"Line":5}},{"line":347,"address":[13858848,13858857,13788384,13788464],"length":1,"stats":{"Line":4}},{"line":348,"address":[13657278,13657195,13727328,13657417,13727337],"length":1,"stats":{"Line":5}},{"line":349,"address":[13688913,13688833],"length":1,"stats":{"Line":2}},{"line":352,"address":[13789516,13789608],"length":1,"stats":{"Line":2}},{"line":354,"address":[13697221,13697216],"length":1,"stats":{"Line":2}},{"line":355,"address":[19370208,19370217],"length":1,"stats":{"Line":2}},{"line":356,"address":[13789724,13789810],"length":1,"stats":{"Line":2}},{"line":358,"address":[13578992,13578997],"length":1,"stats":{"Line":2}},{"line":359,"address":[13653616,13653625],"length":1,"stats":{"Line":2}},{"line":360,"address":[13653670,13651427,13653648],"length":1,"stats":{"Line":3}},{"line":361,"address":[13693487,13693579],"length":1,"stats":{"Line":2}},{"line":363,"address":[13579109,13579104],"length":1,"stats":{"Line":2}},{"line":364,"address":[21354112,21354117],"length":1,"stats":{"Line":2}},{"line":365,"address":[13653760,13653769],"length":1,"stats":{"Line":2}},{"line":370,"address":[13689850],"length":1,"stats":{"Line":1}},{"line":371,"address":[13577290,13577222],"length":1,"stats":{"Line":2}},{"line":372,"address":[13690112],"length":1,"stats":{"Line":1}},{"line":378,"address":[13786393,13790754,13791381,13790820],"length":1,"stats":{"Line":3}},{"line":382,"address":[13697488,13698915,13699104],"length":1,"stats":{"Line":0}},{"line":383,"address":[13692926],"length":1,"stats":{"Line":0}},{"line":384,"address":[13586014],"length":1,"stats":{"Line":0}},{"line":385,"address":[13593016],"length":1,"stats":{"Line":0}},{"line":386,"address":[13695934,13696013],"length":1,"stats":{"Line":0}},{"line":387,"address":[13692101,13692167],"length":1,"stats":{"Line":0}},{"line":388,"address":[13792559,13792628,13792871],"length":1,"stats":{"Line":0}},{"line":389,"address":[13699138,13698039,13699120],"length":1,"stats":{"Line":0}},{"line":390,"address":[13792795],"length":1,"stats":{"Line":0}},{"line":391,"address":[21354853,21354919],"length":1,"stats":{"Line":0}},{"line":392,"address":[13698255],"length":1,"stats":{"Line":0}},{"line":393,"address":[13586798],"length":1,"stats":{"Line":0}},{"line":394,"address":[13697632,13697633,13696726],"length":1,"stats":{"Line":0}},{"line":395,"address":[21355143],"length":1,"stats":{"Line":0}},{"line":399,"address":[13795485,13794080,13795400],"length":1,"stats":{"Line":1}},{"line":400,"address":[21357009],"length":1,"stats":{"Line":1}},{"line":401,"address":[13655638],"length":1,"stats":{"Line":1}},{"line":402,"address":[19372265],"length":1,"stats":{"Line":1}},{"line":403,"address":[13655695,13655780],"length":1,"stats":{"Line":2}},{"line":404,"address":[13587996,13588066,13588234],"length":1,"stats":{"Line":2}},{"line":405,"address":[13655994,13657118,13657104],"length":1,"stats":{"Line":0}},{"line":406,"address":[13794448,13794603,13794770],"length":1,"stats":{"Line":2}},{"line":407,"address":[13589406,13588434,13589392],"length":1,"stats":{"Line":0}},{"line":408,"address":[13595385],"length":1,"stats":{"Line":1}},{"line":409,"address":[19372940],"length":1,"stats":{"Line":1}},{"line":410,"address":[19372965,19373856,19373857],"length":1,"stats":{"Line":1}},{"line":411,"address":[19373043],"length":1,"stats":{"Line":1}},{"line":412,"address":[13663431,13663506],"length":1,"stats":{"Line":2}},{"line":416,"address":[13665194,13664240,13665223],"length":1,"stats":{"Line":1}},{"line":417,"address":[13589794,13589526],"length":1,"stats":{"Line":1}},{"line":420,"address":[13696416,13697359],"length":1,"stats":{"Line":1}},{"line":421,"address":[13700391,13701030],"length":1,"stats":{"Line":2}},{"line":422,"address":[13597527],"length":1,"stats":{"Line":1}},{"line":423,"address":[19375856,19375036,19374952,19375220],"length":1,"stats":{"Line":2}},{"line":424,"address":[13666302],"length":1,"stats":{"Line":0}},{"line":426,"address":[13696717,13697568,13697569],"length":1,"stats":{"Line":3}},{"line":427,"address":[13597977],"length":1,"stats":{"Line":1}},{"line":428,"address":[19375323],"length":1,"stats":{"Line":1}},{"line":429,"address":[13598019],"length":1,"stats":{"Line":1}},{"line":430,"address":[13696980],"length":1,"stats":{"Line":1}},{"line":431,"address":[13665902],"length":1,"stats":{"Line":1}},{"line":436,"address":[21358423],"length":1,"stats":{"Line":1}},{"line":437,"address":[21358638,21358063,21358237,21357933],"length":1,"stats":{"Line":2}},{"line":440,"address":[13666400,13666414,13664733],"length":1,"stats":{"Line":0}},{"line":441,"address":[13583608,13583300,13583183,13583647],"length":1,"stats":{"Line":2}},{"line":444,"address":[13696264,13697694,13697680],"length":1,"stats":{"Line":0}},{"line":445,"address":[21358376],"length":1,"stats":{"Line":1}},{"line":449,"address":[21360048],"length":1,"stats":{"Line":0}},{"line":451,"address":[13701821,13701762],"length":1,"stats":{"Line":0}},{"line":452,"address":[13703441,13703525],"length":1,"stats":{"Line":0}},{"line":453,"address":[19376381,19376297],"length":1,"stats":{"Line":0}},{"line":454,"address":[13798337,13798418],"length":1,"stats":{"Line":0}},{"line":455,"address":[19376476,19376406],"length":1,"stats":{"Line":0}},{"line":456,"address":[21360352],"length":1,"stats":{"Line":0}}],"covered":97,"coverable":224},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","p2p_handler.rs"],"content":"use crate::application::services::p2p_service::P2PServiceTrait;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::p2p::{\n    BroadcastRequest, GossipMetricsSummaryResponse, JoinTopicRequest, LeaveTopicRequest,\n    NodeAddressResponse, P2PStatusResponse, TopicStatus,\n};\nuse crate::shared::{AppError, config::BootstrapSource};\nuse std::sync::Arc;\n\npub struct P2PHandler {\n    p2p_service: Arc<dyn P2PServiceTrait>,\n}\n\nimpl P2PHandler {\n    pub fn new(p2p_service: Arc<dyn P2PServiceTrait>) -> Self {\n        Self { p2p_service }\n    }\n\n    /// P2Pネットワークを初期化\n    pub async fn initialize_p2p(&self) -> Result<(), AppError> {\n        self.p2p_service.initialize().await\n    }\n\n    /// P2Pトピックに参加\n    pub async fn join_topic(&self, request: JoinTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .join_topic(&request.topic_id, request.initial_peers)\n            .await\n    }\n\n    /// P2Pトピックから離脱\n    pub async fn leave_topic(&self, request: LeaveTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service.leave_topic(&request.topic_id).await\n    }\n\n    /// トピックにメッセージをブロードキャスト\n    pub async fn broadcast_to_topic(&self, request: BroadcastRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .broadcast_message(&request.topic_id, &request.content)\n            .await\n    }\n\n    /// P2Pステータスを取得\n    pub async fn get_p2p_status(&self) -> Result<P2PStatusResponse, AppError> {\n        let status = self.p2p_service.get_status().await?;\n        let crate::application::services::p2p_service::P2PStatus {\n            connected,\n            connection_status,\n            endpoint_id,\n            active_topics,\n            peer_count,\n            peers,\n            metrics_summary,\n        } = status;\n\n        // サービスから取得したステータスをDTOに変換\n        let topic_statuses: Vec<TopicStatus> = active_topics\n            .into_iter()\n            .map(|topic| TopicStatus {\n                topic_id: topic.id,\n                peer_count: topic.peer_count,\n                message_count: topic.message_count,\n                last_activity: topic.last_activity,\n            })\n            .collect();\n\n        Ok(P2PStatusResponse {\n            connected,\n            connection_status: connection_status.into(),\n            endpoint_id,\n            active_topics: topic_statuses,\n            peer_count,\n            peers: peers.into_iter().map(Into::into).collect(),\n            metrics_summary: GossipMetricsSummaryResponse {\n                joins: metrics_summary.joins,\n                leaves: metrics_summary.leaves,\n                broadcasts_sent: metrics_summary.broadcasts_sent,\n                messages_received: metrics_summary.messages_received,\n            },\n        })\n    }\n\n    /// ノードアドレスを取得\n    pub async fn get_node_address(&self) -> Result<NodeAddressResponse, AppError> {\n        let addresses = self.p2p_service.get_node_addresses().await?;\n\n        Ok(NodeAddressResponse { addresses })\n    }\n\n    pub async fn apply_bootstrap_nodes(\n        &self,\n        nodes: Vec<String>,\n        source: BootstrapSource,\n    ) -> Result<(), AppError> {\n        self.p2p_service.apply_bootstrap_nodes(nodes, source).await\n    }\n}\n","traces":[{"line":15,"address":[20834000],"length":1,"stats":{"Line":0}},{"line":20,"address":[20838143,20838294,20837984,20837968,20837976,20838106,20838559,20838019],"length":1,"stats":{"Line":0}},{"line":21,"address":[20838326,20838085,20838133,20838197],"length":1,"stats":{"Line":0}},{"line":25,"address":[24812508,24812342,24812304,24813102,24812259,24813419,24812995,24812224],"length":1,"stats":{"Line":0}},{"line":26,"address":[20840600,20840688,20840481],"length":1,"stats":{"Line":0}},{"line":28,"address":[20839019,20839222,20839615,20839289],"length":1,"stats":{"Line":0}},{"line":29,"address":[20729273],"length":1,"stats":{"Line":0}},{"line":30,"address":[20840953,20841359,20841158,20840539,20840906],"length":1,"stats":{"Line":0}},{"line":34,"address":[20737000,20736992,20737754,20738069,20737659,20737078,20737040,20737216],"length":1,"stats":{"Line":0}},{"line":35,"address":[20723632,20723544,20723425],"length":1,"stats":{"Line":0}},{"line":37,"address":[20737371,20737481,20737786,20737243],"length":1,"stats":{"Line":0}},{"line":41,"address":[20731383,20731139,20731184,20731104,20731231,20732313,20731891,20731992],"length":1,"stats":{"Line":0}},{"line":42,"address":[20837394,20837485,20837272],"length":1,"stats":{"Line":0}},{"line":44,"address":[20843633,20843325,20843048,20843266],"length":1,"stats":{"Line":0}},{"line":45,"address":[20937942],"length":1,"stats":{"Line":0}},{"line":46,"address":[11634641],"length":1,"stats":{"Line":0}},{"line":50,"address":[24815720,24816101,24815712,24815728,24815894,24815763,24817922,24815958],"length":1,"stats":{"Line":0}},{"line":51,"address":[20938789,20938928,20939057,20938837,20939958],"length":1,"stats":{"Line":0}},{"line":53,"address":[20740392],"length":1,"stats":{"Line":0}},{"line":54,"address":[20844940],"length":1,"stats":{"Line":0}},{"line":55,"address":[20808190],"length":1,"stats":{"Line":0}},{"line":56,"address":[20808235],"length":1,"stats":{"Line":0}},{"line":57,"address":[20845043],"length":1,"stats":{"Line":0}},{"line":58,"address":[20843416],"length":1,"stats":{"Line":0}},{"line":59,"address":[20740584],"length":1,"stats":{"Line":0}},{"line":63,"address":[24817160,24817004],"length":1,"stats":{"Line":0}},{"line":65,"address":[20734864,20734913],"length":1,"stats":{"Line":0}},{"line":66,"address":[20728091],"length":1,"stats":{"Line":0}},{"line":67,"address":[20840821],"length":1,"stats":{"Line":0}},{"line":68,"address":[20846409],"length":1,"stats":{"Line":0}},{"line":69,"address":[14982429],"length":1,"stats":{"Line":0}},{"line":73,"address":[20734258],"length":1,"stats":{"Line":0}},{"line":75,"address":[20808606],"length":1,"stats":{"Line":0}},{"line":76,"address":[20801744],"length":1,"stats":{"Line":0}},{"line":77,"address":[24817304],"length":1,"stats":{"Line":0}},{"line":79,"address":[20843983,20843872],"length":1,"stats":{"Line":0}},{"line":80,"address":[20808962],"length":1,"stats":{"Line":0}},{"line":81,"address":[20844050],"length":1,"stats":{"Line":0}},{"line":82,"address":[20940490],"length":1,"stats":{"Line":0}},{"line":83,"address":[20802018],"length":1,"stats":{"Line":0}},{"line":84,"address":[20802026],"length":1,"stats":{"Line":0}},{"line":90,"address":[24818272,24818569,24818256,24818427,24818307,24818390,24819098,24818264],"length":1,"stats":{"Line":0}},{"line":91,"address":[20841752,20841109,20841237,20840997,20841631,20841045],"length":1,"stats":{"Line":0}},{"line":93,"address":[20841525],"length":1,"stats":{"Line":0}},{"line":96,"address":[20735856],"length":1,"stats":{"Line":0}},{"line":101,"address":[20846219,20845972,20846041,20845924],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","post_handler.rs"],"content":"use crate::{\n    application::services::{AuthService, PostService, TopicService},\n    domain::entities::Post,\n    presentation::dto::{\n        Validate,\n        post_dto::{\n            BookmarkPostRequest, CreatePostRequest, DeletePostRequest, FollowingFeedPageResponse,\n            GetPostsRequest, ListFollowingFeedRequest, ListTrendingPostsRequest,\n            ListTrendingPostsResponse, PostResponse, ReactToPostRequest,\n            TrendingTopicPostsResponse,\n        },\n    },\n    shared::error::AppError,\n};\nuse chrono::Utc;\nuse futures::future::join_all;\nuse std::sync::Arc;\n\npub struct PostHandler {\n    post_service: Arc<PostService>,\n    auth_service: Arc<AuthService>,\n    topic_service: Arc<TopicService>,\n}\n\nimpl PostHandler {\n    async fn map_post(post: Post) -> PostResponse {\n        let author_pubkey = post.author.pubkey.clone();\n        let npub = tokio::task::spawn_blocking({\n            let pubkey = author_pubkey.clone();\n            move || {\n                use nostr_sdk::prelude::*;\n                PublicKey::from_hex(&pubkey)\n                    .ok()\n                    .and_then(|pk| pk.to_bech32().ok())\n                    .unwrap_or(pubkey)\n            }\n        })\n        .await\n        .unwrap_or(author_pubkey.clone());\n\n        PostResponse {\n            id: post.id.to_string(),\n            content: post.content,\n            author_pubkey: author_pubkey.clone(),\n            author_npub: npub,\n            topic_id: post.topic_id,\n            scope: post.scope,\n            epoch: post.epoch,\n            is_encrypted: post.is_encrypted,\n            created_at: post.created_at.timestamp(),\n            likes: post.likes,\n            boosts: post.boosts,\n            replies: post.replies.len() as u32,\n            is_synced: post.is_synced,\n        }\n    }\n\n    async fn map_posts(posts: Vec<Post>) -> Vec<PostResponse> {\n        let futures = posts.into_iter().map(Self::map_post);\n        join_all(futures).await\n    }\n\n    pub fn new(\n        post_service: Arc<PostService>,\n        auth_service: Arc<AuthService>,\n        topic_service: Arc<TopicService>,\n    ) -> Self {\n        Self {\n            post_service,\n            auth_service,\n            topic_service,\n        }\n    }\n\n    pub async fn create_post(&self, request: CreatePostRequest) -> Result<PostResponse, AppError> {\n        // 入力検証\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        // 現在のユーザーを取得\n        let current_user =\n            self.auth_service.get_current_user().await?.ok_or_else(|| {\n                AppError::Unauthorized(\"ユーザーが認証されていません\".to_string())\n            })?;\n\n        // サービス層を呼び出し\n        let post = self\n            .post_service\n            .create_post(\n                request.content,\n                current_user,\n                request.topic_id,\n                request.scope,\n            )\n            .await?;\n\n        // DTOに変換\n        Ok(Self::map_post(post).await)\n    }\n\n    pub async fn get_posts(&self, request: GetPostsRequest) -> Result<Vec<PostResponse>, AppError> {\n        let pagination = request.pagination.unwrap_or_default();\n\n        let posts = if let Some(topic_id) = request.topic_id {\n            self.post_service\n                .get_posts_by_topic(&topic_id, pagination.limit.unwrap_or(50) as usize)\n                .await?\n        } else if let Some(author) = request.author_pubkey {\n            self.post_service\n                .get_posts_by_author(&author, pagination.limit.unwrap_or(50) as usize)\n                .await?\n        } else {\n            self.post_service\n                .get_recent_posts(pagination.limit.unwrap_or(50) as usize)\n                .await?\n        };\n\n        let results = Self::map_posts(posts).await;\n        Ok(results)\n    }\n\n    pub async fn delete_post(&self, request: DeletePostRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service.delete_post(&request.post_id).await?;\n        Ok(())\n    }\n\n    pub async fn react_to_post(&self, request: ReactToPostRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .react_to_post(&request.post_id, &request.reaction)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn bookmark_post(\n        &self,\n        request: BookmarkPostRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .bookmark_post(&request.post_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn unbookmark_post(\n        &self,\n        request: BookmarkPostRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.post_service\n            .unbookmark_post(&request.post_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    /// ユーザーのブックマーク済み投稿IDを取得\n    pub async fn get_bookmarked_post_ids(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let post_ids = self\n            .post_service\n            .get_bookmarked_post_ids(user_pubkey)\n            .await?;\n        Ok(post_ids)\n    }\n\n    pub async fn list_trending_posts(\n        &self,\n        request: ListTrendingPostsRequest,\n    ) -> Result<ListTrendingPostsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let per_topic = request.per_topic.unwrap_or(3).clamp(1, 20) as usize;\n        let mut topics = Vec::new();\n\n        for (index, topic_id) in request.topic_ids.iter().enumerate() {\n            if let Some(topic) = self.topic_service.get_topic(topic_id).await? {\n                let posts = self\n                    .post_service\n                    .get_posts_by_topic(topic_id, per_topic)\n                    .await?;\n                let responses = Self::map_posts(posts).await;\n                topics.push(TrendingTopicPostsResponse {\n                    topic_id: topic.id.clone(),\n                    topic_name: topic.name.clone(),\n                    relative_rank: (index + 1) as u32,\n                    posts: responses,\n                });\n            }\n        }\n\n        let generated_at = self\n            .topic_service\n            .latest_metrics_generated_at()\n            .await?\n            .unwrap_or_else(|| Utc::now().timestamp_millis());\n\n        Ok(ListTrendingPostsResponse {\n            generated_at,\n            topics,\n        })\n    }\n\n    pub async fn list_following_feed(\n        &self,\n        follower_pubkey: &str,\n        request: ListFollowingFeedRequest,\n    ) -> Result<FollowingFeedPageResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let limit = request.limit.unwrap_or(20).clamp(1, 100) as usize;\n        let _include_reactions = request.include_reactions.unwrap_or(false);\n        let feed = self\n            .post_service\n            .list_following_feed(follower_pubkey, request.cursor.as_deref(), limit)\n            .await?;\n        let items = Self::map_posts(feed.items).await;\n\n        Ok(FollowingFeedPageResponse {\n            items,\n            next_cursor: feed.next_cursor,\n            has_more: feed.has_more,\n            server_time: feed.server_time,\n        })\n    }\n}\n","traces":[{"line":26,"address":[16941134,16940896,16941451,16943094,16943225,16940931,16940849,16940832],"length":1,"stats":{"Line":0}},{"line":27,"address":[16946685],"length":1,"stats":{"Line":0}},{"line":28,"address":[16945313,16945525,16945761,16945256],"length":1,"stats":{"Line":0}},{"line":29,"address":[26617750],"length":1,"stats":{"Line":0}},{"line":30,"address":[16912416,16912691,16912663,16910104],"length":1,"stats":{"Line":0}},{"line":32,"address":[16905600,16905698,16905516],"length":1,"stats":{"Line":0}},{"line":34,"address":[16844944,16844958],"length":1,"stats":{"Line":0}},{"line":35,"address":[16905667],"length":1,"stats":{"Line":0}},{"line":38,"address":[16945419,16945292,16945325,16945597,16945097],"length":1,"stats":{"Line":0}},{"line":39,"address":[16903753,16903609,16905223,16903141],"length":1,"stats":{"Line":0}},{"line":42,"address":[11083481],"length":1,"stats":{"Line":0}},{"line":43,"address":[16829249],"length":1,"stats":{"Line":0}},{"line":44,"address":[16945936],"length":1,"stats":{"Line":0}},{"line":46,"address":[17042480],"length":1,"stats":{"Line":0}},{"line":47,"address":[16843215],"length":1,"stats":{"Line":0}},{"line":48,"address":[11083806],"length":1,"stats":{"Line":0}},{"line":49,"address":[16904123],"length":1,"stats":{"Line":0}},{"line":50,"address":[16942245],"length":1,"stats":{"Line":0}},{"line":51,"address":[26618812],"length":1,"stats":{"Line":0}},{"line":52,"address":[16836407],"length":1,"stats":{"Line":0}},{"line":53,"address":[16947921],"length":1,"stats":{"Line":0}},{"line":54,"address":[16946331],"length":1,"stats":{"Line":0}},{"line":58,"address":[11085619,11086216,11085584,11085555,11085712,11085919,11085752,11085552],"length":1,"stats":{"Line":0}},{"line":59,"address":[16948132,16948027],"length":1,"stats":{"Line":0}},{"line":60,"address":[26620795,26620599,26620686],"length":1,"stats":{"Line":0}},{"line":63,"address":[16838720],"length":1,"stats":{"Line":0}},{"line":75,"address":[11088411,11086429,11086307,11087253,11086352,11086272,11086739,11089463],"length":1,"stats":{"Line":0}},{"line":77,"address":[16914088,16914199,16914441,16913921],"length":1,"stats":{"Line":0}},{"line":80,"address":[11505724],"length":1,"stats":{"Line":0}},{"line":82,"address":[26624878],"length":1,"stats":{"Line":0}},{"line":86,"address":[11088631,11087858,11088323,11088253,11088898,11088557],"length":1,"stats":{"Line":0}},{"line":89,"address":[17046805],"length":1,"stats":{"Line":0}},{"line":90,"address":[16946487],"length":1,"stats":{"Line":0}},{"line":91,"address":[16952131],"length":1,"stats":{"Line":0}},{"line":92,"address":[16946600],"length":1,"stats":{"Line":0}},{"line":94,"address":[10860698],"length":1,"stats":{"Line":0}},{"line":97,"address":[11505771],"length":1,"stats":{"Line":0}},{"line":100,"address":[16839390,16838145,16835968,16836003,16836125,16836375,16836048,16837529],"length":1,"stats":{"Line":0}},{"line":101,"address":[16917845],"length":1,"stats":{"Line":0}},{"line":103,"address":[16843335],"length":1,"stats":{"Line":0}},{"line":104,"address":[16949590,16949636,16950373,16949347,16950489,16950679],"length":1,"stats":{"Line":0}},{"line":105,"address":[16850521],"length":1,"stats":{"Line":0}},{"line":106,"address":[16850665,16851687,16851477,16851321,16850725,16850165],"length":1,"stats":{"Line":0}},{"line":107,"address":[11460895],"length":1,"stats":{"Line":0}},{"line":108,"address":[16950006,16949756,16950966,16951082,16951275,16949960],"length":1,"stats":{"Line":0}},{"line":109,"address":[11091450],"length":1,"stats":{"Line":0}},{"line":110,"address":[16953975,16954950,16953066,16953915,16955163,16954794],"length":1,"stats":{"Line":0}},{"line":112,"address":[16949780,16950120,16950166,16951446,16951562,16951891,16951763],"length":1,"stats":{"Line":0}},{"line":113,"address":[16950073],"length":1,"stats":{"Line":0}},{"line":114,"address":[16954135,16955274,16954075,16955651,16953087,16955430],"length":1,"stats":{"Line":0}},{"line":117,"address":[11570695],"length":1,"stats":{"Line":0}},{"line":118,"address":[16958101],"length":1,"stats":{"Line":0}},{"line":121,"address":[16848269,16848169,16847769,16847350,16847139,16847104,16847219,16847184],"length":1,"stats":{"Line":0}},{"line":122,"address":[16840745,16840651,16840960,16840538],"length":1,"stats":{"Line":0}},{"line":124,"address":[26629658,26629838,26630274,26629453,26629577,26630101],"length":1,"stats":{"Line":0}},{"line":125,"address":[16922792],"length":1,"stats":{"Line":0}},{"line":128,"address":[16960038,16959872,16959792,16959907,16961019,16960919,16959827,16960519],"length":1,"stats":{"Line":0}},{"line":129,"address":[16958362,16958846,16958475,16958569],"length":1,"stats":{"Line":0}},{"line":131,"address":[16842108,16842154,16842466,16842597,16842726,16841913,16842365],"length":1,"stats":{"Line":0}},{"line":132,"address":[16960299],"length":1,"stats":{"Line":0}},{"line":133,"address":[16856023,16856309,16855537,16855887,16855941,16856173],"length":1,"stats":{"Line":0}},{"line":134,"address":[17055590],"length":1,"stats":{"Line":0}},{"line":137,"address":[26631472],"length":1,"stats":{"Line":0}},{"line":142,"address":[16917577,16917690,16917784,16918012],"length":1,"stats":{"Line":0}},{"line":144,"address":[16857339,16857440,16857571,16857700,16857128,16857082,16856936],"length":1,"stats":{"Line":0}},{"line":145,"address":[16924791],"length":1,"stats":{"Line":0}},{"line":146,"address":[16843477,16843763,16843341,16843627,16843040,16843395],"length":1,"stats":{"Line":0}},{"line":147,"address":[16918324],"length":1,"stats":{"Line":0}},{"line":150,"address":[16857728],"length":1,"stats":{"Line":0}},{"line":155,"address":[11098618,11098940,11098505,11098712],"length":1,"stats":{"Line":0}},{"line":157,"address":[16858555,16858916,16858344,16858152,16858787,16858656,16858298],"length":1,"stats":{"Line":0}},{"line":158,"address":[16962775],"length":1,"stats":{"Line":0}},{"line":159,"address":[16926363,16926499,16926213,16926077,16925776,16926131],"length":1,"stats":{"Line":0}},{"line":160,"address":[17058020],"length":1,"stats":{"Line":0}},{"line":164,"address":[16926704],"length":1,"stats":{"Line":0}},{"line":168,"address":[16958076,16958231,16958414,16958694,16958512,16958188,16958773],"length":1,"stats":{"Line":0}},{"line":171,"address":[26634068,26634479,26633971,26634294,26634099,26634152],"length":1,"stats":{"Line":0}},{"line":172,"address":[11100197],"length":1,"stats":{"Line":0}},{"line":175,"address":[16964368],"length":1,"stats":{"Line":0}},{"line":179,"address":[16963277,16962973,16963719,16963161],"length":1,"stats":{"Line":0}},{"line":181,"address":[16860360,16860489],"length":1,"stats":{"Line":0}},{"line":182,"address":[16846778],"length":1,"stats":{"Line":0}},{"line":184,"address":[16854913,16854836,16853585,16853688],"length":1,"stats":{"Line":0}},{"line":185,"address":[11655612],"length":1,"stats":{"Line":0}},{"line":186,"address":[16961914,16961960,16962222,16962479,16961732,16962106],"length":1,"stats":{"Line":0}},{"line":188,"address":[16855935],"length":1,"stats":{"Line":0}},{"line":189,"address":[11538994],"length":1,"stats":{"Line":0}},{"line":190,"address":[17062881,17059511,17062725,17060279],"length":1,"stats":{"Line":0}},{"line":191,"address":[17060866,17060624],"length":1,"stats":{"Line":0}},{"line":192,"address":[16964212],"length":1,"stats":{"Line":0}},{"line":193,"address":[17060708],"length":1,"stats":{"Line":0}},{"line":194,"address":[26636183,26636391],"length":1,"stats":{"Line":0}},{"line":195,"address":[16964394],"length":1,"stats":{"Line":0}},{"line":200,"address":[16857159,16857451,16854881,16854999,16856888,16857004,16855045],"length":1,"stats":{"Line":0}},{"line":203,"address":[11657332],"length":1,"stats":{"Line":0}},{"line":204,"address":[16925268,16925264],"length":1,"stats":{"Line":0}},{"line":206,"address":[16963161],"length":1,"stats":{"Line":0}},{"line":208,"address":[16968713],"length":1,"stats":{"Line":0}},{"line":212,"address":[16925296],"length":1,"stats":{"Line":0}},{"line":217,"address":[16963720,16964377,16963970,16963857],"length":1,"stats":{"Line":0}},{"line":219,"address":[11105659,11105536],"length":1,"stats":{"Line":0}},{"line":220,"address":[16969687],"length":1,"stats":{"Line":0}},{"line":221,"address":[11106152,11106282,11106620,11105867,11105919,11105749],"length":1,"stats":{"Line":0}},{"line":223,"address":[16865260],"length":1,"stats":{"Line":0}},{"line":224,"address":[16969362,16969876,16970021,16970556,16969933,16970200],"length":1,"stats":{"Line":0}},{"line":225,"address":[11538656],"length":1,"stats":{"Line":0}},{"line":227,"address":[16934399],"length":1,"stats":{"Line":0}},{"line":229,"address":[16866580],"length":1,"stats":{"Line":0}},{"line":230,"address":[16971146],"length":1,"stats":{"Line":0}},{"line":231,"address":[16927464],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":110},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","secure_storage_handler.rs"],"content":"use crate::{\n    application::ports::secure_storage::SecureAccountStore,\n    application::services::AuthService,\n    domain::entities::{AccountMetadata, AccountRegistration},\n    presentation::dto::{Validate, auth_dto::LoginResponse},\n    shared::error::AppError,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountRequest {\n    pub nsec: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl Validate for AddAccountRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.is_empty() {\n            return Err(\"nsec is required\".into());\n        }\n        if self.name.is_empty() {\n            return Err(\"name is required\".into());\n        }\n        if self.display_name.is_empty() {\n            return Err(\"display_name is required\".into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SwitchAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetCurrentAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub metadata: AccountMetadata,\n}\n\npub struct SecureStorageHandler {\n    auth_service: Arc<AuthService>,\n    secure_store: Arc<dyn SecureAccountStore>,\n}\n\nimpl SecureStorageHandler {\n    pub fn new(auth_service: Arc<AuthService>, secure_store: Arc<dyn SecureAccountStore>) -> Self {\n        Self {\n            auth_service,\n            secure_store,\n        }\n    }\n\n    pub async fn add_account(\n        &self,\n        request: AddAccountRequest,\n    ) -> Result<AddAccountResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n        let AddAccountRequest {\n            nsec,\n            name,\n            display_name,\n            picture,\n        } = request;\n\n        // nsecから公開鍵とnpubを生成\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        // セキュアストレージに保存\n        let registration = AccountRegistration {\n            npub: user.npub.clone(),\n            nsec,\n            pubkey: user.pubkey.clone(),\n            name,\n            display_name,\n            picture,\n        };\n        self.secure_store.add_account(registration).await?;\n\n        Ok(AddAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        self.secure_store.list_accounts().await\n    }\n\n    pub async fn switch_account(&self, npub: String) -> Result<SwitchAccountResponse, AppError> {\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // 秘密鍵を取得してログイン\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(SwitchAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn remove_account(&self, npub: String) -> Result<(), AppError> {\n        self.secure_store.remove_account(&npub).await\n    }\n\n    pub async fn get_current_account(&self) -> Result<Option<GetCurrentAccountResponse>, AppError> {\n        if let Some(current) = self.secure_store.current_account().await? {\n            let user = self.auth_service.login_with_nsec(&current.nsec).await?;\n\n            Ok(Some(GetCurrentAccountResponse {\n                npub: user.npub,\n                nsec: current.nsec,\n                pubkey: user.pubkey,\n                metadata: current.metadata,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn secure_login(&self, npub: String) -> Result<LoginResponse, AppError> {\n        // セキュアストレージから秘密鍵を取得\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // ログイン処理\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(LoginResponse {\n            success: true,\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n}\n","traces":[{"line":20,"address":[20811424],"length":1,"stats":{"Line":0}},{"line":21,"address":[14984238],"length":1,"stats":{"Line":0}},{"line":22,"address":[20811482],"length":1,"stats":{"Line":0}},{"line":24,"address":[20811467],"length":1,"stats":{"Line":0}},{"line":25,"address":[20943119],"length":1,"stats":{"Line":0}},{"line":27,"address":[20943104],"length":1,"stats":{"Line":0}},{"line":28,"address":[20736914],"length":1,"stats":{"Line":0}},{"line":30,"address":[17158547],"length":1,"stats":{"Line":0}},{"line":60,"address":[20804800],"length":1,"stats":{"Line":0}},{"line":67,"address":[20943312],"length":1,"stats":{"Line":0}},{"line":71,"address":[20943793,20943936,20944314,20944619],"length":1,"stats":{"Line":0}},{"line":73,"address":[20847587],"length":1,"stats":{"Line":0}},{"line":74,"address":[20812530],"length":1,"stats":{"Line":0}},{"line":75,"address":[20805668],"length":1,"stats":{"Line":0}},{"line":76,"address":[20843846],"length":1,"stats":{"Line":0}},{"line":80,"address":[20844079,20843486,20843912,20845654,20844713,20844311],"length":1,"stats":{"Line":0}},{"line":84,"address":[17160356],"length":1,"stats":{"Line":0}},{"line":86,"address":[20732213],"length":1,"stats":{"Line":0}},{"line":91,"address":[20849297,20849382,20847443,20849618],"length":1,"stats":{"Line":0}},{"line":93,"address":[20740300],"length":1,"stats":{"Line":0}},{"line":94,"address":[17161780],"length":1,"stats":{"Line":0}},{"line":95,"address":[20946550],"length":1,"stats":{"Line":0}},{"line":99,"address":[20852394,20852659,20852206,20852080,20852243,20852115,20852064,20852072],"length":1,"stats":{"Line":0}},{"line":100,"address":[20853945,20853829,20853881,20854074],"length":1,"stats":{"Line":0}},{"line":103,"address":[20848736,20848744,20851831,20849340,20848784,20850103,20848831,20848978],"length":1,"stats":{"Line":0}},{"line":105,"address":[11680376,11680284],"length":1,"stats":{"Line":0}},{"line":108,"address":[14991572,14992561,14991937,14991454,14991631,14992328,14991817,14992096],"length":1,"stats":{"Line":0}},{"line":110,"address":[20950291],"length":1,"stats":{"Line":0}},{"line":111,"address":[20854201,20854384,20853983,20853936,20854048,20852965],"length":1,"stats":{"Line":0}},{"line":112,"address":[11680457],"length":1,"stats":{"Line":0}},{"line":114,"address":[17166345,17167017,17166491,17164662,17166189],"length":1,"stats":{"Line":0}},{"line":116,"address":[20951754],"length":1,"stats":{"Line":0}},{"line":117,"address":[20813210],"length":1,"stats":{"Line":0}},{"line":118,"address":[20820170],"length":1,"stats":{"Line":0}},{"line":122,"address":[20820928,20820966,20821347,20820888,20821087,20821611,20820880,20821706],"length":1,"stats":{"Line":0}},{"line":123,"address":[11007886],"length":1,"stats":{"Line":0}},{"line":126,"address":[20814800,20816204,20815086,20814808,20814832,20814879,20815258,20815022],"length":1,"stats":{"Line":0}},{"line":127,"address":[11634223],"length":1,"stats":{"Line":0}},{"line":128,"address":[20816940,20815849,20815950,20815073,20816213],"length":1,"stats":{"Line":0}},{"line":130,"address":[20748944],"length":1,"stats":{"Line":0}},{"line":131,"address":[20755739],"length":1,"stats":{"Line":0}},{"line":132,"address":[17170103],"length":1,"stats":{"Line":0}},{"line":133,"address":[20823581],"length":1,"stats":{"Line":0}},{"line":134,"address":[20742093],"length":1,"stats":{"Line":0}},{"line":137,"address":[20748296],"length":1,"stats":{"Line":0}},{"line":141,"address":[17172443,17170960,17171007,17171150,17170912,17173931,17171504,17170920],"length":1,"stats":{"Line":0}},{"line":143,"address":[20856400,20856806,20856280,20857121,20856559,20855732,20856010,20856093,20857093],"length":1,"stats":{"Line":0}},{"line":145,"address":[20824759],"length":1,"stats":{"Line":0}},{"line":146,"address":[11673980],"length":1,"stats":{"Line":0}},{"line":147,"address":[11705256],"length":1,"stats":{"Line":0}},{"line":150,"address":[11805705,11805552],"length":1,"stats":{"Line":0}},{"line":153,"address":[11592503],"length":1,"stats":{"Line":0}},{"line":155,"address":[20827022],"length":1,"stats":{"Line":0}},{"line":157,"address":[20858142],"length":1,"stats":{"Line":0}},{"line":158,"address":[20752254],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","topic_handler.rs"],"content":"use crate::{\n    application::services::TopicService,\n    domain::entities::{PendingTopic, TopicVisibility},\n    presentation::dto::{\n        Validate,\n        topic_dto::{\n            CreateTopicRequest, DeleteTopicRequest, EnqueueTopicCreationRequest,\n            EnqueueTopicCreationResponse, GetTopicStatsRequest, JoinTopicRequest,\n            ListTrendingTopicsRequest, ListTrendingTopicsResponse, MarkPendingTopicFailedRequest,\n            MarkPendingTopicSyncedRequest, PendingTopicResponse, TopicResponse, TopicStatsResponse,\n            TrendingTopicDto, UpdateTopicRequest,\n        },\n    },\n    presentation::handlers::offline_handler::map_action_record,\n    shared::error::AppError,\n};\nuse chrono::Utc;\nuse std::sync::Arc;\n\npub struct TopicHandler {\n    topic_service: Arc<TopicService>,\n}\n\nimpl TopicHandler {\n    pub fn new(topic_service: Arc<TopicService>) -> Self {\n        Self { topic_service }\n    }\n\n    pub async fn create_topic(\n        &self,\n        request: CreateTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let visibility = match request.visibility.as_deref() {\n            Some(\"private\") => TopicVisibility::Private,\n            _ => TopicVisibility::Public,\n        };\n        let topic = self\n            .topic_service\n            .create_topic(\n                request.name,\n                Some(request.description),\n                visibility,\n                user_pubkey,\n            )\n            .await?;\n\n        Ok(TopicResponse {\n            id: topic.id.to_string(),\n            name: topic.name,\n            description: topic.description.unwrap_or_default(),\n            image_url: topic.image_url,\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            visibility: topic.visibility.as_str().to_string(),\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn enqueue_topic_creation(\n        &self,\n        request: EnqueueTopicCreationRequest,\n        user_pubkey: &str,\n    ) -> Result<EnqueueTopicCreationResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let visibility = match request.visibility.as_deref() {\n            Some(\"private\") => TopicVisibility::Private,\n            _ => TopicVisibility::Public,\n        };\n        let result = self\n            .topic_service\n            .enqueue_topic_creation(user_pubkey, request.name, request.description, visibility)\n            .await?;\n\n        Ok(EnqueueTopicCreationResponse {\n            pending_topic: map_pending_topic(result.pending_topic),\n            offline_action: map_action_record(&result.offline_action)?,\n        })\n    }\n\n    pub async fn list_pending_topics(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<PendingTopicResponse>, AppError> {\n        let topics = self.topic_service.list_pending_topics(user_pubkey).await?;\n        Ok(topics.into_iter().map(map_pending_topic).collect())\n    }\n\n    pub async fn mark_pending_topic_synced(\n        &self,\n        request: MarkPendingTopicSyncedRequest,\n        user_pubkey: &str,\n    ) -> Result<PendingTopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let pending = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        if pending.user_pubkey != user_pubkey {\n            return Err(AppError::Unauthorized(\n                \"You cannot modify this pending topic\".to_string(),\n            ));\n        }\n\n        self.topic_service\n            .mark_pending_topic_synced(&request.pending_id, &request.topic_id)\n            .await?;\n\n        let updated = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        Ok(map_pending_topic(updated))\n    }\n\n    pub async fn mark_pending_topic_failed(\n        &self,\n        request: MarkPendingTopicFailedRequest,\n        user_pubkey: &str,\n    ) -> Result<PendingTopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let pending = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        if pending.user_pubkey != user_pubkey {\n            return Err(AppError::Unauthorized(\n                \"You cannot modify this pending topic\".to_string(),\n            ));\n        }\n\n        self.topic_service\n            .mark_pending_topic_failed(&request.pending_id, request.error_message.clone())\n            .await?;\n\n        let updated = self\n            .topic_service\n            .get_pending_topic(&request.pending_id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Pending topic not found\".to_string()))?;\n\n        Ok(map_pending_topic(updated))\n    }\n\n    pub async fn update_topic(\n        &self,\n        request: UpdateTopicRequest,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let mut topic = self\n            .topic_service\n            .get_topic(&request.id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Topic not found\".to_string()))?;\n\n        if let Some(name) = request.name {\n            topic.name = name;\n        }\n        if let Some(description) = request.description {\n            topic.description = Some(description);\n        }\n        if let Some(image_url) = request.image_url {\n            topic.image_url = if image_url.is_empty() {\n                None\n            } else {\n                Some(image_url)\n            };\n        }\n        topic.updated_at = Utc::now();\n\n        self.topic_service.update_topic(&topic).await?;\n\n        Ok(TopicResponse {\n            id: topic.id.clone(),\n            name: topic.name.clone(),\n            description: topic.description.clone().unwrap_or_default(),\n            image_url: topic.image_url.clone(),\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            visibility: topic.visibility.as_str().to_string(),\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn delete_topic(&self, request: DeleteTopicRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service.delete_topic(&request.id).await?;\n        Ok(())\n    }\n\n    pub async fn get_all_topics(\n        &self,\n        user_pubkey: Option<&str>,\n    ) -> Result<Vec<TopicResponse>, AppError> {\n        let topics = self\n            .topic_service\n            .list_topics_with_membership(user_pubkey)\n            .await?;\n\n        Ok(topics\n            .into_iter()\n            .map(|t| TopicResponse {\n                id: t.id.to_string(),\n                name: t.name,\n                description: t.description.unwrap_or_default(),\n                image_url: t.image_url,\n                member_count: t.member_count,\n                post_count: t.post_count,\n                is_joined: t.is_joined,\n                visibility: t.visibility.as_str().to_string(),\n                created_at: t.created_at.timestamp(),\n                updated_at: t.updated_at.timestamp(),\n            })\n            .collect())\n    }\n\n    pub async fn join_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .join_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .leave_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn get_topic_stats(\n        &self,\n        request: GetTopicStatsRequest,\n    ) -> Result<TopicStatsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let (member_count, post_count) = self\n            .topic_service\n            .get_topic_stats(&request.topic_id)\n            .await?;\n\n        let active_users_24h = member_count.min(post_count);\n        let trending_score = if member_count == 0 && post_count == 0 {\n            0.0\n        } else {\n            (post_count as f64 * 0.6) + (member_count as f64 * 0.4)\n        };\n\n        Ok(TopicStatsResponse {\n            topic_id: request.topic_id,\n            member_count,\n            post_count,\n            active_users_24h,\n            trending_score,\n        })\n    }\n\n    pub async fn list_trending_topics(\n        &self,\n        request: ListTrendingTopicsRequest,\n    ) -> Result<ListTrendingTopicsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let limit = request.limit.unwrap_or(10).clamp(1, 100) as usize;\n        let result = self.topic_service.list_trending_topics(limit).await?;\n\n        let topics: Vec<TrendingTopicDto> = result\n            .entries\n            .into_iter()\n            .enumerate()\n            .map(|(index, entry)| TrendingTopicDto {\n                topic_id: entry.topic.id.clone(),\n                name: entry.topic.name.clone(),\n                description: entry.topic.description.clone(),\n                member_count: entry.topic.member_count,\n                post_count: entry.topic.post_count,\n                trending_score: entry.trending_score,\n                rank: (index as u32) + 1,\n                score_change: None,\n            })\n            .collect();\n\n        Ok(ListTrendingTopicsResponse {\n            generated_at: result.generated_at,\n            topics,\n        })\n    }\n}\n\nfn map_pending_topic(topic: PendingTopic) -> PendingTopicResponse {\n    PendingTopicResponse {\n        pending_id: topic.pending_id,\n        name: topic.name,\n        description: topic.description,\n        status: topic.status.as_str().to_string(),\n        offline_action_id: topic.offline_action_id,\n        synced_topic_id: topic.synced_topic_id,\n        error_message: topic.error_message,\n        created_at: topic.created_at.timestamp(),\n        updated_at: topic.updated_at.timestamp(),\n    }\n}\n","traces":[{"line":25,"address":[23052528],"length":1,"stats":{"Line":0}},{"line":29,"address":[23045760],"length":1,"stats":{"Line":0}},{"line":34,"address":[23259416,23260114,23259294,23259531],"length":1,"stats":{"Line":0}},{"line":36,"address":[23164711,23164842],"length":1,"stats":{"Line":0}},{"line":37,"address":[17300903,17300956],"length":1,"stats":{"Line":0}},{"line":38,"address":[17300942],"length":1,"stats":{"Line":0}},{"line":40,"address":[23128768,23128498,23129084,23128848,23128417,23128194],"length":1,"stats":{"Line":0}},{"line":43,"address":[23053546],"length":1,"stats":{"Line":0}},{"line":44,"address":[17301116],"length":1,"stats":{"Line":0}},{"line":48,"address":[23046951,23046283,23047516,23047250,23047102,23047011],"length":1,"stats":{"Line":0}},{"line":50,"address":[23122674],"length":1,"stats":{"Line":0}},{"line":51,"address":[23061254],"length":1,"stats":{"Line":0}},{"line":52,"address":[23260717],"length":1,"stats":{"Line":0}},{"line":53,"address":[23260757],"length":1,"stats":{"Line":0}},{"line":54,"address":[23122388],"length":1,"stats":{"Line":0}},{"line":55,"address":[23054620],"length":1,"stats":{"Line":0}},{"line":56,"address":[23054631],"length":1,"stats":{"Line":0}},{"line":57,"address":[23260930],"length":1,"stats":{"Line":0}},{"line":58,"address":[23047952,23047869],"length":1,"stats":{"Line":0}},{"line":59,"address":[23261043],"length":1,"stats":{"Line":0}},{"line":60,"address":[23164676],"length":1,"stats":{"Line":0}},{"line":64,"address":[23049376],"length":1,"stats":{"Line":0}},{"line":69,"address":[23049817,23050577,23050054,23049939],"length":1,"stats":{"Line":0}},{"line":71,"address":[23166658,23166789],"length":1,"stats":{"Line":0}},{"line":72,"address":[23168482,23168535],"length":1,"stats":{"Line":0}},{"line":73,"address":[23063993],"length":1,"stats":{"Line":0}},{"line":75,"address":[23132294,23133397,23132033,23131786,23131955,23132368,23132616],"length":1,"stats":{"Line":0}},{"line":77,"address":[23124930],"length":1,"stats":{"Line":0}},{"line":78,"address":[10946592],"length":1,"stats":{"Line":0}},{"line":80,"address":[14401441],"length":1,"stats":{"Line":0}},{"line":81,"address":[23057772],"length":1,"stats":{"Line":0}},{"line":82,"address":[23163946,23163878,23164150],"length":1,"stats":{"Line":0}},{"line":86,"address":[23164928],"length":1,"stats":{"Line":0}},{"line":90,"address":[14402484,14402721,14403071,14402611,14402523],"length":1,"stats":{"Line":0}},{"line":91,"address":[23052982,23053166],"length":1,"stats":{"Line":0}},{"line":94,"address":[23060160],"length":1,"stats":{"Line":0}},{"line":99,"address":[23166571,23166938,23166404,23166681],"length":1,"stats":{"Line":0}},{"line":101,"address":[23267193,23267018,23267770,23267595,23267239,23268055,23267515,23268585],"length":1,"stats":{"Line":0}},{"line":103,"address":[23067822],"length":1,"stats":{"Line":0}},{"line":104,"address":[11689820],"length":1,"stats":{"Line":0}},{"line":105,"address":[23061719,23063920,23063934],"length":1,"stats":{"Line":0}},{"line":107,"address":[23129670,23129488],"length":1,"stats":{"Line":0}},{"line":108,"address":[23172020],"length":1,"stats":{"Line":0}},{"line":109,"address":[23068875],"length":1,"stats":{"Line":0}},{"line":113,"address":[23055084,23055640,23055894,23055313,23056120,23055267,23055766],"length":1,"stats":{"Line":0}},{"line":114,"address":[23173437],"length":1,"stats":{"Line":0}},{"line":115,"address":[11691490],"length":1,"stats":{"Line":0}},{"line":117,"address":[14405944,14406147,14406239,14406384,14405722,14405914,14406961,14406946,14406668],"length":1,"stats":{"Line":0}},{"line":119,"address":[23172606],"length":1,"stats":{"Line":0}},{"line":120,"address":[23174377,23174760,23174317,23174413,23174561,23172094],"length":1,"stats":{"Line":0}},{"line":121,"address":[11690065,11690098],"length":1,"stats":{"Line":0}},{"line":123,"address":[14406770,14406577],"length":1,"stats":{"Line":0}},{"line":126,"address":[14407168],"length":1,"stats":{"Line":0}},{"line":131,"address":[23132411,23132521,23132778,23132244],"length":1,"stats":{"Line":0}},{"line":133,"address":[23271145,23271722,23272525,23271547,23270970,23272007,23271191,23271467],"length":1,"stats":{"Line":0}},{"line":135,"address":[23064798],"length":1,"stats":{"Line":0}},{"line":136,"address":[11654268],"length":1,"stats":{"Line":0}},{"line":137,"address":[23135678,23135664,23133479],"length":1,"stats":{"Line":0}},{"line":139,"address":[23072608,23072790],"length":1,"stats":{"Line":0}},{"line":140,"address":[23177608],"length":1,"stats":{"Line":0}},{"line":141,"address":[23059067],"length":1,"stats":{"Line":0}},{"line":145,"address":[23072796,23073013,23072959,23073340,23073466,23073594,23073820],"length":1,"stats":{"Line":0}},{"line":146,"address":[23175741],"length":1,"stats":{"Line":0}},{"line":147,"address":[23073546,23073388,23071497,23073232,23072986,23073046],"length":1,"stats":{"Line":0}},{"line":149,"address":[23074220,23073756,23073518,23073971,23073710,23074516,23074810,23074051,23074825],"length":1,"stats":{"Line":0}},{"line":151,"address":[23176546],"length":1,"stats":{"Line":0}},{"line":152,"address":[11572795],"length":1,"stats":{"Line":0}},{"line":153,"address":[23060708,23061168,23061182],"length":1,"stats":{"Line":0}},{"line":155,"address":[17314965,17315166],"length":1,"stats":{"Line":0}},{"line":158,"address":[23061264],"length":1,"stats":{"Line":0}},{"line":162,"address":[23062134,23061788,23061895,23061645],"length":1,"stats":{"Line":0}},{"line":164,"address":[23143940,23144362,23143860,23143387,23144109,23143590,23145759,23143544],"length":1,"stats":{"Line":0}},{"line":166,"address":[23180268],"length":1,"stats":{"Line":0}},{"line":167,"address":[23068827,23069126,23069325,23068978,23068887,23068490],"length":1,"stats":{"Line":0}},{"line":168,"address":[11522010],"length":1,"stats":{"Line":0}},{"line":170,"address":[23179387,23179519,23179782],"length":1,"stats":{"Line":0}},{"line":171,"address":[23137524,23137604],"length":1,"stats":{"Line":0}},{"line":173,"address":[23179601,23180114,23179816],"length":1,"stats":{"Line":0}},{"line":174,"address":[23076989,23077101],"length":1,"stats":{"Line":0}},{"line":176,"address":[23181578,23182221,23181767],"length":1,"stats":{"Line":0}},{"line":177,"address":[23063736,23063862,23063548,23063626,23063756],"length":1,"stats":{"Line":0}},{"line":178,"address":[23276810],"length":1,"stats":{"Line":0}},{"line":180,"address":[23176336],"length":1,"stats":{"Line":0}},{"line":183,"address":[23138151,23138637],"length":1,"stats":{"Line":0}},{"line":185,"address":[11589766],"length":1,"stats":{"Line":0}},{"line":187,"address":[23078933],"length":1,"stats":{"Line":0}},{"line":188,"address":[17318839],"length":1,"stats":{"Line":0}},{"line":189,"address":[23182942],"length":1,"stats":{"Line":0}},{"line":190,"address":[23177511,23177436],"length":1,"stats":{"Line":0}},{"line":191,"address":[23064834],"length":1,"stats":{"Line":0}},{"line":192,"address":[23078669],"length":1,"stats":{"Line":0}},{"line":193,"address":[23071711],"length":1,"stats":{"Line":0}},{"line":194,"address":[17319241],"length":1,"stats":{"Line":0}},{"line":195,"address":[17319251,17319333],"length":1,"stats":{"Line":0}},{"line":196,"address":[17319352],"length":1,"stats":{"Line":0}},{"line":197,"address":[14414676],"length":1,"stats":{"Line":0}},{"line":201,"address":[23149553,23149953,23150053,23149134,23149011,23148976,23148928,23148936],"length":1,"stats":{"Line":0}},{"line":202,"address":[23180290,23180403,23180712,23180497],"length":1,"stats":{"Line":0}},{"line":204,"address":[17322081,17322173,17321945,17322369,17322655,17322832],"length":1,"stats":{"Line":0}},{"line":205,"address":[23184960],"length":1,"stats":{"Line":0}},{"line":208,"address":[23075328],"length":1,"stats":{"Line":0}},{"line":212,"address":[23082855,23082623,23082953,23082500,23082669,23083168],"length":1,"stats":{"Line":0}},{"line":215,"address":[11735204],"length":1,"stats":{"Line":0}},{"line":217,"address":[23076086,23076270],"length":1,"stats":{"Line":0}},{"line":219,"address":[17324000,17324566,17324787],"length":1,"stats":{"Line":0}},{"line":220,"address":[23069734],"length":1,"stats":{"Line":0}},{"line":221,"address":[23188132],"length":1,"stats":{"Line":0}},{"line":222,"address":[23151390],"length":1,"stats":{"Line":0}},{"line":223,"address":[23188260],"length":1,"stats":{"Line":0}},{"line":224,"address":[23186644],"length":1,"stats":{"Line":0}},{"line":225,"address":[23182718],"length":1,"stats":{"Line":0}},{"line":226,"address":[17324328],"length":1,"stats":{"Line":0}},{"line":227,"address":[23070034,23070116],"length":1,"stats":{"Line":0}},{"line":228,"address":[23283212],"length":1,"stats":{"Line":0}},{"line":229,"address":[23186846],"length":1,"stats":{"Line":0}},{"line":234,"address":[23187312],"length":1,"stats":{"Line":0}},{"line":239,"address":[23071112,23070905,23071018,23071340],"length":1,"stats":{"Line":0}},{"line":241,"address":[23071499,23071600,23071242,23071096,23071288,23071731,23071860],"length":1,"stats":{"Line":0}},{"line":242,"address":[23189479],"length":1,"stats":{"Line":0}},{"line":243,"address":[11623684],"length":1,"stats":{"Line":0}},{"line":244,"address":[23078436],"length":1,"stats":{"Line":0}},{"line":247,"address":[23188528],"length":1,"stats":{"Line":0}},{"line":252,"address":[23185032,23184825,23185260,23184938],"length":1,"stats":{"Line":0}},{"line":254,"address":[23072458,23072715,23072504,23072816,23072947,23072312,23073076],"length":1,"stats":{"Line":0}},{"line":255,"address":[23189047],"length":1,"stats":{"Line":0}},{"line":256,"address":[11515908],"length":1,"stats":{"Line":0}},{"line":257,"address":[23147460],"length":1,"stats":{"Line":0}},{"line":260,"address":[23073104],"length":1,"stats":{"Line":0}},{"line":264,"address":[17327696,17327790,17327583,17328008],"length":1,"stats":{"Line":0}},{"line":266,"address":[23192151,23191940,23191894,23191758,23192774,23192259,23192424],"length":1,"stats":{"Line":0}},{"line":268,"address":[23191853],"length":1,"stats":{"Line":0}},{"line":269,"address":[11608593],"length":1,"stats":{"Line":0}},{"line":271,"address":[23074181,23074073],"length":1,"stats":{"Line":0}},{"line":272,"address":[23074261,23074188],"length":1,"stats":{"Line":0}},{"line":273,"address":[23192551],"length":1,"stats":{"Line":0}},{"line":275,"address":[23155730],"length":1,"stats":{"Line":0}},{"line":278,"address":[14423554],"length":1,"stats":{"Line":0}},{"line":279,"address":[23190927],"length":1,"stats":{"Line":0}},{"line":283,"address":[14423545],"length":1,"stats":{"Line":0}},{"line":287,"address":[17328848],"length":1,"stats":{"Line":0}},{"line":291,"address":[23288305,23288017,23287798,23287913],"length":1,"stats":{"Line":0}},{"line":293,"address":[23287986,23288097],"length":1,"stats":{"Line":0}},{"line":294,"address":[23089075,23088895,23089492,23088541,23088834],"length":1,"stats":{"Line":0}},{"line":296,"address":[23075665,23075858],"length":1,"stats":{"Line":0}},{"line":300,"address":[17330486,17330818,17331053,17330448],"length":1,"stats":{"Line":0}},{"line":301,"address":[23157751],"length":1,"stats":{"Line":0}},{"line":302,"address":[23150883],"length":1,"stats":{"Line":0}},{"line":303,"address":[23194644],"length":1,"stats":{"Line":0}},{"line":304,"address":[23289498],"length":1,"stats":{"Line":0}},{"line":305,"address":[23151029],"length":1,"stats":{"Line":0}},{"line":306,"address":[23289520],"length":1,"stats":{"Line":0}},{"line":307,"address":[23193325,23193103],"length":1,"stats":{"Line":0}},{"line":308,"address":[23076502],"length":1,"stats":{"Line":0}},{"line":312,"address":[23089707],"length":1,"stats":{"Line":0}},{"line":313,"address":[23188643],"length":1,"stats":{"Line":0}},{"line":319,"address":[23194172,23194367,23193424],"length":1,"stats":{"Line":0}},{"line":321,"address":[23193454],"length":1,"stats":{"Line":0}},{"line":322,"address":[23151471],"length":1,"stats":{"Line":0}},{"line":323,"address":[23083681],"length":1,"stats":{"Line":0}},{"line":324,"address":[14426057,14426135],"length":1,"stats":{"Line":0}},{"line":325,"address":[23189731],"length":1,"stats":{"Line":0}},{"line":326,"address":[23193699],"length":1,"stats":{"Line":0}},{"line":327,"address":[23077094],"length":1,"stats":{"Line":0}},{"line":328,"address":[17331436],"length":1,"stats":{"Line":0}},{"line":329,"address":[23158724],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":165},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","ipc","direct_message_notifier.rs"],"content":"use crate::application::ports::direct_message_notifier::DirectMessageNotifier;\nuse crate::domain::entities::DirectMessage;\nuse crate::shared::AppError;\nuse async_trait::async_trait;\nuse serde::Serialize;\nuse tauri::{AppHandle, Emitter};\n\n#[derive(Clone)]\npub struct IpcDirectMessageNotifier {\n    app_handle: AppHandle,\n}\n\nimpl IpcDirectMessageNotifier {\n    pub fn new(app_handle: &AppHandle) -> Self {\n        Self {\n            app_handle: app_handle.clone(),\n        }\n    }\n}\n\n#[derive(Serialize, Clone)]\nstruct DirectMessagePayload {\n    event_id: Option<String>,\n    client_message_id: Option<String>,\n    sender_npub: String,\n    recipient_npub: String,\n    content: String,\n    created_at: i64,\n    delivered: bool,\n    direction: &'static str,\n    increment_amount: u32,\n}\n\n#[derive(Serialize, Clone)]\nstruct DirectMessageEventPayload {\n    owner_npub: String,\n    conversation_npub: String,\n    message: DirectMessagePayload,\n}\n\n#[async_trait]\nimpl DirectMessageNotifier for IpcDirectMessageNotifier {\n    async fn notify(&self, owner_npub: &str, message: &DirectMessage) -> Result<(), AppError> {\n        let payload = DirectMessageEventPayload {\n            owner_npub: owner_npub.to_string(),\n            conversation_npub: message.conversation_npub.clone(),\n            message: DirectMessagePayload {\n                event_id: message.event_id.clone(),\n                client_message_id: message.client_message_id.clone(),\n                sender_npub: message.sender_npub.clone(),\n                recipient_npub: message.recipient_npub.clone(),\n                content: message.decrypted_content.clone().unwrap_or_default(),\n                created_at: message.created_at_millis(),\n                delivered: message.delivered,\n                direction: message.direction.as_str(),\n                increment_amount: if message.direction\n                    == crate::domain::entities::MessageDirection::Inbound\n                {\n                    1\n                } else {\n                    0\n                },\n            },\n        };\n\n        self.app_handle\n            .emit(\"direct-message:received\", payload)\n            .map_err(|err| {\n                AppError::Internal(format!(\"Failed to emit direct message event: {err}\"))\n            })\n    }\n}\n","traces":[{"line":14,"address":[13004128],"length":1,"stats":{"Line":0}},{"line":16,"address":[12903784],"length":1,"stats":{"Line":0}},{"line":43,"address":[12917192,12917412,12917278,12917248,12917341,12917435,12918663],"length":1,"stats":{"Line":0}},{"line":45,"address":[13022068],"length":1,"stats":{"Line":0}},{"line":46,"address":[20678788],"length":1,"stats":{"Line":0}},{"line":47,"address":[13117576],"length":1,"stats":{"Line":0}},{"line":66,"address":[13117883],"length":1,"stats":{"Line":0}},{"line":68,"address":[12979552,12979778],"length":1,"stats":{"Line":0}},{"line":69,"address":[17313614,17313662],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","ipc","mod.rs"],"content":"pub mod direct_message_notifier;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","mod.rs"],"content":"pub mod commands;\npub mod dto;\npub mod handlers;\npub mod ipc;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","config.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[repr(u8)]\n#[derive(Debug, Copy, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum BootstrapSource {\n    Env,\n    User,\n    Bundle,\n    Fallback,\n    #[default]\n    None,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AppConfig {\n    pub database: DatabaseConfig,\n    pub network: NetworkConfig,\n    pub sync: SyncConfig,\n    pub storage: StorageConfig,\n    pub metrics: MetricsConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    pub url: String,\n    pub max_connections: u32,\n    pub connection_timeout: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkConfig {\n    pub bootstrap_peers: Vec<String>,\n    pub max_peers: u32,\n    pub connection_timeout: u64,\n    pub retry_interval: u64,\n    // DHT/Discovery 関連フラグ\n    pub enable_dht: bool,\n    pub enable_dns: bool,\n    pub enable_local: bool,\n    #[serde(default)]\n    pub bootstrap_source: BootstrapSource,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncConfig {\n    pub auto_sync: bool,\n    pub sync_interval: u64,\n    pub max_retry: u32,\n    pub batch_size: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StorageConfig {\n    pub data_dir: String,\n    pub cache_size: u64,\n    pub cache_ttl: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsConfig {\n    pub enabled: bool,\n    pub interval_minutes: u64,\n    pub ttl_hours: u64,\n    pub score_weights: MetricsScoreWeightsConfig,\n    #[serde(default)]\n    pub prometheus_port: Option<u16>,\n    #[serde(default)]\n    pub emit_histogram: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsScoreWeightsConfig {\n    pub posts: f64,\n    pub unique_authors: f64,\n    pub boosts: f64,\n}\n\nimpl Default for AppConfig {\n    fn default() -> Self {\n        Self {\n            database: DatabaseConfig {\n                url: \"sqlite:data/kukuri.db\".to_string(),\n                max_connections: 5,\n                connection_timeout: 30,\n            },\n            network: NetworkConfig {\n                bootstrap_peers: vec![],\n                max_peers: 50,\n                connection_timeout: 30,\n                retry_interval: 60,\n                enable_dht: true,\n                enable_dns: true,\n                enable_local: false,\n                bootstrap_source: BootstrapSource::None,\n            },\n            sync: SyncConfig {\n                auto_sync: true,\n                sync_interval: 300, // 5 minutes\n                max_retry: 3,\n                batch_size: 100,\n            },\n            storage: StorageConfig {\n                data_dir: \"./data\".to_string(),\n                cache_size: 100 * 1024 * 1024, // 100MB\n                cache_ttl: 3600,               // 1 hour\n            },\n            metrics: MetricsConfig::default(),\n        }\n    }\n}\n\nimpl Default for MetricsConfig {\n    fn default() -> Self {\n        Self {\n            enabled: true,\n            interval_minutes: 5,\n            ttl_hours: 48,\n            score_weights: MetricsScoreWeightsConfig::default(),\n            prometheus_port: None,\n            emit_histogram: false,\n        }\n    }\n}\n\nimpl Default for MetricsScoreWeightsConfig {\n    fn default() -> Self {\n        Self {\n            posts: 0.6,\n            unique_authors: 0.3,\n            boosts: 0.1,\n        }\n    }\n}\n\nimpl AppConfig {\n    pub fn from_env() -> Self {\n        // 既定値\n        let mut cfg = Self::default();\n        let mut bootstrap_source = BootstrapSource::None;\n\n        // ネットワーク設定の環境変数反映\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DHT\") {\n            cfg.network.enable_dht = parse_bool(&v, cfg.network.enable_dht);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DNS\") {\n            cfg.network.enable_dns = parse_bool(&v, cfg.network.enable_dns);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_LOCAL\") {\n            cfg.network.enable_local = parse_bool(&v, cfg.network.enable_local);\n        }\n\n        if let Ok(v) = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\") {\n            let peers: Vec<String> = v\n                .split(',')\n                .map(|s| s.trim().to_string())\n                .filter(|s| !s.is_empty())\n                .collect();\n            if !peers.is_empty() {\n                cfg.network.bootstrap_peers = peers;\n                bootstrap_source = BootstrapSource::Env;\n            }\n        }\n\n        cfg.network.bootstrap_source = bootstrap_source;\n\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_ENABLED\") {\n            cfg.metrics.enabled = parse_bool(&v, cfg.metrics.enabled);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_INTERVAL_MINUTES\") {\n            if let Some(value) = parse_u64(&v) {\n                cfg.metrics.interval_minutes = value.max(1);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_TTL_HOURS\") {\n            if let Some(value) = parse_u64(&v) {\n                cfg.metrics.ttl_hours = value.max(1);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_POSTS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.posts = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_UNIQUE_AUTHORS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.unique_authors = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_WEIGHT_BOOSTS\") {\n            if let Some(value) = parse_f64(&v) {\n                cfg.metrics.score_weights.boosts = value.max(0.0);\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_PROMETHEUS_PORT\") {\n            if let Some(value) = parse_u16(&v) {\n                cfg.metrics.prometheus_port = if value == 0 { None } else { Some(value) };\n            }\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_METRICS_EMIT_HISTOGRAM\") {\n            cfg.metrics.emit_histogram = parse_bool(&v, cfg.metrics.emit_histogram);\n        }\n\n        cfg\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if self.database.max_connections == 0 {\n            return Err(\"Database max_connections must be greater than 0\".to_string());\n        }\n        if self.network.max_peers == 0 {\n            return Err(\"Network max_peers must be greater than 0\".to_string());\n        }\n        if self.metrics.enabled {\n            if self.metrics.interval_minutes == 0 {\n                return Err(\"Metrics interval_minutes must be greater than 0\".to_string());\n            }\n            if self.metrics.ttl_hours == 0 {\n                return Err(\"Metrics ttl_hours must be greater than 0\".to_string());\n            }\n        }\n        if let Some(port) = self.metrics.prometheus_port {\n            if port == 0 {\n                return Err(\"Metrics prometheus_port must be greater than 0\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\nfn parse_bool(s: &str, default: bool) -> bool {\n    match s.to_ascii_lowercase().as_str() {\n        \"1\" | \"true\" | \"yes\" | \"on\" => true,\n        \"0\" | \"false\" | \"no\" | \"off\" => false,\n        _ => default,\n    }\n}\n\nfn parse_u64(value: &str) -> Option<u64> {\n    value.trim().parse::<u64>().ok()\n}\n\nfn parse_f64(value: &str) -> Option<f64> {\n    value.trim().parse::<f64>().ok()\n}\n\nfn parse_u16(value: &str) -> Option<u16> {\n    value.trim().parse::<u16>().ok()\n}\n","traces":[{"line":80,"address":[21529585,21528816],"length":1,"stats":{"Line":1}},{"line":82,"address":[21410571],"length":1,"stats":{"Line":1}},{"line":87,"address":[21492196],"length":1,"stats":{"Line":1}},{"line":97,"address":[21424532],"length":1,"stats":{"Line":1}},{"line":103,"address":[21492525],"length":1,"stats":{"Line":1}},{"line":108,"address":[21492577],"length":1,"stats":{"Line":1}},{"line":114,"address":[23094976],"length":1,"stats":{"Line":1}},{"line":119,"address":[21527982],"length":1,"stats":{"Line":1}},{"line":127,"address":[21529744],"length":1,"stats":{"Line":1}},{"line":137,"address":[21493024,21493468,21498104],"length":1,"stats":{"Line":0}},{"line":139,"address":[21425287],"length":1,"stats":{"Line":0}},{"line":140,"address":[21411552],"length":1,"stats":{"Line":0}},{"line":143,"address":[21524339,21524264],"length":1,"stats":{"Line":0}},{"line":144,"address":[23095326,23095428],"length":1,"stats":{"Line":0}},{"line":146,"address":[21486490,21486571],"length":1,"stats":{"Line":0}},{"line":147,"address":[21412030,21412132],"length":1,"stats":{"Line":0}},{"line":149,"address":[21525018,21524946],"length":1,"stats":{"Line":0}},{"line":150,"address":[21412365,21412467],"length":1,"stats":{"Line":0}},{"line":153,"address":[21530937,21530865],"length":1,"stats":{"Line":0}},{"line":154,"address":[15667004,15667109],"length":1,"stats":{"Line":0}},{"line":156,"address":[21533301,21533248],"length":1,"stats":{"Line":0}},{"line":157,"address":[23100336,23100361],"length":1,"stats":{"Line":0}},{"line":159,"address":[21525622,21525696,21525925],"length":1,"stats":{"Line":0}},{"line":160,"address":[21494596,21494518],"length":1,"stats":{"Line":0}},{"line":161,"address":[21487791],"length":1,"stats":{"Line":0}},{"line":165,"address":[21626394],"length":1,"stats":{"Line":0}},{"line":167,"address":[21413336,21413430],"length":1,"stats":{"Line":0}},{"line":168,"address":[21495001,21495103],"length":1,"stats":{"Line":0}},{"line":170,"address":[21530333,21530405],"length":1,"stats":{"Line":0}},{"line":171,"address":[21413921,21413816,21414062],"length":1,"stats":{"Line":0}},{"line":172,"address":[21530694,21530643],"length":1,"stats":{"Line":0}},{"line":175,"address":[21627258,21627186],"length":1,"stats":{"Line":0}},{"line":176,"address":[21428243,21428102,21427997],"length":1,"stats":{"Line":0}},{"line":177,"address":[21531115,21531064],"length":1,"stats":{"Line":0}},{"line":180,"address":[21421391,21421319],"length":1,"stats":{"Line":0}},{"line":181,"address":[21496426,21496178,21496283],"length":1,"stats":{"Line":0}},{"line":182,"address":[21533141,21533185],"length":1,"stats":{"Line":0}},{"line":185,"address":[21414958,21415030],"length":1,"stats":{"Line":0}},{"line":186,"address":[15669478,15669385,15669603],"length":1,"stats":{"Line":0}},{"line":187,"address":[21422074,21422036],"length":1,"stats":{"Line":0}},{"line":190,"address":[21628495,21628423],"length":1,"stats":{"Line":0}},{"line":191,"address":[21422258,21422476,21422351],"length":1,"stats":{"Line":0}},{"line":192,"address":[15669987,15669949],"length":1,"stats":{"Line":0}},{"line":195,"address":[21532384,21532456],"length":1,"stats":{"Line":0}},{"line":196,"address":[21422744,21422916,21422651],"length":1,"stats":{"Line":0}},{"line":197,"address":[23099693,23099666],"length":1,"stats":{"Line":0}},{"line":200,"address":[21528960,21528888],"length":1,"stats":{"Line":0}},{"line":201,"address":[21529011,21529101],"length":1,"stats":{"Line":0}},{"line":204,"address":[21498029],"length":1,"stats":{"Line":0}},{"line":207,"address":[21529456],"length":1,"stats":{"Line":0}},{"line":208,"address":[21629854],"length":1,"stats":{"Line":0}},{"line":209,"address":[21529492],"length":1,"stats":{"Line":0}},{"line":211,"address":[21498369],"length":1,"stats":{"Line":0}},{"line":212,"address":[23100502],"length":1,"stats":{"Line":0}},{"line":214,"address":[21630003],"length":1,"stats":{"Line":0}},{"line":215,"address":[23100604],"length":1,"stats":{"Line":0}},{"line":216,"address":[21498502],"length":1,"stats":{"Line":0}},{"line":218,"address":[21498566],"length":1,"stats":{"Line":0}},{"line":219,"address":[23100688],"length":1,"stats":{"Line":0}},{"line":222,"address":[23100577,23100752],"length":1,"stats":{"Line":0}},{"line":223,"address":[21533775],"length":1,"stats":{"Line":0}},{"line":224,"address":[15671468],"length":1,"stats":{"Line":0}},{"line":227,"address":[23100778],"length":1,"stats":{"Line":0}},{"line":231,"address":[21417248,21417770],"length":1,"stats":{"Line":0}},{"line":232,"address":[21417293,21417368],"length":1,"stats":{"Line":0}},{"line":233,"address":[21491976],"length":1,"stats":{"Line":0}},{"line":234,"address":[15671870],"length":1,"stats":{"Line":0}},{"line":235,"address":[21492331],"length":1,"stats":{"Line":0}},{"line":239,"address":[21530496],"length":1,"stats":{"Line":0}},{"line":240,"address":[21431566],"length":1,"stats":{"Line":0}},{"line":243,"address":[21530560],"length":1,"stats":{"Line":0}},{"line":244,"address":[21417870],"length":1,"stats":{"Line":0}},{"line":247,"address":[21499440],"length":1,"stats":{"Line":0}},{"line":248,"address":[21424718],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":74},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","error.rs"],"content":"use crate::shared::validation::ValidationFailureKind;\nuse serde::Serialize;\nuse thiserror::Error;\n\n#[derive(Debug, Error, Serialize)]\npub enum AppError {\n    #[error(\"Database error: {0}\")]\n    Database(String),\n    #[error(\"Network error: {0}\")]\n    Network(String),\n    #[error(\"Crypto error: {0}\")]\n    Crypto(String),\n    #[error(\"Storage error: {0}\")]\n    Storage(String),\n    #[error(\"Auth error: {0}\")]\n    Auth(String),\n    #[error(\"Unauthorized: {0}\")]\n    Unauthorized(String),\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n    #[error(\"Validation error ({kind}): {message}\")]\n    ValidationError {\n        kind: ValidationFailureKind,\n        message: String,\n    },\n    #[error(\"Rate limited: {message}\")]\n    RateLimited {\n        message: String,\n        retry_after_seconds: u64,\n    },\n    #[error(\"Nostr error: {0}\")]\n    NostrError(String),\n    #[error(\"P2P error: {0}\")]\n    P2PError(String),\n    #[error(\"Configuration error: {0}\")]\n    ConfigurationError(String),\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n    #[error(\"Deserialization error: {0}\")]\n    DeserializationError(String),\n    #[error(\"Not implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n}\n\nimpl AppError {\n    pub fn validation(kind: ValidationFailureKind, message: impl Into<String>) -> Self {\n        AppError::ValidationError {\n            kind,\n            message: message.into(),\n        }\n    }\n\n    pub fn validation_kind(&self) -> Option<ValidationFailureKind> {\n        match self {\n            AppError::ValidationError { kind, .. } => Some(*kind),\n            _ => None,\n        }\n    }\n\n    pub fn validation_message(&self) -> Option<&str> {\n        match self {\n            AppError::ValidationError { message, .. } => Some(message.as_str()),\n            _ => None,\n        }\n    }\n\n    pub fn validation_mapper(kind: ValidationFailureKind) -> impl FnOnce(String) -> Self {\n        move |message| AppError::validation(kind, message)\n    }\n\n    pub fn rate_limited(message: impl Into<String>, retry_after_seconds: u64) -> Self {\n        AppError::RateLimited {\n            message: message.into(),\n            retry_after_seconds,\n        }\n    }\n\n    pub fn code(&self) -> &'static str {\n        match self {\n            AppError::Database(_) => \"DATABASE_ERROR\",\n            AppError::Network(_) => \"NETWORK_ERROR\",\n            AppError::Crypto(_) => \"CRYPTO_ERROR\",\n            AppError::Storage(_) => \"STORAGE_ERROR\",\n            AppError::Auth(_) => \"AUTH_ERROR\",\n            AppError::Unauthorized(_) => \"UNAUTHORIZED\",\n            AppError::NotFound(_) => \"NOT_FOUND\",\n            AppError::InvalidInput(_) => \"INVALID_INPUT\",\n            AppError::ValidationError { .. } => \"VALIDATION_ERROR\",\n            AppError::RateLimited { .. } => \"RATE_LIMITED\",\n            AppError::NostrError(_) => \"NOSTR_ERROR\",\n            AppError::P2PError(_) => \"P2P_ERROR\",\n            AppError::ConfigurationError(_) => \"CONFIGURATION_ERROR\",\n            AppError::SerializationError(_) => \"SERIALIZATION_ERROR\",\n            AppError::DeserializationError(_) => \"DESERIALIZATION_ERROR\",\n            AppError::NotImplemented(_) => \"NOT_IMPLEMENTED\",\n            AppError::Internal(_) => \"INTERNAL_ERROR\",\n        }\n    }\n\n    pub fn user_message(&self) -> String {\n        match self {\n            AppError::Database(_) => \"Database operation failed\".to_string(),\n            AppError::Network(_) => \"Network request failed\".to_string(),\n            AppError::Crypto(_) => \"Cryptographic operation failed\".to_string(),\n            AppError::Storage(_) => \"Storage access failed\".to_string(),\n            AppError::Auth(_) => \"Authentication failed\".to_string(),\n            AppError::Unauthorized(_) => {\n                \"You are not authorized to perform this action\".to_string()\n            }\n            AppError::NotFound(_) => \"The requested resource was not found\".to_string(),\n            AppError::InvalidInput(_) => \"Input data is invalid\".to_string(),\n            AppError::ValidationError { message, .. } => {\n                format!(\"Validation failed: {message}\")\n            }\n            AppError::RateLimited { message, .. } => message.clone(),\n            AppError::NostrError(_) => \"Nostr operation failed\".to_string(),\n            AppError::P2PError(_) => \"Peer-to-peer operation failed\".to_string(),\n            AppError::ConfigurationError(_) => \"Configuration error detected\".to_string(),\n            AppError::SerializationError(_) => \"Serialization error occurred\".to_string(),\n            AppError::DeserializationError(_) => \"Deserialization error occurred\".to_string(),\n            AppError::NotImplemented(_) => \"This feature is not implemented\".to_string(),\n            AppError::Internal(_) => \"An internal error occurred\".to_string(),\n        }\n    }\n}\n\nimpl From<sqlx::Error> for AppError {\n    fn from(err: sqlx::Error) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error>> for AppError {\n    fn from(err: Box<dyn std::error::Error>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error + Send + Sync>> for AppError {\n    fn from(err: Box<dyn std::error::Error + Send + Sync>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<String> for AppError {\n    fn from(err: String) -> Self {\n        AppError::Internal(err)\n    }\n}\n\nimpl From<&str> for AppError {\n    fn from(err: &str) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::EventId> for AppError {\n    fn from(_: nostr_sdk::prelude::EventId) -> Self {\n        AppError::NostrError(\"Invalid EventId conversion\".to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::Error> for AppError {\n    fn from(err: nostr_sdk::event::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::secp256k1::Error> for AppError {\n    fn from(err: nostr_sdk::prelude::secp256k1::Error) -> Self {\n        AppError::Crypto(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::key::Error> for AppError {\n    fn from(err: nostr_sdk::key::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::builder::Error> for AppError {\n    fn from(err: nostr_sdk::event::builder::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<serde_json::Error> for AppError {\n    fn from(err: serde_json::Error) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<anyhow::Error> for AppError {\n    fn from(err: anyhow::Error) -> Self {\n        AppError::P2PError(err.to_string())\n    }\n}\n\nimpl From<sqlx::migrate::MigrateError> for AppError {\n    fn from(err: sqlx::migrate::MigrateError) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<iroh::endpoint::Builder> for AppError {\n    fn from(err: iroh::endpoint::Builder) -> Self {\n        AppError::P2PError(format!(\"Endpoint builder error: {err:?}\"))\n    }\n}\n\npub type Result<T> = std::result::Result<T, AppError>;\n","traces":[{"line":50,"address":[16714912,16714800],"length":1,"stats":{"Line":1}},{"line":53,"address":[26641394,26641527],"length":1,"stats":{"Line":1}},{"line":57,"address":[16713392],"length":1,"stats":{"Line":1}},{"line":58,"address":[16809834],"length":1,"stats":{"Line":1}},{"line":59,"address":[16603560],"length":1,"stats":{"Line":1}},{"line":60,"address":[16709501],"length":1,"stats":{"Line":1}},{"line":64,"address":[24371792],"length":1,"stats":{"Line":1}},{"line":65,"address":[16671421],"length":1,"stats":{"Line":1}},{"line":66,"address":[16709546],"length":1,"stats":{"Line":1}},{"line":67,"address":[16713508],"length":1,"stats":{"Line":0}},{"line":71,"address":[16809968],"length":1,"stats":{"Line":3}},{"line":72,"address":[16610672,16610691],"length":1,"stats":{"Line":0}},{"line":75,"address":[16671552],"length":1,"stats":{"Line":1}},{"line":77,"address":[16715281],"length":1,"stats":{"Line":1}},{"line":82,"address":[26641920],"length":1,"stats":{"Line":0}},{"line":83,"address":[24372053],"length":1,"stats":{"Line":0}},{"line":84,"address":[26641956],"length":1,"stats":{"Line":0}},{"line":85,"address":[16597134],"length":1,"stats":{"Line":0}},{"line":86,"address":[16671752],"length":1,"stats":{"Line":0}},{"line":87,"address":[16810258],"length":1,"stats":{"Line":0}},{"line":88,"address":[16709916],"length":1,"stats":{"Line":0}},{"line":89,"address":[16671830],"length":1,"stats":{"Line":0}},{"line":90,"address":[16709968],"length":1,"stats":{"Line":0}},{"line":91,"address":[16671882],"length":1,"stats":{"Line":0}},{"line":92,"address":[16710020],"length":1,"stats":{"Line":0}},{"line":93,"address":[16671934],"length":1,"stats":{"Line":0}},{"line":94,"address":[16714008],"length":1,"stats":{"Line":0}},{"line":95,"address":[16611154],"length":1,"stats":{"Line":0}},{"line":96,"address":[16597417],"length":1,"stats":{"Line":0}},{"line":97,"address":[16678960],"length":1,"stats":{"Line":0}},{"line":98,"address":[26642311],"length":1,"stats":{"Line":0}},{"line":99,"address":[16715774],"length":1,"stats":{"Line":0}},{"line":100,"address":[16714149],"length":1,"stats":{"Line":0}},{"line":104,"address":[16611312],"length":1,"stats":{"Line":0}},{"line":105,"address":[16679102],"length":1,"stats":{"Line":0}},{"line":106,"address":[16597618],"length":1,"stats":{"Line":0}},{"line":107,"address":[16715934],"length":1,"stats":{"Line":0}},{"line":108,"address":[16604458],"length":1,"stats":{"Line":0}},{"line":109,"address":[24372678],"length":1,"stats":{"Line":0}},{"line":110,"address":[16611490],"length":1,"stats":{"Line":0}},{"line":112,"address":[16611518],"length":1,"stats":{"Line":0}},{"line":114,"address":[16710490],"length":1,"stats":{"Line":0}},{"line":115,"address":[16604598],"length":1,"stats":{"Line":0}},{"line":116,"address":[16714482],"length":1,"stats":{"Line":0}},{"line":117,"address":[24372827],"length":1,"stats":{"Line":0}},{"line":119,"address":[24372944],"length":1,"stats":{"Line":0}},{"line":120,"address":[16611756],"length":1,"stats":{"Line":0}},{"line":121,"address":[16714664],"length":1,"stats":{"Line":0}},{"line":122,"address":[24373025],"length":1,"stats":{"Line":0}},{"line":123,"address":[16598074],"length":1,"stats":{"Line":0}},{"line":124,"address":[16611859],"length":1,"stats":{"Line":0}},{"line":125,"address":[16598124],"length":1,"stats":{"Line":0}},{"line":126,"address":[16604933],"length":1,"stats":{"Line":0}},{"line":132,"address":[16672907,16672784],"length":1,"stats":{"Line":1}},{"line":133,"address":[26643064,26643113],"length":1,"stats":{"Line":2}},{"line":138,"address":[24373312,24373443],"length":1,"stats":{"Line":0}},{"line":139,"address":[16605200,16605143],"length":1,"stats":{"Line":0}},{"line":144,"address":[16680016,16680147],"length":1,"stats":{"Line":0}},{"line":145,"address":[24373495,24373552],"length":1,"stats":{"Line":0}},{"line":150,"address":[16612416],"length":1,"stats":{"Line":0}},{"line":151,"address":[24373635],"length":1,"stats":{"Line":0}},{"line":156,"address":[16612448],"length":1,"stats":{"Line":0}},{"line":157,"address":[16673303],"length":1,"stats":{"Line":0}},{"line":162,"address":[16605552],"length":1,"stats":{"Line":0}},{"line":163,"address":[16711485],"length":1,"stats":{"Line":0}},{"line":168,"address":[16715611,16715488],"length":1,"stats":{"Line":0}},{"line":169,"address":[24373843,24373901],"length":1,"stats":{"Line":0}},{"line":174,"address":[16715632],"length":1,"stats":{"Line":0}},{"line":175,"address":[16599014],"length":1,"stats":{"Line":0}},{"line":180,"address":[16673680],"length":1,"stats":{"Line":0}},{"line":181,"address":[16673693],"length":1,"stats":{"Line":0}},{"line":186,"address":[16715808,16715931],"length":1,"stats":{"Line":0}},{"line":187,"address":[16680707,16680765],"length":1,"stats":{"Line":0}},{"line":192,"address":[16812384,16812512],"length":1,"stats":{"Line":0}},{"line":193,"address":[16673981,16673923],"length":1,"stats":{"Line":0}},{"line":198,"address":[16716240,16716112],"length":1,"stats":{"Line":0}},{"line":199,"address":[16712195,16712253],"length":1,"stats":{"Line":0}},{"line":204,"address":[16606539,16606416],"length":1,"stats":{"Line":0}},{"line":205,"address":[16599651,16599709],"length":1,"stats":{"Line":0}},{"line":210,"address":[16718290,16718064],"length":1,"stats":{"Line":0}},{"line":211,"address":[16716498,16716438],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":81},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","metrics.rs"],"content":"use std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub const UNSET_TS: u64 = 0;\n\n#[derive(Debug)]\npub struct AtomicMetric {\n    success: AtomicU64,\n    failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct AtomicSnapshot {\n    pub successes: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\nimpl AtomicMetric {\n    pub const fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(UNSET_TS),\n            last_failure_ms: AtomicU64::new(UNSET_TS),\n        }\n    }\n\n    pub fn record_success(&self) {\n        self.success.fetch_add(1, Ordering::Relaxed);\n        self.last_success_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    pub fn record_failure(&self) {\n        self.failure.fetch_add(1, Ordering::Relaxed);\n        self.last_failure_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    pub fn snapshot(&self) -> AtomicSnapshot {\n        AtomicSnapshot {\n            successes: self.success.load(Ordering::Relaxed),\n            failures: self.failure.load(Ordering::Relaxed),\n            last_success_ms: timestamp_to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: timestamp_to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n        }\n    }\n\n    pub fn reset(&self) {\n        self.success.store(0, Ordering::Relaxed);\n        self.failure.store(0, Ordering::Relaxed);\n        self.last_success_ms.store(UNSET_TS, Ordering::Relaxed);\n        self.last_failure_ms.store(UNSET_TS, Ordering::Relaxed);\n    }\n}\n\n#[inline]\npub fn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|duration| duration.as_millis() as u64)\n        .unwrap_or(UNSET_TS)\n}\n\n#[inline]\npub fn timestamp_to_option(value: u64) -> Option<u64> {\n    if value == UNSET_TS { None } else { Some(value) }\n}\n","traces":[{"line":23,"address":[19121952],"length":1,"stats":{"Line":0}},{"line":25,"address":[18983486],"length":1,"stats":{"Line":0}},{"line":26,"address":[18915702],"length":1,"stats":{"Line":0}},{"line":27,"address":[18922702],"length":1,"stats":{"Line":0}},{"line":28,"address":[19122038],"length":1,"stats":{"Line":0}},{"line":32,"address":[18909056],"length":1,"stats":{"Line":1}},{"line":33,"address":[18990590],"length":1,"stats":{"Line":1}},{"line":34,"address":[18983714,18983687],"length":1,"stats":{"Line":2}},{"line":35,"address":[19122176],"length":1,"stats":{"Line":1}},{"line":38,"address":[18915936],"length":1,"stats":{"Line":1}},{"line":39,"address":[19122238],"length":1,"stats":{"Line":1}},{"line":40,"address":[18915979,18916006],"length":1,"stats":{"Line":2}},{"line":41,"address":[13163508],"length":1,"stats":{"Line":1}},{"line":44,"address":[18983840],"length":1,"stats":{"Line":1}},{"line":46,"address":[18990798],"length":1,"stats":{"Line":1}},{"line":47,"address":[19022006],"length":1,"stats":{"Line":2}},{"line":48,"address":[18909330],"length":1,"stats":{"Line":2}},{"line":49,"address":[19122443],"length":1,"stats":{"Line":2}},{"line":53,"address":[19026112],"length":1,"stats":{"Line":1}},{"line":54,"address":[19022189],"length":1,"stats":{"Line":1}},{"line":55,"address":[19026148],"length":1,"stats":{"Line":1}},{"line":56,"address":[18916319],"length":1,"stats":{"Line":1}},{"line":57,"address":[21057946],"length":1,"stats":{"Line":1}},{"line":62,"address":[19026240],"length":1,"stats":{"Line":1}},{"line":63,"address":[13163908],"length":1,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[18991215,18991200],"length":1,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[18923472],"length":1,"stats":{"Line":2}},{"line":71,"address":[21058106],"length":1,"stats":{"Line":2}}],"covered":23,"coverable":30},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","mod.rs"],"content":"#![allow(unused_imports)]\n\npub mod config;\npub mod error;\npub mod metrics;\npub mod rate_limiter;\npub mod validation;\n\npub use config::AppConfig;\npub use error::{AppError, Result};\npub use rate_limiter::RateLimiter;\npub use validation::ValidationFailureKind;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","rate_limiter.rs"],"content":"use crate::shared::AppError;\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse tokio::sync::Mutex;\n\npub struct RateLimiter {\n    requests: Mutex<HashMap<String, Vec<Instant>>>,\n    max_requests: usize,\n    window: Duration,\n}\n\nimpl RateLimiter {\n    pub fn new(max_requests: usize, window: Duration) -> Self {\n        Self {\n            requests: Mutex::new(HashMap::new()),\n            max_requests,\n            window,\n        }\n    }\n\n    pub async fn check_and_record(&self, key: &str, message: &str) -> Result<(), AppError> {\n        let mut guard = self.requests.lock().await;\n        let now = Instant::now();\n        let entries = guard.entry(key.to_string()).or_default();\n        entries.retain(|instant| now.duration_since(*instant) < self.window);\n        if entries.len() >= self.max_requests {\n            let retry_after = self\n                .window\n                .checked_sub(now.duration_since(entries[0]))\n                .unwrap_or_default();\n            return Err(AppError::rate_limited(\n                message,\n                retry_after.as_secs().max(1),\n            ));\n        }\n        entries.push(now);\n        Ok(())\n    }\n}\n","traces":[{"line":13,"address":[14327184],"length":1,"stats":{"Line":2}},{"line":15,"address":[14252645],"length":1,"stats":{"Line":2}},{"line":21,"address":[14334300,14334272,14334336,14335754,14334542,14334582,14334383,14334720],"length":1,"stats":{"Line":8}},{"line":22,"address":[14466124,14466063,14466184,14466304],"length":1,"stats":{"Line":4}},{"line":23,"address":[14267209,14267294],"length":1,"stats":{"Line":4}},{"line":24,"address":[14267309],"length":1,"stats":{"Line":2}},{"line":25,"address":[14268037,14268016,14267437],"length":1,"stats":{"Line":5}},{"line":26,"address":[14253713],"length":1,"stats":{"Line":2}},{"line":27,"address":[14267555,14267751],"length":1,"stats":{"Line":2}},{"line":29,"address":[14335343,14335459],"length":1,"stats":{"Line":2}},{"line":31,"address":[14335665],"length":1,"stats":{"Line":1}},{"line":32,"address":[14267820],"length":1,"stats":{"Line":1}},{"line":33,"address":[14254094],"length":1,"stats":{"Line":1}},{"line":36,"address":[22028733],"length":1,"stats":{"Line":2}},{"line":37,"address":[14267610],"length":1,"stats":{"Line":2}}],"covered":15,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","validation.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// Nostr イベント検証やアプリケーションレベルのバリデーション失敗理由。\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub enum ValidationFailureKind {\n    /// 汎用的なバリデーションエラー。\n    Generic,\n    /// NIP-01 の基本整合性（ID 再計算・署名・タイムスタンプなど）違反。\n    Nip01Integrity,\n    /// NIP-10 のタグ構造（marker・relay URL 等）違反。\n    Nip10TagStructure,\n    /// NIP-19 の bech32 エンコードが不正な場合。\n    Nip19Encoding,\n    /// NIP-19 の TLV セクションが仕様外な場合。\n    Nip19Tlv,\n    /// サポート外の `kind` が指定された場合。\n    UnsupportedKind,\n    /// kind:30078 の必須タグ欠如や識別子不正。\n    Kind30078TagMissing,\n    /// kind:30078 のタグ値に不一致がある場合。\n    Kind30078TagMismatch,\n    /// kind:30078 の content スキーマが仕様外。\n    Kind30078ContentSchema,\n    /// kind:30078 の content サイズが許容範囲を超えた場合。\n    Kind30078ContentSize,\n    /// content のサイズが制限を超過。\n    ContentTooLarge,\n    /// tags の件数が制限を超過、またはタグ内容が UTF-8 ではない。\n    TagLimitExceeded,\n    /// 非 UTF-8 文字列が含まれている場合。\n    Utf8Invalid,\n    /// 許容できないタイムスタンプやプレシデンス違反。\n    TimestampOutOfRange,\n    /// PRE（Parameterized Replaceable Event）の古いリビジョンを拒否した場合。\n    PrecedenceRejected,\n}\n\nimpl ValidationFailureKind {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            ValidationFailureKind::Generic => \"generic\",\n            ValidationFailureKind::Nip01Integrity => \"nip01_integrity\",\n            ValidationFailureKind::Nip10TagStructure => \"nip10_tag_structure\",\n            ValidationFailureKind::Nip19Encoding => \"nip19_encoding\",\n            ValidationFailureKind::Nip19Tlv => \"nip19_tlv\",\n            ValidationFailureKind::UnsupportedKind => \"unsupported_kind\",\n            ValidationFailureKind::Kind30078TagMissing => \"kind30078_tag_missing\",\n            ValidationFailureKind::Kind30078TagMismatch => \"kind30078_tag_mismatch\",\n            ValidationFailureKind::Kind30078ContentSchema => \"kind30078_content_schema\",\n            ValidationFailureKind::Kind30078ContentSize => \"kind30078_content_size\",\n            ValidationFailureKind::ContentTooLarge => \"content_too_large\",\n            ValidationFailureKind::TagLimitExceeded => \"tag_limit_exceeded\",\n            ValidationFailureKind::Utf8Invalid => \"utf8_invalid\",\n            ValidationFailureKind::TimestampOutOfRange => \"timestamp_out_of_range\",\n            ValidationFailureKind::PrecedenceRejected => \"precedence_rejected\",\n        }\n    }\n}\n\nimpl fmt::Display for ValidationFailureKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}\nimpl FromStr for ValidationFailureKind {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"generic\" => Ok(ValidationFailureKind::Generic),\n            \"nip01_integrity\" => Ok(ValidationFailureKind::Nip01Integrity),\n            \"nip10_tag_structure\" => Ok(ValidationFailureKind::Nip10TagStructure),\n            \"nip19_encoding\" => Ok(ValidationFailureKind::Nip19Encoding),\n            \"nip19_tlv\" => Ok(ValidationFailureKind::Nip19Tlv),\n            \"unsupported_kind\" => Ok(ValidationFailureKind::UnsupportedKind),\n            \"kind30078_tag_missing\" => Ok(ValidationFailureKind::Kind30078TagMissing),\n            \"kind30078_tag_mismatch\" => Ok(ValidationFailureKind::Kind30078TagMismatch),\n            \"kind30078_content_schema\" => Ok(ValidationFailureKind::Kind30078ContentSchema),\n            \"kind30078_content_size\" => Ok(ValidationFailureKind::Kind30078ContentSize),\n            \"content_too_large\" => Ok(ValidationFailureKind::ContentTooLarge),\n            \"tag_limit_exceeded\" => Ok(ValidationFailureKind::TagLimitExceeded),\n            \"utf8_invalid\" => Ok(ValidationFailureKind::Utf8Invalid),\n            \"timestamp_out_of_range\" => Ok(ValidationFailureKind::TimestampOutOfRange),\n            \"precedence_rejected\" => Ok(ValidationFailureKind::PrecedenceRejected),\n            _ => Err(()),\n        }\n    }\n}\n","traces":[{"line":40,"address":[24736576],"length":1,"stats":{"Line":0}},{"line":41,"address":[24780277],"length":1,"stats":{"Line":0}},{"line":42,"address":[24743540],"length":1,"stats":{"Line":0}},{"line":43,"address":[24736638],"length":1,"stats":{"Line":0}},{"line":44,"address":[24662072],"length":1,"stats":{"Line":0}},{"line":45,"address":[24743618],"length":1,"stats":{"Line":0}},{"line":46,"address":[24780412],"length":1,"stats":{"Line":0}},{"line":47,"address":[24675910],"length":1,"stats":{"Line":0}},{"line":48,"address":[24662176],"length":1,"stats":{"Line":0}},{"line":49,"address":[24662202],"length":1,"stats":{"Line":0}},{"line":50,"address":[24662228],"length":1,"stats":{"Line":0}},{"line":51,"address":[24669038],"length":1,"stats":{"Line":0}},{"line":52,"address":[24780565],"length":1,"stats":{"Line":0}},{"line":53,"address":[24669084],"length":1,"stats":{"Line":0}},{"line":54,"address":[24775027],"length":1,"stats":{"Line":0}},{"line":55,"address":[24743866],"length":1,"stats":{"Line":0}},{"line":56,"address":[18916673],"length":1,"stats":{"Line":0}},{"line":62,"address":[24743936],"length":1,"stats":{"Line":0}},{"line":63,"address":[24779074],"length":1,"stats":{"Line":0}},{"line":69,"address":[24780752],"length":1,"stats":{"Line":0}},{"line":71,"address":[24737080,24737134],"length":1,"stats":{"Line":0}},{"line":72,"address":[24744113,24744039],"length":1,"stats":{"Line":0}},{"line":73,"address":[24737162,24737236],"length":1,"stats":{"Line":0}},{"line":74,"address":[24780983,24780909],"length":1,"stats":{"Line":0}},{"line":75,"address":[24669530,24669456],"length":1,"stats":{"Line":0}},{"line":76,"address":[24676483,24676557],"length":1,"stats":{"Line":0}},{"line":77,"address":[18917152,18917078],"length":1,"stats":{"Line":0}},{"line":78,"address":[24744419,24744345],"length":1,"stats":{"Line":0}},{"line":79,"address":[24662876,24662950],"length":1,"stats":{"Line":0}},{"line":80,"address":[24775705,24775631],"length":1,"stats":{"Line":0}},{"line":81,"address":[24781340,24781266],"length":1,"stats":{"Line":0}},{"line":82,"address":[12246853,12246927],"length":1,"stats":{"Line":0}},{"line":83,"address":[24876223,24876152],"length":1,"stats":{"Line":0}},{"line":84,"address":[24663199,24663128],"length":1,"stats":{"Line":0}},{"line":85,"address":[12247000,12247045],"length":1,"stats":{"Line":0}},{"line":86,"address":[24876286],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","app","kukuri-tauri","src-tauri","src","state.rs"],"content":"use crate::application::ports::key_manager::{KeyManager, KeyMaterialStore};\r\nuse crate::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse crate::domain::entities::ScoreWeights;\nuse crate::domain::p2p::P2PEvent;\n\r\n// アプリケーションサービスのインポート\r\nuse crate::application::ports::auth_lifecycle::AuthLifecyclePort;\nuse crate::application::ports::cache::PostCache;\nuse crate::application::ports::event_topic_store::EventTopicStore;\nuse crate::application::ports::group_key_store::GroupKeyStore;\nuse crate::application::ports::join_request_store::JoinRequestStore;\nuse crate::application::ports::messaging_gateway::MessagingGateway;\nuse crate::application::ports::offline_store::OfflinePersistence;\nuse crate::application::ports::repositories::{\r\n    BookmarkRepository, DirectMessageRepository, EventRepository, PendingTopicRepository,\r\n    PostRepository, TopicMetricsRepository, TopicRepository, UserRepository,\r\n};\r\nuse crate::application::ports::secure_storage::SecureAccountStore;\r\nuse crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\r\nuse crate::application::services::event_service::EventServiceTrait;\r\nuse crate::application::services::offline_service::OfflineServiceTrait;\r\nuse crate::application::services::p2p_service::P2PServiceTrait;\r\nuse crate::application::services::sync_service::{SyncParticipant, SyncServiceTrait};\r\nuse crate::application::services::{\n    AccessControlService, AuthService, DirectMessageService, EventService, OfflineService,\n    PostService, ProfileAvatarService, SubscriptionStateMachine, SyncService, TopicService,\n    UserSearchService, UserService,\n};\n// プレゼンテーション層のハンドラーのインポート\r\nuse crate::application::services::auth_lifecycle::DefaultAuthLifecycle;\r\nuse crate::infrastructure::{\r\n    cache::PostCacheService,\r\n    crypto::{DefaultKeyManager, DefaultSignatureService, SignatureService},\r\n    database::{\r\n        Repository, SqliteSubscriptionStateRepository, connection_pool::ConnectionPool,\r\n        sqlite_repository::SqliteRepository,\r\n    },\r\n    event::{\r\n        EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\r\n        LegacyEventManagerHandle, RepositoryEventTopicStore,\r\n    },\r\n    jobs::{\r\n        trending_metrics_job::TrendingMetricsJob,\r\n        trending_metrics_metrics::TrendingMetricsRecorder,\r\n        trending_metrics_server::spawn_prometheus_exporter,\r\n    },\r\n    messaging::NostrMessagingGateway,\r\n    offline::{OfflineReindexJob, SqliteOfflinePersistence},\r\n    p2p::{\r\n        GossipService, NetworkService,\r\n        bootstrap::P2PBootstrapper,\r\n        event_distributor::{DefaultEventDistributor, EventDistributor},\r\n    },\r\n    storage::{\n        SecureGroupKeyStore, SecureJoinRequestStore, SecureStorage,\n        secure_storage::DefaultSecureStorage,\n    },\n};\r\nuse crate::presentation::handlers::{\n    CommunityNodeHandler, EventHandler, OfflineHandler, P2PHandler, SecureStorageHandler,\n};\nuse crate::presentation::ipc::direct_message_notifier::IpcDirectMessageNotifier;\r\n\r\nuse nostr_sdk::prelude::{Event as NostrEvent, Kind, TagStandard, ToBech32};\r\nuse std::collections::{HashSet as StdHashSet, VecDeque as StdVecDeque};\r\nuse std::sync::Arc;\r\nuse tauri::{Emitter, async_runtime};\r\nuse tokio::sync::RwLock;\r\nuse tokio::sync::broadcast;\r\nuse tokio::time::{Duration, sleep};\r\n\r\nconst P2P_DEDUP_MAX: usize = 8192;\r\nconst DEFAULT_SYNC_INTERVAL_SECS: u64 = 30;\r\n\r\n/// P2P関連の状態\r\npub struct P2PState {\r\n    /// Message event channel\r\n    pub event_rx: Arc<RwLock<Option<broadcast::Receiver<P2PEvent>>>>,\r\n    /// GossipService 本体（UI購読導線で使用）\r\n    pub gossip_service: Arc<dyn GossipService>,\r\n    /// UI購読済みトピック集合（重複購読防止）\r\n    pub ui_subscribed_topics: Arc<RwLock<std::collections::HashSet<String>>>,\r\n    /// 受信イベントIDの重複排除用セット\r\n    pub seen_event_ids: Arc<RwLock<StdHashSet<String>>>,\r\n    /// 受信イベントIDの順序（容量制御用）\r\n    pub seen_event_order: Arc<RwLock<StdVecDeque<String>>>,\r\n}\r\n\r\n/// アプリケーション全体の状態を管理する構造体\r\n#[derive(Clone)]\r\npub struct AppState {\r\n    pub app_handle: tauri::AppHandle,\r\n    // 既存のマネージャー（Phase5でArc<dyn KeyManager>へ移行済み）\r\n    pub key_manager: Arc<dyn KeyManager>,\r\n    pub event_manager: Arc<dyn EventManagerHandle>,\r\n    pub p2p_state: Arc<RwLock<P2PState>>,\r\n    pub offline_reindex_job: Arc<OfflineReindexJob>,\r\n\r\n    // 新アーキテクチャのサービス層\r\n    pub auth_service: Arc<AuthService>,\r\n    pub post_service: Arc<PostService>,\r\n    pub topic_service: Arc<TopicService>,\r\n    pub user_service: Arc<UserService>,\r\n    pub user_search_service: Arc<UserSearchService>,\r\n    pub event_service: Arc<EventService>,\r\n    pub direct_message_service: Arc<DirectMessageService>,\r\n    pub sync_service: Arc<dyn SyncServiceTrait>,\n    pub p2p_service: Arc<dyn P2PServiceTrait>,\n    pub offline_service: Arc<OfflineService>,\n    pub profile_avatar_service: Arc<ProfileAvatarService>,\n    #[allow(dead_code)]\n    pub group_key_store: Arc<dyn GroupKeyStore>,\n    pub access_control_service: Arc<AccessControlService>,\n\r\n    // プレゼンテーション層のハンドラー（最適化用）\r\n    pub secure_storage_handler: Arc<SecureStorageHandler>,\n    pub event_handler: Arc<EventHandler>,\n    pub p2p_handler: Arc<P2PHandler>,\n    pub offline_handler: Arc<OfflineHandler>,\n    pub community_node_handler: Arc<CommunityNodeHandler>,\n}\n\r\nimpl AppState {\r\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\r\n        let bootstrapper = P2PBootstrapper::new(app_handle).await?;\r\n        let metrics_config = bootstrapper.config().metrics.clone();\r\n        let app_data_dir = bootstrapper.app_data_dir().to_path_buf();\r\n        let profile_avatar_dir = app_data_dir.join(\"profile_avatars\");\r\n\r\n        // Use absolute path for database\r\n        let db_path = app_data_dir.join(\"kukuri.db\");\r\n\r\n        // Debug logging\r\n        tracing::info!(\"Database path: {:?}\", db_path);\r\n\r\n        // Ensure the database file path is canonical\r\n        let db_path_str = db_path\r\n            .to_str()\r\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid database path encoding\"))?;\r\n\r\n        // Format database URL for sqlx\r\n        // On Windows, sqlx may need a specific format\r\n        let db_url = if cfg!(windows) {\r\n            // Try Windows-specific format\r\n            tracing::info!(\"Using Windows database URL format\");\r\n            format!(\"sqlite:{}?mode=rwc\", db_path_str.replace('\\\\', \"/\"))\r\n        } else {\r\n            format!(\"sqlite://{db_path_str}?mode=rwc\")\r\n        };\r\n\r\n        tracing::info!(\"Database URL: {db_url}\");\r\n\r\n        // 新アーキテクチャのリポジトリとサービスを初期化\r\n        let connection_pool = ConnectionPool::new(&db_url).await?;\r\n        let repository = Arc::new(SqliteRepository::new(connection_pool.clone()));\r\n        let topic_metrics_repository: Arc<dyn TopicMetricsRepository> =\r\n            Arc::clone(&repository) as Arc<dyn TopicMetricsRepository>;\r\n        let event_topic_store: Arc<dyn EventTopicStore> = Arc::new(RepositoryEventTopicStore::new(\r\n            Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n        ));\r\n        let subscription_repository: Arc<dyn SubscriptionStateRepository> = Arc::new(\r\n            SqliteSubscriptionStateRepository::new(connection_pool.clone()),\r\n        );\r\n\r\n        // リポジトリのマイグレーションを実行\r\n        repository.initialize().await?;\r\n\r\n        let sqlite_pool = connection_pool.get_pool().clone();\r\n\r\n        let event_manager: Arc<dyn EventManagerHandle> = Arc::new(\r\n            LegacyEventManagerHandle::new_with_connection_pool(connection_pool.clone()),\r\n        );\r\n        let offline_persistence_concrete =\r\n            Arc::new(SqliteOfflinePersistence::new(sqlite_pool.clone()));\r\n        let offline_persistence: Arc<dyn OfflinePersistence> = offline_persistence_concrete.clone();\r\n        let offline_reindex_job =\r\n            OfflineReindexJob::create(Some(app_handle.clone()), Arc::clone(&offline_persistence));\r\n        offline_reindex_job.trigger();\r\n        let offline_service = Arc::new(OfflineService::new(Arc::clone(&offline_persistence)));\r\n\r\n        // インフラストラクチャサービスの初期化\r\n        let secure_storage_impl = Arc::new(DefaultSecureStorage::new());\n        let key_material_store: Arc<dyn KeyMaterialStore> = secure_storage_impl.clone();\n        let key_manager: Arc<dyn KeyManager> = Arc::new(DefaultKeyManager::with_store(Arc::clone(\n            &key_material_store,\n        )));\n        let secure_storage: Arc<dyn SecureStorage> = secure_storage_impl.clone();\n        let secure_account_store: Arc<dyn SecureAccountStore> = secure_storage_impl.clone();\n        let group_key_store: Arc<dyn GroupKeyStore> =\n            Arc::new(SecureGroupKeyStore::new(Arc::clone(&secure_storage)));\n        let join_request_store: Arc<dyn JoinRequestStore> =\n            Arc::new(SecureJoinRequestStore::new(Arc::clone(&secure_storage)));\n        let signature_service: Arc<dyn SignatureService> = Arc::new(DefaultSignatureService::new());\n        let default_event_distributor = Arc::new(DefaultEventDistributor::new());\r\n        let event_distributor: Arc<dyn EventDistributor> =\r\n            default_event_distributor.clone() as Arc<dyn EventDistributor>;\r\n\r\n        // P2Pサービスの初期化\r\n        let (p2p_event_tx, _initial_rx) = broadcast::channel(512);\r\n        let p2p_stack = bootstrapper.build_stack(p2p_event_tx.clone()).await?;\r\n\r\n        let network_service: Arc<dyn NetworkService> = Arc::clone(&p2p_stack.network_service);\n        let gossip_service: Arc<dyn GossipService> = Arc::clone(&p2p_stack.gossip_service);\n        let p2p_service = Arc::clone(&p2p_stack.p2p_service);\n\n        let access_control_service = Arc::new(AccessControlService::new(\n            Arc::clone(&key_manager),\n            Arc::clone(&group_key_store),\n            Arc::clone(&join_request_store),\n            Arc::clone(&repository) as Arc<dyn UserRepository>,\n            Arc::clone(&signature_service),\n            Arc::clone(&gossip_service),\n        ));\n\r\n        default_event_distributor\r\n            .set_gossip_service(Arc::clone(&gossip_service))\r\n            .await;\r\n        default_event_distributor\r\n            .set_network_service(Arc::clone(&network_service))\r\n            .await;\r\n        // EventManagerへGossipServiceを接続（P2P配信経路の直結）\r\n        event_manager\r\n            .set_gossip_service(Arc::clone(&gossip_service))\r\n            .await;\r\n        // EventManagerへEventRepositoryを接続（参照トピック解決用）\r\n        event_manager\r\n            .set_event_topic_store(Arc::clone(&event_topic_store))\r\n            .await;\r\n\r\n        // UserServiceを先に初期化（他のサービスの依存）\r\n        let user_service = Arc::new(UserService::new(\r\n            Arc::clone(&repository) as Arc<dyn UserRepository>\r\n        ));\r\n        let user_search_service = Arc::new(UserSearchService::new(\r\n            Arc::clone(&repository) as Arc<dyn UserRepository>\r\n        ));\r\n\r\n        // TopicServiceを初期化（AuthServiceの依存）\r\n        let topic_service = Arc::new(TopicService::new(\r\n            Arc::clone(&repository) as Arc<dyn TopicRepository>,\r\n            Arc::clone(&repository) as Arc<dyn PendingTopicRepository>,\r\n            Arc::clone(&topic_metrics_repository),\r\n            metrics_config.enabled,\r\n            Arc::clone(&p2p_service),\r\n            Arc::clone(&offline_service) as Arc<dyn OfflineServiceTrait>,\r\n        ));\r\n        // 既定トピック（public）を保証し、EventManagerの既定配信先に設定\n        topic_service\n            .ensure_public_topic()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to ensure public topic: {}\", e))?;\n        event_manager\n            .set_default_p2p_topic_id(DEFAULT_PUBLIC_TOPIC_ID)\n            .await;\n        let distributor_default_topics = event_manager.list_default_p2p_topics().await;\r\n        default_event_distributor\r\n            .set_default_topics(distributor_default_topics)\r\n            .await;\r\n\r\n        if metrics_config.enabled {\r\n            let score_weights = ScoreWeights {\r\n                posts: metrics_config.score_weights.posts,\r\n                unique_authors: metrics_config.score_weights.unique_authors,\r\n                boosts: metrics_config.score_weights.boosts,\r\n            };\r\n\r\n            let metrics_recorder = TrendingMetricsRecorder::new(metrics_config.emit_histogram)\r\n                .map(Arc::new)\r\n                .map_err(|err| anyhow::anyhow!(\"Failed to initialize metrics recorder: {err}\"))?;\r\n\r\n            if let Some(port) = metrics_config.prometheus_port {\r\n                spawn_prometheus_exporter(port, Arc::clone(&metrics_recorder));\r\n            }\r\n\r\n            let job = Arc::new(TrendingMetricsJob::new(\r\n                Arc::clone(&topic_metrics_repository),\r\n                Some(score_weights),\r\n                metrics_config.ttl_hours,\r\n                Some(Arc::clone(&metrics_recorder)),\r\n            ));\r\n            spawn_trending_metrics_job(\r\n                job,\r\n                Duration::from_secs(metrics_config.interval_minutes.max(1) * 60),\r\n            );\r\n        }\r\n\r\n        // AuthServiceの初期化（UserServiceとTopicServiceが必要）\r\n        let lifecycle_port: Arc<dyn AuthLifecyclePort> = Arc::new(DefaultAuthLifecycle::new(\r\n            Arc::clone(&user_service),\r\n            Arc::clone(&topic_service),\r\n        ));\r\n\r\n        let auth_service = Arc::new(AuthService::new(\r\n            Arc::clone(&key_manager),\r\n            Arc::clone(&secure_storage),\r\n            lifecycle_port,\r\n        ));\r\n\r\n        let subscription_state = Arc::new(SubscriptionStateMachine::new(Arc::clone(\r\n            &subscription_repository,\r\n        )));\r\n\r\n        // EventServiceの初期化\r\n        let legacy_event_gateway =\r\n            Arc::new(LegacyEventManagerGateway::new(Arc::clone(&event_manager)));\r\n        let event_gateway: Arc<dyn crate::application::ports::event_gateway::EventGateway> =\r\n            legacy_event_gateway.clone();\r\n        let mut event_service_inner = EventService::new(\r\n            Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n            Arc::clone(&signature_service),\r\n            Arc::clone(&event_distributor),\r\n            event_gateway,\r\n            Arc::clone(&subscription_state)\r\n                as Arc<dyn crate::application::services::SubscriptionStateStore>,\r\n        );\r\n        event_service_inner.set_subscription_invoker(Arc::new(\r\n            EventManagerSubscriptionInvoker::new(Arc::clone(&event_manager)),\r\n        ));\r\n        legacy_event_gateway\r\n            .set_app_handle(app_handle.clone())\r\n            .await;\r\n        let event_service = Arc::new(event_service_inner);\r\n\r\n        let messaging_gateway: Arc<dyn MessagingGateway> = Arc::new(NostrMessagingGateway::new(\r\n            Arc::clone(&key_manager),\r\n            Arc::clone(&event_manager),\r\n        ));\r\n\r\n        let direct_message_service = Arc::new(DirectMessageService::new(\r\n            Arc::clone(&repository) as Arc<dyn DirectMessageRepository>,\r\n            Arc::clone(&messaging_gateway),\r\n            Some(Arc::new(IpcDirectMessageNotifier::new(app_handle))),\r\n        ));\r\n\r\n        {\r\n            let event_manager_for_dm = Arc::clone(&event_manager);\r\n            let key_manager_for_dm = Arc::clone(&key_manager);\r\n            let direct_message_service_for_dm = Arc::clone(&direct_message_service);\r\n\r\n            event_manager_for_dm\r\n                .register_event_callback(Arc::new(move |event: NostrEvent| {\r\n                    if event.kind != Kind::EncryptedDirectMessage {\r\n                        return;\r\n                    }\r\n\r\n                    let recipient_pubkey =\r\n                        event\r\n                            .tags\r\n                            .iter()\r\n                            .find_map(|tag| match tag.as_standardized() {\r\n                                Some(TagStandard::PublicKey { public_key, .. }) => Some(public_key),\r\n                                _ => None,\r\n                            });\r\n\r\n                    let Some(recipient_pubkey) = recipient_pubkey else {\r\n                        return;\r\n                    };\r\n\r\n                    let recipient_hex = recipient_pubkey.to_string();\r\n                    let key_manager = Arc::clone(&key_manager_for_dm);\r\n                    let dm_service = Arc::clone(&direct_message_service_for_dm);\r\n                    let event_clone = event.clone();\r\n\r\n                    async_runtime::spawn(async move {\r\n                        let keypair = match key_manager.current_keypair().await {\r\n                            Ok(pair) => pair,\r\n                            Err(err) => {\r\n                                tracing::error!(\r\n                                    error = %err,\r\n                                    \"Failed to load current keypair for direct message ingestion\"\r\n                                );\r\n                                return;\r\n                            }\r\n                        };\r\n\r\n                        if keypair.public_key != recipient_hex {\r\n                            return;\r\n                        }\r\n\r\n                        let sender_npub = match event_clone.pubkey.to_bech32() {\r\n                            Ok(value) => value,\r\n                            Err(err) => {\r\n                                tracing::error!(\r\n                                    error = %err,\r\n                                    \"Failed to convert sender pubkey to npub for direct message\"\r\n                                );\r\n                                return;\r\n                            }\r\n                        };\r\n\r\n                        let created_at_millis =\n                            (event_clone.created_at.as_secs() as i64).saturating_mul(1000);\n                        if let Err(err) = dm_service\r\n                            .ingest_incoming_message(\r\n                                &keypair.npub,\r\n                                &sender_npub,\r\n                                &event_clone.content,\r\n                                Some(event_clone.id.to_string()),\r\n                                created_at_millis,\r\n                            )\r\n                            .await\r\n                        {\r\n                            tracing::error!(\r\n                                error = %err,\r\n                                sender = sender_npub,\r\n                                owner = keypair.npub,\r\n                                \"Failed to ingest incoming direct message\"\r\n                            );\r\n                        }\r\n                    });\r\n                }))\r\n                .await;\r\n        }\r\n\r\n        let post_cache: Arc<dyn PostCache> = Arc::new(PostCacheService::new());\r\n        // PostServiceの初期化\r\n        let post_service = Arc::new(PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            Arc::clone(&event_service) as Arc<dyn EventServiceTrait>,\n            Arc::clone(&post_cache),\n            Arc::clone(&group_key_store),\n        ));\n\r\n        let post_sync_participant: Arc<dyn SyncParticipant> = post_service.clone();\r\n        let event_sync_participant: Arc<dyn SyncParticipant> = event_service.clone();\r\n\r\n        let sync_service: Arc<dyn SyncServiceTrait> = Arc::new(SyncService::new(\r\n            Arc::clone(&network_service),\r\n            post_sync_participant,\r\n            event_sync_participant,\r\n        ));\r\n\r\n        let profile_avatar_service = Arc::new(\r\n            ProfileAvatarService::new(profile_avatar_dir.clone())\r\n                .await\r\n                .map_err(|e| anyhow::anyhow!(\"Failed to initialize profile avatar service: {e}\"))?,\r\n        );\r\n\r\n        // プレゼンテーション層のハンドラーを初期化\r\n        let secure_storage_handler = Arc::new(SecureStorageHandler::new(\n            Arc::clone(&auth_service),\r\n            Arc::clone(&secure_account_store),\r\n        ));\r\n        let event_handler = Arc::new(EventHandler::new(\n            Arc::clone(&event_service)\n                as Arc<dyn crate::application::services::event_service::EventServiceTrait>,\n            Arc::clone(&key_manager),\n            Arc::clone(&event_manager),\n        ));\n        let p2p_handler = Arc::new(P2PHandler::new(Arc::clone(&p2p_service)));\n        let offline_handler = Arc::new(OfflineHandler::new(Arc::clone(&offline_service)\n            as Arc<dyn crate::application::services::offline_service::OfflineServiceTrait>));\n        let community_node_handler = Arc::new(CommunityNodeHandler::new(\n            Arc::clone(&key_manager),\n            Arc::clone(&secure_storage),\n            Arc::clone(&group_key_store),\n        ));\n\r\n        // P2P接続イベントを監視し、再接続時に再索引ジョブをトリガー\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let job = Arc::clone(&offline_reindex_job);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    if matches!(event, P2PEvent::NetworkConnected { .. }) {\r\n                        job.trigger();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let event_service_clone = Arc::clone(&event_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    match event {\r\n                        P2PEvent::NetworkDisconnected { .. } => {\r\n                            if let Err(e) = event_service_clone.handle_network_disconnected().await\r\n                            {\r\n                                tracing::warn!(\"Failed to mark subscriptions for resync: {}\", e);\r\n                            }\r\n                        }\r\n                        P2PEvent::NetworkConnected { .. } => {\r\n                            if let Err(e) = event_service_clone.handle_network_connected().await {\r\n                                tracing::warn!(\r\n                                    \"Failed to restore subscriptions after reconnect: {}\",\r\n                                    e\r\n                                );\r\n                            }\r\n                        }\r\n                        _ => {}\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // UI向けイベント購読を確保\r\n        let p2p_event_rx = p2p_event_tx.subscribe();\r\n\r\n        // P2P状態の初期化\r\n        let p2p_state = Arc::new(RwLock::new(P2PState {\r\n            event_rx: Arc::new(RwLock::new(Some(p2p_event_rx))),\r\n            gossip_service: Arc::clone(&gossip_service),\r\n            ui_subscribed_topics: Arc::new(RwLock::new(Default::default())),\r\n            seen_event_ids: Arc::new(RwLock::new(Default::default())),\r\n            seen_event_order: Arc::new(RwLock::new(Default::default())),\r\n        }));\r\n\r\n        // 既定トピック`public`に対するUI購読を張る（冪等）\r\n        // TopicService.ensure_public_topic でjoinは保証済\r\n        let this_handle = app_handle.clone();\r\n        let this = Self {\r\n            app_handle: this_handle,\r\n            key_manager,\r\n            event_manager,\r\n            p2p_state,\r\n            offline_reindex_job,\r\n            auth_service,\r\n            post_service,\r\n            topic_service,\r\n            user_service,\r\n            user_search_service,\r\n            event_service,\r\n            direct_message_service,\n            sync_service,\n            p2p_service,\n            offline_service,\n            profile_avatar_service,\n            group_key_store,\n            access_control_service,\n            secure_storage_handler,\n            event_handler,\n            p2p_handler,\n            offline_handler,\n            community_node_handler,\n        };\n\r\n        // SyncService の定期実行と P2P 接続状態フックをセットアップ\r\n        {\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                if let Err(err) = sync_service.start_sync().await {\r\n                    tracing::warn!(error = %err, \"initial sync run failed\");\r\n                }\r\n            });\r\n        }\r\n\r\n        {\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                sync_service.schedule_sync(DEFAULT_SYNC_INTERVAL_SECS).await;\r\n            });\r\n        }\r\n\r\n        {\r\n            let mut event_rx = p2p_event_tx.subscribe();\r\n            let sync_service = Arc::clone(&this.sync_service);\r\n            tauri::async_runtime::spawn(async move {\r\n                while let Ok(event) = event_rx.recv().await {\r\n                    match event {\r\n                        P2PEvent::NetworkConnected { .. } => {\r\n                            if let Err(err) = sync_service.start_sync().await {\r\n                                tracing::warn!(\r\n                                    error = %err,\r\n                                    \"failed to trigger sync after network connect\"\r\n                                );\r\n                            }\r\n                        }\r\n                        P2PEvent::NetworkDisconnected { .. } => {\r\n                            if let Err(err) = sync_service.stop_sync().await {\r\n                                tracing::warn!(\r\n                                    error = %err,\r\n                                    \"failed to stop sync after network disconnect\"\r\n                                );\r\n                            }\r\n                        }\r\n                        _ => {}\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        // 起動時に既定＋ユーザー固有トピックの購読を確立\r\n        {\r\n            let this_clone = this.clone();\r\n            tauri::async_runtime::spawn(async move {\r\n                if let Err(e) = this_clone.ensure_default_and_user_subscriptions().await {\r\n                    tracing::warn!(\"Failed to ensure default/user subscriptions: {}\", e);\r\n                }\r\n            });\r\n        }\r\n\r\n        Ok(this)\r\n    }\r\n\r\n    /// P2P機能を初期化\r\n    pub async fn initialize_p2p(&self) -> anyhow::Result<()> {\r\n        // 旧GossipManager経路は無効化。IrohGossipService経由で運用。\r\n        // 互換のため成功扱いで何もしない。\r\n        Ok(())\r\n    }\r\n\r\n    // Event loop for P2P messages is now handled via UI emitter in lib.rs using event_rx\r\n\r\n    /// UI向けに指定トピックの購読を確立（冪等）\r\n    pub async fn ensure_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\r\n        // 重複購読チェック\r\n        {\r\n            let p2p_state = self.p2p_state.read().await;\r\n            let subs = p2p_state.ui_subscribed_topics.read().await;\r\n            if subs.contains(topic_id) {\r\n                return Ok(());\r\n            }\r\n        }\r\n\r\n        // 購読開始（joinはTopicService側で行われるが、冪等joinは吸収される）\r\n        let (\n            gossip,\n            event_manager,\n            access_control,\n            community_node_handler,\n            p2p_state_arc,\n            app_handle,\n            topic,\n        ) = {\n            let p2p_state = self.p2p_state.read().await;\n            (\n                Arc::clone(&p2p_state.gossip_service),\n                Arc::clone(&self.event_manager),\n                Arc::clone(&self.access_control_service),\n                Arc::clone(&self.community_node_handler),\n                Arc::clone(&self.p2p_state),\n                self.app_handle.clone(),\n                topic_id.to_string(),\n            )\n        };\n\r\n        // 先にフラグを立てる（競合回避）\r\n        {\r\n            let ui_arc = {\r\n                let p2p = p2p_state_arc.read().await;\r\n                Arc::clone(&p2p.ui_subscribed_topics)\r\n            };\r\n            let mut subs = ui_arc.write().await;\r\n            subs.insert(topic.clone());\r\n        }\r\n\r\n        tauri::async_runtime::spawn(async move {\r\n            match gossip.subscribe(&topic).await {\r\n                Ok(mut rx) => {\r\n                    tracing::info!(\"UI subscribed to topic {}\", topic);\r\n                    while let Some(evt) = rx.recv().await {\r\n                        // 重複排除（イベントID）\r\n                        let evt_id = evt.id.clone();\r\n                        let (set_arc, order_arc) = {\r\n                            let p2p = p2p_state_arc.read().await;\r\n                            (\r\n                                Arc::clone(&p2p.seen_event_ids),\r\n                                Arc::clone(&p2p.seen_event_order),\r\n                            )\r\n                        };\r\n                        {\r\n                            let mut set = set_arc.write().await;\r\n                            if set.contains(&evt_id) {\r\n                                continue;\r\n                            }\r\n                            set.insert(evt_id.clone());\r\n                        }\r\n                        {\r\n                            let mut order = order_arc.write().await;\r\n                            order.push_back(evt_id.clone());\r\n                            if order.len() > P2P_DEDUP_MAX {\r\n                                if let Some(old_id) = order.pop_front() {\r\n                                    let mut set = set_arc.write().await;\r\n                                    set.remove(&old_id);\r\n                                }\r\n                            }\r\n                        }\r\n                        // 受信: domain::entities::Event\r\n                        // UIへemit（p2p://message）\r\n                        #[derive(serde::Serialize, Clone)]\r\n                        struct UiMsg {\r\n                            id: String,\r\n                            author: String,\r\n                            content: String,\r\n                            timestamp: i64,\r\n                            signature: String,\r\n                        }\r\n                        #[derive(serde::Serialize, Clone)]\r\n                        struct UiP2PMessageEvent {\r\n                            topic_id: String,\r\n                            message: UiMsg,\r\n                        }\r\n\r\n                        let payload = UiP2PMessageEvent {\r\n                            topic_id: topic.clone(),\r\n                            message: UiMsg {\r\n                                id: evt.id.clone(),\r\n                                author: evt.pubkey.clone(),\r\n                                content: evt.content.clone(),\r\n                                timestamp: evt.created_at.timestamp_millis(),\r\n                                signature: evt.sig.clone(),\r\n                            },\r\n                        };\r\n                        if let Err(e) = app_handle.emit(\"p2p://message\", payload) {\n                            tracing::error!(\"Failed to emit UI P2P message: {}\", e);\n                        }\n\n                        if matches!(evt.kind, 39020 | 39022) {\n                            let access_control = Arc::clone(&access_control);\n                            let event_clone = evt.clone();\n                            tauri::async_runtime::spawn(async move {\n                                if let Err(err) =\n                                    access_control.handle_incoming_event(&event_clone).await\n                                {\n                                    tracing::warn!(\n                                        error = %err,\n                                        kind = event_clone.kind,\n                                        \"access control event handling failed\"\n                                    );\n                                }\n                            });\n                        }\n\n                        if matches!(evt.kind, 39000 | 39001) {\n                            let handler = Arc::clone(&community_node_handler);\n                            let event_clone = evt.clone();\n                            tauri::async_runtime::spawn(async move {\n                                if let Err(err) = handler.ingest_bootstrap_event(&event_clone).await\n                                {\n                                    tracing::warn!(\n                                        error = %err,\n                                        kind = event_clone.kind,\n                                        \"bootstrap gossip event ingestion failed\"\n                                    );\n                                }\n                            });\n                        }\n\n                        // 既存Nostr系導線へも流す（必要に応じて）\n                        // domain::Event -> NostrEventPayload 相当はEventManager内にあるが、\n                        // ここではDB保存・加工は後段で検討するためスキップ\n                        let _ = event_manager; // 未来の拡張用プレースホルダ\n                    }\r\n                    // チャネルクローズ時、購読フラグを解除\r\n                    let ui_arc = {\r\n                        let p2p = p2p_state_arc.read().await;\r\n                        Arc::clone(&p2p.ui_subscribed_topics)\r\n                    };\r\n                    let mut subs = ui_arc.write().await;\r\n                    subs.remove(&topic);\r\n                    tracing::info!(\"UI subscription ended for topic {}\", topic);\r\n                }\r\n                Err(e) => {\r\n                    tracing::error!(\"Failed to subscribe to topic {}: {}\", topic, e);\r\n                    let ui_arc = {\r\n                        let p2p = p2p_state_arc.read().await;\r\n                        Arc::clone(&p2p.ui_subscribed_topics)\r\n                    };\r\n                    let mut subs = ui_arc.write().await;\r\n                    subs.remove(&topic);\r\n                }\r\n            }\r\n        });\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// 既定トピックとユーザー固有トピックの購読を確立（冪等）\r\n    pub async fn ensure_default_and_user_subscriptions(&self) -> anyhow::Result<()> {\n        let mut topics = self.event_manager.list_default_p2p_topics().await;\n        if let Ok(keypair) = self.key_manager.current_keypair().await {\n            topics.push(crate::domain::p2p::user_topic_id(&keypair.public_key));\n        }\n        for t in topics {\n            if let Err(e) = self.ensure_ui_subscription(&t).await {\n                tracing::warn!(\"Failed to ensure subscription for {}: {}\", t, e);\n            }\n        }\n        Ok(())\r\n    }\r\n\r\n    /// UI向け購読を停止（存在しなければ何もしない）\r\n    pub async fn stop_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\r\n        // フラグのみ除去（購読タスクはチャネルクローズにより自然終了）\r\n        let ui_subs_arc = {\r\n            let p2p_state = self.p2p_state.read().await;\r\n            Arc::clone(&p2p_state.ui_subscribed_topics)\r\n        };\r\n        let mut subs = ui_subs_arc.write().await;\r\n        subs.remove(topic_id);\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn spawn_trending_metrics_job(job: Arc<TrendingMetricsJob>, interval: Duration) {\r\n    tracing::info!(\r\n        target: \"metrics::trending\",\r\n        interval_seconds = interval.as_secs(),\r\n        \"starting trending metrics job loop\"\r\n    );\r\n    async_runtime::spawn(async move {\r\n        loop {\r\n            if let Err(err) = job.run_once().await {\r\n                tracing::error!(\r\n                    target: \"metrics::trending\",\r\n                    error = %err,\r\n                    \"trending metrics job run failed\"\r\n                );\r\n            }\r\n            sleep(interval).await;\r\n        }\r\n    });\r\n}\r\n","traces":[{"line":123,"address":[89557003,89556890,89554659,89555396,89554522,89556074,89556199,89555338,89557701,89557764],"length":1,"stats":{"Line":0}},{"line":124,"address":[19827453,19826272,19826391,19826304,19826280,19827597,19832487,19827116],"length":1,"stats":{"Line":0}},{"line":125,"address":[19769940],"length":1,"stats":{"Line":0}},{"line":126,"address":[19835064,19834940],"length":1,"stats":{"Line":0}},{"line":127,"address":[19760354],"length":1,"stats":{"Line":0}},{"line":128,"address":[14008056,14007951],"length":1,"stats":{"Line":0}},{"line":131,"address":[89839935,89837567,89836843,89839187,89836678,89836830,89839174,89838370,89837580,89839022,89837415,89838383,89839783,89838218,89839948],"length":1,"stats":{"Line":0}},{"line":134,"address":[19870575,19871181,19870661,20029081,20029215],"length":1,"stats":{"Line":0}},{"line":137,"address":[13000865,13002208,13004135,13001998],"length":1,"stats":{"Line":0}},{"line":139,"address":[19802096,19802100,19769592],"length":1,"stats":{"Line":0}},{"line":145,"address":[19987529,19987663],"length":1,"stats":{"Line":0}},{"line":148,"address":[19868502,19868581],"length":1,"stats":{"Line":0}},{"line":151,"address":[19837504,19994953,19837590,19995087,19838110],"length":1,"stats":{"Line":0}},{"line":154,"address":[12113278],"length":1,"stats":{"Line":0}},{"line":155,"address":[19765032,19765209],"length":1,"stats":{"Line":0}},{"line":156,"address":[19758512,19758605],"length":1,"stats":{"Line":0}},{"line":158,"address":[13005019],"length":1,"stats":{"Line":0}},{"line":159,"address":[19772394],"length":1,"stats":{"Line":0}},{"line":162,"address":[89841774,89840118,89841174,89841702,89840190,89840718,89840646,89841246],"length":1,"stats":{"Line":0}},{"line":166,"address":[14006900,14013309,14013902,14017116,14013575,14013402],"length":1,"stats":{"Line":0}},{"line":168,"address":[19834283,19834156],"length":1,"stats":{"Line":0}},{"line":171,"address":[89559095,89559048,89560104,89559576,89560151,89559623,89558567,89558520],"length":1,"stats":{"Line":0}},{"line":173,"address":[19841473,19841563],"length":1,"stats":{"Line":0}},{"line":175,"address":[19841650,19841743],"length":1,"stats":{"Line":0}},{"line":176,"address":[19769523,19767036],"length":1,"stats":{"Line":0}},{"line":178,"address":[19877197],"length":1,"stats":{"Line":0}},{"line":179,"address":[19767512,19767415],"length":1,"stats":{"Line":0}},{"line":182,"address":[19774606,19774665],"length":1,"stats":{"Line":0}},{"line":183,"address":[19974037,19974130],"length":1,"stats":{"Line":0}},{"line":184,"address":[14015515,14015406],"length":1,"stats":{"Line":0}},{"line":185,"address":[14015391],"length":1,"stats":{"Line":0}},{"line":187,"address":[19835901,19835991],"length":1,"stats":{"Line":0}},{"line":188,"address":[13007560,13007645],"length":1,"stats":{"Line":0}},{"line":189,"address":[19775310,19775434],"length":1,"stats":{"Line":0}},{"line":191,"address":[14016198,14016092],"length":1,"stats":{"Line":0}},{"line":193,"address":[19775815,19775753],"length":1,"stats":{"Line":0}},{"line":194,"address":[19768965,19768895],"length":1,"stats":{"Line":0}},{"line":195,"address":[19762249,19762342],"length":1,"stats":{"Line":0}},{"line":199,"address":[19836963,19837045],"length":1,"stats":{"Line":0}},{"line":200,"address":[11539286],"length":1,"stats":{"Line":0}},{"line":202,"address":[19776991,19777145],"length":1,"stats":{"Line":0}},{"line":203,"address":[19770191,19770300],"length":1,"stats":{"Line":0}},{"line":204,"address":[19881975,19881826],"length":1,"stats":{"Line":0}},{"line":206,"address":[19882740,19883077,19882949],"length":1,"stats":{"Line":0}},{"line":207,"address":[19880442,19880349],"length":1,"stats":{"Line":0}},{"line":208,"address":[19976898,19977008],"length":1,"stats":{"Line":0}},{"line":209,"address":[13009928,13010030],"length":1,"stats":{"Line":0}},{"line":210,"address":[19838686,19838780],"length":1,"stats":{"Line":0}},{"line":211,"address":[13010171,13010273],"length":1,"stats":{"Line":0}},{"line":212,"address":[19880993],"length":1,"stats":{"Line":0}},{"line":215,"address":[19883289,19883095,19883243],"length":1,"stats":{"Line":0}},{"line":216,"address":[19877593],"length":1,"stats":{"Line":0}},{"line":217,"address":[19878208,19877678,19877738,19865342],"length":1,"stats":{"Line":0}},{"line":218,"address":[19882345,19882445,19882491],"length":1,"stats":{"Line":0}},{"line":219,"address":[19765739],"length":1,"stats":{"Line":0}},{"line":220,"address":[19865363,19878528,19878588],"length":1,"stats":{"Line":0}},{"line":222,"address":[13012162,13012079,13011939],"length":1,"stats":{"Line":0}},{"line":223,"address":[19878897],"length":1,"stats":{"Line":0}},{"line":224,"address":[14020676,14006984,14020611],"length":1,"stats":{"Line":0}},{"line":226,"address":[19766838,19766755,19766607],"length":1,"stats":{"Line":0}},{"line":227,"address":[19883321],"length":1,"stats":{"Line":0}},{"line":228,"address":[12113434],"length":1,"stats":{"Line":0}},{"line":231,"address":[19883819],"length":1,"stats":{"Line":0}},{"line":232,"address":[19883735],"length":1,"stats":{"Line":0}},{"line":234,"address":[19885697],"length":1,"stats":{"Line":0}},{"line":235,"address":[14021608],"length":1,"stats":{"Line":0}},{"line":239,"address":[19849618],"length":1,"stats":{"Line":0}},{"line":240,"address":[19884263,19884158],"length":1,"stats":{"Line":0}},{"line":241,"address":[13013500,13013422],"length":1,"stats":{"Line":0}},{"line":242,"address":[19886043,19886145],"length":1,"stats":{"Line":0}},{"line":243,"address":[19849393],"length":1,"stats":{"Line":0}},{"line":244,"address":[13013654,13013740],"length":1,"stats":{"Line":0}},{"line":245,"address":[13013756],"length":1,"stats":{"Line":0}},{"line":248,"address":[19775179,19775089,19775659,19775816,19776012,19775529,19775225],"length":1,"stats":{"Line":0}},{"line":250,"address":[12107876],"length":1,"stats":{"Line":0}},{"line":251,"address":[19906703,19906688,19887304],"length":1,"stats":{"Line":0}},{"line":252,"address":[13014745,13014840,13014650],"length":1,"stats":{"Line":0}},{"line":254,"address":[19770174],"length":1,"stats":{"Line":0}},{"line":255,"address":[11539452],"length":1,"stats":{"Line":0}},{"line":256,"address":[13015800,13015770,13015621],"length":1,"stats":{"Line":0}},{"line":257,"address":[19886711],"length":1,"stats":{"Line":0}},{"line":258,"address":[14024449,14024509,14007089],"length":1,"stats":{"Line":0}},{"line":260,"address":[19883144],"length":1,"stats":{"Line":0}},{"line":262,"address":[19883198],"length":1,"stats":{"Line":0}},{"line":263,"address":[19983582],"length":1,"stats":{"Line":0}},{"line":264,"address":[19887158],"length":1,"stats":{"Line":0}},{"line":267,"address":[19780939,19777337,19777585],"length":1,"stats":{"Line":0}},{"line":269,"address":[19905279,19887425,19905264],"length":1,"stats":{"Line":0}},{"line":271,"address":[19883534,19883466],"length":1,"stats":{"Line":0}},{"line":272,"address":[19777774,19777645],"length":1,"stats":{"Line":0}},{"line":275,"address":[19845829,19845896],"length":1,"stats":{"Line":0}},{"line":276,"address":[19887528,19887694],"length":1,"stats":{"Line":0}},{"line":277,"address":[19887718],"length":1,"stats":{"Line":0}},{"line":278,"address":[19777906],"length":1,"stats":{"Line":0}},{"line":279,"address":[19984217,19984301],"length":1,"stats":{"Line":0}},{"line":282,"address":[117105845,117109550],"length":1,"stats":{"Line":0}},{"line":283,"address":[19884155,19884067],"length":1,"stats":{"Line":0}},{"line":288,"address":[19785496,19785539,19785616],"length":1,"stats":{"Line":0}},{"line":289,"address":[19778421,19777241],"length":1,"stats":{"Line":0}},{"line":290,"address":[19785413],"length":1,"stats":{"Line":0}},{"line":293,"address":[19885030,19884902,19884845],"length":1,"stats":{"Line":0}},{"line":294,"address":[19778678,19778771],"length":1,"stats":{"Line":0}},{"line":295,"address":[19888651],"length":1,"stats":{"Line":0}},{"line":296,"address":[76117194,76117264,76113603],"length":1,"stats":{"Line":0}},{"line":299,"address":[19885063,19885154],"length":1,"stats":{"Line":0}},{"line":300,"address":[13017868],"length":1,"stats":{"Line":0}},{"line":304,"address":[19847145,19847254],"length":1,"stats":{"Line":0}},{"line":306,"address":[19779641,19779533],"length":1,"stats":{"Line":0}},{"line":309,"address":[116465804,116462112],"length":1,"stats":{"Line":0}},{"line":310,"address":[19773125,19773023],"length":1,"stats":{"Line":0}},{"line":311,"address":[116496772,116493098],"length":1,"stats":{"Line":0}},{"line":312,"address":[119653467,119649793],"length":1,"stats":{"Line":0}},{"line":313,"address":[19787066],"length":1,"stats":{"Line":0}},{"line":314,"address":[119649839,119653513],"length":1,"stats":{"Line":0}},{"line":316,"address":[19848284,19848118],"length":1,"stats":{"Line":0}},{"line":317,"address":[19886353,19886255],"length":1,"stats":{"Line":0}},{"line":319,"address":[19848413,19848467,19848337],"length":1,"stats":{"Line":0}},{"line":320,"address":[19886483],"length":1,"stats":{"Line":0}},{"line":321,"address":[19774177,19773908,19752806,19773848],"length":1,"stats":{"Line":0}},{"line":322,"address":[19855898,19856118],"length":1,"stats":{"Line":0}},{"line":324,"address":[19887536,19887587,19887670],"length":1,"stats":{"Line":0}},{"line":325,"address":[19887320,19887413],"length":1,"stats":{"Line":0}},{"line":326,"address":[19887437],"length":1,"stats":{"Line":0}},{"line":329,"address":[19988439,19988544,19988675],"length":1,"stats":{"Line":0}},{"line":330,"address":[19849587,19849664],"length":1,"stats":{"Line":0}},{"line":331,"address":[19856623,19856730],"length":1,"stats":{"Line":0}},{"line":332,"address":[14029613,14029538],"length":1,"stats":{"Line":0}},{"line":336,"address":[19850344,19850213],"length":1,"stats":{"Line":0}},{"line":337,"address":[117150801,117154537,117154354,117150615],"length":1,"stats":{"Line":0}},{"line":338,"address":[19850506,19850611],"length":1,"stats":{"Line":0}},{"line":340,"address":[19857562,19857906,19857813],"length":1,"stats":{"Line":0}},{"line":341,"address":[19871272,19857684,19871344,19870352],"length":1,"stats":{"Line":0}},{"line":342,"address":[116669862,116673598],"length":1,"stats":{"Line":0}},{"line":347,"address":[19907267,19907310],"length":1,"stats":{"Line":0}},{"line":350,"address":[19789867,19789840],"length":1,"stats":{"Line":0}},{"line":351,"address":[19796738],"length":1,"stats":{"Line":0}},{"line":352,"address":[19908231],"length":1,"stats":{"Line":0}},{"line":355,"address":[19863655],"length":1,"stats":{"Line":0}},{"line":359,"address":[19863694],"length":1,"stats":{"Line":0}},{"line":360,"address":[19789131,19789208],"length":1,"stats":{"Line":0}},{"line":361,"address":[19796084,19796016],"length":1,"stats":{"Line":0}},{"line":362,"address":[116494208,116497958],"length":1,"stats":{"Line":0}},{"line":364,"address":[19790150,19790000,19789369,19793852,19793942,19790417,19790046,19789663],"length":1,"stats":{"Line":0}},{"line":365,"address":[19902815,19902982,19902884,19903153],"length":1,"stats":{"Line":0}},{"line":366,"address":[19804531],"length":1,"stats":{"Line":0}},{"line":367,"address":[14045308],"length":1,"stats":{"Line":0}},{"line":368,"address":[14046791,14045356,14046290,14168233,14168367],"length":1,"stats":{"Line":0}},{"line":376,"address":[116498160,116501910],"length":1,"stats":{"Line":0}},{"line":380,"address":[14045451],"length":1,"stats":{"Line":0}},{"line":381,"address":[119653548,119653903,119654710,119649660,119653343,119653403,119649703,119654801,119649874,119649614,119654560,119653205,119653283,119654005,119651028,119650960,119650283,119650827,119649746,119650198],"length":1,"stats":{"Line":0}},{"line":383,"address":[13335881,13336015],"length":1,"stats":{"Line":0}},{"line":391,"address":[116500330,116496509,116500214,116501771,116498032,116496633,116501846],"length":1,"stats":{"Line":0}},{"line":392,"address":[19909659,19909565],"length":1,"stats":{"Line":0}},{"line":393,"address":[19807986,19810197,19805599,19805162,19805527,19807884],"length":1,"stats":{"Line":0}},{"line":394,"address":[76120584],"length":1,"stats":{"Line":0}},{"line":395,"address":[20004505],"length":1,"stats":{"Line":0}},{"line":396,"address":[14045807],"length":1,"stats":{"Line":0}},{"line":397,"address":[19908213],"length":1,"stats":{"Line":0}},{"line":398,"address":[19798424],"length":1,"stats":{"Line":0}},{"line":401,"address":[11580429],"length":1,"stats":{"Line":0}},{"line":403,"address":[19907615,19907114,20027625,20027759,19907013],"length":1,"stats":{"Line":0}},{"line":412,"address":[19752827,19776531,19776343,19776408],"length":1,"stats":{"Line":0}},{"line":415,"address":[19889492],"length":1,"stats":{"Line":0}},{"line":417,"address":[19895919,19896050,19895750],"length":1,"stats":{"Line":0}},{"line":418,"address":[13022221,13022148],"length":1,"stats":{"Line":0}},{"line":419,"address":[19783857,19783763],"length":1,"stats":{"Line":0}},{"line":420,"address":[76121264,76120752],"length":1,"stats":{"Line":0}},{"line":421,"address":[13022588,13022486],"length":1,"stats":{"Line":0}},{"line":422,"address":[19791123],"length":1,"stats":{"Line":0}},{"line":425,"address":[117157014,117157526],"length":1,"stats":{"Line":0}},{"line":426,"address":[19890627,19890732],"length":1,"stats":{"Line":0}},{"line":428,"address":[117157044,117157556],"length":1,"stats":{"Line":0}},{"line":429,"address":[117113342,117113854],"length":1,"stats":{"Line":0}},{"line":430,"address":[19852779],"length":1,"stats":{"Line":0}},{"line":431,"address":[116500178,116500690],"length":1,"stats":{"Line":0}},{"line":435,"address":[14033329,14032743,14033583,14032797,14033413,14032657],"length":1,"stats":{"Line":0}},{"line":436,"address":[12069920],"length":1,"stats":{"Line":0}},{"line":437,"address":[19796768,19779263,19796783],"length":1,"stats":{"Line":0}},{"line":441,"address":[117053310,117052798],"length":1,"stats":{"Line":0}},{"line":442,"address":[119657605,119657093],"length":1,"stats":{"Line":0}},{"line":443,"address":[116500944,116500432],"length":1,"stats":{"Line":0}},{"line":445,"address":[117114149,117113637],"length":1,"stats":{"Line":0}},{"line":446,"address":[19992739,19992816],"length":1,"stats":{"Line":0}},{"line":447,"address":[116469809,116469297],"length":1,"stats":{"Line":0}},{"line":448,"address":[19898173,19898063],"length":1,"stats":{"Line":0}},{"line":449,"address":[19896549],"length":1,"stats":{"Line":0}},{"line":451,"address":[116469896,116470232],"length":1,"stats":{"Line":0}},{"line":452,"address":[19787174,19787265],"length":1,"stats":{"Line":0}},{"line":453,"address":[117053913,117053577],"length":1,"stats":{"Line":0}},{"line":454,"address":[116395352,116395312,116395688,116395648],"length":1,"stats":{"Line":0}},{"line":455,"address":[116470362,116470026],"length":1,"stats":{"Line":0}},{"line":456,"address":[14034995,14035105],"length":1,"stats":{"Line":0}},{"line":457,"address":[19787609],"length":1,"stats":{"Line":0}},{"line":462,"address":[19862726,19862633],"length":1,"stats":{"Line":0}},{"line":463,"address":[19788014,19788094],"length":1,"stats":{"Line":0}},{"line":464,"address":[19855910,19871593,19871568,19872384,19871703,19871645,19872238],"length":1,"stats":{"Line":0}},{"line":465,"address":[11629742],"length":1,"stats":{"Line":0}},{"line":466,"address":[20010563,20010648],"length":1,"stats":{"Line":0}},{"line":467,"address":[116505754,116506122,116505794,116506162],"length":1,"stats":{"Line":0}},{"line":474,"address":[119659115,119658747],"length":1,"stats":{"Line":0}},{"line":475,"address":[19899849,19899929],"length":1,"stats":{"Line":0}},{"line":476,"address":[19898289,19914528,19914559,19914626,19914729,19916956,19919822],"length":1,"stats":{"Line":0}},{"line":477,"address":[19914650,19914761,19914624,19914699,19917009],"length":1,"stats":{"Line":0}},{"line":478,"address":[19807572],"length":1,"stats":{"Line":0}},{"line":480,"address":[13042403,13045223,13045096,13042284],"length":1,"stats":{"Line":0}},{"line":482,"address":[19914836,19914234,20028121,20028255,19914335],"length":1,"stats":{"Line":0}},{"line":486,"address":[20011267,20011118,20014045,20013975,20011625],"length":1,"stats":{"Line":0}},{"line":487,"address":[20032687,19915868,19915367,19915266,20032553],"length":1,"stats":{"Line":0}},{"line":500,"address":[19863295,19863394],"length":1,"stats":{"Line":0}},{"line":503,"address":[19895257],"length":1,"stats":{"Line":0}},{"line":504,"address":[19863503,19863410],"length":1,"stats":{"Line":0}},{"line":505,"address":[13027039,13027130],"length":1,"stats":{"Line":0}},{"line":506,"address":[19894908,19894848],"length":1,"stats":{"Line":0}},{"line":507,"address":[19782344,19782281],"length":1,"stats":{"Line":0}},{"line":508,"address":[19900709,19900772],"length":1,"stats":{"Line":0}},{"line":513,"address":[19895430],"length":1,"stats":{"Line":0}},{"line":542,"address":[19858571,19858484],"length":1,"stats":{"Line":0}},{"line":543,"address":[19817184,19797755,19819491,19817087,19817417,19817056,19819480],"length":1,"stats":{"Line":0}},{"line":544,"address":[116506681],"length":1,"stats":{"Line":0}},{"line":545,"address":[20129615,20129481,20017700,20017199,20017098],"length":1,"stats":{"Line":0}},{"line":551,"address":[19865601],"length":1,"stats":{"Line":0}},{"line":552,"address":[116502985],"length":1,"stats":{"Line":0}},{"line":553,"address":[19880727,19880485,19880593,19880538],"length":1,"stats":{"Line":0}},{"line":558,"address":[19902522,19902609],"length":1,"stats":{"Line":0}},{"line":559,"address":[19997417,19997494],"length":1,"stats":{"Line":0}},{"line":560,"address":[19924687,19930228,19924857,19924656,19902726,19924754,19927194],"length":1,"stats":{"Line":0}},{"line":561,"address":[19919243,19921663,19919194,19919168,19919305],"length":1,"stats":{"Line":0}},{"line":562,"address":[20022450],"length":1,"stats":{"Line":0}},{"line":563,"address":[116503141],"length":1,"stats":{"Line":0}},{"line":564,"address":[11423797],"length":1,"stats":{"Line":0}},{"line":565,"address":[76123855],"length":1,"stats":{"Line":0}},{"line":567,"address":[117160086],"length":1,"stats":{"Line":0}},{"line":571,"address":[116679259],"length":1,"stats":{"Line":0}},{"line":572,"address":[11491630],"length":1,"stats":{"Line":0}},{"line":573,"address":[20030105,20030239,19919810,19919911,19920412],"length":1,"stats":{"Line":0}},{"line":574,"address":[117055666],"length":1,"stats":{"Line":0}},{"line":587,"address":[19901222],"length":1,"stats":{"Line":0}},{"line":588,"address":[19895765,19893615,19895776,19893885,19866142,19893584,19893707],"length":1,"stats":{"Line":0}},{"line":589,"address":[11530257],"length":1,"stats":{"Line":0}},{"line":590,"address":[19925975,20030735,19925373,20030601,19925474],"length":1,"stats":{"Line":0}},{"line":595,"address":[19798488],"length":1,"stats":{"Line":0}},{"line":599,"address":[19927056,19927064,19927072,19927165,19927086],"length":1,"stats":{"Line":0}},{"line":602,"address":[20027481],"length":1,"stats":{"Line":0}},{"line":608,"address":[19932832,19933418,19932863,19933120,19933973,19933247,19932784,19932802],"length":1,"stats":{"Line":0}},{"line":611,"address":[19828922,19828777,19828622,19828548],"length":1,"stats":{"Line":0}},{"line":612,"address":[11606792],"length":1,"stats":{"Line":0}},{"line":613,"address":[19816053,19815974],"length":1,"stats":{"Line":0}},{"line":614,"address":[19816125],"length":1,"stats":{"Line":0}},{"line":620,"address":[14071929],"length":1,"stats":{"Line":0}},{"line":621,"address":[19831438],"length":1,"stats":{"Line":0}},{"line":622,"address":[19899236],"length":1,"stats":{"Line":0}},{"line":623,"address":[19817754],"length":1,"stats":{"Line":0}},{"line":624,"address":[19824576],"length":1,"stats":{"Line":0}},{"line":625,"address":[19831590],"length":1,"stats":{"Line":0}},{"line":626,"address":[13061540],"length":1,"stats":{"Line":0}},{"line":628,"address":[11400529],"length":1,"stats":{"Line":0}},{"line":630,"address":[19898322,19898243],"length":1,"stats":{"Line":0}},{"line":631,"address":[19898385,19898494],"length":1,"stats":{"Line":0}},{"line":632,"address":[20030155,20030062],"length":1,"stats":{"Line":0}},{"line":633,"address":[19935463,19935379],"length":1,"stats":{"Line":0}},{"line":634,"address":[19933907,19933823],"length":1,"stats":{"Line":0}},{"line":635,"address":[19824059],"length":1,"stats":{"Line":0}},{"line":636,"address":[19817350],"length":1,"stats":{"Line":0}},{"line":643,"address":[11393770],"length":1,"stats":{"Line":0}},{"line":644,"address":[19892979,19893052],"length":1,"stats":{"Line":0}},{"line":646,"address":[19832378,19832291,19828706],"length":1,"stats":{"Line":0}},{"line":647,"address":[13062578,13062630],"length":1,"stats":{"Line":0}},{"line":650,"address":[19827476,19825936,19826826,19831470,19842668,19826768,19826952],"length":1,"stats":{"Line":0}},{"line":651,"address":[14074411,14075028,14074502,14074787],"length":1,"stats":{"Line":0}},{"line":652,"address":[19827818],"length":1,"stats":{"Line":0}},{"line":653,"address":[14172697,14172831,14075360,14075530,14076046],"length":1,"stats":{"Line":0}},{"line":654,"address":[11534115],"length":1,"stats":{"Line":0}},{"line":656,"address":[19947615],"length":1,"stats":{"Line":0}},{"line":657,"address":[14084362],"length":1,"stats":{"Line":0}},{"line":658,"address":[11645645],"length":1,"stats":{"Line":0}},{"line":660,"address":[19942491,19942570],"length":1,"stats":{"Line":0}},{"line":661,"address":[19836768,19836689],"length":1,"stats":{"Line":0}},{"line":665,"address":[19302359],"length":1,"stats":{"Line":0}},{"line":666,"address":[20043610,20043531],"length":1,"stats":{"Line":0}},{"line":669,"address":[20043705,20043656],"length":1,"stats":{"Line":0}},{"line":672,"address":[11527409],"length":1,"stats":{"Line":0}},{"line":673,"address":[20044162],"length":1,"stats":{"Line":0}},{"line":674,"address":[19831192],"length":1,"stats":{"Line":0}},{"line":675,"address":[14085577],"length":1,"stats":{"Line":0}},{"line":676,"address":[10899379],"length":1,"stats":{"Line":0}},{"line":677,"address":[13068629,13068689],"length":1,"stats":{"Line":0}},{"line":683,"address":[20035511,20037480,20037408,20037618,20035472,20037546,20037020,20036992],"length":1,"stats":{"Line":0}},{"line":685,"address":[20133870],"length":1,"stats":{"Line":0}},{"line":686,"address":[19934587],"length":1,"stats":{"Line":0}},{"line":687,"address":[19995478],"length":1,"stats":{"Line":0}},{"line":688,"address":[19934709],"length":1,"stats":{"Line":0}},{"line":689,"address":[13342398],"length":1,"stats":{"Line":0}},{"line":691,"address":[19934944,19934977,19935744,19935809],"length":1,"stats":{"Line":0}},{"line":693,"address":[20040302],"length":1,"stats":{"Line":0}},{"line":694,"address":[19928817],"length":1,"stats":{"Line":0}},{"line":697,"address":[13069384],"length":1,"stats":{"Line":0}},{"line":698,"address":[19943733],"length":1,"stats":{"Line":0}},{"line":699,"address":[20038896],"length":1,"stats":{"Line":0}},{"line":700,"address":[19825479],"length":1,"stats":{"Line":0}},{"line":701,"address":[19942197],"length":1,"stats":{"Line":0}},{"line":702,"address":[19907152],"length":1,"stats":{"Line":0}},{"line":703,"address":[19900299],"length":1,"stats":{"Line":0}},{"line":704,"address":[19900374],"length":1,"stats":{"Line":0}},{"line":707,"address":[20039176],"length":1,"stats":{"Line":0}},{"line":708,"address":[19839994,19936127,19840095,19935993,19840596],"length":1,"stats":{"Line":0}},{"line":711,"address":[19902487,19902875],"length":1,"stats":{"Line":0}},{"line":712,"address":[19841819,19841742],"length":1,"stats":{"Line":0}},{"line":713,"address":[19902667],"length":1,"stats":{"Line":0}},{"line":714,"address":[19910704,19910735,19910834,19913337,19913266,19902735,19911057],"length":1,"stats":{"Line":0}},{"line":715,"address":[19953429,19955323],"length":1,"stats":{"Line":0}},{"line":716,"address":[11654104],"length":1,"stats":{"Line":0}},{"line":718,"address":[19844229,19843728,19929513,19843627,19929647],"length":1,"stats":{"Line":0}},{"line":727,"address":[19827949,19828646,19828288],"length":1,"stats":{"Line":0}},{"line":728,"address":[19828422,19828345],"length":1,"stats":{"Line":0}},{"line":729,"address":[19842198],"length":1,"stats":{"Line":0}},{"line":730,"address":[19838994,19838864,19839217,19828506,19841426,19841497,19838895],"length":1,"stats":{"Line":0}},{"line":731,"address":[11096788],"length":1,"stats":{"Line":0}},{"line":733,"address":[20053269,20136297,20136431,20052667,20052768],"length":1,"stats":{"Line":0}},{"line":749,"address":[11534245],"length":1,"stats":{"Line":0}},{"line":750,"address":[14086532,14086453],"length":1,"stats":{"Line":0}},{"line":752,"address":[19302463],"length":1,"stats":{"Line":0}},{"line":753,"address":[19846522,19846601],"length":1,"stats":{"Line":0}},{"line":754,"address":[14178159,14087171,14087707,14178025],"length":1,"stats":{"Line":0}},{"line":756,"address":[20034159],"length":1,"stats":{"Line":0}},{"line":757,"address":[19933841,20036921,19936093,20037055,19935577],"length":1,"stats":{"Line":0}},{"line":759,"address":[19820366,19834515,19823345,19824570],"length":1,"stats":{"Line":0}},{"line":760,"address":[14089149,14089076],"length":1,"stats":{"Line":0}},{"line":762,"address":[19848763,19834147,19848676],"length":1,"stats":{"Line":0}},{"line":763,"address":[19849115,19849188],"length":1,"stats":{"Line":0}},{"line":768,"address":[19833213],"length":1,"stats":{"Line":0}},{"line":772,"address":[19916240,19916698,19916505,19916271,19916208,19916408,19917231,19916216],"length":1,"stats":{"Line":0}},{"line":773,"address":[11515919],"length":1,"stats":{"Line":0}},{"line":774,"address":[11515938],"length":1,"stats":{"Line":0}},{"line":775,"address":[19917890,19917760],"length":1,"stats":{"Line":0}},{"line":777,"address":[19956287,19956175,19958486,19958548],"length":1,"stats":{"Line":0}},{"line":778,"address":[14097976,14096192,14098284,14100172,14100312],"length":1,"stats":{"Line":0}},{"line":779,"address":[20041353,19960665,19960766,19961267,20041487],"length":1,"stats":{"Line":0}},{"line":782,"address":[13088593],"length":1,"stats":{"Line":0}},{"line":786,"address":[19962951,19962841,19963009,19963738,19962786,19962768,19963156,19962816],"length":1,"stats":{"Line":0}},{"line":789,"address":[14100722,14100852,14100642,14100592],"length":1,"stats":{"Line":0}},{"line":790,"address":[19853643,19853570],"length":1,"stats":{"Line":0}},{"line":792,"address":[12124898],"length":1,"stats":{"Line":0}},{"line":793,"address":[19854190,19854117],"length":1,"stats":{"Line":0}},{"line":794,"address":[13090014],"length":1,"stats":{"Line":0}},{"line":798,"address":[19964640,19964176,19965959,19965991],"length":1,"stats":{"Line":0}},{"line":799,"address":[19964298,19965453,19965740,19964642,20041849,20041983,19964206,19964848],"length":1,"stats":{"Line":0}},{"line":804,"address":[19858799,19856317,19856144,19858728,19856068,19854900,19856175,19856239],"length":1,"stats":{"Line":0}},{"line":805,"address":[19924045],"length":1,"stats":{"Line":0}},{"line":806,"address":[20062621,20062571,20062904,20062543],"length":1,"stats":{"Line":0}},{"line":807,"address":[19966974,19966873,19967475,20042479,20042345],"length":1,"stats":{"Line":0}},{"line":813,"address":[19856273,19858688,19856367,19858737],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":351},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","fixtures","mod.rs"],"content":"use serde_json::json;\n\npub fn create_test_user(npub: &str) -> serde_json::Value {\n    json!({\n        \"npub\": npub,\n        \"pubkey\": format!(\"pubkey_{}\", npub),\n        \"name\": format!(\"Test User {}\", npub),\n        \"display_name\": format!(\"Test {}\", npub),\n        \"about\": \"Test user for unit tests\",\n        \"picture\": \"https://example.com/avatar.jpg\",\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890\n    })\n}\n\npub fn create_test_post(id: &str, author_npub: &str, topic_id: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"content\": format!(\"Test post content {}\", id),\n        \"author\": create_test_user(author_npub),\n        \"topic_id\": topic_id,\n        \"created_at\": 1234567890,\n        \"tags\": [\"test\", \"fixture\"],\n        \"likes\": 0,\n        \"boosts\": 0,\n        \"replies\": [],\n        \"is_synced\": false,\n        \"is_boosted\": false,\n        \"is_bookmarked\": false,\n        \"local_id\": id,\n        \"event_id\": null\n    })\n}\n\npub fn create_test_topic(id: &str, name: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"name\": name,\n        \"description\": format!(\"Test topic {}\", name),\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890,\n        \"is_joined\": false,\n        \"member_count\": 0,\n        \"post_count\": 0,\n        \"visibility\": \"public\",\n        \"owner\": null\n    })\n}\n\npub fn create_test_event(id: &str, kind: u32, content: &str, pubkey: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"pubkey\": pubkey,\n        \"created_at\": 1234567890,\n        \"kind\": kind,\n        \"tags\": [],\n        \"content\": content,\n        \"sig\": format!(\"signature_{}\", id)\n    })\n}\n\npub fn create_test_keypair() -> (String, String, String, String) {\n    let id = uuid::Uuid::new_v4().to_string();\n    let npub = format!(\"npub1{}\", &id[..59]);\n    let nsec = format!(\"nsec1{}\", &id[..59]);\n    let pubkey = format!(\"pubkey_{}\", id);\n    let privkey = format!(\"privkey_{}\", id);\n    \n    (npub, nsec, pubkey, privkey)\n}\n\npub fn create_test_database_url() -> String {\n    \":memory:\".to_string()\n}\n\npub fn create_test_config() -> serde_json::Value {\n    json!({\n        \"database\": {\n            \"url\": \":memory:\",\n            \"max_connections\": 5,\n            \"connection_timeout\": 30\n        },\n        \"network\": {\n            \"bootstrap_peers\": [],\n            \"max_peers\": 50,\n            \"connection_timeout\": 30,\n            \"retry_interval\": 60\n        },\n        \"sync\": {\n            \"auto_sync\": true,\n            \"sync_interval\": 300,\n            \"max_retry\": 3,\n            \"batch_size\": 100\n        },\n        \"storage\": {\n            \"data_dir\": \"./test_data\",\n            \"cache_size\": 100000000,\n            \"cache_ttl\": 3600\n        }\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_gateway.rs"],"content":"﻿use async_trait::async_trait;\nuse mockall::mock;\n\nuse kukuri_lib::application::ports::event_gateway::EventGateway;\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\nuse kukuri_lib::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\nuse kukuri_lib::domain::value_objects::{EventId, TopicId};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventGatewayPort {}\n\n    #[async_trait]\n    impl EventGateway for EventGatewayPort {\n        async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\n        async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n        async fn publish_topic_post(\n            &self,\n            topic_id: &TopicId,\n            content: &TopicContent,\n            reply_to: Option<&EventId>,\n            scope: Option<&str>,\n            epoch: Option<i64>,\n        ) -> Result<EventId, AppError>;\n        async fn send_reaction(\n            &self,\n            target: &EventId,\n            reaction: &ReactionValue,\n        ) -> Result<EventId, AppError>;\n        async fn update_profile_metadata(\n            &self,\n            metadata: &ProfileMetadata,\n        ) -> Result<EventId, AppError>;\n        async fn delete_events(\n            &self,\n            targets: &[EventId],\n            reason: Option<&str>,\n        ) -> Result<EventId, AppError>;\n        async fn disconnect(&self) -> Result<(), AppError>;\n        async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\n        async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\n        async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\n    }\n}\n\npub type MockEventGateway = MockEventGatewayPort;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_service.rs"],"content":"use async_trait::async_trait;\nuse mockall::mock;\nuse nostr_sdk::prelude::Timestamp;\n\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse kukuri_lib::domain::entities::Event;\nuse kukuri_lib::infrastructure::crypto::SignatureService;\nuse kukuri_lib::infrastructure::database::EventRepository;\nuse kukuri_lib::infrastructure::p2p::{event_distributor::DistributionStrategy, EventDistributor};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventRepo {}\n\n    #[async_trait]\n    impl EventRepository for EventRepo {\n        async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n        async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n        async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn get_events_by_author(&self, pubkey: &str, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n        async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n        async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n        async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError>;\n        async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError>;\n    }\n}\n\nmock! {\n    pub SignatureServ {}\n\n    #[async_trait]\n    impl SignatureService for SignatureServ {\n        async fn sign_event(&self, event: &mut Event, private_key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_event(&self, event: &Event) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n        async fn sign_message(&self, message: &str, private_key: &str) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_message(&self, message: &str, signature: &str, public_key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub EventDist {}\n\n    #[async_trait]\n    impl EventDistributor for EventDist {\n        async fn distribute(&self, event: &Event, strategy: DistributionStrategy) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn set_strategy(&self, strategy: DistributionStrategy);\n        async fn get_pending_events(&self) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub SubscriptionStateMock {}\n\n    #[async_trait]\n    impl SubscriptionStateStore for SubscriptionStateMock {\n        async fn record_request(&self, target: SubscriptionTarget) -> Result<SubscriptionRecord, AppError>;\n        async fn mark_subscribed(&self, target: &SubscriptionTarget, synced_at: i64) -> Result<(), AppError>;\n        async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n        async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n        async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n        async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n    }\n}\n\nmock! {\n    pub SubscriptionInvokerMock {}\n\n    #[async_trait]\n    impl SubscriptionInvoker for SubscriptionInvokerMock {\n        async fn subscribe_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n        async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_crypto.rs"],"content":"use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockKeyManager {\n    keypairs: Arc<RwLock<HashMap<String, MockKeyPair>>>,\n}\n\n#[derive(Debug, Clone)]\npub struct MockKeyPair {\n    pub npub: String,\n    pub nsec: String,\n    pub public_key: String,\n    pub private_key: String,\n}\n\nimpl MockKeyManager {\n    pub fn new() -> Self {\n        Self {\n            keypairs: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn generate_keypair(&self) -> MockKeyPair {\n        let id = uuid::Uuid::new_v4().to_string();\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", &id[..59]),\n            nsec: format!(\"nsec1{}\", &id[..59]),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        keypair\n    }\n\n    pub async fn import_private_key(&self, nsec: &str) -> Result<MockKeyPair, String> {\n        if !nsec.starts_with(\"nsec1\") {\n            return Err(\"Invalid nsec format\".to_string());\n        }\n        \n        let id = &nsec[5..];\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", id),\n            nsec: nsec.to_string(),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        Ok(keypair)\n    }\n\n    pub async fn get_keypair(&self, npub: &str) -> Option<MockKeyPair> {\n        self.keypairs.read().await.get(npub).cloned()\n    }\n\n    pub async fn list_npubs(&self) -> Vec<String> {\n        self.keypairs.read().await.keys().cloned().collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSignatureService;\n\nimpl MockSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn sign_event(&self, event_id: &str, _private_key: &str) -> String {\n        format!(\"signature_for_{}\", event_id)\n    }\n\n    pub async fn verify_event(&self, _event_id: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n\n    pub async fn sign_message(&self, message: &str, _private_key: &str) -> String {\n        format!(\"sig_{}\", &message[..message.len().min(10)])\n    }\n\n    pub async fn verify_message(&self, _message: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEncryptionService;\n\nimpl MockEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn encrypt(&self, data: &[u8], _recipient_pubkey: &str) -> Vec<u8> {\n        // Simple mock: just reverse the bytes\n        data.iter().rev().cloned().collect()\n    }\n\n    pub async fn decrypt(&self, encrypted_data: &[u8], _sender_pubkey: &str) -> Vec<u8> {\n        // Simple mock: reverse back\n        encrypted_data.iter().rev().cloned().collect()\n    }\n\n    pub async fn encrypt_symmetric(&self, data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR with password hash\n        let key = password.bytes().cycle();\n        data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n\n    pub async fn decrypt_symmetric(&self, encrypted_data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR back with password hash\n        let key = password.bytes().cycle();\n        encrypted_data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSecureStorage {\n    storage: Arc<RwLock<HashMap<String, String>>>,\n}\n\nimpl MockSecureStorage {\n    pub fn new() -> Self {\n        Self {\n            storage: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn store(&self, key: &str, value: &str) -> Result<(), String> {\n        self.storage.write().await.insert(key.to_string(), value.to_string());\n        Ok(())\n    }\n\n    pub async fn retrieve(&self, key: &str) -> Result<Option<String>, String> {\n        Ok(self.storage.read().await.get(key).cloned())\n    }\n\n    pub async fn delete(&self, key: &str) -> Result<(), String> {\n        self.storage.write().await.remove(key);\n        Ok(())\n    }\n\n    pub async fn exists(&self, key: &str) -> bool {\n        self.storage.read().await.contains_key(key)\n    }\n\n    pub async fn list_keys(&self) -> Vec<String> {\n        self.storage.read().await.keys().cloned().collect()\n    }\n\n    pub async fn clear(&self) -> Result<(), String> {\n        self.storage.write().await.clear();\n        Ok(())\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_network.rs"],"content":"use async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockNetworkService {\n    is_connected: Arc<RwLock<bool>>,\n    peers: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockNetworkService {\n    pub fn new() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(false)),\n            peers: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn connected() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(true)),\n            peers: Arc::new(RwLock::new(vec![\"peer1\".to_string(), \"peer2\".to_string()])),\n        }\n    }\n\n    pub async fn set_connected(&self, connected: bool) {\n        *self.is_connected.write().await = connected;\n    }\n\n    pub async fn add_peer(&self, peer: String) {\n        self.peers.write().await.push(peer);\n    }\n\n    pub async fn is_connected(&self) -> bool {\n        *self.is_connected.read().await\n    }\n\n    pub async fn get_peers(&self) -> Vec<String> {\n        self.peers.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockGossipService {\n    topics: Arc<RwLock<Vec<String>>>,\n    messages: Arc<RwLock<Vec<(String, String)>>>, // (topic, message)\n}\n\nimpl MockGossipService {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(Vec::new())),\n            messages: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn join_topic(&self, topic: String) {\n        self.topics.write().await.push(topic);\n    }\n\n    pub async fn leave_topic(&self, topic: &str) {\n        self.topics.write().await.retain(|t| t != topic);\n    }\n\n    pub async fn broadcast(&self, topic: String, message: String) {\n        self.messages.write().await.push((topic, message));\n    }\n\n    pub async fn get_joined_topics(&self) -> Vec<String> {\n        self.topics.read().await.clone()\n    }\n\n    pub async fn get_messages(&self) -> Vec<(String, String)> {\n        self.messages.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEventDistributor {\n    distributed_events: Arc<RwLock<Vec<String>>>,\n    pending_events: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn with_pending(events: Vec<String>) -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(events)),\n        }\n    }\n\n    pub async fn distribute(&self, event_id: String) {\n        self.distributed_events.write().await.push(event_id.clone());\n        self.pending_events.write().await.retain(|e| e != &event_id);\n    }\n\n    pub async fn get_distributed_events(&self) -> Vec<String> {\n        self.distributed_events.read().await.clone()\n    }\n\n    pub async fn get_pending_events(&self) -> Vec<String> {\n        self.pending_events.read().await.clone()\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_repository.rs"],"content":"use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n// Note: These types would need to be imported from the actual application\n// For now, we'll use placeholder types\ntype Post = serde_json::Value;\ntype Topic = serde_json::Value;\ntype User = serde_json::Value;\ntype Event = serde_json::Value;\n\npub struct MockPostRepository {\n    posts: Arc<RwLock<HashMap<String, Post>>>,\n}\n\nimpl MockPostRepository {\n    pub fn new() -> Self {\n        Self {\n            posts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_posts(posts: Vec<Post>) -> Self {\n        let mut map = HashMap::new();\n        for post in posts {\n            if let Some(id) = post.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), post);\n            }\n        }\n        Self {\n            posts: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockTopicRepository {\n    topics: Arc<RwLock<HashMap<String, Topic>>>,\n}\n\nimpl MockTopicRepository {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_topics(topics: Vec<Topic>) -> Self {\n        let mut map = HashMap::new();\n        for topic in topics {\n            if let Some(id) = topic.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), topic);\n            }\n        }\n        Self {\n            topics: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockUserRepository {\n    users: Arc<RwLock<HashMap<String, User>>>,\n}\n\nimpl MockUserRepository {\n    pub fn new() -> Self {\n        Self {\n            users: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_users(users: Vec<User>) -> Self {\n        let mut map = HashMap::new();\n        for user in users {\n            if let Some(npub) = user.get(\"npub\").and_then(|v| v.as_str()) {\n                map.insert(npub.to_string(), user);\n            }\n        }\n        Self {\n            users: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockEventRepository {\n    events: Arc<RwLock<HashMap<String, Event>>>,\n}\n\nimpl MockEventRepository {\n    pub fn new() -> Self {\n        Self {\n            events: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_events(events: Vec<Event>) -> Self {\n        let mut map = HashMap::new();\n        for event in events {\n            if let Some(id) = event.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), event);\n            }\n        }\n        Self {\n            events: Arc::new(RwLock::new(map)),\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mod.rs"],"content":"pub mod event_gateway;\npub mod event_service;\npub mod mock_repository;\npub mod mock_network;\npub mod mock_crypto;\n\npub use event_gateway::*;\npub use event_service::*;\npub use mock_repository::*;\npub use mock_network::*;\npub use mock_crypto::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mod.rs"],"content":"pub mod mocks;\npub mod fixtures;\npub mod performance;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","offline_support.rs"],"content":"use std::sync::Arc;\r\n\r\nuse chrono::Utc;\r\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\r\nuse kukuri_lib::test_support::application::services::offline_service::{\r\n    OfflineService, SaveOfflineActionParams,\r\n};\r\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\r\nuse kukuri_lib::test_support::domain::value_objects::offline::{\r\n    EntityId, EntityType, OfflineActionType, OfflinePayload,\r\n};\r\nuse kukuri_lib::test_support::infrastructure::offline::SqliteOfflinePersistence;\r\nuse serde_json::json;\r\nuse sqlx::{Executor, Pool, Sqlite, sqlite::SqlitePoolOptions};\r\n\r\npub const TEST_PUBKEY_HEX: &str =\r\n    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\r\n\r\npub struct OfflineTestContext {\r\n    pub service: OfflineService,\r\n    pub pool: Pool<Sqlite>,\r\n}\r\n\r\npub async fn setup_offline_service() -> OfflineTestContext {\r\n    let pool = SqlitePoolOptions::new()\r\n        .max_connections(1)\r\n        .connect(\"sqlite::memory:?cache=shared\")\r\n        .await\r\n        .expect(\"in-memory sqlite\");\r\n\r\n    initialize_schema(&pool).await;\r\n\r\n    let persistence: Arc<dyn OfflinePersistence> =\r\n        Arc::new(SqliteOfflinePersistence::new(pool.clone()));\r\n\r\n    OfflineTestContext {\r\n        service: OfflineService::new(persistence),\r\n        pool,\r\n    }\r\n}\r\n\r\n#[allow(dead_code)]\npub fn sample_save_params() -> SaveOfflineActionParams {\n    SaveOfflineActionParams {\r\n        user_pubkey: PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"),\r\n        action_type: OfflineActionType::new(\"create_post\".into()).expect(\"action type\"),\r\n        entity_type: EntityType::new(\"post\".into()).expect(\"entity type\"),\r\n        entity_id: EntityId::new(\"post123\".into()).expect(\"entity id\"),\r\n        payload: OfflinePayload::from_json_str(r#\"{\"content\":\"Hello\"}\"#).expect(\"payload\"),\r\n    }\r\n}\r\n\r\npub fn build_params_for_index(index: usize) -> SaveOfflineActionParams {\r\n    let payload = json!({\r\n        \"content\": format!(\"Post {index}\"),\r\n        \"topicId\": format!(\"topic-{}\", index % 8),\r\n        \"created_at\": Utc::now().timestamp()\r\n    });\r\n\r\n    SaveOfflineActionParams {\r\n        user_pubkey: PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"),\r\n        action_type: OfflineActionType::new(\"create_post\".into()).expect(\"action type\"),\r\n        entity_type: EntityType::new(\"post\".into()).expect(\"entity type\"),\r\n        entity_id: EntityId::new(format!(\"post_{index:04}\").into()).expect(\"entity id\"),\r\n        payload: OfflinePayload::from_json_str(&payload.to_string()).expect(\"payload\"),\r\n    }\r\n}\r\n\r\nasync fn initialize_schema(pool: &Pool<Sqlite>) {\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS offline_actions (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            user_pubkey TEXT NOT NULL,\r\n            action_type TEXT NOT NULL,\r\n            target_id TEXT,\r\n            action_data TEXT NOT NULL,\r\n            local_id TEXT NOT NULL,\r\n            remote_id TEXT,\r\n            is_synced INTEGER DEFAULT 0,\r\n            created_at INTEGER NOT NULL,\r\n            synced_at INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"offline_actions table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS sync_queue (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            action_type TEXT NOT NULL,\r\n            payload TEXT NOT NULL,\r\n            status TEXT NOT NULL,\r\n            retry_count INTEGER DEFAULT 0,\r\n            max_retries INTEGER DEFAULT 3,\r\n            created_at INTEGER NOT NULL,\r\n            updated_at INTEGER NOT NULL,\r\n            synced_at INTEGER,\r\n            error_message TEXT\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"sync_queue table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS cache_metadata (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            cache_key TEXT NOT NULL UNIQUE,\r\n            cache_type TEXT NOT NULL,\r\n            last_synced_at INTEGER,\r\n            last_accessed_at INTEGER,\r\n            data_version INTEGER DEFAULT 1,\r\n            is_stale INTEGER DEFAULT 0,\r\n            expiry_time INTEGER,\r\n            metadata TEXT,\r\n            doc_version INTEGER,\r\n            blob_hash TEXT,\r\n            payload_bytes INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE INDEX IF NOT EXISTS idx_cache_metadata_doc_version ON cache_metadata(doc_version);\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata doc_version index\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE INDEX IF NOT EXISTS idx_cache_metadata_blob_hash ON cache_metadata(blob_hash);\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"cache_metadata blob_hash index\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS optimistic_updates (\r\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            update_id TEXT NOT NULL UNIQUE,\r\n            entity_type TEXT NOT NULL,\r\n            entity_id TEXT NOT NULL,\r\n            original_data TEXT,\r\n            updated_data TEXT NOT NULL,\r\n            is_confirmed INTEGER DEFAULT 0,\r\n            created_at INTEGER NOT NULL,\r\n            confirmed_at INTEGER\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"optimistic_updates table\");\r\n\r\n    pool.execute(\r\n        r#\"\r\n        CREATE TABLE IF NOT EXISTS sync_status (\r\n            entity_type TEXT NOT NULL,\r\n            entity_id TEXT NOT NULL,\r\n            local_version INTEGER NOT NULL,\r\n            last_local_update INTEGER NOT NULL,\r\n            sync_status TEXT NOT NULL,\r\n            conflict_data TEXT,\r\n            PRIMARY KEY (entity_type, entity_id)\r\n        )\r\n        \"#,\r\n    )\r\n    .await\r\n    .expect(\"sync_status table\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","mod.rs"],"content":"pub mod offline_seed;\n#[path = \"../offline_support.rs\"]\npub mod offline_support;\npub mod recorder;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","offline_seed.rs"],"content":"use anyhow::{Result, anyhow};\r\nuse chrono::{Duration, Utc};\r\nuse kukuri_lib::test_support::application::services::offline_service::{\r\n    OfflineService, OfflineServiceTrait,\r\n};\r\nuse kukuri_lib::test_support::domain::entities::offline::CacheMetadataUpdate;\r\nuse kukuri_lib::test_support::domain::value_objects::offline::{CacheKey, CacheType};\r\nuse serde_json::json;\r\n\r\nuse super::offline_support::build_params_for_index;\r\n\r\npub async fn seed_offline_actions(service: &OfflineService, count: usize) -> Result<()> {\r\n    for i in 0..count {\r\n        service\r\n            .save_action(build_params_for_index(i))\r\n            .await\r\n            .map_err(|err| anyhow!(\"{err}\"))?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub async fn seed_cache_metadata(service: &OfflineService, count: usize) -> Result<()> {\r\n    for i in 0..count {\r\n        let update = CacheMetadataUpdate {\r\n            cache_key: CacheKey::new(format!(\"cache:test:{i}\").into()).expect(\"cache key\"),\r\n            cache_type: CacheType::new(\"posts\".into()).expect(\"cache type\"),\r\n            metadata: Some(json!({ \"version\": i })),\r\n            expiry: Some(Utc::now() + Duration::seconds((i as i64 % 3) + 1)),\r\n            is_stale: Some(false),\r\n            doc_version: None,\r\n            blob_hash: None,\r\n            payload_bytes: None,\r\n        };\r\n        service\r\n            .upsert_cache_metadata(update)\r\n            .await\r\n            .map_err(|err| anyhow!(\"{err}\"))?;\r\n    }\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","performance","recorder.rs"],"content":"use std::{\n    collections::BTreeMap,\n    env,\n    fs::{self, File},\n    path::PathBuf,\n};\n\nuse anyhow::{Context, Result};\nuse chrono::{Timelike, Utc};\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct PerformanceReport<'a> {\n    scenario: &'a str,\n    timestamp: String,\n    iterations: u64,\n    metrics: &'a BTreeMap<String, f64>,\n    notes: &'a BTreeMap<String, String>,\n}\n\n#[derive(Default)]\npub struct PerformanceRecorder {\n    scenario: String,\n    iterations: u64,\n    metrics: BTreeMap<String, f64>,\n    notes: BTreeMap<String, String>,\n}\n\nimpl PerformanceRecorder {\n    pub fn new<S: Into<String>>(scenario: S) -> Self {\n        Self {\n            scenario: scenario.into(),\n            iterations: 0,\n            metrics: BTreeMap::new(),\n            notes: BTreeMap::new(),\n        }\n    }\n\n    pub fn iterations(mut self, value: u64) -> Self {\n        self.iterations = value;\n        self\n    }\n\n    pub fn metric(mut self, key: &str, value: f64) -> Self {\n        self.metrics.insert(key.to_string(), value);\n        self\n    }\n\n    pub fn note(mut self, key: &str, value: impl Into<String>) -> Self {\n        self.notes.insert(key.to_string(), value.into());\n        self\n    }\n\n    pub fn write(self) -> Result<PathBuf> {\n        let output_dir = resolve_output_dir();\n        fs::create_dir_all(&output_dir).context(\"create performance output directory\")?;\n\n        let timestamp = Utc::now();\n        let filename = format!(\n            \"{}-{}.json\",\n            timestamp.format(\"%Y%m%d%H%M%S\"),\n            sanitize_filename(&self.scenario)\n        );\n        let path = output_dir.join(filename);\n\n        let report = PerformanceReport {\n            scenario: &self.scenario,\n            timestamp: timestamp\n                .with_nanosecond(0)\n                .unwrap_or(timestamp)\n                .to_rfc3339(),\n            iterations: self.iterations,\n            metrics: &self.metrics,\n            notes: &self.notes,\n        };\n\n        let file = File::create(&path).context(\"create performance report file\")?;\n        serde_json::to_writer_pretty(file, &report).context(\"write performance report\")?;\n        Ok(path)\n    }\n}\n\nfn resolve_output_dir() -> PathBuf {\n    env::var(\"KUKURI_PERFORMANCE_OUTPUT\")\n        .map(PathBuf::from)\n        .unwrap_or_else(|_| PathBuf::from(\"test-results/performance\"))\n}\n\nfn sanitize_filename(source: &str) -> String {\n    let mut sanitized: String = source\n        .chars()\n        .map(|c| match c {\n            'a'..='z' | '0'..='9' => c,\n            'A'..='Z' => c.to_ascii_lowercase(),\n            '_' | '-' => c,\n            _ if c.is_whitespace() => '_',\n            _ => '-',\n        })\n        .collect();\n\n    if sanitized.is_empty() {\n        sanitized.push_str(\"scenario\");\n    }\n\n    while sanitized.starts_with(['-', '_']) {\n        sanitized.remove(0);\n    }\n\n    if sanitized.is_empty() {\n        sanitized.push_str(\"scenario\");\n    }\n\n    sanitized\n}\n\npub fn duration_secs(duration: std::time::Duration) -> f64 {\n    let secs = duration.as_secs_f64();\n    if secs <= f64::EPSILON {\n        f64::EPSILON\n    } else {\n        secs\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract","direct_messages.rs"],"content":"use chrono::{TimeZone, Utc};\nuse kukuri_lib::test_support::application::ports::repositories::DirectMessageRepository;\nuse kukuri_lib::test_support::domain::entities::{MessageDirection, NewDirectMessage};\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::repository::Repository;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\n\nconst OWNER_NPUB: &str =\n    \"npub1contractowner00000000000000000000000000000000000000000000000000000000\";\nconst FRIEND_NPUB: &str =\n    \"npub1contractfriend0000000000000000000000000000000000000000000000000000000\";\n\n#[tokio::test]\nasync fn direct_message_read_receipts_sync_across_devices() {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"create pool\");\n    let repository = SqliteRepository::new(pool);\n    repository.initialize().await.expect(\"initialize schema\");\n\n    let base_timestamp = 1_700_000_000_000i64;\n    for (index, content) in [\"first\", \"second\", \"third\"].iter().enumerate() {\n        let created_at = Utc\n            .timestamp_millis_opt(base_timestamp + (index as i64 * 1_000))\n            .single()\n            .expect(\"valid timestamp\");\n        let new_message = NewDirectMessage {\n            owner_npub: OWNER_NPUB.to_string(),\n            conversation_npub: FRIEND_NPUB.to_string(),\n            sender_npub: FRIEND_NPUB.to_string(),\n            recipient_npub: OWNER_NPUB.to_string(),\n            event_id: Some(format!(\"evt-{index}\")),\n            client_message_id: Some(format!(\"client-{index}\")),\n            payload_cipher_base64: format!(\"cipher-{content}\"),\n            created_at,\n            delivered: true,\n            direction: MessageDirection::Inbound,\n        };\n        let stored = repository\n            .insert_direct_message(&new_message)\n            .await\n            .expect(\"insert direct message\");\n        repository\n            .upsert_conversation_metadata(\n                OWNER_NPUB,\n                FRIEND_NPUB,\n                stored.id,\n                stored.created_at.timestamp_millis(),\n            )\n            .await\n            .expect(\"upsert metadata\");\n    }\n\n    let initial = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list conversations\");\n    assert_eq!(initial.items.len(), 1);\n    assert_eq!(\n        initial.items[0].unread_count, 3,\n        \"all inbound messages start unread\"\n    );\n    assert_eq!(\n        initial.items[0].last_read_at, 0,\n        \"last_read_at defaults to zero before any device reads\"\n    );\n\n    let second_message_timestamp = base_timestamp + 1_000;\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, second_message_timestamp)\n        .await\n        .expect(\"mark read up to second message\");\n    let after_second = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after read\");\n    assert_eq!(\n        after_second.items[0].last_read_at, second_message_timestamp,\n        \"read receipt should store the latest acknowledged timestamp\"\n    );\n    assert_eq!(\n        after_second.items[0].unread_count, 1,\n        \"only the newest inbound message remains unread\"\n    );\n\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, base_timestamp + 500)\n        .await\n        .expect(\"stale read marker should be ignored\");\n    let after_stale = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after stale mark\");\n    assert_eq!(\n        after_stale.items[0].last_read_at, second_message_timestamp,\n        \"stale timestamps must not overwrite newer read positions\"\n    );\n    assert_eq!(after_stale.items[0].unread_count, 1);\n\n    let final_timestamp = base_timestamp + 2_000;\n    repository\n        .mark_conversation_as_read(OWNER_NPUB, FRIEND_NPUB, final_timestamp)\n        .await\n        .expect(\"mark all messages read\");\n    let final_state = repository\n        .list_direct_message_conversations(OWNER_NPUB, None, 10)\n        .await\n        .expect(\"list after all read\");\n    assert_eq!(final_state.items[0].unread_count, 0);\n    assert_eq!(final_state.items[0].last_read_at, final_timestamp);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract","nip10.rs"],"content":"use kukuri_lib::contract_testing::validate_nip10_tags;\r\nuse serde::Deserialize;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Nip10Case {\n    name: String,\n    #[serde(rename = \"description\")]\n    _description: Option<String>,\n    tags: Vec<Vec<String>>,\n    expected: bool,\n}\n\r\n#[test]\r\nfn nip10_contract_cases_align_with_rust_validation() {\r\n    let data = include_str!(concat!(\r\n        env!(\"CARGO_MANIFEST_DIR\"),\r\n        \"/../testdata/nip10_contract_cases.json\"\r\n    ));\r\n    let cases: Vec<Nip10Case> =\r\n        serde_json::from_str(data).expect(\"nip10 contract cases json should parse\");\r\n\r\n    for case in cases {\r\n        let result = validate_nip10_tags(case.tags.clone());\r\n        if case.expected {\r\n            assert!(\r\n                result.is_ok(),\r\n                \"case '{}' expected success but got error: {:?}\",\r\n                case.name,\r\n                result.err()\r\n            );\r\n        } else {\r\n            assert!(\r\n                result.is_err(),\r\n                \"case '{}' expected failure but succeeded\",\r\n                case.name\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract.rs"],"content":"#[path = \"contract/direct_messages.rs\"]\nmod direct_messages;\n#[path = \"contract/nip10.rs\"]\nmod nip10;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","event_manager_integration.rs"],"content":"#[path = \"integration/event/manager/mod.rs\"]\nmod manager;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","access_control_p2p_invite.rs"],"content":"use async_trait::async_trait;\nuse kukuri_lib::test_support::application::ports::cache::PostCache;\nuse kukuri_lib::test_support::application::ports::group_key_store::{\n    GroupKeyEntry, GroupKeyRecord, GroupKeyStore,\n};\nuse kukuri_lib::test_support::application::ports::join_request_store::{\n    InviteUsageRecord, JoinRequestRecord, JoinRequestStore,\n};\nuse kukuri_lib::test_support::application::ports::key_manager::{KeyManager, KeyPair};\nuse kukuri_lib::test_support::application::ports::repositories::{\n    BookmarkRepository, FollowListSort, PostRepository, UserCursorPage, UserRepository,\n};\nuse kukuri_lib::test_support::application::services::event_service::EventServiceTrait;\nuse kukuri_lib::test_support::application::services::{AccessControlService, JoinRequestInput, PostService};\nuse kukuri_lib::test_support::domain::entities::{Event, Post, User};\nuse kukuri_lib::test_support::domain::p2p::user_topic_id;\nuse kukuri_lib::test_support::domain::value_objects::{EncryptedPostPayload, EventId};\nuse kukuri_lib::test_support::infrastructure::crypto::DefaultSignatureService;\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::test_support::shared::error::AppError;\nuse nostr_sdk::prelude::{Keys, ToBech32};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse tokio::sync::{Mutex, RwLock};\n\n#[derive(Clone)]\nstruct TestKeyManager {\n    keypair: KeyPair,\n}\n\nimpl TestKeyManager {\n    fn new(keypair: KeyPair) -> Self {\n        Self { keypair }\n    }\n}\n\n#[async_trait]\nimpl KeyManager for TestKeyManager {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n        Err(AppError::NotImplemented(\"generate_keypair\".into()))\n    }\n\n    async fn import_private_key(&self, _nsec: &str) -> Result<KeyPair, AppError> {\n        Err(AppError::NotImplemented(\"import_private_key\".into()))\n    }\n\n    async fn export_private_key(&self, _npub: &str) -> Result<String, AppError> {\n        Err(AppError::NotImplemented(\"export_private_key\".into()))\n    }\n\n    async fn get_public_key(&self, _npub: &str) -> Result<String, AppError> {\n        Err(AppError::NotImplemented(\"get_public_key\".into()))\n    }\n\n    async fn store_keypair(&self, _keypair: &KeyPair) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"store_keypair\".into()))\n    }\n\n    async fn delete_keypair(&self, _npub: &str) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"delete_keypair\".into()))\n    }\n\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n        Ok(vec![self.keypair.npub.clone()])\n    }\n\n    async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        Ok(self.keypair.clone())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestGroupKeyStore {\n    records: Arc<RwLock<Vec<GroupKeyRecord>>>,\n}\n\n#[async_trait]\nimpl GroupKeyStore for TestGroupKeyStore {\n    async fn store_key(&self, record: GroupKeyRecord) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        records.retain(|entry| {\n            !(entry.topic_id == record.topic_id\n                && entry.scope == record.scope\n                && entry.epoch == record.epoch)\n        });\n        records.push(record);\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n        epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .find(|entry| {\n                entry.topic_id == topic_id && entry.scope == scope && entry.epoch == epoch\n            })\n            .cloned())\n    }\n\n    async fn get_latest_key(\n        &self,\n        topic_id: &str,\n        scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .filter(|entry| entry.topic_id == topic_id && entry.scope == scope)\n            .max_by_key(|entry| entry.epoch)\n            .cloned())\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .iter()\n            .map(|entry| GroupKeyEntry {\n                topic_id: entry.topic_id.clone(),\n                scope: entry.scope.clone(),\n                epoch: entry.epoch,\n                stored_at: entry.stored_at,\n            })\n            .collect())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestJoinRequestStore {\n    records: Arc<RwLock<HashMap<String, HashMap<String, JoinRequestRecord>>>>,\n    invite_usage: Arc<RwLock<HashMap<String, HashMap<String, InviteUsageRecord>>>>,\n}\n\n#[async_trait]\nimpl JoinRequestStore for TestJoinRequestStore {\n    async fn upsert_request(\n        &self,\n        owner_pubkey: &str,\n        record: JoinRequestRecord,\n    ) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        let owner = records.entry(owner_pubkey.to_string()).or_default();\n        owner.insert(record.event.id.clone(), record);\n        Ok(())\n    }\n\n    async fn list_requests(&self, owner_pubkey: &str) -> Result<Vec<JoinRequestRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .map(|owner| owner.values().cloned().collect())\n            .unwrap_or_default())\n    }\n\n    async fn get_request(\n        &self,\n        owner_pubkey: &str,\n        event_id: &str,\n    ) -> Result<Option<JoinRequestRecord>, AppError> {\n        let records = self.records.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .and_then(|owner| owner.get(event_id).cloned()))\n    }\n\n    async fn delete_request(&self, owner_pubkey: &str, event_id: &str) -> Result<(), AppError> {\n        let mut records = self.records.write().await;\n        if let Some(owner) = records.get_mut(owner_pubkey) {\n            owner.remove(event_id);\n        }\n        Ok(())\n    }\n\n    async fn get_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        invite_event_id: &str,\n    ) -> Result<Option<InviteUsageRecord>, AppError> {\n        let records = self.invite_usage.read().await;\n        Ok(records\n            .get(owner_pubkey)\n            .and_then(|owner| owner.get(invite_event_id).cloned()))\n    }\n\n    async fn upsert_invite_usage(\n        &self,\n        owner_pubkey: &str,\n        record: InviteUsageRecord,\n    ) -> Result<(), AppError> {\n        let mut records = self.invite_usage.write().await;\n        let owner = records.entry(owner_pubkey.to_string()).or_default();\n        owner.insert(record.invite_event_id.clone(), record);\n        Ok(())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestUserRepository {\n    follows: Arc<RwLock<HashSet<(String, String)>>>,\n}\n\nimpl TestUserRepository {\n    async fn seed_follow(&self, follower: &str, followed: &str) {\n        let mut follows = self.follows.write().await;\n        follows.insert((follower.to_string(), followed.to_string()));\n    }\n}\n\n#[async_trait]\nimpl UserRepository for TestUserRepository {\n    async fn create_user(&self, _user: &User) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"create_user\".into()))\n    }\n\n    async fn get_user(&self, _npub: &str) -> Result<Option<User>, AppError> {\n        Err(AppError::NotImplemented(\"get_user\".into()))\n    }\n\n    async fn get_user_by_pubkey(&self, _pubkey: &str) -> Result<Option<User>, AppError> {\n        Err(AppError::NotImplemented(\"get_user_by_pubkey\".into()))\n    }\n\n    async fn search_users(&self, _query: &str, _limit: usize) -> Result<Vec<User>, AppError> {\n        Err(AppError::NotImplemented(\"search_users\".into()))\n    }\n\n    async fn update_user(&self, _user: &User) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"update_user\".into()))\n    }\n\n    async fn delete_user(&self, _npub: &str) -> Result<(), AppError> {\n        Err(AppError::NotImplemented(\"delete_user\".into()))\n    }\n\n    async fn get_followers_paginated(\n        &self,\n        _npub: &str,\n        _cursor: Option<&str>,\n        _limit: usize,\n        _sort: FollowListSort,\n        _search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        Err(AppError::NotImplemented(\"get_followers_paginated\".into()))\n    }\n\n    async fn get_following_paginated(\n        &self,\n        _npub: &str,\n        _cursor: Option<&str>,\n        _limit: usize,\n        _sort: FollowListSort,\n        _search: Option<&str>,\n    ) -> Result<UserCursorPage, AppError> {\n        Err(AppError::NotImplemented(\"get_following_paginated\".into()))\n    }\n\n    async fn add_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let mut follows = self.follows.write().await;\n        Ok(follows.insert((\n            follower_pubkey.to_string(),\n            followed_pubkey.to_string(),\n        )))\n    }\n\n    async fn remove_follow_relation(\n        &self,\n        follower_pubkey: &str,\n        followed_pubkey: &str,\n    ) -> Result<bool, AppError> {\n        let mut follows = self.follows.write().await;\n        Ok(follows.remove(&(\n            follower_pubkey.to_string(),\n            followed_pubkey.to_string(),\n        )))\n    }\n\n    async fn list_following_pubkeys(\n        &self,\n        follower_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let follows = self.follows.read().await;\n        Ok(follows\n            .iter()\n            .filter_map(|(follower, followed)| {\n                if follower == follower_pubkey {\n                    Some(followed.clone())\n                } else {\n                    None\n                }\n            })\n            .collect())\n    }\n\n    async fn list_follower_pubkeys(\n        &self,\n        followed_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let follows = self.follows.read().await;\n        Ok(follows\n            .iter()\n            .filter_map(|(follower, followed)| {\n                if followed == followed_pubkey {\n                    Some(follower.clone())\n                } else {\n                    None\n                }\n            })\n            .collect())\n    }\n}\n\n#[derive(Clone, Default)]\nstruct TestGossipService {\n    joined: Arc<RwLock<HashSet<String>>>,\n    broadcasts: Arc<RwLock<Vec<(String, Event)>>>,\n}\n\nimpl TestGossipService {\n    async fn broadcasts(&self) -> Vec<(String, Event)> {\n        self.broadcasts.read().await.clone()\n    }\n}\n\n#[async_trait]\nimpl kukuri_lib::test_support::infrastructure::p2p::GossipService for TestGossipService {\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.joined.write().await.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.joined.write().await.remove(topic);\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        self.broadcasts\n            .write()\n            .await\n            .push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError> {\n        Err(AppError::NotImplemented(\"subscribe\".into()))\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(self.joined.read().await.iter().cloned().collect())\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Err(AppError::NotImplemented(\"get_topic_peers\".into()))\n    }\n\n    async fn get_topic_stats(\n        &self,\n        _topic: &str,\n    ) -> Result<Option<kukuri_lib::test_support::domain::p2p::TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct TestPostCache {\n    posts: Mutex<HashMap<String, Post>>,\n}\n\n#[async_trait]\nimpl PostCache for TestPostCache {\n    async fn add(&self, post: Post) {\n        self.posts.lock().await.insert(post.id.clone(), post);\n    }\n\n    async fn get(&self, id: &str) -> Option<Post> {\n        self.posts.lock().await.get(id).cloned()\n    }\n\n    async fn remove(&self, id: &str) -> Option<Post> {\n        self.posts.lock().await.remove(id)\n    }\n\n    async fn get_by_topic(&self, topic_id: &str, limit: usize) -> Vec<Post> {\n        let posts = self.posts.lock().await;\n        let mut filtered: Vec<Post> = posts\n            .values()\n            .filter(|post| post.topic_id == topic_id)\n            .cloned()\n            .collect();\n        filtered.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n        if limit == usize::MAX {\n            return filtered;\n        }\n        filtered.into_iter().take(limit).collect()\n    }\n\n    async fn set_topic_posts(&self, topic_id: &str, posts: Vec<Post>) {\n        let mut guard = self.posts.lock().await;\n        guard.retain(|_, post| post.topic_id != topic_id);\n        for post in posts {\n            guard.insert(post.id.clone(), post);\n        }\n    }\n\n    async fn invalidate_topic(&self, topic_id: &str) {\n        let mut guard = self.posts.lock().await;\n        guard.retain(|_, post| post.topic_id != topic_id);\n    }\n}\n\n#[derive(Default)]\nstruct TestEventService;\n\n#[async_trait]\nimpl EventServiceTrait for TestEventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, _content: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn publish_topic_post(\n        &self,\n        _topic_id: &str,\n        _content: &str,\n        _reply_to: Option<&str>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn send_reaction(&self, _event_id: &str, _reaction: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn update_metadata(\n        &self,\n        _metadata: kukuri_lib::test_support::presentation::dto::event::NostrMetadataDto,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn subscribe_to_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn subscribe_to_user(&self, _pubkey: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        Ok(None)\n    }\n\n    async fn boost_post(&self, _event_id: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn delete_events(\n        &self,\n        _event_ids: Vec<String>,\n        _reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn set_default_p2p_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn list_subscriptions(\n        &self,\n    ) -> Result<Vec<kukuri_lib::test_support::application::services::SubscriptionRecord>, AppError>\n    {\n        Ok(vec![])\n    }\n}\n\nfn make_keypair() -> KeyPair {\n    let keys = Keys::generate();\n    let public_key = keys.public_key().to_string();\n    let private_key = keys.secret_key().display_secret().to_string();\n    let npub = keys\n        .public_key()\n        .to_bech32()\n        .unwrap_or_else(|_| public_key.clone());\n    let nsec = format!(\"nsec1{private_key}\");\n    KeyPair {\n        public_key,\n        private_key,\n        npub,\n        nsec,\n    }\n}\n\nasync fn setup_post_service_with_group_store(\n    group_key_store: Arc<dyn GroupKeyStore>,\n    event_service: Arc<dyn EventServiceTrait>,\n) -> (PostService, Arc<SqliteRepository>) {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"failed to create pool\");\n\n    sqlx::query(\n        r#\"\n        CREATE TABLE IF NOT EXISTS bookmarks (\n            id TEXT PRIMARY KEY,\n            user_pubkey TEXT NOT NULL,\n            post_id TEXT NOT NULL,\n            created_at INTEGER NOT NULL,\n            UNIQUE(user_pubkey, post_id)\n        )\n        \"#,\n    )\n    .execute(pool.get_pool())\n    .await\n    .expect(\"failed to create bookmarks table\");\n\n    let repository = Arc::new(SqliteRepository::new(pool));\n    repository\n        .initialize()\n        .await\n        .expect(\"failed to initialize repository schema\");\n\n    let cache: Arc<dyn PostCache> = Arc::new(TestPostCache::default());\n\n    let service = PostService::new(\n        Arc::clone(&repository) as Arc<dyn PostRepository>,\n        Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n        event_service,\n        cache,\n        group_key_store,\n    );\n\n    (service, repository)\n}\n\n#[tokio::test]\nasync fn p2p_only_invite_join_key_envelope_encrypted_post_flow() {\n    let inviter_keypair = make_keypair();\n    let requester_keypair = make_keypair();\n\n    let inviter_key_manager = Arc::new(TestKeyManager::new(inviter_keypair.clone()));\n    let requester_key_manager = Arc::new(TestKeyManager::new(requester_keypair.clone()));\n\n    let inviter_group_keys = Arc::new(TestGroupKeyStore::default());\n    let requester_group_keys = Arc::new(TestGroupKeyStore::default());\n    let inviter_join_requests = Arc::new(TestJoinRequestStore::default());\n    let requester_join_requests = Arc::new(TestJoinRequestStore::default());\n    let user_repository = Arc::new(TestUserRepository::default());\n\n    let signature_service = Arc::new(DefaultSignatureService::new());\n    let inviter_gossip = Arc::new(TestGossipService::default());\n    let requester_gossip = Arc::new(TestGossipService::default());\n\n    let inviter_service = AccessControlService::new(\n        inviter_key_manager,\n        Arc::clone(&inviter_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&inviter_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        inviter_gossip.clone(),\n    );\n    let requester_service = AccessControlService::new(\n        requester_key_manager,\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&requester_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        requester_gossip.clone(),\n    );\n\n    let topic_id = \"kukuri:topic-invite\";\n    let invite_json = inviter_service\n        .issue_invite(topic_id, Some(900), Some(1), Some(\"p2p-e2e\".into()))\n        .await\n        .expect(\"issue invite\");\n\n    let join_result = requester_service\n        .request_join(JoinRequestInput {\n            topic_id: None,\n            scope: None,\n            invite_event_json: Some(invite_json.clone()),\n            target_pubkey: None,\n            broadcast_to_topic: false,\n        })\n        .await\n        .expect(\"request join\");\n\n    let inviter_topic = user_topic_id(&inviter_keypair.public_key);\n    assert!(\n        join_result.sent_topics.contains(&inviter_topic),\n        \"join request should target inviter topic\"\n    );\n\n    let requester_broadcasts = requester_gossip.broadcasts().await;\n    let join_event = requester_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39022)\n        .map(|(_, event)| event.clone())\n        .expect(\"join request event broadcasted\");\n\n    inviter_service\n        .handle_incoming_event(&join_event)\n        .await\n        .expect(\"inviter handles join request\");\n\n    let pending = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending join requests\");\n    assert_eq!(pending.len(), 1);\n\n    inviter_service\n        .approve_join_request(&join_event.id)\n        .await\n        .expect(\"approve join request\");\n    let pending_after = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending cleared\");\n    assert!(pending_after.is_empty());\n\n    let inviter_broadcasts = inviter_gossip.broadcasts().await;\n    let key_envelope_event = inviter_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39020)\n        .map(|(_, event)| event.clone())\n        .expect(\"key envelope broadcasted\");\n\n    requester_service\n        .handle_incoming_event(&key_envelope_event)\n        .await\n        .expect(\"requester stores key envelope\");\n\n    let stored_key = requester_group_keys\n        .get_latest_key(topic_id, \"invite\")\n        .await\n        .expect(\"load key\")\n        .expect(\"invite key stored\");\n    assert_eq!(stored_key.scope, \"invite\");\n\n    let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n    let (post_service, repository) = setup_post_service_with_group_store(\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        event_service,\n    )\n    .await;\n\n    let author = User::new(requester_keypair.npub.clone(), requester_keypair.public_key.clone());\n    let created = post_service\n        .create_post(\n            \"p2p invite encrypted post\".into(),\n            author,\n            topic_id.to_string(),\n            Some(\"invite\".into()),\n        )\n        .await\n        .expect(\"create encrypted post\");\n\n    assert!(created.is_encrypted);\n    assert_eq!(created.scope.as_deref(), Some(\"invite\"));\n    assert_eq!(created.epoch, Some(stored_key.epoch));\n    assert_eq!(created.content, \"p2p invite encrypted post\");\n\n    let stored = repository\n        .get_post(&created.id)\n        .await\n        .expect(\"fetch stored post\")\n        .expect(\"stored post exists\");\n    assert_ne!(stored.content, \"p2p invite encrypted post\");\n    let payload =\n        EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n    assert_eq!(payload.scope, \"invite\");\n    assert_eq!(payload.epoch, stored_key.epoch);\n}\n\n#[tokio::test]\nasync fn p2p_only_friend_plus_join_key_envelope_encrypted_post_flow() {\n    let inviter_keypair = make_keypair();\n    let requester_keypair = make_keypair();\n    let friend_keypair = make_keypair();\n\n    let inviter_key_manager = Arc::new(TestKeyManager::new(inviter_keypair.clone()));\n    let requester_key_manager = Arc::new(TestKeyManager::new(requester_keypair.clone()));\n\n    let inviter_group_keys = Arc::new(TestGroupKeyStore::default());\n    let requester_group_keys = Arc::new(TestGroupKeyStore::default());\n    let inviter_join_requests = Arc::new(TestJoinRequestStore::default());\n    let requester_join_requests = Arc::new(TestJoinRequestStore::default());\n    let user_repository = Arc::new(TestUserRepository::default());\n\n    user_repository\n        .seed_follow(&inviter_keypair.public_key, &friend_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&friend_keypair.public_key, &inviter_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&friend_keypair.public_key, &requester_keypair.public_key)\n        .await;\n    user_repository\n        .seed_follow(&requester_keypair.public_key, &friend_keypair.public_key)\n        .await;\n\n    let signature_service = Arc::new(DefaultSignatureService::new());\n    let inviter_gossip = Arc::new(TestGossipService::default());\n    let requester_gossip = Arc::new(TestGossipService::default());\n\n    let inviter_service = AccessControlService::new(\n        inviter_key_manager,\n        Arc::clone(&inviter_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&inviter_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        inviter_gossip.clone(),\n    );\n    let requester_service = AccessControlService::new(\n        requester_key_manager,\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        Arc::clone(&requester_join_requests) as Arc<dyn JoinRequestStore>,\n        Arc::clone(&user_repository) as Arc<dyn UserRepository>,\n        Arc::clone(&signature_service),\n        requester_gossip.clone(),\n    );\n\n    let topic_id = \"kukuri:topic-friend-plus\";\n\n    let join_result = requester_service\n        .request_join(JoinRequestInput {\n            topic_id: Some(topic_id.to_string()),\n            scope: Some(\"friend_plus\".into()),\n            invite_event_json: None,\n            target_pubkey: Some(inviter_keypair.public_key.clone()),\n            broadcast_to_topic: false,\n        })\n        .await\n        .expect(\"request join\");\n\n    let inviter_topic = user_topic_id(&inviter_keypair.public_key);\n    assert!(\n        join_result.sent_topics.contains(&inviter_topic),\n        \"join request should target inviter topic\"\n    );\n\n    let requester_broadcasts = requester_gossip.broadcasts().await;\n    let join_event = requester_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39022)\n        .map(|(_, event)| event.clone())\n        .expect(\"join request event broadcasted\");\n\n    inviter_service\n        .handle_incoming_event(&join_event)\n        .await\n        .expect(\"inviter handles join request\");\n\n    let pending = inviter_service\n        .list_pending_join_requests()\n        .await\n        .expect(\"pending join requests\");\n    assert_eq!(pending.len(), 1);\n    assert_eq!(pending[0].scope, \"friend_plus\");\n\n    inviter_service\n        .approve_join_request(&join_event.id)\n        .await\n        .expect(\"approve join request\");\n\n    let inviter_broadcasts = inviter_gossip.broadcasts().await;\n    let key_envelope_event = inviter_broadcasts\n        .iter()\n        .find(|(_, event)| event.kind == 39020)\n        .map(|(_, event)| event.clone())\n        .expect(\"key envelope broadcasted\");\n\n    requester_service\n        .handle_incoming_event(&key_envelope_event)\n        .await\n        .expect(\"requester stores key envelope\");\n\n    let stored_key = requester_group_keys\n        .get_latest_key(topic_id, \"friend_plus\")\n        .await\n        .expect(\"load key\")\n        .expect(\"friend_plus key stored\");\n    assert_eq!(stored_key.scope, \"friend_plus\");\n\n    let event_service: Arc<dyn EventServiceTrait> = Arc::new(TestEventService::default());\n    let (post_service, repository) = setup_post_service_with_group_store(\n        Arc::clone(&requester_group_keys) as Arc<dyn GroupKeyStore>,\n        event_service,\n    )\n    .await;\n\n    let author = User::new(requester_keypair.npub.clone(), requester_keypair.public_key.clone());\n    let created = post_service\n        .create_post(\n            \"p2p friend_plus encrypted post\".into(),\n            author,\n            topic_id.to_string(),\n            Some(\"friend_plus\".into()),\n        )\n        .await\n        .expect(\"create encrypted post\");\n\n    assert!(created.is_encrypted);\n    assert_eq!(created.scope.as_deref(), Some(\"friend_plus\"));\n    assert_eq!(created.epoch, Some(stored_key.epoch));\n    assert_eq!(created.content, \"p2p friend_plus encrypted post\");\n\n    let stored = repository\n        .get_post(&created.id)\n        .await\n        .expect(\"fetch stored post\")\n        .expect(\"stored post exists\");\n    assert_ne!(stored.content, \"p2p friend_plus encrypted post\");\n    let payload =\n        EncryptedPostPayload::try_parse(&stored.content).expect(\"encrypted payload parse\");\n    assert_eq!(payload.scope, \"friend_plus\");\n    assert_eq!(payload.epoch, stored_key.epoch);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","event","manager","mod.rs"],"content":"use std::path::Path;\nuse std::sync::Arc;\n\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\nuse kukuri_lib::test_support::application::ports::event_topic_store::EventTopicStore;\nuse kukuri_lib::test_support::application::ports::key_manager::KeyManager;\nuse kukuri_lib::test_support::domain::entities::Event as DomainEvent;\nuse kukuri_lib::test_support::infrastructure::crypto::DefaultKeyManager;\nuse kukuri_lib::test_support::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::test_support::infrastructure::database::repository::Repository;\nuse kukuri_lib::test_support::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::test_support::infrastructure::event::{\n    EventManagerHandle, LegacyEventManagerHandle, RepositoryEventTopicStore,\n};\nuse kukuri_lib::test_support::infrastructure::p2p::GossipService;\nuse kukuri_lib::test_support::shared::error::AppError;\nuse nostr_sdk::prelude::*;\nuse sqlx::Row;\nuse tempfile::TempDir;\nuse tokio::sync::Mutex;\n\n#[tokio::test]\nasync fn handle_p2p_event_persists_rows() -> Result<()> {\n    let ctx = TestContext::setup().await?;\n\n    let keys = Keys::generate();\n    let event = EventBuilder::text_note(\"phase5-incoming-event\")\n        .tag(Tag::hashtag(DEFAULT_PUBLIC_TOPIC_ID))\n        .sign_with_keys(&keys)?;\n\n    ctx.manager.handle_p2p_event(event.clone()).await?;\n\n    let stored = sqlx::query(\"SELECT content FROM events WHERE event_id = ?1\")\n        .bind(event.id.to_hex())\n        .fetch_optional(ctx.pool.get_pool())\n        .await?;\n    let row = stored.expect(\"event row should exist after handler\");\n    let stored_content: String = row.try_get(\"content\")?;\n    assert_eq!(stored_content, \"phase5-incoming-event\");\n\n    let topics = sqlx::query(\"SELECT topic_id FROM event_topics WHERE event_id = ?1\")\n        .bind(event.id.to_hex())\n        .fetch_all(ctx.pool.get_pool())\n        .await?;\n    let topic_ids: Vec<String> = topics\n        .iter()\n        .map(|row| {\n            row.try_get::<String, _>(\"topic_id\")\n                .expect(\"topic id column\")\n        })\n        .collect();\n    assert!(\n        topic_ids\n            .iter()\n            .any(|topic| topic == DEFAULT_PUBLIC_TOPIC_ID),\n        \"expected hashtag mapping for public\"\n    );\n\n    ctx.pool.close().await;\n    Ok(())\n}\n\n#[tokio::test]\nasync fn publish_topic_post_broadcasts_and_links_topics() -> Result<()> {\n    let ctx = TestContext::setup().await?;\n    let manager: Arc<dyn EventManagerHandle> = ctx.manager.clone();\n\n    manager\n        .set_default_p2p_topics(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])\n        .await;\n\n    unsafe {\n        std::env::set_var(\"KUKURI_ALLOW_NO_RELAY\", \"1\");\n    }\n    let _event_id = manager\n        .publish_topic_post(\n            DEFAULT_PUBLIC_TOPIC_ID,\n            \"phase5-topic-body\",\n            None,\n            None,\n            None,\n        )\n        .await?;\n\n    let joined = ctx.gossip.joined_topics().await;\n    assert!(joined.iter().any(|topic| topic == DEFAULT_PUBLIC_TOPIC_ID));\n\n    unsafe {\n        std::env::remove_var(\"KUKURI_ALLOW_NO_RELAY\");\n    }\n    ctx.pool.close().await;\n    Ok(())\n}\n\nstruct TestContext {\n    _temp_dir: TempDir,\n    pool: ConnectionPool,\n    _repository: Arc<SqliteRepository>,\n    manager: Arc<LegacyEventManagerHandle>,\n    gossip: Arc<RecordingGossipService>,\n}\n\nimpl TestContext {\n    async fn setup() -> Result<Self> {\n        let temp_dir = tempfile::tempdir()?;\n        let db_path = temp_dir.path().join(\"event_manager.db\");\n        let db_url = format_sqlite_url(&db_path);\n        let pool = ConnectionPool::new(&db_url).await?;\n\n        let repository = Arc::new(SqliteRepository::new(pool.clone()));\n        repository.initialize().await?;\n\n        let manager = Arc::new(LegacyEventManagerHandle::new_with_connection_pool(\n            pool.clone(),\n        ));\n        let event_manager = manager.as_event_manager();\n\n        let key_manager = DefaultKeyManager::new();\n        key_manager.generate_keypair().await?;\n        event_manager\n            .initialize_with_key_manager(&key_manager)\n            .await?;\n\n        let gossip = Arc::new(RecordingGossipService::default());\n        let gossip_trait: Arc<dyn GossipService> = gossip.clone();\n        manager.set_gossip_service(gossip_trait).await;\n\n        let topic_store: Arc<dyn EventTopicStore> =\n            Arc::new(RepositoryEventTopicStore::new(repository.clone()));\n        manager.set_event_topic_store(topic_store).await;\n\n        Ok(Self {\n            _temp_dir: temp_dir,\n            pool,\n            _repository: repository,\n            manager,\n            gossip,\n        })\n    }\n}\n\n#[derive(Default)]\nstruct RecordingGossipService {\n    joined_topics: Mutex<Vec<String>>,\n    broadcasts: Mutex<Vec<(String, DomainEvent)>>,\n    messages: Mutex<Vec<(String, Vec<u8>)>>,\n}\n\nimpl RecordingGossipService {\n    async fn joined_topics(&self) -> Vec<String> {\n        self.joined_topics.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl GossipService for RecordingGossipService {\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.joined_topics.lock().await.push(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &DomainEvent) -> Result<(), AppError> {\n        self.broadcasts\n            .lock()\n            .await\n            .push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<DomainEvent>, AppError> {\n        let (_tx, rx) = tokio::sync::mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(self.joined_topics().await)\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_stats(\n        &self,\n        _topic: &str,\n    ) -> Result<Option<kukuri_lib::test_support::domain::p2p::TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError> {\n        self.messages\n            .lock()\n            .await\n            .push((topic.to_string(), message.to_vec()));\n        Ok(())\n    }\n}\n\nfn format_sqlite_url(path: &Path) -> String {\n    let mut value = path.to_string_lossy().to_string();\n    if cfg!(windows) {\n        value = value.replace('\\\\', \"/\");\n    }\n    format!(\"sqlite://{}?mode=rwc\", value)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","offline","mod.rs"],"content":"#[path = \"../../common/offline_support.rs\"]\nmod offline_support;\n\nuse chrono::{Duration, Utc};\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait,\n};\nuse kukuri_lib::test_support::domain::entities::offline::{CacheMetadataUpdate, SyncStatusUpdate};\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::test_support::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflinePayload, SyncStatus,\n};\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\nuse offline_support::{\n    OfflineTestContext, TEST_PUBKEY_HEX, sample_save_params, setup_offline_service,\n};\nuse serde_json::Value;\nuse std::sync::Arc;\n\n#[tokio::test]\nasync fn save_action_persists_record() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let saved = service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save action\");\n\n    assert_eq!(saved.action.user_pubkey.as_hex(), TEST_PUBKEY_HEX);\n    assert_eq!(\n        saved\n            .action\n            .target_id\n            .as_ref()\n            .map(ToString::to_string)\n            .as_deref(),\n        Some(\"post123\")\n    );\n    assert_eq!(saved.action.action_type.as_str(), \"create_post\");\n\n    let (count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM offline_actions\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"offline_actions count\");\n    assert_eq!(count, 1);\n}\n\n#[tokio::test]\nasync fn list_actions_applies_sync_filter() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let mut second_params = sample_save_params();\n    second_params.entity_id = EntityId::new(\"post124\".into()).expect(\"entity id\");\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save first\");\n    let second = service\n        .save_action(second_params)\n        .await\n        .expect(\"save second\");\n\n    sqlx::query(\"UPDATE offline_actions SET is_synced = 1 WHERE local_id = ?\")\n        .bind(second.local_id.as_str())\n        .execute(&pool)\n        .await\n        .expect(\"mark synced\");\n\n    let synced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(true),\n            limit: None,\n        })\n        .await\n        .expect(\"list synced\");\n    assert_eq!(synced.len(), 1);\n\n    let unsynced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .expect(\"list unsynced\");\n    assert_eq!(unsynced.len(), 1);\n}\n\n#[tokio::test]\nasync fn sync_actions_marks_records_and_enqueues() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save action\");\n\n    let result = service\n        .sync_actions(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"))\n        .await\n        .expect(\"sync actions\");\n    assert_eq!(result.synced_count, 1);\n    assert_eq!(result.failed_count, 0);\n\n    let (is_synced,): (i64,) = sqlx::query_as(\"SELECT is_synced FROM offline_actions LIMIT 1\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"synced flag\");\n    assert_eq!(is_synced, 1);\n\n    let (queue_count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM sync_queue\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"queue count\");\n    assert_eq!(queue_count, 1);\n}\n\n#[tokio::test]\nasync fn cache_metadata_upsert_and_cleanup() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"cache:topics\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"topics\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\"version\": 1})),\n        expiry: Some(Utc::now() + Duration::seconds(1)),\n        is_stale: Some(false),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n\n    service\n        .upsert_cache_metadata(update)\n        .await\n        .expect(\"upsert cache\");\n\n    sqlx::query(\n        r#\"\n        UPDATE cache_metadata\n        SET expiry_time = expiry_time - 10\n        WHERE cache_key = ?1\n        \"#,\n    )\n    .bind(\"cache:topics\")\n    .execute(&pool)\n    .await\n    .expect(\"force expiry for cleanup test\");\n\n    let removed = service.cleanup_expired_cache().await.expect(\"cleanup\");\n    assert_eq!(removed, 1);\n\n    let (remaining,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM cache_metadata\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"remaining cache rows\");\n    assert_eq!(remaining, 0);\n}\n\n#[tokio::test]\nasync fn cache_status_returns_metadata_summary() {\n    let OfflineTestContext { service, .. } = setup_offline_service().await;\n\n    let first_update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"sync_queue::offline_actions\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"sync_queue\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\n            \"cacheType\": \"offline_actions\",\n            \"requestedAt\": \"2025-11-09T00:00:00Z\",\n            \"requestedBy\": \"npub1first\"\n        })),\n        expiry: None,\n        is_stale: Some(true),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n    service\n        .upsert_cache_metadata(first_update)\n        .await\n        .expect(\"upsert first metadata\");\n\n    tokio::time::sleep(std::time::Duration::from_millis(5)).await;\n\n    let second_update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"sync_queue::trending\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"sync_queue\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\n            \"cacheType\": \"trending\",\n            \"requestedAt\": \"2025-11-09T00:00:01Z\",\n            \"requestedBy\": \"npub1latest\",\n            \"queueItemId\": 42\n        })),\n        expiry: None,\n        is_stale: Some(true),\n        doc_version: None,\n        blob_hash: None,\n        payload_bytes: None,\n    };\n    service\n        .upsert_cache_metadata(second_update)\n        .await\n        .expect(\"upsert second metadata\");\n\n    let snapshot = service.cache_status().await.expect(\"cache status\");\n    let queue_summary = snapshot\n        .cache_types\n        .into_iter()\n        .find(|status| status.cache_type.as_str() == \"sync_queue\")\n        .expect(\"sync_queue summary\");\n\n    assert_eq!(queue_summary.item_count, 2);\n    assert!(queue_summary.is_stale);\n    let metadata = queue_summary.metadata.expect(\"metadata present\");\n    assert_eq!(\n        metadata.get(\"requestedBy\").and_then(|value| value.as_str()),\n        Some(\"npub1latest\")\n    );\n    assert_eq!(\n        metadata.get(\"queueItemId\").and_then(|value| value.as_i64()),\n        Some(42)\n    );\n}\n\n#[tokio::test]\nasync fn update_sync_status_performs_upsert() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    let pending = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"pending\"),\n        Some(OfflinePayload::new(Value::String(\"conflict\".into())).expect(\"payload\")),\n        Utc::now(),\n    );\n    service\n        .update_sync_status(pending)\n        .await\n        .expect(\"initial update\");\n\n    let resolved = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"resolved\"),\n        None,\n        Utc::now(),\n    );\n    service\n        .update_sync_status(resolved)\n        .await\n        .expect(\"second update\");\n\n    let (local_version, sync_status, conflict_data): (i64, String, Option<String>) =\n        sqlx::query_as(\n            r#\"\n            SELECT local_version, sync_status, conflict_data\n            FROM sync_status\n            WHERE entity_type = 'post' AND entity_id = 'p1'\n            \"#,\n        )\n        .fetch_one(&pool)\n        .await\n        .expect(\"sync_status row\");\n\n    assert_eq!(local_version, 2);\n    assert_eq!(sync_status, \"resolved\");\n    assert!(conflict_data.is_none());\n}\n\n#[tokio::test]\nasync fn cache_status_reports_per_type() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .upsert_cache_metadata(CacheMetadataUpdate {\n            cache_key: CacheKey::new(\"cache:posts:1\".into()).expect(\"cache key\"),\n            cache_type: CacheType::new(\"posts\".into()).expect(\"cache type\"),\n            metadata: Some(serde_json::json!({\"version\": 1})),\n            expiry: None,\n            is_stale: Some(false),\n            doc_version: None,\n            blob_hash: None,\n            payload_bytes: None,\n        })\n        .await\n        .expect(\"upsert posts\");\n\n    service\n        .upsert_cache_metadata(CacheMetadataUpdate {\n            cache_key: CacheKey::new(\"cache:topics:1\".into()).expect(\"cache key\"),\n            cache_type: CacheType::new(\"topics\".into()).expect(\"cache type\"),\n            metadata: None,\n            expiry: Some(Utc::now() + Duration::seconds(60)),\n            is_stale: Some(false),\n            doc_version: None,\n            blob_hash: None,\n            payload_bytes: None,\n        })\n        .await\n        .expect(\"upsert topics\");\n\n    sqlx::query(\"UPDATE cache_metadata SET is_stale = 1 WHERE cache_type = ?\")\n        .bind(\"posts\")\n        .execute(&pool)\n        .await\n        .expect(\"mark posts stale\");\n\n    let status = service.cache_status().await.expect(\"cache status\");\n    assert_eq!(status.total_items, 2);\n    assert_eq!(status.stale_items, 1);\n\n    let mut posts_entry = None;\n    let mut topics_entry = None;\n    for entry in status.cache_types {\n        match entry.cache_type.as_str() {\n            \"posts\" => posts_entry = Some(entry),\n            \"topics\" => topics_entry = Some(entry),\n            _ => {}\n        }\n    }\n\n    let posts = posts_entry.expect(\"posts entry\");\n    assert!(posts.is_stale);\n    let topics = topics_entry.expect(\"topics entry\");\n    assert!(!topics.is_stale);\n}\n\n#[tokio::test]\nasync fn sync_actions_after_reindex_clears_pending() {\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save first\");\n\n    let mut second = sample_save_params();\n    second.entity_id = EntityId::new(\"post124\".into()).expect(\"entity id\");\n    service.save_action(second).await.expect(\"save second\");\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence.clone());\n    let report = job.reindex_once().await.expect(\"reindex report\");\n    assert_eq!(report.queued_action_count, 2);\n\n    let result = service\n        .sync_actions(PublicKey::from_hex_str(TEST_PUBKEY_HEX).expect(\"pubkey\"))\n        .await\n        .expect(\"sync actions\");\n\n    assert_eq!(result.synced_count, 2);\n    assert_eq!(result.pending_count, 0);\n\n    let (unsynced,): (i64,) =\n        sqlx::query_as(\"SELECT COUNT(*) FROM offline_actions WHERE is_synced = 0\")\n            .fetch_one(&pool)\n            .await\n            .expect(\"unsynced count\");\n    assert_eq!(unsynced, 0);\n}\n\nmod recovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","offline","recovery.rs"],"content":"use super::offline_support::{\n    OfflineTestContext, build_params_for_index, sample_save_params, setup_offline_service,\n};\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\n\nuse std::sync::Arc;\n\n#[tokio::test]\nasync fn reindex_job_populates_pending_queue_and_reports() {\n    let OfflineTestContext {\n        service: offline_service,\n        pool,\n    } = setup_offline_service().await;\n\n    let params: SaveOfflineActionParams = sample_save_params();\n    let saved = offline_service.save_action(params).await.unwrap();\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let persistence_trait: Arc<dyn OfflinePersistence> = persistence.clone();\n\n    let job = OfflineReindexJob::with_emitter(None, persistence_trait.clone());\n    let report = job.reindex_once().await.unwrap();\n\n    assert_eq!(report.offline_action_count, 1);\n    assert_eq!(report.queued_action_count, 1);\n    assert_eq!(report.pending_queue_count, 1);\n    assert_eq!(\n        report.queued_offline_action_ids,\n        vec![saved.action.action_id.to_string()]\n    );\n\n    let pending_queue = persistence.list_pending_sync_queue().await.unwrap();\n    assert_eq!(pending_queue.len(), 1);\n\n    let unsynced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .unwrap();\n    assert_eq!(unsynced.len(), 1);\n}\n\n#[tokio::test]\nasync fn reindex_job_ignores_already_synced_actions() {\n    let OfflineTestContext {\n        service: offline_service,\n        pool,\n    } = setup_offline_service().await;\n\n    let first = offline_service\n        .save_action(build_params_for_index(0))\n        .await\n        .expect(\"save first action\");\n    let second = offline_service\n        .save_action(build_params_for_index(1))\n        .await\n        .expect(\"save second action\");\n\n    sqlx::query(\"UPDATE offline_actions SET is_synced = 1 WHERE local_id = ?\")\n        .bind(second.local_id.as_str())\n        .execute(&pool)\n        .await\n        .expect(\"mark second as synced\");\n\n    let persistence = Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence.clone());\n\n    let report = job.reindex_once().await.expect(\"reindex report\");\n\n    assert_eq!(report.offline_action_count, 1);\n    assert_eq!(report.queued_action_count, 1);\n    assert_eq!(report.pending_queue_count, 1);\n    assert_eq!(\n        report.queued_offline_action_ids,\n        vec![first.action.action_id.to_string()]\n    );\n\n    let pending_queue = persistence.list_pending_sync_queue().await.unwrap();\n    assert_eq!(pending_queue.len(), 1);\n    assert_eq!(pending_queue[0].status.as_str(), \"pending\");\n\n    let synced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(true),\n            limit: None,\n        })\n        .await\n        .expect(\"list synced\")\n        .len();\n    assert_eq!(synced, 1);\n\n    let unsynced = offline_service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: None,\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .expect(\"list unsynced\")\n        .len();\n    assert_eq!(unsynced, 1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","post_delete_flow.rs"],"content":"use async_trait::async_trait;\nuse kukuri_lib::application::ports::cache::PostCache;\nuse kukuri_lib::application::ports::group_key_store::{GroupKeyEntry, GroupKeyRecord, GroupKeyStore};\nuse kukuri_lib::application::ports::repositories::{\n    BookmarkRepository, PostRepository, UserRepository,\n};\nuse kukuri_lib::application::services::event_service::EventServiceTrait;\nuse kukuri_lib::application::services::post_service::PostService;\nuse kukuri_lib::application::services::user_service::UserService;\nuse kukuri_lib::application::services::SubscriptionRecord;\nuse kukuri_lib::domain::value_objects::EventId;\nuse kukuri_lib::infrastructure::cache::PostCacheService;\nuse kukuri_lib::infrastructure::database::connection_pool::ConnectionPool;\nuse kukuri_lib::infrastructure::database::sqlite_repository::SqliteRepository;\nuse kukuri_lib::presentation::dto::event::NostrMetadataDto;\nuse kukuri_lib::shared::error::AppError;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[derive(Default)]\nstruct DummyGroupKeyStore;\n\n#[async_trait]\nimpl GroupKeyStore for DummyGroupKeyStore {\n    async fn store_key(&self, _record: GroupKeyRecord) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_key(\n        &self,\n        _topic_id: &str,\n        _scope: &str,\n        _epoch: i64,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        Ok(None)\n    }\n\n    async fn get_latest_key(\n        &self,\n        _topic_id: &str,\n        _scope: &str,\n    ) -> Result<Option<GroupKeyRecord>, AppError> {\n        Ok(None)\n    }\n\n    async fn list_keys(&self) -> Result<Vec<GroupKeyEntry>, AppError> {\n        Ok(Vec::new())\n    }\n}\n\n#[derive(Default)]\nstruct RecordingEventService {\n    deleted_event_ids: Mutex<Vec<String>>,\n}\n\nimpl RecordingEventService {\n    async fn collected_ids(&self) -> Vec<String> {\n        self.deleted_event_ids.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl EventServiceTrait for RecordingEventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, _content: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn publish_topic_post(\n        &self,\n        _topic_id: &str,\n        _content: &str,\n        _reply_to: Option<&str>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn send_reaction(&self, _event_id: &str, _reaction: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn update_metadata(&self, _metadata: NostrMetadataDto) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn subscribe_to_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn subscribe_to_user(&self, _pubkey: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        Ok(None)\n    }\n\n    async fn boost_post(&self, _event_id: &str) -> Result<EventId, AppError> {\n        Ok(EventId::generate())\n    }\n\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        _reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        let mut guard = self.deleted_event_ids.lock().await;\n        guard.extend(event_ids);\n        Ok(EventId::generate())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn set_default_p2p_topic(&self, _topic_id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        Ok(vec![])\n    }\n}\n\nconst FOLLOWER_NPUB: &str =\n    \"npub1postdeleteflowfollower00000000000000000000000000000000000000000000000000000\";\nconst FOLLOWER_PUBKEY: &str = \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\nconst AUTHOR_NPUB: &str =\n    \"npub1postdeleteflowauthor0000000000000000000000000000000000000000000000000000000\";\nconst AUTHOR_PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n#[tokio::test]\nasync fn delete_post_is_removed_from_following_and_topic_feeds() {\n    let (post_service, cache, event_service, repository) = setup_post_service().await;\n\n    let user_service = UserService::new(Arc::clone(&repository) as Arc<dyn UserRepository>);\n\n    let follower = user_service\n        .create_user(FOLLOWER_NPUB.to_string(), FOLLOWER_PUBKEY.to_string())\n        .await\n        .expect(\"create follower\");\n    let author = user_service\n        .create_user(AUTHOR_NPUB.to_string(), AUTHOR_PUBKEY.to_string())\n        .await\n        .expect(\"create author\");\n\n    user_service\n        .follow_user(&follower.npub, &author.npub)\n        .await\n        .expect(\"establish follow relationship\");\n\n    let topic_id = \"post-delete-flow-topic\";\n    let first_post = post_service\n        .create_post(\n            \"first post\".into(),\n            author.clone(),\n            topic_id.to_string(),\n            None,\n        )\n        .await\n        .expect(\"create first post\");\n    let second_post = post_service\n        .create_post(\n            \"second post\".into(),\n            author.clone(),\n            topic_id.to_string(),\n            None,\n        )\n        .await\n        .expect(\"create second post\");\n\n    let initial_feed = post_service\n        .list_following_feed(&follower.pubkey, None, 10)\n        .await\n        .expect(\"initial feed\");\n    assert_eq!(initial_feed.items.len(), 2);\n    assert_eq!(initial_feed.items[0].id, second_post.id);\n    assert_eq!(initial_feed.items[1].id, first_post.id);\n\n    let topic_posts = post_service\n        .get_posts_by_topic(topic_id, 10)\n        .await\n        .expect(\"topic posts before deletion\");\n    assert_eq!(topic_posts.len(), 2);\n\n    post_service\n        .delete_post(&first_post.id)\n        .await\n        .expect(\"delete post\");\n\n    let updated_feed = post_service\n        .list_following_feed(&follower.pubkey, None, 10)\n        .await\n        .expect(\"feed after delete\");\n    assert_eq!(updated_feed.items.len(), 1);\n    assert_eq!(updated_feed.items[0].id, second_post.id);\n    assert!(\n        updated_feed\n            .items\n            .iter()\n            .all(|post| post.id != first_post.id),\n        \"deleted post should not appear in following feed\"\n    );\n\n    let refreshed_topic_posts = post_service\n        .get_posts_by_topic(topic_id, 10)\n        .await\n        .expect(\"topic posts after deletion\");\n    assert_eq!(refreshed_topic_posts.len(), 1);\n    assert_eq!(refreshed_topic_posts[0].id, second_post.id);\n\n    assert!(\n        cache.get(&first_post.id).await.is_none(),\n        \"cache entry should be cleared when the post is deleted\"\n    );\n\n    let deleted_ids = event_service.collected_ids().await;\n    assert!(\n        deleted_ids.contains(&first_post.id),\n        \"delete_post should call EventService::delete_events with the removed post id\"\n    );\n}\n\nasync fn setup_post_service(\n) -> (\n    Arc<PostService>,\n    Arc<PostCacheService>,\n    Arc<RecordingEventService>,\n    Arc<SqliteRepository>,\n) {\n    let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"create pool\");\n\n    sqlx::query(\n        r#\"\n        CREATE TABLE IF NOT EXISTS bookmarks (\n            id TEXT PRIMARY KEY,\n            user_pubkey TEXT NOT NULL,\n            post_id TEXT NOT NULL,\n            created_at INTEGER NOT NULL,\n            UNIQUE(user_pubkey, post_id)\n        )\n        \"#,\n    )\n    .execute(pool.get_pool())\n    .await\n    .expect(\"create bookmarks table\");\n\n    let repository = Arc::new(SqliteRepository::new(pool));\n    repository\n        .initialize()\n        .await\n        .expect(\"initialize schema\");\n\n    let cache = Arc::new(PostCacheService::new());\n    let event_service = Arc::new(RecordingEventService::default());\n    let group_key_store: Arc<dyn GroupKeyStore> = Arc::new(DummyGroupKeyStore::default());\n\n    let post_service = Arc::new(PostService::new(\n        Arc::clone(&repository) as Arc<dyn PostRepository>,\n        Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n        Arc::clone(&event_service) as Arc<dyn EventServiceTrait>,\n        Arc::clone(&cache) as Arc<dyn PostCache>,\n        group_key_store,\n    ));\n\n    (post_service, cache, event_service, repository)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_auth.rs"],"content":"// Example integration test for authentication\nuse crate::common::fixtures;\nuse crate::common::mocks::{MockKeyManager, MockSecureStorage};\n\n#[tokio::test]\nasync fn test_create_account() {\n    let key_manager = MockKeyManager::new();\n    let secure_storage = MockSecureStorage::new();\n    \n    // Generate keypair\n    let keypair = key_manager.generate_keypair().await;\n    \n    // Store in secure storage\n    secure_storage\n        .store(\"current_npub\", &keypair.npub)\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify storage\n    let stored_npub = secure_storage\n        .retrieve(\"current_npub\")\n        .await\n        .expect(\"Failed to retrieve npub\");\n    \n    assert_eq!(stored_npub, Some(keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_login_with_nsec() {\n    let key_manager = MockKeyManager::new();\n    let nsec = \"nsec1test1234567890abcdefghijklmnopqrstuvwxyz1234567890abcdef\";\n    \n    // Import private key\n    let result = key_manager.import_private_key(nsec).await;\n    \n    assert!(result.is_ok());\n    let keypair = result.unwrap();\n    assert_eq!(keypair.nsec, nsec);\n    \n    // Verify it was stored\n    let npubs = key_manager.list_npubs().await;\n    assert!(npubs.contains(&keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_logout() {\n    let secure_storage = MockSecureStorage::new();\n    \n    // Store npub\n    secure_storage\n        .store(\"current_npub\", \"npub1test\")\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify it exists\n    assert!(secure_storage.exists(\"current_npub\").await);\n    \n    // Logout (delete)\n    secure_storage\n        .delete(\"current_npub\")\n        .await\n        .expect(\"Failed to delete npub\");\n    \n    // Verify it's gone\n    assert!(!secure_storage.exists(\"current_npub\").await);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_gateway.rs"],"content":"use chrono::Utc;\r\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, EventTag};\r\nuse kukuri_lib::domain::entities::EventKind;\r\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\r\nuse kukuri_lib::domain::value_objects::event_gateway::PublicKey;\r\nuse kukuri_lib::domain::value_objects::EventId;\r\nuse kukuri_lib::infrastructure::database::{\r\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository, EventRepository,\r\n};\r\nuse kukuri_lib::infrastructure::event::{\r\n    EventManagerHandle, LegacyEventManagerGateway, LegacyEventManagerHandle,\r\n};\r\nuse sqlx::Row;\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\nuse tempfile::tempdir;\r\n\r\n#[tokio::test]\r\nasync fn gateway_persists_p2p_events_via_event_manager() -> anyhow::Result<()> {\r\n    let temp_dir = tempdir()?;\r\n    let db_path = temp_dir.path().join(\"event_gateway.db\");\r\n    let db_url = format_sqlite_url(&db_path);\r\n    let pool = ConnectionPool::new(&db_url).await?;\r\n\r\n    let repository = Arc::new(SqliteRepository::new(pool.clone()));\r\n    repository.initialize().await?;\r\n\r\n    let event_manager: Arc<dyn EventManagerHandle> =\r\n        Arc::new(LegacyEventManagerHandle::new_with_connection_pool(pool.clone()));\r\n    event_manager\r\n        .set_event_repository(Arc::clone(&repository) as Arc<dyn EventRepository>)\r\n        .await;\r\n\r\n    let gateway = LegacyEventManagerGateway::new(Arc::clone(&event_manager));\r\n\r\n    let event_id =\r\n        EventId::from_hex(&\"a\".repeat(64)).expect(\"64 hex characters produce a valid event id\");\r\n    let public_key =\r\n        PublicKey::from_hex_str(&\"b\".repeat(64)).expect(\"64 hex characters produce a public key\");\r\n    let topic_tag = EventTag::new(\"t\", vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()]).expect(\"tag construction\");\r\n    let signature = \"c\".repeat(128);\r\n    let payload = DomainEvent::new(\r\n        event_id.clone(),\r\n        public_key.clone(),\r\n        EventKind::TextNote,\r\n        Utc::now(),\r\n        \"hello-mainline-gateway\".to_string(),\r\n        vec![topic_tag],\r\n        signature,\r\n    )\r\n    .expect(\"domain event creation\");\r\n\r\n    gateway\r\n        .handle_incoming_event(payload)\r\n        .await\r\n        .expect(\"gateway should accept domain events\");\r\n\r\n    let stored = sqlx::query(\"SELECT event_id, content FROM events WHERE event_id = ?1\")\r\n        .bind(event_id.to_hex())\r\n        .fetch_optional(pool.get_pool())\r\n        .await?;\r\n    assert!(stored.is_some(), \"event record should exist after gateway call\");\r\n    let row = stored.unwrap();\r\n    let stored_id: String = row.try_get(\"event_id\")?;\r\n    let stored_content: String = row.try_get(\"content\")?;\r\n    assert_eq!(stored_id, event_id.to_hex());\r\n    assert_eq!(stored_content, \"hello-mainline-gateway\");\r\n\r\n    let topics = sqlx::query(\"SELECT topic_id FROM event_topics WHERE event_id = ?1\")\r\n        .bind(event_id.to_hex())\r\n        .fetch_all(pool.get_pool())\r\n        .await?;\r\n    assert_eq!(\r\n        topics.len(),\r\n        1,\r\n        \"event_topics should receive a single hashtag mapping\"\r\n    );\r\n    assert_eq!(topics[0].try_get::<String, _>(\"topic_id\")?, DEFAULT_PUBLIC_TOPIC_ID);\r\n\r\n    pool.close().await;\r\n    Ok(())\r\n}\r\n\r\nfn format_sqlite_url(path: &Path) -> String {\r\n    let mut value = path.to_string_lossy().to_string();\r\n    if cfg!(windows) {\r\n        value = value.replace('\\\\', \"/\");\r\n    }\r\n    format!(\"sqlite://{}?mode=rwc\", value)\r\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_service_gateway.rs"],"content":"use async_trait::async_trait;\r\nuse kukuri_lib::application::ports::key_manager::KeyPair;\r\nuse kukuri_lib::application::services::event_service::EventService;\r\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\r\nuse kukuri_lib::domain::value_objects::subscription::{\r\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\r\n};\r\nuse kukuri_lib::domain::entities::Event;\r\nuse kukuri_lib::domain::value_objects::EventId;\r\nuse kukuri_lib::infrastructure::crypto::SignatureService;\r\nuse kukuri_lib::infrastructure::database::EventRepository;\r\nuse kukuri_lib::infrastructure::event::{\r\n    EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\r\n};\r\nuse kukuri_lib::infrastructure::p2p::GossipService;\r\nuse kukuri_lib::infrastructure::p2p::event_distributor::{\r\n    DistributionStrategy, EventDistributor,\r\n};\r\nuse kukuri_lib::presentation::dto::event::NostrMetadataDto;\r\nuse kukuri_lib::shared::error::AppError;\r\nuse kukuri_lib::domain::constants::DEFAULT_PUBLIC_TOPIC_ID;\r\nuse nostr_sdk::prelude::{EventId as NostrEventId, Keys, Metadata, PublicKey};\r\nuse nostr_sdk::Timestamp;\r\nuse serde_json::Value;\r\nuse std::sync::atomic::{AtomicU32, Ordering};\r\nuse std::sync::Arc;\r\nuse tokio::sync::Mutex;\r\n\r\nfn repeating_hex(ch: char) -> String {\r\n    std::iter::repeat(ch).take(64).collect()\r\n}\r\n\r\nfn to_event_id(hex: &str) -> EventId {\r\n    EventId::from_hex(hex).expect(\"valid hex event id\")\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publish_text_note_routes_through_gateway() {\r\n    let (service, manager, _) = build_service().await;\r\n    let event_id = service\r\n        .publish_text_note(\"phase5-text-note\")\r\n        .await\r\n        .expect(\"publish text note\");\r\n\r\n    assert_eq!(\r\n        event_id.to_hex(),\r\n        manager.last_event_id().await.expect(\"event id recorded\")\r\n    );\r\n    let notes = manager.text_notes().await;\r\n    assert_eq!(notes, vec![\"phase5-text-note\".to_string()]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn publish_topic_post_converts_topic_and_reply() {\r\n    let (service, manager, _) = build_service().await;\r\n    let reply_id = repeating_hex('b');\r\n    service\n        .publish_topic_post(\n            DEFAULT_PUBLIC_TOPIC_ID,\n            \"phase5 topic body\",\n            Some(&reply_id),\n            None,\n            None,\n        )\n        .await\n        .expect(\"publish topic post\");\n\r\n    let posts = manager.topic_posts().await;\r\n    assert_eq!(posts.len(), 1);\r\n    let post = &posts[0];\r\n    assert_eq!(post.topic_id, DEFAULT_PUBLIC_TOPIC_ID);\r\n    assert_eq!(post.content, \"phase5 topic body\");\r\n    assert_eq!(post.reply_to_hex.as_deref(), Some(&reply_id));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn send_reaction_uses_gateway_and_passes_parameters() {\r\n    let (service, manager, _) = build_service().await;\r\n    let target = repeating_hex('c');\r\n    service\r\n        .send_reaction(&target, \":+1:\")\r\n        .await\r\n        .expect(\"send reaction\");\r\n\r\n    let reactions = manager.reactions().await;\r\n    assert_eq!(reactions, vec![(target, \":+1:\".to_string())]);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn update_metadata_flows_through_conversion() {\r\n    let (service, manager, _) = build_service().await;\r\n    let dto = NostrMetadataDto {\r\n        name: Some(\"Alice\".into()),\r\n        display_name: Some(\"Alice / Phase5\".into()),\r\n        about: Some(\"updating metadata\".into()),\r\n        picture: Some(\"https://example.com/p.png\".into()),\r\n        banner: None,\r\n        nip05: None,\r\n        lud16: Some(\"alice@getalby.com\".into()),\r\n        website: Some(\"https://kukuri.app\".into()),\r\n    };\r\n\r\n    service\r\n        .update_metadata(dto.clone())\r\n        .await\r\n        .expect(\"update metadata succeeds\");\r\n\r\n    let metadata = manager.metadata().await;\r\n    assert_eq!(metadata.len(), 1);\r\n    let serialized: Value =\r\n        serde_json::to_value(&metadata[0]).expect(\"metadata serializable to json\");\r\n    assert_eq!(serialized[\"name\"], dto.name.unwrap().into());\r\n    assert_eq!(serialized[\"display_name\"], dto.display_name.unwrap().into());\r\n    assert_eq!(serialized[\"about\"], dto.about.unwrap().into());\r\n    assert_eq!(serialized[\"picture\"], dto.picture.unwrap().into());\r\n    assert_eq!(serialized[\"lud16\"], dto.lud16.unwrap().into());\r\n    assert_eq!(serialized[\"website\"], dto.website.unwrap().into());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn delete_events_invokes_gateway_and_repository_cleanup() {\r\n    let (service, manager, repo) = build_service().await;\r\n    let targets = vec![repeating_hex('d'), repeating_hex('e')];\r\n    service\r\n        .delete_events(targets.clone(), Some(\"cleanup\".into()))\r\n        .await\r\n        .expect(\"delete events\");\r\n\r\n    let deletions = manager.deletions().await;\r\n    assert_eq!(deletions.len(), 1);\r\n    assert_eq!(deletions[0].targets, targets);\r\n    assert_eq!(deletions[0].reason.as_deref(), Some(\"cleanup\"));\r\n\r\n    let deleted_ids = repo.deleted_ids().await;\r\n    assert_eq!(deleted_ids, targets);\r\n}\r\n\r\nasync fn build_service(\r\n) -> (\r\n    EventService,\r\n    Arc<RecordingEventManager>,\r\n    Arc<RecordingEventRepository>,\r\n) {\r\n    let manager = Arc::new(RecordingEventManager::new());\r\n    let repository = Arc::new(RecordingEventRepository::default());\r\n    let manager_trait: Arc<dyn EventManagerHandle> = Arc::clone(&manager);\r\n    let event_gateway = Arc::new(LegacyEventManagerGateway::new(Arc::clone(&manager_trait)));\r\n\r\n    let mut service = EventService::new(\r\n        Arc::clone(&repository) as Arc<dyn EventRepository>,\r\n        Arc::new(NoopSignatureService),\r\n        Arc::new(NoopEventDistributor),\r\n        event_gateway,\r\n        Arc::new(NoopSubscriptionStateStore),\r\n    );\r\n    service.set_subscription_invoker(Arc::new(EventManagerSubscriptionInvoker::new(\r\n        Arc::clone(&manager_trait),\r\n    )));\r\n\r\n    (service, manager, repository)\r\n}\r\n\r\n#[derive(Clone)]\r\nstruct RecordingEventManager {\r\n    text_notes: Arc<Mutex<Vec<String>>>,\r\n    topic_posts: Arc<Mutex<Vec<TopicPostRecord>>>,\r\n    reactions: Arc<Mutex<Vec<(String, String)>>>,\r\n    metadata: Arc<Mutex<Vec<Metadata>>>,\r\n    deletions: Arc<Mutex<Vec<DeletionRecord>>>,\r\n    default_topics: Arc<Mutex<Vec<String>>>,\r\n    public_key: PublicKey,\r\n    counter: Arc<AtomicU32>,\r\n    last_event_hex: Arc<Mutex<Option<String>>>,\r\n}\r\n\r\nimpl RecordingEventManager {\r\n    fn new() -> Self {\r\n        let keys = Keys::generate();\r\n        Self {\r\n            text_notes: Arc::new(Mutex::new(Vec::new())),\r\n            topic_posts: Arc::new(Mutex::new(Vec::new())),\r\n            reactions: Arc::new(Mutex::new(Vec::new())),\r\n            metadata: Arc::new(Mutex::new(Vec::new())),\r\n            deletions: Arc::new(Mutex::new(Vec::new())),\r\n            default_topics: Arc::new(Mutex::new(vec![DEFAULT_PUBLIC_TOPIC_ID.to_string()])),\r\n            public_key: keys.public_key(),\r\n            counter: Arc::new(AtomicU32::new(1)),\r\n            last_event_hex: Arc::new(Mutex::new(None)),\r\n        }\r\n    }\r\n\r\n    async fn record_event_id(&self, id: &NostrEventId) {\r\n        let mut guard = self.last_event_hex.lock().await;\r\n        *guard = Some(id.to_hex());\r\n    }\r\n\r\n    async fn last_event_id(&self) -> Option<String> {\r\n        self.last_event_hex.lock().await.clone()\r\n    }\r\n\r\n    async fn text_notes(&self) -> Vec<String> {\r\n        self.text_notes.lock().await.clone()\r\n    }\r\n\r\n    async fn topic_posts(&self) -> Vec<TopicPostRecord> {\r\n        self.topic_posts.lock().await.clone()\r\n    }\r\n\r\n    async fn reactions(&self) -> Vec<(String, String)> {\r\n        self.reactions.lock().await.clone()\r\n    }\r\n\r\n    async fn metadata(&self) -> Vec<Metadata> {\r\n        self.metadata.lock().await.clone()\r\n    }\r\n\r\n    async fn deletions(&self) -> Vec<DeletionRecord> {\r\n        self.deletions.lock().await.clone()\r\n    }\r\n\r\n    fn next_event_id(&self) -> NostrEventId {\r\n        let next = self.counter.fetch_add(1, Ordering::Relaxed);\r\n        let mut bytes = [0u8; 32];\r\n        bytes[..4].copy_from_slice(&next.to_be_bytes());\r\n        NostrEventId::from_slice(&bytes).expect(\"event id from counter\")\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\nstruct TopicPostRecord {\r\n    topic_id: String,\r\n    content: String,\r\n    reply_to_hex: Option<String>,\r\n}\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\nstruct DeletionRecord {\r\n    targets: Vec<String>,\r\n    reason: Option<String>,\r\n}\r\n\r\n#[async_trait]\r\nimpl EventManagerHandle for RecordingEventManager {\r\n    async fn set_gossip_service(&self, _gossip: Arc<dyn GossipService>) {}\r\n\r\n    async fn set_event_repository(&self, _repo: Arc<dyn EventRepository>) {}\r\n\r\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\r\n        let mut guard = self.default_topics.lock().await;\r\n        guard.clear();\r\n        guard.push(topic_id.to_string());\r\n    }\r\n\r\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\r\n        let mut guard = self.default_topics.lock().await;\r\n        *guard = topics;\r\n    }\r\n\r\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\r\n        self.default_topics.lock().await.clone()\r\n    }\r\n\r\n    async fn handle_p2p_event(&self, _event: nostr_sdk::Event) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn publish_text_note(&self, content: &str) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.text_notes.lock().await.push(content.to_string());\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n        _scope: Option<&str>,\n        _epoch: Option<i64>,\n    ) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.topic_posts.lock().await.push(TopicPostRecord {\r\n            topic_id: topic_id.to_string(),\r\n            content: content.to_string(),\r\n            reply_to_hex: reply_to.map(|id| id.to_hex()),\r\n        });\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn send_reaction(\r\n        &self,\r\n        target: &NostrEventId,\r\n        reaction: &str,\r\n    ) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.reactions\r\n            .lock()\r\n            .await\r\n            .push((target.to_hex(), reaction.to_string()));\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn update_metadata(&self, metadata: Metadata) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.metadata.lock().await.push(metadata);\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn delete_events(\r\n        &self,\r\n        target_ids: Vec<NostrEventId>,\r\n        reason: Option<String>,\r\n    ) -> anyhow::Result<NostrEventId> {\r\n        let event_id = self.next_event_id();\r\n        self.record_event_id(&event_id).await;\r\n        self.deletions.lock().await.push(DeletionRecord {\r\n            targets: target_ids.into_iter().map(|id| id.to_hex()).collect(),\r\n            reason,\r\n        });\r\n        Ok(event_id)\r\n    }\r\n\r\n    async fn disconnect(&self) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_public_key(&self) -> Option<PublicKey> {\r\n        Some(self.public_key)\r\n    }\r\n\r\n    async fn subscribe_to_topic(\r\n        &self,\r\n        _topic_id: &str,\r\n        _since: Option<Timestamp>,\r\n    ) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn subscribe_to_user(\r\n        &self,\r\n        _pubkey: PublicKey,\r\n        _since: Option<Timestamp>,\r\n    ) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn initialize_with_keypair(&self, _keypair: KeyPair) -> anyhow::Result<()> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Default)]\r\nstruct RecordingEventRepository {\r\n    deleted: Mutex<Vec<String>>,\r\n}\r\n\r\nimpl RecordingEventRepository {\r\n    async fn deleted_ids(&self) -> Vec<String> {\r\n        self.deleted.lock().await.clone()\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl EventRepository for RecordingEventRepository {\r\n    async fn create_event(&self, _event: &Event) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_event(&self, _id: &str) -> Result<Option<Event>, AppError> {\r\n        Ok(None)\r\n    }\r\n\r\n    async fn get_events_by_kind(\r\n        &self,\r\n        _kind: u32,\r\n        _limit: usize,\r\n    ) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn get_events_by_author(\r\n        &self,\r\n        _pubkey: &str,\r\n        _limit: usize,\r\n    ) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\r\n        self.deleted.lock().await.push(id.to_string());\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn mark_event_synced(&self, _id: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\nstruct NoopSignatureService;\r\n\r\n#[async_trait]\r\nimpl SignatureService for NoopSignatureService {\r\n    async fn sign_event(\r\n        &self,\r\n        _event: &mut Event,\r\n        _private_key: &str,\r\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn verify_event(\r\n        &self,\r\n        _event: &Event,\r\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(true)\r\n    }\r\n\r\n    async fn sign_message(\r\n        &self,\r\n        message: &str,\r\n        _private_key: &str,\r\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(message.to_string())\r\n    }\r\n\r\n    async fn verify_message(\r\n        &self,\r\n        _message: &str,\r\n        _signature: &str,\r\n        _public_key: &str,\r\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(true)\r\n    }\r\n}\r\n\r\nstruct NoopEventDistributor;\r\n\r\n#[async_trait]\r\nimpl EventDistributor for NoopEventDistributor {\r\n    async fn distribute(\r\n        &self,\r\n        _event: &Event,\r\n        _strategy: DistributionStrategy,\r\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(None)\r\n    }\r\n\r\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {}\r\n\r\n    async fn get_pending_events(\r\n        &self,\r\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\r\n        Ok(0)\r\n    }\r\n}\r\n\r\nstruct NoopSubscriptionStateStore;\r\n\r\n#[async_trait]\r\nimpl SubscriptionStateStore for NoopSubscriptionStateStore {\r\n    async fn record_request(\r\n        &self,\r\n        target: SubscriptionTarget,\r\n    ) -> Result<SubscriptionRecord, AppError> {\r\n        Ok(SubscriptionRecord {\r\n            target,\r\n            status: SubscriptionStatus::Pending,\r\n            last_synced_at: None,\r\n            last_attempt_at: None,\r\n            failure_count: 0,\r\n            error_message: None,\r\n        })\r\n    }\r\n\r\n    async fn mark_subscribed(\r\n        &self,\r\n        _target: &SubscriptionTarget,\r\n        _synced_at: i64,\r\n    ) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn mark_failure(&self, _target: &SubscriptionTarget, _error: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_p2p_mainline.rs"],"content":"use iroh::SecretKey;\nuse kukuri_lib::application::services::p2p_service::P2PService;\nuse kukuri_lib::infrastructure::p2p::DiscoveryOptions;\nuse kukuri_lib::shared::config::NetworkConfig as AppNetworkConfig;\n\nfn mainline_ready_config() -> AppNetworkConfig {\n    AppNetworkConfig {\n        bootstrap_peers: vec![\"peer1.example:1337\".into()],\n        max_peers: 24,\n        connection_timeout: 30,\n        retry_interval: 10,\n        enable_dht: true,\n        enable_dns: false,\n        enable_local: true,\n    }\n}\n\n#[test]\nfn builder_enables_mainline_when_configured() {\n    let config = mainline_ready_config();\n    let secret = SecretKey::from_bytes(&[1u8; 32]);\n\n    let builder = P2PService::builder(secret, config.clone());\n    let options = builder.discovery_options();\n\n    assert!(options.enable_mainline(), \"mainline should be enabled\");\n    assert!(!options.enable_dns, \"DNS discovery stays disabled\");\n    assert!(options.enable_local, \"local discovery remains enabled\");\n}\n\n#[test]\nfn builder_can_disable_mainline_via_toggle() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    let secret = SecretKey::from_bytes(&[2u8; 32]);\n\n    let builder = P2PService::builder(secret, config).enable_mainline(false);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options,\n        DiscoveryOptions::new(false, false, true),\n        \"explicit toggle should override configuration flags\"\n    );\n}\n\n#[test]\nfn builder_honors_custom_discovery_overrides() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    config.enable_dns = true;\n    config.enable_local = false;\n    let secret = SecretKey::from_bytes(&[3u8; 32]);\n\n    let custom = DiscoveryOptions::new(true, true, false);\n    let builder = P2PService::builder(secret, config).with_discovery_options(custom);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options, custom,\n        \"custom discovery options should take precedence over network config\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","topic_create_join.rs"],"content":"use async_trait::async_trait;\r\nuse kukuri_lib::application::services::offline_service::{OfflineService, OfflineServiceTrait};\r\nuse kukuri_lib::application::services::topic_service::{PendingTopicStatus, TopicService};\r\nuse kukuri_lib::domain::entities::Topic;\r\nuse kukuri_lib::infrastructure::database::{\r\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\r\n};\r\nuse kukuri_lib::infrastructure::offline::SqliteOfflinePersistence;\r\nuse kukuri_lib::shared::{error::AppError, config::BootstrapSource};\r\nuse kukuri_lib::application::services::p2p_service::{P2PServiceTrait, P2PStatus};\r\nuse std::sync::Arc;\r\nuse tokio::sync::Mutex;\r\n\r\n#[derive(Default)]\r\nstruct TestP2PService {\r\n    joins: Mutex<Vec<String>>,\r\n}\r\n\r\n#[async_trait]\r\nimpl P2PServiceTrait for TestP2PService {\r\n    async fn initialize(&self) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn join_topic(\r\n        &self,\r\n        topic_id: &str,\r\n        _initial_peers: Vec<String>,\r\n    ) -> Result<(), AppError> {\r\n        self.joins.lock().await.push(topic_id.to_string());\r\n        Ok(())\r\n    }\r\n\r\n    async fn leave_topic(&self, _topic_id: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn broadcast_message(&self, _topic_id: &str, _content: &str) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n\r\n    async fn get_status(&self) -> Result<P2PStatus, AppError> {\r\n        Ok(P2PStatus {\r\n            is_connected: true,\r\n            connected_peers: vec![],\r\n            gossip_topics: vec![],\r\n            node_addresses: vec![],\r\n            bootstrap_source: BootstrapSource::Bundle,\r\n        })\r\n    }\r\n\r\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError> {\r\n        Ok(vec![])\r\n    }\r\n\r\n    fn generate_topic_id(&self, topic_name: &str) -> String {\r\n        topic_name.to_string()\r\n    }\r\n\r\n    async fn apply_bootstrap_nodes(\r\n        &self,\r\n        _nodes: Vec<String>,\r\n        _source: BootstrapSource,\r\n    ) -> Result<(), AppError> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn test_pubkey() -> String {\r\n    std::iter::repeat('a').take(64).collect()\r\n}\r\n\r\n#[tokio::test]\r\nasync fn enqueue_create_and_sync_pending_topic() {\r\n    let connection_pool = ConnectionPool::from_memory()\r\n        .await\r\n        .expect(\"create memory pool\");\r\n    let repository = Arc::new(SqliteRepository::new(connection_pool.clone()));\r\n    repository.initialize().await.expect(\"run migrations\");\r\n\r\n    let topic_repo: Arc<dyn kukuri_lib::application::ports::repositories::TopicRepository> =\r\n        Arc::clone(&repository);\r\n    let pending_repo: Arc<dyn kukuri_lib::application::ports::repositories::PendingTopicRepository> =\r\n        Arc::clone(&repository);\r\n    let metrics_repo: Arc<dyn kukuri_lib::application::ports::repositories::TopicMetricsRepository> =\r\n        Arc::clone(&repository);\r\n\r\n    let offline_persistence =\r\n        Arc::new(SqliteOfflinePersistence::new(connection_pool.get_pool().clone()));\r\n    let offline_service: Arc<dyn OfflineServiceTrait> =\r\n        Arc::new(OfflineService::new(offline_persistence));\r\n\r\n    let p2p_service = Arc::new(TestP2PService::default());\r\n\r\n    let topic_service = TopicService::new(\r\n        topic_repo,\r\n        pending_repo,\r\n        metrics_repo,\r\n        false,\r\n        Arc::clone(&p2p_service) as Arc<dyn P2PServiceTrait>,\r\n        offline_service,\r\n    );\r\n    topic_service\r\n        .ensure_public_topic()\r\n        .await\r\n        .expect(\"ensure public topic\");\r\n\r\n    let user_pubkey = test_pubkey();\r\n    let enqueue = topic_service\r\n        .enqueue_topic_creation(&user_pubkey, \"offline.topic\".into(), Some(\"desc\".into()))\r\n        .await\r\n        .expect(\"enqueue topic creation\");\r\n    assert_eq!(enqueue.pending_topic.status, PendingTopicStatus::Queued);\r\n\r\n    let created = topic_service\r\n        .create_topic(\"offline.topic\".into(), Some(\"desc\".into()), TopicVisibility::Public, &user_pubkey)\r\n        .await\r\n        .expect(\"create topic\");\r\n\r\n    topic_service\r\n        .mark_pending_topic_synced(&enqueue.pending_topic.pending_id, &created.id)\r\n        .await\r\n        .expect(\"mark pending synced\");\r\n\r\n    let synced = topic_service\r\n        .get_pending_topic(&enqueue.pending_topic.pending_id)\r\n        .await\r\n        .expect(\"get pending topic\")\r\n        .expect(\"pending entry exists\");\r\n    assert_eq!(synced.status, PendingTopicStatus::Synced);\r\n    assert_eq!(synced.synced_topic_id.as_deref(), Some(created.id.as_str()));\r\n\r\n    let joined = repository\r\n        .get_joined_topics(&user_pubkey)\r\n        .await\r\n        .expect(\"joined topics\");\r\n    assert!(\r\n        joined.iter().any(|topic: &Topic| topic.id == created.id),\r\n        \"user should be joined to newly created topic\"\r\n    );\r\n\r\n    {\r\n        let joins = p2p_service.joins.lock().await;\r\n        assert!(\r\n            joins.contains(&created.id),\r\n            \"p2p service should receive join request\"\r\n        );\r\n    }\r\n\r\n    let failed = topic_service\r\n        .enqueue_topic_creation(&user_pubkey, \"offline.fail\".into(), None)\r\n        .await\r\n        .expect(\"enqueue second topic\");\r\n    topic_service\r\n        .mark_pending_topic_failed(&failed.pending_topic.pending_id, Some(\"network error\".into()))\r\n        .await\r\n        .expect(\"mark pending failed\");\r\n\r\n    let failed_entry = topic_service\r\n        .get_pending_topic(&failed.pending_topic.pending_id)\r\n        .await\r\n        .expect(\"get failed pending\")\r\n        .expect(\"failed entry exists\");\r\n    assert_eq!(failed_entry.status, PendingTopicStatus::Failed);\r\n    assert_eq!(\r\n        failed_entry.error_message.as_deref(),\r\n        Some(\"network error\")\r\n    );\r\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","key_management.rs"],"content":"use std::{collections::HashMap, sync::Arc};\n\nuse async_trait::async_trait;\nuse kukuri_lib::test_support::{\n    application::{\n        ports::{\n            auth_lifecycle::{AuthLifecycleEvent, AuthLifecyclePort},\n            key_manager::KeyManager,\n        },\n        services::AuthService,\n    },\n    domain::entities::User,\n    infrastructure::{crypto::DefaultKeyManager, storage::secure_storage::SecureStorage},\n    shared::error::AppError,\n};\nuse tokio::sync::Mutex;\n\n#[derive(Default)]\nstruct InMemorySecureStorage {\n    entries: Mutex<HashMap<String, String>>,\n}\n\n#[async_trait]\nimpl SecureStorage for InMemorySecureStorage {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries\n            .lock()\n            .await\n            .insert(key.to_string(), value.to_string());\n        Ok(())\n    }\n\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.get(key).cloned())\n    }\n\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries.lock().await.remove(key);\n        Ok(())\n    }\n\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.contains_key(key))\n    }\n\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(self.entries.lock().await.keys().cloned().collect())\n    }\n\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.entries.lock().await.clear();\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct TestAuthLifecycle {\n    users: Mutex<HashMap<String, User>>,\n}\n\n#[async_trait]\nimpl AuthLifecyclePort for TestAuthLifecycle {\n    async fn handle(&self, event: AuthLifecycleEvent) -> Result<User, AppError> {\n        let account = event.account;\n        let user = User::new(account.npub.clone(), account.public_key.clone());\n        self.users\n            .lock()\n            .await\n            .insert(account.npub.clone(), user.clone());\n        Ok(user)\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        Ok(self.users.lock().await.get(npub).cloned())\n    }\n}\n\n#[tokio::test]\nasync fn export_private_key_roundtrip() {\n    let key_manager = Arc::new(DefaultKeyManager::new()) as Arc<dyn KeyManager>;\n    let secure_storage = Arc::new(InMemorySecureStorage::default());\n    let lifecycle = Arc::new(TestAuthLifecycle::default());\n\n    let service = AuthService::new(\n        key_manager,\n        secure_storage.clone() as Arc<dyn SecureStorage>,\n        lifecycle as Arc<dyn AuthLifecyclePort>,\n    );\n\n    let created_user = service.create_account().await.expect(\"create account\");\n    let exported = service\n        .export_private_key(&created_user.npub)\n        .await\n        .expect(\"export key\");\n    assert!(exported.starts_with(\"nsec1\"));\n\n    service.logout().await.expect(\"logout\");\n    let imported_user = service\n        .login_with_nsec(&exported)\n        .await\n        .expect(\"login with exported key\");\n\n    assert_eq!(imported_user.npub, created_user.npub);\n\n    let stored_npub = secure_storage\n        .retrieve(\"current_npub\")\n        .await\n        .expect(\"current_npub entry\");\n    assert_eq!(stored_npub, Some(created_user.npub));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","offline_integration.rs"],"content":"﻿#[path = \"integration/offline/mod.rs\"]\nmod offline;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_gossip_smoke.rs"],"content":"use kukuri_lib::test_support::application::shared::tests::p2p::bootstrap::{\n    DEFAULT_EVENT_TIMEOUT, DEFAULT_JOIN_TIMEOUT, build_peer_hints, create_service,\n    wait_for_peer_join_event, wait_for_topic_membership,\n};\nuse kukuri_lib::test_support::application::shared::tests::p2p::config::load_bootstrap_context;\nuse kukuri_lib::test_support::application::shared::tests::p2p::fixtures::nostr_to_domain;\nuse kukuri_lib::test_support::application::shared::tests::p2p::logging::init_tracing;\nuse kukuri_lib::test_support::domain::p2p::generate_topic_id;\nuse kukuri_lib::test_support::infrastructure::p2p::gossip_service::GossipService;\nuse nostr_sdk::prelude::*;\nuse tokio::sync::broadcast;\nuse tokio::time::{Duration, sleep, timeout};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    };\n}\n\n/// subscribe → join の最小シナリオで接続確認を行う\n#[tokio::test]\nasync fn test_two_nodes_connect_and_join() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_connect_and_join\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_connect_and_join start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-two-nodes\");\n    log_step!(\"joining topic {} on both services\", topic);\n\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined topic {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined topic {}\", topic);\n\n    let _rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"both services joined topic {}\", topic);\n\n    let joined_a = svc_a.get_joined_topics().await.unwrap();\n    let joined_b = svc_b.get_joined_topics().await.unwrap();\n    assert!(joined_a.contains(&topic));\n    assert!(joined_b.contains(&topic));\n    log_step!(\"--- test_two_nodes_connect_and_join end ---\");\n}\n\n/// 双方向にメッセージをやり取りし、近接で安定して届くことを検証する\n#[tokio::test]\nasync fn test_peer_connection_stability_bidirectional() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_peer_connection_stability_bidirectional\") else {\n        return;\n    };\n    log_step!(\"--- test_peer_connection_stability_bidirectional start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-stability\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for stability test, continuing optimistically\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting ping sequence on topic {}\", topic);\n\n    for i in 0..5u32 {\n        let keys = Keys::generate();\n        let ne = EventBuilder::text_note(format!(\"ping-{i}\"))\n            .sign_with_keys(&keys)\n            .unwrap();\n        let ev = nostr_to_domain(&ne);\n        if i % 2 == 0 {\n            svc_a.broadcast(&topic, &ev).await.unwrap();\n        } else {\n            svc_b.broadcast(&topic, &ev).await.unwrap();\n        }\n    }\n\n    let mut count_a = 0;\n    let mut count_b = 0;\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < Duration::from_secs(12) && (count_a < 3 || count_b < 3) {\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_a.recv().await }).await\n        {\n            count_a += 1;\n        }\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_b.recv().await }).await\n        {\n            count_b += 1;\n        }\n    }\n\n    assert!(\n        count_a >= 3 || count_b >= 3,\n        \"insufficient messages received: a={count_a}, b={count_b}\"\n    );\n    log_step!(\n        \"--- test_peer_connection_stability_bidirectional end (counts a={}, b={}) ---\",\n        count_a,\n        count_b\n    );\n}\n\n/// 二ノード間でのブロードキャスト配送を検証する\n#[tokio::test]\nasync fn test_two_nodes_broadcast_and_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_broadcast_and_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_broadcast_and_receive start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let (tx_a, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a.subscribe();\n    let (tx_b, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b.subscribe();\n    svc_a.set_event_sender(tx_a);\n    svc_b.set_event_sender(tx_b);\n\n    let topic = generate_topic_id(\"iroh-int-recv\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let _rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"services joined topic {}, waiting for peer events\", topic);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed, continuing after grace period\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"sending broadcast message on topic {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-int\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"receive timeout\");\n    assert!(r.is_some());\n    assert_eq!(r.unwrap().content, \"hello-int\");\n    log_step!(\"--- test_two_nodes_broadcast_and_receive end ---\");\n}\n\n/// 複数購読者が同一トピックのイベントを受け取れることを検証\n#[tokio::test]\nasync fn test_multiple_subscribers_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multiple_subscribers_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_multiple_subscribers_receive start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-subs\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx1 = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx2 = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting multi-subscriber event on {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-multi\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r1 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx1.recv().await })\n        .await\n        .expect(\"rx1 timeout\");\n    let r2 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx2.recv().await })\n        .await\n        .expect(\"rx2 timeout\");\n\n    assert!(r1.is_some() && r2.is_some());\n    assert_eq!(r1.unwrap().content, \"hello-multi\");\n    assert_eq!(r2.unwrap().content, \"hello-multi\");\n    log_step!(\"--- test_multiple_subscribers_receive end ---\");\n}\n\n/// P2P経路のみで返信イベントが伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_reply_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_reply_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_reply_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-reply-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for reply flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"reply-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let root_id = base_event.id.clone();\n    let root_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending reply\");\n\n    let reply_event_tag = Tag::from_standardized(TagStandard::Event {\n        event_id: base_note.id,\n        relay_url: None,\n        marker: Some(Marker::Reply),\n        public_key: None,\n        uppercase: false,\n    });\n    let reply_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let reply_keys = Keys::generate();\n    let reply_note = EventBuilder::text_note(\"reply-post\")\n        .tags([reply_event_tag, reply_pubkey_tag])\n        .sign_with_keys(&reply_keys)\n        .unwrap();\n\n    let reply_event = nostr_to_domain(&reply_note);\n    svc_b.broadcast(&topic, &reply_event).await.unwrap();\n\n    let received_reply = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"reply receive timeout\")\n        .expect(\"reply channel closed\");\n    assert_eq!(received_reply.content, \"reply-post\");\n\n    let e_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"e\"))\n        .expect(\"reply event missing e tag\");\n    assert_eq!(e_tag.get(1).map(|s| s.as_str()), Some(root_id.as_str()));\n    assert_eq!(e_tag.get(3).map(|s| s.as_str()), Some(\"reply\"));\n\n    let p_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"reply event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(root_pubkey.as_str()));\n    log_step!(\"--- test_p2p_reply_flow end ---\");\n}\n\n/// P2P経路のみで引用イベント（mention）が伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_quote_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_quote_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_quote_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-quote-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, _) = broadcast::channel(64);\n    let mut rx_a_evt = tx_a_evt.subscribe();\n    let (tx_b_evt, _) = broadcast::channel(64);\n    let mut rx_b_evt = tx_b_evt.subscribe();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for quote flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"quote-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let base_id = base_event.id.clone();\n    let base_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending quote\");\n\n    let quote_tag = Tag::from_standardized(TagStandard::Quote {\n        event_id: base_note.id,\n        relay_url: None,\n        public_key: None,\n    });\n    let quote_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let quote_keys = Keys::generate();\n    let quote_note = EventBuilder::text_note(\"quote-post\")\n        .tags([quote_tag, quote_pubkey_tag])\n        .sign_with_keys(&quote_keys)\n        .unwrap();\n    let quote_event = nostr_to_domain(&quote_note);\n    svc_b.broadcast(&topic, &quote_event).await.unwrap();\n\n    let received_quote = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"quote receive timeout\")\n        .expect(\"quote channel closed\");\n    assert_eq!(received_quote.content, \"quote-post\");\n\n    let q_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"q\"))\n        .expect(\"quote event missing q tag\");\n    assert_eq!(q_tag.get(1).map(|s| s.as_str()), Some(base_id.as_str()));\n\n    let p_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"quote event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(base_pubkey.as_str()));\n    log_step!(\"--- test_p2p_quote_flow end ---\");\n}\n\n/// 3ノード構成でA->(B,C)へブロードキャストが届くことを検証\n#[tokio::test]\nasync fn test_multi_node_broadcast_three_nodes() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multi_node_broadcast_three_nodes\") else {\n        return;\n    };\n    log_step!(\"--- test_multi_node_broadcast_three_nodes start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n    let svc_c = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-node\");\n    let local_hints = vec![\n        svc_a.local_peer_hint(),\n        svc_b.local_peer_hint(),\n        svc_c.local_peer_hint(),\n    ];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n    let hints_c = build_peer_hints(&ctx.hints, &local_hints, 2);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n    svc_c.join_topic(&topic, hints_c).await.unwrap();\n    log_step!(\"svc_c joined {}\", topic);\n\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx_c = svc_c.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_c, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_c failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    log_step!(\"all nodes joined topic {}\", topic);\n\n    sleep(Duration::from_secs(1)).await;\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-3nodes\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r_b = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"B receive timeout\");\n    let r_c = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_c.recv().await })\n        .await\n        .expect(\"C receive timeout\");\n\n    assert!(r_b.is_some() && r_c.is_some());\n    assert_eq!(r_b.unwrap().content, \"hello-3nodes\");\n    assert_eq!(r_c.unwrap().content, \"hello-3nodes\");\n    log_step!(\"--- test_multi_node_broadcast_three_nodes end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_mainline_smoke.rs"],"content":"use chrono::Utc;\nuse iroh::SecretKey;\nuse kukuri_lib::test_support::application::services::p2p_service::P2PService;\nuse kukuri_lib::test_support::infrastructure::p2p::{\n    DiscoveryOptions, NetworkService, gossip_service::GossipService,\n};\nuse kukuri_lib::test_support::shared::config::{AppConfig, NetworkConfig as AppNetworkConfig};\nuse rand::{RngCore, SeedableRng, rngs::StdRng};\nuse std::sync::Arc;\nuse tokio::time::{Duration, Instant, sleep};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        eprintln!(\"[p2p_mainline_smoke] {}\", format!($($arg)*));\n    }};\n}\n\nstruct MainlineContext {\n    hints: Vec<String>,\n    network_config: AppNetworkConfig,\n}\n\nfn prepare_context(test_name: &str) -> Option<MainlineContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\n        return None;\n    }\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    let hints: Vec<String> = raw\n        .split(',')\n        .map(|s| s.trim().to_string())\n        .filter(|s| !s.is_empty())\n        .collect();\n    if hints.is_empty() {\n        eprintln!(\"skipping {test_name} (KUKURI_BOOTSTRAP_PEERS not set)\");\n        return None;\n    }\n\n    let app_cfg = AppConfig::from_env();\n    let mut network_config = app_cfg.network.clone();\n    if network_config.bootstrap_peers.is_empty() {\n        network_config.bootstrap_peers = hints.clone();\n    }\n    network_config.enable_dht = true;\n    network_config.enable_dns = false;\n    network_config.enable_local = true;\n\n    Some(MainlineContext {\n        hints,\n        network_config,\n    })\n}\n\nfn random_secret(rng: &mut StdRng) -> SecretKey {\n    let mut bytes = [0u8; 32];\n    rng.fill_bytes(&mut bytes);\n    SecretKey::from_bytes(&bytes)\n}\n\nasync fn wait_for_bootstrap_peer(\n    service: &Arc<dyn NetworkService>,\n    min_peers: usize,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Ok(peers) = service.get_peers().await {\n            if peers.len() >= min_peers {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\nasync fn wait_for_local_peer_hint(\n    service: &Arc<dyn GossipService>,\n    deadline: Duration,\n) -> Option<String> {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Some(hint) = service.local_peer_hint() {\n            return Some(hint);\n        }\n        sleep(Duration::from_millis(150)).await;\n    }\n    None\n}\n\nasync fn wait_for_topic_membership(\n    service: &Arc<dyn GossipService>,\n    topic: &str,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        match service.get_joined_topics().await {\n            Ok(joined) if joined.iter().any(|t| t == topic) => return true,\n            Ok(_) => {}\n            Err(err) => {\n                log_step!(\"get_joined_topics error for {}: {:?}\", topic, err);\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\n#[tokio::test]\nasync fn test_mainline_dht_handshake_and_routing() {\n    let Some(ctx) = prepare_context(\"test_mainline_dht_handshake_and_routing\") else {\n        return;\n    };\n    log_step!(\"--- mainline handshake start ---\");\n\n    let discovery = DiscoveryOptions::new(false, true, true);\n\n    let mut thread_rng = rand::rng();\n    let mut rng = StdRng::from_rng(&mut thread_rng);\n    let secret_a = random_secret(&mut rng);\n    let secret_b = random_secret(&mut rng);\n\n    let stack_a = P2PService::builder(secret_a, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack A\");\n    let stack_b = P2PService::builder(secret_b, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack B\");\n\n    stack_a\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network A\");\n    stack_b\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network B\");\n\n    assert!(\n        wait_for_bootstrap_peer(&stack_a.network_service, 1, Duration::from_secs(20)).await,\n        \"A failed to discover bootstrap peer via mainline DHT\"\n    );\n    assert!(\n        wait_for_bootstrap_peer(&stack_b.network_service, 1, Duration::from_secs(20)).await,\n        \"B failed to discover bootstrap peer via mainline DHT\"\n    );\n\n    let hint_a = wait_for_local_peer_hint(&stack_a.gossip_service, Duration::from_secs(5)).await;\n    let hint_b = wait_for_local_peer_hint(&stack_b.gossip_service, Duration::from_secs(5)).await;\n\n    let mut hints_for_a = ctx.hints.clone();\n    let mut hints_for_b = ctx.hints.clone();\n    if let Some(h) = &hint_b {\n        hints_for_a.push(h.clone());\n    }\n    if let Some(h) = &hint_a {\n        hints_for_b.push(h.clone());\n    }\n    hints_for_a.sort();\n    hints_for_a.dedup();\n    hints_for_b.sort();\n    hints_for_b.dedup();\n\n    let topic_seed = format!(\n        \"mainline-handshake-routing-{}\",\n        Utc::now().timestamp_nanos_opt().unwrap_or_default()\n    );\n    let topic_id = stack_a.p2p_service.generate_topic_id(&topic_seed);\n\n    stack_a\n        .p2p_service\n        .join_topic(&topic_id, hints_for_a.clone())\n        .await\n        .expect(\"join topic on A\");\n    stack_b\n        .p2p_service\n        .join_topic(&topic_id, hints_for_b.clone())\n        .await\n        .expect(\"join topic on B\");\n\n    assert!(\n        wait_for_topic_membership(&stack_a.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"A did not observe topic membership via DHT routing\"\n    );\n    assert!(\n        wait_for_topic_membership(&stack_b.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"B did not observe topic membership via DHT routing\"\n    );\n\n    let stats_a = stack_a\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from A\");\n    assert!(\n        stats_a.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    let stats_b = stack_b\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from B\");\n    assert!(\n        stats_b.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    stack_a\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic A\");\n    stack_b\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic B\");\n\n    log_step!(\"--- mainline handshake end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance","cache.rs"],"content":"use std::time::Instant;\n\nuse super::performance_common::{\n    offline_seed::seed_cache_metadata,\n    offline_support::{\n        OfflineTestContext, TEST_PUBKEY_HEX, build_params_for_index, setup_offline_service,\n    },\n    recorder::{PerformanceRecorder, duration_secs},\n};\nuse anyhow::{Result, anyhow};\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait,\n};\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse tokio::time::{Duration, sleep};\n\n#[tokio::test]\n#[ignore]\nasync fn offline_action_save_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 200;\n    let OfflineTestContext { service, pool: _ } = setup_offline_service().await;\n\n    let save_started = Instant::now();\n    for index in 0..ACTION_COUNT {\n        service.save_action(build_params_for_index(index)).await?;\n    }\n    let save_elapsed = save_started.elapsed();\n    let user_pubkey = PublicKey::from_hex_str(TEST_PUBKEY_HEX).map_err(|err| anyhow!(err))?;\n    let list_started = Instant::now();\n    let records = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(user_pubkey),\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await?;\n    let list_elapsed = list_started.elapsed();\n\n    let save_secs = duration_secs(save_elapsed);\n    let list_secs = duration_secs(list_elapsed);\n\n    PerformanceRecorder::new(\"offline_action_save_throughput\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"save_total_ms\", save_secs * 1_000.0)\n        .metric(\"save_throughput_per_sec\", ACTION_COUNT as f64 / save_secs)\n        .metric(\"list_total_ms\", list_secs * 1_000.0)\n        .metric(\"list_throughput_per_sec\", records.len() as f64 / list_secs)\n        .note(\n            \"description\",\n            \"OfflineService::save_action and list_actions against in-memory SQLite\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(records.len(), ACTION_COUNT);\n    Ok(())\n}\n\n#[tokio::test]\n#[ignore]\nasync fn cache_cleanup_latency() -> Result<()> {\n    const CACHE_ENTRIES: usize = 50;\n    let OfflineTestContext { service, .. } = setup_offline_service().await;\n    seed_cache_metadata(&service, CACHE_ENTRIES).await?;\n\n    // expiry values are 1-3 seconds; wait long enough for at least two buckets.\n    sleep(Duration::from_secs(4)).await;\n\n    let cleanup_started = Instant::now();\n    let removed = service.cleanup_expired_cache().await?;\n    let cleanup_elapsed = cleanup_started.elapsed();\n    let cleanup_secs = duration_secs(cleanup_elapsed);\n\n    PerformanceRecorder::new(\"offline_cache_cleanup_latency\")\n        .iterations(CACHE_ENTRIES as u64)\n        .metric(\"removed_entries\", removed as f64)\n        .metric(\"cleanup_total_ms\", cleanup_secs * 1_000.0)\n        .metric(\"cleanup_throughput_per_sec\", removed as f64 / cleanup_secs)\n        .note(\n            \"description\",\n            \"OfflineService::cleanup_expired_cache after staged expiry seeding\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance","sync.rs"],"content":"use std::{sync::Arc, time::Instant};\n\nuse super::performance_common::{\n    offline_seed::seed_offline_actions,\n    offline_support::{OfflineTestContext, TEST_PUBKEY_HEX, setup_offline_service},\n    recorder::{PerformanceRecorder, duration_secs},\n};\nuse anyhow::{Result, anyhow};\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\nuse kukuri_lib::test_support::application::services::offline_service::OfflineServiceTrait;\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::test_support::infrastructure::offline::{\n    OfflineReindexJob, SqliteOfflinePersistence,\n};\nuse sqlx::Row;\n\n#[tokio::test]\n#[ignore]\nasync fn offline_reindex_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 120;\n\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n    seed_offline_actions(&service, ACTION_COUNT).await?;\n\n    let persistence: Arc<dyn OfflinePersistence> =\n        Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    let job = OfflineReindexJob::with_emitter(None, persistence);\n\n    let started = Instant::now();\n    let report = job.reindex_once().await?;\n    let elapsed = started.elapsed();\n    let secs = duration_secs(elapsed);\n\n    PerformanceRecorder::new(\"offline_reindex_once\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"duration_ms\", secs * 1_000.0)\n        .metric(\"actions_per_sec\", report.offline_action_count as f64 / secs)\n        .metric(\"queued_actions\", report.queued_action_count as f64)\n        .metric(\"pending_queue\", report.pending_queue_count as f64)\n        .note(\n            \"description\",\n            \"OfflineReindexJob::reindex_once after seeding offline actions\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(report.offline_action_count as usize, ACTION_COUNT);\n    Ok(())\n}\n\n#[tokio::test]\n#[ignore]\nasync fn offline_sync_actions_throughput() -> Result<()> {\n    const ACTION_COUNT: usize = 120;\n\n    let OfflineTestContext { service, pool } = setup_offline_service().await;\n    seed_offline_actions(&service, ACTION_COUNT).await?;\n\n    let user_pubkey = PublicKey::from_hex_str(TEST_PUBKEY_HEX).map_err(|err| anyhow!(err))?;\n    let started = Instant::now();\n    let result = service.sync_actions(user_pubkey).await?;\n    let elapsed = started.elapsed();\n    let secs = duration_secs(elapsed);\n\n    PerformanceRecorder::new(\"offline_sync_actions\")\n        .iterations(ACTION_COUNT as u64)\n        .metric(\"duration_ms\", secs * 1_000.0)\n        .metric(\"synced_count\", result.synced_count as f64)\n        .metric(\"failed_count\", result.failed_count as f64)\n        .metric(\"throughput_per_sec\", result.synced_count as f64 / secs)\n        .note(\n            \"description\",\n            \"OfflineService::sync_actions with seeded offline queue entries\",\n        )\n        .note(\n            \"environment\",\n            std::env::var(\"CI\").unwrap_or_else(|_| \"local\".into()),\n        )\n        .write()?;\n\n    assert_eq!(result.synced_count as usize, ACTION_COUNT);\n    assert_eq!(result.failed_count, 0);\n\n    let queue_count: i64 = sqlx::query(\"SELECT COUNT(*) FROM sync_queue\")\n        .fetch_one(&pool)\n        .await?\n        .get(0);\n    assert_eq!(queue_count as usize, ACTION_COUNT);\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance.rs"],"content":"#[path = \"common/performance/mod.rs\"]\nmod performance_common;\n\n#[path = \"performance/cache.rs\"]\nmod cache;\n#[path = \"performance/sync.rs\"]\nmod sync;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","profile_avatar_sync.rs"],"content":"use kukuri_lib::test_support::application::services::{\n    ProfileAvatarService, UploadProfileAvatarInput,\n};\nuse kukuri_lib::test_support::domain::entities::ProfileAvatarAccessLevel;\n\n#[tokio::test]\nasync fn profile_avatar_sync_between_nodes() {\n    let node1_dir = tempfile::tempdir().expect(\"node1 dir\");\n    let node2_dir = tempfile::tempdir().expect(\"node2 dir\");\n\n    let service_a = ProfileAvatarService::new(node1_dir.path().to_path_buf())\n        .await\n        .expect(\"service a\");\n    let service_b = ProfileAvatarService::new(node2_dir.path().to_path_buf())\n        .await\n        .expect(\"service b\");\n\n    let npub = \"npub1syncavatar\".to_string();\n    let avatar_bytes: Vec<u8> = (0..128).collect();\n\n    let upload_entry = service_a\n        .upload_avatar(UploadProfileAvatarInput {\n            npub: npub.clone(),\n            bytes: avatar_bytes.clone(),\n            format: \"image/png\".to_string(),\n            access_level: ProfileAvatarAccessLevel::ContactsOnly,\n        })\n        .await\n        .expect(\"upload\");\n\n    let package = service_a\n        .export_sync_package(&npub)\n        .await\n        .expect(\"export\")\n        .expect(\"package\");\n\n    let imported_entry = service_b\n        .import_sync_package(package)\n        .await\n        .expect(\"import\");\n\n    assert_eq!(upload_entry.blob_hash, imported_entry.blob_hash);\n    assert_eq!(upload_entry.version, imported_entry.version);\n    assert_eq!(upload_entry.share_ticket, imported_entry.share_ticket);\n\n    let fetched = service_b.fetch_avatar(&npub).await.expect(\"fetch on node2\");\n\n    assert_eq!(fetched.bytes, avatar_bytes);\n    assert_eq!(fetched.metadata.blob_hash, upload_entry.blob_hash);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","event_service","mod.rs"],"content":"﻿#[path = \"../../../common/mod.rs\"]\r\nmod common;\r\n\r\nuse std::sync::Arc;\r\n\r\nuse common::mocks::{\r\n    MockEventDist, MockEventGateway, MockEventRepo, MockSignatureServ, MockSubscriptionInvokerMock,\r\n    MockSubscriptionStateMock,\r\n};\r\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::event_service::EventService;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse kukuri_lib::domain::entities::Event;\r\nuse kukuri_lib::infrastructure::crypto::SignatureService;\r\nuse kukuri_lib::infrastructure::database::EventRepository;\r\nuse kukuri_lib::infrastructure::p2p::EventDistributor;\r\nuse kukuri_lib::shared::error::AppError;\r\nuse mockall::predicate::*;\r\n\r\nfn create_test_event() -> Event {\r\n    Event::new(1, \"Test content\".into(), \"test_pubkey\".into())\r\n}\r\n\r\nfn service_with_state(\r\n    repo: MockEventRepo,\r\n    signature: MockSignatureServ,\r\n    distributor: MockEventDist,\r\n    state: MockSubscriptionStateMock,\r\n    gateway: MockEventGateway,\r\n) -> EventService {\r\n    EventService::new(\r\n        Arc::new(repo) as Arc<dyn EventRepository>,\r\n        Arc::new(signature) as Arc<dyn SignatureService>,\r\n        Arc::new(distributor) as Arc<dyn EventDistributor>,\r\n        Arc::new(gateway)\r\n            as Arc<dyn kukuri_lib::application::ports::event_gateway::EventGateway>,\r\n        Arc::new(state) as Arc<dyn SubscriptionStateStore>,\r\n    )\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_event_success() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let event = service\r\n        .create_event(\r\n            1,\r\n            \"Test content\".to_string(),\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"create_event should succeed\");\r\n\r\n    assert_eq!(event.content, \"Test content\");\r\n    assert_eq!(event.pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_valid_signature() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(true));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_handle_incoming_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_invalid_signature() {\r\n    let mock_repo = MockEventRepo::new();\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(false));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_err());\r\n    assert!(\r\n        result\r\n            .unwrap_err()\r\n            .to_string()\r\n            .contains(\"Invalid event signature\")\r\n    );\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_requires_ids() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(Vec::new(), None)\r\n        .await\r\n        .expect_err(\"empty ids should result in validation error\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError { .. }));\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_with_invalid_id() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(vec![\"invalid\".to_string()], None)\r\n        .await\r\n        .expect_err(\"invalid id should fail\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError { .. }));\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_gateway_failure_maps_to_nostr_error() {\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_delete_events()\r\n        .times(1)\r\n        .returning(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let valid_id = format!(\"{:064x}\", 1);\r\n    let err = service\r\n        .delete_events(vec![valid_id], Some(\"cleanup\".to_string()))\r\n        .await\r\n        .expect_err(\"gateway failure should map to nostr error\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let event = create_test_event();\r\n    let cloned = event.clone();\r\n\r\n    mock_repo\r\n        .expect_get_event()\r\n        .with(eq(\"test_id\"))\r\n        .times(1)\r\n        .returning(move |_| Ok(Some(cloned.clone())));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_event(\"test_id\")\r\n        .await\r\n        .expect(\"get_event should succeed\");\r\n\r\n    assert!(fetched.is_some());\r\n    assert_eq!(fetched.unwrap().content, \"Test content\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_kind() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_kind()\r\n        .with(eq(1u32), eq(10usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_kind(1, 10)\r\n        .await\r\n        .expect(\"get_events_by_kind should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_author() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_author()\r\n        .with(eq(\"test_pubkey\"), eq(5usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_author(\"test_pubkey\", 5)\r\n        .await\r\n        .expect(\"get_events_by_author should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 1);\r\n    assert_eq!(fetched[0].pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n    mock_repo\r\n        .expect_delete_event()\r\n        .with(eq(\"event_to_delete\"))\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    service\r\n        .delete_event(\r\n            \"event_to_delete\",\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"delete_event should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_sync_pending_events() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_unsync_events()\r\n        .times(1)\r\n        .returning(move || Ok(cloned.clone()));\r\n\r\n    mock_repo\r\n        .expect_mark_event_synced()\r\n        .times(events.len())\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(events.len())\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let synced = service\r\n        .sync_pending_events()\r\n        .await\r\n        .expect(\"sync_pending_events should succeed\");\r\n\r\n    assert_eq!(synced, 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_uses_state_machine_and_invoker() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .withf(|target| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(1)\r\n        .withf(|target, _| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect(\"subscribe_to_topic should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_failure_marks_state() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_failure()\r\n        .times(1)\r\n        .withf(|target, message| {\r\n            matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\")\r\n                && message.contains(\"failed\")\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .return_once(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    let err = service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect_err(\"subscription failure should bubble up\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_handle_network_connected_restores_subscriptions() {\r\n    let topic_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::NeedsResync,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n    let user_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::User(\"user\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: Some(3600),\r\n        last_attempt_at: None,\r\n        failure_count: 1,\r\n        error_message: Some(\"previous failure\".into()),\r\n    };\r\n    let list_topic = topic_record.clone();\r\n    let list_user = user_record.clone();\r\n    let predicate_user = user_record.clone();\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_list_for_restore()\r\n        .times(1)\r\n        .return_once(move || Ok(vec![list_topic, list_user]));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(2)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n    mock_invoker\r\n        .expect_subscribe_user()\r\n        .times(1)\r\n        .withf(move |pubkey, since| {\r\n            pubkey == \"user\"\r\n                && since.map(|ts| ts.as_secs())\n                    == predicate_user\r\n                        .last_synced_at\r\n                        .map(|value| (value - 300) as u64)\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .handle_network_connected()\r\n        .await\r\n        .expect(\"handle_network_connected should succeed\");\r\n}\r\n\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","mod.rs"],"content":"mod event_service;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","mod.rs"],"content":"mod application;\n","traces":[],"covered":0,"coverable":0}],"coverage":40.945665698880134,"covered":4936,"coverable":12055}