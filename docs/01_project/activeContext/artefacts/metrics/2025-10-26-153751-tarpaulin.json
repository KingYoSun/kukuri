{"files":[{"path":["/","app","kukuri-tauri","src-tauri","benches","command_optimization.rs"],"content":"use criterion::{BenchmarkId, Criterion, black_box, criterion_group, criterion_main};\nuse tokio::runtime::Runtime;\n\nfn benchmark_single_vs_batch_posts(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    let mut group = c.benchmark_group(\"post_retrieval\");\n\n    // 10, 50, 100個の投稿IDでテスト\n    for size in [10, 50, 100].iter() {\n        let post_ids: Vec<String> = (0..*size).map(|i| format!(\"post_{}\", i)).collect();\n\n        group.bench_with_input(BenchmarkId::new(\"individual\", size), size, |b, _| {\n            b.to_async(&rt).iter(|| async {\n                // 個別取得のシミュレーション\n                for id in &post_ids {\n                    // DBアクセスのシミュレーション\n                    tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\n                }\n            });\n        });\n\n        group.bench_with_input(BenchmarkId::new(\"batch\", size), size, |b, _| {\n            b.to_async(&rt).iter(|| async {\n                // バッチ取得のシミュレーション\n                tokio::time::sleep(tokio::time::Duration::from_micros(200)).await;\n            });\n        });\n    }\n\n    group.finish();\n}\n\nfn benchmark_cache_vs_no_cache(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    let mut group = c.benchmark_group(\"cache_performance\");\n\n    group.bench_function(\"without_cache\", |b| {\n        b.to_async(&rt).iter(|| async {\n            // DBアクセスのシミュレーション\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await;\n            black_box(\"post_content\");\n        });\n    });\n\n    group.bench_function(\"with_cache_miss\", |b| {\n        b.to_async(&rt).iter(|| async {\n            // キャッシュチェック + DBアクセス\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await; // キャッシュチェック\n            tokio::time::sleep(tokio::time::Duration::from_micros(500)).await; // DBアクセス\n            black_box(\"post_content\");\n        });\n    });\n\n    group.bench_function(\"with_cache_hit\", |b| {\n        b.to_async(&rt).iter(|| async {\n            // キャッシュヒット（DBアクセスなし）\n            tokio::time::sleep(tokio::time::Duration::from_micros(10)).await;\n            black_box(\"cached_post_content\");\n        });\n    });\n\n    group.finish();\n}\n\nfn benchmark_parallel_npub_conversion(c: &mut Criterion) {\n    use nostr_sdk::prelude::*;\n    let rt = Runtime::new().unwrap();\n\n    let mut group = c.benchmark_group(\"npub_conversion\");\n\n    let pubkeys: Vec<String> = (0..100)\n        .map(|i| {\n            format!(\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa{:03}\",\n                i\n            )\n        })\n        .collect();\n\n    group.bench_function(\"serial\", |b| {\n        b.iter(|| {\n            for pubkey in &pubkeys {\n                let _ = PublicKey::from_hex(pubkey)\n                    .ok()\n                    .and_then(|pk| pk.to_bech32().ok())\n                    .unwrap_or_else(|| pubkey.clone());\n            }\n        });\n    });\n\n    group.bench_function(\"parallel\", |b| {\n        b.to_async(&rt).iter(|| async {\n            use futures::future::join_all;\n\n            let futures = pubkeys.iter().map(|pubkey| {\n                let pk = pubkey.clone();\n                async move {\n                    tokio::task::spawn_blocking(move || {\n                        PublicKey::from_hex(&pk)\n                            .ok()\n                            .and_then(|pk| pk.to_bech32().ok())\n                            .unwrap_or(pk)\n                    })\n                    .await\n                    .unwrap_or_else(|_| pubkey.clone())\n                }\n            });\n\n            let _ = join_all(futures).await;\n        });\n    });\n\n    group.finish();\n}\n\nfn benchmark_handler_reuse(c: &mut Criterion) {\n    let rt = Runtime::new().unwrap();\n\n    let mut group = c.benchmark_group(\"handler_initialization\");\n\n    group.bench_function(\"new_handler_each_time\", |b| {\n        b.to_async(&rt).iter(|| async {\n            // ハンドラーを毎回生成（最適化前）\n            tokio::time::sleep(tokio::time::Duration::from_micros(50)).await;\n            black_box(\"handler_created\");\n        });\n    });\n\n    group.bench_function(\"reused_handler\", |b| {\n        b.to_async(&rt).iter(|| async {\n            // ハンドラーを再利用（最適化後）\n            tokio::time::sleep(tokio::time::Duration::from_micros(1)).await;\n            black_box(\"handler_reused\");\n        });\n    });\n\n    group.finish();\n}\n\ncriterion_group!(\n    benches,\n    benchmark_single_vs_batch_posts,\n    benchmark_cache_vs_no_cache,\n    benchmark_parallel_npub_conversion,\n    benchmark_handler_reuse\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","build.rs"],"content":"fn main() {\n    tauri_build::build();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","mod.rs"],"content":"#![allow(dead_code)]\n\npub mod ports;\npub mod services;\npub mod shared;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","event_gateway.rs"],"content":"use crate::domain::entities::{DomainEvent, ProfileMetadata};\nuse crate::domain::value_objects::{EventId, PublicKey, ReactionValue, TopicContent, TopicId};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n/// EventManager などの具体実装に依存せず、Application 層からイベント配信を扱うためのポート。\n///\n/// 設計ドキュメント: `docs/01_project/activeContext/artefacts/phase5_event_gateway_design.md`\n#[async_trait]\npub trait EventGateway: Send + Sync {\n    /// P2P や Gossip など外部ソースから受信したイベントを処理する。\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\n\n    /// 自身のノードとしてテキストノートを発行する。\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n\n    /// トピックに紐づく投稿を公開する。`reply_to` によりスレッド返信を指示できる。\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n    ) -> Result<EventId, AppError>;\n\n    /// 任意イベントへリアクションを送信する。\n    async fn send_reaction(\n        &self,\n        target: &EventId,\n        reaction: &ReactionValue,\n    ) -> Result<EventId, AppError>;\n\n    /// プロフィールメタデータを更新し、新しいイベント ID を返却する。\n    async fn update_profile_metadata(\n        &self,\n        metadata: &ProfileMetadata,\n    ) -> Result<EventId, AppError>;\n\n    /// 指定されたイベント群を削除し、削除イベントの ID を返却する。\n    async fn delete_events(\n        &self,\n        targets: &[EventId],\n        reason: Option<&str>,\n    ) -> Result<EventId, AppError>;\n\n    /// ネットワーク接続を切断する。\n    async fn disconnect(&self) -> Result<(), AppError>;\n\n    /// ノードが利用する公開鍵を取得する。\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\n\n    /// 既定の購読トピックを更新する。\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\n\n    /// 既定の購読トピックを一覧する。\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","key_manager.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyPair {\n    pub public_key: String,\n    pub private_key: String,\n    pub npub: String,\n    pub nsec: String,\n}\n\n#[async_trait]\npub trait KeyManager: Send + Sync {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError>;\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError>;\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError>;\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError>;\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError>;\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError>;\n    async fn current_keypair(&self) -> Result<KeyPair, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","mod.rs"],"content":"pub mod event_gateway;\npub mod key_manager;\npub mod offline_store;\npub mod secure_storage;\npub mod subscription_invoker;\npub mod subscription_state_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","offline_store.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft, OfflineActionFilter,\n    OfflineActionRecord, OptimisticUpdateDraft, SavedOfflineAction, SyncQueueItemDraft, SyncResult,\n    SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait OfflinePersistence: Send + Sync {\n    async fn save_action(&self, draft: OfflineActionDraft) -> Result<SavedOfflineAction, AppError>;\n\n    async fn list_actions(\n        &self,\n        filter: OfflineActionFilter,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","secure_storage.rs"],"content":"use crate::domain::entities::{AccountMetadata, AccountRegistration, CurrentAccountSecret};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SecureAccountStore: Send + Sync {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError>;\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError>;\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError>;\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError>;\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError>;\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_invoker.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\n\n/// 購読復元や加入リクエストを実行するためのポート。\n///\n/// EventService など Application 層はこの trait を通じて購読処理を発行し、\n/// 具体的な実装（EventManager など）は Infrastructure 層に閉じ込める。\n#[async_trait]\npub trait SubscriptionInvoker: Send + Sync {\n    /// 指定トピックに対する購読を開始する。\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError>;\n\n    /// 指定ユーザー（公開鍵）に対する購読を開始する。\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","ports","subscription_state_repository.rs"],"content":"use crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SubscriptionStateRepository: Send + Sync {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError>;\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError>;\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","auth_service.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::domain::entities::User;\nuse crate::infrastructure::storage::SecureStorage;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct AuthStatus {\n    pub is_authenticated: bool,\n    pub current_user: Option<User>,\n    pub npub: Option<String>,\n}\n\npub struct AuthService {\n    key_manager: Arc<dyn KeyManager>,\n    secure_storage: Arc<dyn SecureStorage>,\n    user_service: Arc<super::UserService>,\n    topic_service: Arc<super::TopicService>,\n}\n\nimpl AuthService {\n    pub fn new(\n        key_manager: Arc<dyn KeyManager>,\n        secure_storage: Arc<dyn SecureStorage>,\n        user_service: Arc<super::UserService>,\n        topic_service: Arc<super::TopicService>,\n    ) -> Self {\n        Self {\n            key_manager,\n            secure_storage,\n            user_service,\n            topic_service,\n        }\n    }\n\n    pub async fn create_account(&self) -> Result<User, AppError> {\n        // Generate new keypair\n        let keypair = self.key_manager.generate_keypair().await?;\n\n        // Store securely\n        self.key_manager.store_keypair(&keypair).await?;\n        self.secure_storage\n            .store(\"current_npub\", &keypair.npub)\n            .await?;\n\n        // Create user\n        let public_key = keypair.public_key.clone();\n        let user = self\n            .user_service\n            .create_user(keypair.npub.clone(), public_key.clone())\n            .await?;\n\n        // Join public topic by default\n        self.topic_service.ensure_public_topic().await?;\n        self.topic_service.join_topic(\"public\", &public_key).await?;\n\n        Ok(user)\n    }\n\n    pub async fn login_with_nsec(&self, nsec: &str) -> Result<User, AppError> {\n        // Import private key\n        let keypair = self.key_manager.import_private_key(nsec).await?;\n\n        // Store securely\n        self.key_manager.store_keypair(&keypair).await?;\n        self.secure_storage\n            .store(\"current_npub\", &keypair.npub)\n            .await?;\n\n        let public_key = keypair.public_key.clone();\n        // Get or create user\n        let user = match self.user_service.get_user(&keypair.npub).await? {\n            Some(user) => user,\n            None => {\n                self.user_service\n                    .create_user(keypair.npub.clone(), public_key.clone())\n                    .await?\n            }\n        };\n\n        // Join public topic by default\n        self.topic_service.ensure_public_topic().await?;\n        self.topic_service.join_topic(\"public\", &public_key).await?;\n\n        Ok(user)\n    }\n\n    pub async fn login_with_npub(&self, npub: &str) -> Result<User, AppError> {\n        // Check if we have the private key stored\n        let _private_key = self.key_manager.export_private_key(npub).await?;\n\n        // Get user\n        let user = self\n            .user_service\n            .get_user(npub)\n            .await?\n            .ok_or(\"User not found\")?;\n\n        self.secure_storage.store(\"current_npub\", npub).await?;\n\n        Ok(user)\n    }\n\n    pub async fn logout(&self) -> Result<(), AppError> {\n        self.secure_storage.delete(\"current_npub\").await?;\n        Ok(())\n    }\n\n    pub async fn get_current_user(&self) -> Result<Option<User>, AppError> {\n        if let Some(npub) = self.secure_storage.retrieve(\"current_npub\").await? {\n            self.user_service.get_user(&npub).await\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn is_authenticated(&self) -> bool {\n        self.secure_storage\n            .retrieve(\"current_npub\")\n            .await\n            .unwrap_or(None)\n            .is_some()\n    }\n\n    pub async fn get_auth_status(&self) -> Result<AuthStatus, AppError> {\n        let current_user = self.get_current_user().await?;\n        let npub = self.secure_storage.retrieve(\"current_npub\").await?;\n\n        Ok(AuthStatus {\n            is_authenticated: current_user.is_some(),\n            current_user,\n            npub,\n        })\n    }\n\n    pub async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        self.key_manager.export_private_key(npub).await\n    }\n\n    pub async fn list_accounts(&self) -> Result<Vec<String>, AppError> {\n        self.key_manager.list_npubs().await\n    }\n\n    pub async fn switch_account(&self, npub: &str) -> Result<User, AppError> {\n        self.login_with_npub(npub).await\n    }\n}\n","traces":[{"line":22,"address":[12064608],"length":1,"stats":{"Line":0}},{"line":36,"address":[12064712,12065266,12064783,12064913,12064736,12064704,12065061,12066217],"length":1,"stats":{"Line":0}},{"line":38,"address":[11179988],"length":1,"stats":{"Line":0}},{"line":41,"address":[10378298],"length":1,"stats":{"Line":0}},{"line":42,"address":[12308100,12307820,12308518,12307333,12307962,12307639,12307544],"length":1,"stats":{"Line":0}},{"line":43,"address":[12066645],"length":1,"stats":{"Line":0}},{"line":44,"address":[18994664],"length":1,"stats":{"Line":0}},{"line":47,"address":[11536806],"length":1,"stats":{"Line":0}},{"line":48,"address":[15438416,15438936,15438338,15438113,15438733,15438653,15439139],"length":1,"stats":{"Line":0}},{"line":50,"address":[12067664,12067377,12067565],"length":1,"stats":{"Line":0}},{"line":51,"address":[10378342],"length":1,"stats":{"Line":0}},{"line":54,"address":[11180092],"length":1,"stats":{"Line":0}},{"line":55,"address":[14310102],"length":1,"stats":{"Line":0}},{"line":57,"address":[12069193],"length":1,"stats":{"Line":0}},{"line":60,"address":[15440226,15440208,15441837,15440886,15440256,15440318,15440665,15440496],"length":1,"stats":{"Line":0}},{"line":62,"address":[12310763,12310470,12310542,12310934,12311510,12311794],"length":1,"stats":{"Line":0}},{"line":65,"address":[14315403],"length":1,"stats":{"Line":0}},{"line":66,"address":[15443163,15442900,15442608,15442750,15442332,15442121,15442427],"length":1,"stats":{"Line":0}},{"line":67,"address":[17657457],"length":1,"stats":{"Line":0}},{"line":68,"address":[12071840,12071568,12069752,12071695,12072052,12071633],"length":1,"stats":{"Line":0}},{"line":70,"address":[12098758],"length":1,"stats":{"Line":0}},{"line":72,"address":[15444108,15442929,15443168,15440589,15443009],"length":1,"stats":{"Line":0}},{"line":73,"address":[12072871],"length":1,"stats":{"Line":0}},{"line":75,"address":[15444723,15443906,15443984,15444362,15443655,15444282,15444520],"length":1,"stats":{"Line":0}},{"line":76,"address":[12313774,12313965,12314067],"length":1,"stats":{"Line":0}},{"line":77,"address":[10971398],"length":1,"stats":{"Line":0}},{"line":82,"address":[11539415,11543816,11542857,11543512,11544051,11543397],"length":1,"stats":{"Line":0}},{"line":83,"address":[12101682,12100920,12101590,12096572,12101218,12101021],"length":1,"stats":{"Line":0}},{"line":85,"address":[12315586],"length":1,"stats":{"Line":0}},{"line":88,"address":[12316115,12315792,12315810,12317025,12316324,12315887,12316030,12315840],"length":1,"stats":{"Line":0}},{"line":90,"address":[10384639],"length":1,"stats":{"Line":0}},{"line":93,"address":[12075854,12076076,12076422,12076348,12077096,12076030,12076838,12076593,12077068],"length":1,"stats":{"Line":0}},{"line":95,"address":[12076014],"length":1,"stats":{"Line":0}},{"line":96,"address":[12316081,12317034,12317182,12316938,12317393,12316881],"length":1,"stats":{"Line":0}},{"line":99,"address":[11546366,11547093,11546698,11546528,11544870],"length":1,"stats":{"Line":0}},{"line":101,"address":[11546995],"length":1,"stats":{"Line":0}},{"line":104,"address":[12318432,12318467,12318558,12318424,12318761,12318416,12318598,12319209],"length":1,"stats":{"Line":0}},{"line":105,"address":[11133462],"length":1,"stats":{"Line":0}},{"line":106,"address":[15449045],"length":1,"stats":{"Line":0}},{"line":109,"address":[12105144,12106424,12105152,12105193,12105304,12105362,12105136,12105534],"length":1,"stats":{"Line":0}},{"line":110,"address":[12078595,12078531,12078683,12079686,12078830],"length":1,"stats":{"Line":0}},{"line":111,"address":[11548934,11549040,11548213,11549297],"length":1,"stats":{"Line":0}},{"line":113,"address":[12106327],"length":1,"stats":{"Line":0}},{"line":117,"address":[12106728,12106736,12106892,12106761,12106720,12106852,12107055,12107426],"length":1,"stats":{"Line":0}},{"line":118,"address":[15451273,15451097,15450907,15451026,15451366],"length":1,"stats":{"Line":0}},{"line":120,"address":[10392420],"length":1,"stats":{"Line":0}},{"line":121,"address":[12107278],"length":1,"stats":{"Line":0}},{"line":125,"address":[15451673,15451860,15451536,15451574,15451520,15452577,15451728,15451528],"length":1,"stats":{"Line":0}},{"line":126,"address":[12107562,12107620,12107812,12108196,12108447,12107695],"length":1,"stats":{"Line":0}},{"line":127,"address":[12108323,12107635,12108878,12108159,12108506],"length":1,"stats":{"Line":0}},{"line":129,"address":[15453145],"length":1,"stats":{"Line":0}},{"line":130,"address":[17667635],"length":1,"stats":{"Line":0}},{"line":131,"address":[15453063],"length":1,"stats":{"Line":0}},{"line":132,"address":[12109017],"length":1,"stats":{"Line":0}},{"line":136,"address":[15453344,15453990,15453296,15453314,15453505,15453379,15453705,15453545],"length":1,"stats":{"Line":0}},{"line":137,"address":[15453484,15453737,15453532,15453609],"length":1,"stats":{"Line":0}},{"line":140,"address":[12324024,12324623,12324191,12324032,12324341,12324067,12324154,12324016],"length":1,"stats":{"Line":0}},{"line":141,"address":[12083301,12083413,12083541,12083349],"length":1,"stats":{"Line":0}},{"line":144,"address":[17669347,17669312,17669497,17669880,17669264,17669460,17669282,17669608],"length":1,"stats":{"Line":0}},{"line":145,"address":[17669640,17669453,17669557,17669487],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","core.rs"],"content":"use super::distribution::distribute_hybrid;\nuse super::factory::build_deletion_event;\nuse crate::application::ports::event_gateway::EventGateway;\nuse crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::application::services::{SubscriptionRecord, SubscriptionStateStore};\nuse crate::application::shared::mappers::{\n    domain_event_from_event, dto_to_profile_metadata, parse_event_id, parse_event_ids,\n    parse_optional_event_id,\n};\nuse crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::event_gateway::{ReactionValue, TopicContent};\nuse crate::domain::value_objects::{EventId, TopicId};\nuse crate::infrastructure::crypto::SignatureService;\nuse crate::infrastructure::database::EventRepository;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::presentation::dto::event::NostrMetadataDto;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse std::sync::Arc;\n\npub struct EventService {\n    pub(crate) repository: Arc<dyn EventRepository>,\n    pub(crate) signature_service: Arc<dyn SignatureService>,\n    pub(crate) distributor: Arc<dyn EventDistributor>,\n    pub(crate) event_gateway: Arc<dyn EventGateway>,\n    pub(crate) subscription_state: Arc<dyn SubscriptionStateStore>,\n    pub(crate) subscription_invoker: Option<Arc<dyn SubscriptionInvoker>>,\n}\n\nimpl EventService {\n    pub fn new(\n        repository: Arc<dyn EventRepository>,\n        signature_service: Arc<dyn SignatureService>,\n        distributor: Arc<dyn EventDistributor>,\n        event_gateway: Arc<dyn EventGateway>,\n        subscription_state: Arc<dyn SubscriptionStateStore>,\n    ) -> Self {\n        Self {\n            repository,\n            signature_service,\n            distributor,\n            event_gateway,\n            subscription_state,\n            subscription_invoker: None,\n        }\n    }\n\n    /// Attach the subscription invoker used to execute subscriptions.\n    pub fn set_subscription_invoker(&mut self, invoker: Arc<dyn SubscriptionInvoker>) {\n        self.subscription_invoker = Some(invoker);\n    }\n\n    pub(crate) fn subscription_invoker(&self) -> Result<&Arc<dyn SubscriptionInvoker>, AppError> {\n        self.subscription_invoker\n            .as_ref()\n            .ok_or_else(|| AppError::ConfigurationError(\"Subscription invoker not set\".to_string()))\n    }\n\n    pub async fn create_event(\n        &self,\n        kind: u32,\n        content: String,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<Event, AppError> {\n        let mut event = Event::new(kind, content, pubkey);\n\n        self.signature_service\n            .sign_event(&mut event, private_key)\n            .await?;\n\n        self.repository.create_event(&event).await?;\n        distribute_hybrid(&self.distributor, &event).await?;\n\n        Ok(event)\n    }\n\n    pub async fn process_received_event(&self, event: Event) -> Result<(), AppError> {\n        if !self.signature_service.verify_event(&event).await? {\n            return Err(\"Invalid event signature\".into());\n        }\n\n        self.repository.create_event(&event).await?;\n\n        if matches!(\n            EventKind::from_u32(event.kind),\n            Some(EventKind::TextNote)\n                | Some(EventKind::Metadata)\n                | Some(EventKind::Reaction)\n                | Some(EventKind::Repost)\n        ) {\n            let domain_event = domain_event_from_event(&event)?;\n            self.event_gateway\n                .handle_incoming_event(domain_event)\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    pub async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        self.repository.get_event(id).await\n    }\n\n    pub async fn get_events_by_kind(\n        &self,\n        kind: u32,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_kind(kind, limit).await\n    }\n\n    pub async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        self.repository.get_events_by_author(pubkey, limit).await\n    }\n\n    pub async fn delete_event(\n        &self,\n        id: &str,\n        pubkey: String,\n        private_key: &str,\n    ) -> Result<(), AppError> {\n        let mut deletion_event = build_deletion_event(id, pubkey);\n\n        self.signature_service\n            .sign_event(&mut deletion_event, private_key)\n            .await?;\n        self.repository.create_event(&deletion_event).await?;\n        distribute_hybrid(&self.distributor, &deletion_event).await?;\n\n        self.repository.delete_event(id).await\n    }\n\n    pub async fn sync_pending_events(&self) -> Result<u32, AppError> {\n        let unsync_events = self.repository.get_unsync_events().await?;\n        let mut synced_count = 0;\n\n        for event in unsync_events {\n            distribute_hybrid(&self.distributor, &event).await?;\n            self.repository.mark_event_synced(&event.id).await?;\n            synced_count += 1;\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[async_trait]\npub trait EventServiceTrait: Send + Sync {\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n    ) -> Result<EventId, AppError>;\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError>;\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError>;\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError>;\n    async fn get_public_key(&self) -> Result<Option<String>, AppError>;\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError>;\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[async_trait]\nimpl EventServiceTrait for EventService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\n        self.event_gateway.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<&str>,\n    ) -> Result<EventId, AppError> {\n        let topic = TopicId::new(topic_id.to_string())\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid topic ID: {err}\")))?;\n        let topic_content = TopicContent::parse(content)\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid topic content: {err}\")))?;\n        let reply_to_id = parse_optional_event_id(reply_to)?;\n        self.event_gateway\n            .publish_topic_post(&topic, &topic_content, reply_to_id.as_ref())\n            .await\n    }\n\n    async fn send_reaction(&self, event_id: &str, reaction: &str) -> Result<EventId, AppError> {\n        let event_id = parse_event_id(event_id)?;\n        let reaction_value = ReactionValue::parse(reaction)\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid reaction value: {err}\")))?;\n        self.event_gateway\n            .send_reaction(&event_id, &reaction_value)\n            .await\n    }\n\n    async fn update_metadata(&self, metadata: NostrMetadataDto) -> Result<EventId, AppError> {\n        let profile = dto_to_profile_metadata(metadata)?;\n        self.event_gateway.update_profile_metadata(&profile).await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_topic_internal(self, topic_id).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: &str) -> Result<(), AppError> {\n        super::subscription::subscribe_to_user_internal(self, pubkey).await\n    }\n\n    async fn get_public_key(&self) -> Result<Option<String>, AppError> {\n        self.event_gateway\n            .get_public_key()\n            .await\n            .map(|key| key.map(|pk| pk.as_hex().to_string()))\n    }\n\n    async fn delete_events(\n        &self,\n        event_ids: Vec<String>,\n        reason: Option<String>,\n    ) -> Result<EventId, AppError> {\n        if event_ids.is_empty() {\n            return Err(AppError::ValidationError(\n                \"No event IDs provided\".to_string(),\n            ));\n        }\n\n        let parsed_ids = parse_event_ids(&event_ids)?;\n        let deletion_event_id = self\n            .event_gateway\n            .delete_events(&parsed_ids, reason.as_deref())\n            .await?;\n\n        for event_id in event_ids {\n            self.repository.delete_event(&event_id).await?;\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        self.event_gateway.disconnect().await\n    }\n\n    async fn set_default_p2p_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        if topic_id.is_empty() {\n            return Err(AppError::ValidationError(\n                \"Topic ID is required\".to_string(),\n            ));\n        }\n        let topic = TopicId::new(topic_id.to_string())\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid topic ID: {err}\")))?;\n        self.event_gateway\n            .set_default_topics(std::slice::from_ref(&topic))\n            .await?;\n        Ok(())\n    }\n\n    async fn list_subscriptions(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        super::subscription::list_subscriptions_internal(self).await\n    }\n}\n","traces":[{"line":31,"address":[12805616],"length":1,"stats":{"Line":0}},{"line":49,"address":[13363000,13362928],"length":1,"stats":{"Line":0}},{"line":50,"address":[18549976,18550051],"length":1,"stats":{"Line":0}},{"line":53,"address":[18550080],"length":1,"stats":{"Line":0}},{"line":54,"address":[16707168],"length":1,"stats":{"Line":0}},{"line":56,"address":[13363136,13363150],"length":1,"stats":{"Line":0}},{"line":59,"address":[18550240],"length":1,"stats":{"Line":0}},{"line":66,"address":[13577716],"length":1,"stats":{"Line":0}},{"line":68,"address":[13363797,13364444,13364303,13364173,13364607,13363994,13363929],"length":1,"stats":{"Line":0}},{"line":69,"address":[16707997],"length":1,"stats":{"Line":0}},{"line":70,"address":[13577788,13578059,13578112,13578175,13578311,13578508],"length":1,"stats":{"Line":0}},{"line":72,"address":[16708563,16708724,16709191,16708459,16709035,16707793],"length":1,"stats":{"Line":0}},{"line":73,"address":[16707814,16709648,16708996,16709196,16709525,16709101],"length":1,"stats":{"Line":0}},{"line":75,"address":[13579483],"length":1,"stats":{"Line":0}},{"line":78,"address":[18553738,18555130,18552786,18552607,18552480,18553080,18552515,18552560],"length":1,"stats":{"Line":0}},{"line":79,"address":[13579941,13580020,13580142,13580328,13580989],"length":1,"stats":{"Line":0}},{"line":80,"address":[13366559,13366639],"length":1,"stats":{"Line":0}},{"line":83,"address":[13339861,13340470,13341266,13340012,13340171,13339209],"length":1,"stats":{"Line":0}},{"line":85,"address":[13340580,13340597,13341552],"length":1,"stats":{"Line":0}},{"line":86,"address":[18554138,18553997,18554099],"length":1,"stats":{"Line":0}},{"line":92,"address":[13581519,13582076,13581595,13581782],"length":1,"stats":{"Line":0}},{"line":93,"address":[16712405,16712300,16711948,16712578,16711726,16712007,16712196],"length":1,"stats":{"Line":0}},{"line":94,"address":[16711883],"length":1,"stats":{"Line":0}},{"line":95,"address":[13341412,13339230,13341213,13341160,13341271,13341557],"length":1,"stats":{"Line":0}},{"line":98,"address":[16711462],"length":1,"stats":{"Line":0}},{"line":101,"address":[13368576,13368937,13369206,13368777,13368546,13368528,13368611,13368737],"length":1,"stats":{"Line":0}},{"line":102,"address":[18555605,18555484,18555528,18555725],"length":1,"stats":{"Line":0}},{"line":105,"address":[13369216],"length":1,"stats":{"Line":0}},{"line":110,"address":[13342778,13342906,13342654,13342702],"length":1,"stats":{"Line":0}},{"line":113,"address":[13584000],"length":1,"stats":{"Line":0}},{"line":118,"address":[18556894,18556976,18556850,18557097],"length":1,"stats":{"Line":0}},{"line":121,"address":[12813520],"length":1,"stats":{"Line":0}},{"line":127,"address":[13370999],"length":1,"stats":{"Line":0}},{"line":129,"address":[13371329,13372049,13371597,13371412,13371733,13371197,13371886],"length":1,"stats":{"Line":0}},{"line":130,"address":[18558009],"length":1,"stats":{"Line":0}},{"line":131,"address":[18558321,18558061,18558122,18557771,18558522,18558184],"length":1,"stats":{"Line":0}},{"line":132,"address":[16715901,16716005,16715172,16716471,16716628,16716166],"length":1,"stats":{"Line":0}},{"line":133,"address":[13345616,13345817,13346116,13346326,13344377,13345721],"length":1,"stats":{"Line":0}},{"line":135,"address":[16715214,16716899,16717233,16717011],"length":1,"stats":{"Line":0}},{"line":138,"address":[13373432,13374636,13373456,13373644,13373744,13373940,13373424,13373503],"length":1,"stats":{"Line":0}},{"line":139,"address":[11001460],"length":1,"stats":{"Line":0}},{"line":140,"address":[18560869],"length":1,"stats":{"Line":0}},{"line":142,"address":[12818159,12818101,12817203,12817394],"length":1,"stats":{"Line":0}},{"line":143,"address":[11001483],"length":1,"stats":{"Line":0}},{"line":144,"address":[10429034],"length":1,"stats":{"Line":0}},{"line":145,"address":[13375130,13375027,13375173],"length":1,"stats":{"Line":0}},{"line":148,"address":[13589472],"length":1,"stats":{"Line":0}},{"line":179,"address":[18687293,18686894,18686864,18686825,18686962,18687164],"length":1,"stats":{"Line":0}},{"line":180,"address":[18687224],"length":1,"stats":{"Line":0}},{"line":183,"address":[16844019,16844064,16844099,16844434,16844927,16844186,16844638],"length":1,"stats":{"Line":0}},{"line":184,"address":[19192244],"length":1,"stats":{"Line":0}},{"line":193,"address":[13476147,13475097,13474824],"length":1,"stats":{"Line":0}},{"line":194,"address":[12944665,12946272,12946294],"length":1,"stats":{"Line":0}},{"line":195,"address":[12944630,12944983,12944782,12945745],"length":1,"stats":{"Line":0}},{"line":196,"address":[18689427,18690912,18690934],"length":1,"stats":{"Line":0}},{"line":197,"address":[16846431,16846160,16846284],"length":1,"stats":{"Line":0}},{"line":198,"address":[13475936,13476290,13475590,13475877],"length":1,"stats":{"Line":0}},{"line":199,"address":[13475752],"length":1,"stats":{"Line":0}},{"line":200,"address":[13502920,13503058,13501193,13502694,13502641],"length":1,"stats":{"Line":0}},{"line":203,"address":[13477672,13477418,13477296,13478478,13478561,13477225,13477331],"length":1,"stats":{"Line":0}},{"line":204,"address":[16849372,16848727,16848553],"length":1,"stats":{"Line":0}},{"line":205,"address":[12947479,12947625,12947828],"length":1,"stats":{"Line":0}},{"line":206,"address":[12948592,12947796,12948614],"length":1,"stats":{"Line":0}},{"line":207,"address":[13505432,13505173,13505072,13504907],"length":1,"stats":{"Line":0}},{"line":208,"address":[16849136],"length":1,"stats":{"Line":0}},{"line":209,"address":[13504181,13505186,13505464,13505329,13505142],"length":1,"stats":{"Line":0}},{"line":212,"address":[18693200,18693238,18693135,18693373,18693632,18694182,18694291],"length":1,"stats":{"Line":0}},{"line":213,"address":[12949647,12949967,12949471],"length":1,"stats":{"Line":0}},{"line":214,"address":[13506280,13506913,13507289,13506758,13507007],"length":1,"stats":{"Line":0}},{"line":217,"address":[12950733,12950559,12950608,12951123,12951415,12950643,12950960],"length":1,"stats":{"Line":0}},{"line":218,"address":[16852371,16851976,16852239],"length":1,"stats":{"Line":0}},{"line":221,"address":[18695647,18696479,18696044,18696199,18695696,18695731,18695821],"length":1,"stats":{"Line":0}},{"line":222,"address":[11136903],"length":1,"stats":{"Line":0}},{"line":225,"address":[13483138,13482803,13483329,13483645,13482768,13482890,13482729],"length":1,"stats":{"Line":0}},{"line":226,"address":[18697056,18697215,18697313,18696970],"length":1,"stats":{"Line":0}},{"line":228,"address":[11370820],"length":1,"stats":{"Line":0}},{"line":229,"address":[13483676,13483723,13483664,13483696],"length":1,"stats":{"Line":0}},{"line":237,"address":[16855478,16855393],"length":1,"stats":{"Line":0}},{"line":238,"address":[12954991],"length":1,"stats":{"Line":0}},{"line":239,"address":[13511443],"length":1,"stats":{"Line":0}},{"line":243,"address":[13484765,13484935,13484668,13485363],"length":1,"stats":{"Line":0}},{"line":244,"address":[18698946,18699678,18699865,18699007,18699349,18698612,18699465],"length":1,"stats":{"Line":0}},{"line":246,"address":[18698792],"length":1,"stats":{"Line":0}},{"line":247,"address":[10615375],"length":1,"stats":{"Line":0}},{"line":249,"address":[13513531,13512822,13513463,13512628],"length":1,"stats":{"Line":0}},{"line":250,"address":[11128393],"length":1,"stats":{"Line":0}},{"line":253,"address":[13727699],"length":1,"stats":{"Line":0}},{"line":256,"address":[13514698,13514946,13515137,13515426,13514611,13514576,13514537],"length":1,"stats":{"Line":0}},{"line":257,"address":[12957870,12958033,12957589],"length":1,"stats":{"Line":0}},{"line":260,"address":[12959597,12958323,12960075,12958384,12958422,12958524,12958790],"length":1,"stats":{"Line":0}},{"line":261,"address":[13489261],"length":1,"stats":{"Line":0}},{"line":262,"address":[13730700],"length":1,"stats":{"Line":0}},{"line":263,"address":[13516069],"length":1,"stats":{"Line":0}},{"line":266,"address":[13730432,13730695,13730130,13730199],"length":1,"stats":{"Line":0}},{"line":267,"address":[13730400,13731328,13731350],"length":1,"stats":{"Line":0}},{"line":268,"address":[13731178,13730649,13730375,13730590,13730966,13731058],"length":1,"stats":{"Line":0}},{"line":269,"address":[16860521],"length":1,"stats":{"Line":0}},{"line":270,"address":[16860602,16859767,16860649,16860845,16860982,16861130],"length":1,"stats":{"Line":0}},{"line":271,"address":[12959879],"length":1,"stats":{"Line":0}},{"line":274,"address":[13490761,13491146,13491316,13490835,13490922,13491605,13490800],"length":1,"stats":{"Line":0}},{"line":275,"address":[18704453,18704840,18704714],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":101},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","distribution.rs"],"content":"use crate::domain::entities::Event;\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::infrastructure::p2p::event_distributor::DistributionStrategy;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub(crate) async fn distribute_hybrid(\n    distributor: &Arc<dyn EventDistributor>,\n    event: &Event,\n) -> Result<(), AppError> {\n    distributor\n        .distribute(event, DistributionStrategy::Hybrid)\n        .await?;\n    Ok(())\n}\n","traces":[{"line":7,"address":[18663664],"length":1,"stats":{"Line":0}},{"line":11,"address":[19221582,19221181,19220973,19221460,19221348,19221685,19221114],"length":1,"stats":{"Line":0}},{"line":12,"address":[18663970],"length":1,"stats":{"Line":0}},{"line":13,"address":[19221390,19221550,19221150,19221257,19221021,19221197],"length":1,"stats":{"Line":0}},{"line":14,"address":[12284552],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","factory.rs"],"content":"pub(crate) use crate::application::shared::nostr::build_deletion_event;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","mod.rs"],"content":"pub mod core;\npub mod distribution;\npub mod factory;\npub mod subscription;\n\npub use core::{EventService, EventServiceTrait};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","event_service","subscription.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse chrono::Utc;\nuse tracing::warn;\n\nuse super::EventService;\n\nimpl EventService {\n    pub async fn handle_network_disconnected(&self) -> Result<(), AppError> {\n        self.subscription_state.mark_all_need_resync().await\n    }\n\n    pub async fn handle_network_connected(&self) -> Result<(), AppError> {\n        self.restore_subscriptions().await\n    }\n\n    async fn restore_subscriptions(&self) -> Result<(), AppError> {\n        let invoker = self.subscription_invoker()?;\n\n        let records = self.subscription_state.list_for_restore().await?;\n        let mut failure_message: Option<String> = None;\n\n        for record in records {\n            let target = record.target.clone();\n            let since = record.since_timestamp();\n            let target_label = match &target {\n                SubscriptionTarget::Topic(t) => format!(\"topic:{t}\"),\n                SubscriptionTarget::User(u) => format!(\"user:{u}\"),\n            };\n\n            let result = match &target {\n                SubscriptionTarget::Topic(topic_id) => {\n                    invoker.subscribe_topic(topic_id, since).await\n                }\n                SubscriptionTarget::User(pubkey) => invoker.subscribe_user(pubkey, since).await,\n            };\n\n            match result {\n                Ok(_) => {\n                    self.subscription_state\n                        .mark_subscribed(&target, Utc::now().timestamp())\n                        .await?;\n                }\n                Err(err) => {\n                    let err_message = err.to_string();\n                    if let Err(store_err) = self\n                        .subscription_state\n                        .mark_failure(&target, &err_message)\n                        .await\n                    {\n                        warn!(\n                            \"Failed to record subscription failure for {}: {}\",\n                            target_label, store_err\n                        );\n                    }\n                    warn!(\n                        \"Failed to restore subscription for {}: {}\",\n                        target_label, err_message\n                    );\n                    failure_message = Some(err_message);\n                }\n            }\n        }\n\n        if let Some(message) = failure_message {\n            Err(AppError::NostrError(message))\n        } else {\n            Ok(())\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_topic_internal(\n    service: &EventService,\n    topic_id: &str,\n) -> Result<(), AppError> {\n    if topic_id.is_empty() {\n        return Err(AppError::ValidationError(\n            \"Topic ID is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::Topic(topic_id.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_topic(topic_id, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for topic {}: {}\",\n                    topic_id, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn subscribe_to_user_internal(\n    service: &EventService,\n    pubkey: &str,\n) -> Result<(), AppError> {\n    if pubkey.is_empty() {\n        return Err(AppError::ValidationError(\n            \"Public key is required\".to_string(),\n        ));\n    }\n\n    let invoker = service.subscription_invoker()?;\n\n    let target = SubscriptionTarget::User(pubkey.to_string());\n    let record = service\n        .subscription_state\n        .record_request(target.clone())\n        .await?;\n    let since = record.since_timestamp();\n\n    match invoker.subscribe_user(pubkey, since).await {\n        Ok(_) => {\n            service\n                .subscription_state\n                .mark_subscribed(&target, Utc::now().timestamp())\n                .await?;\n            Ok(())\n        }\n        Err(err) => {\n            let err_message = err.to_string();\n            if let Err(store_err) = service\n                .subscription_state\n                .mark_failure(&target, &err_message)\n                .await\n            {\n                warn!(\n                    \"Failed to record subscription failure for user {}: {}\",\n                    pubkey, store_err\n                );\n            }\n            Err(err)\n        }\n    }\n}\n\npub(crate) async fn list_subscriptions_internal(\n    service: &EventService,\n) -> Result<Vec<SubscriptionRecord>, AppError> {\n    service.subscription_state.list_all().await\n}\n","traces":[{"line":9,"address":[12393454,12393491,12393328,12393641,12393363,12393923],"length":1,"stats":{"Line":0}},{"line":10,"address":[11159796],"length":1,"stats":{"Line":0}},{"line":13,"address":[13165168,13165328,13165447,13165203,13165747,13165291],"length":1,"stats":{"Line":0}},{"line":14,"address":[16295359,16295256,16295302,16295463],"length":1,"stats":{"Line":0}},{"line":17,"address":[12394528,12394865,12394575,12395396,12396117,12394738],"length":1,"stats":{"Line":0}},{"line":18,"address":[16296131,16296255,16295920,16296524],"length":1,"stats":{"Line":0}},{"line":20,"address":[11361650],"length":1,"stats":{"Line":0}},{"line":21,"address":[15902428],"length":1,"stats":{"Line":0}},{"line":23,"address":[12395817,12396008,12401405,12401350],"length":1,"stats":{"Line":0}},{"line":24,"address":[16302735],"length":1,"stats":{"Line":0}},{"line":25,"address":[13173203],"length":1,"stats":{"Line":0}},{"line":26,"address":[12402045],"length":1,"stats":{"Line":0}},{"line":27,"address":[12402172,12402083],"length":1,"stats":{"Line":0}},{"line":28,"address":[13173362,13173548],"length":1,"stats":{"Line":0}},{"line":31,"address":[12959417],"length":1,"stats":{"Line":0}},{"line":32,"address":[12402436],"length":1,"stats":{"Line":0}},{"line":33,"address":[10607716],"length":1,"stats":{"Line":0}},{"line":35,"address":[11361697],"length":1,"stats":{"Line":0}},{"line":38,"address":[15909558],"length":1,"stats":{"Line":0}},{"line":40,"address":[13175414,13174777,13175324,13175022,13175220,13175081],"length":1,"stats":{"Line":0}},{"line":41,"address":[12403689],"length":1,"stats":{"Line":0}},{"line":42,"address":[12934271,12934218,12934420,12926600,12934550,12925231],"length":1,"stats":{"Line":0}},{"line":44,"address":[15910092],"length":1,"stats":{"Line":0}},{"line":45,"address":[13175651,13174850],"length":1,"stats":{"Line":0}},{"line":46,"address":[12953703,12961696,12961753,12953519,12961570],"length":1,"stats":{"Line":0}},{"line":48,"address":[12961627],"length":1,"stats":{"Line":0}},{"line":49,"address":[13175820,13175871,13167679,13166084,13167469],"length":1,"stats":{"Line":0}},{"line":51,"address":[13167857,13231567,13168459,13167958,13231433],"length":1,"stats":{"Line":0}},{"line":56,"address":[16361913,16362047,16300587,16299962],"length":1,"stats":{"Line":0}},{"line":60,"address":[15907487,15905837],"length":1,"stats":{"Line":0}},{"line":65,"address":[15908332,15908103],"length":1,"stats":{"Line":0}},{"line":66,"address":[16302872],"length":1,"stats":{"Line":0}},{"line":68,"address":[12932182],"length":1,"stats":{"Line":0}},{"line":73,"address":[12404704],"length":1,"stats":{"Line":0}},{"line":77,"address":[12962058,12962254],"length":1,"stats":{"Line":0}},{"line":78,"address":[13177041],"length":1,"stats":{"Line":0}},{"line":79,"address":[15911599],"length":1,"stats":{"Line":0}},{"line":83,"address":[15911745,15911649,15912141,15911572],"length":1,"stats":{"Line":0}},{"line":85,"address":[13176606,13176502],"length":1,"stats":{"Line":0}},{"line":86,"address":[15913365,15911849,15911999,15912498,15912086,15913020,15912694],"length":1,"stats":{"Line":0}},{"line":88,"address":[15911960],"length":1,"stats":{"Line":0}},{"line":89,"address":[15912610,15912108,15912988,15911433,15912390,15912047],"length":1,"stats":{"Line":0}},{"line":90,"address":[12963857,12963685],"length":1,"stats":{"Line":0}},{"line":92,"address":[14350088],"length":1,"stats":{"Line":0}},{"line":94,"address":[16309528,16308512,16308771,16308854,16309627,16309424],"length":1,"stats":{"Line":0}},{"line":96,"address":[16308671],"length":1,"stats":{"Line":0}},{"line":97,"address":[11220126],"length":1,"stats":{"Line":0}},{"line":98,"address":[12965501],"length":1,"stats":{"Line":0}},{"line":100,"address":[15913699],"length":1,"stats":{"Line":0}},{"line":101,"address":[12937784],"length":1,"stats":{"Line":0}},{"line":102,"address":[12965173,12965881,12964881,12965090,12965745],"length":1,"stats":{"Line":0}},{"line":104,"address":[15914212],"length":1,"stats":{"Line":0}},{"line":105,"address":[19034775],"length":1,"stats":{"Line":0}},{"line":107,"address":[12939304,12939203,12939805,12991593,12991727],"length":1,"stats":{"Line":0}},{"line":112,"address":[12941220],"length":1,"stats":{"Line":0}},{"line":117,"address":[15917296],"length":1,"stats":{"Line":0}},{"line":121,"address":[12411438,12411242],"length":1,"stats":{"Line":0}},{"line":122,"address":[13183361],"length":1,"stats":{"Line":0}},{"line":123,"address":[12941875],"length":1,"stats":{"Line":0}},{"line":127,"address":[12969177,12968580,12968645,12968761],"length":1,"stats":{"Line":0}},{"line":129,"address":[12411694,12411590],"length":1,"stats":{"Line":0}},{"line":130,"address":[13183822,13183638,13183123,13182965,13184172,13184537,13183214],"length":1,"stats":{"Line":0}},{"line":132,"address":[15918104],"length":1,"stats":{"Line":0}},{"line":133,"address":[14347938],"length":1,"stats":{"Line":0}},{"line":134,"address":[13184273,13184101],"length":1,"stats":{"Line":0}},{"line":136,"address":[12970474,12968462,12970215],"length":1,"stats":{"Line":0}},{"line":138,"address":[12414528,12414632,12413875,12414731,12413958,12413616],"length":1,"stats":{"Line":0}},{"line":140,"address":[15919955],"length":1,"stats":{"Line":0}},{"line":141,"address":[10433350],"length":1,"stats":{"Line":0}},{"line":142,"address":[12414685],"length":1,"stats":{"Line":0}},{"line":144,"address":[15919843],"length":1,"stats":{"Line":0}},{"line":145,"address":[16314920],"length":1,"stats":{"Line":0}},{"line":146,"address":[16315281,16316281,16315573,16315490,16316145],"length":1,"stats":{"Line":0}},{"line":148,"address":[12971324],"length":1,"stats":{"Line":0}},{"line":149,"address":[11003927],"length":1,"stats":{"Line":0}},{"line":151,"address":[16316339,16363039,16316941,16316440,16362905],"length":1,"stats":{"Line":0}},{"line":156,"address":[15923236],"length":1,"stats":{"Line":0}},{"line":161,"address":[15923440],"length":1,"stats":{"Line":0}},{"line":164,"address":[12948105,12947861,12947977,12947913],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":79},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","mod.rs"],"content":"pub mod auth_service;\npub mod event_service;\npub mod offline_service;\npub mod p2p_service;\npub mod post_service;\nmod subscription_state;\npub mod sync_service;\npub mod topic_service;\npub mod user_service;\n\npub use crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use auth_service::AuthService;\npub use event_service::EventService;\npub use offline_service::OfflineService;\npub use p2p_service::P2PService;\npub use post_service::PostService;\npub use subscription_state::{SubscriptionStateMachine, SubscriptionStateStore};\npub use sync_service::SyncService;\npub use topic_service::TopicService;\npub use user_service::UserService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","offline_service.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionDraft, OfflineActionFilter,\n    OfflineActionRecord, OptimisticUpdateDraft, SavedOfflineAction, SyncQueueItemDraft, SyncResult,\n    SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, OptimisticUpdateId, SyncQueueId,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct SaveOfflineActionParams {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub payload: OfflinePayload,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct OfflineActionsQuery {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\n#[async_trait]\npub trait OfflineServiceTrait: Send + Sync {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError>;\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError>;\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError>;\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError>;\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError>;\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError>;\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError>;\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError>;\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError>;\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError>;\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError>;\n}\n\npub struct OfflineService {\n    persistence: Arc<dyn OfflinePersistence>,\n}\n\nimpl OfflineService {\n    pub fn new(persistence: Arc<dyn OfflinePersistence>) -> Self {\n        Self { persistence }\n    }\n\n    fn build_action_draft(\n        params: &SaveOfflineActionParams,\n    ) -> Result<OfflineActionDraft, AppError> {\n        let payload_value = params.payload.clone().into_inner();\n        let mut map = match payload_value {\n            Value::Object(map) => map,\n            _ => {\n                return Err(AppError::ValidationError(\n                    \"Offline action payload must be a JSON object\".to_string(),\n                ));\n            }\n        };\n\n        map.insert(\n            \"entityType\".to_string(),\n            Value::String(params.entity_type.to_string()),\n        );\n        map.insert(\n            \"entityId\".to_string(),\n            Value::String(params.entity_id.to_string()),\n        );\n\n        let enriched_payload =\n            OfflinePayload::new(Value::Object(map)).map_err(AppError::ValidationError)?;\n\n        Ok(OfflineActionDraft::new(\n            params.user_pubkey.clone(),\n            params.action_type.clone(),\n            Some(params.entity_id.clone()),\n            enriched_payload,\n        ))\n    }\n\n    fn filter_from_query(query: &OfflineActionsQuery) -> OfflineActionFilter {\n        OfflineActionFilter::new(query.user_pubkey.clone(), query.include_synced, query.limit)\n    }\n}\n\n#[async_trait]\nimpl OfflineServiceTrait for OfflineService {\n    async fn save_action(\n        &self,\n        params: SaveOfflineActionParams,\n    ) -> Result<SavedOfflineAction, AppError> {\n        let draft = Self::build_action_draft(&params)?;\n        self.persistence.save_action(draft).await\n    }\n\n    async fn list_actions(\n        &self,\n        query: OfflineActionsQuery,\n    ) -> Result<Vec<OfflineActionRecord>, AppError> {\n        let filter = Self::filter_from_query(&query);\n        self.persistence.list_actions(filter).await\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        self.persistence.sync_actions(user_pubkey).await\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        self.persistence.cache_status().await\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        self.persistence.enqueue_sync(draft).await\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        self.persistence.upsert_cache_metadata(update).await\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        self.persistence.save_optimistic_update(draft).await\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        self.persistence.confirm_optimistic_update(update_id).await\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        self.persistence.rollback_optimistic_update(update_id).await\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        self.persistence.cleanup_expired_cache().await\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        self.persistence.update_sync_status(update).await\n    }\n}\n","traces":[{"line":67,"address":[18099504],"length":1,"stats":{"Line":4}},{"line":71,"address":[14797907,14796064,14797512],"length":1,"stats":{"Line":3}},{"line":74,"address":[12857790],"length":1,"stats":{"Line":3}},{"line":75,"address":[14796187],"length":1,"stats":{"Line":3}},{"line":76,"address":[18099671],"length":1,"stats":{"Line":3}},{"line":78,"address":[18074477],"length":1,"stats":{"Line":0}},{"line":79,"address":[18313866],"length":1,"stats":{"Line":0}},{"line":84,"address":[14796482],"length":1,"stats":{"Line":3}},{"line":85,"address":[18099850,18099739],"length":1,"stats":{"Line":6}},{"line":86,"address":[18099919,18099858],"length":1,"stats":{"Line":6}},{"line":88,"address":[14796697],"length":1,"stats":{"Line":3}},{"line":89,"address":[17542894],"length":1,"stats":{"Line":3}},{"line":90,"address":[18073338,18073402],"length":1,"stats":{"Line":6}},{"line":93,"address":[18100249,18100512],"length":1,"stats":{"Line":3}},{"line":96,"address":[17543690,17543778],"length":1,"stats":{"Line":6}},{"line":97,"address":[12858724,12858843],"length":1,"stats":{"Line":6}},{"line":98,"address":[18073891,18073953],"length":1,"stats":{"Line":6}},{"line":99,"address":[17543618,17543561],"length":1,"stats":{"Line":6}},{"line":100,"address":[18314882],"length":1,"stats":{"Line":3}},{"line":104,"address":[14797936],"length":1,"stats":{"Line":1}},{"line":105,"address":[18074743],"length":1,"stats":{"Line":1}},{"line":115,"address":[18130367,18130429,18130753],"length":1,"stats":{"Line":6}},{"line":116,"address":[18371705,18370917,18372180,18371564],"length":1,"stats":{"Line":8}},{"line":123,"address":[17601908,17601844],"length":1,"stats":{"Line":2}},{"line":124,"address":[18131916,18132388,18132644,18132316],"length":1,"stats":{"Line":3}},{"line":127,"address":[12918019,12917984,12918263,12918703,12917929,12919001,12918423,12918130],"length":1,"stats":{"Line":4}},{"line":128,"address":[18133775,18133197,18133526,18133599],"length":1,"stats":{"Line":3}},{"line":131,"address":[12919593,12919876,12919120,12919254,12919155,12919406,12919081],"length":1,"stats":{"Line":0}},{"line":132,"address":[14852362,14852214,14852033],"length":1,"stats":{"Line":0}},{"line":135,"address":[18376279,18375875,18375986,18376119,18376615,18376913,18375769,18375840],"length":1,"stats":{"Line":0}},{"line":136,"address":[14488878],"length":1,"stats":{"Line":0}},{"line":139,"address":[17606002,17605891,17606295,17606985,17606687,17605856,17606135,17605759],"length":1,"stats":{"Line":4}},{"line":140,"address":[10624554],"length":1,"stats":{"Line":3}},{"line":147,"address":[18138173,18138249,18137769,18138511],"length":1,"stats":{"Line":0}},{"line":154,"address":[11383774],"length":1,"stats":{"Line":0}},{"line":161,"address":[11385358],"length":1,"stats":{"Line":0}},{"line":164,"address":[12926514,12926266,12926105,12926144,12926700,12926989,12926179],"length":1,"stats":{"Line":3}},{"line":165,"address":[19192468],"length":1,"stats":{"Line":2}},{"line":168,"address":[18142639,18142334,18142176,18143113,18142470,18142211,18142063,18143418],"length":1,"stats":{"Line":4}},{"line":169,"address":[10617341],"length":1,"stats":{"Line":3}}],"covered":31,"coverable":40},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","p2p_service.rs"],"content":"use crate::domain::p2p::events::P2PEvent;\nuse crate::infrastructure::p2p::{\n    DiscoveryOptions, GossipService, NetworkService, iroh_gossip_service::IrohGossipService,\n    iroh_network_service::IrohNetworkService, metrics,\n};\nuse crate::shared::config::NetworkConfig as AppNetworkConfig;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse iroh::SecretKey;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse tokio::sync::{RwLock, mpsc::UnboundedSender};\n\n/// P2Pネットワークのステータス情報\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatus {\n    pub connected: bool,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicInfo>,\n    pub peer_count: usize,\n    pub metrics_summary: GossipMetricsSummary,\n}\n\n/// Gossipメトリクスのサマリー\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummary {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n\n/// トピック情報\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicInfo {\n    pub id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\n/// P2Pサービスのトレイト\n#[async_trait]\npub trait P2PServiceTrait: Send + Sync {\n    /// P2Pネットワークを初期化\n    async fn initialize(&self) -> Result<(), AppError>;\n\n    /// トピックに参加\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n\n    /// トピックから離脱\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError>;\n\n    /// メッセージをブロードキャスト\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError>;\n\n    /// P2Pステータスを取得\n    async fn get_status(&self) -> Result<P2PStatus, AppError>;\n\n    /// ノードアドレスを取得\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError>;\n\n    /// トピックIDを生成\n    fn generate_topic_id(&self, topic_name: &str) -> String;\n}\n\n/// P2Pサービスの実装\npub struct P2PService {\n    network_service: Arc<dyn NetworkService>,\n    gossip_service: Arc<dyn GossipService>,\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\n}\n\nimpl P2PService {\n    pub fn new(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n    ) -> Self {\n        Self::with_discovery(network_service, gossip_service, DiscoveryOptions::default())\n    }\n\n    pub fn with_discovery(\n        network_service: Arc<dyn NetworkService>,\n        gossip_service: Arc<dyn GossipService>,\n        discovery: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            network_service,\n            gossip_service,\n            discovery_options: Arc::new(RwLock::new(discovery)),\n        }\n    }\n\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\n        *self.discovery_options.read().await\n    }\n\n    pub async fn set_mainline_enabled(&self, enabled: bool) {\n        let mut options = self.discovery_options.write().await;\n        *options = options.with_mainline(enabled);\n    }\n\n    pub fn builder(secret_key: SecretKey, network_config: AppNetworkConfig) -> P2PServiceBuilder {\n        let discovery_options = DiscoveryOptions::from(&network_config);\n        P2PServiceBuilder::new(secret_key, network_config, discovery_options)\n    }\n}\n\n/// P2Pレイヤーの構築結果\npub struct P2PStack {\n    pub network_service: Arc<IrohNetworkService>,\n    pub gossip_service: Arc<IrohGossipService>,\n    pub p2p_service: Arc<P2PService>,\n}\n\npub struct P2PServiceBuilder {\n    secret_key: SecretKey,\n    network_config: AppNetworkConfig,\n    discovery_options: DiscoveryOptions,\n    event_sender: Option<UnboundedSender<P2PEvent>>,\n}\n\nimpl P2PServiceBuilder {\n    fn new(\n        secret_key: SecretKey,\n        network_config: AppNetworkConfig,\n        discovery_options: DiscoveryOptions,\n    ) -> Self {\n        Self {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender: None,\n        }\n    }\n\n    pub fn with_discovery_options(mut self, options: DiscoveryOptions) -> Self {\n        self.discovery_options = options;\n        self\n    }\n\n    pub fn enable_mainline(mut self, enabled: bool) -> Self {\n        self.discovery_options = self.discovery_options.with_mainline(enabled);\n        self\n    }\n\n    pub fn with_event_sender(mut self, sender: UnboundedSender<P2PEvent>) -> Self {\n        self.event_sender = Some(sender);\n        self\n    }\n\n    pub fn discovery_options(&self) -> DiscoveryOptions {\n        self.discovery_options\n    }\n\n    pub async fn build(self) -> Result<P2PStack, AppError> {\n        let P2PServiceBuilder {\n            secret_key,\n            network_config,\n            discovery_options,\n            event_sender,\n        } = self;\n\n        let network_service =\n            Arc::new(IrohNetworkService::new(secret_key, network_config, discovery_options).await?);\n        let endpoint_arc = network_service.endpoint().clone();\n        let mut gossip_inner = IrohGossipService::new(endpoint_arc)?;\n        if let Some(tx) = event_sender {\n            gossip_inner.set_event_sender(tx);\n        }\n        let gossip_service = Arc::new(gossip_inner);\n\n        let network_service_dyn: Arc<dyn NetworkService> = network_service.clone();\n        let gossip_service_dyn: Arc<dyn GossipService> = gossip_service.clone();\n        let p2p_service = Arc::new(P2PService::with_discovery(\n            network_service_dyn,\n            gossip_service_dyn,\n            discovery_options,\n        ));\n\n        Ok(P2PStack {\n            network_service,\n            gossip_service,\n            p2p_service,\n        })\n    }\n}\n\n#[async_trait]\nimpl P2PServiceTrait for P2PService {\n    async fn initialize(&self) -> Result<(), AppError> {\n        // P2Pネットワークの初期化処理\n        // 既にstate.rsのinitialize_p2pで初期化されている場合はチェックのみ\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\n        self.gossip_service\n            .join_topic(topic_id, initial_peers)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    async fn leave_topic(&self, topic_id: &str) -> Result<(), AppError> {\n        self.gossip_service\n            .leave_topic(topic_id)\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    async fn broadcast_message(&self, topic_id: &str, content: &str) -> Result<(), AppError> {\n        self.gossip_service\n            .broadcast_message(topic_id, content.as_bytes())\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    async fn get_status(&self) -> Result<P2PStatus, AppError> {\n        // ステータス情報を収集\n        let endpoint_id = self\n            .network_service\n            .get_node_id()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        // 実際のトピック情報を取得\n        let joined_topics = self\n            .gossip_service\n            .get_joined_topics()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n        let mut active_topics = Vec::new();\n        let mut total_peer_count = 0;\n\n        for topic_id in joined_topics {\n            let stats = self\n                .gossip_service\n                .get_topic_stats(&topic_id)\n                .await\n                .map_err(|e| AppError::P2PError(e.to_string()))?;\n\n            let (peer_count, message_count, last_activity) = if let Some(stats) = stats {\n                (stats.peer_count, stats.message_count, stats.last_activity)\n            } else {\n                let peers = self\n                    .gossip_service\n                    .get_topic_peers(&topic_id)\n                    .await\n                    .map_err(|e| AppError::P2PError(e.to_string()))?;\n                (peers.len(), 0, chrono::Utc::now().timestamp())\n            };\n\n            total_peer_count += peer_count;\n\n            active_topics.push(TopicInfo {\n                id: topic_id,\n                peer_count,\n                message_count,\n                last_activity,\n            });\n        }\n\n        let metrics_snapshot = metrics::snapshot();\n        let metrics_summary = GossipMetricsSummary {\n            joins: metrics_snapshot.joins,\n            leaves: metrics_snapshot.leaves,\n            broadcasts_sent: metrics_snapshot.broadcasts_sent,\n            messages_received: metrics_snapshot.messages_received,\n        };\n\n        Ok(P2PStatus {\n            connected: true,\n            endpoint_id,\n            active_topics,\n            peer_count: total_peer_count,\n            metrics_summary,\n        })\n    }\n\n    async fn get_node_addresses(&self) -> Result<Vec<String>, AppError> {\n        self.network_service\n            .get_addresses()\n            .await\n            .map_err(|e| AppError::P2PError(e.to_string()))\n    }\n\n    fn generate_topic_id(&self, topic_name: &str) -> String {\n        // トピック名からIDを生成（例：ハッシュを使用）\n        use sha2::{Digest, Sha256};\n        let mut hasher = Sha256::new();\n        hasher.update(topic_name.as_bytes());\n        format!(\"{:x}\", hasher.finalize())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::p2p::TopicStats;\n    use crate::infrastructure::p2p::{GossipService, NetworkService, metrics};\n    use async_trait::async_trait;\n    use chrono::Utc;\n    use mockall::{mock, predicate::*};\n    use std::sync::Mutex;\n\n    // NetworkServiceのモック - 手動実装\n    pub struct MockNetworkServ {\n        node_id: Mutex<Option<String>>,\n        addresses: Mutex<Option<Vec<String>>>,\n    }\n\n    impl MockNetworkServ {\n        pub fn new() -> Self {\n            Self {\n                node_id: Mutex::new(None),\n                addresses: Mutex::new(None),\n            }\n        }\n\n        pub fn expect_get_node_id(&mut self) -> &mut Self {\n            self\n        }\n\n        pub fn returning<F>(&mut self, f: F) -> &mut Self\n        where\n            F: FnOnce() -> Result<String, AppError> + 'static,\n        {\n            if let Ok(value) = f() {\n                *self.node_id.lock().unwrap() = Some(value);\n            }\n            self\n        }\n\n        pub fn expect_get_addresses(&mut self) -> &mut Self {\n            self\n        }\n\n        pub fn returning_addresses<F>(&mut self, f: F) -> &mut Self\n        where\n            F: FnOnce() -> Result<Vec<String>, AppError> + 'static,\n        {\n            if let Ok(value) = f() {\n                *self.addresses.lock().unwrap() = Some(value);\n            }\n            self\n        }\n    }\n\n    #[async_trait]\n    impl NetworkService for MockNetworkServ {\n        fn as_any(&self) -> &dyn std::any::Any {\n            self\n        }\n\n        async fn connect(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn disconnect(&self) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn get_peers(\n            &self,\n        ) -> Result<Vec<crate::infrastructure::p2p::network_service::Peer>, AppError> {\n            Ok(vec![])\n        }\n\n        async fn add_peer(&self, _address: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn remove_peer(&self, _peer_id: &str) -> Result<(), AppError> {\n            Ok(())\n        }\n\n        async fn get_stats(\n            &self,\n        ) -> Result<crate::infrastructure::p2p::network_service::NetworkStats, AppError> {\n            Ok(crate::infrastructure::p2p::network_service::NetworkStats {\n                connected_peers: 0,\n                total_messages_sent: 0,\n                total_messages_received: 0,\n                bandwidth_up: 0,\n                bandwidth_down: 0,\n            })\n        }\n\n        async fn is_connected(&self) -> bool {\n            true\n        }\n\n        async fn get_node_id(&self) -> Result<String, AppError> {\n            let node_id = self.node_id.lock().unwrap();\n            Ok(node_id\n                .clone()\n                .unwrap_or_else(|| \"default_node_id\".to_string()))\n        }\n\n        async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\n            let addresses = self.addresses.lock().unwrap();\n            Ok(addresses.clone().unwrap_or_else(std::vec::Vec::new))\n        }\n    }\n\n    // GossipServiceのモック\n    mock! {\n        pub GossipServ {}\n\n        #[async_trait]\n        impl GossipService for GossipServ {\n            async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\n            async fn broadcast(&self, topic: &str, event: &crate::domain::entities::Event) -> Result<(), AppError>;\n            async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<crate::domain::entities::Event>, AppError>;\n            async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n            async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n            async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n            async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n        }\n    }\n\n    #[tokio::test]\n    async fn test_initialize() {\n        let mock_network = MockNetworkServ::new();\n        let mock_gossip = MockGossipServ::new();\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.initialize().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_join_topic_success() {\n        let mock_network = MockNetworkServ::new();\n        let mut mock_gossip = MockGossipServ::new();\n\n        mock_gossip\n            .expect_join_topic()\n            .with(\n                eq(\"test_topic\"),\n                eq(vec![\"peer1\".to_string(), \"peer2\".to_string()]),\n            )\n            .times(1)\n            .returning(|_, _| Ok(()));\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service\n            .join_topic(\"test_topic\", vec![\"peer1\".to_string(), \"peer2\".to_string()])\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_join_topic_failure() {\n        let mock_network = MockNetworkServ::new();\n        let mut mock_gossip = MockGossipServ::new();\n\n        mock_gossip\n            .expect_join_topic()\n            .with(eq(\"test_topic\"), eq(vec![]))\n            .times(1)\n            .returning(|_, _| Err(AppError::P2PError(\"Failed to join topic\".to_string())));\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.join_topic(\"test_topic\", vec![]).await;\n        assert!(result.is_err());\n        assert!(\n            result\n                .unwrap_err()\n                .to_string()\n                .contains(\"Failed to join topic\")\n        );\n    }\n\n    #[tokio::test]\n    async fn test_leave_topic() {\n        let mock_network = MockNetworkServ::new();\n        let mut mock_gossip = MockGossipServ::new();\n\n        mock_gossip\n            .expect_leave_topic()\n            .with(eq(\"test_topic\"))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.leave_topic(\"test_topic\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_broadcast_message() {\n        let mock_network = MockNetworkServ::new();\n        let mut mock_gossip = MockGossipServ::new();\n\n        let test_content = \"Test message\";\n        mock_gossip\n            .expect_broadcast_message()\n            .with(eq(\"test_topic\"), eq(test_content.as_bytes()))\n            .times(1)\n            .returning(|_, _| Ok(()));\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.broadcast_message(\"test_topic\", test_content).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_get_status() {\n        metrics::reset_all();\n        let mut mock_network = MockNetworkServ::new();\n        mock_network\n            .expect_get_node_id()\n            .returning(|| Ok(\"node123\".to_string()));\n\n        let mut mock_gossip = MockGossipServ::new();\n        mock_gossip\n            .expect_get_joined_topics()\n            .times(1)\n            .returning(|| Ok(vec![\"topic1\".to_string(), \"topic2\".to_string()]));\n\n        mock_gossip\n            .expect_get_topic_stats()\n            .with(eq(\"topic1\"))\n            .times(1)\n            .returning(|_| {\n                Ok(Some(TopicStats {\n                    peer_count: 5,\n                    message_count: 12,\n                    last_activity: 1_700_000_000,\n                }))\n            });\n\n        mock_gossip\n            .expect_get_topic_stats()\n            .with(eq(\"topic2\"))\n            .times(1)\n            .returning(|_| {\n                Ok(Some(TopicStats {\n                    peer_count: 3,\n                    message_count: 4,\n                    last_activity: 1_700_000_100,\n                }))\n            });\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.get_status().await;\n        assert!(result.is_ok());\n\n        let status = result.unwrap();\n        assert_eq!(status.endpoint_id, \"node123\");\n        assert!(status.connected);\n        assert_eq!(status.active_topics.len(), 2);\n        assert_eq!(status.peer_count, 8); // 5 + 3\n        assert_eq!(status.metrics_summary.joins, 0);\n        assert_eq!(status.metrics_summary.leaves, 0);\n        assert_eq!(status.metrics_summary.broadcasts_sent, 0);\n        assert_eq!(status.metrics_summary.messages_received, 0);\n        assert_eq!(status.active_topics[0].message_count, 12);\n        assert_eq!(status.active_topics[0].last_activity, 1_700_000_000);\n        assert_eq!(status.active_topics[1].message_count, 4);\n        assert_eq!(status.active_topics[1].last_activity, 1_700_000_100);\n    }\n\n    #[tokio::test]\n    async fn test_get_status_fallback_to_peers_when_stats_missing() {\n        metrics::reset_all();\n        let mut mock_network = MockNetworkServ::new();\n        mock_network\n            .expect_get_node_id()\n            .returning(|| Ok(\"node123\".to_string()));\n\n        let mut mock_gossip = MockGossipServ::new();\n        mock_gossip\n            .expect_get_joined_topics()\n            .times(1)\n            .returning(|| Ok(vec![\"topic1\".to_string()]));\n\n        mock_gossip\n            .expect_get_topic_stats()\n            .with(eq(\"topic1\"))\n            .times(1)\n            .returning(|_| Ok(None));\n\n        mock_gossip\n            .expect_get_topic_peers()\n            .with(eq(\"topic1\"))\n            .times(1)\n            .returning(|_| Ok(vec![\"peer1\".to_string(), \"peer2\".to_string()]));\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let before = Utc::now().timestamp();\n        let status = service.get_status().await.unwrap();\n        let after = Utc::now().timestamp();\n\n        assert_eq!(status.active_topics.len(), 1);\n        let topic = &status.active_topics[0];\n        assert_eq!(topic.peer_count, 2);\n        assert_eq!(topic.message_count, 0);\n        assert!(topic.last_activity >= before);\n        assert!(topic.last_activity <= after);\n    }\n\n    #[tokio::test]\n    async fn test_get_node_addresses() {\n        let mut mock_network = MockNetworkServ::new();\n        mock_network.expect_get_addresses().returning_addresses(|| {\n            Ok(vec![\n                \"/ip4/127.0.0.1/tcp/4001\".to_string(),\n                \"/ip4/192.168.1.10/tcp/4001\".to_string(),\n            ])\n        });\n\n        let mock_gossip = MockGossipServ::new();\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let result = service.get_node_addresses().await;\n        assert!(result.is_ok());\n\n        let addresses = result.unwrap();\n        assert_eq!(addresses.len(), 2);\n        assert!(addresses.contains(&\"/ip4/127.0.0.1/tcp/4001\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_generate_topic_id() {\n        let mock_network = MockNetworkServ::new();\n        let mock_gossip = MockGossipServ::new();\n\n        let service = P2PService::new(Arc::new(mock_network), Arc::new(mock_gossip));\n\n        let topic_id1 = service.generate_topic_id(\"test_topic\");\n        let topic_id2 = service.generate_topic_id(\"test_topic\");\n        let topic_id3 = service.generate_topic_id(\"different_topic\");\n\n        // 同じトピック名から同じIDが生成される\n        assert_eq!(topic_id1, topic_id2);\n        // 異なるトピック名からは異なるIDが生成される\n        assert_ne!(topic_id1, topic_id3);\n    }\n}\n","traces":[{"line":75,"address":[16744624,16744906],"length":1,"stats":{"Line":1}},{"line":79,"address":[11529841,11529885,11529617],"length":1,"stats":{"Line":1}},{"line":82,"address":[11530247,11530222,11529904],"length":1,"stats":{"Line":1}},{"line":90,"address":[16745045,16745181],"length":1,"stats":{"Line":4}},{"line":94,"address":[11531000,11530436,11530272,11530288,11530399,11530577,11530313,11530280],"length":1,"stats":{"Line":0}},{"line":95,"address":[11530609,11530379,11530485,11530426],"length":1,"stats":{"Line":0}},{"line":98,"address":[16986896,16987107,16986915,16986944,16986969,16987240,16987070,16987788],"length":1,"stats":{"Line":0}},{"line":99,"address":[16746218,16746440,16746324,16746265],"length":1,"stats":{"Line":0}},{"line":100,"address":[16216311,16216244],"length":1,"stats":{"Line":0}},{"line":103,"address":[16988204,16987808],"length":1,"stats":{"Line":0}},{"line":104,"address":[19796659,19796752],"length":1,"stats":{"Line":0}},{"line":105,"address":[16773889],"length":1,"stats":{"Line":0}},{"line":124,"address":[11532384],"length":1,"stats":{"Line":0}},{"line":137,"address":[16774320],"length":1,"stats":{"Line":0}},{"line":138,"address":[16774367],"length":1,"stats":{"Line":0}},{"line":139,"address":[16774389],"length":1,"stats":{"Line":0}},{"line":142,"address":[11532640,11532867],"length":1,"stats":{"Line":0}},{"line":143,"address":[16217432,16217310],"length":1,"stats":{"Line":0}},{"line":144,"address":[16217487],"length":1,"stats":{"Line":0}},{"line":147,"address":[16748073,16747936],"length":1,"stats":{"Line":0}},{"line":148,"address":[19797649,19797582],"length":1,"stats":{"Line":0}},{"line":149,"address":[11533013],"length":1,"stats":{"Line":0}},{"line":152,"address":[16748096],"length":1,"stats":{"Line":0}},{"line":153,"address":[16748101],"length":1,"stats":{"Line":0}},{"line":156,"address":[16988993,16989040,16988976,16989135,16989696,16989510,16991607,16991461],"length":1,"stats":{"Line":0}},{"line":158,"address":[16989253],"length":1,"stats":{"Line":0}},{"line":159,"address":[16775190],"length":1,"stats":{"Line":0}},{"line":160,"address":[11533462],"length":1,"stats":{"Line":0}},{"line":161,"address":[16775271],"length":1,"stats":{"Line":0}},{"line":164,"address":[10930358,10930406,10930305],"length":1,"stats":{"Line":0}},{"line":166,"address":[19799118,19799061],"length":1,"stats":{"Line":0}},{"line":167,"address":[16219194,16219245,16219396],"length":1,"stats":{"Line":0}},{"line":168,"address":[16219465,16219361],"length":1,"stats":{"Line":0}},{"line":169,"address":[16750037,16749897],"length":1,"stats":{"Line":0}},{"line":171,"address":[16990748,16990876],"length":1,"stats":{"Line":0}},{"line":173,"address":[11535012,11535090],"length":1,"stats":{"Line":0}},{"line":174,"address":[19799762,19799707],"length":1,"stats":{"Line":0}},{"line":175,"address":[16219910],"length":1,"stats":{"Line":0}},{"line":176,"address":[16219851],"length":1,"stats":{"Line":0}},{"line":178,"address":[16777011],"length":1,"stats":{"Line":0}},{"line":181,"address":[19799959],"length":1,"stats":{"Line":0}},{"line":182,"address":[16991249],"length":1,"stats":{"Line":0}},{"line":183,"address":[16777161],"length":1,"stats":{"Line":0}},{"line":191,"address":[11628816,11628945,11628473,11628542,11628610,11628512],"length":1,"stats":{"Line":3}},{"line":194,"address":[16313516],"length":1,"stats":{"Line":1}},{"line":197,"address":[11629072,11629511,11630129,11629351,11629804,11629218,11629011,11629107],"length":1,"stats":{"Line":4}},{"line":198,"address":[17085810,17085446,17085896,17085572,17085639],"length":1,"stats":{"Line":6}},{"line":199,"address":[11629651],"length":1,"stats":{"Line":1}},{"line":200,"address":[16871746,16871612,16871512,16871021,16871556],"length":1,"stats":{"Line":3}},{"line":201,"address":[11630192,11630210],"length":1,"stats":{"Line":2}},{"line":204,"address":[16315410,16315075,16315930,16315614,16314995,16315040,16315162],"length":1,"stats":{"Line":3}},{"line":205,"address":[11631108,11630937,11631194,11630830,11630878],"length":1,"stats":{"Line":5}},{"line":206,"address":[16315505],"length":1,"stats":{"Line":1}},{"line":207,"address":[16315189,16315546,16315590,16315780,16315646],"length":1,"stats":{"Line":3}},{"line":208,"address":[16315952,16315970],"length":1,"stats":{"Line":0}},{"line":211,"address":[11631485,11631958,11631552,11632252,11632577,11631590,11631692],"length":1,"stats":{"Line":3}},{"line":212,"address":[16847064,16847429,16847521,16847190,16847249],"length":1,"stats":{"Line":5}},{"line":213,"address":[16847109],"length":1,"stats":{"Line":1}},{"line":214,"address":[14474740],"length":1,"stats":{"Line":3}},{"line":215,"address":[16874368,16874386],"length":1,"stats":{"Line":0}},{"line":218,"address":[17088623,17088872,17089108,17090107,17088672,17088719,17089371],"length":1,"stats":{"Line":3}},{"line":220,"address":[11633753,11634230,11633643,11633305,11633975,11633443],"length":1,"stats":{"Line":4}},{"line":223,"address":[11096418],"length":1,"stats":{"Line":3}},{"line":224,"address":[19840737,19844496,19844519],"length":1,"stats":{"Line":0}},{"line":227,"address":[16318814,16319106,16318537,16319320,16319627,16318996,16318731],"length":1,"stats":{"Line":5}},{"line":230,"address":[19839883,19840921,19841164,19840982,19841028],"length":1,"stats":{"Line":4}},{"line":231,"address":[16322626,16322608,16319288],"length":1,"stats":{"Line":0}},{"line":233,"address":[19841389],"length":1,"stats":{"Line":1}},{"line":234,"address":[16319405],"length":1,"stats":{"Line":1}},{"line":236,"address":[17091957,17090775,17092006,17090653,17092064],"length":1,"stats":{"Line":7}},{"line":237,"address":[16321642,16321768,16321945,16320874,16322275,16321503,16321444],"length":1,"stats":{"Line":5}},{"line":239,"address":[19843452],"length":1,"stats":{"Line":1}},{"line":240,"address":[16876806,16878826,16878661,16874848,16878608],"length":1,"stats":{"Line":4}},{"line":241,"address":[17093145,17094002,17093984],"length":1,"stats":{"Line":0}},{"line":243,"address":[11637257,11635764,11637342,11637438],"length":1,"stats":{"Line":4}},{"line":244,"address":[16322030],"length":1,"stats":{"Line":1}},{"line":246,"address":[16850253,16852483,16852648,16850411,16850614,16852589,16852700],"length":1,"stats":{"Line":5}},{"line":248,"address":[16852540],"length":1,"stats":{"Line":1}},{"line":249,"address":[16319707,16322270,16319885,16322217,16317733],"length":1,"stats":{"Line":4}},{"line":250,"address":[16877318,16880032,16880050],"length":1,"stats":{"Line":0}},{"line":251,"address":[16877291,16877431],"length":1,"stats":{"Line":2}},{"line":254,"address":[11636050,11635836],"length":1,"stats":{"Line":1}},{"line":256,"address":[11635911,11635968],"length":1,"stats":{"Line":2}},{"line":257,"address":[17091798],"length":1,"stats":{"Line":1}},{"line":264,"address":[16851320],"length":1,"stats":{"Line":1}},{"line":266,"address":[16878075],"length":1,"stats":{"Line":1}},{"line":267,"address":[19843019],"length":1,"stats":{"Line":1}},{"line":268,"address":[16878091],"length":1,"stats":{"Line":1}},{"line":269,"address":[16851363],"length":1,"stats":{"Line":1}},{"line":272,"address":[17092335],"length":1,"stats":{"Line":1}},{"line":274,"address":[16851403],"length":1,"stats":{"Line":1}},{"line":275,"address":[16321047],"length":1,"stats":{"Line":1}},{"line":276,"address":[11636451],"length":1,"stats":{"Line":1}},{"line":281,"address":[17094281,17094320,17094442,17094690,17094877,17094355,17095193],"length":1,"stats":{"Line":3}},{"line":282,"address":[16880915,16880654,16881001,16880744],"length":1,"stats":{"Line":4}},{"line":284,"address":[19845269,19845696,19845641,19845601,19845822],"length":1,"stats":{"Line":3}},{"line":285,"address":[16323984,16324002],"length":1,"stats":{"Line":0}},{"line":288,"address":[16881264],"length":1,"stats":{"Line":1}},{"line":291,"address":[19846179],"length":1,"stats":{"Line":1}},{"line":292,"address":[19846199],"length":1,"stats":{"Line":1}},{"line":293,"address":[19846217],"length":1,"stats":{"Line":1}}],"covered":55,"coverable":101},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","post_service.rs"],"content":"use crate::domain::entities::{Event, Post, User};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse crate::infrastructure::cache::PostCacheService;\nuse crate::infrastructure::database::{BookmarkRepository, PostRepository};\nuse crate::infrastructure::p2p::EventDistributor;\nuse crate::infrastructure::p2p::event_distributor::DistributionStrategy;\nuse crate::shared::error::AppError;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\n\npub struct PostService {\n    repository: Arc<dyn PostRepository>,\n    bookmark_repository: Arc<dyn BookmarkRepository>,\n    distributor: Arc<dyn EventDistributor>,\n    cache: Arc<PostCacheService>,\n    keys: Option<Keys>,\n}\n\nimpl PostService {\n    pub fn new(\n        repository: Arc<dyn PostRepository>,\n        bookmark_repository: Arc<dyn BookmarkRepository>,\n        distributor: Arc<dyn EventDistributor>,\n    ) -> Self {\n        Self {\n            repository,\n            bookmark_repository,\n            distributor,\n            cache: Arc::new(PostCacheService::new()),\n            keys: None,\n        }\n    }\n\n    pub fn with_keys(mut self, keys: Keys) -> Self {\n        self.keys = Some(keys);\n        self\n    }\n\n    pub async fn create_post(\n        &self,\n        content: String,\n        author: User,\n        topic_id: String,\n    ) -> Result<Post, AppError> {\n        let mut post = Post::new(content.clone(), author.clone(), topic_id.clone());\n\n        // Save to database\n        self.repository.create_post(&post).await?;\n\n        // Convert to Nostr event and distribute\n        if let Some(ref keys) = self.keys {\n            // Create Nostr event with topic tag\n            let tag = Tag::hashtag(topic_id.clone());\n\n            let mut event_builder = EventBuilder::text_note(&content);\n            event_builder = event_builder.tag(tag);\n            let nostr_event = event_builder.sign_with_keys(keys)?;\n\n            // Convert to domain Event\n            let mut event = Event::new(\n                1, // Kind 1 for text notes\n                content,\n                author.pubkey.clone(),\n            );\n            event.tags = vec![vec![\"t\".to_string(), topic_id]];\n\n            // Distribute via P2P\n            self.distributor\n                .distribute(&event, DistributionStrategy::Hybrid)\n                .await?;\n\n            // Mark post as synced\n            post.mark_as_synced(nostr_event.id.to_hex());\n            self.repository.update_post(&post).await?;\n        }\n\n        // 新規作成した投稿をキャッシュに保存\n        self.cache.add(post.clone()).await;\n\n        Ok(post)\n    }\n\n    pub async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        // キャッシュから取得を試みる\n        if let Some(post) = self.cache.get(id).await {\n            return Ok(Some(post));\n        }\n\n        // キャッシュにない場合はDBから取得\n        let post = self.repository.get_post(id).await?;\n\n        // キャッシュに保存\n        if let Some(ref p) = post {\n            self.cache.add(p.clone()).await;\n        }\n\n        Ok(post)\n    }\n\n    pub async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        // TODO: トピック別の投稿キャッシュを実装\n        // 現在は直接DBから取得（キャッシュの無効化が複雑なため）\n        let posts = self.repository.get_posts_by_topic(topic_id, limit).await?;\n\n        // 個別の投稿をキャッシュに保存\n        for post in &posts {\n            self.cache.add(post.clone()).await;\n        }\n\n        Ok(posts)\n    }\n\n    pub async fn like_post(&self, post_id: &str) -> Result<(), AppError> {\n        if let Some(mut post) = self.repository.get_post(post_id).await? {\n            post.increment_likes();\n            self.repository.update_post(&post).await?;\n\n            // キャッシュを無効化\n            self.cache.remove(post_id).await;\n\n            // Send like event (Nostr reaction)\n            if let Some(ref keys) = self.keys {\n                let event_id = nostr_sdk::EventId::from_hex(post_id)?;\n                // Create a simple reaction event\n                let _reaction_event = EventBuilder::text_note(\"+\")\n                    .tag(Tag::event(event_id))\n                    .sign_with_keys(keys)?;\n\n                // Convert to domain Event and distribute\n                let mut event = Event::new(\n                    7, // Kind 7 for reactions\n                    \"+\".to_string(),\n                    keys.public_key().to_hex(),\n                );\n                event.tags = vec![vec![\"e\".to_string(), post_id.to_string()]];\n\n                self.distributor\n                    .distribute(&event, DistributionStrategy::Nostr)\n                    .await?;\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn boost_post(&self, post_id: &str) -> Result<(), AppError> {\n        if let Some(mut post) = self.repository.get_post(post_id).await? {\n            post.increment_boosts();\n            self.repository.update_post(&post).await?;\n\n            // キャッシュを無効化\n            self.cache.remove(post_id).await;\n\n            // Send boost event (Nostr repost)\n            if let Some(ref keys) = self.keys {\n                let event_id = nostr_sdk::EventId::from_hex(post_id)?;\n                // Create a repost event\n                let _repost_event = EventBuilder::text_note(\"\")\n                    .tag(Tag::event(event_id))\n                    .sign_with_keys(keys)?;\n\n                // Convert to domain Event and distribute\n                let mut event = Event::new(\n                    6, // Kind 6 for reposts\n                    \"\".to_string(),\n                    keys.public_key().to_hex(),\n                );\n                event.tags = vec![vec![\"e\".to_string(), post_id.to_string()]];\n\n                self.distributor\n                    .distribute(&event, DistributionStrategy::Nostr)\n                    .await?;\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        // Send deletion event\n        if let Some(ref keys) = self.keys {\n            let event_id = nostr_sdk::EventId::from_hex(id)?;\n            // Create a deletion event\n            let _deletion_event = EventBuilder::text_note(\"Post deleted\")\n                .tag(Tag::event(event_id))\n                .sign_with_keys(keys)?;\n\n            // Convert to domain Event and distribute\n            let mut event = Event::new(\n                5, // Kind 5 for deletions\n                \"Post deleted\".to_string(),\n                keys.public_key().to_hex(),\n            );\n            event.tags = vec![vec![\"e\".to_string(), id.to_string()]];\n\n            self.distributor\n                .distribute(&event, DistributionStrategy::Nostr)\n                .await?;\n        }\n\n        // Mark as deleted in database\n        self.repository.delete_post(id).await\n    }\n\n    pub async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        self.repository\n            .get_posts_by_author(author_pubkey, limit)\n            .await\n    }\n\n    pub async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        self.repository.get_recent_posts(limit).await\n    }\n\n    pub async fn react_to_post(&self, post_id: &str, reaction: &str) -> Result<(), AppError> {\n        // TODO: Implement reaction logic\n        if reaction == \"+\" {\n            self.like_post(post_id).await\n        } else {\n            // Custom reaction\n            Ok(())\n        }\n    }\n\n    pub async fn bookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id).map_err(AppError::ValidationError)?;\n        let public_key = PublicKey::from_hex_str(user_pubkey).map_err(AppError::ValidationError)?;\n\n        self.bookmark_repository\n            .create_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn unbookmark_post(&self, post_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let event_id = EventId::from_hex(post_id).map_err(AppError::ValidationError)?;\n        let public_key = PublicKey::from_hex_str(user_pubkey).map_err(AppError::ValidationError)?;\n\n        self.bookmark_repository\n            .delete_bookmark(&public_key, &event_id)\n            .await?;\n        // キャッシュを無効化して次回取得時に最新状態を反映\n        self.cache.remove(post_id).await;\n        Ok(())\n    }\n\n    pub async fn get_bookmarked_post_ids(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<String>, AppError> {\n        let public_key = PublicKey::from_hex_str(user_pubkey).map_err(AppError::ValidationError)?;\n\n        let bookmarks = self.bookmark_repository.list_bookmarks(&public_key).await?;\n\n        Ok(bookmarks\n            .into_iter()\n            .map(|bookmark| bookmark.post_id().as_str().to_string())\n            .collect())\n    }\n\n    pub async fn sync_pending_posts(&self) -> Result<u32, AppError> {\n        let unsync_posts = self.repository.get_unsync_posts().await?;\n        let mut synced_count = 0;\n\n        for post in unsync_posts {\n            // Convert to Event and distribute\n            let mut event = Event::new(\n                1, // Kind 1 for text notes\n                post.content.clone(),\n                post.author.pubkey.clone(), // Use pubkey from author\n            );\n            event.tags = vec![vec![\"t\".to_string(), post.topic_id.clone()]];\n\n            // Try to distribute\n            if self\n                .distributor\n                .distribute(&event, DistributionStrategy::Hybrid)\n                .await\n                .is_ok()\n            {\n                // Mark as synced\n                self.repository\n                    .mark_post_synced(&post.id, &event.id)\n                    .await?;\n                synced_count += 1;\n            }\n        }\n\n        Ok(synced_count)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::database::{\n        BookmarkRepository, PostRepository, connection_pool::ConnectionPool,\n        sqlite_repository::SqliteRepository,\n    };\n    use async_trait::async_trait;\n    use std::sync::Arc;\n\n    struct NoopDistributor;\n\n    #[async_trait]\n    impl EventDistributor for NoopDistributor {\n        async fn distribute(\n            &self,\n            _event: &Event,\n            _strategy: DistributionStrategy,\n        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n            Ok(())\n        }\n\n        async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(None)\n        }\n\n        async fn set_strategy(&self, _strategy: DistributionStrategy) {}\n\n        async fn get_pending_events(\n            &self,\n        ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(vec![])\n        }\n\n        async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\n            Ok(0)\n        }\n    }\n\n    async fn setup_post_service() -> PostService {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            )\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create bookmarks table\");\n\n        let repository = Arc::new(SqliteRepository::new(pool));\n        let distributor: Arc<dyn EventDistributor> = Arc::new(NoopDistributor);\n\n        PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            distributor,\n        )\n    }\n\n    const SAMPLE_PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    #[tokio::test]\n    async fn bookmark_flow_roundtrip() {\n        let service = setup_post_service().await;\n        let event_id = EventId::generate();\n        let event_hex = event_id.to_hex();\n\n        service\n            .bookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"bookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks\");\n        assert_eq!(bookmarked, vec![event_hex.clone()]);\n\n        service\n            .unbookmark_post(&event_hex, SAMPLE_PUBKEY)\n            .await\n            .expect(\"unbookmark should succeed\");\n\n        let bookmarked = service\n            .get_bookmarked_post_ids(SAMPLE_PUBKEY)\n            .await\n            .expect(\"list bookmarks after removal\");\n        assert!(bookmarked.is_empty());\n    }\n}\n","traces":[{"line":20,"address":[12084464,12084768,12084809],"length":1,"stats":{"Line":1}},{"line":29,"address":[15455445,15455383],"length":1,"stats":{"Line":2}},{"line":34,"address":[12111759,12111568],"length":1,"stats":{"Line":0}},{"line":35,"address":[16558545,16558647],"length":1,"stats":{"Line":0}},{"line":36,"address":[12111736],"length":1,"stats":{"Line":0}},{"line":39,"address":[12085056],"length":1,"stats":{"Line":0}},{"line":45,"address":[16559213,16559898,16559356,16559917],"length":1,"stats":{"Line":0}},{"line":48,"address":[11556260,11558685,11555573,11555216,11555689,11555957],"length":1,"stats":{"Line":0}},{"line":51,"address":[12113465,12116925,12113368],"length":1,"stats":{"Line":0}},{"line":53,"address":[15457700,15457580],"length":1,"stats":{"Line":0}},{"line":55,"address":[12113662],"length":1,"stats":{"Line":0}},{"line":56,"address":[16560620],"length":1,"stats":{"Line":0}},{"line":57,"address":[16562642,16560936,16561327],"length":1,"stats":{"Line":0}},{"line":62,"address":[12328452],"length":1,"stats":{"Line":0}},{"line":63,"address":[12328513],"length":1,"stats":{"Line":0}},{"line":65,"address":[16562569,16561518,16561588],"length":1,"stats":{"Line":0}},{"line":68,"address":[12329586,12330172,12330324,12330557,12329684,12329769,12330042],"length":1,"stats":{"Line":0}},{"line":69,"address":[16562403],"length":1,"stats":{"Line":0}},{"line":70,"address":[11148220],"length":1,"stats":{"Line":0}},{"line":73,"address":[12116152,12116262],"length":1,"stats":{"Line":0}},{"line":74,"address":[16563292,16563570,16563853,16559322,16563097],"length":1,"stats":{"Line":0}},{"line":78,"address":[15461010,15457614,15461627,15456495],"length":1,"stats":{"Line":0}},{"line":80,"address":[12090999],"length":1,"stats":{"Line":0}},{"line":83,"address":[15462332,15462080,15462417,15462128,15462190,15462592,15463238,15462098],"length":1,"stats":{"Line":0}},{"line":85,"address":[18954097],"length":1,"stats":{"Line":0}},{"line":86,"address":[16565586],"length":1,"stats":{"Line":0}},{"line":90,"address":[14269477],"length":1,"stats":{"Line":0}},{"line":93,"address":[12092766,12092879],"length":1,"stats":{"Line":0}},{"line":94,"address":[10898681],"length":1,"stats":{"Line":0}},{"line":97,"address":[12092939],"length":1,"stats":{"Line":0}},{"line":100,"address":[12093392],"length":1,"stats":{"Line":0}},{"line":107,"address":[15465118,15464520,15464447,15464629,15464764,15465289],"length":1,"stats":{"Line":0}},{"line":110,"address":[12094269,12094922,12094776,12094426],"length":1,"stats":{"Line":0}},{"line":111,"address":[11196805],"length":1,"stats":{"Line":0}},{"line":114,"address":[16568145],"length":1,"stats":{"Line":0}},{"line":117,"address":[12095104,12095489,12095710,12095122,12095214,12095383,12095152,12096683],"length":1,"stats":{"Line":0}},{"line":118,"address":[12095413,12095555,12095742,12096595,12095334],"length":1,"stats":{"Line":0}},{"line":119,"address":[16569539],"length":1,"stats":{"Line":0}},{"line":120,"address":[14271752],"length":1,"stats":{"Line":0}},{"line":123,"address":[18956414],"length":1,"stats":{"Line":0}},{"line":126,"address":[16570733],"length":1,"stats":{"Line":0}},{"line":127,"address":[16570785,16572786,16570949,16570845],"length":1,"stats":{"Line":0}},{"line":129,"address":[15468852,15468781,15469095,15470426,15468545],"length":1,"stats":{"Line":0}},{"line":130,"address":[15468828,15468645,15470431],"length":1,"stats":{"Line":0}},{"line":131,"address":[11567831],"length":1,"stats":{"Line":0}},{"line":136,"address":[16571385,16571540],"length":1,"stats":{"Line":0}},{"line":137,"address":[15469255,15469191],"length":1,"stats":{"Line":0}},{"line":139,"address":[16571760,16571696,16572686],"length":1,"stats":{"Line":0}},{"line":141,"address":[12099481,12099331,12099414,12099736,12099860,12099994],"length":1,"stats":{"Line":0}},{"line":142,"address":[12099381],"length":1,"stats":{"Line":0}},{"line":143,"address":[12126378,12126186,12126698,12126514,12126239,12122212],"length":1,"stats":{"Line":0}},{"line":146,"address":[16569837],"length":1,"stats":{"Line":0}},{"line":149,"address":[15470978,15471345,15471239,15470960,15471008,15471070,15472539,15471566],"length":1,"stats":{"Line":0}},{"line":150,"address":[15471190,15471411,15472451,15471598,15471269],"length":1,"stats":{"Line":0}},{"line":151,"address":[12101299],"length":1,"stats":{"Line":0}},{"line":152,"address":[12102039,12102245,12101402,12100474,12101732],"length":1,"stats":{"Line":0}},{"line":155,"address":[15472817,15471311,15473092,15472932],"length":1,"stats":{"Line":0}},{"line":158,"address":[15473392],"length":1,"stats":{"Line":0}},{"line":159,"address":[16575794,16575693,16575633,16577628],"length":1,"stats":{"Line":0}},{"line":161,"address":[16575787,16575995,16576066,16577601,16576306],"length":1,"stats":{"Line":0}},{"line":162,"address":[12104649,12102866,12103049],"length":1,"stats":{"Line":0}},{"line":163,"address":[11572865],"length":1,"stats":{"Line":0}},{"line":168,"address":[11572837,11572993],"length":1,"stats":{"Line":0}},{"line":169,"address":[12130209,12130145],"length":1,"stats":{"Line":0}},{"line":171,"address":[12103553,12104571,12103621],"length":1,"stats":{"Line":0}},{"line":173,"address":[11574628,11573965,11574370,11574048,11574115,11574494],"length":1,"stats":{"Line":0}},{"line":174,"address":[12345247],"length":1,"stats":{"Line":0}},{"line":175,"address":[12100516,12104812,12104996,12104537,12104484,12104676],"length":1,"stats":{"Line":0}},{"line":178,"address":[12101621],"length":1,"stats":{"Line":0}},{"line":181,"address":[12346253,12346048,12346000,12346433,12346095,12346018,12348380,12348571],"length":1,"stats":{"Line":0}},{"line":183,"address":[12132221,12132132],"length":1,"stats":{"Line":0}},{"line":184,"address":[12105517,12105756,12107737,12105648],"length":1,"stats":{"Line":0}},{"line":186,"address":[12106032,12105725,12105961,12107630,12106275],"length":1,"stats":{"Line":0}},{"line":187,"address":[12105825,12106008,12107715],"length":1,"stats":{"Line":0}},{"line":188,"address":[12132963],"length":1,"stats":{"Line":0}},{"line":193,"address":[12106196,12106355],"length":1,"stats":{"Line":0}},{"line":194,"address":[12347203,12347267],"length":1,"stats":{"Line":0}},{"line":196,"address":[12347415,12348389,12347344],"length":1,"stats":{"Line":0}},{"line":198,"address":[11577465,11577586,11576939,11577025,11577717,11577092],"length":1,"stats":{"Line":0}},{"line":199,"address":[15478211],"length":1,"stats":{"Line":0}},{"line":200,"address":[10343121],"length":1,"stats":{"Line":0}},{"line":204,"address":[10935064],"length":1,"stats":{"Line":0}},{"line":207,"address":[12349472],"length":1,"stats":{"Line":0}},{"line":212,"address":[12135723,12135586,12135782,12135955],"length":1,"stats":{"Line":0}},{"line":214,"address":[12135641,12135795,12135987,12135852,12135751],"length":1,"stats":{"Line":0}},{"line":217,"address":[12136160,12136195,12136351,12136128,12136141,12136793,12136507,12136311],"length":1,"stats":{"Line":0}},{"line":218,"address":[12109803,12109602,12109674,12109547],"length":1,"stats":{"Line":0}},{"line":221,"address":[12351216,12350940,12351728,12351176,12350976,12350912,12351470,12351011],"length":1,"stats":{"Line":0}},{"line":223,"address":[15481251,15481129,15481269],"length":1,"stats":{"Line":0}},{"line":224,"address":[10962471],"length":1,"stats":{"Line":0}},{"line":227,"address":[12137177],"length":1,"stats":{"Line":0}},{"line":231,"address":[12111020,12110976,12111253,12111195,12110940,12112139,12110912,12112980],"length":1,"stats":{"Line":4}},{"line":232,"address":[16583928,16584766,16584080,16584225],"length":1,"stats":{"Line":2}},{"line":233,"address":[12138510,12138190,12138326,12138765],"length":1,"stats":{"Line":2}},{"line":235,"address":[12138656,12138715,12139493,12139184,12138470,12139022],"length":1,"stats":{"Line":5}},{"line":236,"address":[11581501],"length":1,"stats":{"Line":1}},{"line":237,"address":[12138684,12139118,12138907,12139442,12138734,12137958],"length":1,"stats":{"Line":5}},{"line":239,"address":[10962210],"length":1,"stats":{"Line":1}},{"line":240,"address":[12113259],"length":1,"stats":{"Line":1}},{"line":243,"address":[12354268,12354224,12354188,12354443,12355387,12354160,12354501,12355928],"length":1,"stats":{"Line":4}},{"line":244,"address":[15484705,15485286,15484532,15484392],"length":1,"stats":{"Line":2}},{"line":245,"address":[15485261,15484822,15485006,15484686],"length":1,"stats":{"Line":2}},{"line":247,"address":[12114693,12114791,12114911,12114150,12114395,12114336],"length":1,"stats":{"Line":5}},{"line":248,"address":[12114317],"length":1,"stats":{"Line":1}},{"line":249,"address":[19000833],"length":1,"stats":{"Line":4}},{"line":251,"address":[11186229],"length":1,"stats":{"Line":2}},{"line":252,"address":[12115375],"length":1,"stats":{"Line":1}},{"line":255,"address":[12356272],"length":1,"stats":{"Line":1}},{"line":259,"address":[11585231,11585334,11585499,11585737],"length":1,"stats":{"Line":2}},{"line":261,"address":[14338788],"length":1,"stats":{"Line":3}},{"line":263,"address":[11586340,11586163],"length":1,"stats":{"Line":2}},{"line":265,"address":[12357808,12357776],"length":1,"stats":{"Line":2}},{"line":269,"address":[12357960,12358492,12358031,12357952,12358287,12358187,12357984,12359191],"length":1,"stats":{"Line":0}},{"line":270,"address":[12117385,12117521,12118136,12117306,12117692,12118337],"length":1,"stats":{"Line":0}},{"line":271,"address":[15488860],"length":1,"stats":{"Line":0}},{"line":273,"address":[12359883,12359085,12358894,12359941],"length":1,"stats":{"Line":0}},{"line":277,"address":[11588745,11588951],"length":1,"stats":{"Line":0}},{"line":278,"address":[11588959],"length":1,"stats":{"Line":0}},{"line":280,"address":[11589104,11590700],"length":1,"stats":{"Line":0}},{"line":283,"address":[12147460,12145618,12147131,12147216,12147340,12147531,12147036],"length":1,"stats":{"Line":0}},{"line":285,"address":[16592682],"length":1,"stats":{"Line":0}},{"line":286,"address":[10982939],"length":1,"stats":{"Line":0}},{"line":290,"address":[12120842,12118824,12118706,12121016,12121073,12118551],"length":1,"stats":{"Line":0}},{"line":291,"address":[11590502],"length":1,"stats":{"Line":0}},{"line":292,"address":[15491860,15489399,15488243,15489221,15491911,15489608],"length":1,"stats":{"Line":0}},{"line":293,"address":[12359716,12359591,12359700],"length":1,"stats":{"Line":0}},{"line":297,"address":[16591522],"length":1,"stats":{"Line":0}}],"covered":23,"coverable":127},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","subscription_state.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse std::sync::Arc;\n\n#[async_trait]\npub trait SubscriptionStateStore: Send + Sync {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError>;\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError>;\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n}\n\n#[derive(Clone)]\npub struct SubscriptionStateMachine {\n    repository: Arc<dyn SubscriptionStateRepository>,\n}\n\nimpl SubscriptionStateMachine {\n    pub fn new(repository: Arc<dyn SubscriptionStateRepository>) -> Self {\n        Self { repository }\n    }\n\n    async fn load_or_initialize(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        match self.repository.find(target).await? {\n            Some(record) => Ok(record),\n            None => Ok(SubscriptionRecord::new(target.clone())),\n        }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateStore for SubscriptionStateMachine {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self\n            .repository\n            .find(&target)\n            .await?\n            .unwrap_or_else(|| SubscriptionRecord::new(target.clone()));\n\n        record.mark_requested(now_secs);\n\n        self.repository.upsert(&record).await\n    }\n\n    async fn mark_subscribed(\n        &self,\n        target: &SubscriptionTarget,\n        synced_at: i64,\n    ) -> Result<(), AppError> {\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_subscribed(synced_at);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError> {\n        let now_secs = Utc::now().timestamp();\n        let mut record = self.load_or_initialize(target).await?;\n        record.mark_failure(now_secs, error);\n        self.repository.upsert(&record).await?;\n        Ok(())\n    }\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\n        let now_ms = Utc::now().timestamp_millis();\n        self.repository.mark_all_need_resync(now_ms).await\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_for_restore().await\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        self.repository.list_all().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::value_objects::subscription::SubscriptionStatus;\n    use crate::infrastructure::database::{\n        SqliteSubscriptionStateRepository, connection_pool::ConnectionPool,\n    };\n\n    async fn setup_state_machine() -> SubscriptionStateMachine {\n        let pool = ConnectionPool::from_memory().await.unwrap();\n        sqlx::migrate!(\"./migrations\")\n            .run(pool.get_pool())\n            .await\n            .unwrap();\n        let repository = Arc::new(SqliteSubscriptionStateRepository::new(pool));\n        SubscriptionStateMachine::new(repository)\n    }\n\n    #[tokio::test]\n    async fn record_request_inserts_and_updates() {\n        let machine = setup_state_machine().await;\n        let record = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record.failure_count, 0);\n        assert_eq!(record.status, SubscriptionStatus::Pending);\n\n        let record_again = machine\n            .record_request(SubscriptionTarget::Topic(\"test\".into()))\n            .await\n            .unwrap();\n        assert_eq!(record_again.status, SubscriptionStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn mark_subscribed_updates_status() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 100).await.unwrap();\n        let all = machine.list_all().await.unwrap();\n        assert_eq!(all[0].status, SubscriptionStatus::Subscribed);\n        assert_eq!(all[0].last_synced_at, Some(100));\n    }\n\n    #[tokio::test]\n    async fn mark_failure_increments_counter() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"fail_topic\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_failure(&target, \"error\").await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(|record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"fail_topic\"))\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n        assert_eq!(record.failure_count, 1);\n        assert_eq!(record.error_message.as_deref(), Some(\"error\"));\n    }\n\n    #[tokio::test]\n    async fn mark_all_need_resync_updates_subscribed() {\n        let machine = setup_state_machine().await;\n        let target = SubscriptionTarget::Topic(\"resync\".into());\n        machine.record_request(target.clone()).await.unwrap();\n        machine.mark_subscribed(&target, 200).await.unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n        let records = machine.list_all().await.unwrap();\n        let record = records\n            .into_iter()\n            .find(\n                |record| matches!(&record.target, SubscriptionTarget::Topic(id) if id == \"resync\"),\n            )\n            .unwrap();\n        assert_eq!(record.status, SubscriptionStatus::NeedsResync);\n    }\n\n    #[tokio::test]\n    async fn list_for_restore_filters_status() {\n        let machine = setup_state_machine().await;\n        let pending_target = SubscriptionTarget::Topic(\"pending\".into());\n        machine.record_request(pending_target).await.unwrap();\n        let subscribed_target = SubscriptionTarget::User(\"user\".into());\n        machine\n            .record_request(subscribed_target.clone())\n            .await\n            .unwrap();\n        machine\n            .mark_subscribed(&subscribed_target, 100)\n            .await\n            .unwrap();\n        machine.mark_all_need_resync().await.unwrap();\n\n        let restore = machine.list_for_restore().await.unwrap();\n        assert_eq!(restore.len(), 2);\n    }\n}\n","traces":[{"line":36,"address":[16593520],"length":1,"stats":{"Line":2}},{"line":40,"address":[18662864],"length":1,"stats":{"Line":1}},{"line":44,"address":[11018164],"length":1,"stats":{"Line":3}},{"line":45,"address":[18663719],"length":1,"stats":{"Line":1}},{"line":46,"address":[13448655,13448733],"length":1,"stats":{"Line":0}},{"line":57,"address":[18722109,18722176],"length":1,"stats":{"Line":6}},{"line":58,"address":[18165155,18165578,18165824,18165400,18165100,18165214,18165762],"length":1,"stats":{"Line":15}},{"line":60,"address":[16752011],"length":1,"stats":{"Line":3}},{"line":61,"address":[18165512,18165183,18165230,18165792,18165290,18164747],"length":1,"stats":{"Line":8}},{"line":62,"address":[16753664,16753682,16752591],"length":1,"stats":{"Line":4}},{"line":64,"address":[18937093],"length":1,"stats":{"Line":2}},{"line":66,"address":[18166118,18166030,18166360,18164768,18165939],"length":1,"stats":{"Line":7}},{"line":74,"address":[13483835,13483566,13482863,13483002,13482549],"length":1,"stats":{"Line":2}},{"line":75,"address":[18698579],"length":1,"stats":{"Line":1}},{"line":76,"address":[18168489,18168320,18167207],"length":1,"stats":{"Line":2}},{"line":77,"address":[18169134],"length":1,"stats":{"Line":1}},{"line":80,"address":[18169303,18169360,18169488,18170880,18170002,18169395,18169769],"length":1,"stats":{"Line":3}},{"line":81,"address":[13485185],"length":1,"stats":{"Line":1}},{"line":82,"address":[13484875,13485394,13486235,13485255,13485966],"length":1,"stats":{"Line":2}},{"line":83,"address":[13485931],"length":1,"stats":{"Line":1}},{"line":84,"address":[19204459,19204504,19204402],"length":1,"stats":{"Line":2}},{"line":85,"address":[18701934],"length":1,"stats":{"Line":1}},{"line":88,"address":[16758442,16758355,16758320,16758692,16758281,16758938,16759215],"length":1,"stats":{"Line":3}},{"line":89,"address":[18729289],"length":1,"stats":{"Line":1}},{"line":90,"address":[10646964],"length":1,"stats":{"Line":2}},{"line":93,"address":[18944058,18944493,18943897,18943936,18944306,18944782,18943971],"length":1,"stats":{"Line":3}},{"line":94,"address":[19208132],"length":1,"stats":{"Line":2}},{"line":97,"address":[13489011,13489822,13489533,13488937,13488976,13489098,13489346],"length":1,"stats":{"Line":3}},{"line":98,"address":[10632852],"length":1,"stats":{"Line":2}}],"covered":28,"coverable":29},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","sync_service.rs"],"content":"use crate::infrastructure::p2p::NetworkService;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct SyncStatus {\n    pub is_syncing: bool,\n    pub pending_posts: u32,\n    pub pending_events: u32,\n    pub last_sync: Option<i64>,\n    pub sync_errors: u32,\n}\n\npub struct SyncService {\n    network: Arc<dyn NetworkService>,\n    post_service: Arc<super::PostService>,\n    event_service: Arc<super::EventService>,\n    status: Arc<RwLock<SyncStatus>>,\n}\n\nimpl SyncService {\n    pub fn new(\n        network: Arc<dyn NetworkService>,\n        post_service: Arc<super::PostService>,\n        event_service: Arc<super::EventService>,\n    ) -> Self {\n        Self {\n            network,\n            post_service,\n            event_service,\n            status: Arc::new(RwLock::new(SyncStatus {\n                is_syncing: false,\n                pending_posts: 0,\n                pending_events: 0,\n                last_sync: None,\n                sync_errors: 0,\n            })),\n        }\n    }\n\n    pub async fn start_sync(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        let mut status = self.status.write().await;\n\n        if status.is_syncing {\n            return Ok(());\n        }\n\n        status.is_syncing = true;\n        drop(status);\n\n        // Ensure network is connected\n        if !self.network.is_connected().await {\n            self.network.connect().await?;\n        }\n\n        // Sync pending posts\n        let synced_posts = self.post_service.sync_pending_posts().await?;\n\n        // Sync pending events\n        let synced_events = self.event_service.sync_pending_events().await?;\n\n        // Update status\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        status.last_sync = Some(chrono::Utc::now().timestamp());\n        status.pending_posts = status.pending_posts.saturating_sub(synced_posts);\n        status.pending_events = status.pending_events.saturating_sub(synced_events);\n\n        Ok(())\n    }\n\n    pub async fn stop_sync(&self) -> Result<(), Box<dyn std::error::Error>> {\n        let mut status = self.status.write().await;\n        status.is_syncing = false;\n        Ok(())\n    }\n\n    pub async fn get_status(&self) -> SyncStatus {\n        self.status.read().await.clone()\n    }\n\n    pub async fn reset_sync(&self) -> Result<(), Box<dyn std::error::Error>> {\n        let mut status = self.status.write().await;\n        status.pending_posts = 0;\n        status.pending_events = 0;\n        status.sync_errors = 0;\n        Ok(())\n    }\n\n    pub async fn schedule_sync(&self, interval_secs: u64) {\n        let service = Arc::new(self.clone());\n        tokio::spawn(async move {\n            let mut interval =\n                tokio::time::interval(tokio::time::Duration::from_secs(interval_secs));\n\n            loop {\n                interval.tick().await;\n\n                if let Err(e) = service.start_sync().await {\n                    tracing::error!(\"Sync error: {}\", e);\n                    let mut status = service.status.write().await;\n                    status.sync_errors += 1;\n                }\n            }\n        });\n    }\n}\n\nimpl Clone for SyncService {\n    fn clone(&self) -> Self {\n        Self {\n            network: self.network.clone(),\n            post_service: self.post_service.clone(),\n            event_service: self.event_service.clone(),\n            status: self.status.clone(),\n        }\n    }\n}\n","traces":[{"line":22,"address":[13960249,13959904,13960208],"length":1,"stats":{"Line":0}},{"line":31,"address":[14731217,14731359],"length":1,"stats":{"Line":0}},{"line":41,"address":[14732749,14731536,14731512,14731721,14731504,14731881,14732043,14731595],"length":1,"stats":{"Line":0}},{"line":42,"address":[11144881],"length":1,"stats":{"Line":0}},{"line":44,"address":[14074621,14074701],"length":1,"stats":{"Line":0}},{"line":45,"address":[14732450],"length":1,"stats":{"Line":0}},{"line":48,"address":[14074759,14074707],"length":1,"stats":{"Line":0}},{"line":49,"address":[14491647],"length":1,"stats":{"Line":0}},{"line":52,"address":[10338849],"length":1,"stats":{"Line":0}},{"line":53,"address":[14519576,14518885,14517697,14518976,14519371],"length":1,"stats":{"Line":0}},{"line":57,"address":[11144950],"length":1,"stats":{"Line":0}},{"line":60,"address":[14520127,14517739,14519992,14519882,14520440,14520630],"length":1,"stats":{"Line":0}},{"line":63,"address":[14734609,14734851,14731856,14734505],"length":1,"stats":{"Line":0}},{"line":64,"address":[17865147,17865074],"length":1,"stats":{"Line":0}},{"line":65,"address":[13963935],"length":1,"stats":{"Line":0}},{"line":66,"address":[14494455],"length":1,"stats":{"Line":0}},{"line":67,"address":[14077485],"length":1,"stats":{"Line":0}},{"line":69,"address":[14494633],"length":1,"stats":{"Line":0}},{"line":72,"address":[14077765,14077802,14077648,14077931,14077632,14077640,14077683,14078312],"length":1,"stats":{"Line":0}},{"line":73,"address":[17865653,17865700,17865759,17865883],"length":1,"stats":{"Line":0}},{"line":74,"address":[14078174,14078226],"length":1,"stats":{"Line":0}},{"line":75,"address":[17866170],"length":1,"stats":{"Line":0}},{"line":78,"address":[14078469,14079043,14078344,14078387,14078336,14078635,14078506,14078352],"length":1,"stats":{"Line":0}},{"line":79,"address":[10903812],"length":1,"stats":{"Line":0}},{"line":82,"address":[14079056,14079064,14079226,14079107,14079072,14079355,14079797,14079189],"length":1,"stats":{"Line":0}},{"line":83,"address":[17867204,17867387,17867263,17867157],"length":1,"stats":{"Line":0}},{"line":84,"address":[14523592,14523525],"length":1,"stats":{"Line":0}},{"line":85,"address":[14737695],"length":1,"stats":{"Line":0}},{"line":86,"address":[14523632],"length":1,"stats":{"Line":0}},{"line":87,"address":[14496927],"length":1,"stats":{"Line":0}},{"line":90,"address":[14079821,14079860,14079808,14079840,14080135,14079944],"length":1,"stats":{"Line":0}},{"line":91,"address":[14497230,14497148],"length":1,"stats":{"Line":0}},{"line":92,"address":[14527751,14524175,14524005,14524271,14524470,14524144],"length":1,"stats":{"Line":0}},{"line":94,"address":[13967268,13967101],"length":1,"stats":{"Line":0}},{"line":97,"address":[19054617],"length":1,"stats":{"Line":0}},{"line":99,"address":[14738407,14738616,14739470],"length":1,"stats":{"Line":0}},{"line":100,"address":[14082270,14081704,14081765,14216207,14216073],"length":1,"stats":{"Line":0}},{"line":101,"address":[14370018],"length":1,"stats":{"Line":0}},{"line":102,"address":[14524928,14524983,14524852],"length":1,"stats":{"Line":0}},{"line":110,"address":[13970656,13970958],"length":1,"stats":{"Line":0}},{"line":112,"address":[17871904],"length":1,"stats":{"Line":0}},{"line":113,"address":[14527913,14527848],"length":1,"stats":{"Line":0}},{"line":114,"address":[14083858,14083912],"length":1,"stats":{"Line":0}},{"line":115,"address":[14083917],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":44},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","topic_service.rs"],"content":"use crate::domain::entities::Topic;\nuse crate::infrastructure::database::TopicRepository;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub struct TopicService {\n    repository: Arc<dyn TopicRepository>,\n    gossip: Arc<dyn GossipService>,\n}\n\nimpl TopicService {\n    pub fn new(repository: Arc<dyn TopicRepository>, gossip: Arc<dyn GossipService>) -> Self {\n        Self { repository, gossip }\n    }\n\n    pub async fn create_topic(\n        &self,\n        name: String,\n        description: Option<String>,\n    ) -> Result<Topic, AppError> {\n        let topic = Topic::new(name, description);\n        self.repository.create_topic(&topic).await?;\n\n        // Join gossip topic\n        self.gossip.join_topic(&topic.id, vec![]).await?;\n\n        Ok(topic)\n    }\n\n    pub async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        self.repository.get_topic(id).await\n    }\n\n    pub async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_all_topics().await\n    }\n\n    pub async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        self.repository.get_joined_topics(user_pubkey).await\n    }\n\n    pub async fn join_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.join_topic(id, user_pubkey).await?;\n        self.gossip.join_topic(id, vec![]).await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(&self, id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        self.repository.leave_topic(id, user_pubkey).await?;\n        self.gossip.leave_topic(id).await?;\n        Ok(())\n    }\n\n    pub async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        self.repository.update_topic(topic).await\n    }\n\n    pub async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        // Prevent deletion of public topic\n        if id == \"public\" {\n            return Err(\"Cannot delete public topic\".into());\n        }\n\n        self.gossip.leave_topic(id).await?;\n        self.repository.delete_topic(id).await\n    }\n\n    pub async fn get_topic_stats(&self, id: &str) -> Result<(u32, u32), AppError> {\n        if let Some(topic) = self.repository.get_topic(id).await? {\n            Ok((topic.member_count, topic.post_count))\n        } else {\n            Ok((0, 0))\n        }\n    }\n\n    pub async fn ensure_public_topic(&self) -> Result<(), AppError> {\n        if self.repository.get_topic(\"public\").await?.is_none() {\n            let public_topic = Topic::public_topic();\n            self.repository.create_topic(&public_topic).await?;\n            self.gossip.join_topic(\"public\", vec![]).await?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::database::TopicRepository as InfraTopicRepository;\n    use crate::infrastructure::p2p::GossipService;\n    use async_trait::async_trait;\n    use mockall::{mock, predicate::*};\n\n    mock! {\n        pub TopicRepo {}\n\n        #[async_trait]\n        impl InfraTopicRepository for TopicRepo {\n            async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n            async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n            async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n            async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n            async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n            async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n            async fn update_topic_stats(\n                &self,\n                topic_id: &str,\n                member_count: u32,\n                post_count: u32,\n            ) -> Result<(), AppError>;\n        }\n    }\n\n    mock! {\n        pub GossipSvc {}\n\n        #[async_trait]\n        impl GossipService for GossipSvc {\n            async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n            async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\n            async fn broadcast(&self, topic: &str, event: &crate::domain::entities::Event) -> Result<(), AppError>;\n            async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<crate::domain::entities::Event>, AppError>;\n            async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n            async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n            async fn get_topic_stats(&self, topic: &str) -> Result<Option<crate::domain::p2p::TopicStats>, AppError>;\n            async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n        }\n    }\n\n    #[tokio::test]\n    async fn test_join_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_join_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut gossip = MockGossipSvc::new();\n        gossip\n            .expect_join_topic()\n            .with(eq(\"tech\"), eq(Vec::<String>::new()))\n            .times(1)\n            .returning(|_, _| Ok(()));\n\n        let repo_arc: Arc<dyn InfraTopicRepository> = Arc::new(repo);\n        let gossip_arc: Arc<dyn GossipService> = Arc::new(gossip);\n        let service = TopicService::new(repo_arc, gossip_arc);\n\n        let result = service.join_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_leave_topic_calls_repository_and_gossip() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_leave_topic()\n            .with(eq(\"tech\"), eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_, _| Ok(()));\n        let mut gossip = MockGossipSvc::new();\n        gossip\n            .expect_leave_topic()\n            .with(eq(\"tech\"))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let repo_arc: Arc<dyn InfraTopicRepository> = Arc::new(repo);\n        let gossip_arc: Arc<dyn GossipService> = Arc::new(gossip);\n        let service = TopicService::new(repo_arc, gossip_arc);\n\n        let result = service.leave_topic(\"tech\", \"pubkey1\").await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_get_joined_topics_passes_user_pubkey() {\n        let mut repo = MockTopicRepo::new();\n        repo.expect_get_joined_topics()\n            .with(eq(\"pubkey1\"))\n            .times(1)\n            .returning(|_| Ok(vec![]));\n        let gossip = MockGossipSvc::new();\n\n        let repo_arc: Arc<dyn InfraTopicRepository> = Arc::new(repo);\n        let gossip_arc: Arc<dyn GossipService> = Arc::new(gossip);\n        let service = TopicService::new(repo_arc, gossip_arc);\n        let result = service.get_joined_topics(\"pubkey1\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().len(), 0);\n    }\n}\n","traces":[{"line":13,"address":[11845088],"length":1,"stats":{"Line":1}},{"line":17,"address":[15746352],"length":1,"stats":{"Line":0}},{"line":22,"address":[12616639],"length":1,"stats":{"Line":0}},{"line":23,"address":[15746692,15747359,15746776,15747050,15747656,15746876],"length":1,"stats":{"Line":0}},{"line":26,"address":[12617709,12618039,12617464,12618162,12617338,12616729],"length":1,"stats":{"Line":0}},{"line":28,"address":[14799605],"length":1,"stats":{"Line":0}},{"line":31,"address":[12618854,12618176,12618194,12618585,12618259,12618224,12618385,12618425],"length":1,"stats":{"Line":0}},{"line":32,"address":[12377657,12377580,12377532,12377785],"length":1,"stats":{"Line":0}},{"line":35,"address":[12618872,12618915,12619002,12619471,12619189,12618864,12618880,12619039],"length":1,"stats":{"Line":0}},{"line":36,"address":[19005652],"length":1,"stats":{"Line":0}},{"line":39,"address":[12405440,12405641,12405801,12405475,12405392,12405410,12406086,12405601],"length":1,"stats":{"Line":4}},{"line":40,"address":[12405628,12405580,12405705,12405833],"length":1,"stats":{"Line":2}},{"line":43,"address":[12379424,12379388,12380606,12379360,12379723,12379927,12379471,12379659],"length":1,"stats":{"Line":4}},{"line":44,"address":[14302497],"length":1,"stats":{"Line":2}},{"line":45,"address":[12407351,12406952,12407078,12407625,12406446],"length":1,"stats":{"Line":2}},{"line":46,"address":[11850472],"length":1,"stats":{"Line":1}},{"line":49,"address":[15752319,15751804,15751887,15751776,15752931,15752066,15751840,15752130],"length":1,"stats":{"Line":4}},{"line":50,"address":[10373873],"length":1,"stats":{"Line":2}},{"line":51,"address":[14306709],"length":1,"stats":{"Line":2}},{"line":52,"address":[15753197],"length":1,"stats":{"Line":1}},{"line":55,"address":[15753328,15753309,15753363,15753472,15753954,15753296,15753668,15753512],"length":1,"stats":{"Line":0}},{"line":56,"address":[14311012],"length":1,"stats":{"Line":0}},{"line":59,"address":[15754016,15754664,15754060,15753986,15754250,15753968,15755188,15754192],"length":1,"stats":{"Line":0}},{"line":61,"address":[11853085,11852942],"length":1,"stats":{"Line":0}},{"line":62,"address":[15754517,15754344],"length":1,"stats":{"Line":0}},{"line":65,"address":[12624411,12625002,12624235,12624323,12625199,12624712],"length":1,"stats":{"Line":0}},{"line":66,"address":[15755065,15755197,15754237,15754953],"length":1,"stats":{"Line":0}},{"line":69,"address":[12384873,12385034,12385707,12384672,12384624,12384707,12384642,12384833],"length":1,"stats":{"Line":0}},{"line":70,"address":[12385066,12385703,12384937,12384860,12384812],"length":1,"stats":{"Line":0}},{"line":71,"address":[11855125],"length":1,"stats":{"Line":0}},{"line":73,"address":[11855269],"length":1,"stats":{"Line":0}},{"line":77,"address":[14807848,14808331,14807919,14807840,14809142,14808037,14807872,14808122],"length":1,"stats":{"Line":0}},{"line":78,"address":[12412816,12412999,12412695,12413843,12412623],"length":1,"stats":{"Line":0}},{"line":79,"address":[15757667],"length":1,"stats":{"Line":0}},{"line":80,"address":[11205576],"length":1,"stats":{"Line":0}},{"line":81,"address":[11857376,11857187,11857668,11855601,11857061],"length":1,"stats":{"Line":0}},{"line":83,"address":[14808898],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","application","services","user_service.rs"],"content":"use crate::domain::entities::{User, UserMetadata};\nuse crate::infrastructure::database::UserRepository;\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub struct UserService {\n    repository: Arc<dyn UserRepository>,\n}\n\nimpl UserService {\n    pub fn new(repository: Arc<dyn UserRepository>) -> Self {\n        Self { repository }\n    }\n\n    pub async fn create_user(&self, npub: String, pubkey: String) -> Result<User, AppError> {\n        let user = User::new(npub, pubkey);\n        self.repository.create_user(&user).await?;\n        Ok(user)\n    }\n\n    pub async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        self.repository.get_user(npub).await\n    }\n\n    pub async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\n        self.repository.get_user_by_pubkey(pubkey).await\n    }\n\n    pub async fn update_profile(&self, npub: &str, metadata: UserMetadata) -> Result<(), AppError> {\n        if let Some(mut user) = self.repository.get_user(npub).await? {\n            user.update_metadata(metadata);\n            self.repository.update_user(&user).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_user(&self, user: User) -> Result<(), AppError> {\n        self.repository.update_user(&user).await\n    }\n\n    pub async fn follow_user(\n        &self,\n        _follower_npub: &str,\n        _target_npub: &str,\n    ) -> Result<(), AppError> {\n        // TODO: Implement follow relationship\n        Ok(())\n    }\n\n    pub async fn unfollow_user(\n        &self,\n        _follower_npub: &str,\n        _target_npub: &str,\n    ) -> Result<(), AppError> {\n        // TODO: Implement unfollow\n        Ok(())\n    }\n\n    pub async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError> {\n        self.repository.get_followers(npub).await\n    }\n\n    pub async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError> {\n        self.repository.get_following(npub).await\n    }\n\n    pub async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\n        self.repository.delete_user(npub).await\n    }\n}\n","traces":[{"line":11,"address":[15775328],"length":1,"stats":{"Line":0}},{"line":15,"address":[15802653,15802211,15802413,15802176,15803131,15802096,15802104,15802373],"length":1,"stats":{"Line":0}},{"line":16,"address":[16016436],"length":1,"stats":{"Line":0}},{"line":17,"address":[10935444],"length":1,"stats":{"Line":0}},{"line":18,"address":[15776206],"length":1,"stats":{"Line":0}},{"line":21,"address":[16017457,16017657,16017296,16017266,16017331,16017497,16017926,16017248],"length":1,"stats":{"Line":0}},{"line":22,"address":[15803340,15803465,15803388,15803593],"length":1,"stats":{"Line":0}},{"line":25,"address":[16017936,16018145,16018185,16018614,16017984,16018345,16017954,16018019],"length":1,"stats":{"Line":0}},{"line":26,"address":[15246892,15246940,15247017,15247145],"length":1,"stats":{"Line":0}},{"line":29,"address":[10563406,10562752,10564375,10562864,10563153,10562797,10562911,10564805],"length":1,"stats":{"Line":0}},{"line":30,"address":[10967071],"length":1,"stats":{"Line":0}},{"line":31,"address":[15248611],"length":1,"stats":{"Line":0}},{"line":32,"address":[15778244,15779718,15779424,15779177],"length":1,"stats":{"Line":0}},{"line":34,"address":[14087933],"length":1,"stats":{"Line":0}},{"line":37,"address":[15806867,15806832,15807296,15807540,15806947,15807080,15807664,15806912],"length":1,"stats":{"Line":0}},{"line":38,"address":[10343757],"length":1,"stats":{"Line":0}},{"line":41,"address":[15780944],"length":1,"stats":{"Line":0}},{"line":47,"address":[15250713],"length":1,"stats":{"Line":0}},{"line":50,"address":[15781200],"length":1,"stats":{"Line":0}},{"line":56,"address":[15808105],"length":1,"stats":{"Line":0}},{"line":59,"address":[15781474,15781456,15781705,15781539,15781504,15782150,15781865,15781665],"length":1,"stats":{"Line":0}},{"line":60,"address":[14306836],"length":1,"stats":{"Line":0}},{"line":63,"address":[15251778,15251843,15252169,15251808,15251760,15252454,15251969,15252009],"length":1,"stats":{"Line":0}},{"line":64,"address":[16023305,16023433,16023180,16023228],"length":1,"stats":{"Line":0}},{"line":67,"address":[15783073,15782912,15782864,15782947,15782882,15783113,15783273,15783558],"length":1,"stats":{"Line":0}},{"line":68,"address":[14091576,14091653,14091773,14091532],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","default_topics.rs"],"content":"use std::collections::HashSet;\nuse tokio::sync::RwLock;\n\n/// 既定トピック集合を管理し、非同期アクセスを直列化するレジストリ。\npub struct DefaultTopicsRegistry {\n    topics: RwLock<HashSet<String>>,\n}\n\nimpl DefaultTopicsRegistry {\n    pub fn with_topics<I>(topics: I) -> Self\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut set = HashSet::new();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                set.insert(topic);\n            }\n        }\n        Self {\n            topics: RwLock::new(set),\n        }\n    }\n\n    pub async fn replace_with_single(&self, topic: String) {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        if !topic.trim().is_empty() {\n            guard.insert(topic);\n        }\n    }\n\n    pub async fn replace_all<I>(&self, topics: I)\n    where\n        I: IntoIterator<Item = String>,\n    {\n        let mut guard = self.topics.write().await;\n        guard.clear();\n        for topic in topics {\n            let topic = topic.trim().to_string();\n            if !topic.is_empty() {\n                guard.insert(topic);\n            }\n        }\n    }\n\n    pub async fn add(&self, topic: String) {\n        let normalized = topic.trim();\n        if normalized.is_empty() {\n            return;\n        }\n        let mut guard = self.topics.write().await;\n        guard.insert(normalized.to_string());\n    }\n\n    pub async fn remove(&self, topic: &str) {\n        let mut guard = self.topics.write().await;\n        guard.remove(topic);\n    }\n\n    pub async fn list(&self) -> Vec<String> {\n        let guard = self.topics.read().await;\n        guard.iter().cloned().collect()\n    }\n\n    pub async fn snapshot(&self) -> HashSet<String> {\n        let guard = self.topics.read().await;\n        guard.clone()\n    }\n}\n","traces":[{"line":10,"address":[12860634,12859760,12860662],"length":1,"stats":{"Line":1}},{"line":14,"address":[17544422],"length":1,"stats":{"Line":1}},{"line":15,"address":[18101753,18101652,18101844,18101898],"length":1,"stats":{"Line":4}},{"line":16,"address":[17544802,17545001],"length":1,"stats":{"Line":2}},{"line":17,"address":[19804187,19804243],"length":1,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[17544822],"length":1,"stats":{"Line":1}},{"line":26,"address":[18102488,18102528,18102480,18102553,18102840,18103442,18102686],"length":1,"stats":{"Line":0}},{"line":27,"address":[18316763,18316968,18316809,18316864],"length":1,"stats":{"Line":0}},{"line":28,"address":[18317183,18317250],"length":1,"stats":{"Line":0}},{"line":29,"address":[17546133,17546029,17546199],"length":1,"stats":{"Line":0}},{"line":30,"address":[18103275,18103249],"length":1,"stats":{"Line":0}},{"line":34,"address":[12861744,12861870],"length":1,"stats":{"Line":2}},{"line":38,"address":[11286929],"length":1,"stats":{"Line":2}},{"line":39,"address":[19806126,19806072],"length":1,"stats":{"Line":2}},{"line":40,"address":[18104213,18104416,18104470],"length":1,"stats":{"Line":3}},{"line":41,"address":[17547374,17547512],"length":1,"stats":{"Line":2}},{"line":42,"address":[17547574,17547630],"length":1,"stats":{"Line":2}},{"line":43,"address":[18318904,18318868],"length":1,"stats":{"Line":2}},{"line":48,"address":[18320093,18319686,18319112,18319104,18319177,18319152,18319298,18319608],"length":1,"stats":{"Line":4}},{"line":49,"address":[18078440,18078561],"length":1,"stats":{"Line":2}},{"line":50,"address":[19807270],"length":1,"stats":{"Line":1}},{"line":53,"address":[18319527,18319485,18319718,18319325],"length":1,"stats":{"Line":2}},{"line":54,"address":[19807791,19807742],"length":1,"stats":{"Line":2}},{"line":57,"address":[19807977,19807904,19807952,19808234,19808082,19808119,19808589,19807922],"length":1,"stats":{"Line":4}},{"line":58,"address":[18106225,18106282,18106179,18106386],"length":1,"stats":{"Line":2}},{"line":59,"address":[18106601,18106666],"length":1,"stats":{"Line":2}},{"line":62,"address":[12865112,12865027,12865751,12864992,12864976,12865149,12864984,12865265],"length":1,"stats":{"Line":4}},{"line":63,"address":[10379956],"length":1,"stats":{"Line":2}},{"line":64,"address":[12865533,12865600],"length":1,"stats":{"Line":2}},{"line":67,"address":[18080808,18080851,18080800,18081496,18080816,18080936,18081089,18080973],"length":1,"stats":{"Line":0}},{"line":68,"address":[17550721,17550617,17550517,17550563],"length":1,"stats":{"Line":0}},{"line":69,"address":[19809896,19809956],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","event_id_mapper.rs"],"content":"use crate::domain::value_objects::EventId;\nuse crate::shared::error::AppError;\n\npub(crate) fn parse_event_id(hex: &str) -> Result<EventId, AppError> {\n    EventId::from_hex(hex)\n        .map_err(|err| AppError::ValidationError(format!(\"Invalid event ID: {err}\")))\n}\n\npub(crate) fn parse_optional_event_id(hex: Option<&str>) -> Result<Option<EventId>, AppError> {\n    match hex {\n        Some(value) => parse_event_id(value).map(Some),\n        None => Ok(None),\n    }\n}\n\npub(crate) fn parse_event_ids(hexes: &[String]) -> Result<Vec<EventId>, AppError> {\n    hexes.iter().map(|value| parse_event_id(value)).collect()\n}\n","traces":[{"line":4,"address":[12121248],"length":1,"stats":{"Line":0}},{"line":5,"address":[15492088],"length":1,"stats":{"Line":0}},{"line":6,"address":[11590934,11590912],"length":1,"stats":{"Line":0}},{"line":9,"address":[12121568],"length":1,"stats":{"Line":0}},{"line":10,"address":[15492407],"length":1,"stats":{"Line":0}},{"line":11,"address":[12362504],"length":1,"stats":{"Line":0}},{"line":12,"address":[12148357],"length":1,"stats":{"Line":0}},{"line":16,"address":[14092512],"length":1,"stats":{"Line":0}},{"line":17,"address":[14092562,14092643,14092608],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","metadata_mapper.rs"],"content":"use crate::domain::entities::event_gateway::ProfileMetadata;\nuse crate::presentation::dto::event::NostrMetadataDto;\nuse crate::shared::error::AppError;\nuse nostr_sdk::JsonUtil;\nuse nostr_sdk::prelude::{Metadata, Url};\nuse serde_json::{Map, Value};\n\npub(crate) fn dto_to_profile_metadata(dto: NostrMetadataDto) -> Result<ProfileMetadata, AppError> {\n    ProfileMetadata::new(\n        dto.name,\n        dto.display_name,\n        dto.about,\n        dto.picture,\n        dto.banner,\n        dto.nip05,\n        dto.lud16,\n        dto.website,\n    )\n    .map_err(|err| AppError::ValidationError(format!(\"Invalid profile metadata: {err}\")))\n}\n\npub(crate) fn profile_metadata_to_nostr(metadata: &ProfileMetadata) -> Result<Metadata, AppError> {\n    if let Some(website) = metadata.website.as_ref() {\n        Url::parse(website)\n            .map_err(|_| AppError::ValidationError(\"Invalid website URL\".to_string()))?;\n    }\n\n    let mut map = Map::new();\n    if let Some(name) = metadata.name.as_ref() {\n        map.insert(\"name\".to_string(), Value::String(name.clone()));\n    }\n    if let Some(display_name) = metadata.display_name.as_ref() {\n        map.insert(\n            \"display_name\".to_string(),\n            Value::String(display_name.clone()),\n        );\n    }\n    if let Some(about) = metadata.about.as_ref() {\n        map.insert(\"about\".to_string(), Value::String(about.clone()));\n    }\n    if let Some(picture) = metadata.picture.as_ref() {\n        map.insert(\"picture\".to_string(), Value::String(picture.clone()));\n    }\n    if let Some(banner) = metadata.banner.as_ref() {\n        map.insert(\"banner\".to_string(), Value::String(banner.clone()));\n    }\n    if let Some(nip05) = metadata.nip05.as_ref() {\n        map.insert(\"nip05\".to_string(), Value::String(nip05.clone()));\n    }\n    if let Some(lud16) = metadata.lud16.as_ref() {\n        map.insert(\"lud16\".to_string(), Value::String(lud16.clone()));\n    }\n    if let Some(website) = metadata.website.as_ref() {\n        map.insert(\"website\".to_string(), Value::String(website.clone()));\n    }\n\n    Metadata::from_json(Value::Object(map).to_string())\n        .map_err(|err| AppError::NostrError(err.to_string()))\n}\n","traces":[{"line":8,"address":[14439904],"length":1,"stats":{"Line":0}},{"line":10,"address":[14439921],"length":1,"stats":{"Line":0}},{"line":11,"address":[15211188],"length":1,"stats":{"Line":0}},{"line":12,"address":[18341208],"length":1,"stats":{"Line":0}},{"line":13,"address":[14997164],"length":1,"stats":{"Line":0}},{"line":14,"address":[14970464],"length":1,"stats":{"Line":0}},{"line":15,"address":[16594740],"length":1,"stats":{"Line":0}},{"line":16,"address":[14997278],"length":1,"stats":{"Line":0}},{"line":17,"address":[14970587],"length":1,"stats":{"Line":0}},{"line":19,"address":[15211606,15211584],"length":1,"stats":{"Line":0}},{"line":22,"address":[16598719,16596144,16595248],"length":1,"stats":{"Line":0}},{"line":23,"address":[14971058],"length":1,"stats":{"Line":0}},{"line":24,"address":[14997932,14998225,14998085],"length":1,"stats":{"Line":0}},{"line":25,"address":[16595639,16598752,16598773],"length":1,"stats":{"Line":0}},{"line":28,"address":[14440898],"length":1,"stats":{"Line":0}},{"line":29,"address":[14998063,14998311],"length":1,"stats":{"Line":0}},{"line":30,"address":[14998436,14998369],"length":1,"stats":{"Line":0}},{"line":32,"address":[14441272,14441521],"length":1,"stats":{"Line":0}},{"line":33,"address":[16596391],"length":1,"stats":{"Line":0}},{"line":34,"address":[14971979,14972046],"length":1,"stats":{"Line":0}},{"line":35,"address":[18342870,18342930],"length":1,"stats":{"Line":0}},{"line":38,"address":[18343074,18342834],"length":1,"stats":{"Line":0}},{"line":39,"address":[15213148,15213215],"length":1,"stats":{"Line":0}},{"line":41,"address":[14972595,14972355],"length":1,"stats":{"Line":0}},{"line":42,"address":[14442320,14442253],"length":1,"stats":{"Line":0}},{"line":44,"address":[14442292,14442532],"length":1,"stats":{"Line":0}},{"line":45,"address":[14999726,14999793],"length":1,"stats":{"Line":0}},{"line":47,"address":[15214101,15213861],"length":1,"stats":{"Line":0}},{"line":48,"address":[15214229,15214159],"length":1,"stats":{"Line":0}},{"line":50,"address":[14973609,14973366],"length":1,"stats":{"Line":0}},{"line":51,"address":[14443267,14443337],"length":1,"stats":{"Line":0}},{"line":53,"address":[15214538,15214781],"length":1,"stats":{"Line":0}},{"line":54,"address":[18344823,18344969],"length":1,"stats":{"Line":0}},{"line":57,"address":[16598275,16598657],"length":1,"stats":{"Line":0}},{"line":58,"address":[16598597,16598866,16598848,16598687],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","mod.rs"],"content":"pub(crate) mod event_id_mapper;\npub(crate) mod metadata_mapper;\npub(crate) mod nostr_to_domain;\n\npub(crate) use event_id_mapper::{parse_event_id, parse_event_ids, parse_optional_event_id};\npub(crate) use metadata_mapper::{dto_to_profile_metadata, profile_metadata_to_nostr};\npub(crate) use nostr_to_domain::{\n    domain_event_from_event, domain_event_to_nostr_event, nostr_event_to_domain_event,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","event","nostr_to_domain.rs"],"content":"use crate::application::shared::nostr::to_nostr_event;\nuse crate::domain::entities::Event;\nuse crate::domain::entities::event_gateway::DomainEvent;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse nostr_sdk::prelude::Event as NostrEvent;\n\npub(crate) fn domain_event_from_event(event: &Event) -> Result<DomainEvent, AppError> {\n    DomainEvent::try_from(event)\n        .map_err(|err| AppError::ValidationError(format!(\"Invalid domain event: {err}\")))\n}\n\npub(crate) fn domain_event_to_nostr_event(\n    domain_event: &DomainEvent,\n) -> Result<nostr_sdk::Event, AppError> {\n    to_nostr_event(&domain_event.to_event())\n}\n\npub(crate) fn nostr_event_to_domain_event(event: &NostrEvent) -> Result<Event, AppError> {\n    let id = EventId::from_hex(&event.id.to_string()).map_err(|err| {\n        AppError::ValidationError(format!(\"Invalid event ID received from gateway: {err}\"))\n    })?;\n\n    let created_at = DateTime::<Utc>::from_timestamp(event.created_at.as_u64() as i64, 0)\n        .ok_or_else(|| AppError::ValidationError(\"Invalid event timestamp\".to_string()))?;\n\n    let tags = event.tags.iter().map(|tag| tag.clone().to_vec()).collect();\n\n    Ok(Event::new_with_id(\n        id,\n        event.pubkey.to_string(),\n        event.content.clone(),\n        event.kind.as_u16() as u32,\n        tags,\n        created_at,\n        event.sig.to_string(),\n    ))\n}\n","traces":[{"line":9,"address":[16220528],"length":1,"stats":{"Line":0}},{"line":10,"address":[16750952],"length":1,"stats":{"Line":0}},{"line":11,"address":[11535952,11535974],"length":1,"stats":{"Line":0}},{"line":14,"address":[14093104,14092992],"length":1,"stats":{"Line":1}},{"line":17,"address":[16778008],"length":1,"stats":{"Line":1}},{"line":20,"address":[16779570,16778144,16779703],"length":1,"stats":{"Line":1}},{"line":21,"address":[16778174,16779760,16779990,16778324,16778548],"length":1,"stats":{"Line":2}},{"line":22,"address":[16993878,16993938],"length":1,"stats":{"Line":0}},{"line":25,"address":[14093595,14093797],"length":1,"stats":{"Line":1}},{"line":26,"address":[16753280,16752065,16753294],"length":1,"stats":{"Line":0}},{"line":28,"address":[14093832,14093743,14095040,14095086],"length":1,"stats":{"Line":2}},{"line":30,"address":[16752765,16752589],"length":1,"stats":{"Line":2}},{"line":31,"address":[16993031],"length":1,"stats":{"Line":1}},{"line":32,"address":[16752313,16752244],"length":1,"stats":{"Line":2}},{"line":33,"address":[16993153,16993219],"length":1,"stats":{"Line":2}},{"line":34,"address":[11537355,11537422],"length":1,"stats":{"Line":2}},{"line":35,"address":[14094157],"length":1,"stats":{"Line":1}},{"line":37,"address":[14094205],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","events.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::value_objects::EventId;\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_event_row(row: &SqliteRow) -> Result<Event, AppError> {\n    let event_id_hex: String = row.try_get(\"event_id\")?;\n    let event_id = EventId::from_hex(event_id_hex.as_str())?;\n    let kind = row.try_get::<i64, _>(\"kind\")? as u32;\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n    let tags = parse_event_tags(&tags_json);\n\n    Ok(Event::new_with_id(\n        event_id,\n        row.try_get(\"public_key\")?,\n        row.try_get(\"content\")?,\n        kind,\n        tags,\n        created_at,\n        row.try_get(\"sig\")?,\n    ))\n}\n\npub(crate) fn parse_event_tags(tags_json: &str) -> Vec<Vec<String>> {\n    serde_json::from_str(tags_json).unwrap_or_default()\n}\n","traces":[{"line":7,"address":[18323823,18321152,18324276],"length":1,"stats":{"Line":0}},{"line":8,"address":[16780238,16780440],"length":1,"stats":{"Line":0}},{"line":9,"address":[18321366,18321495,18321645,18324274],"length":1,"stats":{"Line":0}},{"line":10,"address":[18321613,18324215,18321743,18321869],"length":1,"stats":{"Line":0}},{"line":11,"address":[11541591,11539248,11539135],"length":1,"stats":{"Line":0}},{"line":13,"address":[11539462],"length":1,"stats":{"Line":0}},{"line":14,"address":[16224168,16224247],"length":1,"stats":{"Line":0}},{"line":16,"address":[18323151,18323462],"length":1,"stats":{"Line":0}},{"line":17,"address":[16995499],"length":1,"stats":{"Line":0}},{"line":18,"address":[16995547,16995622,16995797],"length":1,"stats":{"Line":0}},{"line":19,"address":[11540046,11540273,11539889],"length":1,"stats":{"Line":0}},{"line":21,"address":[16996061],"length":1,"stats":{"Line":0}},{"line":23,"address":[16782170,16782417,16782013],"length":1,"stats":{"Line":0}},{"line":27,"address":[18324304],"length":1,"stats":{"Line":0}},{"line":28,"address":[18324327],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","mod.rs"],"content":"pub(crate) mod event;\npub(crate) mod events;\npub(crate) mod posts;\npub(crate) mod topics;\npub(crate) mod users;\n\npub(crate) use event::{\n    domain_event_from_event, domain_event_to_nostr_event, dto_to_profile_metadata,\n    nostr_event_to_domain_event, parse_event_id, parse_event_ids, parse_optional_event_id,\n    profile_metadata_to_nostr,\n};\npub(crate) use events::map_event_row;\npub(crate) use posts::map_post_row;\npub(crate) use topics::{map_joined_topic_row, map_topic_row};\npub(crate) use users::map_user_row;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","posts.rs"],"content":"use crate::domain::entities::{Post, User};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_post_row(\n    row: &SqliteRow,\n    fallback_topic: Option<&str>,\n) -> Result<Post, AppError> {\n    let event_id: String = row.try_get(\"event_id\")?;\n    let public_key: String = row.try_get(\"public_key\")?;\n    let content: String = row.try_get(\"content\")?;\n    let created_at: i64 = row.try_get(\"created_at\")?;\n    let tags_json: String = row.try_get(\"tags\").unwrap_or_default();\n\n    let topic_id = fallback_topic\n        .map(|id| id.to_string())\n        .or_else(|| extract_topic_from_tags(&tags_json))\n        .unwrap_or_default();\n\n    let user = User::from_pubkey(&public_key);\n    let created_at = DateTime::from_timestamp_millis(created_at).unwrap_or_else(Utc::now);\n\n    Ok(Post::new_with_id(\n        event_id, content, user, topic_id, created_at,\n    ))\n}\n\npub(crate) fn extract_topic_from_tags(tags_json: &str) -> Option<String> {\n    let tags = serde_json::from_str::<Vec<Vec<String>>>(tags_json).ok()?;\n    tags.into_iter().find_map(|tag| match tag.as_slice() {\n        [key, value, ..] if key == \"t\" => Some(value.clone()),\n        _ => None,\n    })\n}\n","traces":[{"line":6,"address":[12821130,12819120,12821001],"length":1,"stats":{"Line":0}},{"line":10,"address":[13349576,13349784],"length":1,"stats":{"Line":0}},{"line":11,"address":[16720569,16722331,16720695,16720862],"length":1,"stats":{"Line":0}},{"line":12,"address":[11730386,11729097,11728948,11729268],"length":1,"stats":{"Line":0}},{"line":13,"address":[13377042,13377320,13377196],"length":1,"stats":{"Line":0}},{"line":14,"address":[13377397,13377284],"length":1,"stats":{"Line":0}},{"line":16,"address":[13377434,13377497],"length":1,"stats":{"Line":0}},{"line":17,"address":[13592422,13592400],"length":1,"stats":{"Line":0}},{"line":18,"address":[11730496,11730514],"length":1,"stats":{"Line":0}},{"line":21,"address":[13350907,13350839],"length":1,"stats":{"Line":0}},{"line":22,"address":[11729890,11729845],"length":1,"stats":{"Line":0}},{"line":24,"address":[13351188],"length":1,"stats":{"Line":0}},{"line":25,"address":[13591858],"length":1,"stats":{"Line":0}},{"line":29,"address":[13351680,13352078],"length":1,"stats":{"Line":0}},{"line":30,"address":[13592544,13592746],"length":1,"stats":{"Line":0}},{"line":31,"address":[16722944,16722665,16722794,16722979,16723218],"length":1,"stats":{"Line":0}},{"line":32,"address":[11731238,11731088,11731119],"length":1,"stats":{"Line":0}},{"line":33,"address":[11731099],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","topics.rs"],"content":"use crate::domain::entities::Topic;\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    base_topic_from_row(row)\n}\n\npub(crate) fn map_joined_topic_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let mut topic = base_topic_from_row(row)?;\n    topic.is_joined = true;\n    Ok(topic)\n}\n\nfn base_topic_from_row(row: &SqliteRow) -> Result<Topic, AppError> {\n    let created_at =\n        DateTime::from_timestamp_millis(row.try_get(\"created_at\")?).unwrap_or_else(Utc::now);\n    let description = row\n        .try_get::<Option<String>, _>(\"description\")?\n        .unwrap_or_default();\n    let mut topic = Topic::new_with_id(\n        row.try_get(\"topic_id\")?,\n        row.try_get(\"name\")?,\n        description,\n        created_at,\n    );\n    topic.updated_at =\n        DateTime::from_timestamp_millis(row.try_get(\"updated_at\")?).unwrap_or(created_at);\n    topic.member_count = row.try_get::<i64, _>(\"member_count\")? as u32;\n    topic.post_count = row.try_get::<i64, _>(\"post_count\")? as u32;\n    Ok(topic)\n}\n","traces":[{"line":6,"address":[17263824],"length":1,"stats":{"Line":0}},{"line":7,"address":[14133857],"length":1,"stats":{"Line":0}},{"line":10,"address":[13893040],"length":1,"stats":{"Line":0}},{"line":11,"address":[13919978,13919800],"length":1,"stats":{"Line":0}},{"line":12,"address":[13893183],"length":1,"stats":{"Line":0}},{"line":13,"address":[17264007],"length":1,"stats":{"Line":0}},{"line":16,"address":[14134176,14136292,14136193],"length":1,"stats":{"Line":0}},{"line":17,"address":[18324960,18324750],"length":1,"stats":{"Line":0}},{"line":19,"address":[17264332,17264474,17264606],"length":1,"stats":{"Line":0}},{"line":23,"address":[18325378,18325083,18325207],"length":1,"stats":{"Line":0}},{"line":24,"address":[13921115,13920732,13920889],"length":1,"stats":{"Line":0}},{"line":25,"address":[13894251],"length":1,"stats":{"Line":0}},{"line":28,"address":[13894824],"length":1,"stats":{"Line":0}},{"line":29,"address":[13921321,13921246,13922083],"length":1,"stats":{"Line":0}},{"line":30,"address":[14135686,14135843,14136177],"length":1,"stats":{"Line":0}},{"line":31,"address":[18326543,18326394,18326626,18326289],"length":1,"stats":{"Line":0}},{"line":32,"address":[18326479],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":17},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mappers","users.rs"],"content":"use crate::domain::entities::{User, UserProfile};\nuse crate::shared::error::AppError;\nuse sqlx::{Row, sqlite::SqliteRow};\n\npub(crate) fn map_user_row(row: &SqliteRow) -> Result<User, AppError> {\n    let profile = UserProfile {\n        display_name: row.try_get(\"display_name\").unwrap_or_default(),\n        bio: row.try_get(\"bio\").unwrap_or_default(),\n        avatar_url: row.try_get(\"avatar_url\").ok(),\n    };\n\n    let user = User::new_with_profile(row.try_get(\"npub\")?, profile);\n    Ok(user)\n}\n","traces":[{"line":5,"address":[13971833,13971804,13970992],"length":1,"stats":{"Line":0}},{"line":7,"address":[14528166],"length":1,"stats":{"Line":0}},{"line":8,"address":[13971163,13971098],"length":1,"stats":{"Line":0}},{"line":9,"address":[17872411,17872483],"length":1,"stats":{"Line":0}},{"line":12,"address":[19810459,19810391],"length":1,"stats":{"Line":0}},{"line":13,"address":[19810739],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","mod.rs"],"content":"pub mod default_topics;\npub mod mappers;\npub mod nostr;\n#[doc(hidden)]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","factory.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::shared::error::AppError;\nuse nostr_sdk::JsonUtil;\nuse serde_json::json;\n\npub fn build_deletion_event(id: &str, pubkey: String) -> Event {\n    let mut deletion_event = Event::new(EventKind::EventDeletion.as_u32(), String::new(), pubkey);\n    deletion_event.add_e_tag(id.to_string());\n    deletion_event\n}\n\npub fn to_nostr_event(event: &Event) -> Result<nostr_sdk::Event, AppError> {\n    let event_json = json!({\n        \"id\": event.id,\n        \"pubkey\": event.pubkey,\n        \"created_at\": event.created_at.timestamp(),\n        \"kind\": event.kind,\n        \"tags\": event.tags,\n        \"content\": event.content,\n        \"sig\": event.sig,\n    });\n\n    nostr_sdk::Event::from_json(event_json.to_string())\n        .map_err(|e| AppError::NostrError(format!(\"Failed to convert event: {e}\")))\n}\n","traces":[{"line":6,"address":[19195299,19194960],"length":1,"stats":{"Line":0}},{"line":7,"address":[13979967,13980054],"length":1,"stats":{"Line":0}},{"line":8,"address":[18664842,18664782],"length":1,"stats":{"Line":0}},{"line":9,"address":[19195271],"length":1,"stats":{"Line":0}},{"line":12,"address":[13980304,13982188],"length":1,"stats":{"Line":1}},{"line":13,"address":[19436863,19436206,19438082,19436810],"length":1,"stats":{"Line":2}},{"line":16,"address":[19222695,19222759],"length":1,"stats":{"Line":2}},{"line":23,"address":[19812935,19813013],"length":1,"stats":{"Line":2}},{"line":24,"address":[19813278,19813248],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","mod.rs"],"content":"pub mod factory;\npub mod publisher;\n\npub use factory::*;\npub use publisher::EventPublisher;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","nostr","publisher.rs"],"content":"use anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse tracing::{debug, info};\n\n/// Nostr イベントの生成を担う共通パブリッシャー。\n#[derive(Default)]\npub struct EventPublisher {\n    keys: Option<Keys>,\n}\n\nimpl EventPublisher {\n    /// 新しい EventPublisher インスタンスを作成\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// 鍵を設定\n    pub fn set_keys(&mut self, keys: Keys) {\n        self.keys = Some(keys);\n    }\n\n    /// テキストノートイベントを作成\n    pub fn create_text_note(&self, content: &str, tags: Vec<Tag>) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\n        let event = EventBuilder::text_note(content)\n            .tags(tags)\n            .sign_with_keys(keys)?;\n\n        debug!(\"Created text note event: {}\", event.id);\n        Ok(event)\n    }\n\n    /// メタデータイベントを作成\n    pub fn create_metadata(&self, metadata: Metadata) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\n        let event = EventBuilder::metadata(&metadata).sign_with_keys(keys)?;\n\n        debug!(\"Created metadata event: {}\", event.id);\n        Ok(event)\n    }\n\n    /// リアクションイベントを作成\n    pub fn create_reaction(&self, event_id: &EventId, reaction: &str) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\n        // リアクションイベント用のタグを作成\n        let tags = vec![Tag::event(*event_id), Tag::public_key(keys.public_key())];\n\n        let event = EventBuilder::new(Kind::Reaction, reaction)\n            .tags(tags)\n            .sign_with_keys(keys)?;\n\n        debug!(\"Created reaction event: {}\", event.id);\n        Ok(event)\n    }\n\n    /// 削除イベントを作成\n    pub fn create_deletion(&self, event_ids: Vec<EventId>, reason: Option<&str>) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\n        // 削除イベント用のタグを作成\n        let tags: Vec<Tag> = event_ids.iter().map(|id| Tag::event(*id)).collect();\n\n        let content = reason.unwrap_or(\"\");\n\n        let event = EventBuilder::new(Kind::EventDeletion, content)\n            .tags(tags)\n            .sign_with_keys(keys)?;\n\n        debug!(\"Created deletion event: {}\", event.id);\n        Ok(event)\n    }\n\n    /// トピック投稿イベントを作成（kukuri 独自実装）\n    pub fn create_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n    ) -> Result<Event> {\n        let keys = self\n            .keys\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Keys not set\"))?;\n\n        let mut tags = vec![\n            Tag::hashtag(topic_id),\n            Tag::custom(TagKind::Custom(\"topic\".into()), vec![topic_id.to_string()]),\n        ];\n\n        if let Some(reply_id) = reply_to {\n            tags.push(Tag::event(reply_id));\n            tags.push(Tag::custom(\n                TagKind::Custom(\"reply\".into()),\n                vec![reply_id.to_string()],\n            ));\n        }\n\n        let event = EventBuilder::text_note(content)\n            .tags(tags)\n            .sign_with_keys(keys)?;\n\n        info!(\"Created topic post for topic: {}\", topic_id);\n        Ok(event)\n    }\n\n    /// 公開鍵を取得\n    pub fn get_public_key(&self) -> Option<PublicKey> {\n        self.keys.as_ref().map(|k| k.public_key())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_event_publisher_creation() {\n        let publisher = EventPublisher::new();\n        assert!(publisher.keys.is_none());\n    }\n\n    #[test]\n    fn test_set_keys() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        let public_key = keys.public_key();\n\n        publisher.set_keys(keys);\n        assert_eq!(publisher.get_public_key(), Some(public_key));\n    }\n\n    #[test]\n    fn test_create_text_note() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let event = publisher.create_text_note(\"Hello, Nostr!\", vec![]).unwrap();\n        assert_eq!(event.content, \"Hello, Nostr!\");\n        assert_eq!(event.kind, Kind::TextNote);\n    }\n\n    #[test]\n    fn test_create_text_note_with_tags() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let tags = vec![Tag::hashtag(\"nostr\"), Tag::hashtag(\"test\")];\n\n        let event = publisher\n            .create_text_note(\"Hello with tags!\", tags.clone())\n            .unwrap();\n        assert_eq!(event.content, \"Hello with tags!\");\n\n        // タグが含まれていることを確認\n        let event_tags: Vec<_> = event.tags.into_iter().collect();\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"nostr\")));\n        assert!(event_tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"test\")));\n    }\n\n    #[test]\n    fn test_create_metadata() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let metadata = Metadata::new()\n            .name(\"Test User\")\n            .about(\"Test about\")\n            .picture(Url::parse(\"https://example.com/pic.jpg\").unwrap());\n\n        let event = publisher.create_metadata(metadata).unwrap();\n        assert_eq!(event.kind, Kind::Metadata);\n        assert!(event.content.contains(\"Test User\"));\n    }\n\n    #[test]\n    fn test_create_reaction() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys.clone());\n\n        let event_id = EventId::from_slice(&[1; 32]).unwrap();\n        let event = publisher.create_reaction(&event_id, \"+\").unwrap();\n\n        assert_eq!(event.kind, Kind::Reaction);\n        assert_eq!(event.content, \"+\");\n\n        // タグにイベントIDが含まれていることを確認\n        let tags: Vec<_> = event.tags.into_iter().collect();\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id: id, .. }) if id == &event_id)));\n    }\n\n    #[test]\n    fn test_create_deletion() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let event_ids = vec![\n            EventId::from_slice(&[1; 32]).unwrap(),\n            EventId::from_slice(&[2; 32]).unwrap(),\n        ];\n\n        let event = publisher\n            .create_deletion(event_ids.clone(), Some(\"Spam\"))\n            .unwrap();\n        assert_eq!(event.kind, Kind::EventDeletion);\n        assert_eq!(event.content, \"Spam\");\n\n        // 削除対象のイベントIDが含まれていることを確認\n        let tags: Vec<_> = event.tags.into_iter().collect();\n        for id in &event_ids {\n            assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == id)));\n        }\n    }\n\n    #[test]\n    fn test_create_topic_post() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let event = publisher\n            .create_topic_post(\"bitcoin\", \"Let's discuss Bitcoin!\", None)\n            .unwrap();\n        assert!(event.content.contains(\"Let's discuss Bitcoin!\"));\n\n        // タグを確認\n        let tags: Vec<_> = event.tags.into_iter().collect();\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Hashtag(h)) if h == \"bitcoin\")));\n        assert!(\n            tags.iter()\n                .any(|t| t.kind().to_string() == \"topic\" && t.content().is_some())\n        );\n    }\n\n    #[test]\n    fn test_create_topic_post_with_reply() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        let reply_to = EventId::from_slice(&[3; 32]).unwrap();\n        let event = publisher\n            .create_topic_post(\"nostr\", \"Reply to thread\", Some(reply_to))\n            .unwrap();\n\n        // タグにリプライ情報が含まれていることを確認\n        let tags: Vec<_> = event.tags.into_iter().collect();\n        assert!(tags.iter().any(|t| matches!(t.as_standardized(), Some(nostr_sdk::TagStandard::Event { event_id, .. }) if event_id == &reply_to)));\n        assert!(\n            tags.iter()\n                .any(|t| t.kind().to_string() == \"reply\" && t.content().is_some())\n        );\n    }\n\n    #[test]\n    fn test_no_keys_error() {\n        let publisher = EventPublisher::new();\n\n        // 鍵が設定されていない状態で各メソッドを呼び出すとエラーになることを確認\n        assert!(publisher.create_text_note(\"test\", vec![]).is_err());\n        assert!(publisher.create_metadata(Metadata::new()).is_err());\n        assert!(\n            publisher\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\n                .is_err()\n        );\n        assert!(publisher.create_deletion(vec![], None).is_err());\n        assert!(\n            publisher\n                .create_topic_post(\"topic\", \"content\", None)\n                .is_err()\n        );\n    }\n\n    #[test]\n    fn test_event_signature_verification() {\n        let mut publisher = EventPublisher::new();\n        let keys = Keys::generate();\n        publisher.set_keys(keys);\n\n        // 各種イベントを作成して署名が正しいことを確認\n        let events = vec![\n            publisher.create_text_note(\"test\", vec![]).unwrap(),\n            publisher\n                .create_metadata(Metadata::new().name(\"test\"))\n                .unwrap(),\n            publisher\n                .create_reaction(&EventId::from_slice(&[1; 32]).unwrap(), \"+\")\n                .unwrap(),\n            publisher\n                .create_topic_post(\"test\", \"content\", None)\n                .unwrap(),\n        ];\n\n        for event in events {\n            assert!(\n                event.verify().is_ok(),\n                \"Event signature verification failed\"\n            );\n        }\n    }\n}\n","traces":[{"line":13,"address":[14974784],"length":1,"stats":{"Line":1}},{"line":14,"address":[18562712],"length":1,"stats":{"Line":1}},{"line":18,"address":[14974816,14974900],"length":1,"stats":{"Line":1}},{"line":19,"address":[15001571,15001675],"length":1,"stats":{"Line":5}},{"line":23,"address":[14447832,14447791,14444576],"length":1,"stats":{"Line":1}},{"line":24,"address":[15001802,15001886,15004950,15002082],"length":1,"stats":{"Line":4}},{"line":27,"address":[18349092,18349088,18346146],"length":1,"stats":{"Line":3}},{"line":29,"address":[15216628,15219032,15216238,15216135],"length":1,"stats":{"Line":2}},{"line":30,"address":[18346191],"length":1,"stats":{"Line":1}},{"line":31,"address":[18563629],"length":1,"stats":{"Line":0}},{"line":33,"address":[14976209,14976408,14975876,15064297,15064431,14976843],"length":1,"stats":{"Line":8}},{"line":34,"address":[15003522],"length":1,"stats":{"Line":2}},{"line":38,"address":[18569412,18566256,18569383],"length":1,"stats":{"Line":1}},{"line":39,"address":[14448249,14451069,14448065,14447994],"length":1,"stats":{"Line":4}},{"line":42,"address":[14451088,14451092,14448233],"length":1,"stats":{"Line":3}},{"line":44,"address":[14978618,14981451,14978977,14978694],"length":1,"stats":{"Line":2}},{"line":46,"address":[14448705,14534393,14534527,14449237,14449686,14449038],"length":1,"stats":{"Line":5}},{"line":47,"address":[15006751],"length":1,"stats":{"Line":1}},{"line":51,"address":[14454748,14451152,14454767],"length":1,"stats":{"Line":1}},{"line":52,"address":[18352466,18352656],"length":1,"stats":{"Line":2}},{"line":55,"address":[18573188,18569773,18573184],"length":1,"stats":{"Line":3}},{"line":58,"address":[18569814,18573180,18569695,18570202],"length":1,"stats":{"Line":1}},{"line":60,"address":[18570157,18570299,18570686],"length":1,"stats":{"Line":2}},{"line":61,"address":[14982315],"length":1,"stats":{"Line":1}},{"line":62,"address":[15009433],"length":1,"stats":{"Line":0}},{"line":64,"address":[14535023,14452758,14452425,14453400,14534889,14452957],"length":1,"stats":{"Line":5}},{"line":65,"address":[15010471],"length":1,"stats":{"Line":1}},{"line":69,"address":[15015603,15012016,15015546],"length":1,"stats":{"Line":1}},{"line":70,"address":[18573597,18576838,18573338,18573413],"length":1,"stats":{"Line":4}},{"line":73,"address":[15226461,15229716,15229712],"length":1,"stats":{"Line":3}},{"line":76,"address":[18573550,18576949,18576928,18573630],"length":1,"stats":{"Line":4}},{"line":78,"address":[14455502,14455411],"length":1,"stats":{"Line":2}},{"line":80,"address":[18357209,18356734,18356819],"length":1,"stats":{"Line":2}},{"line":81,"address":[18356779],"length":1,"stats":{"Line":1}},{"line":82,"address":[14455945],"length":1,"stats":{"Line":0}},{"line":84,"address":[15014198,15013209,15013741,15013542,15092521,15092655],"length":1,"stats":{"Line":5}},{"line":85,"address":[15228215],"length":1,"stats":{"Line":1}},{"line":89,"address":[15234493,15229856,15231614],"length":1,"stats":{"Line":1}},{"line":95,"address":[15229985,15230169],"length":1,"stats":{"Line":3}},{"line":98,"address":[15016057,15020464,15020468],"length":1,"stats":{"Line":3}},{"line":100,"address":[15020456,15016001,15016091,15016173,15016622,15016822],"length":1,"stats":{"Line":6}},{"line":101,"address":[15230110],"length":1,"stats":{"Line":3}},{"line":102,"address":[14993693,14989478,14989399],"length":1,"stats":{"Line":6}},{"line":105,"address":[15230903,15230942],"length":1,"stats":{"Line":4}},{"line":106,"address":[14990268,14990134],"length":1,"stats":{"Line":2}},{"line":107,"address":[15017479,15017428],"length":1,"stats":{"Line":2}},{"line":108,"address":[14459902],"length":1,"stats":{"Line":1}},{"line":109,"address":[18578362,18578759,18578426],"length":1,"stats":{"Line":2}},{"line":113,"address":[15232080,15231037,15231690],"length":1,"stats":{"Line":4}},{"line":114,"address":[14990818],"length":1,"stats":{"Line":2}},{"line":115,"address":[15232032],"length":1,"stats":{"Line":0}},{"line":117,"address":[15093017,15093151,15018596,15019039,15018064,15018397],"length":1,"stats":{"Line":8}},{"line":118,"address":[14992238],"length":1,"stats":{"Line":2}},{"line":122,"address":[18581808],"length":1,"stats":{"Line":1}},{"line":123,"address":[18581840,18581888,18581872],"length":1,"stats":{"Line":3}}],"covered":51,"coverable":55},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","fixtures.rs"],"content":"use nostr_sdk::prelude::*;\n\npub fn sample_signed_event() -> Event {\n    let keys = Keys::generate();\n    EventBuilder::text_note(\"Test content\")\n        .tags(vec![Tag::hashtag(\"test\")])\n        .sign_with_keys(&keys)\n        .expect(\"sign text note\")\n}\n","traces":[{"line":3,"address":[11667855,11667264,11667819],"length":1,"stats":{"Line":0}},{"line":4,"address":[11667281],"length":1,"stats":{"Line":0}},{"line":5,"address":[13495197,13495125,13494755],"length":1,"stats":{"Line":0}},{"line":6,"address":[13495276,13494823,13495168],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mocks.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse tokio::sync::RwLock;\n\nuse crate::domain::entities as domain;\nuse crate::domain::p2p::TopicStats;\nuse crate::infrastructure::p2p::GossipService;\nuse crate::shared::error::AppError;\n\npub struct TestGossipService {\n    joined: Arc<RwLock<HashSet<String>>>,\n    broadcasts: Arc<RwLock<Vec<(String, domain::Event)>>>,\n}\n\nimpl TestGossipService {\n    pub fn new() -> Self {\n        Self {\n            joined: Arc::new(RwLock::new(HashSet::new())),\n            broadcasts: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn joined_topics(&self) -> HashSet<String> {\n        self.joined.read().await.clone()\n    }\n\n    pub async fn broadcasted_topics(&self) -> Vec<String> {\n        self.broadcasts\n            .read()\n            .await\n            .iter()\n            .map(|(t, _)| t.clone())\n            .collect()\n    }\n}\n\nimpl Default for TestGossipService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl GossipService for TestGossipService {\n    async fn join_topic(&self, topic: &str, _initial_peers: Vec<String>) -> Result<(), AppError> {\n        let mut j = self.joined.write().await;\n        j.insert(topic.to_string());\n        Ok(())\n    }\n\n    async fn leave_topic(&self, _topic: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn broadcast(&self, topic: &str, event: &domain::Event) -> Result<(), AppError> {\n        let mut b = self.broadcasts.write().await;\n        b.push((topic.to_string(), event.clone()));\n        Ok(())\n    }\n\n    async fn subscribe(\n        &self,\n        _topic: &str,\n    ) -> Result<tokio::sync::mpsc::Receiver<domain::Event>, AppError> {\n        let (_tx, rx) = tokio::sync::mpsc::channel(1);\n        Ok(rx)\n    }\n\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_peers(&self, _topic: &str) -> Result<Vec<String>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_topic_stats(&self, _topic: &str) -> Result<Option<TopicStats>, AppError> {\n        Ok(None)\n    }\n\n    async fn broadcast_message(&self, _topic: &str, _message: &[u8]) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[18364704,18364916],"length":1,"stats":{"Line":1}},{"line":20,"address":[14463495],"length":1,"stats":{"Line":1}},{"line":21,"address":[18364840,18364783],"length":1,"stats":{"Line":2}},{"line":25,"address":[19814391,19813712,19813763,19813878,19813728,19813720,19813841,19814010],"length":1,"stats":{"Line":4}},{"line":26,"address":[14994288,14994245,14994347,14994471],"length":1,"stats":{"Line":2}},{"line":29,"address":[15021616,15021654,15021600,15021942,15021786,15022494,15021746,15021608],"length":1,"stats":{"Line":4}},{"line":30,"address":[14995562,14994990,14995102,14995148,14995375,14995489],"length":1,"stats":{"Line":6}},{"line":32,"address":[19814684,19814740,19814914,19814650,19814560],"length":1,"stats":{"Line":3}},{"line":34,"address":[18366625,18366592],"length":1,"stats":{"Line":2}},{"line":40,"address":[19815280],"length":1,"stats":{"Line":0}},{"line":41,"address":[14995841],"length":1,"stats":{"Line":0}},{"line":47,"address":[18438764,18437683,18437648,18438084,18437567,18437915,18438297,18437794],"length":1,"stats":{"Line":4}},{"line":48,"address":[15307837,15308149,15308345,15308215],"length":1,"stats":{"Line":2}},{"line":49,"address":[19869156,19869207],"length":1,"stats":{"Line":2}},{"line":50,"address":[14537462],"length":1,"stats":{"Line":1}},{"line":53,"address":[19869454,19869724,19869424,19869395,19869853,19869522],"length":1,"stats":{"Line":0}},{"line":54,"address":[19869784],"length":1,"stats":{"Line":0}},{"line":57,"address":[18439475,18439383,18439792,18439440,18439565,18439978,18440593],"length":1,"stats":{"Line":3}},{"line":58,"address":[19870136,19870395,19870537],"length":1,"stats":{"Line":1}},{"line":59,"address":[15310253,15310320],"length":1,"stats":{"Line":2}},{"line":60,"address":[14539277],"length":1,"stats":{"Line":1}},{"line":67,"address":[15096956],"length":1,"stats":{"Line":0}},{"line":68,"address":[18441095],"length":1,"stats":{"Line":0}},{"line":71,"address":[15311325,15311257,15311782,15311296,15311393,15311598],"length":1,"stats":{"Line":0}},{"line":72,"address":[18441642],"length":1,"stats":{"Line":0}},{"line":75,"address":[15311985,15312374,15312190,15311917,15311843,15311888],"length":1,"stats":{"Line":0}},{"line":76,"address":[14541018],"length":1,"stats":{"Line":0}},{"line":79,"address":[15098339,15098783,15098384,15098414,15098482,15098610],"length":1,"stats":{"Line":0}},{"line":80,"address":[15071934],"length":1,"stats":{"Line":0}},{"line":83,"address":[19873506,19873438,19873408,19873837,19873708,19873373],"length":1,"stats":{"Line":0}},{"line":84,"address":[19873768],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","event","mod.rs"],"content":"pub mod fixtures;\npub mod mocks;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","mod.rs"],"content":"#![allow(dead_code)]\n\n//! 共通テストユーティリティ。\n\npub mod event;\npub mod p2p;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","bootstrap.rs"],"content":"use crate::domain::p2p::P2PEvent;\nuse crate::infrastructure::p2p::gossip_service::GossipService;\nuse crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\nuse iroh::{Endpoint, NodeAddr};\nuse std::net::{Ipv4Addr, SocketAddrV4};\nuse std::sync::Arc;\nuse tokio::time::{Duration, sleep, timeout};\n\nuse super::logging::log_step;\n\npub const DEFAULT_JOIN_TIMEOUT: Duration = Duration::from_secs(15);\npub const DEFAULT_EVENT_TIMEOUT: Duration = Duration::from_secs(15);\n\n#[derive(Clone, Debug)]\npub struct BootstrapContext {\n    pub hints: Vec<String>,\n    pub node_addrs: Vec<NodeAddr>,\n}\n\npub async fn create_service(ctx: &BootstrapContext) -> IrohGossipService {\n    let bind_addr = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 0);\n    log_step!(\n        \"binding endpoint on {} and enabling DHT discovery (bootstrap hints: {})\",\n        bind_addr,\n        ctx.hints.join(\", \")\n    );\n    let endpoint = Arc::new(\n        Endpoint::builder()\n            .discovery_dht()\n            .bind_addr_v4(bind_addr)\n            .bind()\n            .await\n            .expect(\"failed to bind iroh endpoint\"),\n    );\n    endpoint.online().await;\n    for addr in &ctx.node_addrs {\n        log_step!(\"adding bootstrap node addr {}\", addr.node_id);\n        let _ = endpoint.add_node_addr_with_source(addr.clone(), \"integration-bootstrap\");\n        match endpoint.connect(addr.clone(), iroh_gossip::ALPN).await {\n            Ok(_) => log_step!(\"connected to bootstrap {}\", addr.node_id),\n            Err(err) => log_step!(\"failed to connect to bootstrap {}: {:?}\", addr.node_id, err),\n        }\n    }\n    log_step!(\"endpoint ready, building gossip service\");\n    sleep(Duration::from_millis(200)).await;\n    IrohGossipService::new(endpoint).expect(\"failed to create gossip service\")\n}\n\npub fn build_peer_hints(\n    base: &[String],\n    local_hints: &[Option<String>],\n    self_idx: usize,\n) -> Vec<String> {\n    let mut result = base.to_vec();\n    for (idx, hint) in local_hints.iter().enumerate() {\n        if idx == self_idx {\n            continue;\n        }\n        if let Some(h) = hint {\n            if !result.contains(h) {\n                result.push(h.clone());\n            }\n        }\n    }\n    result\n}\n\npub async fn wait_for_topic_membership(\n    service: &IrohGossipService,\n    topic: &str,\n    timeout_duration: Duration,\n) -> bool {\n    let target = topic.to_string();\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < timeout_duration {\n        log_step!(\n            \"checking joined topics for {} (elapsed {:?}/{:?})\",\n            topic,\n            start.elapsed(),\n            timeout_duration\n        );\n        if let Ok(joined) = service.get_joined_topics().await {\n            log_step!(\"currently joined topics: {:?}\", joined);\n            if joined.iter().any(|t| t == &target) {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(100)).await;\n    }\n    false\n}\n\npub async fn wait_for_peer_join_event(\n    receivers: &mut [&mut tokio::sync::mpsc::UnboundedReceiver<P2PEvent>],\n    max_wait: Duration,\n) -> bool {\n    log_step!(\n        \"waiting up to {:?} for peer join events across {} receivers\",\n        max_wait,\n        receivers.len()\n    );\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < max_wait {\n        for rx in receivers.iter_mut() {\n            if let Ok(Some(evt)) =\n                timeout(Duration::from_millis(150), async { rx.recv().await }).await\n            {\n                if matches!(evt, P2PEvent::PeerJoined { .. }) {\n                    log_step!(\"received PeerJoined event after {:?}\", start.elapsed());\n                    return true;\n                }\n            }\n        }\n    }\n    log_step!(\n        \"timed out waiting for peer join events after {:?}\",\n        max_wait\n    );\n    false\n}\n","traces":[{"line":20,"address":[12414888,12414880,12418064,12414912,12415049,12415316,12417126,12415210],"length":1,"stats":{"Line":0}},{"line":21,"address":[12388643,12388402],"length":1,"stats":{"Line":0}},{"line":22,"address":[11860190,11859548],"length":1,"stats":{"Line":0}},{"line":28,"address":[12632397,12631908,12632329,12631965,12630024,12632099],"length":1,"stats":{"Line":0}},{"line":30,"address":[12391103],"length":1,"stats":{"Line":0}},{"line":32,"address":[12391360,12391297,12388504,12391240,12391499],"length":1,"stats":{"Line":0}},{"line":35,"address":[10659810],"length":1,"stats":{"Line":0}},{"line":36,"address":[17678564,17678629,17673799],"length":1,"stats":{"Line":0}},{"line":38,"address":[15771577,15770193],"length":1,"stats":{"Line":0}},{"line":39,"address":[12388546,12392179,12400855],"length":1,"stats":{"Line":0}},{"line":41,"address":[12636077,12635554,12633438],"length":1,"stats":{"Line":0}},{"line":45,"address":[17680549,17682812,17679164,17670327],"length":1,"stats":{"Line":0}},{"line":46,"address":[11870815],"length":1,"stats":{"Line":0}},{"line":49,"address":[15772850,15772224],"length":1,"stats":{"Line":0}},{"line":54,"address":[12401480],"length":1,"stats":{"Line":0}},{"line":55,"address":[12428542,12428240,12428312],"length":1,"stats":{"Line":0}},{"line":56,"address":[15772659],"length":1,"stats":{"Line":0}},{"line":59,"address":[17683597],"length":1,"stats":{"Line":0}},{"line":60,"address":[11871504],"length":1,"stats":{"Line":0}},{"line":61,"address":[12428715],"length":1,"stats":{"Line":0}},{"line":65,"address":[15772580],"length":1,"stats":{"Line":0}},{"line":68,"address":[17683808],"length":1,"stats":{"Line":0}},{"line":73,"address":[12643114],"length":1,"stats":{"Line":0}},{"line":74,"address":[12429160,12429274],"length":1,"stats":{"Line":0}},{"line":75,"address":[17684614,17684288],"length":1,"stats":{"Line":0}},{"line":76,"address":[12404297,12404898],"length":1,"stats":{"Line":0}},{"line":82,"address":[12643449,12643175,12646161,12644353],"length":1,"stats":{"Line":0}},{"line":84,"address":[12432997,12434880,12434417,12434893],"length":1,"stats":{"Line":0}},{"line":85,"address":[12648624],"length":1,"stats":{"Line":0}},{"line":88,"address":[10660613],"length":1,"stats":{"Line":0}},{"line":90,"address":[12402940],"length":1,"stats":{"Line":0}},{"line":93,"address":[12408192],"length":1,"stats":{"Line":0}},{"line":97,"address":[11879885,11879379],"length":1,"stats":{"Line":0}},{"line":102,"address":[12408996,12410628],"length":1,"stats":{"Line":0}},{"line":103,"address":[12437370,12440369],"length":1,"stats":{"Line":0}},{"line":104,"address":[15784543,15786453,15784300],"length":1,"stats":{"Line":0}},{"line":105,"address":[15781885,15781850,15781913],"length":1,"stats":{"Line":0}},{"line":108,"address":[11880723],"length":1,"stats":{"Line":0}},{"line":109,"address":[12439209,12439716],"length":1,"stats":{"Line":0}},{"line":110,"address":[17693477],"length":1,"stats":{"Line":0}},{"line":119,"address":[17695998],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","config.rs"],"content":"use crate::infrastructure::p2p::utils::parse_peer_hint;\n\nuse super::bootstrap::BootstrapContext;\nuse super::logging::log_step;\n\npub fn load_bootstrap_context(test_name: &str) -> Option<BootstrapContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        log_step!(\"skipping {} (ENABLE_P2P_INTEGRATION != 1)\", test_name);\n        return None;\n    }\n\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    if raw.trim().is_empty() {\n        log_step!(\"skipping {} (KUKURI_BOOTSTRAP_PEERS not set)\", test_name);\n        return None;\n    }\n\n    let mut hints = Vec::new();\n    let mut addrs = Vec::new();\n\n    for entry in raw.split(',') {\n        let trimmed = entry.trim();\n        if trimmed.is_empty() {\n            continue;\n        }\n        hints.push(trimmed.to_string());\n        match parse_peer_hint(trimmed) {\n            Ok(parsed) => {\n                if let Some(addr) = parsed.node_addr {\n                    addrs.push(addr);\n                } else {\n                    log_step!(\"bootstrap peer '{}' missing address; skipping\", trimmed);\n                }\n            }\n            Err(err) => {\n                log_step!(\"failed to parse bootstrap peer '{}': {:?}\", trimmed, err);\n                return None;\n            }\n        }\n    }\n\n    if addrs.is_empty() {\n        log_step!(\n            \"skipping {} (no usable bootstrap node addresses)\",\n            test_name\n        );\n        return None;\n    }\n\n    log_step!(\n        \"test {} using bootstrap peers: {}\",\n        test_name,\n        hints.join(\", \")\n    );\n\n    Some(BootstrapContext {\n        hints,\n        node_addrs: addrs,\n    })\n}\n","traces":[{"line":6,"address":[15404896,15416859,15407817],"length":1,"stats":{"Line":4}},{"line":7,"address":[15404950,15405232],"length":1,"stats":{"Line":8}},{"line":9,"address":[12669960],"length":1,"stats":{"Line":4}},{"line":12,"address":[15405131],"length":1,"stats":{"Line":0}},{"line":13,"address":[15787529,15787658],"length":1,"stats":{"Line":0}},{"line":15,"address":[15797807],"length":1,"stats":{"Line":0}},{"line":18,"address":[11886508],"length":1,"stats":{"Line":0}},{"line":19,"address":[12443694],"length":1,"stats":{"Line":0}},{"line":21,"address":[15405525,15412840,15405605,15405800],"length":1,"stats":{"Line":0}},{"line":22,"address":[12448670,12444076],"length":1,"stats":{"Line":0}},{"line":23,"address":[15792766],"length":1,"stats":{"Line":0}},{"line":26,"address":[15792813],"length":1,"stats":{"Line":0}},{"line":27,"address":[12448802],"length":1,"stats":{"Line":0}},{"line":28,"address":[11891727],"length":1,"stats":{"Line":0}},{"line":29,"address":[12662993,12663072],"length":1,"stats":{"Line":0}},{"line":30,"address":[12449152,12449048],"length":1,"stats":{"Line":0}},{"line":35,"address":[15410665],"length":1,"stats":{"Line":0}},{"line":37,"address":[12424941],"length":1,"stats":{"Line":0}},{"line":42,"address":[15788189,15788098],"length":1,"stats":{"Line":0}},{"line":47,"address":[12661280],"length":1,"stats":{"Line":0}},{"line":50,"address":[12446257,12445622],"length":1,"stats":{"Line":0}},{"line":56,"address":[12418011],"length":1,"stats":{"Line":0}},{"line":57,"address":[15406407],"length":1,"stats":{"Line":0}},{"line":58,"address":[15406455],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","fixtures.rs"],"content":"use crate::domain::entities::Event;\n\npub fn nostr_to_domain(ev: &nostr_sdk::Event) -> Event {\n    let created_at =\n        chrono::DateTime::<chrono::Utc>::from_timestamp(ev.created_at.as_u64() as i64, 0)\n            .expect(\"invalid timestamp in nostr event\");\n    Event {\n        id: ev.id.to_string(),\n        pubkey: ev.pubkey.to_string(),\n        created_at,\n        kind: ev.kind.as_u16() as u32,\n        tags: ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n        content: ev.content.clone(),\n        sig: ev.sig.to_string(),\n    }\n}\n","traces":[{"line":3,"address":[15419054,15418352],"length":1,"stats":{"Line":0}},{"line":4,"address":[15605670],"length":1,"stats":{"Line":0}},{"line":8,"address":[15846577],"length":1,"stats":{"Line":0}},{"line":9,"address":[15418480],"length":1,"stats":{"Line":0}},{"line":11,"address":[15846739,15846669],"length":1,"stats":{"Line":0}},{"line":12,"address":[15419088,15419134,15418626],"length":1,"stats":{"Line":0}},{"line":13,"address":[15418698],"length":1,"stats":{"Line":0}},{"line":14,"address":[15418770],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","logging.rs"],"content":"use std::sync::Once;\nuse tracing_subscriber::EnvFilter;\n\nstatic INIT_TRACING: Once = Once::new();\n\npub fn init_tracing() {\n    INIT_TRACING.call_once(|| {\n        let env_filter = EnvFilter::try_from_default_env()\n            .unwrap_or_else(|_| EnvFilter::new(\"info,iroh_tests=info\"));\n        let subscriber = tracing_subscriber::fmt()\n            .with_env_filter(env_filter)\n            .with_target(true)\n            .compact()\n            .finish();\n        let _ = tracing::subscriber::set_global_default(subscriber);\n    });\n}\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    }};\n}\n\npub(crate) use log_step;\n","traces":[{"line":6,"address":[18081520],"length":1,"stats":{"Line":1}},{"line":7,"address":[18081921,18081552,18081950,18081521],"length":1,"stats":{"Line":4}},{"line":8,"address":[18108340],"length":1,"stats":{"Line":1}},{"line":9,"address":[18108720,18108396,18108704],"length":1,"stats":{"Line":1}},{"line":10,"address":[18081668,18081773],"length":1,"stats":{"Line":2}},{"line":11,"address":[12866688],"length":1,"stats":{"Line":1}},{"line":15,"address":[18081886],"length":1,"stats":{"Line":1}},{"line":21,"address":[15407461,15451583,15405871,15450095,15410697,15452575,15417614,15405246,15413442,15450457,15450591,15408096,15407834,15414995,15412947,15406636,15410929,15415477,15450953,15451087,15416872,15451945,15408476,15410830,15449961,15452079,15405423,15451449,15408958,15452441],"length":1,"stats":{"Line":8}}],"covered":8,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","application","shared","tests","p2p","mod.rs"],"content":"pub mod bootstrap;\npub mod config;\npub mod fixtures;\npub mod logging;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","contract_testing.rs"],"content":"use crate::domain::entities::event::Event;\n\npub fn validate_nip10_tags(tags: Vec<Vec<String>>) -> Result<(), String> {\n    let mut event = Event::new(1, String::new(), \"a\".repeat(64));\n    event.id = \"f\".repeat(64);\n    event.sig = \"f\".repeat(128);\n    event.created_at = chrono::Utc::now();\n    event.tags = tags;\n    event.validate_nip10_19()\n}\n","traces":[{"line":3,"address":[18993932,18993120,18993963],"length":1,"stats":{"Line":1}},{"line":4,"address":[15863158,15863238,15863957],"length":1,"stats":{"Line":2}},{"line":5,"address":[15649346,15649273],"length":1,"stats":{"Line":2}},{"line":6,"address":[15863547],"length":1,"stats":{"Line":1}},{"line":7,"address":[15622873],"length":1,"stats":{"Line":1}},{"line":8,"address":[13571911],"length":1,"stats":{"Line":1}},{"line":9,"address":[13572060],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","account","mod.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// SecureStorage に保存されるアカウント情報を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccountMetadata {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n    pub last_used: DateTime<Utc>,\n}\n\nimpl AccountMetadata {\n    pub fn mark_used(&mut self, timestamp: DateTime<Utc>) {\n        self.last_used = timestamp;\n    }\n}\n\n/// SecureStorage に保存されるアカウント一覧と現在アカウントのメタデータ。\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct AccountsMetadata {\n    pub accounts: HashMap<String, AccountMetadata>,\n    pub current_npub: Option<String>,\n}\n\n/// アカウント登録時に必要な情報。\n#[derive(Debug, Clone)]\npub struct AccountRegistration {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl AccountRegistration {\n    pub fn into_metadata(self) -> (AccountMetadata, String) {\n        let AccountRegistration {\n            npub,\n            nsec,\n            pubkey,\n            name,\n            display_name,\n            picture,\n        } = self;\n\n        let metadata = AccountMetadata {\n            npub: npub.clone(),\n            pubkey,\n            name,\n            display_name,\n            picture,\n            last_used: Utc::now(),\n        };\n\n        (metadata, nsec)\n    }\n}\n\n/// 現在のアカウントのメタデータと秘密鍵。\n#[derive(Debug, Clone)]\npub struct CurrentAccountSecret {\n    pub metadata: AccountMetadata,\n    pub nsec: String,\n}\n","traces":[{"line":17,"address":[16599008],"length":1,"stats":{"Line":0}},{"line":18,"address":[14136341],"length":1,"stats":{"Line":0}},{"line":41,"address":[13366070,13365136,13366299],"length":1,"stats":{"Line":0}},{"line":42,"address":[13365158],"length":1,"stats":{"Line":0}},{"line":43,"address":[13895590],"length":1,"stats":{"Line":0}},{"line":44,"address":[17266423],"length":1,"stats":{"Line":0}},{"line":45,"address":[17266441],"length":1,"stats":{"Line":0}},{"line":46,"address":[13365251],"length":1,"stats":{"Line":0}},{"line":47,"address":[14136515],"length":1,"stats":{"Line":0}},{"line":48,"address":[17266531],"length":1,"stats":{"Line":0}},{"line":52,"address":[13922486],"length":1,"stats":{"Line":0}},{"line":57,"address":[16599473],"length":1,"stats":{"Line":0}},{"line":60,"address":[16599811],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","bookmark.rs"],"content":"use crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// ユーザーが投稿をブックマークした履歴を表現するドメインエンティティ。\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Bookmark {\n    id: BookmarkId,\n    user_pubkey: PublicKey,\n    post_id: EventId,\n    created_at: DateTime<Utc>,\n}\n\nimpl Bookmark {\n    /// 現在時刻で新しいブックマークを作成する。\n    pub fn new(user_pubkey: PublicKey, post_id: EventId) -> Self {\n        Self {\n            id: BookmarkId::random(),\n            user_pubkey,\n            post_id,\n            created_at: Utc::now(),\n        }\n    }\n\n    /// 既存レコードからブックマークを復元する。\n    pub fn from_parts(\n        id: BookmarkId,\n        user_pubkey: PublicKey,\n        post_id: EventId,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            user_pubkey,\n            post_id,\n            created_at,\n        }\n    }\n\n    pub fn id(&self) -> &BookmarkId {\n        &self.id\n    }\n\n    pub fn user_pubkey(&self) -> &PublicKey {\n        &self.user_pubkey\n    }\n\n    pub fn post_id(&self) -> &EventId {\n        &self.post_id\n    }\n\n    pub fn created_at(&self) -> DateTime<Utc> {\n        self.created_at\n    }\n}\n","traces":[{"line":16,"address":[11882390,11881968,11882318],"length":1,"stats":{"Line":1}},{"line":18,"address":[11641163],"length":1,"stats":{"Line":1}},{"line":21,"address":[11882144],"length":1,"stats":{"Line":1}},{"line":26,"address":[15012416],"length":1,"stats":{"Line":1}},{"line":40,"address":[11641696],"length":1,"stats":{"Line":1}},{"line":44,"address":[15012528],"length":1,"stats":{"Line":1}},{"line":45,"address":[13027896],"length":1,"stats":{"Line":1}},{"line":48,"address":[13027904],"length":1,"stats":{"Line":1}},{"line":49,"address":[15012552],"length":1,"stats":{"Line":1}},{"line":52,"address":[13027920],"length":1,"stats":{"Line":1}},{"line":53,"address":[13027928],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":11},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event.rs"],"content":"use crate::domain::value_objects::EventId;\nuse bech32::FromBase32 as _;\nuse chrono::{DateTime, Utc};\nuse nostr_sdk::prelude::{EventId as NostrEventId, FromBech32 as _, PublicKey as NostrPublicKey};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n// NIP-19 厳密なTLVデコードはSDKの公開API差異があるため、\n// ここではEventId/PublicKeyのbech32復号と形式検証で代替する。\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]\n#[repr(u32)]\npub enum EventKind {\n    Metadata = 0,\n    TextNote = 1,\n    RecommendRelay = 2,\n    Contacts = 3,\n    EncryptedDirectMessage = 4,\n    EventDeletion = 5,\n    Repost = 6,\n    Reaction = 7,\n    BadgeAward = 8,\n    ChannelCreation = 40,\n    ChannelMetadata = 41,\n    ChannelMessage = 42,\n    ChannelHideMessage = 43,\n    ChannelMuteUser = 44,\n    Custom(u32),\n}\n\nimpl From<u32> for EventKind {\n    fn from(value: u32) -> Self {\n        match value {\n            0 => EventKind::Metadata,\n            1 => EventKind::TextNote,\n            2 => EventKind::RecommendRelay,\n            3 => EventKind::Contacts,\n            4 => EventKind::EncryptedDirectMessage,\n            5 => EventKind::EventDeletion,\n            6 => EventKind::Repost,\n            7 => EventKind::Reaction,\n            8 => EventKind::BadgeAward,\n            40 => EventKind::ChannelCreation,\n            41 => EventKind::ChannelMetadata,\n            42 => EventKind::ChannelMessage,\n            43 => EventKind::ChannelHideMessage,\n            44 => EventKind::ChannelMuteUser,\n            v => EventKind::Custom(v),\n        }\n    }\n}\n\nimpl From<EventKind> for u32 {\n    fn from(value: EventKind) -> Self {\n        match value {\n            EventKind::Metadata => 0,\n            EventKind::TextNote => 1,\n            EventKind::RecommendRelay => 2,\n            EventKind::Contacts => 3,\n            EventKind::EncryptedDirectMessage => 4,\n            EventKind::EventDeletion => 5,\n            EventKind::Repost => 6,\n            EventKind::Reaction => 7,\n            EventKind::BadgeAward => 8,\n            EventKind::ChannelCreation => 40,\n            EventKind::ChannelMetadata => 41,\n            EventKind::ChannelMessage => 42,\n            EventKind::ChannelHideMessage => 43,\n            EventKind::ChannelMuteUser => 44,\n            EventKind::Custom(v) => v,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Event {\n    pub id: String,\n    pub pubkey: String,\n    pub created_at: DateTime<Utc>,\n    pub kind: u32,\n    pub tags: Vec<Vec<String>>,\n    pub content: String,\n    pub sig: String,\n}\n\nimpl Event {\n    pub fn new(kind: u32, content: String, pubkey: String) -> Self {\n        Self {\n            id: String::new(),\n            pubkey,\n            created_at: chrono::Utc::now(),\n            kind,\n            tags: Vec::new(),\n            content,\n            sig: String::new(),\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<Vec<String>>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn add_tag(&mut self, tag: Vec<String>) {\n        self.tags.push(tag);\n    }\n\n    pub fn add_p_tag(&mut self, pubkey: String) {\n        self.tags.push(vec![\"p\".to_string(), pubkey]);\n    }\n\n    pub fn add_e_tag(&mut self, event_id: String) {\n        self.tags.push(vec![\"e\".to_string(), event_id]);\n    }\n\n    pub fn add_t_tag(&mut self, hashtag: String) {\n        self.tags.push(vec![\"t\".to_string(), hashtag]);\n    }\n\n    pub fn get_referenced_event_ids(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"e\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_referenced_pubkeys(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"p\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn get_hashtags(&self) -> Vec<String> {\n        self.tags\n            .iter()\n            .filter(|tag| tag.len() >= 2 && tag[0] == \"t\")\n            .map(|tag| tag[1].clone())\n            .collect()\n    }\n\n    pub fn new_with_id(\n        id: EventId,\n        pubkey: String,\n        content: String,\n        kind: u32,\n        tags: Vec<Vec<String>>,\n        created_at: DateTime<Utc>,\n        sig: String,\n    ) -> Self {\n        Self {\n            id: id.to_hex(),\n            pubkey,\n            created_at,\n            kind,\n            tags,\n            content,\n            sig,\n        }\n    }\n\n    /// NIP-01に基づく基本バリデーション\n    /// - idは[0,pubkey,created_at,kind,tags,content]のsha256\n    /// - pubkeyは32byte hex（64桁）\n    /// - sigは64byte hex（128桁）\n    pub fn validate_nip01(&self) -> Result<(), String> {\n        // 1) 形式検証\n        let is_hex = |s: &str| s.chars().all(|c| c.is_ascii_hexdigit());\n        if self.pubkey.len() != 64 || !is_hex(&self.pubkey) {\n            return Err(\"invalid pubkey (expect 64 hex)\".into());\n        }\n        if self.sig.len() != 128 || !is_hex(&self.sig) {\n            return Err(\"invalid sig (expect 128 hex)\".into());\n        }\n        if self.id.len() != 64 || !is_hex(&self.id) {\n            return Err(\"invalid id (expect 64 hex)\".into());\n        }\n\n        // 2) ID再計算\n        // created_atは秒\n        let created_at_secs = self.created_at.timestamp();\n        // JSON array を構築\n        let arr = serde_json::json!([\n            0,\n            self.pubkey,\n            created_at_secs,\n            self.kind,\n            self.tags,\n            self.content,\n        ]);\n        let serialized =\n            serde_json::to_vec(&arr).map_err(|e| format!(\"serialization error: {e}\"))?;\n        let hash = Sha256::digest(&serialized);\n        let calc_id = format!(\"{hash:x}\");\n        if calc_id != self.id {\n            return Err(\"id mismatch (not NIP-01 compliant)\".into());\n        }\n        Ok(())\n    }\n\n    /// NIP-10/NIP-19 の基本バリデーション\n    /// - e タグ: イベント参照（64hex または note1... のbech32）。markerはroot/reply/mentionのみ。root/replyは多重不可。\n    /// - p タグ: 公開鍵参照（64hex または npub1... のbech32）\n    pub fn validate_nip10_19(&self) -> Result<(), String> {\n        let mut root_seen = 0usize;\n        let mut reply_seen = 0usize;\n\n        for tag in &self.tags {\n            if tag.is_empty() {\n                continue;\n            }\n            match tag[0].as_str() {\n                \"e\" => {\n                    if tag.len() < 2 {\n                        return Err(\"invalid e tag (len < 2)\".into());\n                    }\n                    let evref = &tag[1];\n                    if !(is_hex_n(evref, 64) || is_valid_event_ref(evref)) {\n                        return Err(\"invalid e tag id (not hex or bech32)\".into());\n                    }\n                    // 推奨リレーURLチェック（3番目要素）\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(\"invalid e tag relay_url (expect ws[s]://)\".into());\n                        }\n                    }\n                    // markerチェック（4番目要素）\n                    if tag.len() >= 4 {\n                        let marker = tag[3].as_str();\n                        match marker {\n                            \"root\" => root_seen += 1,\n                            \"reply\" => reply_seen += 1,\n                            \"mention\" => {}\n                            _ => return Err(format!(\"invalid e tag marker: {marker}\")),\n                        }\n                    }\n                }\n                \"p\" => {\n                    if tag.len() < 2 {\n                        return Err(\"invalid p tag (len < 2)\".into());\n                    }\n                    let pkref = &tag[1];\n                    if !(is_hex_n(pkref, 64) || is_valid_pubkey_ref(pkref)) {\n                        return Err(\"invalid p tag pubkey (not hex or bech32)\".into());\n                    }\n                    // 推奨リレーURLチェック（3番目要素）\n                    if tag.len() >= 3 {\n                        let relay_url = tag[2].as_str();\n                        if !relay_url.is_empty() && !is_ws_url(relay_url) {\n                            return Err(\"invalid p tag relay_url (expect ws[s]://)\".into());\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if root_seen > 1 {\n            return Err(\"multiple root markers in e tags\".into());\n        }\n        if reply_seen > 1 {\n            return Err(\"multiple reply markers in e tags\".into());\n        }\n        Ok(())\n    }\n}\n\nfn is_hex_n(s: &str, n: usize) -> bool {\n    s.len() == n && s.chars().all(|c| c.is_ascii_hexdigit())\n}\n\nfn is_valid_event_ref(s: &str) -> bool {\n    // 支持: note1... / nevent1...\n    if s.starts_with(\"note1\") {\n        return NostrEventId::from_bech32(s).is_ok();\n    }\n    if s.starts_with(\"nevent1\") {\n        return is_valid_nevent_tlv(s);\n    }\n    false\n}\n\nfn is_valid_pubkey_ref(s: &str) -> bool {\n    // 支持: npub1... / nprofile1...\n    if s.starts_with(\"npub1\") {\n        return NostrPublicKey::from_bech32(s).is_ok();\n    }\n    if s.starts_with(\"nprofile1\") {\n        return is_valid_nprofile_tlv(s);\n    }\n    false\n}\n\nfn is_ws_url(url: &str) -> bool {\n    let lower = url.to_ascii_lowercase();\n    (lower.starts_with(\"ws://\") || lower.starts_with(\"wss://\")) && lower.len() > 5\n}\n\nfn is_valid_nprofile_tlv(s: &str) -> bool {\n    if let Ok((hrp, data, _)) = bech32::decode(s) {\n        if hrp != \"nprofile\" {\n            return false;\n        }\n        if let Ok(bytes) = Vec::<u8>::from_base32(&data) {\n            let mut has_pubkey = false;\n            let mut relay_count = 0usize;\n            if parse_tlv(&bytes, |tag, value| match tag {\n                0 => {\n                    if has_pubkey || value.len() != 32 {\n                        return Err(());\n                    }\n                    has_pubkey = true;\n                    Ok(())\n                }\n                1 => {\n                    relay_count += 1;\n                    if relay_count > MAX_TLV_RELAY_URLS || !validate_tlv_relay(value) {\n                        return Err(());\n                    }\n                    Ok(())\n                }\n                _ => Ok(()),\n            })\n            .is_err()\n            {\n                return false;\n            }\n            return has_pubkey;\n        }\n    }\n    false\n}\n\nfn is_valid_nevent_tlv(s: &str) -> bool {\n    if let Ok((hrp, data, _)) = bech32::decode(s) {\n        if hrp != \"nevent\" {\n            return false;\n        }\n        if let Ok(bytes) = Vec::<u8>::from_base32(&data) {\n            let mut has_event_id = false;\n            let mut has_author = false;\n            let mut has_kind = false;\n            let mut relay_count = 0usize;\n            if parse_tlv(&bytes, |tag, value| match tag {\n                0 => {\n                    if has_event_id || value.len() != 32 {\n                        return Err(());\n                    }\n                    has_event_id = true;\n                    Ok(())\n                }\n                1 => {\n                    relay_count += 1;\n                    if relay_count > MAX_TLV_RELAY_URLS || !validate_tlv_relay(value) {\n                        return Err(());\n                    }\n                    Ok(())\n                }\n                2 => {\n                    if has_author || value.len() != 32 {\n                        return Err(());\n                    }\n                    has_author = true;\n                    Ok(())\n                }\n                3 => {\n                    if has_kind || value.len() != 4 {\n                        return Err(());\n                    }\n                    has_kind = true;\n                    Ok(())\n                }\n                _ => Ok(()),\n            })\n            .is_err()\n            {\n                return false;\n            }\n            return has_event_id;\n        }\n    }\n    false\n}\n\nimpl EventKind {\n    pub fn as_u32(&self) -> u32 {\n        u32::from(*self)\n    }\n\n    pub fn from_u32(value: u32) -> Option<Self> {\n        match value {\n            0 => Some(EventKind::Metadata),\n            1 => Some(EventKind::TextNote),\n            2 => Some(EventKind::RecommendRelay),\n            3 => Some(EventKind::Contacts),\n            4 => Some(EventKind::EncryptedDirectMessage),\n            5 => Some(EventKind::EventDeletion),\n            6 => Some(EventKind::Repost),\n            7 => Some(EventKind::Reaction),\n            8 => Some(EventKind::BadgeAward),\n            40 => Some(EventKind::ChannelCreation),\n            41 => Some(EventKind::ChannelMetadata),\n            42 => Some(EventKind::ChannelMessage),\n            43 => Some(EventKind::ChannelHideMessage),\n            44 => Some(EventKind::ChannelMuteUser),\n            _ => None,\n        }\n    }\n}\n\nconst MAX_TLV_RELAY_URLS: usize = 16;\nconst MAX_TLV_RELAY_URL_LEN: usize = 255;\n\nfn parse_tlv(bytes: &[u8], mut handler: impl FnMut(u8, &[u8]) -> Result<(), ()>) -> Result<(), ()> {\n    let mut i = 0usize;\n    while i + 2 <= bytes.len() {\n        let tag = bytes[i];\n        let len = bytes[i + 1] as usize;\n        i += 2;\n        if i + len > bytes.len() {\n            return Err(());\n        }\n        let value = &bytes[i..i + len];\n        handler(tag, value)?;\n        i += len;\n    }\n    if i == bytes.len() { Ok(()) } else { Err(()) }\n}\n\nfn validate_tlv_relay(value: &[u8]) -> bool {\n    if value.len() > MAX_TLV_RELAY_URL_LEN {\n        return false;\n    }\n    if value.is_empty() {\n        return true;\n    }\n    match std::str::from_utf8(value) {\n        Ok(url) => url.is_ascii() && is_ws_url(url),\n        Err(_) => false,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use nostr_sdk::prelude::*;\n\n    #[tokio::test]\n    async fn test_validate_nip01_ok() {\n        let keys = Keys::generate();\n        let nostr_ev = EventBuilder::text_note(\"hello nip01\")\n            .sign_with_keys(&keys)\n            .unwrap();\n\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_u64() as i64, 0)\n                .unwrap();\n\n        let dom = super::Event {\n            id: nostr_ev.id.to_string(),\n            pubkey: nostr_ev.pubkey.to_string(),\n            created_at,\n            kind: nostr_ev.kind.as_u16() as u32,\n            tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n            content: nostr_ev.content.clone(),\n            sig: nostr_ev.sig.to_string(),\n        };\n\n        assert!(dom.validate_nip01().is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_validate_nip01_bad_id() {\n        let keys = Keys::generate();\n        let nostr_ev = EventBuilder::text_note(\"oops\")\n            .sign_with_keys(&keys)\n            .unwrap();\n\n        let created_at =\n            chrono::DateTime::<chrono::Utc>::from_timestamp(nostr_ev.created_at.as_u64() as i64, 0)\n                .unwrap();\n\n        let mut dom = super::Event {\n            id: nostr_ev.id.to_string(),\n            pubkey: nostr_ev.pubkey.to_string(),\n            created_at,\n            kind: nostr_ev.kind.as_u16() as u32,\n            tags: nostr_ev.tags.iter().map(|t| t.clone().to_vec()).collect(),\n            content: nostr_ev.content.clone(),\n            sig: nostr_ev.sig.to_string(),\n        };\n        // 改ざん\n        dom.content = \"tampered\".into();\n        assert!(dom.validate_nip01().is_err());\n    }\n}\n\n#[cfg(test)]\nmod nip10_19_tests {\n    use bech32::{ToBase32 as _, Variant};\n    use nostr_sdk::prelude::*;\n\n    fn dummy_event_with_tags(tags: Vec<Vec<String>>) -> super::Event {\n        super::Event {\n            id: \"0\".repeat(64),\n            pubkey: \"f\".repeat(64),\n            created_at: chrono::Utc::now(),\n            kind: 1,\n            tags,\n            content: String::new(),\n            sig: \"f\".repeat(128),\n        }\n    }\n\n    #[test]\n    fn test_validate_nip10_19_ok_with_bech32_refs() {\n        let keys = Keys::generate();\n        let npub = keys.public_key().to_bech32().unwrap();\n\n        // 参照用のイベントID\n        let nostr_ev = EventBuilder::text_note(\"x\").sign_with_keys(&keys).unwrap();\n        let note = nostr_ev.id.to_bech32().unwrap();\n\n        let e_tag = vec![\"e\".into(), note, String::new(), \"reply\".into()];\n        let p_tag = vec![\"p\".into(), npub];\n        let ev = dummy_event_with_tags(vec![e_tag, p_tag]);\n        assert!(ev.validate_nip10_19().is_ok());\n    }\n\n    #[test]\n    fn test_validate_nip10_19_rejects_invalid_marker_and_pk() {\n        let e_tag = vec![\"e\".into(), \"0\".repeat(64), String::new(), \"bad\".into()];\n        let p_tag = vec![\"p\".into(), \"zzz\".into()];\n        let ev = dummy_event_with_tags(vec![e_tag, p_tag]);\n        assert!(ev.validate_nip10_19().is_err());\n    }\n\n    #[test]\n    fn test_nprofile_tlv_multiple_relays_ok() {\n        let keys = Keys::generate();\n        let mut bytes = Vec::new();\n        bytes.push(0);\n        bytes.push(32);\n        bytes.extend_from_slice(&keys.public_key().to_bytes());\n        for relay in [\"wss://relay.one\", \"wss://relay.two\"] {\n            let relay_bytes = relay.as_bytes();\n            bytes.push(1);\n            bytes.push(relay_bytes.len() as u8);\n            bytes.extend_from_slice(relay_bytes);\n        }\n        let encoded =\n            bech32::encode(\"nprofile\", bytes.to_base32(), Variant::Bech32).expect(\"encode\");\n        assert!(super::is_valid_nprofile_tlv(&encoded));\n    }\n\n    #[test]\n    fn test_nprofile_tlv_rejects_invalid_relay_scheme() {\n        let keys = Keys::generate();\n        let mut bytes = Vec::new();\n        bytes.push(0);\n        bytes.push(32);\n        bytes.extend_from_slice(&keys.public_key().to_bytes());\n        let relay_bytes = b\"https://relay.invalid\";\n        bytes.push(1);\n        bytes.push(relay_bytes.len() as u8);\n        bytes.extend_from_slice(relay_bytes);\n        let encoded =\n            bech32::encode(\"nprofile\", bytes.to_base32(), Variant::Bech32).expect(\"encode\");\n        assert!(!super::is_valid_nprofile_tlv(&encoded));\n    }\n\n    #[test]\n    fn test_nevent_tlv_with_optional_author_and_kind() {\n        let keys = Keys::generate();\n        let nostr_ev = EventBuilder::text_note(\"tlv\")\n            .sign_with_keys(&keys)\n            .expect(\"sign\");\n        let mut bytes = Vec::new();\n        bytes.push(0);\n        bytes.push(32);\n        bytes.extend_from_slice(&nostr_ev.id.to_bytes());\n        let relay_bytes = b\"wss://relay.example\";\n        bytes.push(1);\n        bytes.push(relay_bytes.len() as u8);\n        bytes.extend_from_slice(relay_bytes);\n        bytes.push(2);\n        bytes.push(32);\n        bytes.extend_from_slice(&nostr_ev.pubkey.to_bytes());\n        let kind_bytes = (nostr_ev.kind.as_u16() as u32).to_be_bytes();\n        bytes.push(3);\n        bytes.push(kind_bytes.len() as u8);\n        bytes.extend_from_slice(&kind_bytes);\n        let encoded = bech32::encode(\"nevent\", bytes.to_base32(), Variant::Bech32).unwrap();\n        assert!(super::is_valid_nevent_tlv(&encoded));\n    }\n\n    #[test]\n    fn test_nevent_tlv_rejects_invalid_author_length() {\n        let mut bytes = Vec::new();\n        bytes.push(0);\n        bytes.push(32);\n        bytes.extend_from_slice(&[0u8; 32]);\n        bytes.push(2);\n        bytes.push(31);\n        bytes.extend_from_slice(&[0u8; 31]);\n        let encoded = bech32::encode(\"nevent\", bytes.to_base32(), Variant::Bech32).unwrap();\n        assert!(!super::is_valid_nevent_tlv(&encoded));\n    }\n}\n","traces":[{"line":31,"address":[12867040],"length":1,"stats":{"Line":0}},{"line":32,"address":[18108824],"length":1,"stats":{"Line":0}},{"line":33,"address":[18108878],"length":1,"stats":{"Line":0}},{"line":34,"address":[11305195],"length":1,"stats":{"Line":0}},{"line":35,"address":[12867125],"length":1,"stats":{"Line":0}},{"line":36,"address":[18108911],"length":1,"stats":{"Line":0}},{"line":37,"address":[18108921],"length":1,"stats":{"Line":0}},{"line":38,"address":[17551795],"length":1,"stats":{"Line":0}},{"line":39,"address":[18323037],"length":1,"stats":{"Line":0}},{"line":40,"address":[11305255],"length":1,"stats":{"Line":0}},{"line":41,"address":[18108961],"length":1,"stats":{"Line":0}},{"line":42,"address":[18323067],"length":1,"stats":{"Line":0}},{"line":43,"address":[17551845],"length":1,"stats":{"Line":0}},{"line":44,"address":[18082255],"length":1,"stats":{"Line":0}},{"line":45,"address":[18082265],"length":1,"stats":{"Line":0}},{"line":46,"address":[17551875],"length":1,"stats":{"Line":0}},{"line":47,"address":[18108861],"length":1,"stats":{"Line":0}},{"line":53,"address":[12867264],"length":1,"stats":{"Line":1}},{"line":54,"address":[18323144],"length":1,"stats":{"Line":1}},{"line":55,"address":[17551944],"length":1,"stats":{"Line":0}},{"line":56,"address":[18323189],"length":1,"stats":{"Line":1}},{"line":57,"address":[18323202],"length":1,"stats":{"Line":0}},{"line":58,"address":[18109116],"length":1,"stats":{"Line":0}},{"line":59,"address":[18082390],"length":1,"stats":{"Line":0}},{"line":60,"address":[18109136],"length":1,"stats":{"Line":0}},{"line":61,"address":[11305450],"length":1,"stats":{"Line":0}},{"line":62,"address":[18109156],"length":1,"stats":{"Line":0}},{"line":63,"address":[18323262],"length":1,"stats":{"Line":0}},{"line":64,"address":[18082440],"length":1,"stats":{"Line":0}},{"line":65,"address":[11305490],"length":1,"stats":{"Line":0}},{"line":66,"address":[18323292],"length":1,"stats":{"Line":0}},{"line":67,"address":[11305510],"length":1,"stats":{"Line":0}},{"line":68,"address":[17552080],"length":1,"stats":{"Line":0}},{"line":69,"address":[11305530],"length":1,"stats":{"Line":0}},{"line":86,"address":[17552630,17552112,17552704],"length":1,"stats":{"Line":1}},{"line":88,"address":[18323381],"length":1,"stats":{"Line":1}},{"line":90,"address":[12867623],"length":1,"stats":{"Line":1}},{"line":92,"address":[17552320],"length":1,"stats":{"Line":1}},{"line":94,"address":[17552380],"length":1,"stats":{"Line":1}},{"line":98,"address":[18109872,18110029],"length":1,"stats":{"Line":0}},{"line":99,"address":[11306286,11306208],"length":1,"stats":{"Line":0}},{"line":100,"address":[11306309],"length":1,"stats":{"Line":0}},{"line":103,"address":[17552912],"length":1,"stats":{"Line":0}},{"line":104,"address":[18110053],"length":1,"stats":{"Line":0}},{"line":107,"address":[18083744,18083344,18083758],"length":1,"stats":{"Line":0}},{"line":108,"address":[18083364,18083448,18083753],"length":1,"stats":{"Line":0}},{"line":111,"address":[18084206,18084192,18083792],"length":1,"stats":{"Line":0}},{"line":112,"address":[18084201,18083896,18083812],"length":1,"stats":{"Line":0}},{"line":115,"address":[11307676,11307690,11307280],"length":1,"stats":{"Line":0}},{"line":116,"address":[17553944,17553860,17554249],"length":1,"stats":{"Line":0}},{"line":119,"address":[18084688],"length":1,"stats":{"Line":0}},{"line":120,"address":[18111456],"length":1,"stats":{"Line":0}},{"line":122,"address":[18325632,18325651],"length":1,"stats":{"Line":0}},{"line":123,"address":[11307987,11307952],"length":1,"stats":{"Line":0}},{"line":127,"address":[17554592],"length":1,"stats":{"Line":0}},{"line":128,"address":[18325856],"length":1,"stats":{"Line":0}},{"line":130,"address":[17554704,17554723],"length":1,"stats":{"Line":0}},{"line":131,"address":[11308291,11308256],"length":1,"stats":{"Line":0}},{"line":135,"address":[11308336],"length":1,"stats":{"Line":0}},{"line":136,"address":[17554928],"length":1,"stats":{"Line":0}},{"line":138,"address":[17555027,17555008],"length":1,"stats":{"Line":0}},{"line":139,"address":[18326352,18326387],"length":1,"stats":{"Line":0}},{"line":143,"address":[18086097,18085600,18086169],"length":1,"stats":{"Line":1}},{"line":153,"address":[17555275],"length":1,"stats":{"Line":1}},{"line":167,"address":[18088303,18086192,18088314],"length":1,"stats":{"Line":1}},{"line":169,"address":[18115165,18115072,18115152,18115115],"length":1,"stats":{"Line":4}},{"line":170,"address":[18327062],"length":1,"stats":{"Line":1}},{"line":171,"address":[12871236],"length":1,"stats":{"Line":0}},{"line":173,"address":[18327179],"length":1,"stats":{"Line":1}},{"line":174,"address":[12871355],"length":1,"stats":{"Line":0}},{"line":176,"address":[18113202],"length":1,"stats":{"Line":1}},{"line":177,"address":[11309528],"length":1,"stats":{"Line":0}},{"line":182,"address":[17556175],"length":1,"stats":{"Line":1}},{"line":184,"address":[18328397,18329159,18327435],"length":1,"stats":{"Line":1}},{"line":192,"address":[18328370,18329301,18328457,18328618,18329144,18329280],"length":1,"stats":{"Line":3}},{"line":194,"address":[18114490],"length":1,"stats":{"Line":1}},{"line":195,"address":[18087891],"length":1,"stats":{"Line":1}},{"line":196,"address":[12873054,12872983],"length":1,"stats":{"Line":2}},{"line":197,"address":[18088137,18088226],"length":1,"stats":{"Line":2}},{"line":199,"address":[12873075],"length":1,"stats":{"Line":1}},{"line":205,"address":[18115392],"length":1,"stats":{"Line":2}},{"line":206,"address":[18115430],"length":1,"stats":{"Line":3}},{"line":207,"address":[18088703],"length":1,"stats":{"Line":3}},{"line":209,"address":[18088799,18088712],"length":1,"stats":{"Line":6}},{"line":210,"address":[18329652],"length":1,"stats":{"Line":3}},{"line":213,"address":[11312023],"length":1,"stats":{"Line":3}},{"line":214,"address":[18329904],"length":1,"stats":{"Line":3}},{"line":215,"address":[17558734],"length":1,"stats":{"Line":3}},{"line":216,"address":[12874646],"length":1,"stats":{"Line":0}},{"line":218,"address":[18089625],"length":1,"stats":{"Line":3}},{"line":219,"address":[11312651,11312761],"length":1,"stats":{"Line":5}},{"line":220,"address":[17559410],"length":1,"stats":{"Line":1}},{"line":223,"address":[12874756],"length":1,"stats":{"Line":2}},{"line":224,"address":[11312911],"length":1,"stats":{"Line":2}},{"line":225,"address":[17559577],"length":1,"stats":{"Line":3}},{"line":226,"address":[18090005],"length":1,"stats":{"Line":1}},{"line":230,"address":[11312885],"length":1,"stats":{"Line":3}},{"line":231,"address":[11313080],"length":1,"stats":{"Line":3}},{"line":233,"address":[17560110,17559730,17559806],"length":1,"stats":{"Line":4}},{"line":234,"address":[12875237,12875127,12875439],"length":1,"stats":{"Line":6}},{"line":235,"address":[18090234],"length":1,"stats":{"Line":2}},{"line":236,"address":[12875264],"length":1,"stats":{"Line":2}},{"line":240,"address":[18329935],"length":1,"stats":{"Line":2}},{"line":241,"address":[18089160],"length":1,"stats":{"Line":2}},{"line":242,"address":[18089238],"length":1,"stats":{"Line":0}},{"line":244,"address":[17558777],"length":1,"stats":{"Line":2}},{"line":245,"address":[11312203,11312313],"length":1,"stats":{"Line":4}},{"line":246,"address":[17558965],"length":1,"stats":{"Line":1}},{"line":249,"address":[18330180],"length":1,"stats":{"Line":2}},{"line":250,"address":[18089448],"length":1,"stats":{"Line":1}},{"line":251,"address":[12874466],"length":1,"stats":{"Line":1}},{"line":252,"address":[11312534],"length":1,"stats":{"Line":1}},{"line":260,"address":[17558389],"length":1,"stats":{"Line":2}},{"line":261,"address":[17558445],"length":1,"stats":{"Line":0}},{"line":263,"address":[12873795],"length":1,"stats":{"Line":2}},{"line":264,"address":[18329772],"length":1,"stats":{"Line":1}},{"line":266,"address":[18088925],"length":1,"stats":{"Line":2}},{"line":270,"address":[17560144],"length":1,"stats":{"Line":3}},{"line":271,"address":[12875616,12875629,12875537],"length":1,"stats":{"Line":7}},{"line":274,"address":[18331743,18331520],"length":1,"stats":{"Line":2}},{"line":276,"address":[17560312],"length":1,"stats":{"Line":2}},{"line":277,"address":[18117592,18117514],"length":1,"stats":{"Line":2}},{"line":279,"address":[18090744],"length":1,"stats":{"Line":1}},{"line":280,"address":[18331666],"length":1,"stats":{"Line":1}},{"line":282,"address":[17560417],"length":1,"stats":{"Line":0}},{"line":285,"address":[18090944,18091167],"length":1,"stats":{"Line":2}},{"line":287,"address":[18117704],"length":1,"stats":{"Line":2}},{"line":288,"address":[12876072,12875994],"length":1,"stats":{"Line":2}},{"line":290,"address":[11313976],"length":1,"stats":{"Line":1}},{"line":291,"address":[17560690],"length":1,"stats":{"Line":1}},{"line":293,"address":[18117809],"length":1,"stats":{"Line":0}},{"line":296,"address":[17560800,17561081],"length":1,"stats":{"Line":2}},{"line":297,"address":[17560833],"length":1,"stats":{"Line":2}},{"line":298,"address":[18091308,18091243,18091466],"length":1,"stats":{"Line":6}},{"line":301,"address":[18332336,18333050,18332941],"length":1,"stats":{"Line":2}},{"line":302,"address":[18118269],"length":1,"stats":{"Line":2}},{"line":303,"address":[17561225,17561312],"length":1,"stats":{"Line":4}},{"line":304,"address":[18332579],"length":1,"stats":{"Line":0}},{"line":306,"address":[11314726,11314677],"length":1,"stats":{"Line":4}},{"line":307,"address":[18332685],"length":1,"stats":{"Line":2}},{"line":308,"address":[12876821],"length":1,"stats":{"Line":2}},{"line":309,"address":[12876833,12876954,12877245,12877200],"length":1,"stats":{"Line":8}},{"line":311,"address":[17561913,17561957],"length":1,"stats":{"Line":4}},{"line":312,"address":[12877323],"length":1,"stats":{"Line":0}},{"line":314,"address":[17561975],"length":1,"stats":{"Line":2}},{"line":315,"address":[18119117],"length":1,"stats":{"Line":2}},{"line":318,"address":[17562025,17561928,17562006],"length":1,"stats":{"Line":4}},{"line":319,"address":[18119187,18119149],"length":1,"stats":{"Line":4}},{"line":320,"address":[12877420],"length":1,"stats":{"Line":2}},{"line":322,"address":[18333299],"length":1,"stats":{"Line":2}},{"line":324,"address":[18333133],"length":1,"stats":{"Line":0}},{"line":328,"address":[11315021],"length":1,"stats":{"Line":2}},{"line":330,"address":[11315006],"length":1,"stats":{"Line":2}},{"line":333,"address":[18333018],"length":1,"stats":{"Line":0}},{"line":336,"address":[11316221,11315440,11316112],"length":1,"stats":{"Line":2}},{"line":337,"address":[12877469],"length":1,"stats":{"Line":2}},{"line":338,"address":[18333433,18333520],"length":1,"stats":{"Line":5}},{"line":339,"address":[18119459],"length":1,"stats":{"Line":0}},{"line":341,"address":[18119430,18119479],"length":1,"stats":{"Line":4}},{"line":342,"address":[11315788],"length":1,"stats":{"Line":2}},{"line":343,"address":[18092837],"length":1,"stats":{"Line":2}},{"line":344,"address":[17562445],"length":1,"stats":{"Line":2}},{"line":345,"address":[11315812],"length":1,"stats":{"Line":2}},{"line":346,"address":[18120057,18119601,18119714,18120016],"length":1,"stats":{"Line":10}},{"line":348,"address":[18334289,18334198],"length":1,"stats":{"Line":6}},{"line":349,"address":[18120199],"length":1,"stats":{"Line":0}},{"line":351,"address":[17563075],"length":1,"stats":{"Line":3}},{"line":352,"address":[17563081],"length":1,"stats":{"Line":3}},{"line":355,"address":[17563107,17562981,17563126],"length":1,"stats":{"Line":4}},{"line":356,"address":[12878512,12878474],"length":1,"stats":{"Line":4}},{"line":357,"address":[17563161],"length":1,"stats":{"Line":0}},{"line":359,"address":[18120304],"length":1,"stats":{"Line":2}},{"line":362,"address":[18334243,18334412],"length":1,"stats":{"Line":4}},{"line":363,"address":[18093586],"length":1,"stats":{"Line":1}},{"line":365,"address":[18334430],"length":1,"stats":{"Line":2}},{"line":366,"address":[17563205],"length":1,"stats":{"Line":2}},{"line":369,"address":[17563034,17563217],"length":1,"stats":{"Line":4}},{"line":370,"address":[11316583],"length":1,"stats":{"Line":0}},{"line":372,"address":[12878598],"length":1,"stats":{"Line":2}},{"line":373,"address":[18334477],"length":1,"stats":{"Line":2}},{"line":375,"address":[11316314],"length":1,"stats":{"Line":0}},{"line":379,"address":[12878074],"length":1,"stats":{"Line":1}},{"line":381,"address":[11316054],"length":1,"stats":{"Line":2}},{"line":384,"address":[18334066],"length":1,"stats":{"Line":1}},{"line":388,"address":[18120400],"length":1,"stats":{"Line":0}},{"line":389,"address":[11316632],"length":1,"stats":{"Line":0}},{"line":392,"address":[18120432],"length":1,"stats":{"Line":0}},{"line":393,"address":[12878661],"length":1,"stats":{"Line":0}},{"line":394,"address":[18120483],"length":1,"stats":{"Line":0}},{"line":395,"address":[18120512],"length":1,"stats":{"Line":0}},{"line":396,"address":[18120541],"length":1,"stats":{"Line":0}},{"line":397,"address":[18120570],"length":1,"stats":{"Line":0}},{"line":398,"address":[17563463],"length":1,"stats":{"Line":0}},{"line":399,"address":[12878852],"length":1,"stats":{"Line":0}},{"line":400,"address":[12878881],"length":1,"stats":{"Line":0}},{"line":401,"address":[18334782],"length":1,"stats":{"Line":0}},{"line":402,"address":[12878939],"length":1,"stats":{"Line":0}},{"line":403,"address":[11316965],"length":1,"stats":{"Line":0}},{"line":404,"address":[17563631],"length":1,"stats":{"Line":0}},{"line":405,"address":[12879017],"length":1,"stats":{"Line":0}},{"line":406,"address":[18334915],"length":1,"stats":{"Line":0}},{"line":407,"address":[11317069],"length":1,"stats":{"Line":0}},{"line":408,"address":[11316694],"length":1,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":4}},{"line":417,"address":[18095121,18094188],"length":1,"stats":{"Line":4}},{"line":418,"address":[11317160,11318893,11318093,11317984],"length":1,"stats":{"Line":9}},{"line":419,"address":[12880324,12880209,12879403,12880276,12879352,12879285],"length":1,"stats":{"Line":8}},{"line":420,"address":[12879366,12879529,12880355,12880290,12880444,12879437],"length":1,"stats":{"Line":8}},{"line":421,"address":[11317492,11318410,11318503,11317588,11317560,11318475],"length":1,"stats":{"Line":8}},{"line":422,"address":[12880534,12880483,12879568,12879622],"length":1,"stats":{"Line":10}},{"line":423,"address":[12879688,12880600],"length":1,"stats":{"Line":0}},{"line":425,"address":[17564364,17564295,17565207,17565273],"length":1,"stats":{"Line":10}},{"line":426,"address":[18122634,18122488,18122699,18121725,18121790,18121587],"length":1,"stats":{"Line":11}},{"line":427,"address":[],"length":0,"stats":{"Line":10}},{"line":429,"address":[18121041,18122005,18121081,18121968],"length":1,"stats":{"Line":4}},{"line":432,"address":[18122720],"length":1,"stats":{"Line":2}},{"line":433,"address":[18336840],"length":1,"stats":{"Line":2}},{"line":434,"address":[12880999],"length":1,"stats":{"Line":0}},{"line":436,"address":[18096027],"length":1,"stats":{"Line":2}},{"line":437,"address":[18096077],"length":1,"stats":{"Line":0}},{"line":439,"address":[18122792],"length":1,"stats":{"Line":2}},{"line":440,"address":[11319044,11319092],"length":1,"stats":{"Line":2}},{"line":441,"address":[11319085],"length":1,"stats":{"Line":1}}],"covered":130,"coverable":223},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","domain_event.rs"],"content":"use crate::domain::entities::{Event, EventKind};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Nostr イベントのタグを表現するドメイン型。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct EventTag {\n    name: String,\n    values: Vec<String>,\n}\n\nimpl EventTag {\n    /// 新しいタグを生成する。タグ名は1文字以上である必要がある。\n    pub fn new<N: Into<String>>(name: N, values: Vec<String>) -> Result<Self, String> {\n        let name = name.into();\n        if name.trim().is_empty() {\n            return Err(\"Tag name cannot be empty\".to_string());\n        }\n        Ok(Self { name, values })\n    }\n\n    pub fn name(&self) -> &str {\n        &self.name\n    }\n\n    pub fn values(&self) -> &[String] {\n        &self.values\n    }\n\n    pub fn to_raw(&self) -> Vec<String> {\n        std::iter::once(self.name.clone())\n            .chain(self.values.iter().cloned())\n            .collect()\n    }\n\n    pub fn into_raw(self) -> Vec<String> {\n        std::iter::once(self.name).chain(self.values).collect()\n    }\n}\n\nimpl TryFrom<Vec<String>> for EventTag {\n    type Error = String;\n\n    fn try_from(value: Vec<String>) -> Result<Self, Self::Error> {\n        let mut iter = value.into_iter();\n        let name = iter\n            .next()\n            .ok_or_else(|| \"Tag vector must contain at least one element\".to_string())?;\n        let values: Vec<String> = iter.collect();\n        Self::new(name, values)\n    }\n}\n\nimpl From<EventTag> for Vec<String> {\n    fn from(tag: EventTag) -> Self {\n        tag.into_raw()\n    }\n}\n\n/// Application 層が扱う Nostr ドメインイベント。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct DomainEvent {\n    pub id: EventId,\n    pub author: PublicKey,\n    pub kind: EventKind,\n    pub created_at: DateTime<Utc>,\n    pub content: String,\n    pub tags: Vec<EventTag>,\n    pub signature: String,\n}\n\nimpl DomainEvent {\n    const SIGNATURE_LENGTH: usize = 128;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: EventId,\n        author: PublicKey,\n        kind: EventKind,\n        created_at: DateTime<Utc>,\n        content: String,\n        tags: Vec<EventTag>,\n        signature: String,\n    ) -> Result<Self, String> {\n        Self::validate_signature(&signature)?;\n        Ok(Self {\n            id,\n            author,\n            kind,\n            created_at,\n            content,\n            tags,\n            signature,\n        })\n    }\n\n    pub fn with_tags(mut self, tags: Vec<EventTag>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn signature(&self) -> &str {\n        &self.signature\n    }\n\n    pub fn kind(&self) -> EventKind {\n        self.kind\n    }\n\n    pub fn to_event(&self) -> Event {\n        Event {\n            id: self.id.to_hex(),\n            pubkey: self.author.as_hex().to_string(),\n            created_at: self.created_at,\n            kind: u32::from(self.kind),\n            tags: self.tags.iter().map(EventTag::to_raw).collect(),\n            content: self.content.clone(),\n            sig: self.signature.clone(),\n        }\n    }\n\n    fn validate_signature(signature: &str) -> Result<(), String> {\n        if signature.len() != Self::SIGNATURE_LENGTH {\n            return Err(\"Signature must be 128 hex characters\".to_string());\n        }\n        if !signature.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Signature must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl TryFrom<Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .into_iter()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content,\n            tags,\n            value.sig,\n        )\n    }\n}\n\nimpl TryFrom<&Event> for DomainEvent {\n    type Error = String;\n\n    fn try_from(value: &Event) -> Result<Self, Self::Error> {\n        let id = EventId::from_hex(&value.id)?;\n        let author = PublicKey::from_hex_str(&value.pubkey)?;\n        let kind = EventKind::from(value.kind);\n        let tags = value\n            .tags\n            .iter()\n            .cloned()\n            .map(EventTag::try_from)\n            .collect::<Result<Vec<_>, _>>()?;\n        Self::new(\n            id,\n            author,\n            kind,\n            value.created_at,\n            value.content.clone(),\n            tags,\n            value.sig.clone(),\n        )\n    }\n}\n\nimpl From<&DomainEvent> for Event {\n    fn from(value: &DomainEvent) -> Self {\n        value.to_event()\n    }\n}\n","traces":[{"line":15,"address":[16319692,16319184],"length":1,"stats":{"Line":1}},{"line":16,"address":[16319206],"length":1,"stats":{"Line":1}},{"line":17,"address":[16319340,16319275],"length":1,"stats":{"Line":2}},{"line":18,"address":[12948770,12948816],"length":1,"stats":{"Line":0}},{"line":20,"address":[12948586],"length":1,"stats":{"Line":1}},{"line":23,"address":[16319728],"length":1,"stats":{"Line":0}},{"line":24,"address":[12975653],"length":1,"stats":{"Line":0}},{"line":27,"address":[12975664],"length":1,"stats":{"Line":0}},{"line":28,"address":[19817045],"length":1,"stats":{"Line":0}},{"line":31,"address":[16320099,16320070,16319776],"length":1,"stats":{"Line":1}},{"line":32,"address":[19817292,19817330,19817102],"length":1,"stats":{"Line":3}},{"line":33,"address":[12976003,12975788,12975958],"length":1,"stats":{"Line":2}},{"line":37,"address":[12949546,12949296,12949513],"length":1,"stats":{"Line":0}},{"line":38,"address":[13190250,13190150],"length":1,"stats":{"Line":0}},{"line":45,"address":[19818138,19818176,19817648],"length":1,"stats":{"Line":0}},{"line":46,"address":[13190417],"length":1,"stats":{"Line":0}},{"line":47,"address":[13190465,13190525,13190730],"length":1,"stats":{"Line":0}},{"line":49,"address":[12976896,12976908,12976608],"length":1,"stats":{"Line":0}},{"line":50,"address":[16320622],"length":1,"stats":{"Line":0}},{"line":51,"address":[12976705],"length":1,"stats":{"Line":0}},{"line":56,"address":[11591488],"length":1,"stats":{"Line":0}},{"line":57,"address":[12148632],"length":1,"stats":{"Line":0}},{"line":77,"address":[19818256,19819280],"length":1,"stats":{"Line":1}},{"line":86,"address":[12977695,12977040,12977113],"length":1,"stats":{"Line":2}},{"line":87,"address":[19818707],"length":1,"stats":{"Line":1}},{"line":88,"address":[12420084],"length":1,"stats":{"Line":1}},{"line":89,"address":[12420119],"length":1,"stats":{"Line":1}},{"line":92,"address":[13191386],"length":1,"stats":{"Line":1}},{"line":93,"address":[13191421],"length":1,"stats":{"Line":1}},{"line":94,"address":[13191456],"length":1,"stats":{"Line":1}},{"line":98,"address":[12951437,12951280],"length":1,"stats":{"Line":0}},{"line":99,"address":[16322128,16322210],"length":1,"stats":{"Line":0}},{"line":100,"address":[13192249],"length":1,"stats":{"Line":0}},{"line":103,"address":[12978192],"length":1,"stats":{"Line":0}},{"line":104,"address":[12421061],"length":1,"stats":{"Line":0}},{"line":107,"address":[13192304],"length":1,"stats":{"Line":0}},{"line":108,"address":[13192309],"length":1,"stats":{"Line":0}},{"line":111,"address":[13192320,13193047],"length":1,"stats":{"Line":1}},{"line":113,"address":[13192350],"length":1,"stats":{"Line":1}},{"line":114,"address":[13192369,13192445],"length":1,"stats":{"Line":2}},{"line":115,"address":[13192469],"length":1,"stats":{"Line":1}},{"line":116,"address":[16322481],"length":1,"stats":{"Line":1}},{"line":117,"address":[12978471],"length":1,"stats":{"Line":1}},{"line":118,"address":[12978592],"length":1,"stats":{"Line":1}},{"line":119,"address":[12978664],"length":1,"stats":{"Line":1}},{"line":123,"address":[12952240],"length":1,"stats":{"Line":1}},{"line":124,"address":[12952290],"length":1,"stats":{"Line":1}},{"line":125,"address":[19820360],"length":1,"stats":{"Line":0}},{"line":127,"address":[16323325,16323312,16323129],"length":1,"stats":{"Line":3}},{"line":128,"address":[16323217],"length":1,"stats":{"Line":0}},{"line":130,"address":[13193294],"length":1,"stats":{"Line":1}},{"line":137,"address":[12423608,12422128],"length":1,"stats":{"Line":0}},{"line":138,"address":[12954170,12952852,12952698,12952558],"length":1,"stats":{"Line":0}},{"line":139,"address":[12952826,12954125,12952964,12953128],"length":1,"stats":{"Line":0}},{"line":140,"address":[12953098,12953243],"length":1,"stats":{"Line":0}},{"line":141,"address":[19821800,19821257],"length":1,"stats":{"Line":0}},{"line":147,"address":[16324331],"length":1,"stats":{"Line":0}},{"line":148,"address":[19821525],"length":1,"stats":{"Line":0}},{"line":150,"address":[16324405],"length":1,"stats":{"Line":0}},{"line":151,"address":[12953614],"length":1,"stats":{"Line":0}},{"line":152,"address":[12953646],"length":1,"stats":{"Line":0}},{"line":153,"address":[19821662],"length":1,"stats":{"Line":0}},{"line":161,"address":[12956143,12954576,12956349],"length":1,"stats":{"Line":0}},{"line":162,"address":[13195452,13195669],"length":1,"stats":{"Line":0}},{"line":163,"address":[19823066,19824210,19822758,19822919],"length":1,"stats":{"Line":0}},{"line":164,"address":[19823037,19823177],"length":1,"stats":{"Line":0}},{"line":165,"address":[13196102,13196552],"length":1,"stats":{"Line":0}},{"line":172,"address":[13196368],"length":1,"stats":{"Line":0}},{"line":173,"address":[16326400],"length":1,"stats":{"Line":0}},{"line":175,"address":[12955632],"length":1,"stats":{"Line":0}},{"line":176,"address":[12425395,12425257],"length":1,"stats":{"Line":0}},{"line":177,"address":[12955803],"length":1,"stats":{"Line":0}},{"line":178,"address":[19823756],"length":1,"stats":{"Line":0}},{"line":184,"address":[11319136],"length":1,"stats":{"Line":0}},{"line":185,"address":[11319153],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":75},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","mod.rs"],"content":"pub mod domain_event;\npub mod profile_metadata;\n\npub use domain_event::{DomainEvent, EventTag};\npub use profile_metadata::ProfileMetadata;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","event_gateway","profile_metadata.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// プロフィール更新時に利用するメタデータ。\n#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]\npub struct ProfileMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub website: Option<String>,\n}\n\nimpl ProfileMetadata {\n    const NAME_LIMIT: usize = 100;\n    const DISPLAY_NAME_LIMIT: usize = 100;\n    const ABOUT_LIMIT: usize = 1_000;\n    const URL_LIMIT: usize = 1_024;\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n        picture: Option<String>,\n        banner: Option<String>,\n        nip05: Option<String>,\n        lud16: Option<String>,\n        website: Option<String>,\n    ) -> Result<Self, String> {\n        let metadata = Self {\n            name,\n            display_name,\n            about,\n            picture,\n            banner,\n            nip05,\n            lud16,\n            website,\n        };\n        metadata.validate()?;\n        Ok(metadata)\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if let Some(name) = self.name.as_ref() {\n            if name.chars().count() > Self::NAME_LIMIT {\n                return Err(format!(\n                    \"Name is too long (max {} characters)\",\n                    Self::NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(display_name) = self.display_name.as_ref() {\n            if display_name.chars().count() > Self::DISPLAY_NAME_LIMIT {\n                return Err(format!(\n                    \"Display name is too long (max {} characters)\",\n                    Self::DISPLAY_NAME_LIMIT\n                ));\n            }\n        }\n\n        if let Some(about) = self.about.as_ref() {\n            if about.chars().count() > Self::ABOUT_LIMIT {\n                return Err(format!(\n                    \"About is too long (max {} characters)\",\n                    Self::ABOUT_LIMIT\n                ));\n            }\n        }\n\n        if let Some(picture) = self.picture.as_ref() {\n            Self::validate_url_length(picture, \"Picture\")?;\n        }\n\n        if let Some(banner) = self.banner.as_ref() {\n            Self::validate_url_length(banner, \"Banner\")?;\n        }\n\n        if let Some(website) = self.website.as_ref() {\n            Self::validate_url_length(website, \"Website\")?;\n        }\n\n        Ok(())\n    }\n\n    fn validate_url_length(value: &str, field: &str) -> Result<(), String> {\n        if value.chars().count() > Self::URL_LIMIT {\n            return Err(format!(\n                \"{} URL is too long (max {} characters)\",\n                field,\n                Self::URL_LIMIT\n            ));\n        }\n        Ok(())\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.name.is_none()\n            && self.display_name.is_none()\n            && self.about.is_none()\n            && self.picture.is_none()\n            && self.banner.is_none()\n            && self.nip05.is_none()\n            && self.lud16.is_none()\n            && self.website.is_none()\n    }\n}\n","traces":[{"line":23,"address":[11111376,11111868],"length":1,"stats":{"Line":0}},{"line":43,"address":[11882836,11882901,11883016],"length":1,"stats":{"Line":0}},{"line":44,"address":[15012947],"length":1,"stats":{"Line":0}},{"line":47,"address":[11642304],"length":1,"stats":{"Line":0}},{"line":48,"address":[15013158],"length":1,"stats":{"Line":0}},{"line":49,"address":[16600824],"length":1,"stats":{"Line":0}},{"line":50,"address":[11883318],"length":1,"stats":{"Line":0}},{"line":57,"address":[16600862,16601072],"length":1,"stats":{"Line":0}},{"line":58,"address":[15013472],"length":1,"stats":{"Line":0}},{"line":59,"address":[11112350],"length":1,"stats":{"Line":0}},{"line":66,"address":[15013510,15013736],"length":1,"stats":{"Line":0}},{"line":67,"address":[11669672],"length":1,"stats":{"Line":0}},{"line":68,"address":[15013848],"length":1,"stats":{"Line":0}},{"line":75,"address":[11112802,11112576],"length":1,"stats":{"Line":0}},{"line":76,"address":[11884050,11884203],"length":1,"stats":{"Line":0}},{"line":79,"address":[16601746,16601876],"length":1,"stats":{"Line":0}},{"line":80,"address":[16601892,16602048],"length":1,"stats":{"Line":0}},{"line":83,"address":[11670293,11670427],"length":1,"stats":{"Line":0}},{"line":84,"address":[11670562,11670443],"length":1,"stats":{"Line":0}},{"line":87,"address":[16602233],"length":1,"stats":{"Line":0}},{"line":90,"address":[11643904],"length":1,"stats":{"Line":0}},{"line":91,"address":[11884805],"length":1,"stats":{"Line":0}},{"line":92,"address":[11670756],"length":1,"stats":{"Line":0}},{"line":98,"address":[11884834],"length":1,"stats":{"Line":0}},{"line":101,"address":[15015056],"length":1,"stats":{"Line":0}},{"line":102,"address":[16602685],"length":1,"stats":{"Line":0}},{"line":103,"address":[16602709],"length":1,"stats":{"Line":0}},{"line":104,"address":[11644297],"length":1,"stats":{"Line":0}},{"line":105,"address":[11644317],"length":1,"stats":{"Line":0}},{"line":106,"address":[11671073],"length":1,"stats":{"Line":0}},{"line":107,"address":[11885189],"length":1,"stats":{"Line":0}},{"line":108,"address":[16602809],"length":1,"stats":{"Line":0}},{"line":109,"address":[16602835],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","mod.rs"],"content":"pub mod account;\npub mod bookmark;\npub mod event;\npub mod event_gateway;\npub mod offline;\npub mod post;\npub mod topic;\npub mod user;\n\npub use account::{AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret};\npub use bookmark::Bookmark;\npub use event::{Event, EventKind};\npub use event_gateway::{DomainEvent, EventTag, ProfileMetadata};\npub use offline::{\n    CacheMetadataRecord, CacheStatusSnapshot, CacheTypeStatus, OfflineActionDraft,\n    OfflineActionFilter, OfflineActionRecord, OptimisticUpdateDraft, OptimisticUpdateRecord,\n    SavedOfflineAction, SyncQueueItem, SyncQueueItemDraft, SyncResult, SyncStatusRecord,\n    SyncStatusUpdate,\n};\npub use post::Post;\npub use topic::Topic;\npub use user::{User, UserMetadata, UserProfile};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_metadata.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataRecord {\n    pub record_id: i64,\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub last_accessed_at: Option<DateTime<Utc>>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<DateTime<Utc>>,\n    pub metadata: Option<Value>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","cache_status.rs"],"content":"use crate::domain::value_objects::{CacheKey, CacheType};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheTypeStatus {\n    pub cache_type: CacheType,\n    pub item_count: u64,\n    pub last_synced_at: Option<DateTime<Utc>>,\n    pub is_stale: bool,\n}\n\nimpl CacheTypeStatus {\n    pub fn new(\n        cache_type: CacheType,\n        item_count: u64,\n        last_synced_at: Option<DateTime<Utc>>,\n        is_stale: bool,\n    ) -> Self {\n        Self {\n            cache_type,\n            item_count,\n            last_synced_at,\n            is_stale,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheStatusSnapshot {\n    pub total_items: u64,\n    pub stale_items: u64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\nimpl CacheStatusSnapshot {\n    pub fn new(total_items: u64, stale_items: u64, cache_types: Vec<CacheTypeStatus>) -> Self {\n        Self {\n            total_items,\n            stale_items,\n            cache_types,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct CacheMetadataUpdate {\n    pub cache_key: CacheKey,\n    pub cache_type: CacheType,\n    pub metadata: Option<Value>,\n    pub expiry: Option<DateTime<Utc>>,\n}\n","traces":[{"line":15,"address":[18581904],"length":1,"stats":{"Line":1}},{"line":38,"address":[18582016],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","commands.rs"],"content":"use crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    EntityId, EntityType, OfflineActionType, OfflinePayload, SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// オフラインアクションを保存する際に使用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionDraft {\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n}\n\nimpl OfflineActionDraft {\n    pub fn new(\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        }\n    }\n}\n\n/// オフラインアクション取得時のフィルタ。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct OfflineActionFilter {\n    pub user_pubkey: Option<PublicKey>,\n    pub include_synced: Option<bool>,\n    pub limit: Option<u32>,\n}\n\nimpl OfflineActionFilter {\n    pub fn new(\n        user_pubkey: Option<PublicKey>,\n        include_synced: Option<bool>,\n        limit: Option<u32>,\n    ) -> Self {\n        Self {\n            user_pubkey,\n            include_synced,\n            limit,\n        }\n    }\n}\n\n/// 同期キューに追加する際のドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItemDraft {\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub priority: Option<u8>,\n}\n\nimpl SyncQueueItemDraft {\n    pub fn new(\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        priority: Option<u8>,\n    ) -> Self {\n        Self {\n            action_type,\n            payload,\n            priority,\n        }\n    }\n}\n\n/// 楽観的更新の保存に利用するドラフト。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateDraft {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n}\n\nimpl OptimisticUpdateDraft {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        original_data: Option<OfflinePayload>,\n        updated_data: OfflinePayload,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            original_data,\n            updated_data,\n        }\n    }\n}\n\n/// 同期状態の更新に使用するコマンド。\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusUpdate {\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl SyncStatusUpdate {\n    pub fn new(\n        entity_type: EntityType,\n        entity_id: EntityId,\n        sync_status: SyncStatus,\n        conflict_data: Option<OfflinePayload>,\n        updated_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            entity_type,\n            entity_id,\n            sync_status,\n            conflict_data,\n            updated_at,\n        }\n    }\n}\n","traces":[{"line":18,"address":[17535840],"length":1,"stats":{"Line":4}},{"line":42,"address":[17698224],"length":1,"stats":{"Line":2}},{"line":64,"address":[17536016],"length":1,"stats":{"Line":3}},{"line":87,"address":[17698400],"length":1,"stats":{"Line":1}},{"line":113,"address":[17698512],"length":1,"stats":{"Line":2}}],"covered":5,"coverable":5},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","mod.rs"],"content":"pub mod cache_metadata;\npub mod cache_status;\npub mod commands;\npub mod offline_action;\npub mod optimistic_update;\npub mod saved_action;\npub mod sync_queue_item;\npub mod sync_result;\npub mod sync_status_record;\n\npub use cache_metadata::CacheMetadataRecord;\npub use cache_status::{CacheMetadataUpdate, CacheStatusSnapshot, CacheTypeStatus};\npub use commands::{\n    OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft, SyncQueueItemDraft,\n    SyncStatusUpdate,\n};\npub use offline_action::OfflineActionRecord;\npub use optimistic_update::OptimisticUpdateRecord;\npub use saved_action::SavedOfflineAction;\npub use sync_queue_item::SyncQueueItem;\npub use sync_result::SyncResult;\npub use sync_status_record::SyncStatusRecord;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","offline_action.rs"],"content":"use crate::domain::value_objects::{\n    EntityId, OfflineActionId, OfflineActionType, OfflinePayload, PublicKey, RemoteEventId,\n    SyncStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflineActionRecord {\n    pub record_id: Option<i64>,\n    pub action_id: OfflineActionId,\n    pub user_pubkey: PublicKey,\n    pub action_type: OfflineActionType,\n    pub target_id: Option<EntityId>,\n    pub payload: OfflinePayload,\n    pub remote_id: Option<RemoteEventId>,\n    pub sync_status: SyncStatus,\n    pub created_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl OfflineActionRecord {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        record_id: Option<i64>,\n        action_id: OfflineActionId,\n        user_pubkey: PublicKey,\n        action_type: OfflineActionType,\n        target_id: Option<EntityId>,\n        payload: OfflinePayload,\n        sync_status: SyncStatus,\n        created_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) -> Self {\n        Self {\n            record_id,\n            action_id,\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n            remote_id,\n            sync_status,\n            created_at,\n            synced_at,\n            error_message: None,\n        }\n    }\n\n    pub fn with_error_message(mut self, message: Option<String>) -> Self {\n        self.error_message = message;\n        self\n    }\n\n    pub fn mark_synced(\n        &mut self,\n        status: SyncStatus,\n        synced_at: Option<DateTime<Utc>>,\n        remote_id: Option<RemoteEventId>,\n    ) {\n        self.sync_status = status;\n        self.synced_at = synced_at;\n        self.remote_id = remote_id;\n    }\n}\n","traces":[{"line":25,"address":[17698640],"length":1,"stats":{"Line":3}},{"line":52,"address":[13352975,13352800],"length":1,"stats":{"Line":0}},{"line":53,"address":[13593755,13593664],"length":1,"stats":{"Line":0}},{"line":54,"address":[17699159],"length":1,"stats":{"Line":0}},{"line":57,"address":[13593840,13594152,13594178],"length":1,"stats":{"Line":0}},{"line":63,"address":[17699228],"length":1,"stats":{"Line":0}},{"line":64,"address":[17699354],"length":1,"stats":{"Line":0}},{"line":65,"address":[17699373],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":8},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","optimistic_update.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, OptimisticUpdateId};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OptimisticUpdateRecord {\n    pub record_id: i64,\n    pub update_id: OptimisticUpdateId,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub original_data: Option<OfflinePayload>,\n    pub updated_data: OfflinePayload,\n    pub is_confirmed: bool,\n    pub created_at: DateTime<Utc>,\n    pub confirmed_at: Option<DateTime<Utc>>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","saved_action.rs"],"content":"use super::OfflineActionRecord;\nuse crate::domain::value_objects::OfflineActionId;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SavedOfflineAction {\n    pub local_id: OfflineActionId,\n    pub action: OfflineActionRecord,\n}\n\nimpl SavedOfflineAction {\n    pub fn new(local_id: OfflineActionId, action: OfflineActionRecord) -> Self {\n        Self { local_id, action }\n    }\n}\n","traces":[{"line":12,"address":[13027952],"length":1,"stats":{"Line":3}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_queue_item.rs"],"content":"use crate::domain::value_objects::{\n    OfflineActionType, OfflinePayload, SyncQueueId, SyncQueueStatus,\n};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncQueueItem {\n    pub id: SyncQueueId,\n    pub action_type: OfflineActionType,\n    pub payload: OfflinePayload,\n    pub status: SyncQueueStatus,\n    pub retry_count: u32,\n    pub max_retries: u32,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub synced_at: Option<DateTime<Utc>>,\n    pub error_message: Option<String>,\n}\n\nimpl SyncQueueItem {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        id: SyncQueueId,\n        action_type: OfflineActionType,\n        payload: OfflinePayload,\n        status: SyncQueueStatus,\n        retry_count: u32,\n        max_retries: u32,\n        created_at: DateTime<Utc>,\n        updated_at: DateTime<Utc>,\n        synced_at: Option<DateTime<Utc>>,\n        error_message: Option<String>,\n    ) -> Self {\n        Self {\n            id,\n            action_type,\n            payload,\n            status,\n            retry_count,\n            max_retries,\n            created_at,\n            updated_at,\n            synced_at,\n            error_message,\n        }\n    }\n}\n","traces":[{"line":23,"address":[11319168],"length":1,"stats":{"Line":2}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_result.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct SyncResult {\n    pub synced_count: u32,\n    pub failed_count: u32,\n    pub pending_count: u32,\n}\n\nimpl SyncResult {\n    pub fn new(synced_count: u32, failed_count: u32, pending_count: u32) -> Self {\n        Self {\n            synced_count,\n            failed_count,\n            pending_count,\n        }\n    }\n}\n","traces":[{"line":11,"address":[11731296],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","offline","sync_status_record.rs"],"content":"use crate::domain::value_objects::{EntityId, EntityType, OfflinePayload, SyncStatus};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct SyncStatusRecord {\n    pub record_id: i64,\n    pub entity_type: EntityType,\n    pub entity_id: EntityId,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: DateTime<Utc>,\n    pub last_remote_sync: Option<DateTime<Utc>>,\n    pub sync_status: SyncStatus,\n    pub conflict_data: Option<OfflinePayload>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","post.rs"],"content":"use super::user::User;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Post {\n    pub id: String,\n    pub content: String,\n    pub author: User,\n    pub topic_id: String,\n    pub created_at: DateTime<Utc>,\n    pub tags: Vec<String>,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: Vec<Post>,\n    pub is_synced: bool,\n    pub is_boosted: bool,\n    pub is_bookmarked: bool,\n    pub local_id: Option<String>,\n    pub event_id: Option<String>,\n}\n\nimpl Post {\n    pub fn new(content: String, author: User, topic_id: String) -> Self {\n        let id = uuid::Uuid::new_v4().to_string();\n        let local_id = id.clone();\n\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at: chrono::Utc::now(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            local_id: Some(local_id),\n            event_id: None,\n        }\n    }\n\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    pub fn mark_as_synced(&mut self, event_id: String) {\n        self.is_synced = true;\n        self.event_id = Some(event_id);\n    }\n\n    pub fn add_reply(&mut self, reply: Post) {\n        self.replies.push(reply);\n    }\n\n    pub fn increment_likes(&mut self) {\n        self.likes += 1;\n    }\n\n    pub fn decrement_likes(&mut self) {\n        if self.likes > 0 {\n            self.likes -= 1;\n        }\n    }\n\n    pub fn increment_boosts(&mut self) {\n        self.boosts += 1;\n        self.is_boosted = true;\n    }\n\n    pub fn toggle_bookmark(&mut self) {\n        self.is_bookmarked = !self.is_bookmarked;\n    }\n\n    pub fn new_with_id(\n        id: String,\n        content: String,\n        author: User,\n        topic_id: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            content,\n            author,\n            topic_id,\n            created_at,\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: false,\n            is_boosted: false,\n            is_bookmarked: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    pub fn mark_as_unsynced(&mut self) {\n        self.is_synced = false;\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostDraft {\n    pub id: String,\n    pub content: String,\n    pub topic_id: String,\n    pub tags: Vec<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl PostDraft {\n    pub fn new(content: String, topic_id: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            content,\n            topic_id,\n            tags: Vec::new(),\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn update_content(&mut self, content: String) {\n        self.content = content;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn into_post(self, author: User) -> Post {\n        Post::new(self.content, author, self.topic_id).with_tags(self.tags)\n    }\n}\n","traces":[{"line":24,"address":[18134675,18134518,18133488],"length":1,"stats":{"Line":0}},{"line":25,"address":[18663920,18664033],"length":1,"stats":{"Line":0}},{"line":26,"address":[15924222],"length":1,"stats":{"Line":0}},{"line":33,"address":[13449219],"length":1,"stats":{"Line":0}},{"line":34,"address":[13449282],"length":1,"stats":{"Line":0}},{"line":37,"address":[18905173],"length":1,"stats":{"Line":0}},{"line":41,"address":[18905238],"length":1,"stats":{"Line":0}},{"line":46,"address":[13450239,13450064],"length":1,"stats":{"Line":0}},{"line":47,"address":[18905968,18906059],"length":1,"stats":{"Line":0}},{"line":48,"address":[18665259],"length":1,"stats":{"Line":0}},{"line":51,"address":[18692048,18692133],"length":1,"stats":{"Line":0}},{"line":52,"address":[18134926],"length":1,"stats":{"Line":0}},{"line":53,"address":[18665333,18665428],"length":1,"stats":{"Line":0}},{"line":56,"address":[13450432],"length":1,"stats":{"Line":0}},{"line":57,"address":[18665477],"length":1,"stats":{"Line":0}},{"line":60,"address":[15925648],"length":1,"stats":{"Line":0}},{"line":61,"address":[18665517,18665554],"length":1,"stats":{"Line":0}},{"line":64,"address":[13450544],"length":1,"stats":{"Line":0}},{"line":65,"address":[13450612,13450558],"length":1,"stats":{"Line":0}},{"line":66,"address":[18135217,18135254],"length":1,"stats":{"Line":0}},{"line":70,"address":[18906512],"length":1,"stats":{"Line":0}},{"line":71,"address":[15925837,15925881],"length":1,"stats":{"Line":0}},{"line":72,"address":[18692461],"length":1,"stats":{"Line":0}},{"line":75,"address":[18665760],"length":1,"stats":{"Line":0}},{"line":76,"address":[13450725],"length":1,"stats":{"Line":0}},{"line":79,"address":[18692528,18693194,18693251],"length":1,"stats":{"Line":0}},{"line":92,"address":[18135514],"length":1,"stats":{"Line":0}},{"line":95,"address":[15926129],"length":1,"stats":{"Line":0}},{"line":104,"address":[18136128],"length":1,"stats":{"Line":0}},{"line":105,"address":[18136133],"length":1,"stats":{"Line":0}},{"line":120,"address":[18907833,18907376,18907905],"length":1,"stats":{"Line":0}},{"line":121,"address":[18136171],"length":1,"stats":{"Line":0}},{"line":123,"address":[18136260],"length":1,"stats":{"Line":0}},{"line":126,"address":[15926907],"length":1,"stats":{"Line":0}},{"line":132,"address":[13452121,13452064],"length":1,"stats":{"Line":0}},{"line":133,"address":[18693932,18693858],"length":1,"stats":{"Line":0}},{"line":134,"address":[18667219],"length":1,"stats":{"Line":0}},{"line":137,"address":[15927408,15927642,15927661],"length":1,"stats":{"Line":0}},{"line":138,"address":[15927429,15927567],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","topic.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Topic {\n    pub id: String,\n    pub name: String,\n    pub description: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n    pub is_joined: bool,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub is_public: bool,\n    pub owner: Option<String>,\n    pub image_url: Option<String>,\n}\n\nimpl Topic {\n    pub fn new(name: String, description: Option<String>) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: uuid::Uuid::new_v4().to_string(),\n            name,\n            description,\n            created_at: now,\n            updated_at: now,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            is_public: true,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn public_topic() -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: \"public\".to_string(),\n            name: \"#public\".to_string(),\n            description: Some(\"公開タイムライン\".to_string()),\n            created_at: now,\n            updated_at: now,\n            is_joined: true,\n            member_count: 0,\n            post_count: 0,\n            is_public: true,\n            owner: None,\n            image_url: None,\n        }\n    }\n\n    pub fn join(&mut self) {\n        self.is_joined = true;\n        self.member_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn leave(&mut self) {\n        self.is_joined = false;\n        if self.member_count > 0 {\n            self.member_count -= 1;\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn increment_post_count(&mut self) {\n        self.post_count += 1;\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn decrement_post_count(&mut self) {\n        if self.post_count > 0 {\n            self.post_count -= 1;\n            self.updated_at = chrono::Utc::now();\n        }\n    }\n\n    pub fn update_description(&mut self, description: String) {\n        self.description = Some(description);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn set_owner(&mut self, owner: String) {\n        self.owner = Some(owner);\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn new_with_id(\n        id: String,\n        name: String,\n        description: String,\n        created_at: DateTime<Utc>,\n    ) -> Self {\n        Self {\n            id,\n            name,\n            description: Some(description),\n            created_at,\n            updated_at: created_at,\n            is_joined: false,\n            member_count: 0,\n            post_count: 0,\n            is_public: true,\n            owner: None,\n            image_url: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStats {\n    pub topic_id: String,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub active_members: u32,\n    pub posts_today: u32,\n    pub last_activity: Option<i64>,\n}\n\nimpl TopicStats {\n    pub fn new(topic_id: String) -> Self {\n        Self {\n            topic_id,\n            member_count: 0,\n            post_count: 0,\n            active_members: 0,\n            posts_today: 0,\n            last_activity: None,\n        }\n    }\n}\n","traces":[{"line":20,"address":[11899472,11899939,11899964],"length":1,"stats":{"Line":0}},{"line":21,"address":[12670730],"length":1,"stats":{"Line":0}},{"line":23,"address":[15800770],"length":1,"stats":{"Line":0}},{"line":37,"address":[12430384,12430891],"length":1,"stats":{"Line":0}},{"line":38,"address":[15801216],"length":1,"stats":{"Line":0}},{"line":40,"address":[17700078],"length":1,"stats":{"Line":0}},{"line":41,"address":[12671282],"length":1,"stats":{"Line":0}},{"line":42,"address":[17700251,17700176],"length":1,"stats":{"Line":0}},{"line":54,"address":[15801744],"length":1,"stats":{"Line":0}},{"line":55,"address":[11900542],"length":1,"stats":{"Line":0}},{"line":56,"address":[15801765,15801841],"length":1,"stats":{"Line":0}},{"line":57,"address":[12457718],"length":1,"stats":{"Line":0}},{"line":60,"address":[15801872],"length":1,"stats":{"Line":0}},{"line":61,"address":[11900670],"length":1,"stats":{"Line":0}},{"line":62,"address":[12671909,12672001],"length":1,"stats":{"Line":0}},{"line":63,"address":[17700835,17700798],"length":1,"stats":{"Line":0}},{"line":65,"address":[17700750],"length":1,"stats":{"Line":0}},{"line":68,"address":[12457936],"length":1,"stats":{"Line":0}},{"line":69,"address":[12458026,12457950],"length":1,"stats":{"Line":0}},{"line":70,"address":[17700911],"length":1,"stats":{"Line":0}},{"line":73,"address":[12431312],"length":1,"stats":{"Line":0}},{"line":74,"address":[12672250,12672158],"length":1,"stats":{"Line":0}},{"line":75,"address":[12458081,12458156],"length":1,"stats":{"Line":0}},{"line":76,"address":[12672212],"length":1,"stats":{"Line":0}},{"line":80,"address":[15802325,15802256],"length":1,"stats":{"Line":0}},{"line":81,"address":[17701118,17701204],"length":1,"stats":{"Line":0}},{"line":82,"address":[17701231],"length":1,"stats":{"Line":0}},{"line":85,"address":[12431685,12431616],"length":1,"stats":{"Line":0}},{"line":86,"address":[12431630,12431716],"length":1,"stats":{"Line":0}},{"line":87,"address":[12458479],"length":1,"stats":{"Line":0}},{"line":90,"address":[12672624],"length":1,"stats":{"Line":0}},{"line":99,"address":[17701459],"length":1,"stats":{"Line":0}},{"line":123,"address":[17701728],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","entities","user.rs"],"content":"use chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n// UserProfile for compatibility with SqliteRepository\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct UserProfile {\n    pub display_name: String,\n    pub bio: String,\n    pub avatar_url: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct User {\n    pub npub: String,\n    pub pubkey: String,\n    pub profile: UserProfile,\n    pub name: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,\n}\n\nimpl User {\n    pub fn new(npub: String, pubkey: String) -> Self {\n        let now = chrono::Utc::now();\n        Self {\n            npub,\n            pubkey,\n            profile: UserProfile {\n                display_name: String::new(),\n                bio: String::new(),\n                avatar_url: None,\n            },\n            name: None,\n            nip05: None,\n            lud16: None,\n            created_at: now,\n            updated_at: now,\n        }\n    }\n\n    pub fn with_profile(\n        mut self,\n        name: Option<String>,\n        display_name: Option<String>,\n        about: Option<String>,\n    ) -> Self {\n        self.name = name;\n        self.profile.display_name = display_name.unwrap_or_default();\n        self.profile.bio = about.unwrap_or_default();\n        self.updated_at = chrono::Utc::now();\n        self\n    }\n\n    pub fn update_metadata(&mut self, metadata: UserMetadata) {\n        if let Some(name) = metadata.name {\n            self.name = Some(name);\n        }\n        if let Some(display_name) = metadata.display_name {\n            self.profile.display_name = display_name;\n        }\n        if let Some(about) = metadata.about {\n            self.profile.bio = about;\n        }\n        if let Some(picture) = metadata.picture {\n            self.profile.avatar_url = Some(picture);\n        }\n        if let Some(nip05) = metadata.nip05 {\n            self.nip05 = Some(nip05);\n        }\n        if let Some(lud16) = metadata.lud16 {\n            self.lud16 = Some(lud16);\n        }\n        self.updated_at = chrono::Utc::now();\n    }\n\n    pub fn pubkey(&self) -> &str {\n        &self.pubkey\n    }\n\n    pub fn npub(&self) -> &str {\n        &self.npub\n    }\n\n    pub fn from_pubkey(pubkey: &str) -> Self {\n        use nostr_sdk::prelude::*;\n\n        let npub = PublicKey::from_hex(pubkey)\n            .ok()\n            .and_then(|pk| pk.to_bech32().ok())\n            .unwrap_or_else(|| pubkey.to_string());\n\n        Self::new(npub, pubkey.to_string())\n    }\n\n    pub fn new_with_profile(npub: String, profile: UserProfile) -> Self {\n        let mut user = Self::new(npub.clone(), String::new());\n        user.profile = profile;\n        user\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserMetadata {\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub nip05: Option<String>,\n    pub lud16: Option<String>,\n}\n","traces":[{"line":25,"address":[12881980,12881216,12882035],"length":1,"stats":{"Line":0}},{"line":26,"address":[17565882],"length":1,"stats":{"Line":0}},{"line":30,"address":[12881525],"length":1,"stats":{"Line":0}},{"line":43,"address":[18124484,18124525,18123840],"length":1,"stats":{"Line":0}},{"line":49,"address":[18123885],"length":1,"stats":{"Line":0}},{"line":50,"address":[18097384,18097292],"length":1,"stats":{"Line":0}},{"line":51,"address":[18124219],"length":1,"stats":{"Line":0}},{"line":52,"address":[18124376],"length":1,"stats":{"Line":0}},{"line":53,"address":[18097697],"length":1,"stats":{"Line":0}},{"line":56,"address":[17567408,17569957,17569254],"length":1,"stats":{"Line":0}},{"line":57,"address":[12882792,12883130],"length":1,"stats":{"Line":0}},{"line":58,"address":[18097992,18098076],"length":1,"stats":{"Line":0}},{"line":60,"address":[12883359,12882992,12883188],"length":1,"stats":{"Line":0}},{"line":61,"address":[18125050,18124990],"length":1,"stats":{"Line":0}},{"line":63,"address":[18098274,18098413,18098593],"length":1,"stats":{"Line":0}},{"line":64,"address":[18339274,18339334],"length":1,"stats":{"Line":0}},{"line":66,"address":[18098462,18098607,18098834],"length":1,"stats":{"Line":0}},{"line":67,"address":[17568239,17568331],"length":1,"stats":{"Line":0}},{"line":69,"address":[17568448,17568291,17568706],"length":1,"stats":{"Line":0}},{"line":70,"address":[18098985,18098883],"length":1,"stats":{"Line":0}},{"line":72,"address":[18099120,18098938,18099355],"length":1,"stats":{"Line":0}},{"line":73,"address":[18585042,18584966],"length":1,"stats":{"Line":0}},{"line":75,"address":[18099208,18099394],"length":1,"stats":{"Line":0}},{"line":78,"address":[18127536],"length":1,"stats":{"Line":0}},{"line":79,"address":[18127541],"length":1,"stats":{"Line":0}},{"line":82,"address":[18100816],"length":1,"stats":{"Line":0}},{"line":83,"address":[18127557],"length":1,"stats":{"Line":0}},{"line":86,"address":[17570432,17570747,17570779],"length":1,"stats":{"Line":0}},{"line":89,"address":[18341707],"length":1,"stats":{"Line":0}},{"line":91,"address":[18127936,18127950],"length":1,"stats":{"Line":0}},{"line":92,"address":[18101285,18101264],"length":1,"stats":{"Line":0}},{"line":94,"address":[18101160,18100999],"length":1,"stats":{"Line":0}},{"line":97,"address":[18128048,18128602,18128539],"length":1,"stats":{"Line":0}},{"line":98,"address":[18101423,18101812,18101339],"length":1,"stats":{"Line":0}},{"line":99,"address":[18587512,18587325],"length":1,"stats":{"Line":0}},{"line":100,"address":[18587544],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","mod.rs"],"content":"#![allow(unused_imports)]\n#![allow(dead_code)]\n\npub mod entities;\npub mod p2p;\npub mod repositories;\npub mod value_objects;\n\npub use entities::{Event, Post, Topic, User};\npub use p2p::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, P2PEvent, TopicMesh, TopicStats,\n    generate_topic_id, user_topic_id,\n};\npub use value_objects::{EventId, Npub, TopicId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\n#[allow(dead_code)]\npub enum P2PError {\n    #[error(\"Failed to initialize endpoint: {0}\")]\n    EndpointInit(String),\n\n    #[error(\"Topic not found: {0}\")]\n    TopicNotFound(String),\n\n    #[error(\"Failed to broadcast message: {0}\")]\n    BroadcastFailed(String),\n\n    #[error(\"Invalid peer address: {0}\")]\n    InvalidPeerAddr(String),\n\n    #[error(\"Failed to join topic: {0}\")]\n    JoinTopicFailed(String),\n\n    #[error(\"Failed to leave topic: {0}\")]\n    LeaveTopicFailed(String),\n\n    #[error(\"Message serialization failed: {0}\")]\n    SerializationError(String),\n\n    #[error(\"Message signature verification failed\")]\n    SignatureVerificationFailed,\n\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n}\n\nimpl From<anyhow::Error> for P2PError {\n    fn from(err: anyhow::Error) -> Self {\n        P2PError::Internal(err.to_string())\n    }\n}\n\nimpl From<std::io::Error> for P2PError {\n    fn from(err: std::io::Error) -> Self {\n        P2PError::Internal(err.to_string())\n    }\n}\n\npub type Result<T> = std::result::Result<T, P2PError>;\n","traces":[{"line":35,"address":[19224400,19224532],"length":1,"stats":{"Line":1}},{"line":36,"address":[19224419,19224477],"length":1,"stats":{"Line":2}},{"line":41,"address":[13028192,13028324],"length":1,"stats":{"Line":1}},{"line":42,"address":[13028269,13028211],"length":1,"stats":{"Line":2}}],"covered":4,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","events.rs"],"content":"use crate::domain::p2p::message::GossipMessage;\n\n#[derive(Clone, Debug)]\npub enum P2PEvent {\n    MessageReceived {\n        topic_id: String,\n        message: GossipMessage,\n        _from_peer: Vec<u8>,\n    },\n    PeerJoined {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n    PeerLeft {\n        topic_id: String,\n        peer_id: Vec<u8>,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","message.rs"],"content":"use bincode::{Decode, Encode};\nuse chrono::Utc;\nuse secp256k1::ecdsa::Signature;\nuse secp256k1::{Message as Secp256k1Message, PublicKey, SECP256K1, SecretKey};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse uuid::Uuid;\n\npub type MessageId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GossipMessage {\n    /// メッセージID（重複チェック用）\n    pub id: MessageId,\n\n    /// メッセージタイプ\n    pub msg_type: MessageType,\n\n    /// ペイロード\n    pub payload: Vec<u8>,\n\n    /// タイムスタンプ\n    pub timestamp: i64,\n\n    /// 送信者の公開鍵（33バイト - 圧縮形式）\n    pub sender: Vec<u8>,\n\n    /// 署名\n    pub signature: Vec<u8>,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, Encode, Decode)]\npub enum MessageType {\n    /// Nostrイベント\n    NostrEvent,\n\n    /// トピック情報の同期\n    TopicSync,\n\n    /// ピア情報の交換\n    PeerExchange,\n\n    /// ハートビート\n    Heartbeat,\n}\n\nimpl GossipMessage {\n    /// 新しいメッセージを作成\n    pub fn new(msg_type: MessageType, payload: Vec<u8>, sender: Vec<u8>) -> Self {\n        let id = generate_message_id();\n        let timestamp = Utc::now().timestamp();\n\n        Self {\n            id,\n            msg_type,\n            payload,\n            timestamp,\n            sender,\n            signature: Vec::new(), // 署名は後で追加\n        }\n    }\n\n    /// メッセージIDを生成\n    #[allow(dead_code)]\n    fn generate_message_id() -> MessageId {\n        let uuid = Uuid::new_v4();\n        let mut id = [0u8; 32];\n        let uuid_bytes = uuid.as_bytes();\n        id[..16].copy_from_slice(uuid_bytes);\n        id[16..].copy_from_slice(uuid_bytes);\n        id\n    }\n\n    /// メッセージを署名用のバイト列に変換\n    pub fn to_signing_bytes(&self) -> Vec<u8> {\n        let mut bytes = Vec::new();\n        bytes.extend_from_slice(&self.id);\n        bytes.extend_from_slice(&(self.msg_type as u8).to_le_bytes());\n        bytes.extend_from_slice(&self.payload);\n        bytes.extend_from_slice(&self.timestamp.to_le_bytes());\n        // 注意: senderは署名に含めない（署名作成時にはまだ設定されていないため）\n        bytes\n    }\n\n    /// バイト列からメッセージを復元\n    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {\n        bincode::decode_from_slice(bytes, bincode::config::standard())\n            .map(|(msg, _)| msg)\n            .map_err(|e| format!(\"Failed to deserialize message: {e}\"))\n    }\n\n    /// メッセージをバイト列に変換\n    pub fn to_bytes(&self) -> Result<Vec<u8>, String> {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| format!(\"Failed to serialize message: {e}\"))\n    }\n\n    /// メッセージに署名を付ける\n    pub fn sign(&mut self, secret_key: &SecretKey) -> Result<(), String> {\n        let signing_bytes = self.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest_slice(&hash)\n            .map_err(|e| format!(\"Failed to create message: {e}\"))?;\n\n        // 署名\n        let signature = SECP256K1.sign_ecdsa(&message, secret_key);\n        self.signature = signature.serialize_compact().to_vec();\n\n        // 公開鍵を設定（圧縮形式）\n        let public_key = PublicKey::from_secret_key(SECP256K1, secret_key);\n        self.sender = public_key.serialize().to_vec();\n\n        Ok(())\n    }\n\n    /// 署名を検証\n    pub fn verify_signature(&self) -> Result<bool, String> {\n        if self.signature.is_empty() || self.sender.is_empty() {\n            return Ok(false);\n        }\n\n        // 公開鍵を復元\n        let public_key =\n            PublicKey::from_slice(&self.sender).map_err(|e| format!(\"Invalid public key: {e}\"))?;\n\n        // 署名を復元\n        let signature = Signature::from_compact(&self.signature)\n            .map_err(|e| format!(\"Invalid signature: {e}\"))?;\n\n        // 署名対象のバイト列を作成\n        let mut message_for_verification = self.clone();\n        message_for_verification.signature = Vec::new(); // 署名フィールドを空にする\n        let signing_bytes = message_for_verification.to_signing_bytes();\n\n        // SHA256ハッシュを計算\n        let mut hasher = Sha256::new();\n        hasher.update(&signing_bytes);\n        let hash = hasher.finalize();\n\n        // ハッシュからSecp256k1メッセージを作成\n        let message = Secp256k1Message::from_digest_slice(&hash)\n            .map_err(|e| format!(\"Failed to create message: {e}\"))?;\n\n        // 署名を検証\n        Ok(SECP256K1\n            .verify_ecdsa(&message, &signature, &public_key)\n            .is_ok())\n    }\n}\n\n/// トピックIDの生成\npub fn generate_topic_id(topic_name: &str) -> String {\n    format!(\"kukuri:topic:{}\", topic_name.to_lowercase())\n}\n\n/// グローバルトピック（全体のタイムライン）\npub const GLOBAL_TOPIC: &str = \"kukuri:global\";\n\n/// ユーザー固有トピック\npub fn user_topic_id(pubkey: &str) -> String {\n    format!(\"kukuri:user:{pubkey}\")\n}\n\nfn generate_message_id() -> MessageId {\n    let uuid = Uuid::new_v4();\n    let mut id = [0u8; 32];\n    let uuid_bytes = uuid.as_bytes();\n    id[..16].copy_from_slice(uuid_bytes);\n    let timestamp = Utc::now().timestamp_nanos_opt().unwrap_or(0);\n    id[16..24].copy_from_slice(&timestamp.to_le_bytes());\n    id[24..].copy_from_slice(&uuid_bytes[8..]);\n    id\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_message_signing_and_verification() {\n        // 秘密鍵を生成\n        let secret_key = SecretKey::new(&mut rand::thread_rng());\n\n        // メッセージを作成\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3, 4, 5], vec![]);\n\n        // 署名\n        assert!(message.sign(&secret_key).is_ok());\n        assert!(!message.signature.is_empty());\n        assert!(!message.sender.is_empty());\n\n        // 検証 - 正しい署名\n        assert!(message.verify_signature().unwrap());\n\n        // ペイロードを改ざん\n        message.payload.push(6);\n        assert!(!message.verify_signature().unwrap());\n\n        // 署名を改ざん\n        message.payload.pop(); // 元に戻す\n        if !message.signature.is_empty() {\n            message.signature[0] ^= 0xFF;\n        }\n        assert!(!message.verify_signature().unwrap());\n    }\n\n    #[test]\n    fn test_message_serialization() {\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![10, 20, 30],\n            vec![1; 33], // 公開鍵は33バイト\n        );\n\n        // シリアライズ\n        let bytes = message.to_bytes().unwrap();\n\n        // デシリアライズ\n        let deserialized = GossipMessage::from_bytes(&bytes).unwrap();\n\n        assert_eq!(message.id, deserialized.id);\n        assert_eq!(message.msg_type as u8, deserialized.msg_type as u8);\n        assert_eq!(message.payload, deserialized.payload);\n        assert_eq!(message.timestamp, deserialized.timestamp);\n        assert_eq!(message.sender, deserialized.sender);\n    }\n}\n","traces":[{"line":49,"address":[17510160,17510104,17509632],"length":1,"stats":{"Line":1}},{"line":50,"address":[12294633],"length":1,"stats":{"Line":1}},{"line":51,"address":[17750590],"length":1,"stats":{"Line":2}},{"line":59,"address":[14095376],"length":1,"stats":{"Line":2}},{"line":65,"address":[17510192],"length":1,"stats":{"Line":0}},{"line":66,"address":[12295166],"length":1,"stats":{"Line":0}},{"line":67,"address":[17510217],"length":1,"stats":{"Line":0}},{"line":68,"address":[17751066],"length":1,"stats":{"Line":0}},{"line":69,"address":[17510254],"length":1,"stats":{"Line":0}},{"line":70,"address":[17751138],"length":1,"stats":{"Line":0}},{"line":71,"address":[17537104],"length":1,"stats":{"Line":0}},{"line":75,"address":[17537539,17537152],"length":1,"stats":{"Line":1}},{"line":76,"address":[12295403],"length":1,"stats":{"Line":1}},{"line":77,"address":[16980072],"length":1,"stats":{"Line":1}},{"line":78,"address":[14096046],"length":1,"stats":{"Line":1}},{"line":79,"address":[17751457],"length":1,"stats":{"Line":1}},{"line":80,"address":[12295644],"length":1,"stats":{"Line":1}},{"line":82,"address":[17537505],"length":1,"stats":{"Line":1}},{"line":86,"address":[17751664],"length":1,"stats":{"Line":1}},{"line":87,"address":[12295834],"length":1,"stats":{"Line":1}},{"line":88,"address":[17537696,17537708],"length":1,"stats":{"Line":2}},{"line":89,"address":[17510992,17511013],"length":1,"stats":{"Line":0}},{"line":93,"address":[17752032],"length":1,"stats":{"Line":1}},{"line":94,"address":[14096728],"length":1,"stats":{"Line":1}},{"line":95,"address":[12296240,12296261],"length":1,"stats":{"Line":0}},{"line":99,"address":[12296448,12297501],"length":1,"stats":{"Line":1}},{"line":100,"address":[16981131],"length":1,"stats":{"Line":1}},{"line":103,"address":[16981145],"length":1,"stats":{"Line":1}},{"line":104,"address":[14097108],"length":1,"stats":{"Line":1}},{"line":105,"address":[17752455],"length":1,"stats":{"Line":1}},{"line":108,"address":[17538492,17538745],"length":1,"stats":{"Line":1}},{"line":109,"address":[17511977,17512600,17512576],"length":1,"stats":{"Line":0}},{"line":112,"address":[17752778,17752880],"length":1,"stats":{"Line":2}},{"line":113,"address":[17752923],"length":1,"stats":{"Line":1}},{"line":116,"address":[12297207],"length":1,"stats":{"Line":1}},{"line":117,"address":[17753150],"length":1,"stats":{"Line":1}},{"line":119,"address":[16982091],"length":1,"stats":{"Line":1}},{"line":123,"address":[12297664,12299240],"length":1,"stats":{"Line":1}},{"line":124,"address":[17539478],"length":1,"stats":{"Line":1}},{"line":125,"address":[12297742],"length":1,"stats":{"Line":0}},{"line":129,"address":[14098281,14099744,14099768,14098526],"length":1,"stats":{"Line":1}},{"line":133,"address":[17753791,17754182,17753969],"length":1,"stats":{"Line":2}},{"line":134,"address":[12299416,12298262,12299392],"length":1,"stats":{"Line":0}},{"line":137,"address":[14098740],"length":1,"stats":{"Line":1}},{"line":138,"address":[14098745,14098882],"length":1,"stats":{"Line":2}},{"line":139,"address":[14099021],"length":1,"stats":{"Line":1}},{"line":142,"address":[17754402],"length":1,"stats":{"Line":1}},{"line":143,"address":[17754465],"length":1,"stats":{"Line":1}},{"line":144,"address":[16983260],"length":1,"stats":{"Line":1}},{"line":147,"address":[14099486,14099253],"length":1,"stats":{"Line":1}},{"line":148,"address":[16984160,16984184,16983620],"length":1,"stats":{"Line":0}},{"line":151,"address":[17754821,17754918],"length":1,"stats":{"Line":2}},{"line":158,"address":[14100128,14100431],"length":1,"stats":{"Line":1}},{"line":159,"address":[12299681],"length":1,"stats":{"Line":1}},{"line":166,"address":[17541760],"length":1,"stats":{"Line":1}},{"line":167,"address":[17755882],"length":1,"stats":{"Line":1}},{"line":170,"address":[17515168],"length":1,"stats":{"Line":1}},{"line":171,"address":[16984785],"length":1,"stats":{"Line":1}},{"line":172,"address":[12300156],"length":1,"stats":{"Line":2}},{"line":173,"address":[17541949],"length":1,"stats":{"Line":2}},{"line":174,"address":[14100676],"length":1,"stats":{"Line":2}},{"line":175,"address":[17542024],"length":1,"stats":{"Line":2}},{"line":176,"address":[17756170],"length":1,"stats":{"Line":2}},{"line":177,"address":[14100885],"length":1,"stats":{"Line":2}},{"line":178,"address":[14100986],"length":1,"stats":{"Line":2}}],"covered":52,"coverable":65},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","mod.rs"],"content":"pub mod error;\npub mod events;\npub mod message;\npub mod topic_mesh;\n\n#[cfg(test)]\nmod tests;\n\npub use error::{P2PError, Result};\npub use events::P2PEvent;\npub use message::{\n    GLOBAL_TOPIC, GossipMessage, MessageId, MessageType, generate_topic_id, user_topic_id,\n};\npub use topic_mesh::{TopicMesh, TopicStats};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","error_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::p2p::error::*;\n    use std::io;\n\n    #[test]\n    fn test_error_display() {\n        let err = P2PError::EndpointInit(\"Failed to bind\".to_string());\n        assert_eq!(\n            err.to_string(),\n            \"Failed to initialize endpoint: Failed to bind\"\n        );\n\n        let err = P2PError::TopicNotFound(\"test-topic\".to_string());\n        assert_eq!(err.to_string(), \"Topic not found: test-topic\");\n\n        let err = P2PError::BroadcastFailed(\"Network error\".to_string());\n        assert_eq!(\n            err.to_string(),\n            \"Failed to broadcast message: Network error\"\n        );\n\n        let err = P2PError::InvalidPeerAddr(\"invalid:addr\".to_string());\n        assert_eq!(err.to_string(), \"Invalid peer address: invalid:addr\");\n    }\n\n    #[test]\n    fn test_error_from_anyhow() {\n        let anyhow_err = anyhow::anyhow!(\"Test error\");\n        let p2p_err: P2PError = anyhow_err.into();\n\n        match p2p_err {\n            P2PError::Internal(msg) => assert_eq!(msg, \"Test error\"),\n            _ => panic!(\"Expected Internal error\"),\n        }\n    }\n\n    #[test]\n    fn test_error_from_io() {\n        let io_err = io::Error::new(io::ErrorKind::NotFound, \"File not found\");\n        let p2p_err: P2PError = io_err.into();\n\n        match p2p_err {\n            P2PError::Internal(msg) => assert!(msg.contains(\"File not found\")),\n            _ => panic!(\"Expected Internal error\"),\n        }\n    }\n\n    #[test]\n    fn test_result_type() {\n        fn test_function() -> Result<String> {\n            Ok(\"Success\".to_string())\n        }\n\n        let result = test_function();\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Success\");\n    }\n\n    #[test]\n    fn test_all_error_variants() {\n        let errors = vec![\n            P2PError::EndpointInit(\"test\".to_string()),\n            P2PError::TopicNotFound(\"test\".to_string()),\n            P2PError::BroadcastFailed(\"test\".to_string()),\n            P2PError::InvalidPeerAddr(\"test\".to_string()),\n            P2PError::JoinTopicFailed(\"test\".to_string()),\n            P2PError::LeaveTopicFailed(\"test\".to_string()),\n            P2PError::SerializationError(\"test\".to_string()),\n            P2PError::SignatureVerificationFailed,\n            P2PError::Internal(\"test\".to_string()),\n        ];\n\n        for err in errors {\n            // すべてのエラーがDebugとDisplayを実装していることを確認\n            let _ = format!(\"{err:?}\");\n            let _ = err.to_string();\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","gossip_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::entities::Event;\n    use crate::domain::p2p::generate_topic_id;\n    use crate::infrastructure::p2p::gossip_service::GossipService;\n    use crate::infrastructure::p2p::iroh_gossip_service::IrohGossipService;\n    use iroh::Endpoint;\n    use std::sync::Arc;\n\n    macro_rules! skip_unless_p2p_enabled {\n        ($name:literal) => {\n            if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n                eprintln!(\"skipping {} (ENABLE_P2P_INTEGRATION!=1)\", $name);\n                return;\n            }\n        };\n    }\n\n    async fn create_test_service() -> IrohGossipService {\n        let endpoint = Endpoint::builder().bind().await.unwrap();\n        IrohGossipService::new(Arc::new(endpoint)).unwrap()\n    }\n\n    #[tokio::test]\n    async fn test_topic_join_leave() {\n        skip_unless_p2p_enabled!(\"test_topic_join_leave\");\n        let service = create_test_service().await;\n        let topic_id = generate_topic_id(\"test-topic\");\n\n        // Join topic\n        let result = service.join_topic(&topic_id, vec![]).await;\n        assert!(result.is_ok());\n\n        // Verify topic is active\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert!(active_topics.contains(&topic_id));\n\n        // Leave topic\n        let result = service.leave_topic(&topic_id).await;\n        assert!(result.is_ok());\n\n        // Verify topic is removed\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert!(!active_topics.contains(&topic_id));\n    }\n\n    #[tokio::test]\n    async fn test_multiple_topics() {\n        skip_unless_p2p_enabled!(\"test_multiple_topics\");\n        let service = create_test_service().await;\n        let topics = vec![\"topic1\", \"topic2\", \"topic3\"];\n\n        // Join multiple topics\n        for topic in &topics {\n            let id = generate_topic_id(topic);\n            service.join_topic(&id, vec![]).await.unwrap();\n        }\n\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert_eq!(active_topics.len(), 3);\n\n        // Leave one topic\n        let id = generate_topic_id(\"topic2\");\n        service.leave_topic(&id).await.unwrap();\n\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert_eq!(active_topics.len(), 2);\n        assert!(!active_topics.contains(&generate_topic_id(\"topic2\")));\n    }\n\n    #[tokio::test]\n    async fn test_leave_nonexistent_topic() {\n        skip_unless_p2p_enabled!(\"test_leave_nonexistent_topic\");\n        let service = create_test_service().await;\n        let topic = generate_topic_id(\"nonexistent\");\n        let result = service.leave_topic(&topic).await;\n        // 未参加トピックのleaveは冪等（エラーにしない）\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_broadcast_to_topic() {\n        skip_unless_p2p_enabled!(\"test_broadcast_to_topic\");\n        let service = create_test_service().await;\n        let topic_id = generate_topic_id(\"broadcast-test\");\n\n        // まずトピックに参加\n        service.join_topic(&topic_id, vec![]).await.unwrap();\n\n        // ダミーEventを作成してブロードキャスト\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\n        let result = service.broadcast(&topic_id, &event).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_broadcast_to_nonexistent_topic() {\n        skip_unless_p2p_enabled!(\"test_broadcast_to_nonexistent_topic\");\n        let service = create_test_service().await;\n\n        let event = Event::new(1, \"hello\".to_string(), \"pubkey_test\".to_string());\n        let result = service.broadcast(\"nonexistent-topic\", &event).await;\n        // 未参加トピックのbroadcastはエラー\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_get_topic_status() {\n        skip_unless_p2p_enabled!(\"test_get_topic_status\");\n        // IrohGossipServiceではステータスAPIは最小提供のためスキップ\n        // 代わりにjoin後にget_joined_topicsで存在確認\n        let service = create_test_service().await;\n        let topic_id = generate_topic_id(\"status-test\");\n        service.join_topic(&topic_id, vec![]).await.unwrap();\n        let topics = service.get_joined_topics().await.unwrap();\n        assert!(topics.contains(&topic_id));\n    }\n\n    #[tokio::test]\n    async fn test_get_all_topic_stats() {\n        skip_unless_p2p_enabled!(\"test_get_all_topic_stats\");\n        let service = create_test_service().await;\n        let topics = vec![\"stats-topic1\", \"stats-topic2\", \"stats-topic3\"];\n        for topic in &topics {\n            service\n                .join_topic(&generate_topic_id(topic), vec![])\n                .await\n                .unwrap();\n        }\n        let joined = service.get_joined_topics().await.unwrap();\n        assert_eq!(joined.len(), 3);\n    }\n\n    #[tokio::test]\n    async fn test_shutdown() {\n        skip_unless_p2p_enabled!(\"test_shutdown\");\n        let service = create_test_service().await;\n        let topics = vec![\"shutdown-topic1\", \"shutdown-topic2\"];\n        for topic in &topics {\n            service\n                .join_topic(&generate_topic_id(topic), vec![])\n                .await\n                .unwrap();\n        }\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert_eq!(active_topics.len(), 2);\n        // leave all\n        for topic in &topics {\n            service\n                .leave_topic(&generate_topic_id(topic))\n                .await\n                .unwrap();\n        }\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert_eq!(active_topics.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_node_id() {\n        skip_unless_p2p_enabled!(\"test_node_id\");\n        // IrohGossipServiceでは直接のNodeID APIは提供しないため簡易確認のみ\n        let _service = create_test_service().await;\n        assert!(true);\n    }\n\n    #[tokio::test]\n    async fn test_node_addr() {\n        skip_unless_p2p_enabled!(\"test_node_addr\");\n        // IrohGossipServiceでは直接のアドレスAPIは提供しないためスキップ\n        let _service = create_test_service().await;\n        assert!(true);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_topic_operations() {\n        skip_unless_p2p_enabled!(\"test_concurrent_topic_operations\");\n        use std::sync::Arc;\n        use tokio::task;\n\n        let service = Arc::new(create_test_service().await);\n        let mut handles = vec![];\n\n        // 並行して複数のトピック操作を実行\n        for i in 0..5 {\n            let service_clone = service.clone();\n            let handle = task::spawn(async move {\n                let topic_id = generate_topic_id(&format!(\"concurrent-topic-{i}\"));\n                service_clone.join_topic(&topic_id, vec![]).await.unwrap();\n                let joined = service_clone.get_joined_topics().await.unwrap();\n                assert!(joined.contains(&topic_id));\n                service_clone.leave_topic(&topic_id).await.unwrap();\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 最終的にすべてのトピックから離脱していることを確認\n        let active_topics = service.get_joined_topics().await.unwrap();\n        assert_eq!(active_topics.len(), 0);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","message_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::p2p::message::*;\n\n    #[test]\n    fn test_message_type_copy() {\n        let msg_type = MessageType::NostrEvent;\n        let copied = msg_type;\n        assert!(matches!(copied, MessageType::NostrEvent));\n    }\n\n    #[test]\n    fn test_gossip_message_creation() {\n        let msg_type = MessageType::NostrEvent;\n        let payload = vec![1, 2, 3, 4, 5];\n        let sender = vec![0; 32];\n\n        let message = GossipMessage::new(msg_type, payload.clone(), sender.clone());\n\n        assert!(matches!(message.msg_type, MessageType::NostrEvent));\n        assert_eq!(message.payload, payload);\n        assert_eq!(message.sender, sender);\n        assert!(message.timestamp > 0);\n        assert_eq!(message.signature.len(), 0); // 初期状態では署名なし\n    }\n\n    #[test]\n    fn test_message_id_uniqueness() {\n        let messages: Vec<GossipMessage> = (0..100)\n            .map(|i| GossipMessage::new(MessageType::Heartbeat, vec![i as u8], vec![0; 32]))\n            .collect();\n\n        // すべてのメッセージIDがユニークであることを確認\n        let mut ids = messages.iter().map(|m| m.id).collect::<Vec<_>>();\n        ids.sort();\n        ids.dedup();\n        assert_eq!(ids.len(), 100);\n    }\n\n    #[test]\n    fn test_generate_topic_id() {\n        assert_eq!(generate_topic_id(\"Bitcoin\"), \"kukuri:topic:bitcoin\");\n        assert_eq!(generate_topic_id(\"NOSTR\"), \"kukuri:topic:nostr\");\n        assert_eq!(generate_topic_id(\"Test Topic\"), \"kukuri:topic:test topic\");\n    }\n\n    #[test]\n    fn test_global_topic_constant() {\n        assert_eq!(GLOBAL_TOPIC, \"kukuri:global\");\n    }\n\n    #[test]\n    fn test_user_topic_id() {\n        let pubkey = \"npub1234567890abcdef\";\n        assert_eq!(user_topic_id(pubkey), \"kukuri:user:npub1234567890abcdef\");\n    }\n\n    #[test]\n    fn test_message_to_signing_bytes() {\n        let message = GossipMessage::new(MessageType::NostrEvent, vec![1, 2, 3], vec![4, 5, 6]);\n\n        let signing_bytes = message.to_signing_bytes();\n\n        // 署名用バイト列が正しく生成されることを確認\n        assert!(!signing_bytes.is_empty());\n        assert!(signing_bytes.len() > message.id.len() + message.payload.len());\n    }\n\n    #[test]\n    fn test_all_message_types() {\n        let types = vec![\n            MessageType::NostrEvent,\n            MessageType::TopicSync,\n            MessageType::PeerExchange,\n            MessageType::Heartbeat,\n        ];\n\n        for msg_type in types {\n            let message = GossipMessage::new(msg_type, vec![], vec![0; 32]);\n            assert!(matches!(message.msg_type, _));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","mod.rs"],"content":"mod error_tests;\nmod gossip_tests;\nmod message_tests;\nmod topic_mesh_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","tests","topic_mesh_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::domain::p2p::message::{GossipMessage, MessageType};\n    use crate::domain::p2p::topic_mesh::*;\n\n    fn create_test_mesh() -> TopicMesh {\n        TopicMesh::new(\"test-topic\".to_string())\n    }\n\n    fn create_test_message(id: u8) -> GossipMessage {\n        let mut message = GossipMessage::new(MessageType::NostrEvent, vec![id], vec![id; 32]);\n        // 一意のIDを設定\n        message.id[0] = id;\n        message\n    }\n\n    #[tokio::test]\n    async fn test_topic_mesh_creation() {\n        let mesh = create_test_mesh();\n        let stats = mesh.get_stats().await;\n\n        assert_eq!(stats.peer_count, 0);\n        assert_eq!(stats.message_count, 0);\n        assert_eq!(stats.last_activity, 0);\n    }\n\n    #[tokio::test]\n    async fn test_message_handling() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(1);\n\n        // メッセージ処理\n        let result = mesh.handle_message(message.clone()).await;\n        assert!(result.is_ok());\n\n        // 統計情報の確認\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.message_count, 1);\n        assert_eq!(stats.peer_count, 1);\n        assert!(stats.last_activity > 0);\n    }\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = create_test_mesh();\n        let message = create_test_message(2);\n\n        // 最初のメッセージは重複ではない\n        assert!(!mesh.is_duplicate(&message.id).await);\n\n        // メッセージを処理\n        mesh.handle_message(message.clone()).await.unwrap();\n\n        // 同じメッセージは重複として検出される\n        assert!(mesh.is_duplicate(&message.id).await);\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = create_test_mesh();\n        let peer1 = vec![1; 32];\n        let peer2 = vec![2; 32];\n\n        // ピアの追加\n        mesh.update_peer_status(peer1.clone(), true).await;\n        mesh.update_peer_status(peer2.clone(), true).await;\n\n        let peers = mesh.get_peers().await;\n        assert_eq!(peers.len(), 2);\n        assert!(peers.contains(&peer1));\n        assert!(peers.contains(&peer2));\n\n        // ピアの削除\n        mesh.update_peer_status(peer1.clone(), false).await;\n\n        let peers = mesh.get_peers().await;\n        assert_eq!(peers.len(), 1);\n        assert!(!peers.contains(&peer1));\n        assert!(peers.contains(&peer2));\n    }\n\n    #[tokio::test]\n    async fn test_recent_messages() {\n        let mesh = create_test_mesh();\n\n        // 複数のメッセージを追加\n        for i in 0..5 {\n            let message = create_test_message(i);\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        // 最新のメッセージを取得\n        let recent = mesh.get_recent_messages(3).await;\n        assert_eq!(recent.len(), 3);\n\n        // タイムスタンプが降順であることを確認\n        for i in 0..recent.len() - 1 {\n            assert!(recent[i].timestamp >= recent[i + 1].timestamp);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_cache_clear() {\n        let mesh = create_test_mesh();\n\n        // メッセージを追加\n        for i in 0..3 {\n            let message = create_test_message(i);\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.message_count, 3);\n\n        // キャッシュをクリア\n        mesh.clear_cache().await;\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.message_count, 0);\n    }\n\n    #[tokio::test]\n    async fn test_cache_limit() {\n        let mesh = create_test_mesh();\n\n        // キャッシュ制限（1000）を超えるメッセージを追加しようとする\n        // 実際にはLRUキャッシュが古いメッセージを削除する\n        for i in 0..1100 {\n            let mut message = create_test_message((i % 256) as u8);\n            // より一意なIDを設定\n            message.id[0] = (i % 256) as u8;\n            message.id[1] = ((i >> 8) % 256) as u8;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        // キャッシュサイズは1000以下\n        assert!(stats.message_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_message_handling() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 10個の並行タスクでメッセージを送信\n        for i in 0..10 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..100 {\n                    let mut message = create_test_message((i * 100 + j) as u8);\n                    // より一意なメッセージIDを設定\n                    message.id[0] = ((i * 100 + j) % 256) as u8;\n                    message.id[1] = ((i * 100 + j) / 256) as u8;\n                    mesh_clone.handle_message(message).await.unwrap();\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 統計情報を確認\n        let stats = mesh.get_stats().await;\n        // 1000メッセージ送信したが、重複があるため実際のメッセージ数は少ない\n        assert!(stats.message_count > 0);\n        assert!(stats.message_count <= 1000); // キャッシュ制限を超えない\n        assert!(stats.peer_count > 0);\n        assert!(stats.peer_count <= 1000);\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_peer_updates() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n        let mut handles = vec![];\n\n        // 並行してピアの追加/削除を行う\n        for i in 0..5 {\n            let mesh_clone = mesh.clone();\n            let handle = task::spawn(async move {\n                for j in 0..20 {\n                    let peer = vec![(i * 20 + j) as u8; 32];\n                    mesh_clone.update_peer_status(peer.clone(), true).await;\n                    if j % 2 == 0 {\n                        mesh_clone.update_peer_status(peer, false).await;\n                    }\n                }\n            });\n            handles.push(handle);\n        }\n\n        // すべてのタスクが完了するのを待つ\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        // 最終的なピア数を確認\n        let peers = mesh.get_peers().await;\n        assert_eq!(peers.len(), 50); // 奇数番号のピアのみ残る\n    }\n\n    #[tokio::test]\n    async fn test_concurrent_cache_operations() {\n        use std::sync::Arc;\n        use tokio::task;\n\n        let mesh = Arc::new(create_test_mesh());\n\n        // メッセージ追加タスク\n        let mesh_add = mesh.clone();\n        let add_task = task::spawn(async move {\n            for i in 0..500 {\n                let message = create_test_message(i as u8);\n                mesh_add.handle_message(message).await.unwrap();\n                tokio::time::sleep(tokio::time::Duration::from_micros(100)).await;\n            }\n        });\n\n        // 統計情報取得タスク\n        let mesh_stats = mesh.clone();\n        let stats_task = task::spawn(async move {\n            let mut last_count = 0;\n            for _ in 0..50 {\n                let stats = mesh_stats.get_stats().await;\n                assert!(stats.message_count >= last_count); // 単調増加\n                last_count = stats.message_count;\n                tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n            }\n        });\n\n        // 最新メッセージ取得タスク\n        let mesh_recent = mesh.clone();\n        let recent_task = task::spawn(async move {\n            for _ in 0..30 {\n                let messages = mesh_recent.get_recent_messages(10).await;\n                assert!(messages.len() <= 10);\n                tokio::time::sleep(tokio::time::Duration::from_millis(8)).await;\n            }\n        });\n\n        // すべてのタスクが完了するのを待つ\n        add_task.await.unwrap();\n        stats_task.await.unwrap();\n        recent_task.await.unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","p2p","topic_mesh.rs"],"content":"use crate::domain::p2p::{\n    error::Result as P2PResult,\n    message::{GossipMessage, MessageId},\n};\nuse lru::LruCache;\nuse std::collections::HashSet;\nuse std::num::NonZeroUsize;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct TopicMesh {\n    #[allow(dead_code)]\n    topic_id: String,\n    // TODO: iroh-gossipのsubscription実装\n    peers: Arc<RwLock<HashSet<Vec<u8>>>>, // PublicKeyのバイト表現\n    message_cache: Arc<RwLock<LruCache<MessageId, GossipMessage>>>,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct TopicStats {\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\nimpl TopicMesh {\n    /// 新しいTopicMeshを作成\n    pub fn new(topic_id: String) -> Self {\n        let cache_size = NonZeroUsize::new(1000).unwrap(); // 最大1000メッセージをキャッシュ\n\n        Self {\n            topic_id,\n            peers: Arc::new(RwLock::new(HashSet::new())),\n            message_cache: Arc::new(RwLock::new(LruCache::new(cache_size))),\n        }\n    }\n\n    /// メッセージの受信処理\n    pub async fn handle_message(&self, message: GossipMessage) -> P2PResult<()> {\n        // 重複チェック\n        if self.is_duplicate(&message.id).await {\n            return Ok(()); // 重複メッセージは無視\n        }\n\n        // メッセージをキャッシュに追加\n        let mut cache = self.message_cache.write().await;\n        cache.put(message.id, message.clone());\n\n        // ピアリストに送信者を追加\n        let mut peers = self.peers.write().await;\n        peers.insert(message.sender.clone());\n\n        Ok(())\n    }\n\n    /// ピアの接続状態管理\n    pub async fn update_peer_status(&self, peer: Vec<u8>, connected: bool) {\n        let mut peers = self.peers.write().await;\n        if connected {\n            peers.insert(peer);\n        } else {\n            peers.remove(&peer);\n        }\n    }\n\n    /// メッセージの重複チェック\n    pub async fn is_duplicate(&self, message_id: &MessageId) -> bool {\n        let cache = self.message_cache.read().await;\n        cache.contains(message_id)\n    }\n\n    /// トピックの統計情報を取得\n    pub async fn get_stats(&self) -> TopicStats {\n        let peers = self.peers.read().await;\n        let cache = self.message_cache.read().await;\n\n        let last_activity = cache\n            .iter()\n            .map(|(_, msg)| msg.timestamp)\n            .max()\n            .unwrap_or(0);\n\n        TopicStats {\n            peer_count: peers.len(),\n            message_count: cache.len(),\n            last_activity,\n        }\n    }\n\n    /// 接続中のピアのリストを取得\n    #[allow(dead_code)]\n    pub async fn get_peers(&self) -> Vec<Vec<u8>> {\n        let peers = self.peers.read().await;\n        peers.iter().cloned().collect()\n    }\n\n    /// キャッシュされたメッセージを取得（最新順）\n    #[allow(dead_code)]\n    pub async fn get_recent_messages(&self, limit: usize) -> Vec<GossipMessage> {\n        let cache = self.message_cache.read().await;\n        let mut messages: Vec<_> = cache.iter().map(|(_, msg)| msg.clone()).collect();\n\n        messages.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));\n        messages.into_iter().take(limit).collect()\n    }\n\n    /// キャッシュをクリア\n    #[allow(dead_code)]\n    pub async fn clear_cache(&self) {\n        let mut cache = self.message_cache.write().await;\n        cache.clear();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::p2p::message::MessageType;\n\n    #[tokio::test]\n    async fn test_duplicate_detection() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let message = GossipMessage::new(\n            MessageType::TopicSync,\n            vec![1, 2, 3],\n            vec![0x02; 33], // 33バイトの公開鍵\n        );\n        let id = message.id;\n\n        mesh.handle_message(message.clone()).await.unwrap();\n        assert!(mesh.is_duplicate(&id).await);\n\n        // もう一度同じメッセージを処理\n        let result = mesh.handle_message(message).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_peer_management() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n        let peer = vec![0x02; 33];\n\n        mesh.update_peer_status(peer.clone(), true).await;\n        let peers = mesh.get_peers().await;\n        assert_eq!(peers.len(), 1);\n        assert_eq!(peers[0], peer);\n\n        mesh.update_peer_status(peer.clone(), false).await;\n        let peers = mesh.get_peers().await;\n        assert_eq!(peers.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_stats() {\n        let mesh = TopicMesh::new(\"test_topic\".to_string());\n\n        for i in 0..5 {\n            let mut message =\n                GossipMessage::new(MessageType::TopicSync, vec![i as u8], vec![0x02; 33]);\n            message.timestamp = i;\n            mesh.handle_message(message).await.unwrap();\n        }\n\n        let stats = mesh.get_stats().await;\n        assert_eq!(stats.peer_count, 1);\n        assert_eq!(stats.message_count, 5);\n        assert_eq!(stats.last_activity, 4);\n    }\n}\n","traces":[{"line":28,"address":[18128624,18129102],"length":1,"stats":{"Line":2}},{"line":29,"address":[18101910,18101993],"length":1,"stats":{"Line":4}},{"line":33,"address":[18102059,18102119],"length":1,"stats":{"Line":3}},{"line":34,"address":[15927990,15928031],"length":1,"stats":{"Line":5}},{"line":39,"address":[18102936,18103474,18103350,18102735,18102496,18102451,18102416,18102531],"length":1,"stats":{"Line":6}},{"line":41,"address":[18129498,18129595,18129433,18129704],"length":1,"stats":{"Line":4}},{"line":42,"address":[17572802],"length":1,"stats":{"Line":1}},{"line":46,"address":[17573083,17572380,17572845,17572770],"length":1,"stats":{"Line":4}},{"line":47,"address":[12888755,12888679],"length":1,"stats":{"Line":3}},{"line":50,"address":[18932203],"length":1,"stats":{"Line":5}},{"line":51,"address":[17573955,17573888],"length":1,"stats":{"Line":4}},{"line":53,"address":[12889376],"length":1,"stats":{"Line":4}},{"line":57,"address":[18105458,18104917,18104496,18104585,18104516,18104560,18104739],"length":1,"stats":{"Line":8}},{"line":58,"address":[11127457],"length":1,"stats":{"Line":4}},{"line":59,"address":[18105285,18105367,18105164],"length":1,"stats":{"Line":5}},{"line":60,"address":[15930924,15930837],"length":1,"stats":{"Line":4}},{"line":62,"address":[17574778,17574865],"length":1,"stats":{"Line":2}},{"line":67,"address":[18346368,18346524,18346701,18347093,18346561,18346381,18346425,18346400],"length":1,"stats":{"Line":6}},{"line":68,"address":[18132514,18132637,18132455,18132408],"length":1,"stats":{"Line":5}},{"line":69,"address":[18346955,18347022],"length":1,"stats":{"Line":3}},{"line":73,"address":[18106280,18106335,18106288,18107134,18106663,18106508,18106272,18106444],"length":1,"stats":{"Line":4}},{"line":74,"address":[10868959],"length":1,"stats":{"Line":2}},{"line":75,"address":[10895714],"length":1,"stats":{"Line":2}},{"line":77,"address":[12892354,12892427],"length":1,"stats":{"Line":3}},{"line":79,"address":[18134576,18134591],"length":1,"stats":{"Line":2}},{"line":84,"address":[17577185],"length":1,"stats":{"Line":4}},{"line":85,"address":[15933140],"length":1,"stats":{"Line":4}},{"line":92,"address":[18348720,18348704,18348712,18348841,18348878,18348755,18349502,18349018],"length":1,"stats":{"Line":4}},{"line":93,"address":[18107989,18108036,18108095,18108218],"length":1,"stats":{"Line":3}},{"line":94,"address":[15933982,15933920],"length":1,"stats":{"Line":3}},{"line":99,"address":[12893999,12893715,12894750,12893648,12893822,12893680,12893661,12893859],"length":1,"stats":{"Line":4}},{"line":100,"address":[12894031,12893802,12893849,12893908],"length":1,"stats":{"Line":2}},{"line":101,"address":[18109808,18109307,18109382,18109848],"length":1,"stats":{"Line":4}},{"line":103,"address":[18109872,18109541,18109904,18109463],"length":1,"stats":{"Line":6}},{"line":104,"address":[18350384],"length":1,"stats":{"Line":1}},{"line":109,"address":[12895566,12895060,12895200,12894896,12894937,12895023,12894904,12894912],"length":1,"stats":{"Line":4}},{"line":110,"address":[10300084],"length":1,"stats":{"Line":2}},{"line":111,"address":[15935822,15935876],"length":1,"stats":{"Line":2}}],"covered":38,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","repositories","mod.rs"],"content":"use crate::domain::entities::{Event, Post, Topic, User};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait PostRepository: Send + Sync {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError>;\n    async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: Option<u32>,\n        offset: Option<u32>,\n    ) -> Result<Vec<Post>, AppError>;\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: Option<u32>,\n        offset: Option<u32>,\n    ) -> Result<Vec<Post>, AppError>;\n    async fn update_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn delete_post(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError>;\n    async fn mark_post_synced(&self, id: &str) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait TopicRepository: Send + Sync {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn update_topic_stats(\n        &self,\n        topic_id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait UserRepository: Send + Sync {\n    async fn create_user(&self, user: &User) -> Result<(), AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError>;\n    async fn update_user(&self, user: &User) -> Result<(), AppError>;\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError>;\n    async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError>;\n}\n\n#[async_trait]\npub trait EventRepository: Send + Sync {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n    async fn get_events_by_kind(\n        &self,\n        kind: u32,\n        limit: Option<u32>,\n    ) -> Result<Vec<Event>, AppError>;\n    async fn get_events_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: Option<u32>,\n    ) -> Result<Vec<Event>, AppError>;\n    async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","bookmark_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Bookmark エンティティの識別子。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct BookmarkId(String);\n\nimpl BookmarkId {\n    /// 既存の識別子文字列から `BookmarkId` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"BookmarkId cannot be empty\".to_string());\n        }\n        uuid::Uuid::parse_str(&value).map_err(|err| format!(\"Invalid BookmarkId format: {err}\"))?;\n        Ok(Self(value))\n    }\n\n    /// 新規 BookmarkId を生成する。\n    pub fn random() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    /// 内部の文字列を参照する。\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for BookmarkId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<BookmarkId> for String {\n    fn from(value: BookmarkId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":10,"address":[15419717,15419184],"length":1,"stats":{"Line":1}},{"line":11,"address":[14137582,14137638],"length":1,"stats":{"Line":2}},{"line":12,"address":[13366829,13366434],"length":1,"stats":{"Line":0}},{"line":14,"address":[13366744,13366809,13366417,13366896,13366913,13366475],"length":1,"stats":{"Line":2}},{"line":15,"address":[13897011],"length":1,"stats":{"Line":1}},{"line":19,"address":[17268240],"length":1,"stats":{"Line":1}},{"line":20,"address":[17268253],"length":1,"stats":{"Line":1}},{"line":24,"address":[13367104],"length":1,"stats":{"Line":1}},{"line":25,"address":[14138341],"length":1,"stats":{"Line":1}},{"line":30,"address":[17268336],"length":1,"stats":{"Line":0}},{"line":31,"address":[13924280],"length":1,"stats":{"Line":0}},{"line":36,"address":[14810160],"length":1,"stats":{"Line":0}},{"line":37,"address":[14810163],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","bookmark","mod.rs"],"content":"pub mod bookmark_id;\n\npub use bookmark_id::BookmarkId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","mod.rs"],"content":"pub mod public_key;\npub mod reaction_value;\npub mod topic_content;\n\npub use public_key::PublicKey;\npub use reaction_value::ReactionValue;\npub use topic_content::TopicContent;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","public_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Nostr の公開鍵（hex 64文字）を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PublicKey(String);\n\nimpl PublicKey {\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    /// 64桁の16進文字列から `PublicKey` を生成する。\n    pub fn from_hex_str(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    /// 内部の16進文字列を参照で取得する。\n    pub fn as_hex(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.len() != 64 {\n            return Err(\"Public key must be 64 hex characters\".to_string());\n        }\n        if !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Public key must contain only hex characters\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for PublicKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<PublicKey> for String {\n    fn from(value: PublicKey) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for PublicKey {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::from_hex_str(value)\n    }\n}\n","traces":[{"line":10,"address":[18977296,18977675],"length":1,"stats":{"Line":0}},{"line":11,"address":[14101143,14101070,14101350],"length":1,"stats":{"Line":0}},{"line":12,"address":[18977473],"length":1,"stats":{"Line":0}},{"line":16,"address":[14101440],"length":1,"stats":{"Line":4}},{"line":17,"address":[14101656,14101483],"length":1,"stats":{"Line":4}},{"line":18,"address":[14101551],"length":1,"stats":{"Line":4}},{"line":22,"address":[15848016],"length":1,"stats":{"Line":2}},{"line":23,"address":[15633925],"length":1,"stats":{"Line":3}},{"line":26,"address":[15076800],"length":1,"stats":{"Line":4}},{"line":27,"address":[15076850],"length":1,"stats":{"Line":4}},{"line":28,"address":[15607303],"length":1,"stats":{"Line":0}},{"line":30,"address":[14101815,14102000,14102013],"length":1,"stats":{"Line":12}},{"line":31,"address":[15634095],"length":1,"stats":{"Line":0}},{"line":33,"address":[18978236],"length":1,"stats":{"Line":4}},{"line":38,"address":[18978304],"length":1,"stats":{"Line":0}},{"line":39,"address":[18978328],"length":1,"stats":{"Line":0}},{"line":44,"address":[11671216],"length":1,"stats":{"Line":0}},{"line":45,"address":[11885315],"length":1,"stats":{"Line":0}},{"line":52,"address":[14102144],"length":1,"stats":{"Line":0}},{"line":53,"address":[14102165],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","reaction_value.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// リアクション（例: 👍, ❤️）の値を表現する値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ReactionValue(String);\n\nimpl ReactionValue {\n    const MAX_LENGTH: usize = 20;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Reaction cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Reaction is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for ReactionValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<ReactionValue> for String {\n    fn from(value: ReactionValue) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for ReactionValue {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for ReactionValue {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[17873451,17873072],"length":1,"stats":{"Line":0}},{"line":12,"address":[17873102,17873175,17873382],"length":1,"stats":{"Line":0}},{"line":13,"address":[13972033],"length":1,"stats":{"Line":0}},{"line":16,"address":[14743504],"length":1,"stats":{"Line":0}},{"line":17,"address":[14743720,14743547],"length":1,"stats":{"Line":0}},{"line":18,"address":[14502783],"length":1,"stats":{"Line":0}},{"line":21,"address":[16603568],"length":1,"stats":{"Line":0}},{"line":22,"address":[14502965],"length":1,"stats":{"Line":0}},{"line":25,"address":[13972576],"length":1,"stats":{"Line":0}},{"line":26,"address":[16603641],"length":1,"stats":{"Line":0}},{"line":27,"address":[14503086],"length":1,"stats":{"Line":0}},{"line":29,"address":[14529798],"length":1,"stats":{"Line":0}},{"line":30,"address":[14744000],"length":1,"stats":{"Line":0}},{"line":35,"address":[13972750],"length":1,"stats":{"Line":0}},{"line":40,"address":[17874144],"length":1,"stats":{"Line":0}},{"line":41,"address":[17874168],"length":1,"stats":{"Line":0}},{"line":46,"address":[11644512],"length":1,"stats":{"Line":0}},{"line":47,"address":[11644515],"length":1,"stats":{"Line":0}},{"line":54,"address":[16604048],"length":1,"stats":{"Line":0}},{"line":55,"address":[14503461],"length":1,"stats":{"Line":0}},{"line":62,"address":[16604096],"length":1,"stats":{"Line":0}},{"line":63,"address":[16604117],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_gateway","topic_content.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// トピック投稿など、長文コンテンツを扱う値オブジェクト。\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TopicContent(String);\n\nimpl TopicContent {\n    const MAX_LENGTH: usize = 10_000;\n\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn into_string(self) -> String {\n        self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if value.chars().count() > Self::MAX_LENGTH {\n            return Err(format!(\n                \"Content is too long (max {} characters)\",\n                Self::MAX_LENGTH\n            ));\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for TopicContent {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicContent> for String {\n    fn from(value: TopicContent) -> Self {\n        value.0\n    }\n}\n\nimpl TryFrom<&str> for TopicContent {\n    type Error = String;\n\n    fn try_from(value: &str) -> Result<Self, Self::Error> {\n        Self::parse(value)\n    }\n}\n\nimpl FromStr for TopicContent {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":11,"address":[18587664,18588039],"length":1,"stats":{"Line":0}},{"line":12,"address":[18587694,18587767,18587974],"length":1,"stats":{"Line":0}},{"line":13,"address":[13197633],"length":1,"stats":{"Line":0}},{"line":16,"address":[18588064],"length":1,"stats":{"Line":0}},{"line":17,"address":[16328072,16327899],"length":1,"stats":{"Line":0}},{"line":18,"address":[16327967],"length":1,"stats":{"Line":0}},{"line":21,"address":[12426928],"length":1,"stats":{"Line":0}},{"line":22,"address":[12984069],"length":1,"stats":{"Line":0}},{"line":25,"address":[18588368],"length":1,"stats":{"Line":0}},{"line":26,"address":[12984083],"length":1,"stats":{"Line":0}},{"line":29,"address":[16328192],"length":1,"stats":{"Line":0}},{"line":30,"address":[16328249],"length":1,"stats":{"Line":0}},{"line":31,"address":[12984224],"length":1,"stats":{"Line":0}},{"line":33,"address":[12427062],"length":1,"stats":{"Line":0}},{"line":34,"address":[13198402],"length":1,"stats":{"Line":0}},{"line":39,"address":[12984288],"length":1,"stats":{"Line":0}},{"line":44,"address":[18588752],"length":1,"stats":{"Line":0}},{"line":45,"address":[12957752],"length":1,"stats":{"Line":0}},{"line":50,"address":[15015360],"length":1,"stats":{"Line":0}},{"line":51,"address":[11885379],"length":1,"stats":{"Line":0}},{"line":58,"address":[12984576],"length":1,"stats":{"Line":0}},{"line":59,"address":[12957861],"length":1,"stats":{"Line":0}},{"line":66,"address":[18588912],"length":1,"stats":{"Line":0}},{"line":67,"address":[18588933],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EventId(String);\n\nimpl EventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Event ID cannot be empty\".to_string());\n        }\n        // Validate hex format (64 characters)\n        if value.len() != 64 || !value.chars().all(|c| c.is_ascii_hexdigit()) {\n            return Err(\"Invalid event ID format: must be 64 hex characters\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        use sha2::{Digest, Sha256};\n        let random_bytes = uuid::Uuid::new_v4().as_bytes().to_vec();\n        let hash = Sha256::digest(&random_bytes);\n        Self(format!(\"{hash:x}\"))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn from_hex(hex: &str) -> Result<Self, String> {\n        Self::new(hex.to_string())\n    }\n\n    pub fn to_hex(&self) -> String {\n        self.0.clone()\n    }\n}\n\nimpl fmt::Display for EventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EventId> for String {\n    fn from(id: EventId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[18367207,18366672],"length":1,"stats":{"Line":1}},{"line":9,"address":[18589046,18588990],"length":1,"stats":{"Line":2}},{"line":10,"address":[18367171,18366781],"length":1,"stats":{"Line":0}},{"line":13,"address":[18589177,18589105,18589520,18589057,18589533],"length":1,"stats":{"Line":5}},{"line":14,"address":[18589133,18589394],"length":1,"stats":{"Line":0}},{"line":16,"address":[18589250],"length":1,"stats":{"Line":1}},{"line":19,"address":[15237594,15237280],"length":1,"stats":{"Line":1}},{"line":21,"address":[15023201],"length":1,"stats":{"Line":1}},{"line":22,"address":[14466126],"length":1,"stats":{"Line":1}},{"line":23,"address":[14466183],"length":1,"stats":{"Line":1}},{"line":26,"address":[14996784],"length":1,"stats":{"Line":1}},{"line":27,"address":[18589893],"length":1,"stats":{"Line":1}},{"line":30,"address":[15023536],"length":1,"stats":{"Line":1}},{"line":31,"address":[18367639],"length":1,"stats":{"Line":1}},{"line":34,"address":[18367680],"length":1,"stats":{"Line":1}},{"line":35,"address":[18367697],"length":1,"stats":{"Line":1}},{"line":40,"address":[15023648],"length":1,"stats":{"Line":0}},{"line":41,"address":[15237768],"length":1,"stats":{"Line":0}},{"line":46,"address":[14810288],"length":1,"stats":{"Line":0}},{"line":47,"address":[14810291],"length":1,"stats":{"Line":0}}],"covered":14,"coverable":20},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","mod.rs"],"content":"pub mod bookmark;\npub mod event_gateway;\npub mod event_id;\npub mod npub;\npub mod offline;\npub mod subscription;\npub mod topic_id;\n\npub use bookmark::BookmarkId;\npub use event_gateway::{PublicKey, ReactionValue, TopicContent};\npub use event_id::EventId;\npub use npub::Npub;\npub use offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\npub use subscription::{\n    RESYNC_BACKOFF_SECS, SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\npub use topic_id::TopicId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","npub.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Npub(String);\n\nimpl Npub {\n    pub fn new(value: String) -> Result<Self, String> {\n        if !value.starts_with(\"npub1\") {\n            return Err(\"Invalid npub format: must start with 'npub1'\".to_string());\n        }\n        if value.len() != 63 {\n            return Err(\"Invalid npub format: incorrect length\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn to_pubkey(&self) -> Result<String, String> {\n        // This would normally use bech32 decoding\n        // For now, return a placeholder\n        Ok(format!(\"pubkey_from_{}\", self.0))\n    }\n}\n\nimpl fmt::Display for Npub {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<Npub> for String {\n    fn from(npub: Npub) -> Self {\n        npub.0\n    }\n}\n","traces":[{"line":8,"address":[16329201,16328752],"length":1,"stats":{"Line":0}},{"line":9,"address":[12957966,12958034],"length":1,"stats":{"Line":0}},{"line":10,"address":[11319592,11319543],"length":1,"stats":{"Line":0}},{"line":12,"address":[12427774,12427704],"length":1,"stats":{"Line":0}},{"line":13,"address":[12985082,12985036],"length":1,"stats":{"Line":0}},{"line":15,"address":[12958190],"length":1,"stats":{"Line":0}},{"line":18,"address":[11319888],"length":1,"stats":{"Line":0}},{"line":19,"address":[12428021],"length":1,"stats":{"Line":0}},{"line":22,"address":[12428032],"length":1,"stats":{"Line":0}},{"line":25,"address":[12958456],"length":1,"stats":{"Line":0}},{"line":30,"address":[11320080],"length":1,"stats":{"Line":0}},{"line":31,"address":[11320104],"length":1,"stats":{"Line":0}},{"line":36,"address":[14810320],"length":1,"stats":{"Line":0}},{"line":37,"address":[14810323],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{fmt, str::FromStr};\n\n/// アプリケーションが参照するオフラインアクションの識別子（`local_id` 相当）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionId(String);\n\nimpl OfflineActionId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn parse(value: &str) -> Result<Self, String> {\n        Self::validate(value)?;\n        Ok(Self(value.to_string()))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionId> for String {\n    fn from(id: OfflineActionId) -> Self {\n        id.0\n    }\n}\n\nimpl FromStr for OfflineActionId {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        Self::parse(s)\n    }\n}\n","traces":[{"line":9,"address":[11591520,11591899],"length":1,"stats":{"Line":0}},{"line":10,"address":[12122023,12121950,12122230],"length":1,"stats":{"Line":0}},{"line":11,"address":[15492913],"length":1,"stats":{"Line":0}},{"line":14,"address":[13495728],"length":1,"stats":{"Line":5}},{"line":15,"address":[12149115,12149288],"length":1,"stats":{"Line":5}},{"line":16,"address":[12149183],"length":1,"stats":{"Line":5}},{"line":19,"address":[12149360],"length":1,"stats":{"Line":0}},{"line":20,"address":[12363461],"length":1,"stats":{"Line":0}},{"line":23,"address":[13496032],"length":1,"stats":{"Line":5}},{"line":24,"address":[12122688],"length":1,"stats":{"Line":5}},{"line":25,"address":[13496120],"length":1,"stats":{"Line":0}},{"line":27,"address":[12122713],"length":1,"stats":{"Line":5}},{"line":32,"address":[12363632],"length":1,"stats":{"Line":1}},{"line":33,"address":[12122824],"length":1,"stats":{"Line":1}},{"line":38,"address":[11885472],"length":1,"stats":{"Line":0}},{"line":39,"address":[15015459],"length":1,"stats":{"Line":0}},{"line":46,"address":[13496304],"length":1,"stats":{"Line":0}},{"line":47,"address":[13496325],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","action_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// オフラインアクションの種類（例: `publish_text_note`、`send_reaction`）。\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OfflineActionType(String);\n\nimpl OfflineActionType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Offline action type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OfflineActionType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OfflineActionType> for String {\n    fn from(kind: OfflineActionType) -> Self {\n        kind.0\n    }\n}\n","traces":[{"line":9,"address":[18590503,18590128],"length":1,"stats":{"Line":4}},{"line":10,"address":[16998086,16997806,16997879],"length":1,"stats":{"Line":8}},{"line":11,"address":[16226721],"length":1,"stats":{"Line":4}},{"line":14,"address":[16226960],"length":1,"stats":{"Line":2}},{"line":15,"address":[16757365],"length":1,"stats":{"Line":3}},{"line":18,"address":[11542336],"length":1,"stats":{"Line":4}},{"line":19,"address":[11542384],"length":1,"stats":{"Line":4}},{"line":20,"address":[16227064],"length":1,"stats":{"Line":0}},{"line":22,"address":[16998281],"length":1,"stats":{"Line":4}},{"line":27,"address":[11542496],"length":1,"stats":{"Line":0}},{"line":28,"address":[16784296],"length":1,"stats":{"Line":0}},{"line":33,"address":[14810384],"length":1,"stats":{"Line":0}},{"line":34,"address":[14810387],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_key.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheKey(String);\n\nimpl CacheKey {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache key cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheKey> for String {\n    fn from(key: CacheKey) -> Self {\n        key.0\n    }\n}\n","traces":[{"line":8,"address":[15936311,15935936],"length":1,"stats":{"Line":2}},{"line":9,"address":[19438846,19439126,19438919],"length":1,"stats":{"Line":4}},{"line":10,"address":[18667761],"length":1,"stats":{"Line":2}},{"line":13,"address":[18668000],"length":1,"stats":{"Line":2}},{"line":14,"address":[19198405],"length":1,"stats":{"Line":2}},{"line":17,"address":[13983376],"length":1,"stats":{"Line":2}},{"line":18,"address":[13983424],"length":1,"stats":{"Line":2}},{"line":19,"address":[18668104],"length":1,"stats":{"Line":0}},{"line":21,"address":[19439321],"length":1,"stats":{"Line":2}},{"line":26,"address":[13983536],"length":1,"stats":{"Line":0}},{"line":27,"address":[19225336],"length":1,"stats":{"Line":0}},{"line":32,"address":[14810416],"length":1,"stats":{"Line":0}},{"line":33,"address":[14810419],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","cache_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CacheType(String);\n\nimpl CacheType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Cache type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for CacheType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<CacheType> for String {\n    fn from(value: CacheType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[15420455,15420080],"length":1,"stats":{"Line":2}},{"line":9,"address":[16998510,16998790,16998583],"length":1,"stats":{"Line":4}},{"line":10,"address":[16227425],"length":1,"stats":{"Line":2}},{"line":13,"address":[16227664],"length":1,"stats":{"Line":2}},{"line":14,"address":[16758069],"length":1,"stats":{"Line":2}},{"line":17,"address":[11543040],"length":1,"stats":{"Line":2}},{"line":18,"address":[11543088],"length":1,"stats":{"Line":2}},{"line":19,"address":[16227768],"length":1,"stats":{"Line":0}},{"line":21,"address":[16998985],"length":1,"stats":{"Line":2}},{"line":26,"address":[11543200],"length":1,"stats":{"Line":0}},{"line":27,"address":[16785000],"length":1,"stats":{"Line":0}},{"line":32,"address":[14810448],"length":1,"stats":{"Line":0}},{"line":33,"address":[14810451],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityId(String);\n\nimpl EntityId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityId> for String {\n    fn from(value: EntityId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[17702199,17701824],"length":1,"stats":{"Line":4}},{"line":9,"address":[18351766,18351559,18351486],"length":1,"stats":{"Line":8}},{"line":10,"address":[17580401],"length":1,"stats":{"Line":4}},{"line":13,"address":[17580640],"length":1,"stats":{"Line":2}},{"line":14,"address":[18111045],"length":1,"stats":{"Line":2}},{"line":17,"address":[12896016],"length":1,"stats":{"Line":4}},{"line":18,"address":[12896064],"length":1,"stats":{"Line":4}},{"line":19,"address":[17580744],"length":1,"stats":{"Line":0}},{"line":21,"address":[18351961],"length":1,"stats":{"Line":4}},{"line":26,"address":[12896176],"length":1,"stats":{"Line":4}},{"line":27,"address":[18137976],"length":1,"stats":{"Line":4}},{"line":32,"address":[14810480],"length":1,"stats":{"Line":0}},{"line":33,"address":[14810483],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","entity_type.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EntityType(String);\n\nimpl EntityType {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Entity type cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for EntityType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<EntityType> for String {\n    fn from(value: EntityType) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[14810887,14810512],"length":1,"stats":{"Line":4}},{"line":9,"address":[18352470,18352190,18352263],"length":1,"stats":{"Line":8}},{"line":10,"address":[17581105],"length":1,"stats":{"Line":4}},{"line":13,"address":[17581344],"length":1,"stats":{"Line":2}},{"line":14,"address":[18111749],"length":1,"stats":{"Line":2}},{"line":17,"address":[12896720],"length":1,"stats":{"Line":4}},{"line":18,"address":[12896768],"length":1,"stats":{"Line":4}},{"line":19,"address":[17581448],"length":1,"stats":{"Line":0}},{"line":21,"address":[18352665],"length":1,"stats":{"Line":4}},{"line":26,"address":[12896880],"length":1,"stats":{"Line":3}},{"line":27,"address":[18138680],"length":1,"stats":{"Line":3}},{"line":32,"address":[14811200],"length":1,"stats":{"Line":0}},{"line":33,"address":[14811203],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","mod.rs"],"content":"pub mod action_id;\npub mod action_type;\npub mod cache_key;\npub mod cache_type;\npub mod entity_id;\npub mod entity_type;\npub mod optimistic_update_id;\npub mod payload;\npub mod remote_event_id;\npub mod sync_queue_id;\npub mod sync_queue_status;\npub mod sync_status;\n\npub use action_id::OfflineActionId;\npub use action_type::OfflineActionType;\npub use cache_key::CacheKey;\npub use cache_type::CacheType;\npub use entity_id::EntityId;\npub use entity_type::EntityType;\npub use optimistic_update_id::OptimisticUpdateId;\npub use payload::OfflinePayload;\npub use remote_event_id::RemoteEventId;\npub use sync_queue_id::SyncQueueId;\npub use sync_queue_status::SyncQueueStatus;\npub use sync_status::SyncStatus;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","optimistic_update_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OptimisticUpdateId(String);\n\nimpl OptimisticUpdateId {\n    pub fn new(value: String) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    fn validate(value: &str) -> Result<(), String> {\n        if value.trim().is_empty() {\n            return Err(\"Optimistic update ID cannot be empty\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Display for OptimisticUpdateId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<OptimisticUpdateId> for String {\n    fn from(value: OptimisticUpdateId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[13028727,13028352],"length":1,"stats":{"Line":1}},{"line":9,"address":[13594375,13594302,13594582],"length":1,"stats":{"Line":2}},{"line":10,"address":[12823217],"length":1,"stats":{"Line":1}},{"line":13,"address":[12823456],"length":1,"stats":{"Line":1}},{"line":14,"address":[13353861],"length":1,"stats":{"Line":1}},{"line":17,"address":[16724688],"length":1,"stats":{"Line":1}},{"line":18,"address":[16724736],"length":1,"stats":{"Line":1}},{"line":19,"address":[12823560],"length":1,"stats":{"Line":0}},{"line":21,"address":[13594777],"length":1,"stats":{"Line":1}},{"line":26,"address":[16724848],"length":1,"stats":{"Line":0}},{"line":27,"address":[13380792],"length":1,"stats":{"Line":0}},{"line":32,"address":[14811232],"length":1,"stats":{"Line":0}},{"line":33,"address":[14811235],"length":1,"stats":{"Line":0}}],"covered":8,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","payload.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct OfflinePayload(Value);\n\nimpl OfflinePayload {\n    pub fn new(value: Value) -> Result<Self, String> {\n        Self::validate(&value)?;\n        Ok(Self(value))\n    }\n\n    pub fn from_json_str(json: &str) -> Result<Self, String> {\n        let value: Value =\n            serde_json::from_str(json).map_err(|e| format!(\"Invalid JSON payload: {e}\"))?;\n        Self::new(value)\n    }\n\n    pub fn as_json(&self) -> &Value {\n        &self.0\n    }\n\n    pub fn into_inner(self) -> Value {\n        self.0\n    }\n\n    fn validate(value: &Value) -> Result<(), String> {\n        if value.is_null() {\n            return Err(\"Offline payload cannot be null\".to_string());\n        }\n        Ok(())\n    }\n}\n\nimpl From<OfflinePayload> for Value {\n    fn from(payload: OfflinePayload) -> Self {\n        payload.0\n    }\n}\n","traces":[{"line":8,"address":[18590816,18591176],"length":1,"stats":{"Line":4}},{"line":9,"address":[15023835,15024055,15023787],"length":1,"stats":{"Line":8}},{"line":10,"address":[18590958],"length":1,"stats":{"Line":4}},{"line":13,"address":[18591574,18591200,18591545],"length":1,"stats":{"Line":4}},{"line":14,"address":[18368661,18368640,18368280,18368466],"length":1,"stats":{"Line":4}},{"line":16,"address":[18368409],"length":1,"stats":{"Line":4}},{"line":19,"address":[14467632],"length":1,"stats":{"Line":3}},{"line":23,"address":[18591808],"length":1,"stats":{"Line":3}},{"line":24,"address":[15238883],"length":1,"stats":{"Line":3}},{"line":27,"address":[15238928],"length":1,"stats":{"Line":4}},{"line":28,"address":[18368942],"length":1,"stats":{"Line":4}},{"line":29,"address":[15238988],"length":1,"stats":{"Line":0}},{"line":31,"address":[15024877],"length":1,"stats":{"Line":4}},{"line":36,"address":[13496352],"length":1,"stats":{"Line":0}},{"line":37,"address":[13496355],"length":1,"stats":{"Line":0}}],"covered":12,"coverable":15},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","remote_event_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RemoteEventId(String);\n\nimpl RemoteEventId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.trim().is_empty() {\n            return Err(\"Remote event ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl fmt::Display for RemoteEventId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<RemoteEventId> for String {\n    fn from(value: RemoteEventId) -> Self {\n        value.0\n    }\n}\n","traces":[{"line":8,"address":[11644864,11645211],"length":1,"stats":{"Line":0}},{"line":9,"address":[19824990,19825058],"length":1,"stats":{"Line":0}},{"line":10,"address":[11885950,11886001],"length":1,"stats":{"Line":0}},{"line":12,"address":[11885852],"length":1,"stats":{"Line":0}},{"line":15,"address":[11671984],"length":1,"stats":{"Line":0}},{"line":16,"address":[11645253],"length":1,"stats":{"Line":0}},{"line":21,"address":[11672000],"length":1,"stats":{"Line":0}},{"line":22,"address":[11645288],"length":1,"stats":{"Line":0}},{"line":27,"address":[14811264],"length":1,"stats":{"Line":0}},{"line":28,"address":[14811267],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct SyncQueueId(i64);\n\nimpl SyncQueueId {\n    pub fn new(value: i64) -> Result<Self, String> {\n        if value <= 0 {\n            return Err(\"Sync queue id must be positive\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn value(&self) -> i64 {\n        self.0\n    }\n}\n\nimpl fmt::Display for SyncQueueId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<SyncQueueId> for i64 {\n    fn from(id: SyncQueueId) -> Self {\n        id.0\n    }\n}\n","traces":[{"line":8,"address":[17515600],"length":1,"stats":{"Line":2}},{"line":9,"address":[12300583],"length":1,"stats":{"Line":3}},{"line":10,"address":[16985257],"length":1,"stats":{"Line":0}},{"line":12,"address":[17515638],"length":1,"stats":{"Line":3}},{"line":15,"address":[12300688],"length":1,"stats":{"Line":0}},{"line":16,"address":[17756565],"length":1,"stats":{"Line":0}},{"line":21,"address":[17542480],"length":1,"stats":{"Line":0}},{"line":22,"address":[18326968],"length":1,"stats":{"Line":0}},{"line":27,"address":[18327056],"length":1,"stats":{"Line":0}}],"covered":3,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_queue_status.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncQueueStatus {\n    Pending,\n    Processing,\n    Failed,\n    Completed,\n    Unknown(String),\n}\n\nimpl SyncQueueStatus {\n    pub fn as_str(&self) -> &str {\n        match self {\n            SyncQueueStatus::Pending => \"pending\",\n            SyncQueueStatus::Processing => \"processing\",\n            SyncQueueStatus::Failed => \"failed\",\n            SyncQueueStatus::Completed => \"completed\",\n            SyncQueueStatus::Unknown(value) => value.as_str(),\n        }\n    }\n}\n\nimpl From<&str> for SyncQueueStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncQueueStatus::Pending,\n            \"processing\" => SyncQueueStatus::Processing,\n            \"failed\" => SyncQueueStatus::Failed,\n            \"completed\" => SyncQueueStatus::Completed,\n            other => SyncQueueStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":13,"address":[11731328],"length":1,"stats":{"Line":0}},{"line":14,"address":[13595215,13595038],"length":1,"stats":{"Line":0}},{"line":15,"address":[12823866],"length":1,"stats":{"Line":0}},{"line":16,"address":[12823889],"length":1,"stats":{"Line":0}},{"line":17,"address":[13354312],"length":1,"stats":{"Line":0}},{"line":18,"address":[16725151],"length":1,"stats":{"Line":0}},{"line":19,"address":[16725179],"length":1,"stats":{"Line":0}},{"line":25,"address":[12824000],"length":1,"stats":{"Line":2}},{"line":27,"address":[13595280,13595338],"length":1,"stats":{"Line":4}},{"line":28,"address":[16725377,16725294],"length":1,"stats":{"Line":0}},{"line":29,"address":[13381349,13381269],"length":1,"stats":{"Line":0}},{"line":30,"address":[11731822,11731721],"length":1,"stats":{"Line":0}},{"line":31,"address":[11731773],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","offline","sync_status.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum SyncStatus {\n    Pending,\n    SentToNostr,\n    SentToP2P,\n    FullySynced,\n    Failed,\n    Conflict,\n    Unknown(String),\n}\n\nimpl SyncStatus {\n    pub fn as_str(&self) -> &str {\n        match self {\n            SyncStatus::Pending => \"pending\",\n            SyncStatus::SentToNostr => \"sent_to_nostr\",\n            SyncStatus::SentToP2P => \"sent_to_p2p\",\n            SyncStatus::FullySynced => \"fully_synced\",\n            SyncStatus::Failed => \"failed\",\n            SyncStatus::Conflict => \"conflict\",\n            SyncStatus::Unknown(value) => value.as_str(),\n        }\n    }\n\n    pub fn is_terminal(&self) -> bool {\n        matches!(\n            self,\n            SyncStatus::FullySynced | SyncStatus::Failed | SyncStatus::Conflict\n        )\n    }\n}\n\nimpl fmt::Display for SyncStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl From<&str> for SyncStatus {\n    fn from(value: &str) -> Self {\n        match value {\n            \"pending\" => SyncStatus::Pending,\n            \"sent_to_nostr\" => SyncStatus::SentToNostr,\n            \"sent_to_p2p\" => SyncStatus::SentToP2P,\n            \"fully_synced\" => SyncStatus::FullySynced,\n            \"failed\" => SyncStatus::Failed,\n            \"conflict\" => SyncStatus::Conflict,\n            other => SyncStatus::Unknown(other.to_string()),\n        }\n    }\n}\n","traces":[{"line":16,"address":[18978464],"length":1,"stats":{"Line":2}},{"line":17,"address":[18978704,18978478],"length":1,"stats":{"Line":4}},{"line":18,"address":[15077322],"length":1,"stats":{"Line":2}},{"line":19,"address":[15848580],"length":1,"stats":{"Line":0}},{"line":20,"address":[15848603],"length":1,"stats":{"Line":0}},{"line":21,"address":[15607794],"length":1,"stats":{"Line":0}},{"line":22,"address":[18327241],"length":1,"stats":{"Line":0}},{"line":23,"address":[15607840],"length":1,"stats":{"Line":0}},{"line":24,"address":[15077468],"length":1,"stats":{"Line":1}},{"line":28,"address":[18327328],"length":1,"stats":{"Line":0}},{"line":29,"address":[15607941],"length":1,"stats":{"Line":0}},{"line":30,"address":[15634645],"length":1,"stats":{"Line":0}},{"line":37,"address":[15848816],"length":1,"stats":{"Line":0}},{"line":38,"address":[15077602],"length":1,"stats":{"Line":0}},{"line":43,"address":[18978928],"length":1,"stats":{"Line":2}},{"line":45,"address":[18978976,18979034],"length":1,"stats":{"Line":4}},{"line":46,"address":[15608190,15608273],"length":1,"stats":{"Line":1}},{"line":47,"address":[15608245,15608328],"length":1,"stats":{"Line":1}},{"line":48,"address":[18327724,18327807],"length":1,"stats":{"Line":1}},{"line":49,"address":[15608435,15608355],"length":1,"stats":{"Line":1}},{"line":50,"address":[18327932,18327831],"length":1,"stats":{"Line":1}},{"line":51,"address":[18327883],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","subscription.rs"],"content":"use crate::shared::error::AppError;\nuse nostr_sdk::prelude::Timestamp;\nuse std::str::FromStr;\n\npub const RESYNC_BACKOFF_SECS: i64 = 300;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum SubscriptionTarget {\n    Topic(String),\n    User(String),\n}\n\nimpl SubscriptionTarget {\n    pub fn as_parts(&self) -> (&str, &str) {\n        match self {\n            SubscriptionTarget::Topic(id) => (\"topic\", id.as_str()),\n            SubscriptionTarget::User(id) => (\"user\", id.as_str()),\n        }\n    }\n\n    pub fn from_parts(target_type: &str, target: String) -> Result<Self, AppError> {\n        match target_type {\n            \"topic\" => Ok(SubscriptionTarget::Topic(target)),\n            \"user\" => Ok(SubscriptionTarget::User(target)),\n            other => Err(AppError::ValidationError(format!(\n                \"Unknown subscription target type: {other}\"\n            ))),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SubscriptionStatus {\n    Pending,\n    Subscribed,\n    NeedsResync,\n}\n\nimpl SubscriptionStatus {\n    pub fn as_str(&self) -> &'static str {\n        match self {\n            SubscriptionStatus::Pending => \"pending\",\n            SubscriptionStatus::Subscribed => \"subscribed\",\n            SubscriptionStatus::NeedsResync => \"needs_resync\",\n        }\n    }\n\n    pub fn parse(value: &str) -> Result<Self, AppError> {\n        match value {\n            \"pending\" => Ok(SubscriptionStatus::Pending),\n            \"subscribed\" => Ok(SubscriptionStatus::Subscribed),\n            \"needs_resync\" => Ok(SubscriptionStatus::NeedsResync),\n            other => Err(AppError::ValidationError(format!(\n                \"Unknown subscription status: {other}\"\n            ))),\n        }\n    }\n}\n\nimpl FromStr for SubscriptionStatus {\n    type Err = AppError;\n\n    fn from_str(value: &str) -> Result<Self, Self::Err> {\n        Self::parse(value)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SubscriptionRecord {\n    pub target: SubscriptionTarget,\n    pub status: SubscriptionStatus,\n    pub last_synced_at: Option<i64>,\n    pub last_attempt_at: Option<i64>,\n    pub failure_count: i64,\n    pub error_message: Option<String>,\n}\n\nimpl SubscriptionRecord {\n    pub fn new(target: SubscriptionTarget) -> Self {\n        Self {\n            target,\n            status: SubscriptionStatus::Pending,\n            last_synced_at: None,\n            last_attempt_at: None,\n            failure_count: 0,\n            error_message: None,\n        }\n    }\n\n    pub fn mark_requested(&mut self, attempt_ts: i64) {\n        self.status = SubscriptionStatus::Pending;\n        self.last_attempt_at = Some(attempt_ts);\n        self.error_message = None;\n    }\n\n    pub fn mark_subscribed(&mut self, synced_at: i64) {\n        self.status = SubscriptionStatus::Subscribed;\n        self.last_synced_at = Some(synced_at);\n        self.failure_count = 0;\n        self.error_message = None;\n    }\n\n    pub fn mark_failure(&mut self, attempt_ts: i64, error_message: impl Into<String>) {\n        self.status = SubscriptionStatus::NeedsResync;\n        self.last_attempt_at = Some(attempt_ts);\n        self.failure_count += 1;\n        self.error_message = Some(error_message.into());\n    }\n\n    pub fn since_timestamp(&self) -> Option<Timestamp> {\n        let last_synced = self.last_synced_at?;\n        let adjusted = last_synced.saturating_sub(RESYNC_BACKOFF_SECS);\n        Some(Timestamp::from(adjusted as u64))\n    }\n}\n","traces":[{"line":14,"address":[18668288],"length":1,"stats":{"Line":3}},{"line":15,"address":[19198712],"length":1,"stats":{"Line":3}},{"line":16,"address":[13496435],"length":1,"stats":{"Line":3}},{"line":17,"address":[19439610],"length":1,"stats":{"Line":1}},{"line":21,"address":[19226394,19225584],"length":1,"stats":{"Line":3}},{"line":22,"address":[19439744],"length":1,"stats":{"Line":3}},{"line":23,"address":[18668648,18668528,18668596],"length":1,"stats":{"Line":6}},{"line":24,"address":[18668612,18668845,18668773],"length":1,"stats":{"Line":3}},{"line":25,"address":[19199189,19199402],"length":1,"stats":{"Line":0}},{"line":40,"address":[18669280],"length":1,"stats":{"Line":1}},{"line":41,"address":[13984645],"length":1,"stats":{"Line":2}},{"line":42,"address":[13984677],"length":1,"stats":{"Line":1}},{"line":43,"address":[18669340],"length":1,"stats":{"Line":1}},{"line":44,"address":[13984723],"length":1,"stats":{"Line":1}},{"line":48,"address":[19226544],"length":1,"stats":{"Line":1}},{"line":50,"address":[19226659,19226601],"length":1,"stats":{"Line":3}},{"line":51,"address":[19440727,19440820],"length":1,"stats":{"Line":2}},{"line":52,"address":[13984916,13985191],"length":1,"stats":{"Line":2}},{"line":53,"address":[18669621],"length":1,"stats":{"Line":0}},{"line":63,"address":[19441104],"length":1,"stats":{"Line":0}},{"line":64,"address":[13985253],"length":1,"stats":{"Line":0}},{"line":79,"address":[13498032],"length":1,"stats":{"Line":1}},{"line":90,"address":[19200480,19200594],"length":1,"stats":{"Line":1}},{"line":91,"address":[19200498],"length":1,"stats":{"Line":2}},{"line":92,"address":[19441342],"length":1,"stats":{"Line":1}},{"line":93,"address":[13985584,13985512],"length":1,"stats":{"Line":3}},{"line":96,"address":[19200778,19200656],"length":1,"stats":{"Line":1}},{"line":97,"address":[19200674],"length":1,"stats":{"Line":1}},{"line":98,"address":[19227422],"length":1,"stats":{"Line":1}},{"line":99,"address":[19227454],"length":1,"stats":{"Line":1}},{"line":100,"address":[18670408,18670336],"length":1,"stats":{"Line":2}},{"line":103,"address":[19200848,19201216],"length":1,"stats":{"Line":1}},{"line":104,"address":[18670499],"length":1,"stats":{"Line":1}},{"line":105,"address":[13498633],"length":1,"stats":{"Line":1}},{"line":106,"address":[19441854,19441785],"length":1,"stats":{"Line":1}},{"line":107,"address":[19441826,19441917],"length":1,"stats":{"Line":2}},{"line":110,"address":[19201232],"length":1,"stats":{"Line":0}},{"line":111,"address":[19442158,19442076],"length":1,"stats":{"Line":0}},{"line":112,"address":[13498998],"length":1,"stats":{"Line":0}},{"line":113,"address":[13499016],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":40},{"path":["/","app","kukuri-tauri","src-tauri","src","domain","value_objects","topic_id.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct TopicId(String);\n\nimpl TopicId {\n    pub fn new(value: String) -> Result<Self, String> {\n        if value.is_empty() {\n            return Err(\"Topic ID cannot be empty\".to_string());\n        }\n        Ok(Self(value))\n    }\n\n    pub fn generate() -> Self {\n        Self(uuid::Uuid::new_v4().to_string())\n    }\n\n    pub fn public() -> Self {\n        Self(\"public\".to_string())\n    }\n\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    pub fn is_public(&self) -> bool {\n        self.0 == \"public\"\n    }\n}\n\nimpl fmt::Display for TopicId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl From<TopicId> for String {\n    fn from(id: TopicId) -> Self {\n        id.0\n    }\n}\n\nimpl Default for TopicId {\n    fn default() -> Self {\n        Self::public()\n    }\n}\n","traces":[{"line":8,"address":[18671230,18670960],"length":1,"stats":{"Line":0}},{"line":9,"address":[19201434,19201385],"length":1,"stats":{"Line":0}},{"line":10,"address":[13986501,13986548],"length":1,"stats":{"Line":0}},{"line":12,"address":[18592073],"length":1,"stats":{"Line":0}},{"line":15,"address":[19228400],"length":1,"stats":{"Line":0}},{"line":16,"address":[19228413],"length":1,"stats":{"Line":0}},{"line":19,"address":[19228480],"length":1,"stats":{"Line":0}},{"line":20,"address":[19442589],"length":1,"stats":{"Line":0}},{"line":23,"address":[18592448],"length":1,"stats":{"Line":0}},{"line":24,"address":[19201829],"length":1,"stats":{"Line":0}},{"line":27,"address":[18592464],"length":1,"stats":{"Line":0}},{"line":28,"address":[19201845],"length":1,"stats":{"Line":0}},{"line":33,"address":[19442704],"length":1,"stats":{"Line":0}},{"line":34,"address":[19201896],"length":1,"stats":{"Line":0}},{"line":39,"address":[11886240],"length":1,"stats":{"Line":0}},{"line":40,"address":[15016227],"length":1,"stats":{"Line":0}},{"line":45,"address":[18592608],"length":1,"stats":{"Line":0}},{"line":46,"address":[18592616],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","memory_cache.rs"],"content":"use std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse std::time::{Duration, Instant};\r\nuse tokio::sync::RwLock;\r\n\r\n#[derive(Clone)]\r\nstruct CacheEntry<T> {\r\n    data: T,\r\n    expires_at: Instant,\r\n}\r\n\r\n/// メモリキャッシュサービス\r\npub struct MemoryCacheService<T: Clone> {\r\n    cache: Arc<RwLock<HashMap<String, CacheEntry<T>>>>,\r\n    default_ttl: Duration,\r\n}\r\n\r\nimpl<T> MemoryCacheService<T>\r\nwhere\r\n    T: Clone + Send + Sync + 'static,\r\n{\r\n    /// 新しいキャッシュサービスを作成\r\n    pub fn new(default_ttl_seconds: u64) -> Self {\r\n        Self {\r\n            cache: Arc::new(RwLock::new(HashMap::new())),\r\n            default_ttl: Duration::from_secs(default_ttl_seconds),\r\n        }\r\n    }\r\n\r\n    /// キャッシュにデータを保存\r\n    pub async fn set(&self, key: String, value: T) {\r\n        self.set_with_ttl(key, value, self.default_ttl).await;\r\n    }\r\n\r\n    /// 指定したTTLでキャッシュに保存\r\n    pub async fn set_with_ttl(&self, key: String, value: T, ttl: Duration) {\r\n        let entry = CacheEntry {\r\n            data: value,\r\n            expires_at: Instant::now() + ttl,\r\n        };\r\n\r\n        let mut cache = self.cache.write().await;\r\n        cache.insert(key, entry);\r\n    }\r\n\r\n    /// キャッシュからデータを取得\r\n    pub async fn get(&self, key: &str) -> Option<T> {\r\n        let cache = self.cache.read().await;\r\n\r\n        if let Some(entry) = cache.get(key) {\r\n            if entry.expires_at > Instant::now() {\r\n                return Some(entry.data.clone());\r\n            }\r\n        }\r\n\r\n        None\r\n    }\r\n\r\n    /// 複数のキーからデータを取得\r\n    pub async fn get_many(&self, keys: &[String]) -> HashMap<String, T> {\r\n        let cache = self.cache.read().await;\r\n        let now = Instant::now();\r\n\r\n        let mut results = HashMap::new();\r\n        for key in keys {\r\n            if let Some(entry) = cache.get(key) {\r\n                if entry.expires_at > now {\r\n                    results.insert(key.clone(), entry.data.clone());\r\n                }\r\n            }\r\n        }\r\n\r\n        results\r\n    }\r\n\r\n    /// キャッシュから削除\r\n    pub async fn delete(&self, key: &str) {\r\n        let mut cache = self.cache.write().await;\r\n        cache.remove(key);\r\n    }\r\n\r\n    /// パターンにマッチするキーを削除\r\n    pub async fn delete_pattern(&self, pattern: &str) {\r\n        let mut cache = self.cache.write().await;\r\n        let keys_to_remove: Vec<String> = cache\r\n            .keys()\r\n            .filter(|k| k.contains(pattern))\r\n            .cloned()\r\n            .collect();\r\n\r\n        for key in keys_to_remove {\r\n            cache.remove(&key);\r\n        }\r\n    }\r\n\r\n    /// キャッシュをクリア\r\n    pub async fn clear(&self) {\r\n        let mut cache = self.cache.write().await;\r\n        cache.clear();\r\n    }\r\n\r\n    /// 期限切れのエントリを削除\r\n    pub async fn cleanup_expired(&self) {\r\n        let mut cache = self.cache.write().await;\r\n        let now = Instant::now();\r\n\r\n        cache.retain(|_, entry| entry.expires_at > now);\r\n    }\r\n\r\n    /// キャッシュサイズを取得\r\n    pub async fn size(&self) -> usize {\r\n        let cache = self.cache.read().await;\r\n        cache.len()\r\n    }\r\n}\r\n\r\n// 投稿用の特殊化されたキャッシュサービス\r\npub struct PostCacheService {\r\n    cache: MemoryCacheService<crate::domain::entities::post::Post>,\r\n}\r\n\r\nimpl PostCacheService {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            // 投稿は5分間キャッシュ\r\n            cache: MemoryCacheService::new(300),\r\n        }\r\n    }\r\n\r\n    pub async fn cache_post(&self, post: crate::domain::entities::post::Post) {\r\n        let key = format!(\"post:{}\", post.id);\r\n        self.cache.set(key, post).await;\r\n    }\r\n\r\n    pub async fn get_post(&self, post_id: &str) -> Option<crate::domain::entities::post::Post> {\r\n        let key = format!(\"post:{post_id}\");\r\n        self.cache.get(&key).await\r\n    }\r\n\r\n    pub async fn cache_posts_by_topic(\r\n        &self,\r\n        _topic_id: &str,\r\n        posts: Vec<crate::domain::entities::post::Post>,\r\n    ) {\r\n        // トピック別の投稿は短めのTTLを想定して個別キャッシュのみ更新\r\n        for post in posts {\r\n            self.cache_post(post).await;\r\n        }\r\n    }\r\n\r\n    pub async fn invalidate_topic_posts(&self, topic_id: &str) {\r\n        let pattern = format!(\"topic_posts:{topic_id}\");\r\n        self.cache.delete_pattern(&pattern).await;\r\n    }\r\n\r\n    pub async fn invalidate_post(&self, post_id: &str) {\r\n        let key = format!(\"post:{post_id}\");\r\n        self.cache.delete(&key).await;\r\n    }\r\n}\r\n\r\n// ユーザー用のキャッシュサービス\r\npub struct UserCacheService {\r\n    cache: MemoryCacheService<crate::domain::entities::user::User>,\r\n}\r\n\r\nimpl UserCacheService {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            // ユーザー情報は10分間キャッシュ\r\n            cache: MemoryCacheService::new(600),\r\n        }\r\n    }\r\n\r\n    pub async fn cache_user(&self, user: crate::domain::entities::user::User) {\r\n        let key = format!(\"user:{}\", user.pubkey);\r\n        self.cache.set(key, user).await;\r\n    }\r\n\r\n    pub async fn get_user(&self, pubkey: &str) -> Option<crate::domain::entities::user::User> {\r\n        let key = format!(\"user:{pubkey}\");\r\n        self.cache.get(&key).await\r\n    }\r\n\r\n    pub async fn invalidate_user(&self, pubkey: &str) {\r\n        let key = format!(\"user:{pubkey}\");\r\n        self.cache.delete(&key).await;\r\n    }\r\n}\r\n\r\n// トピック用のキャッシュサービス\r\npub struct TopicCacheService {\r\n    cache: MemoryCacheService<crate::domain::entities::topic::Topic>,\r\n}\r\n\r\nimpl TopicCacheService {\r\n    pub fn new() -> Self {\r\n        Self {\r\n            // トピック情報は30分間キャッシュ\r\n            cache: MemoryCacheService::new(1800),\r\n        }\r\n    }\r\n\r\n    pub async fn cache_topic(&self, topic: crate::domain::entities::topic::Topic) {\r\n        let key = format!(\"topic:{}\", topic.id);\r\n        self.cache.set(key, topic).await;\r\n    }\r\n\r\n    pub async fn get_topic(&self, topic_id: &str) -> Option<crate::domain::entities::topic::Topic> {\r\n        let key = format!(\"topic:{topic_id}\");\r\n        self.cache.get(&key).await\r\n    }\r\n\r\n    pub async fn cache_all_topics(&self, topics: Vec<crate::domain::entities::topic::Topic>) {\r\n        for topic in topics {\r\n            self.cache_topic(topic).await;\r\n        }\r\n    }\r\n\r\n    pub async fn invalidate_topic(&self, topic_id: &str) {\r\n        let key = format!(\"topic:{topic_id}\");\r\n        self.cache.delete(&key).await;\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[13973389,13973165,13973613],"length":1,"stats":{"Line":0}},{"line":26,"address":[14744922,14744698,14744474],"length":1,"stats":{"Line":0}},{"line":31,"address":[14532521,14531873,14532257,14532733,14531888,14530979,14531168,14531280,14531480,14532088,14532125,14531913,14530944,14531203,14532496,14531649,14532696,14532865,14531091,14531056,14531517,14531305,14533089,14532481],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[14536907,14533841,14533963,14535313,14536785,14535435],"length":1,"stats":{"Line":0}},{"line":42,"address":[17878221,17879693,17881096,17878416,17879440,17879888,17877968,17880912,17881165,17878152,17879624,17881360],"length":1,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[14753462,14752552,14753592,14753400,14752360,14752317,14754397,14754632,14753357,14754440,14752422,14754502],"length":1,"stats":{"Line":0}},{"line":50,"address":[17884861,17883894,17882781,17884934,17883821,17882854],"length":1,"stats":{"Line":0}},{"line":51,"address":[17883031,17883986,17885026,17884071,17885111,17882946],"length":1,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[13981771,13982811,13983851],"length":1,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[14542408,14541312,14543000,14543144,14542264,14541264,14542121,14543556,14541216,14542963,14542857,14541528,14541330,14541282,14541385,14541234,14542084,14542096,14542227,14542820,14541360,14542832,14541491,14541672],"length":1,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[17715134,17714392,17713704,17713758,17714446,17715080],"length":1,"stats":{"Line":0}},{"line":83,"address":[14517048,14517192,14517011,14516850,14518046,14516905,14516832,14516880],"length":1,"stats":{"Line":0}},{"line":84,"address":[17715434,17715504,17715608,17715395],"length":1,"stats":{"Line":0}},{"line":85,"address":[14544175,14544242,14544270],"length":1,"stats":{"Line":0}},{"line":87,"address":[14544818,14544800,14544261],"length":1,"stats":{"Line":0}},{"line":91,"address":[14544513,14544351,14544567],"length":1,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[14518128],"length":1,"stats":{"Line":0}},{"line":126,"address":[14544877],"length":1,"stats":{"Line":0}},{"line":130,"address":[17889631,17889024,17889867,17889129,17889888,17889059,17889104,17889291],"length":1,"stats":{"Line":0}},{"line":131,"address":[14518560,14518444],"length":1,"stats":{"Line":0}},{"line":132,"address":[14545583,14545238,14545381],"length":1,"stats":{"Line":0}},{"line":135,"address":[17889936,17890182,17890142,17890805,17890019,17889984,17890501,17889954],"length":1,"stats":{"Line":0}},{"line":136,"address":[14760130,14760245],"length":1,"stats":{"Line":0}},{"line":137,"address":[13989102,13988953,13989188,13989317],"length":1,"stats":{"Line":0}},{"line":140,"address":[14520000],"length":1,"stats":{"Line":0}},{"line":146,"address":[17718945,17718629,17718535,17718997],"length":1,"stats":{"Line":0}},{"line":147,"address":[14761101,14761264,14761598,14761657],"length":1,"stats":{"Line":0}},{"line":151,"address":[17719712,17719186,17719364,17719938,17719241,17719404,17719216,17719168],"length":1,"stats":{"Line":0}},{"line":152,"address":[14521064,14521179],"length":1,"stats":{"Line":0}},{"line":153,"address":[13990868,13991084,13990719,13990954],"length":1,"stats":{"Line":0}},{"line":156,"address":[14549242,14548448,14548684,14548644,14548466,14548496,14548521,14549004],"length":1,"stats":{"Line":0}},{"line":157,"address":[17720120,17720235],"length":1,"stats":{"Line":0}},{"line":158,"address":[14522084,14521935,14522300,14522170],"length":1,"stats":{"Line":0}},{"line":168,"address":[14522528],"length":1,"stats":{"Line":0}},{"line":171,"address":[14522541],"length":1,"stats":{"Line":0}},{"line":175,"address":[14522713,14523451,14522688,14523215,14523472,14522643,14522875,14522608],"length":1,"stats":{"Line":0}},{"line":176,"address":[14763676,14763792],"length":1,"stats":{"Line":0}},{"line":177,"address":[14523045,14523247,14522902],"length":1,"stats":{"Line":0}},{"line":180,"address":[17721760,17721712,17721730,17721795,17722265,17721918,17721958,17722557],"length":1,"stats":{"Line":0}},{"line":181,"address":[14764645,14764530],"length":1,"stats":{"Line":0}},{"line":182,"address":[14764820,14764585,14764734,14764949],"length":1,"stats":{"Line":0}},{"line":185,"address":[14524400,14524596,14524956,14524448,14525194,14524418,14524473,14524636],"length":1,"stats":{"Line":0}},{"line":186,"address":[17895384,17895499],"length":1,"stats":{"Line":0}},{"line":187,"address":[14765604,14765690,14765455,14765820],"length":1,"stats":{"Line":0}},{"line":197,"address":[17723360],"length":1,"stats":{"Line":0}},{"line":200,"address":[14766061],"length":1,"stats":{"Line":0}},{"line":204,"address":[17723545,17724035,17723440,17723520,17723707,17724259,17723475,17724280],"length":1,"stats":{"Line":0}},{"line":205,"address":[17896464,17896348],"length":1,"stats":{"Line":0}},{"line":206,"address":[11194132],"length":1,"stats":{"Line":0}},{"line":209,"address":[17897893,17897072,17897042,17897270,17897230,17897589,17897024,17897107],"length":1,"stats":{"Line":0}},{"line":210,"address":[14767218,14767333],"length":1,"stats":{"Line":0}},{"line":211,"address":[14526676,14526441,14526805,14526590],"length":1,"stats":{"Line":0}},{"line":214,"address":[14767928,14767993,14768102,14768744,14767968,14768260,14767920,14768142],"length":1,"stats":{"Line":0}},{"line":215,"address":[17898173,17898065,17898513,17898569],"length":1,"stats":{"Line":0}},{"line":216,"address":[14554527,14554196,14554586,14554033],"length":1,"stats":{"Line":0}},{"line":220,"address":[14527954,14528009,14527936,14527984,14528132,14528730,14528172,14528492],"length":1,"stats":{"Line":0}},{"line":221,"address":[17726168,17726283],"length":1,"stats":{"Line":0}},{"line":222,"address":[17726466,17726576,17726372,17726223],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":85},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","mod.rs"],"content":"pub mod memory_cache;\r\npub mod post_cache;\r\n\r\npub use post_cache::PostCacheService;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","cache","post_cache.rs"],"content":"use crate::domain::entities::Post;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// 投稿キャッシュサービス\n#[derive(Clone)]\npub struct PostCacheService {\n    cache: Arc<RwLock<HashMap<String, Post>>>,\n}\n\nimpl PostCacheService {\n    pub fn new() -> Self {\n        Self {\n            cache: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// 投稿をキャッシュに追加\n    pub async fn add(&self, post: Post) {\n        let mut cache = self.cache.write().await;\n        cache.insert(post.id.clone(), post);\n    }\n\n    /// 複数の投稿をキャッシュに追加\n    pub async fn add_many(&self, posts: Vec<Post>) {\n        let mut cache = self.cache.write().await;\n        for post in posts {\n            cache.insert(post.id.clone(), post);\n        }\n    }\n\n    /// IDで投稿を取得\n    pub async fn get(&self, id: &str) -> Option<Post> {\n        let cache = self.cache.read().await;\n        cache.get(id).cloned()\n    }\n\n    /// 複数のIDで投稿を取得\n    pub async fn get_many(&self, ids: &[String]) -> Vec<Post> {\n        let cache = self.cache.read().await;\n        ids.iter().filter_map(|id| cache.get(id).cloned()).collect()\n    }\n\n    /// トピックIDで投稿を取得\n    pub async fn get_by_topic(&self, topic_id: &str) -> Vec<Post> {\n        let cache = self.cache.read().await;\n        cache\n            .values()\n            .filter(|post| post.topic_id == topic_id)\n            .cloned()\n            .collect()\n    }\n\n    /// 投稿を削除\n    pub async fn remove(&self, id: &str) -> Option<Post> {\n        let mut cache = self.cache.write().await;\n        cache.remove(id)\n    }\n\n    /// キャッシュをクリア\n    pub async fn clear(&self) {\n        let mut cache = self.cache.write().await;\n        cache.clear();\n    }\n\n    /// キャッシュサイズを取得\n    pub async fn size(&self) -> usize {\n        let cache = self.cache.read().await;\n        cache.len()\n    }\n}\n\nimpl Default for PostCacheService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_post(id: &str, topic_id: &str) -> Post {\n        use crate::domain::entities::user::User;\n\n        let author = User {\n            npub: \"npub1test\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: \"Test User\".to_string(),\n                bio: \"Test bio\".to_string(),\n                avatar_url: None,\n            },\n            name: Some(\"Test User\".to_string()),\n            nip05: None,\n            lud16: None,\n            created_at: chrono::Utc::now(),\n            updated_at: chrono::Utc::now(),\n        };\n\n        Post {\n            id: id.to_string(),\n            content: \"Test content\".to_string(),\n            author,\n            topic_id: topic_id.to_string(),\n            created_at: chrono::Utc::now(),\n            tags: Vec::new(),\n            likes: 0,\n            boosts: 0,\n            replies: Vec::new(),\n            is_synced: true,\n            is_boosted: false,\n            is_bookmarked: false,\n            local_id: None,\n            event_id: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_add_and_get() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\");\n\n        cache.add(post.clone()).await;\n        let retrieved = cache.get(\"1\").await;\n\n        assert!(retrieved.is_some());\n        assert_eq!(retrieved.unwrap().id, \"1\");\n    }\n\n    #[tokio::test]\n    async fn test_add_many() {\n        let cache = PostCacheService::new();\n        let posts = vec![\n            create_test_post(\"1\", \"topic1\"),\n            create_test_post(\"2\", \"topic1\"),\n            create_test_post(\"3\", \"topic2\"),\n        ];\n\n        cache.add_many(posts).await;\n        assert_eq!(cache.size().await, 3);\n    }\n\n    #[tokio::test]\n    async fn test_get_by_topic() {\n        let cache = PostCacheService::new();\n        let posts = vec![\n            create_test_post(\"1\", \"topic1\"),\n            create_test_post(\"2\", \"topic1\"),\n            create_test_post(\"3\", \"topic2\"),\n        ];\n\n        cache.add_many(posts).await;\n        let topic1_posts = cache.get_by_topic(\"topic1\").await;\n\n        assert_eq!(topic1_posts.len(), 2);\n        assert!(topic1_posts.iter().all(|p| p.topic_id == \"topic1\"));\n    }\n\n    #[tokio::test]\n    async fn test_remove() {\n        let cache = PostCacheService::new();\n        let post = create_test_post(\"1\", \"topic1\");\n\n        cache.add(post.clone()).await;\n        let removed = cache.remove(\"1\").await;\n\n        assert!(removed.is_some());\n        assert_eq!(removed.unwrap().id, \"1\");\n        assert!(cache.get(\"1\").await.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_clear() {\n        let cache = PostCacheService::new();\n        let posts = vec![\n            create_test_post(\"1\", \"topic1\"),\n            create_test_post(\"2\", \"topic1\"),\n            create_test_post(\"3\", \"topic2\"),\n        ];\n\n        cache.add_many(posts).await;\n        assert_eq!(cache.size().await, 3);\n\n        cache.clear().await;\n        assert_eq!(cache.size().await, 0);\n    }\n}\n","traces":[{"line":13,"address":[16758352],"length":1,"stats":{"Line":1}},{"line":15,"address":[16227959],"length":1,"stats":{"Line":1}},{"line":20,"address":[16759391,16758673,16758451,16759370,16758858,16758521,16758496,16758416],"length":1,"stats":{"Line":4}},{"line":21,"address":[14263569],"length":1,"stats":{"Line":2}},{"line":22,"address":[11544071,11544133],"length":1,"stats":{"Line":2}},{"line":26,"address":[16787460,16786387,16786184,16786249,16787439,16786176,16786566,16786224],"length":1,"stats":{"Line":7}},{"line":27,"address":[11544822,11544638,11544698,11544595],"length":1,"stats":{"Line":4}},{"line":28,"address":[16786813,16787111,16787402,16786922,16787057],"length":1,"stats":{"Line":10}},{"line":29,"address":[16230013,16230134],"length":1,"stats":{"Line":4}},{"line":34,"address":[11546114,11545744,11545827,11545970,11545762,11546567,11545792,11545933],"length":1,"stats":{"Line":4}},{"line":35,"address":[14263799],"length":1,"stats":{"Line":2}},{"line":36,"address":[16788161,16788228],"length":1,"stats":{"Line":2}},{"line":40,"address":[16788722,16788352,16788370,16788435,16789210,16788400,16788541,16788578],"length":1,"stats":{"Line":0}},{"line":41,"address":[11546749,11546978,11546854,11546792],"length":1,"stats":{"Line":0}},{"line":42,"address":[16788993,16789078,16789232,16789260],"length":1,"stats":{"Line":0}},{"line":46,"address":[16762946,16762624,16762576,16762765,16762594,16762802,16762659,16763472],"length":1,"stats":{"Line":4}},{"line":47,"address":[16232349,16232454,16232392,16232578],"length":1,"stats":{"Line":2}},{"line":48,"address":[16232817,16232882,16232910],"length":1,"stats":{"Line":3}},{"line":50,"address":[16790037,16790241,16790224],"length":1,"stats":{"Line":3}},{"line":56,"address":[17004557,17004451,17004386,17004594,17005158,17004416,17004368,17004738],"length":1,"stats":{"Line":4}},{"line":57,"address":[11325277,11325316,11325386,11325490],"length":1,"stats":{"Line":2}},{"line":58,"address":[16764165,16764230],"length":1,"stats":{"Line":2}},{"line":62,"address":[16765003,16764344,16764496,16764377,16764336,16764637,16764352,16764459],"length":1,"stats":{"Line":4}},{"line":63,"address":[16791179,16791405,16791222,16791281],"length":1,"stats":{"Line":2}},{"line":64,"address":[11549841,11549908],"length":1,"stats":{"Line":2}},{"line":68,"address":[11326528,11326631,11326520,11326668,11326512,11326553,11326797,11327178],"length":1,"stats":{"Line":8}},{"line":69,"address":[11550091,11550317,11550193,11550134],"length":1,"stats":{"Line":3}},{"line":70,"address":[16765589,16765656],"length":1,"stats":{"Line":2}},{"line":75,"address":[11327200],"length":1,"stats":{"Line":0}},{"line":76,"address":[11327201],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":30},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_encryption_service.rs"],"content":"use super::encryption_service::EncryptionService;\nuse crate::shared::error::AppError;\nuse aes_gcm::{\n    Aes256Gcm, Key, Nonce,\n    aead::{Aead, AeadCore, KeyInit, OsRng},\n};\nuse async_trait::async_trait;\nuse base64::{Engine as _, engine::general_purpose};\nuse sha2::{Digest, Sha256};\nuse std::str;\n\nconst NONCE_SIZE: usize = 12;\n\npub struct DefaultEncryptionService;\n\nimpl DefaultEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn derive_key(password: &str) -> Key<Aes256Gcm> {\n        let mut hasher = Sha256::new();\n        hasher.update(password.as_bytes());\n        let result = hasher.finalize();\n        let mut key = Key::<Aes256Gcm>::default();\n        key.copy_from_slice(&result);\n        key\n    }\n\n    fn encrypt_internal(plaintext: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n        let ciphertext = cipher\n            .encrypt(&nonce, plaintext)\n            .map_err(|err| AppError::Crypto(format!(\"Encryption failed: {err}\")))?;\n\n        let mut combined = nonce.to_vec();\n        combined.extend_from_slice(&ciphertext);\n\n        Ok(general_purpose::STANDARD.encode(combined).into_bytes())\n    }\n\n    fn decrypt_internal(encrypted_data: &[u8], password: &str) -> Result<Vec<u8>, AppError> {\n        let encoded = str::from_utf8(encrypted_data)\n            .map_err(|err| AppError::Crypto(format!(\"Invalid encrypted payload: {err}\")))?;\n        let combined = general_purpose::STANDARD\n            .decode(encoded)\n            .map_err(|err| AppError::Crypto(format!(\"Base64 decode failed: {err}\")))?;\n\n        if combined.len() < NONCE_SIZE {\n            return Err(AppError::Crypto(\n                \"Encrypted data is shorter than nonce size\".to_string(),\n            ));\n        }\n\n        let (nonce_bytes, ciphertext) = combined.split_at(NONCE_SIZE);\n        let mut nonce = Nonce::default();\n        nonce.copy_from_slice(nonce_bytes);\n\n        let key = Self::derive_key(password);\n        let cipher = Aes256Gcm::new(&key);\n\n        cipher\n            .decrypt(&nonce, ciphertext)\n            .map_err(|err| AppError::Crypto(format!(\"Decryption failed: {err}\")))\n    }\n}\n\n#[async_trait]\nimpl EncryptionService for DefaultEncryptionService {\n    async fn encrypt(\n        &self,\n        _data: &[u8],\n        _recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric encryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn decrypt(\n        &self,\n        _encrypted_data: &[u8],\n        _sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Err(Box::new(AppError::NotImplemented(\n            \"Asymmetric decryption is not implemented\".to_string(),\n        )))\n    }\n\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::encrypt_internal(data, password).map_err(|err| Box::new(err) as _)\n    }\n\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        Self::decrypt_internal(encrypted_data, password).map_err(|err| Box::new(err) as _)\n    }\n}\n","traces":[{"line":21,"address":[12428336],"length":1,"stats":{"Line":0}},{"line":22,"address":[12428378],"length":1,"stats":{"Line":0}},{"line":23,"address":[12958798],"length":1,"stats":{"Line":0}},{"line":24,"address":[16604239],"length":1,"stats":{"Line":0}},{"line":25,"address":[16329678],"length":1,"stats":{"Line":0}},{"line":26,"address":[13199708],"length":1,"stats":{"Line":0}},{"line":27,"address":[13199792],"length":1,"stats":{"Line":0}},{"line":30,"address":[12428624,12429502,12429527],"length":1,"stats":{"Line":0}},{"line":31,"address":[13199941],"length":1,"stats":{"Line":0}},{"line":32,"address":[16329953],"length":1,"stats":{"Line":0}},{"line":33,"address":[16604590],"length":1,"stats":{"Line":0}},{"line":34,"address":[12986216,12985971],"length":1,"stats":{"Line":0}},{"line":36,"address":[16605345,16605328,16604844],"length":1,"stats":{"Line":0}},{"line":38,"address":[12959414,12959563],"length":1,"stats":{"Line":0}},{"line":39,"address":[12959590,12959667],"length":1,"stats":{"Line":0}},{"line":41,"address":[16330509],"length":1,"stats":{"Line":0}},{"line":44,"address":[13200976,13202185,13202045],"length":1,"stats":{"Line":0}},{"line":45,"address":[12429803,12430063],"length":1,"stats":{"Line":0}},{"line":46,"address":[12430008,12430992,12430976],"length":1,"stats":{"Line":0}},{"line":47,"address":[16605665,16605843,16606003],"length":1,"stats":{"Line":0}},{"line":49,"address":[16331401,16332368,16332384],"length":1,"stats":{"Line":0}},{"line":51,"address":[12987289,12987460],"length":1,"stats":{"Line":0}},{"line":52,"address":[12987963],"length":1,"stats":{"Line":0}},{"line":53,"address":[12987495],"length":1,"stats":{"Line":0}},{"line":57,"address":[12960803,12960730],"length":1,"stats":{"Line":0}},{"line":58,"address":[12987654],"length":1,"stats":{"Line":0}},{"line":59,"address":[16331753],"length":1,"stats":{"Line":0}},{"line":61,"address":[16606365],"length":1,"stats":{"Line":0}},{"line":62,"address":[16331843],"length":1,"stats":{"Line":0}},{"line":64,"address":[13201896,13201980],"length":1,"stats":{"Line":0}},{"line":66,"address":[13202577,13202560],"length":1,"stats":{"Line":0}},{"line":77,"address":[13025159],"length":1,"stats":{"Line":0}},{"line":78,"address":[16797204],"length":1,"stats":{"Line":0}},{"line":87,"address":[12999047],"length":1,"stats":{"Line":0}},{"line":88,"address":[16369832],"length":1,"stats":{"Line":0}},{"line":97,"address":[16798577,16798436,16798576],"length":1,"stats":{"Line":0}},{"line":105,"address":[16799012,16799153,16799152],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","default_signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::infrastructure::crypto::signature_service::SignatureService;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::*;\n\n/// デフォルトの署名サービス実装\npub struct DefaultSignatureService;\n\nimpl DefaultSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl Default for DefaultSignatureService {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SignatureService for DefaultSignatureService {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // Nostr SDKを使用してイベントに署名\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // イベントIDを計算\n        let tags: Vec<nostr_sdk::Tag> = event\n            .tags\n            .clone()\n            .into_iter()\n            .map(|t| {\n                // Convert Vec<String> to Tag\n                if !t.is_empty() {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(t[0].as_str()), t[1..].to_vec())\n                } else {\n                    nostr_sdk::Tag::custom(nostr_sdk::TagKind::from(\"\"), Vec::<String>::new())\n                }\n            })\n            .collect();\n\n        let mut event_builder =\n            nostr_sdk::EventBuilder::new(Kind::from(event.kind as u16), event.content.clone());\n        for tag in tags {\n            event_builder = event_builder.tag(tag);\n        }\n\n        // 署名を生成\n        let signed_event = event_builder.sign_with_keys(&keys)?;\n        event.sig = signed_event.sig.to_string();\n        event.id = signed_event.id.to_hex();\n\n        Ok(())\n    }\n\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // イベントの署名を検証\n        let _public_key = PublicKey::from_hex(&event.pubkey)?;\n\n        // Nostrイベントを再構築\n        let nostr_event = nostr_sdk::Event::from_json(serde_json::to_string(event)?)?;\n\n        // 署名を検証\n        Ok(nostr_event.verify().is_ok())\n    }\n\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n        let secret_key = SecretKey::from_hex(private_key)?;\n        let keys = Keys::new(secret_key);\n\n        // Create a simple text note event and sign it\n        let event = EventBuilder::text_note(message).sign_with_keys(&keys)?;\n\n        // Return the signature\n        Ok(event.sig.to_string())\n    }\n\n    async fn verify_message(\n        &self,\n        _message: &str,\n        _signature: &str,\n        _public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        // For now, we'll use the Nostr event verification approach\n        // In a real implementation, you'd need to reconstruct the event with the signature\n        // and verify it properly\n\n        // This is a simplified version - you may need to store more context\n        // to properly verify standalone signatures\n        Ok(true) // Placeholder implementation\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_sign_and_verify_message() {\n        let service = DefaultSignatureService::new();\n        let keys = Keys::generate();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let public_key = keys.public_key().to_string();\n\n        let message = \"Test message\";\n        let signature = service.sign_message(message, &private_key).await.unwrap();\n\n        let is_valid = service\n            .verify_message(message, &signature, &public_key)\n            .await\n            .unwrap();\n        assert!(is_valid);\n    }\n}\n","traces":[{"line":16,"address":[15936640],"length":1,"stats":{"Line":0}},{"line":17,"address":[15936641],"length":1,"stats":{"Line":0}},{"line":29,"address":[18954617,18952647,18952403,18952463],"length":1,"stats":{"Line":0}},{"line":30,"address":[16008836],"length":1,"stats":{"Line":0}},{"line":33,"address":[13496871,13496959],"length":1,"stats":{"Line":0}},{"line":37,"address":[13499362,13498800,13499220],"length":1,"stats":{"Line":0}},{"line":39,"address":[18183478,18183554,18183978],"length":1,"stats":{"Line":0}},{"line":40,"address":[18740761,18740977,18740701],"length":1,"stats":{"Line":0}},{"line":42,"address":[16011333,16011064,16011447],"length":1,"stats":{"Line":0}},{"line":47,"address":[18738824,18738929],"length":1,"stats":{"Line":0}},{"line":49,"address":[13497569,13497479,13497344,13497236,13498664],"length":1,"stats":{"Line":0}},{"line":50,"address":[13498630,13497576],"length":1,"stats":{"Line":0}},{"line":54,"address":[18739811,18740342,18739498],"length":1,"stats":{"Line":0}},{"line":55,"address":[18182645,18182805],"length":1,"stats":{"Line":0}},{"line":56,"address":[18954163],"length":1,"stats":{"Line":0}},{"line":58,"address":[18740213],"length":1,"stats":{"Line":0}},{"line":66,"address":[16011979,16011819,16012707],"length":1,"stats":{"Line":0}},{"line":69,"address":[18714984,18715681,18715307,18714903],"length":1,"stats":{"Line":0}},{"line":72,"address":[13500380,13500448,13500260],"length":1,"stats":{"Line":0}},{"line":80,"address":[18957008,18957252,18957926,18957068],"length":1,"stats":{"Line":2}},{"line":81,"address":[18743093],"length":1,"stats":{"Line":1}},{"line":84,"address":[18716514,18716611,18716780],"length":1,"stats":{"Line":2}},{"line":87,"address":[16013746,16013898],"length":1,"stats":{"Line":2}},{"line":102,"address":[16014465],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":24},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","encryption_service.rs"],"content":"use async_trait::async_trait;\n\n#[async_trait]\npub trait EncryptionService: Send + Sync {\n    async fn encrypt(\n        &self,\n        data: &[u8],\n        recipient_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt(\n        &self,\n        encrypted_data: &[u8],\n        sender_pubkey: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn encrypt_symmetric(\n        &self,\n        data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn decrypt_symmetric(\n        &self,\n        encrypted_data: &[u8],\n        password: &str,\n    ) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","key_manager.rs"],"content":"use crate::application::ports::key_manager::{KeyManager, KeyPair};\nuse crate::shared::error::AppError;\nuse anyhow::{Result, anyhow};\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::*;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// デフォルトのKeyManager実装\n#[derive(Clone)]\npub struct DefaultKeyManager {\n    inner: Arc<RwLock<KeyManagerInner>>,\n}\n\nstruct KeyManagerInner {\n    keys: Option<Keys>,\n    stored_keys: HashMap<String, KeyPair>,\n}\n\nimpl DefaultKeyManager {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(KeyManagerInner {\n                keys: None,\n                stored_keys: std::collections::HashMap::new(),\n            })),\n        }\n    }\n\n    /// 旧インターフェース用: 新しいキーペアを生成（タプル形式）\n    pub async fn generate(&self) -> Result<(String, String, String)> {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_hex();\n        let secret_key = keys.secret_key().to_bech32()?;\n        let npub = keys.public_key().to_bech32()?;\n\n        // Save generated keys\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, secret_key, npub))\n    }\n\n    /// 旧インターフェース用: nsecでログイン\n    pub async fn login(&self, nsec: &str) -> Result<(String, String)> {\n        let secret_key = SecretKey::from_bech32(nsec)?;\n        let keys = Keys::new(secret_key);\n\n        let public_key = keys.public_key().to_hex();\n        let npub = keys.public_key().to_bech32()?;\n\n        // Save keys\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n\n        Ok((public_key, npub))\n    }\n\n    /// 旧インターフェース用: ログアウト\n    pub async fn logout(&self) -> Result<()> {\n        let mut inner = self.inner.write().await;\n        inner.keys = None;\n        Ok(())\n    }\n\n    /// 旧インターフェース用: 現在の鍵を取得\n    pub async fn get_keys(&self) -> Result<Keys> {\n        let inner = self.inner.read().await;\n        inner.keys.clone().ok_or_else(|| anyhow!(\"No keys loaded\"))\n    }\n}\n\nimpl Default for DefaultKeyManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl KeyManager for DefaultKeyManager {\n    async fn generate_keypair(&self) -> Result<KeyPair, AppError> {\n        let keys = Keys::generate();\n        let public_key = keys.public_key().to_hex();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let npub = keys\n            .public_key()\n            .to_bech32()\n            .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n        let nsec = keys\n            .secret_key()\n            .to_bech32()\n            .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n\n        let keypair = KeyPair {\n            public_key,\n            private_key,\n            npub: npub.clone(),\n            nsec,\n        };\n\n        // Store in memory\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n        inner.stored_keys.insert(npub, keypair.clone());\n\n        Ok(keypair)\n    }\n\n    async fn import_private_key(&self, nsec: &str) -> Result<KeyPair, AppError> {\n        let secret_key = SecretKey::from_bech32(nsec)\n            .map_err(|e| AppError::Crypto(format!(\"Invalid nsec: {e:?}\")))?;\n        let keys = Keys::new(secret_key);\n\n        let public_key = keys.public_key().to_hex();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let npub = keys\n            .public_key()\n            .to_bech32()\n            .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n\n        let keypair = KeyPair {\n            public_key,\n            private_key,\n            npub: npub.clone(),\n            nsec: nsec.to_string(),\n        };\n\n        // Store in memory\n        let mut inner = self.inner.write().await;\n        inner.keys = Some(keys);\n        inner.stored_keys.insert(npub, keypair.clone());\n\n        Ok(keypair)\n    }\n\n    async fn export_private_key(&self, npub: &str) -> Result<String, AppError> {\n        let inner = self.inner.read().await;\n        inner\n            .stored_keys\n            .get(npub)\n            .map(|kp| kp.nsec.clone())\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn get_public_key(&self, npub: &str) -> Result<String, AppError> {\n        let inner = self.inner.read().await;\n        inner\n            .stored_keys\n            .get(npub)\n            .map(|kp| kp.public_key.clone())\n            .ok_or_else(|| AppError::NotFound(format!(\"Key not found: {npub}\")))\n    }\n\n    async fn store_keypair(&self, keypair: &KeyPair) -> Result<(), AppError> {\n        let mut inner = self.inner.write().await;\n        inner\n            .stored_keys\n            .insert(keypair.npub.clone(), keypair.clone());\n        Ok(())\n    }\n\n    async fn delete_keypair(&self, npub: &str) -> Result<(), AppError> {\n        let mut inner = self.inner.write().await;\n        inner.stored_keys.remove(npub);\n        // If this was the current key, clear it\n        if let Some(keys) = &inner.keys {\n            if keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?\n                == npub\n            {\n                inner.keys = None;\n            }\n        }\n        Ok(())\n    }\n\n    async fn current_keypair(&self) -> Result<KeyPair, AppError> {\n        let (npub, keys, cached_pair) = {\n            let inner = self.inner.read().await;\n            let keys = inner\n                .keys\n                .as_ref()\n                .cloned()\n                .ok_or_else(|| AppError::Unauthorized(\"No keys loaded\".into()))?;\n            let npub = keys\n                .public_key()\n                .to_bech32()\n                .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n            let cached = inner.stored_keys.get(&npub).cloned();\n            (npub, keys, cached)\n        };\n\n        if let Some(pair) = cached_pair {\n            return Ok(pair);\n        }\n\n        let public_key = keys.public_key().to_hex();\n        let private_key = keys.secret_key().display_secret().to_string();\n        let nsec = keys\n            .secret_key()\n            .to_bech32()\n            .map_err(|e| AppError::Crypto(format!(\"Failed to convert to bech32: {e:?}\")))?;\n\n        let keypair = KeyPair {\n            public_key,\n            private_key,\n            npub: npub.clone(),\n            nsec,\n        };\n\n        let mut inner = self.inner.write().await;\n        inner.stored_keys.insert(npub, keypair.clone());\n        Ok(keypair)\n    }\n\n    async fn list_npubs(&self) -> Result<Vec<String>, AppError> {\n        let inner = self.inner.read().await;\n        Ok(inner.stored_keys.keys().cloned().collect())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_key_manager_new() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.get_keys().await;\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), \"No keys loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_generate_keypair() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.generate_keypair().await;\n        assert!(result.is_ok());\n\n        let keypair = result.unwrap();\n        assert_eq!(keypair.public_key.len(), 64); // Hex public key is 64 characters\n        assert!(keypair.nsec.starts_with(\"nsec1\")); // Bech32 secret key starts with nsec1\n        assert!(keypair.npub.starts_with(\"npub1\")); // Bech32 public key starts with npub1\n\n        // Verify keys are stored\n        let stored_keys = key_manager.get_keys().await;\n        assert!(stored_keys.is_ok());\n        assert_eq!(\n            stored_keys.unwrap().public_key().to_hex(),\n            keypair.public_key\n        );\n    }\n\n    #[tokio::test]\n    async fn test_import_private_key() {\n        let key_manager = DefaultKeyManager::new();\n\n        // Generate a test key first\n        let test_keys = Keys::generate();\n        let test_nsec = test_keys.secret_key().to_bech32().unwrap();\n        let expected_public_key = test_keys.public_key().to_hex();\n\n        // Import the test key\n        let result = key_manager.import_private_key(&test_nsec).await;\n        assert!(result.is_ok());\n\n        let keypair = result.unwrap();\n        assert_eq!(keypair.public_key, expected_public_key);\n        assert!(keypair.npub.starts_with(\"npub1\"));\n\n        // Verify keys are stored\n        let stored_keys = key_manager.get_keys().await;\n        assert!(stored_keys.is_ok());\n        assert_eq!(\n            stored_keys.unwrap().public_key().to_hex(),\n            keypair.public_key\n        );\n    }\n\n    #[tokio::test]\n    async fn test_login_with_invalid_nsec() {\n        let key_manager = DefaultKeyManager::new();\n        let result = key_manager.login(\"invalid_nsec\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_logout() {\n        let key_manager = DefaultKeyManager::new();\n\n        // Generate and store keys first\n        let _ = key_manager.generate().await.unwrap();\n        assert!(key_manager.get_keys().await.is_ok());\n\n        // Logout\n        let result = key_manager.logout().await;\n        assert!(result.is_ok());\n\n        // Verify keys are cleared\n        let stored_keys = key_manager.get_keys().await;\n        assert!(stored_keys.is_err());\n        assert_eq!(stored_keys.unwrap_err().to_string(), \"No keys loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_list_npubs() {\n        let key_manager = DefaultKeyManager::new();\n\n        // Initially empty\n        let npubs = key_manager.list_npubs().await.unwrap();\n        assert_eq!(npubs.len(), 0);\n\n        // Generate a keypair\n        let keypair1 = key_manager.generate_keypair().await.unwrap();\n        let npubs = key_manager.list_npubs().await.unwrap();\n        assert_eq!(npubs.len(), 1);\n        assert!(npubs.contains(&keypair1.npub));\n\n        // Generate another keypair\n        let keypair2 = key_manager.generate_keypair().await.unwrap();\n        let npubs = key_manager.list_npubs().await.unwrap();\n        assert_eq!(npubs.len(), 2);\n        assert!(npubs.contains(&keypair1.npub));\n        assert!(npubs.contains(&keypair2.npub));\n    }\n\n    #[tokio::test]\n    async fn test_export_private_key() {\n        let key_manager = DefaultKeyManager::new();\n\n        // Generate a keypair\n        let keypair = key_manager.generate_keypair().await.unwrap();\n\n        // Export the private key\n        let nsec = key_manager.export_private_key(&keypair.npub).await.unwrap();\n        assert_eq!(nsec, keypair.nsec);\n\n        // Try to export non-existent key\n        let result = key_manager.export_private_key(\"npub1nonexistent\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_delete_keypair() {\n        let key_manager = DefaultKeyManager::new();\n\n        // Generate a keypair\n        let keypair = key_manager.generate_keypair().await.unwrap();\n        assert_eq!(key_manager.list_npubs().await.unwrap().len(), 1);\n\n        // Delete the keypair\n        key_manager.delete_keypair(&keypair.npub).await.unwrap();\n        assert_eq!(key_manager.list_npubs().await.unwrap().len(), 0);\n\n        // Verify current keys are also cleared\n        let result = key_manager.get_keys().await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_current_keypair_returns_active_identity() {\n        let key_manager = DefaultKeyManager::new();\n        let generated = key_manager.generate_keypair().await.unwrap();\n\n        let current = key_manager.current_keypair().await.unwrap();\n        assert_eq!(current.public_key, generated.public_key);\n        assert_eq!(current.npub, generated.npub);\n    }\n\n    #[tokio::test]\n    async fn test_current_keypair_requires_active_keys() {\n        let key_manager = DefaultKeyManager::new();\n        let err = key_manager.current_keypair().await.unwrap_err();\n        assert!(matches!(err, AppError::Unauthorized(_)));\n    }\n}\n","traces":[{"line":22,"address":[16985472,16985653],"length":1,"stats":{"Line":1}},{"line":24,"address":[17756785],"length":1,"stats":{"Line":1}},{"line":32,"address":[16985952,16985712,16985900,16985680,16985688,16986712,16987725,16985747],"length":1,"stats":{"Line":4}},{"line":33,"address":[13499481],"length":1,"stats":{"Line":1}},{"line":34,"address":[17516399,17516489],"length":1,"stats":{"Line":2}},{"line":35,"address":[17543344,17543258],"length":1,"stats":{"Line":2}},{"line":36,"address":[13499932,13500016],"length":1,"stats":{"Line":2}},{"line":39,"address":[10380409],"length":1,"stats":{"Line":2}},{"line":40,"address":[17758201,17758908,17758938],"length":1,"stats":{"Line":1}},{"line":42,"address":[16987253],"length":1,"stats":{"Line":1}},{"line":46,"address":[17761181,17759389,17760318,17759090,17759120,17759155,17759337,17759072],"length":1,"stats":{"Line":4}},{"line":47,"address":[17759620,17759318,17759436],"length":1,"stats":{"Line":3}},{"line":48,"address":[12303874,12303683],"length":1,"stats":{"Line":0}},{"line":50,"address":[12303967,12303886],"length":1,"stats":{"Line":0}},{"line":51,"address":[13502187,13502271],"length":1,"stats":{"Line":0}},{"line":54,"address":[17518532,17519518,17519267,17519333],"length":1,"stats":{"Line":0}},{"line":55,"address":[13503404,13503438,13502859],"length":1,"stats":{"Line":0}},{"line":57,"address":[16989625],"length":1,"stats":{"Line":0}},{"line":61,"address":[12306299,12305733,12305440,12305555,12305424,12305432,12305465,12305592],"length":1,"stats":{"Line":4}},{"line":62,"address":[10369220],"length":1,"stats":{"Line":2}},{"line":63,"address":[17761857,17762125,17762152],"length":1,"stats":{"Line":1}},{"line":64,"address":[17547952],"length":1,"stats":{"Line":1}},{"line":68,"address":[13504566,13504695,13504416,13504529,13504400,13505096,13504408,13504451],"length":1,"stats":{"Line":4}},{"line":69,"address":[13504727,13504623,13504517,13504556],"length":1,"stats":{"Line":2}},{"line":70,"address":[12307088,12306957,12306892,12307092],"length":1,"stats":{"Line":4}},{"line":75,"address":[17522192],"length":1,"stats":{"Line":0}},{"line":76,"address":[16991793],"length":1,"stats":{"Line":0}},{"line":82,"address":[17108747,17108506,17106351,17106438,17106400,17106661,17106825],"length":1,"stats":{"Line":3}},{"line":83,"address":[12422263],"length":1,"stats":{"Line":1}},{"line":84,"address":[17878196,17878317],"length":1,"stats":{"Line":2}},{"line":85,"address":[13603567,13603662],"length":1,"stats":{"Line":4}},{"line":86,"address":[17107373,17107627,17107280,17108650],"length":1,"stats":{"Line":4}},{"line":89,"address":[17881376,17881393,17878827],"length":1,"stats":{"Line":0}},{"line":90,"address":[17107732,17108074,17107565],"length":1,"stats":{"Line":4}},{"line":93,"address":[17640736,17638442,17640753],"length":1,"stats":{"Line":0}},{"line":98,"address":[12423368],"length":1,"stats":{"Line":2}},{"line":103,"address":[13604762,13603152,13604835,13605195],"length":1,"stats":{"Line":5}},{"line":104,"address":[13606331,13605425],"length":1,"stats":{"Line":3}},{"line":105,"address":[17639711,17639784,17640323],"length":1,"stats":{"Line":6}},{"line":107,"address":[17666729],"length":1,"stats":{"Line":3}},{"line":110,"address":[17881894,17884259,17881856,17882117,17881791,17882281,17884044],"length":1,"stats":{"Line":3}},{"line":111,"address":[17668613,17670161,17668263,17668346],"length":1,"stats":{"Line":2}},{"line":112,"address":[17885670,17885648,17882677],"length":1,"stats":{"Line":0}},{"line":113,"address":[17111577,17111365],"length":1,"stats":{"Line":2}},{"line":115,"address":[17882933,17882824],"length":1,"stats":{"Line":2}},{"line":116,"address":[12427178,12427083],"length":1,"stats":{"Line":2}},{"line":117,"address":[13608749,13608308,13608401],"length":1,"stats":{"Line":2}},{"line":120,"address":[17114689,17112313,17114672],"length":1,"stats":{"Line":0}},{"line":125,"address":[17883511],"length":1,"stats":{"Line":1}},{"line":126,"address":[17112426],"length":1,"stats":{"Line":1}},{"line":130,"address":[11345655],"length":1,"stats":{"Line":2}},{"line":131,"address":[13609673,13610581],"length":1,"stats":{"Line":1}},{"line":132,"address":[13610549,13609963,13610020],"length":1,"stats":{"Line":2}},{"line":134,"address":[12429235],"length":1,"stats":{"Line":1}},{"line":137,"address":[13611215,13611459,13611947,13611546,13611784,13612434,13611424],"length":1,"stats":{"Line":3}},{"line":138,"address":[12430453,12430879,12430728],"length":1,"stats":{"Line":1}},{"line":139,"address":[17672984,17672964,17672891,17673031],"length":1,"stats":{"Line":4}},{"line":141,"address":[17646235],"length":1,"stats":{"Line":1}},{"line":142,"address":[12431408,12431392],"length":1,"stats":{"Line":2}},{"line":143,"address":[12431461,12431440,12431246],"length":1,"stats":{"Line":3}},{"line":146,"address":[12431647,12431696,12432762,12431818,12432060,12432239,12431731],"length":1,"stats":{"Line":0}},{"line":147,"address":[11128436],"length":1,"stats":{"Line":0}},{"line":148,"address":[17888519,17888379,17888452,17888472],"length":1,"stats":{"Line":0}},{"line":150,"address":[17647627],"length":1,"stats":{"Line":0}},{"line":151,"address":[17888672,17888656],"length":1,"stats":{"Line":0}},{"line":152,"address":[17674592,17674414,17674613],"length":1,"stats":{"Line":0}},{"line":155,"address":[17674962,17675198,17675377,17676048,17674867,17674788,17674832],"length":1,"stats":{"Line":0}},{"line":156,"address":[11341940],"length":1,"stats":{"Line":0}},{"line":157,"address":[17889729,17889802,17889952],"length":1,"stats":{"Line":0}},{"line":159,"address":[17889813,17890122,17889995],"length":1,"stats":{"Line":0}},{"line":160,"address":[17649190],"length":1,"stats":{"Line":0}},{"line":163,"address":[13616329,13615583,13615792,13615922,13617353,13615827,13616166],"length":1,"stats":{"Line":3}},{"line":164,"address":[17676582,17676301,17676733],"length":1,"stats":{"Line":1}},{"line":165,"address":[13616581,13616638],"length":1,"stats":{"Line":2}},{"line":167,"address":[13616696],"length":1,"stats":{"Line":1}},{"line":168,"address":[13616746,13616783,13616963,13617006,13617087,13617320],"length":1,"stats":{"Line":5}},{"line":171,"address":[17891984,17891486,17892001],"length":1,"stats":{"Line":0}},{"line":172,"address":[17677362,17677459,17677513],"length":1,"stats":{"Line":1}},{"line":174,"address":[17651017,17650818],"length":1,"stats":{"Line":1}},{"line":177,"address":[17120021],"length":1,"stats":{"Line":1}},{"line":180,"address":[17892671,17892191,17892240,17892480,17892287,17892878,17895679],"length":1,"stats":{"Line":3}},{"line":181,"address":[13619669],"length":1,"stats":{"Line":1}},{"line":182,"address":[17121678,17121501,17121278],"length":1,"stats":{"Line":1}},{"line":183,"address":[17652350,17652675,17655274,17652429],"length":1,"stats":{"Line":4}},{"line":187,"address":[17652643,17656352,17656366],"length":1,"stats":{"Line":3}},{"line":188,"address":[17122236,17122583,17122356],"length":1,"stats":{"Line":2}},{"line":191,"address":[17679687,17683184,17683201],"length":1,"stats":{"Line":0}},{"line":192,"address":[13619377,13619251],"length":1,"stats":{"Line":2}},{"line":193,"address":[17893956],"length":1,"stats":{"Line":1}},{"line":196,"address":[12438480],"length":1,"stats":{"Line":1}},{"line":197,"address":[12438563],"length":1,"stats":{"Line":1}},{"line":200,"address":[17653631,17653788],"length":1,"stats":{"Line":0}},{"line":201,"address":[17653807,17653893],"length":1,"stats":{"Line":0}},{"line":202,"address":[17680790,17681123,17680704],"length":1,"stats":{"Line":0}},{"line":205,"address":[13620635,13622832,13622849],"length":1,"stats":{"Line":0}},{"line":210,"address":[17681057],"length":1,"stats":{"Line":0}},{"line":214,"address":[17895566,17892531,17896108,17895489],"length":1,"stats":{"Line":0}},{"line":215,"address":[17655527,17655600,17656186],"length":1,"stats":{"Line":0}},{"line":216,"address":[12440773],"length":1,"stats":{"Line":0}},{"line":219,"address":[17898808,17897673,17897834,17897712,17898076,17897747,17898255],"length":1,"stats":{"Line":3}},{"line":220,"address":[17126904,17126629,17127055],"length":1,"stats":{"Line":1}},{"line":221,"address":[13623987,13624044],"length":1,"stats":{"Line":2}}],"covered":69,"coverable":102},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","mod.rs"],"content":"pub mod default_encryption_service;\npub mod default_signature_service;\npub mod encryption_service;\npub mod key_manager;\npub mod signature_service;\n\npub use default_encryption_service::DefaultEncryptionService;\npub use default_signature_service::DefaultSignatureService;\npub use encryption_service::EncryptionService;\npub use key_manager::DefaultKeyManager;\npub use signature_service::SignatureService;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","crypto","signature_service.rs"],"content":"use crate::domain::entities::Event;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait SignatureService: Send + Sync {\n    async fn sign_event(\n        &self,\n        event: &mut Event,\n        private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_event(\n        &self,\n        event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn sign_message(\n        &self,\n        message: &str,\n        private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n    async fn verify_message(\n        &self,\n        message: &str,\n        signature: &str,\n        public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","connection_pool.rs"],"content":"use sqlx::{SqlitePool, sqlite::SqlitePoolOptions};\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct ConnectionPool {\n    pool: Arc<SqlitePool>,\n}\n\nimpl ConnectionPool {\n    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(5)\n            .connect(database_url)\n            .await?;\n\n        Ok(Self {\n            pool: Arc::new(pool),\n        })\n    }\n\n    pub async fn from_memory() -> Result<Self, sqlx::Error> {\n        Self::new(\":memory:\").await\n    }\n\n    pub fn get_pool(&self) -> &SqlitePool {\n        &self.pool\n    }\n\n    pub async fn migrate(&self) -> Result<(), sqlx::migrate::MigrateError> {\n        sqlx::migrate!(\"./migrations\").run(self.pool.as_ref()).await\n    }\n\n    pub async fn close(&self) {\n        self.pool.close().await;\n    }\n}\n","traces":[{"line":10,"address":[15635293,15635480,15635312,15635362,15635717,15635528,15636300,15635280],"length":1,"stats":{"Line":4}},{"line":11,"address":[11732236,11732537,11732037,11732665,11732151,11732417],"length":1,"stats":{"Line":10}},{"line":14,"address":[10958567],"length":1,"stats":{"Line":7}},{"line":16,"address":[15850295],"length":1,"stats":{"Line":3}},{"line":17,"address":[15636054],"length":1,"stats":{"Line":1}},{"line":21,"address":[15079371,15079778,15079483,15079200,15079184,15079250,15079187,15079334],"length":1,"stats":{"Line":4}},{"line":22,"address":[11733183,11732983,11733107,11733037],"length":1,"stats":{"Line":5}},{"line":25,"address":[15851024],"length":1,"stats":{"Line":1}},{"line":26,"address":[15851029],"length":1,"stats":{"Line":3}},{"line":29,"address":[18981203,18981032,18981024,18981056,18981091,18981759,18981389,18981664],"length":1,"stats":{"Line":0}},{"line":30,"address":[10977191],"length":1,"stats":{"Line":0}},{"line":33,"address":[18982099,18981955,18981776,18981918,18982317,18981784,18981833,18981808],"length":1,"stats":{"Line":0}},{"line":34,"address":[11734357,11734318,11734427,11734531],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":13},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","mod.rs"],"content":"pub mod connection_pool;\npub mod repository;\npub mod sqlite_repository;\npub mod subscription_state_repository;\n\npub use connection_pool::ConnectionPool;\npub use repository::{\n    BookmarkRepository, EventRepository, PostRepository, Repository, TopicRepository,\n    UserRepository,\n};\npub use subscription_state_repository::SqliteSubscriptionStateRepository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","repository.rs"],"content":"use crate::domain::entities::{Bookmark, Event, Post, Topic, User};\nuse crate::domain::value_objects::{EventId, PublicKey};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait Repository:\n    PostRepository + TopicRepository + UserRepository + EventRepository + BookmarkRepository\n{\n    async fn initialize(&self) -> Result<(), AppError>;\n    async fn health_check(&self) -> Result<bool, AppError>;\n}\n\n#[async_trait]\npub trait PostRepository: Send + Sync {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError>;\n    async fn get_posts_by_topic(&self, topic_id: &str, limit: usize)\n    -> Result<Vec<Post>, AppError>;\n    async fn update_post(&self, post: &Post) -> Result<(), AppError>;\n    async fn delete_post(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError>;\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError>;\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError>;\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError>;\n}\n\n#[async_trait]\npub trait TopicRepository: Send + Sync {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError>;\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError>;\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError>;\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError>;\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError>;\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError>;\n    async fn update_topic_stats(\n        &self,\n        topic_id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError>;\n}\n\n#[async_trait]\npub trait UserRepository: Send + Sync {\n    async fn create_user(&self, user: &User) -> Result<(), AppError>;\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError>;\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError>;\n    async fn update_user(&self, user: &User) -> Result<(), AppError>;\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError>;\n    async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError>;\n    async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError>;\n}\n\n#[async_trait]\npub trait EventRepository: Send + Sync {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError>;\n    async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n\n    /// イベントとトピックのマッピングを登録（冪等）\n    async fn add_event_topic(&self, _event_id: &str, _topic_id: &str) -> Result<(), AppError> {\n        // 既定実装: 実装なし\n        Ok(())\n    }\n\n    /// イベントが属するトピックID一覧を取得\n    async fn get_event_topics(&self, _event_id: &str) -> Result<Vec<String>, AppError> {\n        // 既定実装: 空\n        Ok(vec![])\n    }\n}\n\n#[async_trait]\npub trait BookmarkRepository: Send + Sync {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError>;\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError>;\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError>;\n}\n","traces":[{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","bookmarks.rs"],"content":"use super::SqliteRepository;\nuse super::queries::{\n    DELETE_BOOKMARK, INSERT_BOOKMARK, SELECT_BOOKMARK_BY_USER_AND_POST, SELECT_BOOKMARKS_BY_USER,\n};\nuse crate::domain::entities::Bookmark;\nuse crate::domain::value_objects::{BookmarkId, EventId, PublicKey};\nuse crate::infrastructure::database::BookmarkRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::{TimeZone, Utc};\nuse sqlx::FromRow;\n\n#[derive(Debug, FromRow)]\nstruct BookmarkRow {\n    id: String,\n    user_pubkey: String,\n    post_id: String,\n    created_at: i64,\n}\n\nimpl BookmarkRow {\n    fn into_domain(self) -> Result<Bookmark, AppError> {\n        let id = BookmarkId::new(self.id)\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid BookmarkId: {err}\")))?;\n        let user_pubkey = PublicKey::from_hex_str(&self.user_pubkey)\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid public key: {err}\")))?;\n        let post_id = EventId::from_hex(&self.post_id)\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid post id: {err}\")))?;\n        let created_at = Utc\n            .timestamp_millis_opt(self.created_at)\n            .single()\n            .ok_or_else(|| AppError::DeserializationError(\"Invalid timestamp\".to_string()))?;\n\n        Ok(Bookmark::from_parts(id, user_pubkey, post_id, created_at))\n    }\n}\n\nimpl SqliteRepository {\n    async fn fetch_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let row = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARK_BY_USER_AND_POST)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => row.into_domain(),\n            None => Err(AppError::NotFound(\"Bookmark not found\".to_string())),\n        }\n    }\n}\n\n#[async_trait]\nimpl BookmarkRepository for SqliteRepository {\n    async fn create_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<Bookmark, AppError> {\n        let bookmark = Bookmark::new(user_pubkey.clone(), post_id.clone());\n\n        let result = sqlx::query(INSERT_BOOKMARK)\n            .bind(bookmark.id().as_str())\n            .bind(bookmark.user_pubkey().as_hex())\n            .bind(bookmark.post_id().as_str())\n            .bind(bookmark.created_at().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        if result.rows_affected() == 0 {\n            return self.fetch_bookmark(user_pubkey, post_id).await;\n        }\n\n        Ok(bookmark)\n    }\n\n    async fn delete_bookmark(\n        &self,\n        user_pubkey: &PublicKey,\n        post_id: &EventId,\n    ) -> Result<(), AppError> {\n        sqlx::query(DELETE_BOOKMARK)\n            .bind(user_pubkey.as_hex())\n            .bind(post_id.as_str())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn list_bookmarks(&self, user_pubkey: &PublicKey) -> Result<Vec<Bookmark>, AppError> {\n        let rows = sqlx::query_as::<_, BookmarkRow>(SELECT_BOOKMARKS_BY_USER)\n            .bind(user_pubkey.as_hex())\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        rows.into_iter().map(BookmarkRow::into_domain).collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::database::connection_pool::ConnectionPool;\n\n    async fn setup_repository() -> SqliteRepository {\n        let pool = ConnectionPool::new(\"sqlite::memory:?cache=shared\")\n            .await\n            .expect(\"failed to create pool\");\n\n        sqlx::query(\n            r#\"\n            CREATE TABLE IF NOT EXISTS bookmarks (\n                id TEXT PRIMARY KEY,\n                user_pubkey TEXT NOT NULL,\n                post_id TEXT NOT NULL,\n                created_at INTEGER NOT NULL,\n                UNIQUE(user_pubkey, post_id)\n            );\n            \"#,\n        )\n        .execute(pool.get_pool())\n        .await\n        .expect(\"failed to create table\");\n\n        SqliteRepository::new(pool)\n    }\n\n    fn sample_pubkey() -> PublicKey {\n        let hex = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n        PublicKey::from_hex_str(hex).expect(\"valid pubkey\")\n    }\n\n    fn sample_event_id() -> EventId {\n        EventId::generate()\n    }\n\n    #[tokio::test]\n    async fn create_and_list_bookmarks() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert_eq!(bookmarks.len(), 1);\n        assert_eq!(bookmarks[0].post_id().as_str(), event_id.as_str());\n        assert_eq!(bookmarks[0].user_pubkey().as_hex(), pubkey.as_hex());\n    }\n\n    #[tokio::test]\n    async fn create_is_idempotent() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        let first = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n        let second = repo\n            .create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark idempotent\");\n\n        assert_eq!(first.id().as_str(), second.id().as_str());\n    }\n\n    #[tokio::test]\n    async fn delete_bookmark_succeeds() {\n        let repo = setup_repository().await;\n        let pubkey = sample_pubkey();\n        let event_id = sample_event_id();\n\n        repo.create_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"bookmark created\");\n\n        repo.delete_bookmark(&pubkey, &event_id)\n            .await\n            .expect(\"deleted\");\n\n        let bookmarks = repo.list_bookmarks(&pubkey).await.expect(\"list\");\n        assert!(bookmarks.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[17327545,17325984],"length":1,"stats":{"Line":1}},{"line":23,"address":[17326304,17327708,17326006,17326137],"length":1,"stats":{"Line":2}},{"line":24,"address":[13204694,13203058,13204672],"length":1,"stats":{"Line":0}},{"line":25,"address":[12431800,12432166,12433287,12431932],"length":1,"stats":{"Line":2}},{"line":26,"address":[12964118,12964096,12962534],"length":1,"stats":{"Line":0}},{"line":27,"address":[12962508,12962646,12962887,12963639],"length":1,"stats":{"Line":2}},{"line":28,"address":[12433974,12432455,12433952],"length":1,"stats":{"Line":0}},{"line":29,"address":[17326846,17326989,17327330],"length":1,"stats":{"Line":2}},{"line":30,"address":[17326842],"length":1,"stats":{"Line":1}},{"line":32,"address":[12964608,12963298,12964622],"length":1,"stats":{"Line":0}},{"line":34,"address":[16334185,16333914],"length":1,"stats":{"Line":2}},{"line":39,"address":[12149696],"length":1,"stats":{"Line":1}},{"line":44,"address":[17329378,17328961,17329640,17329264,17329973,17329792,17328854,17329034,17329154],"length":1,"stats":{"Line":8}},{"line":45,"address":[13205837,13205789,13205946,13206395],"length":1,"stats":{"Line":2}},{"line":46,"address":[12434730,12434842,12435134],"length":1,"stats":{"Line":2}},{"line":47,"address":[13206090,13206187,13206328],"length":1,"stats":{"Line":2}},{"line":48,"address":[17329319,17329720,17329537,17329405,17329925,17328908],"length":1,"stats":{"Line":4}},{"line":50,"address":[16336803],"length":1,"stats":{"Line":1}},{"line":51,"address":[16337286,16336956],"length":1,"stats":{"Line":2}},{"line":52,"address":[17330214,17330006],"length":1,"stats":{"Line":0}},{"line":64,"address":[13243400,13244810],"length":1,"stats":{"Line":1}},{"line":66,"address":[16375284,16375544,16373782,16375089,16373571,16374492,16373669,16374249,16374966,16374094,16373938,16374374],"length":1,"stats":{"Line":10}},{"line":67,"address":[12472601,12472386,12472461,12473514,12473559],"length":1,"stats":{"Line":2}},{"line":68,"address":[13244727,13244690,13244754,13243989,13243626,13243849],"length":1,"stats":{"Line":2}},{"line":69,"address":[12473530,12472773,12472402,12472913,12473439,12473410,12473466],"length":1,"stats":{"Line":2}},{"line":70,"address":[17383618,17384113,17384248,17384541,17384578,17384698,17384634],"length":1,"stats":{"Line":2}},{"line":71,"address":[16374762,16373634,16374559,16374698,16374409,16374642,16374300],"length":1,"stats":{"Line":2}},{"line":72,"address":[19261410],"length":1,"stats":{"Line":4}},{"line":74,"address":[16375326,16375205],"length":1,"stats":{"Line":2}},{"line":75,"address":[16375332,16375572,16375454,16373179],"length":1,"stats":{"Line":3}},{"line":78,"address":[13004551],"length":1,"stats":{"Line":1}},{"line":86,"address":[13005895,13006083,13006474,13005611,13006013,13006697,13005763,13005677,13006372],"length":1,"stats":{"Line":8}},{"line":87,"address":[17386899,17386358,17386401,17386510],"length":1,"stats":{"Line":2}},{"line":88,"address":[12475778,12475414,12475535],"length":1,"stats":{"Line":2}},{"line":89,"address":[13032687,13032784,13032873],"length":1,"stats":{"Line":2}},{"line":90,"address":[17387329,17386772,17386953,17386806,17387104,17386045],"length":1,"stats":{"Line":4}},{"line":91,"address":[16377384],"length":1,"stats":{"Line":1}},{"line":94,"address":[13033472,13033854,13033618,13034377,13034408,13033507],"length":1,"stats":{"Line":3}},{"line":95,"address":[16378065,16378151,16378733,16378374,16378269,16378631,16378986,16377999],"length":1,"stats":{"Line":7}},{"line":96,"address":[17388047,17387937,17387894,17388307],"length":1,"stats":{"Line":2}},{"line":97,"address":[16378207,16378304,16378428],"length":1,"stats":{"Line":2}},{"line":98,"address":[12477096,12477185,12477304,12477463,12477722,12476509],"length":1,"stats":{"Line":4}},{"line":100,"address":[17388684,17388885],"length":1,"stats":{"Line":2}}],"covered":38,"coverable":43},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","events.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_event_row;\nuse super::queries::{\n    INSERT_EVENT, INSERT_EVENT_TOPIC, MARK_EVENT_DELETED, MARK_EVENT_SYNCED, SELECT_EVENT_BY_ID,\n    SELECT_EVENT_TOPICS, SELECT_EVENTS_BY_AUTHOR, SELECT_EVENTS_BY_KIND, SELECT_UNSYNC_EVENTS,\n};\nuse crate::domain::entities::Event;\nuse crate::infrastructure::database::EventRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl EventRepository for SqliteRepository {\n    async fn create_event(&self, event: &Event) -> Result<(), AppError> {\n        let tags_json = serde_json::to_string(&event.tags).unwrap_or_else(|_| \"[]\".to_string());\n\n        sqlx::query(INSERT_EVENT)\n            .bind(event.id.to_string())\n            .bind(&event.pubkey)\n            .bind(&event.content)\n            .bind(event.kind as i64)\n            .bind(&tags_json)\n            .bind(event.created_at.timestamp_millis())\n            .bind(&event.sig)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        for tag in &event.tags {\n            if tag.len() >= 2 {\n                let key = tag[0].to_lowercase();\n                if (key == \"topic\" || key == \"t\") && !tag[1].is_empty() {\n                    let _ = self.add_event_topic(&event.id, &tag[1]).await;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError> {\n        let row = sqlx::query(SELECT_EVENT_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_event_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_KIND)\n            .bind(kind as i64)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn get_events_by_author(\n        &self,\n        pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_EVENTS_BY_AUTHOR)\n            .bind(pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_EVENTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut events = Vec::with_capacity(rows.len());\n        for row in rows {\n            let event = map_event_row(&row)?;\n            events.push(event);\n        }\n\n        Ok(events)\n    }\n\n    async fn mark_event_synced(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_EVENT_SYNCED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError> {\n        sqlx::query(INSERT_EVENT_TOPIC)\n            .bind(event_id)\n            .bind(topic_id)\n            .bind(Utc::now().timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n        Ok(())\n    }\n\n    async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError> {\n        let rows = sqlx::query(SELECT_EVENT_TOPICS)\n            .bind(event_id)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            topics.push(row.try_get::<String, _>(\"topic_id\")?);\n        }\n\n        Ok(topics)\n    }\n}\n","traces":[{"line":16,"address":[17658176,17658475,17659513,17658000,17658047,17659566],"length":1,"stats":{"Line":0}},{"line":17,"address":[17899369,17902032,17902048],"length":1,"stats":{"Line":0}},{"line":19,"address":[17899585,17900141,17899652,17900662,17899994,17900847,17899816,17900548,17899935,17899730,17899442,17900259,17899508,17899777],"length":1,"stats":{"Line":0}},{"line":20,"address":[17658796,17658641,17659544,17658684],"length":1,"stats":{"Line":0}},{"line":21,"address":[12443764],"length":1,"stats":{"Line":0}},{"line":22,"address":[12373326],"length":1,"stats":{"Line":0}},{"line":23,"address":[12373365],"length":1,"stats":{"Line":0}},{"line":24,"address":[17658972,17659011],"length":1,"stats":{"Line":0}},{"line":25,"address":[17685755,17685874,17685583,17686258],"length":1,"stats":{"Line":0}},{"line":26,"address":[12373582,12373656],"length":1,"stats":{"Line":0}},{"line":27,"address":[17659491,17659344,17659232,17659189],"length":1,"stats":{"Line":0}},{"line":28,"address":[10693183],"length":1,"stats":{"Line":0}},{"line":30,"address":[17686801,17687320,17686660,17687248],"length":1,"stats":{"Line":0}},{"line":31,"address":[17130304,17130208],"length":1,"stats":{"Line":0}},{"line":32,"address":[17687458],"length":1,"stats":{"Line":0}},{"line":33,"address":[17687552],"length":1,"stats":{"Line":0}},{"line":34,"address":[12375345,12372691,12374541,12374851],"length":1,"stats":{"Line":0}},{"line":39,"address":[17130149],"length":1,"stats":{"Line":0}},{"line":42,"address":[12446422,12446272,12446996,12446307,12446574],"length":1,"stats":{"Line":0}},{"line":43,"address":[12376122,12376914,12376217,12376314,12376529,12376633,12377505,12376043],"length":1,"stats":{"Line":0}},{"line":44,"address":[17661790,17661745],"length":1,"stats":{"Line":0}},{"line":45,"address":[17131310,17131492,17131614,17131398],"length":1,"stats":{"Line":0}},{"line":46,"address":[11215556],"length":1,"stats":{"Line":0}},{"line":48,"address":[17903331],"length":1,"stats":{"Line":0}},{"line":49,"address":[12376993,12377095,12377437],"length":1,"stats":{"Line":0}},{"line":50,"address":[17132218],"length":1,"stats":{"Line":0}},{"line":54,"address":[17904067,17904940,17904184,17904032,17904447],"length":1,"stats":{"Line":0}},{"line":55,"address":[17664034,17664261,17664363,17665738,17663929,17664569,17663795,17663721],"length":1,"stats":{"Line":0}},{"line":56,"address":[17904623],"length":1,"stats":{"Line":0}},{"line":57,"address":[17690595],"length":1,"stats":{"Line":0}},{"line":58,"address":[17664086,17663867,17663752,17663964],"length":1,"stats":{"Line":0}},{"line":59,"address":[17690885,17691257,17690708,17690797,17691045,17690115],"length":1,"stats":{"Line":0}},{"line":61,"address":[17691233,17691388],"length":1,"stats":{"Line":0}},{"line":62,"address":[17134278,17134389,17134524,17134572],"length":1,"stats":{"Line":0}},{"line":63,"address":[17665483,17665020,17665267],"length":1,"stats":{"Line":0}},{"line":64,"address":[17692165],"length":1,"stats":{"Line":0}},{"line":67,"address":[12379282],"length":1,"stats":{"Line":0}},{"line":75,"address":[12380466,12380675,12380987,12381101,12382398,12380545,12380772,12381283],"length":1,"stats":{"Line":0}},{"line":76,"address":[17907144],"length":1,"stats":{"Line":0}},{"line":77,"address":[17907221],"length":1,"stats":{"Line":0}},{"line":78,"address":[12380617,12380497,12380706,12380820],"length":1,"stats":{"Line":0}},{"line":79,"address":[17693575,17693787,17693238,17692659,17693415,17693327],"length":1,"stats":{"Line":0}},{"line":81,"address":[12381223,12381362],"length":1,"stats":{"Line":0}},{"line":82,"address":[12381487,12381614,12381384,12381658],"length":1,"stats":{"Line":0}},{"line":83,"address":[17137615,17137150,17137397],"length":1,"stats":{"Line":0}},{"line":84,"address":[17667961],"length":1,"stats":{"Line":0}},{"line":87,"address":[17694296],"length":1,"stats":{"Line":0}},{"line":90,"address":[17909139,17909242,17910091,17909478,17909104,17910050],"length":1,"stats":{"Line":0}},{"line":91,"address":[17668937,17669728,17669141,17669403,17668711,17668881,17668782,17669071,17669505],"length":1,"stats":{"Line":0}},{"line":92,"address":[17909574,17909748,17909622,17910059],"length":1,"stats":{"Line":0}},{"line":93,"address":[17138524,17138604],"length":1,"stats":{"Line":0}},{"line":94,"address":[12453924,12453710,12453972,12454066,12454156],"length":1,"stats":{"Line":0}},{"line":95,"address":[17910283,17910123,17909269,17909946,17910512,17910000],"length":1,"stats":{"Line":0}},{"line":97,"address":[17910431],"length":1,"stats":{"Line":0}},{"line":100,"address":[17910754,17910643,17911008,17911390,17910608],"length":1,"stats":{"Line":0}},{"line":101,"address":[17697755,17697115,17696977,17698924,17697048,17697549,17697447,17697220],"length":1,"stats":{"Line":0}},{"line":102,"address":[17911104,17911246,17911368,17911152],"length":1,"stats":{"Line":0}},{"line":103,"address":[14571380],"length":1,"stats":{"Line":0}},{"line":105,"address":[12385154,12385015],"length":1,"stats":{"Line":0}},{"line":106,"address":[17140974,17140728,17141022,17140839],"length":1,"stats":{"Line":0}},{"line":107,"address":[12385498,12385953,12385761],"length":1,"stats":{"Line":0}},{"line":108,"address":[12385903],"length":1,"stats":{"Line":0}},{"line":111,"address":[17698216],"length":1,"stats":{"Line":0}},{"line":114,"address":[12457290,12458139,12457152,12457187,12457526,12458098],"length":1,"stats":{"Line":0}},{"line":115,"address":[17142401,17143248,17142457,17142591,17142302,17142231,17143025,17142661,17142923],"length":1,"stats":{"Line":0}},{"line":116,"address":[12457796,12457622,12458107,12457670],"length":1,"stats":{"Line":0}},{"line":117,"address":[17672924,17672844],"length":1,"stats":{"Line":0}},{"line":118,"address":[12458076,12457892,12457844,12457630,12457986],"length":1,"stats":{"Line":0}},{"line":119,"address":[11227412],"length":1,"stats":{"Line":0}},{"line":121,"address":[17673519],"length":1,"stats":{"Line":0}},{"line":124,"address":[12136671],"length":1,"stats":{"Line":0}},{"line":125,"address":[12459354,12459228,12459916,12459104,12459472,12459542,12460139,12459811,12459188],"length":1,"stats":{"Line":0}},{"line":126,"address":[12388179],"length":1,"stats":{"Line":0}},{"line":127,"address":[17143895,17143855],"length":1,"stats":{"Line":0}},{"line":128,"address":[17915135,17915007,17915510,17915266],"length":1,"stats":{"Line":0}},{"line":129,"address":[12388414,12388503,12388147,12388585],"length":1,"stats":{"Line":0}},{"line":130,"address":[19253703],"length":1,"stats":{"Line":0}},{"line":131,"address":[17915882],"length":1,"stats":{"Line":0}},{"line":134,"address":[12460566,12460192,12460988,12460330,12460227],"length":1,"stats":{"Line":0}},{"line":135,"address":[12389666,12390369,12390073,12389761,12390187,12389587,12389858,12391363],"length":1,"stats":{"Line":0}},{"line":136,"address":[17675737,17675782],"length":1,"stats":{"Line":0}},{"line":137,"address":[12389792,12389618,12389706,12389906],"length":1,"stats":{"Line":0}},{"line":138,"address":[11440644],"length":1,"stats":{"Line":0}},{"line":140,"address":[17676572,17676417],"length":1,"stats":{"Line":0}},{"line":141,"address":[17676844,17676709,17676892,17676598],"length":1,"stats":{"Line":0}},{"line":142,"address":[12390784,12391051],"length":1,"stats":{"Line":0}},{"line":145,"address":[12390822],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mapper.rs"],"content":"pub(super) use crate::application::shared::mappers::{\n    map_event_row, map_joined_topic_row, map_post_row, map_topic_row, map_user_row,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","mod.rs"],"content":"use super::ConnectionPool;\nuse super::Repository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\nmod bookmarks;\nmod events;\nmod mapper;\nmod posts;\nmod queries;\nmod topics;\nmod users;\n\npub struct SqliteRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl Repository for SqliteRepository {\n    async fn initialize(&self) -> Result<(), AppError> {\n        self.pool.migrate().await?;\n        Ok(())\n    }\n\n    async fn health_check(&self) -> Result<bool, AppError> {\n        let result = sqlx::query(\"SELECT 1\")\n            .fetch_one(self.pool.get_pool())\n            .await;\n        Ok(result.is_ok())\n    }\n}\n","traces":[{"line":19,"address":[12363840],"length":1,"stats":{"Line":1}},{"line":26,"address":[12138831,12139005,12139232,12139861,12138880,12139392,12138915],"length":1,"stats":{"Line":0}},{"line":27,"address":[11109497],"length":1,"stats":{"Line":0}},{"line":28,"address":[15510518],"length":1,"stats":{"Line":0}},{"line":31,"address":[15510697,15510736,15510771,15510866,15511102,15511446],"length":1,"stats":{"Line":0}},{"line":32,"address":[18723275,18723468,18723343,18723406,18723683],"length":1,"stats":{"Line":0}},{"line":33,"address":[18723351,18723306,18723437,18723516],"length":1,"stats":{"Line":0}},{"line":34,"address":[11610183,11609677,11610129,11610271,11610479],"length":1,"stats":{"Line":0}},{"line":35,"address":[18723892,18723837],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":9},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","posts.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_post_row;\nuse super::queries::{\n    INSERT_POST_EVENT, MARK_POST_DELETED, MARK_POST_SYNCED, SELECT_POST_BY_ID,\n    SELECT_POSTS_BY_AUTHOR, SELECT_POSTS_BY_TOPIC, SELECT_RECENT_POSTS, SELECT_UNSYNC_POSTS,\n    UPDATE_POST_CONTENT,\n};\nuse crate::domain::entities::Post;\nuse crate::infrastructure::database::PostRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\n\nfn serialize_topic_tags(topic_id: &str) -> String {\n    serde_json::to_string(&vec![vec![\"t\".to_string(), topic_id.to_string()]])\n        .unwrap_or_else(|_| \"[]\".to_string())\n}\n\nfn topic_tag_like(topic_id: &str) -> String {\n    format!(r#\"[\"t\",\"{topic_id}\"]\"#)\n}\n\n#[async_trait]\nimpl PostRepository for SqliteRepository {\n    async fn create_post(&self, post: &Post) -> Result<(), AppError> {\n        let tags_json = serialize_topic_tags(&post.topic_id);\n\n        sqlx::query(INSERT_POST_EVENT)\n            .bind(&post.id)\n            .bind(post.author.pubkey())\n            .bind(&post.content)\n            .bind(1)\n            .bind(&tags_json)\n            .bind(post.created_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_post(&self, id: &str) -> Result<Option<Post>, AppError> {\n        let row = sqlx::query(SELECT_POST_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_post_row(&row, None)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_posts_by_topic(\n        &self,\n        topic_id: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_TOPIC)\n            .bind(topic_tag_like(topic_id))\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, Some(topic_id))?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn update_post(&self, post: &Post) -> Result<(), AppError> {\n        sqlx::query(UPDATE_POST_CONTENT)\n            .bind(&post.content)\n            .bind(Utc::now().timestamp_millis())\n            .bind(&post.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_post(&self, id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_DELETED)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_unsync_posts(&self) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_UNSYNC_POSTS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let mut post = map_post_row(&row, None)?;\n            post.mark_as_unsynced();\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn mark_post_synced(&self, id: &str, event_id: &str) -> Result<(), AppError> {\n        sqlx::query(MARK_POST_SYNCED)\n            .bind(event_id)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_posts_by_author(\n        &self,\n        author_pubkey: &str,\n        limit: usize,\n    ) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_POSTS_BY_AUTHOR)\n            .bind(author_pubkey)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n\n    async fn get_recent_posts(&self, limit: usize) -> Result<Vec<Post>, AppError> {\n        let rows = sqlx::query(SELECT_RECENT_POSTS)\n            .bind(limit as i64)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut posts = Vec::with_capacity(rows.len());\n        for row in rows {\n            let post = map_post_row(&row, None)?;\n            posts.push(post);\n        }\n\n        Ok(posts)\n    }\n}\n","traces":[{"line":14,"address":[17007316,17006592],"length":1,"stats":{"Line":0}},{"line":15,"address":[16793242,16792554,16793173],"length":1,"stats":{"Line":0}},{"line":16,"address":[17007360,17007226,17007376,17007292],"length":1,"stats":{"Line":0}},{"line":19,"address":[15421632],"length":1,"stats":{"Line":0}},{"line":20,"address":[11551626],"length":1,"stats":{"Line":0}},{"line":25,"address":[17099763,17101036,17101089,17099728,17099874,17100128],"length":1,"stats":{"Line":0}},{"line":26,"address":[16328961],"length":1,"stats":{"Line":0}},{"line":28,"address":[17101509,17100952,17100447,17100719,17100252,17100837,17100503,17100606,17100327,17100565,17101233,17101335],"length":1,"stats":{"Line":0}},{"line":29,"address":[16859486,16859522],"length":1,"stats":{"Line":0}},{"line":30,"address":[11644610,11644490,11645195,11644411],"length":1,"stats":{"Line":0}},{"line":31,"address":[16329258],"length":1,"stats":{"Line":0}},{"line":33,"address":[17100597,17100633],"length":1,"stats":{"Line":0}},{"line":34,"address":[17101045,17100759,17100641,17100530],"length":1,"stats":{"Line":0}},{"line":35,"address":[16329775,16329543,16329640],"length":1,"stats":{"Line":0}},{"line":36,"address":[17101281,17100880,17099901,17101461,17100979,17101121],"length":1,"stats":{"Line":0}},{"line":38,"address":[15455070],"length":1,"stats":{"Line":0}},{"line":41,"address":[11645776,11645826,11646093,11646515,11645941],"length":1,"stats":{"Line":0}},{"line":42,"address":[17102648,17102208,17102030,17102313,17102109,17103563,17102932,17102540],"length":1,"stats":{"Line":0}},{"line":43,"address":[16888000,16888045],"length":1,"stats":{"Line":0}},{"line":44,"address":[16888053,16888147,16887965,16888269],"length":1,"stats":{"Line":0}},{"line":45,"address":[19241796],"length":1,"stats":{"Line":0}},{"line":47,"address":[16888754],"length":1,"stats":{"Line":0}},{"line":48,"address":[15456608,15456738,15457080],"length":1,"stats":{"Line":0}},{"line":49,"address":[15456562],"length":1,"stats":{"Line":0}},{"line":58,"address":[17105073,17104078,17104144,17104765,17104408,17106289,17104218,17104513,17104867,17104274],"length":1,"stats":{"Line":0}},{"line":59,"address":[16333034,16333367,16332920,16332877],"length":1,"stats":{"Line":0}},{"line":60,"address":[16890245],"length":1,"stats":{"Line":0}},{"line":61,"address":[16890472,16890347,16890253,16890205],"length":1,"stats":{"Line":0}},{"line":62,"address":[16332523,16333793,16333219,16333421,16333308,16333581],"length":1,"stats":{"Line":0}},{"line":64,"address":[17105156,17105001],"length":1,"stats":{"Line":0}},{"line":65,"address":[16864596,16864350,16864461,16864644],"length":1,"stats":{"Line":0}},{"line":66,"address":[15459341,15459017,15459535],"length":1,"stats":{"Line":0}},{"line":67,"address":[16891884],"length":1,"stats":{"Line":0}},{"line":70,"address":[16891483],"length":1,"stats":{"Line":0}},{"line":73,"address":[17107327,17106339,17106442,17106678,17106304,17107286],"length":1,"stats":{"Line":0}},{"line":74,"address":[16335907,16335511,16335773,16336239,16335977,16335595,16336564,16336341,16335721],"length":1,"stats":{"Line":0}},{"line":75,"address":[15460282,15460318],"length":1,"stats":{"Line":0}},{"line":76,"address":[11650902,11651423,11650990,11651116],"length":1,"stats":{"Line":0}},{"line":77,"address":[11651124,11651200],"length":1,"stats":{"Line":0}},{"line":78,"address":[17107032,17107264,17107080,17106782,17107174],"length":1,"stats":{"Line":0}},{"line":79,"address":[11189236],"length":1,"stats":{"Line":0}},{"line":81,"address":[15461099],"length":1,"stats":{"Line":0}},{"line":84,"address":[17108827,17107875,17108786,17107978,17107840,17108214],"length":1,"stats":{"Line":0}},{"line":85,"address":[16337217,16337407,16337273,16337477,16337841,16337118,16337739,16338064,16337047],"length":1,"stats":{"Line":0}},{"line":86,"address":[16337078,16337252,16337563,16337126],"length":1,"stats":{"Line":0}},{"line":87,"address":[17108492,17108572],"length":1,"stats":{"Line":0}},{"line":88,"address":[17108764,17108674,17108580,17108318,17108532],"length":1,"stats":{"Line":0}},{"line":89,"address":[11215860],"length":1,"stats":{"Line":0}},{"line":91,"address":[15462559],"length":1,"stats":{"Line":0}},{"line":94,"address":[15463132,15462771,15462882,15462736,15463498],"length":1,"stats":{"Line":0}},{"line":95,"address":[17109880,17110381,17110587,17109947,17111808,17109809,17110279,17110052],"length":1,"stats":{"Line":0}},{"line":96,"address":[17110104,17109982,17109888,17109840],"length":1,"stats":{"Line":0}},{"line":97,"address":[16339095,16339307,16338285,16338847,16338758,16338935],"length":1,"stats":{"Line":0}},{"line":99,"address":[16896419,16896574],"length":1,"stats":{"Line":0}},{"line":100,"address":[16869864,16869975,16870110,16870158],"length":1,"stats":{"Line":0}},{"line":101,"address":[17111474,17111022,17111313],"length":1,"stats":{"Line":0}},{"line":102,"address":[11655591],"length":1,"stats":{"Line":0}},{"line":103,"address":[17111584],"length":1,"stats":{"Line":0}},{"line":106,"address":[17111076],"length":1,"stats":{"Line":0}},{"line":109,"address":[11606911],"length":1,"stats":{"Line":0}},{"line":110,"address":[16871524,16872172,16871440,16871840,16872500,16871706,16871650,16872277,16871910],"length":1,"stats":{"Line":0}},{"line":111,"address":[16871511,16871551],"length":1,"stats":{"Line":0}},{"line":112,"address":[16898207,16898295,16898421,16898732],"length":1,"stats":{"Line":0}},{"line":113,"address":[15465881,15465801],"length":1,"stats":{"Line":0}},{"line":114,"address":[16871733,16871965,16871781,16871479,16871875],"length":1,"stats":{"Line":0}},{"line":115,"address":[17112892,17112715,17113284,17113052,17112769,17111992],"length":1,"stats":{"Line":0}},{"line":117,"address":[16872371],"length":1,"stats":{"Line":0}},{"line":125,"address":[17114091,17114525,17114196,17113878,17113957,17114731,17114423,17115930],"length":1,"stats":{"Line":0}},{"line":126,"address":[15467188],"length":1,"stats":{"Line":0}},{"line":127,"address":[17114021],"length":1,"stats":{"Line":0}},{"line":128,"address":[15467273,15467362,15467476,15467153],"length":1,"stats":{"Line":0}},{"line":129,"address":[11658351,11658599,11658811,11658439,11657683,11658262],"length":1,"stats":{"Line":0}},{"line":131,"address":[16900563,16900718],"length":1,"stats":{"Line":0}},{"line":132,"address":[16874254,16874302,16874008,16874119],"length":1,"stats":{"Line":0}},{"line":133,"address":[16874843,16874334,16874625],"length":1,"stats":{"Line":0}},{"line":134,"address":[11659749],"length":1,"stats":{"Line":0}},{"line":137,"address":[17115220],"length":1,"stats":{"Line":0}},{"line":140,"address":[12137486],"length":1,"stats":{"Line":0}},{"line":141,"address":[15469752,15470064,15470178,15469586,15469657,15469849,15470360,15471503],"length":1,"stats":{"Line":0}},{"line":142,"address":[15469689],"length":1,"stats":{"Line":0}},{"line":143,"address":[15469783,15469897,15469617,15469697],"length":1,"stats":{"Line":0}},{"line":144,"address":[19252116],"length":1,"stats":{"Line":0}},{"line":146,"address":[17117176,17117331],"length":1,"stats":{"Line":0}},{"line":147,"address":[15470564,15470735,15470691,15470461],"length":1,"stats":{"Line":0}},{"line":148,"address":[16903587,16903878,16904096],"length":1,"stats":{"Line":0}},{"line":149,"address":[15471218],"length":1,"stats":{"Line":0}},{"line":152,"address":[15470821],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":87},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","queries.rs"],"content":"﻿pub(super) const INSERT_BOOKMARK: &str = r#\"\n    INSERT INTO bookmarks (id, user_pubkey, post_id, created_at)\n    VALUES (?1, ?2, ?3, ?4)\n    ON CONFLICT(user_pubkey, post_id) DO NOTHING\n\"#;\n\npub(super) const DELETE_BOOKMARK: &str = r#\"\n    DELETE FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARK_BY_USER_AND_POST: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?1 AND post_id = ?2\n\"#;\n\npub(super) const SELECT_BOOKMARKS_BY_USER: &str = r#\"\n    SELECT id, user_pubkey, post_id, created_at\n    FROM bookmarks\n    WHERE user_pubkey = ?\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const INSERT_POST_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at)\n    VALUES (?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_POST_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE event_id = ? AND kind = 1\n\"#;\n\npub(super) const SELECT_POSTS_BY_TOPIC: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND tags LIKE '%' || ? || '%'\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const UPDATE_POST_CONTENT: &str = r#\"\n    UPDATE events\n    SET content = ?, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const MARK_POST_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    AND (sync_status IS NULL OR sync_status = 0)\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_POST_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, sync_event_id = ?, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_POSTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1 AND public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_RECENT_POSTS: &str = r#\"\n    SELECT event_id, public_key, content, created_at, tags\n    FROM events\n    WHERE kind = 1\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const INSERT_TOPIC: &str = r#\"\n    INSERT INTO topics (topic_id, name, description, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_TOPIC_BY_ID: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count\n    FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const SELECT_ALL_TOPICS: &str = r#\"\n    SELECT topic_id, name, description, created_at, updated_at, member_count, post_count\n    FROM topics\n    ORDER BY created_at ASC\n\"#;\n\npub(super) const SELECT_JOINED_TOPICS: &str = r#\"\n    SELECT t.topic_id, t.name, t.description, t.created_at, t.updated_at, t.member_count, t.post_count\n    FROM topics t\n    INNER JOIN user_topics ut ON t.topic_id = ut.topic_id\n    WHERE ut.is_joined = 1 AND ut.user_pubkey = ?\n    ORDER BY t.created_at ASC\n\"#;\n\npub(super) const UPDATE_TOPIC: &str = r#\"\n    UPDATE topics\n    SET name = ?, description = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_USER_TOPICS_BY_TOPIC: &str = r#\"\n    DELETE FROM user_topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const DELETE_TOPIC: &str = r#\"\n    DELETE FROM topics\n    WHERE topic_id = ?\n\"#;\n\npub(super) const UPSERT_USER_TOPIC: &str = r#\"\n    INSERT INTO user_topics (topic_id, user_pubkey, is_joined, joined_at, left_at)\n    VALUES (?1, ?2, 1, ?3, NULL)\n    ON CONFLICT(topic_id, user_pubkey) DO UPDATE SET\n        is_joined = 1,\n        joined_at = excluded.joined_at,\n        left_at = NULL\n\"#;\n\npub(super) const SELECT_TOPIC_MEMBER_COUNT: &str = r#\"\n    SELECT COUNT(*) as count\n    FROM user_topics\n    WHERE topic_id = ?1 AND is_joined = 1\n\"#;\n\npub(super) const UPDATE_TOPIC_MEMBER_COUNT: &str = r#\"\n    UPDATE topics\n    SET member_count = ?1, updated_at = ?2\n    WHERE topic_id = ?3\n\"#;\n\npub(super) const MARK_TOPIC_LEFT: &str = r#\"\n    UPDATE user_topics\n    SET is_joined = 0, left_at = ?1\n    WHERE topic_id = ?2 AND user_pubkey = ?3\n\"#;\n\npub(super) const UPDATE_TOPIC_STATS: &str = r#\"\n    UPDATE topics\n    SET member_count = ?, post_count = ?, updated_at = ?\n    WHERE topic_id = ?\n\"#;\n\npub(super) const INSERT_USER: &str = r#\"\n    INSERT INTO users (npub, pubkey, display_name, bio, avatar_url, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_USER_BY_NPUB: &str = r#\"\n    SELECT npub, pubkey, display_name, bio, avatar_url, created_at, updated_at\n    FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_USER_BY_PUBKEY: &str = r#\"\n    SELECT npub, pubkey, display_name, bio, avatar_url, created_at, updated_at\n    FROM users\n    WHERE pubkey = ?\n\"#;\n\npub(super) const UPDATE_USER: &str = r#\"\n    UPDATE users\n    SET display_name = ?, bio = ?, avatar_url = ?, updated_at = ?\n    WHERE npub = ?\n\"#;\n\npub(super) const DELETE_USER: &str = r#\"\n    DELETE FROM users\n    WHERE npub = ?\n\"#;\n\npub(super) const SELECT_FOLLOWERS: &str = r#\"\n    SELECT u.npub, u.pubkey, u.display_name, u.bio, u.avatar_url, u.created_at, u.updated_at\n    FROM users u\n    INNER JOIN follows f ON u.pubkey = f.follower_pubkey\n    WHERE f.followed_pubkey = (SELECT pubkey FROM users WHERE npub = ?)\n\"#;\n\npub(super) const SELECT_FOLLOWING: &str = r#\"\n    SELECT u.npub, u.pubkey, u.display_name, u.bio, u.avatar_url, u.created_at, u.updated_at\n    FROM users u\n    INNER JOIN follows f ON u.pubkey = f.followed_pubkey\n    WHERE f.follower_pubkey = (SELECT pubkey FROM users WHERE npub = ?)\n\"#;\n\npub(super) const INSERT_EVENT: &str = r#\"\n    INSERT INTO events (event_id, public_key, content, kind, tags, created_at, sig)\n    VALUES (?, ?, ?, ?, ?, ?, ?)\n\"#;\n\npub(super) const SELECT_EVENT_BY_ID: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_KIND: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE kind = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const SELECT_EVENTS_BY_AUTHOR: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE public_key = ?\n    ORDER BY created_at DESC\n    LIMIT ?\n\"#;\n\npub(super) const MARK_EVENT_DELETED: &str = r#\"\n    UPDATE events\n    SET deleted = 1, updated_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const SELECT_UNSYNC_EVENTS: &str = r#\"\n    SELECT event_id, public_key, content, kind, tags, created_at, sig\n    FROM events\n    WHERE sync_status IS NULL OR sync_status = 0\n    ORDER BY created_at DESC\n\"#;\n\npub(super) const MARK_EVENT_SYNCED: &str = r#\"\n    UPDATE events\n    SET sync_status = 1, synced_at = ?\n    WHERE event_id = ?\n\"#;\n\npub(super) const INSERT_EVENT_TOPIC: &str = r#\"\n    INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at)\n    VALUES (?1, ?2, ?3)\n\"#;\n\npub(super) const SELECT_EVENT_TOPICS: &str = r#\"\n    SELECT topic_id FROM event_topics WHERE event_id = ?1\n\"#;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","topics.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::{map_joined_topic_row, map_topic_row};\nuse super::queries::{\n    DELETE_TOPIC, DELETE_USER_TOPICS_BY_TOPIC, INSERT_TOPIC, MARK_TOPIC_LEFT, SELECT_ALL_TOPICS,\n    SELECT_JOINED_TOPICS, SELECT_TOPIC_BY_ID, SELECT_TOPIC_MEMBER_COUNT, UPDATE_TOPIC,\n    UPDATE_TOPIC_MEMBER_COUNT, UPDATE_TOPIC_STATS, UPSERT_USER_TOPIC,\n};\nuse crate::domain::entities::Topic;\nuse crate::infrastructure::database::TopicRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::Row;\n\n#[async_trait]\nimpl TopicRepository for SqliteRepository {\n    async fn create_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(INSERT_TOPIC)\n            .bind(&topic.id)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.created_at.timestamp_millis())\n            .bind(topic.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_topic(&self, id: &str) -> Result<Option<Topic>, AppError> {\n        let row = sqlx::query(SELECT_TOPIC_BY_ID)\n            .bind(id)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_topic_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_all_topics(&self) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_ALL_TOPICS)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn get_joined_topics(&self, user_pubkey: &str) -> Result<Vec<Topic>, AppError> {\n        let rows = sqlx::query(SELECT_JOINED_TOPICS)\n            .bind(user_pubkey)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut topics = Vec::with_capacity(rows.len());\n        for row in rows {\n            let topic = map_joined_topic_row(&row)?;\n            topics.push(topic);\n        }\n\n        Ok(topics)\n    }\n\n    async fn update_topic(&self, topic: &Topic) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC)\n            .bind(&topic.name)\n            .bind(&topic.description)\n            .bind(topic.updated_at.timestamp_millis())\n            .bind(&topic.id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_topic(&self, id: &str) -> Result<(), AppError> {\n        if id == \"public\" {\n            return Err(\"デフォルトトピックは削除できません\".into());\n        }\n\n        sqlx::query(DELETE_USER_TOPICS_BY_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        sqlx::query(DELETE_TOPIC)\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn join_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(UPSERT_USER_TOPIC)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .bind(now)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn leave_topic(&self, topic_id: &str, user_pubkey: &str) -> Result<(), AppError> {\n        if topic_id == \"public\" {\n            return Err(\"デフォルトトピックから離脱することはできません\".into());\n        }\n\n        let now = Utc::now().timestamp_millis();\n        let mut tx = self.pool.get_pool().begin().await?;\n\n        sqlx::query(MARK_TOPIC_LEFT)\n            .bind(now)\n            .bind(topic_id)\n            .bind(user_pubkey)\n            .execute(&mut *tx)\n            .await?;\n\n        let member_count: i64 = sqlx::query(SELECT_TOPIC_MEMBER_COUNT)\n            .bind(topic_id)\n            .fetch_one(&mut *tx)\n            .await?\n            .try_get(\"count\")?;\n\n        sqlx::query(UPDATE_TOPIC_MEMBER_COUNT)\n            .bind(member_count)\n            .bind(now)\n            .bind(topic_id)\n            .execute(&mut *tx)\n            .await?;\n\n        tx.commit().await?;\n        Ok(())\n    }\n\n    async fn update_topic_stats(\n        &self,\n        id: &str,\n        member_count: u32,\n        post_count: u32,\n    ) -> Result<(), AppError> {\n        sqlx::query(UPDATE_TOPIC_STATS)\n            .bind(member_count as i64)\n            .bind(post_count as i64)\n            .bind(Utc::now().timestamp_millis())\n            .bind(id)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":17,"address":[11607150],"length":1,"stats":{"Line":0}},{"line":18,"address":[14538633,14538239,14538821,14538314,14538394,14538354,14538751,14539110,14539435,14539212,14538504],"length":1,"stats":{"Line":0}},{"line":19,"address":[14779137],"length":1,"stats":{"Line":0}},{"line":20,"address":[14565077],"length":1,"stats":{"Line":0}},{"line":21,"address":[14008021,14007981],"length":1,"stats":{"Line":0}},{"line":22,"address":[14779261,14779777,14779371,14779102],"length":1,"stats":{"Line":0}},{"line":23,"address":[14008273,14008516,14008155],"length":1,"stats":{"Line":0}},{"line":24,"address":[14008386,14008289,14008475],"length":1,"stats":{"Line":0}},{"line":25,"address":[14259586,14260143,14259620,14258765,14259767,14259918],"length":1,"stats":{"Line":0}},{"line":27,"address":[14566042],"length":1,"stats":{"Line":0}},{"line":30,"address":[18720633],"length":1,"stats":{"Line":0}},{"line":31,"address":[14009633,14009534,14010958,14009455,14010073,14009738,14009965,14010357],"length":1,"stats":{"Line":0}},{"line":32,"address":[17910737,17910782],"length":1,"stats":{"Line":0}},{"line":33,"address":[17910790,17910884,17911006,17910702],"length":1,"stats":{"Line":0}},{"line":34,"address":[11216084],"length":1,"stats":{"Line":0}},{"line":36,"address":[14261395],"length":1,"stats":{"Line":0}},{"line":37,"address":[14781672,14782122,14781774],"length":1,"stats":{"Line":0}},{"line":38,"address":[14010394],"length":1,"stats":{"Line":0}},{"line":42,"address":[12164425],"length":1,"stats":{"Line":0}},{"line":43,"address":[14012203,14011496,14011425,14011997,14011563,14011895,14011668,14013372],"length":1,"stats":{"Line":0}},{"line":44,"address":[14011598,14011504,14011720,14011456],"length":1,"stats":{"Line":0}},{"line":45,"address":[14262799,14263035,14262253,14263235,14262883,14262730],"length":1,"stats":{"Line":0}},{"line":47,"address":[14569422,14569267],"length":1,"stats":{"Line":0}},{"line":48,"address":[17913528,17913774,17913822,17913639],"length":1,"stats":{"Line":0}},{"line":49,"address":[14012901,14012654,14013117],"length":1,"stats":{"Line":0}},{"line":50,"address":[14264111],"length":1,"stats":{"Line":0}},{"line":53,"address":[14783896],"length":1,"stats":{"Line":0}},{"line":56,"address":[14784754,14785008,14784608,14784643,14785430],"length":1,"stats":{"Line":0}},{"line":57,"address":[14571155,14571487,14571056,14572964,14571795,14570977,14571589,14571260],"length":1,"stats":{"Line":0}},{"line":58,"address":[14013907,14013952],"length":1,"stats":{"Line":0}},{"line":59,"address":[14544272,14544454,14544576,14544360],"length":1,"stats":{"Line":0}},{"line":60,"address":[14014239,14014611,14014062,14014399,14014151,14013549],"length":1,"stats":{"Line":0}},{"line":62,"address":[14265722,14265583],"length":1,"stats":{"Line":0}},{"line":63,"address":[14266018,14265974,14265744,14265847],"length":1,"stats":{"Line":0}},{"line":64,"address":[14572493,14572709,14572246],"length":1,"stats":{"Line":0}},{"line":65,"address":[14786751],"length":1,"stats":{"Line":0}},{"line":68,"address":[14545520],"length":1,"stats":{"Line":0}},{"line":71,"address":[14266768,14267138,14266803,14267737,14267768,14266906],"length":1,"stats":{"Line":0}},{"line":72,"address":[17917574,17917614,17917983,17918337,17917495,17917727,17918235,17917779,17918560,17917913],"length":1,"stats":{"Line":0}},{"line":73,"address":[14787577],"length":1,"stats":{"Line":0}},{"line":74,"address":[14016385,14016425],"length":1,"stats":{"Line":0}},{"line":75,"address":[14788085,14787778,14787542,14787665],"length":1,"stats":{"Line":0}},{"line":76,"address":[14267542,14267470],"length":1,"stats":{"Line":0}},{"line":77,"address":[17918038,17917806,17917854,17917948],"length":1,"stats":{"Line":0}},{"line":78,"address":[14017067,14017296,14016794,14016005,14016907,14016740],"length":1,"stats":{"Line":0}},{"line":80,"address":[14268096],"length":1,"stats":{"Line":0}},{"line":83,"address":[14018251,14017392,14017530,14017427,14017784,14018329],"length":1,"stats":{"Line":0}},{"line":84,"address":[14017840],"length":1,"stats":{"Line":0}},{"line":85,"address":[17919476,17919128],"length":1,"stats":{"Line":0}},{"line":88,"address":[14268873,14269034,14269592,14268757,14269321,14269419,14269903,14268972],"length":1,"stats":{"Line":0}},{"line":89,"address":[14575164,14575124],"length":1,"stats":{"Line":0}},{"line":90,"address":[14548539,14548629,14548353,14548436],"length":1,"stats":{"Line":0}},{"line":91,"address":[14789932,14789433,14788789,14789593,14789379,14789753],"length":1,"stats":{"Line":0}},{"line":93,"address":[14270011,14270109,14270332,14269673,14269772,14269834,14269513],"length":1,"stats":{"Line":0}},{"line":94,"address":[14575956,14575996],"length":1,"stats":{"Line":0}},{"line":95,"address":[14576193,14576004,14576107,14575921],"length":1,"stats":{"Line":0}},{"line":96,"address":[10693662],"length":1,"stats":{"Line":0}},{"line":98,"address":[14790623],"length":1,"stats":{"Line":0}},{"line":101,"address":[14549968,14550497,14550159,14550021,14551869,14550814],"length":1,"stats":{"Line":0}},{"line":102,"address":[14550569],"length":1,"stats":{"Line":0}},{"line":103,"address":[14271043,14272242,14270586,14271226,14271107,14271706],"length":1,"stats":{"Line":0}},{"line":105,"address":[14551307,14551516,14552012,14551555,14551664,14551779,14551473,14552120,14552293,14552652],"length":1,"stats":{"Line":0}},{"line":106,"address":[14551458],"length":1,"stats":{"Line":0}},{"line":107,"address":[17922316],"length":1,"stats":{"Line":0}},{"line":108,"address":[14551543,14551582],"length":1,"stats":{"Line":0}},{"line":109,"address":[14272063,14271954,14271787,14272204],"length":1,"stats":{"Line":0}},{"line":110,"address":[17922523,17922713,17921020,17922628,17922876,17923061],"length":1,"stats":{"Line":0}},{"line":112,"address":[14579933,14580566,14579636,14580083,14579528,14579116,14579225,14579852,14578950,14579295],"length":1,"stats":{"Line":0}},{"line":113,"address":[14579101,14579143],"length":1,"stats":{"Line":0}},{"line":114,"address":[14793162,14793356,14793452,14793247],"length":1,"stats":{"Line":0}},{"line":115,"address":[11190648],"length":1,"stats":{"Line":0}},{"line":118,"address":[14554432,14553455,14553384,14553645,14553494,14554058,14553950,14553536,14554311,14553715],"length":1,"stats":{"Line":0}},{"line":120,"address":[17924298],"length":1,"stats":{"Line":0}},{"line":121,"address":[14794395,14794353],"length":1,"stats":{"Line":0}},{"line":122,"address":[14794512,14794247,14794608,14794403],"length":1,"stats":{"Line":0}},{"line":123,"address":[17924504,17921056,17924814,17924651,17924564,17925079],"length":1,"stats":{"Line":0}},{"line":125,"address":[10689900],"length":1,"stats":{"Line":0}},{"line":126,"address":[14554721],"length":1,"stats":{"Line":0}},{"line":129,"address":[18721103],"length":1,"stats":{"Line":0}},{"line":130,"address":[14025176],"length":1,"stats":{"Line":0}},{"line":131,"address":[14025505,14025235],"length":1,"stats":{"Line":0}},{"line":134,"address":[14555676,14555616],"length":1,"stats":{"Line":0}},{"line":135,"address":[14582531,14581920,14583240,14582471,14582742,14583780],"length":1,"stats":{"Line":0}},{"line":137,"address":[14277225,14277110,14277572,14276916,14277001,14276757,14277745,14278088,14276958,14277458],"length":1,"stats":{"Line":0}},{"line":138,"address":[14276904],"length":1,"stats":{"Line":0}},{"line":139,"address":[17927479],"length":1,"stats":{"Line":0}},{"line":140,"address":[14277028,14276985],"length":1,"stats":{"Line":0}},{"line":141,"address":[14026606,14026356,14026189,14026465],"length":1,"stats":{"Line":0}},{"line":142,"address":[14562930],"length":1,"stats":{"Line":0}},{"line":144,"address":[14558375,14558294,14557731,14558078,14558525,14557661,14559008,14557386,14557964,14557552],"length":1,"stats":{"Line":0}},{"line":145,"address":[17928395,17928353],"length":1,"stats":{"Line":0}},{"line":146,"address":[14027392,14027187,14027102,14027296],"length":1,"stats":{"Line":0}},{"line":147,"address":[17928580,17928665,17928520,17928828,17929062,17926036],"length":1,"stats":{"Line":0}},{"line":150,"address":[14799960,14799546,14800074,14799655,14799504,14800449,14799725,14800327,14799465,14799394],"length":1,"stats":{"Line":0}},{"line":152,"address":[17929476],"length":1,"stats":{"Line":0}},{"line":153,"address":[14028341,14028299],"length":1,"stats":{"Line":0}},{"line":154,"address":[14278830,14278986,14279095,14279191],"length":1,"stats":{"Line":0}},{"line":155,"address":[14585912,14586183,14585602,14581974,14585749,14585662],"length":1,"stats":{"Line":0}},{"line":157,"address":[17930156,17930345,17926072,17930438,17930822],"length":1,"stats":{"Line":0}},{"line":158,"address":[14800745],"length":1,"stats":{"Line":0}},{"line":167,"address":[14281596,14280939,14280974,14281348,14281286,14281917,14281156,14281100,14280857,14281694],"length":1,"stats":{"Line":0}},{"line":168,"address":[14030315],"length":1,"stats":{"Line":0}},{"line":169,"address":[14280970,14281001],"length":1,"stats":{"Line":0}},{"line":170,"address":[14561225,14560668,14560915,14560789],"length":1,"stats":{"Line":0}},{"line":171,"address":[17931739,17931819],"length":1,"stats":{"Line":0}},{"line":172,"address":[14801937,14801795,14801508,14802026,14801843],"length":1,"stats":{"Line":0}},{"line":173,"address":[11442420],"length":1,"stats":{"Line":0}},{"line":175,"address":[14281788],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":108},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","sqlite_repository","users.rs"],"content":"use super::SqliteRepository;\nuse super::mapper::map_user_row;\nuse super::queries::{\n    DELETE_USER, INSERT_USER, SELECT_FOLLOWERS, SELECT_FOLLOWING, SELECT_USER_BY_NPUB,\n    SELECT_USER_BY_PUBKEY, UPDATE_USER,\n};\nuse crate::domain::entities::User;\nuse crate::infrastructure::database::UserRepository;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\nimpl UserRepository for SqliteRepository {\n    async fn create_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(INSERT_USER)\n            .bind(user.npub())\n            .bind(user.pubkey())\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(user.created_at.timestamp_millis())\n            .bind(user.updated_at.timestamp_millis())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_user(&self, npub: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_NPUB)\n            .bind(npub)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn get_user_by_pubkey(&self, pubkey: &str) -> Result<Option<User>, AppError> {\n        let row = sqlx::query(SELECT_USER_BY_PUBKEY)\n            .bind(pubkey)\n            .fetch_optional(self.pool.get_pool())\n            .await?;\n\n        match row {\n            Some(row) => Ok(Some(map_user_row(&row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn update_user(&self, user: &User) -> Result<(), AppError> {\n        sqlx::query(UPDATE_USER)\n            .bind(&user.profile.display_name)\n            .bind(&user.profile.bio)\n            .bind(&user.profile.avatar_url)\n            .bind(user.updated_at.timestamp_millis())\n            .bind(user.npub())\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn delete_user(&self, npub: &str) -> Result<(), AppError> {\n        sqlx::query(DELETE_USER)\n            .bind(npub)\n            .execute(self.pool.get_pool())\n            .await?;\n\n        Ok(())\n    }\n\n    async fn get_followers(&self, npub: &str) -> Result<Vec<User>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWERS)\n            .bind(npub)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut users = Vec::with_capacity(rows.len());\n        for row in rows {\n            let user = map_user_row(&row)?;\n            users.push(user);\n        }\n\n        Ok(users)\n    }\n\n    async fn get_following(&self, npub: &str) -> Result<Vec<User>, AppError> {\n        let rows = sqlx::query(SELECT_FOLLOWING)\n            .bind(npub)\n            .fetch_all(self.pool.get_pool())\n            .await?;\n\n        let mut users = Vec::with_capacity(rows.len());\n        for row in rows {\n            let user = map_user_row(&row)?;\n            users.push(user);\n        }\n\n        Ok(users)\n    }\n}\n","traces":[{"line":14,"address":[12379134],"length":1,"stats":{"Line":0}},{"line":15,"address":[15864197,15863923,15863857,15864312,15864425,15864672,15864272,15864141,15864742,15865187,15865085,15865410,15864009,15864554],"length":1,"stats":{"Line":0}},{"line":16,"address":[12493115,12493228,12493072,12494104],"length":1,"stats":{"Line":0}},{"line":17,"address":[12734076,12734192,12734904],"length":1,"stats":{"Line":0}},{"line":18,"address":[15472316],"length":1,"stats":{"Line":0}},{"line":19,"address":[15864259],"length":1,"stats":{"Line":0}},{"line":20,"address":[12520259,12520219],"length":1,"stats":{"Line":0}},{"line":21,"address":[12493531,12494050,12493644,12493408],"length":1,"stats":{"Line":0}},{"line":22,"address":[12734610,12734853,12734492],"length":1,"stats":{"Line":0}},{"line":23,"address":[12734812,12734626,12734723],"length":1,"stats":{"Line":0}},{"line":24,"address":[11430308],"length":1,"stats":{"Line":0}},{"line":26,"address":[12494465],"length":1,"stats":{"Line":0}},{"line":29,"address":[12165113],"length":1,"stats":{"Line":0}},{"line":30,"address":[12495517,12495290,12495909,12495086,12495185,12495625,12496512,12495007],"length":1,"stats":{"Line":0}},{"line":31,"address":[12735950,12735905],"length":1,"stats":{"Line":0}},{"line":32,"address":[11964726,11964942,11964820,11964638],"length":1,"stats":{"Line":0}},{"line":33,"address":[12736397,12736693,12736060,12735649,12736149,12736237],"length":1,"stats":{"Line":0}},{"line":35,"address":[12736659],"length":1,"stats":{"Line":0}},{"line":36,"address":[12523180,12522830,12522728],"length":1,"stats":{"Line":0}},{"line":37,"address":[12736778],"length":1,"stats":{"Line":0}},{"line":41,"address":[15476096,15475542,15475427,15475690,15475392],"length":1,"stats":{"Line":0}},{"line":42,"address":[12737727,12738629,12739232,12737806,12738237,12738345,12738010,12737905],"length":1,"stats":{"Line":0}},{"line":43,"address":[12737838,12737793],"length":1,"stats":{"Line":0}},{"line":44,"address":[12523662,12523844,12523966,12523750],"length":1,"stats":{"Line":0}},{"line":45,"address":[15867932,15868021,15868109,15868269,15867521,15868565],"length":1,"stats":{"Line":0}},{"line":47,"address":[12497715],"length":1,"stats":{"Line":0}},{"line":48,"address":[12738712,12738814,12739164],"length":1,"stats":{"Line":0}},{"line":49,"address":[12524570],"length":1,"stats":{"Line":0}},{"line":53,"address":[12525546,12525187,12526290,12525152,12526350,12525298],"length":1,"stats":{"Line":0}},{"line":54,"address":[12740299,12739786,12739826,12740590,12740692,12740915,12739979,12740111,12739707,12740229,12739866],"length":1,"stats":{"Line":0}},{"line":55,"address":[12525677],"length":1,"stats":{"Line":0}},{"line":56,"address":[11968581],"length":1,"stats":{"Line":0}},{"line":57,"address":[15869877,15869837],"length":1,"stats":{"Line":0}},{"line":58,"address":[11968782,11968669,11968506,11969192],"length":1,"stats":{"Line":0}},{"line":59,"address":[11968798,11968919,11969163],"length":1,"stats":{"Line":0}},{"line":60,"address":[11969032,11969122,11968935],"length":1,"stats":{"Line":0}},{"line":61,"address":[10688948],"length":1,"stats":{"Line":0}},{"line":63,"address":[12740786],"length":1,"stats":{"Line":0}},{"line":66,"address":[12741314,12741090,12741697,12740960,12740995],"length":1,"stats":{"Line":0}},{"line":67,"address":[12527283,12527359,12527855,12527458,12527753,12528078,12527528],"length":1,"stats":{"Line":0}},{"line":68,"address":[12527346,12527391],"length":1,"stats":{"Line":0}},{"line":69,"address":[15871479,15871394,15871573,15871659],"length":1,"stats":{"Line":0}},{"line":70,"address":[14560404],"length":1,"stats":{"Line":0}},{"line":72,"address":[15479949],"length":1,"stats":{"Line":0}},{"line":75,"address":[12138681],"length":1,"stats":{"Line":0}},{"line":76,"address":[15482484,15481075,15481371,15481189,15480668,15480763,15480589,15480860],"length":1,"stats":{"Line":0}},{"line":77,"address":[15872739,15872784],"length":1,"stats":{"Line":0}},{"line":78,"address":[15480708,15480794,15480908,15480620],"length":1,"stats":{"Line":0}},{"line":79,"address":[12502255,12502415,12502078,12502167,12502627,12501565],"length":1,"stats":{"Line":0}},{"line":81,"address":[12743435,12743590],"length":1,"stats":{"Line":0}},{"line":82,"address":[15481702,15481472,15481746,15481575],"length":1,"stats":{"Line":0}},{"line":83,"address":[11972726,11972973,11973189],"length":1,"stats":{"Line":0}},{"line":84,"address":[12503535],"length":1,"stats":{"Line":0}},{"line":87,"address":[11972736],"length":1,"stats":{"Line":0}},{"line":90,"address":[12530592,12530738,12530992,12530627,12531414],"length":1,"stats":{"Line":0}},{"line":91,"address":[12745331,12745436,12745663,12747140,12745153,12745971,12745765,12745232],"length":1,"stats":{"Line":0}},{"line":92,"address":[12745219,12745264],"length":1,"stats":{"Line":0}},{"line":93,"address":[12531392,12531088,12531176,12531270],"length":1,"stats":{"Line":0}},{"line":94,"address":[12504631,12505091,12504542,12504719,12504029,12504879],"length":1,"stats":{"Line":0}},{"line":96,"address":[11974822,11974667],"length":1,"stats":{"Line":0}},{"line":97,"address":[15876310,15876175,15876064,15876358],"length":1,"stats":{"Line":0}},{"line":98,"address":[15876406,15876653,15876869],"length":1,"stats":{"Line":0}},{"line":99,"address":[15484567],"length":1,"stats":{"Line":0}},{"line":102,"address":[15484172],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","database","subscription_state_repository.rs"],"content":"use crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse crate::infrastructure::database::connection_pool::ConnectionPool;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{Row, SqlitePool, sqlite::SqliteRow};\n\n#[derive(Clone)]\npub struct SqliteSubscriptionStateRepository {\n    pool: ConnectionPool,\n}\n\nimpl SqliteSubscriptionStateRepository {\n    pub fn new(pool: ConnectionPool) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &SqlitePool {\n        self.pool.get_pool()\n    }\n\n    fn row_to_record(row: SqliteRow) -> Result<SubscriptionRecord, AppError> {\n        let target_value: String = row.get(\"target\");\n        let target_type: String = row.get(\"target_type\");\n        let status: String = row.get(\"status\");\n        let last_synced_at: Option<i64> = row.get(\"last_synced_at\");\n        let last_attempt_at: Option<i64> = row.get(\"last_attempt_at\");\n        let failure_count: i64 = row.get(\"failure_count\");\n        let error_message: Option<String> = row.get(\"error_message\");\n\n        let target = SubscriptionTarget::from_parts(&target_type, target_value)?;\n        let status = SubscriptionStatus::parse(&status)?;\n\n        Ok(SubscriptionRecord {\n            target,\n            status,\n            last_synced_at,\n            last_attempt_at,\n            failure_count,\n            error_message,\n        })\n    }\n}\n\n#[async_trait]\nimpl SubscriptionStateRepository for SqliteSubscriptionStateRepository {\n    async fn upsert(&self, record: &SubscriptionRecord) -> Result<SubscriptionRecord, AppError> {\n        let (target_type, target_value) = record.target.as_parts();\n        let now_ms = Utc::now().timestamp_millis();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO nostr_subscriptions (\n                target,\n                target_type,\n                status,\n                last_synced_at,\n                last_attempt_at,\n                failure_count,\n                error_message,\n                created_at,\n                updated_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?8)\n            ON CONFLICT(target, target_type) DO UPDATE SET\n                status = excluded.status,\n                last_synced_at = excluded.last_synced_at,\n                last_attempt_at = excluded.last_attempt_at,\n                failure_count = excluded.failure_count,\n                error_message = excluded.error_message,\n                updated_at = excluded.updated_at\n            \"#,\n        )\n        .bind(target_value)\n        .bind(target_type)\n        .bind(record.status.as_str())\n        .bind(record.last_synced_at)\n        .bind(record.last_attempt_at)\n        .bind(record.failure_count)\n        .bind(record.error_message.clone())\n        .bind(now_ms)\n        .execute(self.pool())\n        .await?;\n\n        self.find(&record.target)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Subscription record missing after upsert\".into()))\n    }\n\n    async fn find(\n        &self,\n        target: &SubscriptionTarget,\n    ) -> Result<Option<SubscriptionRecord>, AppError> {\n        let (target_type, target_value) = target.as_parts();\n\n        let row = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE target_type = ?1 AND target = ?2\n            \"#,\n        )\n        .bind(target_type)\n        .bind(target_value)\n        .fetch_optional(self.pool())\n        .await?;\n\n        match row {\n            Some(row) => Ok(Some(Self::row_to_record(row)?)),\n            None => Ok(None),\n        }\n    }\n\n    async fn mark_all_need_resync(&self, updated_at_ms: i64) -> Result<(), AppError> {\n        sqlx::query(\n            r#\"\n            UPDATE nostr_subscriptions\n            SET status = 'needs_resync',\n                updated_at = ?1,\n                error_message = NULL\n            WHERE status = 'subscribed'\n            \"#,\n        )\n        .bind(updated_at_ms)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            WHERE status IN ('pending', 'needs_resync')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        let rows = sqlx::query(\n            r#\"\n            SELECT target, target_type, status, last_synced_at, last_attempt_at, failure_count, error_message\n            FROM nostr_subscriptions\n            ORDER BY target_type ASC, target ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(Self::row_to_record).collect()\n    }\n}\n","traces":[{"line":17,"address":[17899568],"length":1,"stats":{"Line":1}},{"line":21,"address":[17899584],"length":1,"stats":{"Line":3}},{"line":22,"address":[13998373],"length":1,"stats":{"Line":3}},{"line":25,"address":[13999920,14000012,13998384],"length":1,"stats":{"Line":3}},{"line":26,"address":[13998498,13998406],"length":1,"stats":{"Line":6}},{"line":27,"address":[13505350],"length":1,"stats":{"Line":3}},{"line":28,"address":[13505427],"length":1,"stats":{"Line":3}},{"line":29,"address":[14555807,14555903],"length":1,"stats":{"Line":6}},{"line":30,"address":[17900015],"length":1,"stats":{"Line":3}},{"line":31,"address":[14529286],"length":1,"stats":{"Line":3}},{"line":32,"address":[14770171],"length":1,"stats":{"Line":3}},{"line":34,"address":[14529654,14529456,14529385,14530329],"length":1,"stats":{"Line":6}},{"line":35,"address":[14556504,14556909,14556369],"length":1,"stats":{"Line":3}},{"line":37,"address":[17900770],"length":1,"stats":{"Line":2}},{"line":38,"address":[13999490],"length":1,"stats":{"Line":2}},{"line":43,"address":[17900738],"length":1,"stats":{"Line":1}},{"line":50,"address":[13624524,13625910,13624480,13624295,13624647,13625963,13624828],"length":1,"stats":{"Line":4}},{"line":51,"address":[17933086],"length":1,"stats":{"Line":1}},{"line":52,"address":[14031985],"length":1,"stats":{"Line":2}},{"line":77,"address":[13625197],"length":1,"stats":{"Line":1}},{"line":78,"address":[17933405,17933528,17934169,17933288],"length":1,"stats":{"Line":4}},{"line":79,"address":[13625332],"length":1,"stats":{"Line":1}},{"line":80,"address":[14562802],"length":1,"stats":{"Line":2}},{"line":81,"address":[17933708,17933665],"length":1,"stats":{"Line":3}},{"line":82,"address":[17933583,17933840,17934147,17933716],"length":1,"stats":{"Line":3}},{"line":83,"address":[14803926],"length":1,"stats":{"Line":1}},{"line":84,"address":[14032702,14032900,14032659,14032804],"length":1,"stats":{"Line":3}},{"line":85,"address":[11411087],"length":1,"stats":{"Line":6}},{"line":87,"address":[14804562,14805059,14805287,14804722,14805352,14804881],"length":1,"stats":{"Line":8}},{"line":88,"address":[11170274],"length":1,"stats":{"Line":9}},{"line":89,"address":[14591264,14591278],"length":1,"stats":{"Line":0}},{"line":96,"address":[17935856],"length":1,"stats":{"Line":3}},{"line":106,"address":[14565297],"length":1,"stats":{"Line":3}},{"line":107,"address":[13628188,13627985,13628074,13627863],"length":1,"stats":{"Line":6}},{"line":108,"address":[10662004],"length":1,"stats":{"Line":9}},{"line":110,"address":[14806831],"length":1,"stats":{"Line":2}},{"line":111,"address":[14566155,14566317],"length":1,"stats":{"Line":2}},{"line":112,"address":[13628767],"length":1,"stats":{"Line":1}},{"line":116,"address":[13629554,13630168,13629233,13629459,13629424,13629786],"length":1,"stats":{"Line":3}},{"line":126,"address":[14567193],"length":1,"stats":{"Line":1}},{"line":127,"address":[14593937,14594027,14593860,14594114],"length":1,"stats":{"Line":2}},{"line":128,"address":[14808273,14808131,14808185,14807629,14808433,14808662],"length":1,"stats":{"Line":4}},{"line":130,"address":[14037349],"length":1,"stats":{"Line":1}},{"line":133,"address":[14037529,14037603,14038307,14037706,14037930,14037568],"length":1,"stats":{"Line":3}},{"line":142,"address":[14568564,14568685,14568426,14568474],"length":1,"stats":{"Line":2}},{"line":143,"address":[14568133,14568907,14569166,14568748,14568661,14568572],"length":1,"stats":{"Line":4}},{"line":145,"address":[17939915,17940108],"length":1,"stats":{"Line":2}},{"line":148,"address":[14039081,14039120,14039155,14039258,14039859,14039482],"length":1,"stats":{"Line":3}},{"line":156,"address":[17940842,17940932,17940794,17941053],"length":1,"stats":{"Line":2}},{"line":157,"address":[14039813,14039285,14039724,14039900,14040059,14040318],"length":1,"stats":{"Line":4}},{"line":159,"address":[13633764,13633563],"length":1,"stats":{"Line":2}}],"covered":50,"coverable":51},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","event_manager_gateway.rs"],"content":"use crate::application::ports::event_gateway::EventGateway;\nuse crate::application::shared::mappers::{domain_event_to_nostr_event, profile_metadata_to_nostr};\nuse crate::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\nuse crate::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\nuse crate::domain::value_objects::{EventId, TopicId};\nuse crate::infrastructure::event::manager_handle::EventManagerHandle;\nuse crate::infrastructure::event::metrics::{self, GatewayMetricKind};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId};\nuse serde::Serialize;\nuse std::sync::Arc;\nuse tauri::{AppHandle, Emitter};\nuse tokio::sync::RwLock;\nuse tracing::error;\n\npub struct LegacyEventManagerGateway {\n    manager: Arc<dyn EventManagerHandle>,\n    app_handle: Arc<RwLock<Option<AppHandle>>>,\n}\n\n#[derive(Debug, Clone, Serialize)]\nstruct FrontendEventPayload {\n    id: String,\n    author: String,\n    content: String,\n    created_at: u64,\n    kind: u32,\n    tags: Vec<Vec<String>>,\n}\n\nimpl From<&NostrEvent> for FrontendEventPayload {\n    fn from(event: &NostrEvent) -> Self {\n        Self {\n            id: event.id.to_string(),\n            author: event.pubkey.to_string(),\n            content: event.content.clone(),\n            created_at: event.created_at.as_u64(),\n            kind: event.kind.as_u16() as u32,\n            tags: event.tags.iter().map(|tag| tag.clone().to_vec()).collect(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::EventKind;\n    use crate::domain::entities::event_gateway::EventTag;\n    use crate::domain::value_objects::EventId;\n    use crate::infrastructure::database::EventRepository as InfraEventRepository;\n    use crate::infrastructure::event::manager_handle::LegacyEventManagerHandle;\n    use crate::infrastructure::event::metrics;\n    use crate::infrastructure::p2p::GossipService;\n    use anyhow::{Result as AnyResult, anyhow};\n    use chrono::Utc;\n    use nostr_sdk::Timestamp;\n    use nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata};\n\n    #[derive(Default)]\n    struct TestEventManagerHandle {\n        fail_handle_event: bool,\n        fail_publish_text: bool,\n    }\n\n    impl TestEventManagerHandle {\n        fn with_handle_failure() -> Self {\n            Self {\n                fail_handle_event: true,\n                fail_publish_text: false,\n            }\n        }\n\n        fn with_publish_failure() -> Self {\n            Self {\n                fail_handle_event: false,\n                fail_publish_text: true,\n            }\n        }\n    }\n\n    #[async_trait]\n    impl EventManagerHandle for TestEventManagerHandle {\n        async fn set_gossip_service(&self, _: Arc<dyn GossipService>) {}\n\n        async fn set_event_repository(&self, _: Arc<dyn InfraEventRepository>) {}\n\n        async fn set_default_p2p_topic_id(&self, _: &str) {}\n\n        async fn set_default_p2p_topics(&self, _: Vec<String>) {}\n\n        async fn list_default_p2p_topics(&self) -> Vec<String> {\n            vec![]\n        }\n\n        async fn handle_p2p_event(&self, _: NostrEvent) -> AnyResult<()> {\n            if self.fail_handle_event {\n                Err(anyhow!(\"forced incoming failure\"))\n            } else {\n                Ok(())\n            }\n        }\n\n        async fn publish_text_note(&self, _: &str) -> AnyResult<NostrEventId> {\n            if self.fail_publish_text {\n                Err(anyhow!(\"forced publish failure\"))\n            } else {\n                Ok(sample_nostr_event_id('1'))\n            }\n        }\n\n        async fn publish_topic_post(\n            &self,\n            _: &str,\n            _: &str,\n            _: Option<NostrEventId>,\n        ) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('2'))\n        }\n\n        async fn send_reaction(&self, _: &NostrEventId, _: &str) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('3'))\n        }\n\n        async fn update_metadata(&self, _: Metadata) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('4'))\n        }\n\n        async fn delete_events(\n            &self,\n            _: Vec<NostrEventId>,\n            _: Option<String>,\n        ) -> AnyResult<NostrEventId> {\n            Ok(sample_nostr_event_id('5'))\n        }\n\n        async fn disconnect(&self) -> AnyResult<()> {\n            Ok(())\n        }\n\n        async fn get_public_key(&self) -> Option<nostr_sdk::prelude::PublicKey> {\n            None\n        }\n\n        async fn subscribe_to_topic(&self, _: &str, _: Option<Timestamp>) -> AnyResult<()> {\n            Ok(())\n        }\n\n        async fn subscribe_to_user(\n            &self,\n            _: nostr_sdk::prelude::PublicKey,\n            _: Option<Timestamp>,\n        ) -> AnyResult<()> {\n            Ok(())\n        }\n    }\n\n    fn sample_nostr_event_id(ch: char) -> NostrEventId {\n        let hex: String = std::iter::repeat(ch).take(64).collect();\n        NostrEventId::from_hex(&hex).expect(\"valid nostr id\")\n    }\n\n    fn repeating_hex(ch: char, len: usize) -> String {\n        std::iter::repeat(ch).take(len).collect()\n    }\n\n    fn sample_domain_event() -> DomainEvent {\n        let event_id = EventId::from_hex(&repeating_hex('a', 64)).expect(\"valid event id\");\n        let public_key = PublicKey::from_hex_str(&repeating_hex('b', 64)).expect(\"valid pubkey\");\n        let tags = vec![\n            EventTag::new(\"p\", vec![repeating_hex('c', 64)]).expect(\"valid p tag\"),\n            EventTag::new(\"t\", vec![\"sample\".to_string()]).expect(\"valid t tag\"),\n        ];\n        DomainEvent::new(\n            event_id,\n            public_key,\n            EventKind::TextNote,\n            Utc::now(),\n            \"sample content\".to_string(),\n            tags,\n            repeating_hex('d', 128),\n        )\n        .expect(\"valid domain event\")\n    }\n\n    #[tokio::test]\n    async fn handle_incoming_event_without_app_handle_succeeds() {\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(LegacyEventManagerHandle::new());\n        let gateway = LegacyEventManagerGateway::new(manager);\n        let event = sample_domain_event();\n\n        let result = gateway.handle_incoming_event(event).await;\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn frontend_payload_matches_nostr_event() {\n        let event = sample_domain_event();\n        let nostr_event = domain_event_to_nostr_event(&event).expect(\"domain to nostr\");\n        let payload = FrontendEventPayload::from(&nostr_event);\n\n        assert_eq!(payload.id, nostr_event.id.to_string());\n        assert_eq!(payload.author, nostr_event.pubkey.to_string());\n        assert_eq!(payload.content, nostr_event.content);\n        assert_eq!(payload.kind, nostr_event.kind.as_u16() as u32);\n        assert_eq!(payload.tags.len(), nostr_event.tags.len());\n    }\n\n    #[tokio::test]\n    async fn gateway_metrics_record_incoming_success() {\n        let _metrics_guard = metrics::test_guard();\n        metrics::reset();\n        let before = metrics::snapshot();\n        let manager: Arc<dyn EventManagerHandle> = Arc::new(TestEventManagerHandle::default());\n        let gateway = LegacyEventManagerGateway::new(manager);\n        gateway\n            .handle_incoming_event(sample_domain_event())\n            .await\n            .expect(\"incoming event succeeds\");\n\n        let snapshot = metrics::snapshot();\n        assert_eq!(snapshot.incoming.total, before.incoming.total + 1);\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures);\n    }\n\n    #[tokio::test]\n    async fn gateway_metrics_record_incoming_failure() {\n        let _metrics_guard = metrics::test_guard();\n        metrics::reset();\n        let before = metrics::snapshot();\n        let manager: Arc<dyn EventManagerHandle> =\n            Arc::new(TestEventManagerHandle::with_handle_failure());\n        let gateway = LegacyEventManagerGateway::new(manager);\n        let result = gateway.handle_incoming_event(sample_domain_event()).await;\n        assert!(result.is_err());\n\n        let snapshot = metrics::snapshot();\n        assert_eq!(snapshot.incoming.failures, before.incoming.failures + 1);\n        assert_eq!(snapshot.incoming.total, before.incoming.total);\n    }\n\n    #[tokio::test]\n    async fn gateway_metrics_record_publish_failure() {\n        let _metrics_guard = metrics::test_guard();\n        metrics::reset();\n        let before = metrics::snapshot();\n        let manager: Arc<dyn EventManagerHandle> =\n            Arc::new(TestEventManagerHandle::with_publish_failure());\n        let gateway = LegacyEventManagerGateway::new(manager);\n\n        let result = gateway.publish_text_note(\"metrics-check\").await;\n        assert!(result.is_err());\n\n        let snapshot = metrics::snapshot();\n        assert_eq!(\n            snapshot.publish_text_note.failures,\n            before.publish_text_note.failures + 1\n        );\n        assert_eq!(\n            snapshot.publish_text_note.total,\n            before.publish_text_note.total\n        );\n    }\n}\n\nimpl LegacyEventManagerGateway {\n    pub fn new(manager: Arc<dyn EventManagerHandle>) -> Self {\n        Self {\n            manager,\n            app_handle: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    fn to_nostr_event_id(event_id: &EventId) -> Result<NostrEventId, AppError> {\n        NostrEventId::from_hex(event_id.as_str())\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n\n    fn to_domain_event_id(event_id: NostrEventId) -> Result<EventId, AppError> {\n        EventId::from_hex(&event_id.to_hex())\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid event ID returned: {err}\")))\n    }\n\n    fn to_domain_public_key(pk: nostr_sdk::prelude::PublicKey) -> Result<PublicKey, AppError> {\n        PublicKey::from_hex_str(&pk.to_hex())\n            .map_err(|err| AppError::ValidationError(format!(\"Invalid public key: {err}\")))\n    }\n\n    pub async fn set_app_handle(&self, handle: AppHandle) {\n        let mut guard = self.app_handle.write().await;\n        *guard = Some(handle);\n    }\n\n    #[allow(dead_code)]\n    pub async fn clear_app_handle(&self) {\n        let mut guard = self.app_handle.write().await;\n        *guard = None;\n    }\n\n    async fn emit_frontend_event(&self, event: &NostrEvent) {\n        let handle = self.app_handle.read().await.clone();\n        if let Some(handle) = handle {\n            let payload = FrontendEventPayload::from(event);\n\n            if let Err(err) = handle.emit(\"nostr://event/p2p\", payload) {\n                error!(\"Failed to emit nostr event to frontend: {}\", err);\n            }\n        }\n    }\n}\n\n#[async_trait]\nimpl EventGateway for LegacyEventManagerGateway {\n    async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError> {\n        metrics::record_outcome(\n            async {\n                let nostr_event = domain_event_to_nostr_event(&event)?;\n                self.manager\n                    .handle_p2p_event(nostr_event.clone())\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                self.emit_frontend_event(&nostr_event).await;\n                Ok(())\n            }\n            .await,\n            GatewayMetricKind::Incoming,\n        )\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError> {\n        metrics::record_outcome(\n            async {\n                let event_id = self\n                    .manager\n                    .publish_text_note(content)\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\n            }\n            .await,\n            GatewayMetricKind::PublishTextNote,\n        )\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &TopicId,\n        content: &TopicContent,\n        reply_to: Option<&EventId>,\n    ) -> Result<EventId, AppError> {\n        metrics::record_outcome(\n            async {\n                let reply_to_converted = if let Some(reply) = reply_to {\n                    Some(Self::to_nostr_event_id(reply)?)\n                } else {\n                    None\n                };\n\n                let event_id = self\n                    .manager\n                    .publish_topic_post(topic_id.as_str(), content.as_str(), reply_to_converted)\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\n            }\n            .await,\n            GatewayMetricKind::PublishTopicPost,\n        )\n    }\n\n    async fn send_reaction(\n        &self,\n        target: &EventId,\n        reaction: &ReactionValue,\n    ) -> Result<EventId, AppError> {\n        metrics::record_outcome(\n            async {\n                let nostr_event_id = Self::to_nostr_event_id(target)?;\n                let event_id = self\n                    .manager\n                    .send_reaction(&nostr_event_id, reaction.as_str())\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\n            }\n            .await,\n            GatewayMetricKind::Reaction,\n        )\n    }\n\n    async fn update_profile_metadata(\n        &self,\n        metadata: &ProfileMetadata,\n    ) -> Result<EventId, AppError> {\n        metrics::record_outcome(\n            async {\n                let nostr_metadata = profile_metadata_to_nostr(metadata)?;\n                let event_id = self\n                    .manager\n                    .update_metadata(nostr_metadata)\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\n            }\n            .await,\n            GatewayMetricKind::MetadataUpdate,\n        )\n    }\n\n    async fn delete_events(\n        &self,\n        targets: &[EventId],\n        reason: Option<&str>,\n    ) -> Result<EventId, AppError> {\n        metrics::record_outcome(\n            async {\n                let nostr_ids = targets\n                    .iter()\n                    .map(Self::to_nostr_event_id)\n                    .collect::<Result<Vec<_>, _>>()?;\n                let event_id = self\n                    .manager\n                    .delete_events(nostr_ids, reason.map(|value| value.to_string()))\n                    .await\n                    .map_err(|err| AppError::NostrError(err.to_string()))?;\n                Self::to_domain_event_id(event_id)\n            }\n            .await,\n            GatewayMetricKind::DeleteEvents,\n        )\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        metrics::record_outcome(\n            self.manager\n                .disconnect()\n                .await\n                .map_err(|err| AppError::NostrError(err.to_string())),\n            GatewayMetricKind::Disconnect,\n        )\n    }\n\n    async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError> {\n        let maybe_pk = self.manager.get_public_key().await;\n        maybe_pk.map(Self::to_domain_public_key).transpose()\n    }\n\n    async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError> {\n        let topic_strings: Vec<String> = topics\n            .iter()\n            .map(|topic| topic.as_str().to_string())\n            .collect();\n        self.manager.set_default_p2p_topics(topic_strings).await;\n        Ok(())\n    }\n\n    async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError> {\n        let topics = self.manager.list_default_p2p_topics().await;\n        topics\n            .into_iter()\n            .map(|t| {\n                TopicId::new(t).map_err(|err| {\n                    AppError::ValidationError(format!(\"Invalid topic identifier returned: {err}\"))\n                })\n            })\n            .collect()\n    }\n}\n","traces":[{"line":33,"address":[12364376,12363856],"length":1,"stats":{"Line":1}},{"line":35,"address":[15493870],"length":1,"stats":{"Line":1}},{"line":36,"address":[11592677],"length":1,"stats":{"Line":1}},{"line":37,"address":[19825587],"length":1,"stats":{"Line":1}},{"line":38,"address":[12123209],"length":1,"stats":{"Line":1}},{"line":39,"address":[12150010],"length":1,"stats":{"Line":1}},{"line":40,"address":[11593214,11592910,11593168],"length":1,"stats":{"Line":3}},{"line":267,"address":[15494667,15494480],"length":1,"stats":{"Line":1}},{"line":270,"address":[12364539,12364620],"length":1,"stats":{"Line":2}},{"line":274,"address":[12364720],"length":1,"stats":{"Line":0}},{"line":275,"address":[12123918],"length":1,"stats":{"Line":0}},{"line":276,"address":[12123986,12123968],"length":1,"stats":{"Line":0}},{"line":279,"address":[11593863,11593712],"length":1,"stats":{"Line":0}},{"line":280,"address":[19826568,19826642],"length":1,"stats":{"Line":0}},{"line":281,"address":[15495058,15495104,15495126,15494979],"length":1,"stats":{"Line":0}},{"line":284,"address":[12151280,12151431],"length":1,"stats":{"Line":0}},{"line":285,"address":[12151304,12151373],"length":1,"stats":{"Line":0}},{"line":286,"address":[12151410,12151331,12151456,12151478],"length":1,"stats":{"Line":0}},{"line":289,"address":[12151981,12151792,12151747,12152794,12151817,12151712,12152166,12152815],"length":1,"stats":{"Line":0}},{"line":290,"address":[11018305],"length":1,"stats":{"Line":0}},{"line":291,"address":[11595612,11595639,11595283],"length":1,"stats":{"Line":0}},{"line":295,"address":[12126128,12126136,12126441,12126300,12126971,12126144,12126169,12126263],"length":1,"stats":{"Line":0}},{"line":296,"address":[19828686,19828753,19828643,19828860],"length":1,"stats":{"Line":0}},{"line":297,"address":[12367517,12367757,12367784],"length":1,"stats":{"Line":0}},{"line":300,"address":[12368015,12367856,12368066,12367887,12367837,12367824,12370926,12368228],"length":1,"stats":{"Line":4}},{"line":301,"address":[11240436],"length":1,"stats":{"Line":2}},{"line":302,"address":[12127870,12127965],"length":1,"stats":{"Line":2}},{"line":303,"address":[12127934],"length":1,"stats":{"Line":0}},{"line":305,"address":[15500919,15498830],"length":1,"stats":{"Line":0}},{"line":306,"address":[15499061,15498960,15514457,15499562,15514591],"length":1,"stats":{"Line":0}},{"line":314,"address":[19920658,19920428,19920035,19920000,19920146,19920259,19920969,19919935],"length":1,"stats":{"Line":4}},{"line":316,"address":[12145354,12144986,12144794,12145263,12146028,12144683,12146566,12145418,12145216],"length":1,"stats":{"Line":5}},{"line":317,"address":[12172676,12172064,12172204,12172376],"length":1,"stats":{"Line":2}},{"line":318,"address":[12146280,12146415,12145604,12145817,12145884,12146182],"length":1,"stats":{"Line":6}},{"line":319,"address":[12145780],"length":1,"stats":{"Line":1}},{"line":320,"address":[11406916],"length":1,"stats":{"Line":3}},{"line":321,"address":[12146383,12146818,12146800],"length":1,"stats":{"Line":3}},{"line":322,"address":[11615005,11616175,11615952,11616049],"length":1,"stats":{"Line":2}},{"line":323,"address":[11616357],"length":1,"stats":{"Line":1}},{"line":325,"address":[12171455,12171560,12171085,12171620,12171754],"length":1,"stats":{"Line":3}},{"line":326,"address":[12385910],"length":1,"stats":{"Line":1}},{"line":330,"address":[12147059,12147146,12147370,12147868,12147024,12146979,12147553],"length":1,"stats":{"Line":3}},{"line":332,"address":[19923909,19923398,19923635,19923222,19923154,19923710,19924409,19923600,19923750],"length":1,"stats":{"Line":5}},{"line":333,"address":[12388805,12389274,12389450,12388941,12389560,12389000,12389172],"length":1,"stats":{"Line":7}},{"line":335,"address":[12388928],"length":1,"stats":{"Line":1}},{"line":336,"address":[19924083,19923845,19923941,19923885,19923737],"length":1,"stats":{"Line":3}},{"line":337,"address":[15519568,15519586,15519405],"length":1,"stats":{"Line":3}},{"line":338,"address":[19924217,19924331],"length":1,"stats":{"Line":0}},{"line":340,"address":[14509876],"length":1,"stats":{"Line":3}},{"line":341,"address":[19923480],"length":1,"stats":{"Line":1}},{"line":352,"address":[12151342,12149695,12150856,12149904,12150143,12149427,12150050,12149951,12149514],"length":1,"stats":{"Line":0}},{"line":353,"address":[12390845,12390970,12391207,12390925],"length":1,"stats":{"Line":0}},{"line":354,"address":[12391022,12391209,12391308,12390955],"length":1,"stats":{"Line":0}},{"line":356,"address":[12176866],"length":1,"stats":{"Line":0}},{"line":359,"address":[19926885,19926592,19926420,19926920,19926067,19926357,19926718],"length":1,"stats":{"Line":0}},{"line":361,"address":[12150581],"length":1,"stats":{"Line":0}},{"line":362,"address":[12176816,12177624,12177564,12177777,12177517],"length":1,"stats":{"Line":0}},{"line":363,"address":[12392192,12392098,12392210],"length":1,"stats":{"Line":0}},{"line":364,"address":[12392164,12392043],"length":1,"stats":{"Line":0}},{"line":366,"address":[19925252,19925163,19925378,19925197,19924821],"length":1,"stats":{"Line":0}},{"line":367,"address":[12176517],"length":1,"stats":{"Line":0}},{"line":377,"address":[12178814,12180376,12179200,12179323,12179896,12179238,12178995,12179363,12178742],"length":1,"stats":{"Line":0}},{"line":378,"address":[12152674,12153081,12152816,12152561],"length":1,"stats":{"Line":0}},{"line":379,"address":[12153297,12152975,12153034,12153405,12153596,12152783,12153635],"length":1,"stats":{"Line":0}},{"line":381,"address":[15523721],"length":1,"stats":{"Line":0}},{"line":382,"address":[11161412],"length":1,"stats":{"Line":0}},{"line":383,"address":[11623264,11623164,11623282],"length":1,"stats":{"Line":0}},{"line":384,"address":[15524446,15524325],"length":1,"stats":{"Line":0}},{"line":386,"address":[14501188],"length":1,"stats":{"Line":0}},{"line":387,"address":[12179081],"length":1,"stats":{"Line":0}},{"line":396,"address":[12182671,12181271,12181590,12181030,12181639,12181507,12181090,12181472,12182131],"length":1,"stats":{"Line":0}},{"line":397,"address":[12395779,12395950,12395653,12396211],"length":1,"stats":{"Line":0}},{"line":398,"address":[19931003,19930780,19931393,19930588,19931113,19930835,19931280],"length":1,"stats":{"Line":0}},{"line":400,"address":[12181965],"length":1,"stats":{"Line":0}},{"line":401,"address":[12182095,12182052,12182163,12182308,12181617],"length":1,"stats":{"Line":0}},{"line":402,"address":[12182704,12182722,12182517],"length":1,"stats":{"Line":0}},{"line":403,"address":[12155726],"length":1,"stats":{"Line":0}},{"line":405,"address":[19929859,19929948,19929557,19929893,19930074],"length":1,"stats":{"Line":0}},{"line":406,"address":[11624221],"length":1,"stats":{"Line":0}},{"line":416,"address":[11626267,11626532,11626351,11626774,11626942,11627650,11626736,11626890,11627678],"length":1,"stats":{"Line":0}},{"line":417,"address":[15528875,15528215,15528459,15528049],"length":1,"stats":{"Line":0}},{"line":420,"address":[11627211],"length":1,"stats":{"Line":0}},{"line":421,"address":[12184622,12184713,12185241,12185050,12184946,12184314,12185364],"length":1,"stats":{"Line":0}},{"line":423,"address":[12157745,12157938,12158018,12158656,12158678],"length":1,"stats":{"Line":0}},{"line":424,"address":[19933673,19932769,19933416,19933374,19933533],"length":1,"stats":{"Line":0}},{"line":425,"address":[11628304,11628073,11628322],"length":1,"stats":{"Line":0}},{"line":426,"address":[12399250],"length":1,"stats":{"Line":0}},{"line":428,"address":[11626564,11626324,11625989,11626378,11626434],"length":1,"stats":{"Line":0}},{"line":429,"address":[12157018],"length":1,"stats":{"Line":0}},{"line":433,"address":[11628512,11629091,11628547,11628640,11629446,11628903,11628473],"length":1,"stats":{"Line":0}},{"line":435,"address":[15530269,15530535,15530179,15530455],"length":1,"stats":{"Line":0}},{"line":437,"address":[11364916],"length":1,"stats":{"Line":0}},{"line":438,"address":[12159874,12159856],"length":1,"stats":{"Line":0}},{"line":439,"address":[12400570],"length":1,"stats":{"Line":0}},{"line":443,"address":[12160025,12160099,12160625,12161028,12160437,12160064,12160186],"length":1,"stats":{"Line":0}},{"line":444,"address":[12401489,12401045,12401329],"length":1,"stats":{"Line":0}},{"line":445,"address":[15531675],"length":1,"stats":{"Line":0}},{"line":448,"address":[11631128,11631576,11630704,11630659,11630859,11631863,11630745],"length":1,"stats":{"Line":0}},{"line":449,"address":[15532499,15532416],"length":1,"stats":{"Line":0}},{"line":451,"address":[19937667,19937632],"length":1,"stats":{"Line":0}},{"line":453,"address":[12188562,12188486,12188744,12188022],"length":1,"stats":{"Line":0}},{"line":454,"address":[19937494],"length":1,"stats":{"Line":0}},{"line":457,"address":[12189168,12189541,12189129,12189729,12190109,12189203,12189290],"length":1,"stats":{"Line":0}},{"line":458,"address":[12403857,12403413,12403697],"length":1,"stats":{"Line":0}},{"line":459,"address":[12189959],"length":1,"stats":{"Line":0}},{"line":461,"address":[12163392],"length":1,"stats":{"Line":0}},{"line":462,"address":[19938752,19938982,19938704],"length":1,"stats":{"Line":0}},{"line":463,"address":[19938774,19938834],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":108},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","manager_handle.rs"],"content":"use crate::infrastructure::database::{\n    EventRepository as InfraEventRepository, connection_pool::ConnectionPool,\n};\nuse crate::infrastructure::p2p::GossipService;\nuse crate::modules::event::manager::EventManager;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse nostr_sdk::Timestamp;\nuse nostr_sdk::prelude::{Event as NostrEvent, EventId as NostrEventId, Metadata, PublicKey};\nuse std::sync::Arc;\n\n#[async_trait]\npub trait EventManagerHandle: Send + Sync {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>);\n    async fn set_event_repository(&self, repo: Arc<dyn InfraEventRepository>);\n    async fn set_default_p2p_topic_id(&self, topic_id: &str);\n    async fn set_default_p2p_topics(&self, topics: Vec<String>);\n    async fn list_default_p2p_topics(&self) -> Vec<String>;\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()>;\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId>;\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n    ) -> Result<NostrEventId>;\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId>;\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId>;\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId>;\n    async fn disconnect(&self) -> Result<()>;\n    async fn get_public_key(&self) -> Option<PublicKey>;\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()>;\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()>;\n}\n\n#[derive(Clone)]\npub struct LegacyEventManagerHandle {\n    inner: Arc<EventManager>,\n}\n\nimpl LegacyEventManagerHandle {\n    #[allow(dead_code)]\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(EventManager::new()),\n        }\n    }\n\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        Self {\n            inner: Arc::new(EventManager::new_with_connection_pool(pool)),\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn from_arc(inner: Arc<EventManager>) -> Self {\n        Self { inner }\n    }\n\n    #[allow(dead_code)]\n    pub fn into_trait_arc(self) -> Arc<dyn EventManagerHandle> {\n        Arc::new(self)\n    }\n\n    #[allow(dead_code)]\n    pub fn as_event_manager(&self) -> Arc<EventManager> {\n        Arc::clone(&self.inner)\n    }\n}\n\n#[async_trait]\nimpl EventManagerHandle for LegacyEventManagerHandle {\n    async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        self.inner.set_gossip_service(gossip).await;\n    }\n\n    async fn set_event_repository(&self, repo: Arc<dyn InfraEventRepository>) {\n        self.inner.set_event_repository(repo).await;\n    }\n\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\n        self.inner.set_default_p2p_topic_id(topic_id).await;\n    }\n\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.inner.set_default_p2p_topics(topics).await;\n    }\n\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.inner.list_default_p2p_topics().await\n    }\n\n    async fn handle_p2p_event(&self, event: NostrEvent) -> Result<()> {\n        self.inner.handle_p2p_event(event).await\n    }\n\n    async fn publish_text_note(&self, content: &str) -> Result<NostrEventId> {\n        self.inner.publish_text_note(content).await\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n    ) -> Result<NostrEventId> {\n        self.inner\n            .publish_topic_post(topic_id, content, reply_to)\n            .await\n    }\n\n    async fn send_reaction(&self, target: &NostrEventId, reaction: &str) -> Result<NostrEventId> {\n        self.inner.send_reaction(target, reaction).await\n    }\n\n    async fn update_metadata(&self, metadata: Metadata) -> Result<NostrEventId> {\n        self.inner.update_metadata(metadata).await\n    }\n\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> Result<NostrEventId> {\n        self.inner.delete_events(target_ids, reason).await\n    }\n\n    async fn disconnect(&self) -> Result<()> {\n        self.inner.disconnect().await\n    }\n\n    async fn get_public_key(&self) -> Option<PublicKey> {\n        self.inner.get_public_key().await\n    }\n\n    async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_topic(topic_id, since).await\n    }\n\n    async fn subscribe_to_user(&self, pubkey: PublicKey, since: Option<Timestamp>) -> Result<()> {\n        self.inner.subscribe_to_user(pubkey, since).await\n    }\n}\n","traces":[{"line":47,"address":[14467824],"length":1,"stats":{"Line":1}},{"line":49,"address":[15239060],"length":1,"stats":{"Line":1}},{"line":53,"address":[15239088],"length":1,"stats":{"Line":0}},{"line":55,"address":[14467868],"length":1,"stats":{"Line":0}},{"line":60,"address":[14467904],"length":1,"stats":{"Line":0}},{"line":65,"address":[14998320],"length":1,"stats":{"Line":0}},{"line":66,"address":[14467925],"length":1,"stats":{"Line":0}},{"line":70,"address":[11738944],"length":1,"stats":{"Line":0}},{"line":71,"address":[14467957],"length":1,"stats":{"Line":0}},{"line":77,"address":[14543227,14542799,14542864,14543449,14543470,14542889,14543031],"length":1,"stats":{"Line":0}},{"line":78,"address":[15100194,15100395,15100151,15100257],"length":1,"stats":{"Line":0}},{"line":81,"address":[15314848,15315211,15315454,15315015,15315433,15314783,15314873],"length":1,"stats":{"Line":0}},{"line":82,"address":[14516235],"length":1,"stats":{"Line":0}},{"line":85,"address":[15315694,15315609,15315734,15315891,15315535,15315584,15316109],"length":1,"stats":{"Line":0}},{"line":86,"address":[11390025],"length":1,"stats":{"Line":0}},{"line":89,"address":[15316823,15316844,15316365,15316143,15316208,15316233,15316593],"length":1,"stats":{"Line":0}},{"line":90,"address":[14518068],"length":1,"stats":{"Line":0}},{"line":93,"address":[18447081,18447273,18446944,18447448,18447739,18446895,18446979],"length":1,"stats":{"Line":0}},{"line":94,"address":[11838760,11838632,11838404],"length":1,"stats":{"Line":0}},{"line":97,"address":[14546640,14546665,14546559,14546773,14547307,14547571,14547010,14546869],"length":1,"stats":{"Line":4}},{"line":98,"address":[15318032,15318381,15318571,15318320],"length":1,"stats":{"Line":2}},{"line":101,"address":[15105603,15104799,15104913,15104995,15105144,15105338,15104848],"length":1,"stats":{"Line":0}},{"line":102,"address":[14511575],"length":1,"stats":{"Line":0}},{"line":111,"address":[11841447,11841756,11841484,11841582],"length":1,"stats":{"Line":0}},{"line":112,"address":[18450288],"length":1,"stats":{"Line":0}},{"line":113,"address":[11169831],"length":1,"stats":{"Line":0}},{"line":116,"address":[11842163,11842308,11842490,11842743,11842016,11842081,11841955],"length":1,"stats":{"Line":0}},{"line":117,"address":[15321239,15321054,15321406],"length":1,"stats":{"Line":0}},{"line":120,"address":[15107664,15107729,15108006,15108143,15108445,15107850,15108728,15107582],"length":1,"stats":{"Line":0}},{"line":121,"address":[15322381,15322573,15321973,15322320],"length":1,"stats":{"Line":0}},{"line":129,"address":[19189457],"length":1,"stats":{"Line":0}},{"line":132,"address":[15325130,15324505,15324708,15324480,15324431,15324577,15324884],"length":1,"stats":{"Line":0}},{"line":133,"address":[11156103],"length":1,"stats":{"Line":0}},{"line":136,"address":[18455200,18455399,18455623,18455314,18455476,18455151,18455884,18455235],"length":1,"stats":{"Line":0}},{"line":137,"address":[18455341,18455415,18455525,18455655],"length":1,"stats":{"Line":0}},{"line":140,"address":[15326790,15326544,15326175,15325982,15326048,15326103,15326306],"length":1,"stats":{"Line":0}},{"line":141,"address":[19198839],"length":1,"stats":{"Line":0}},{"line":144,"address":[15112750,15113628,15112832,15113090,15113384,15112887,15112959],"length":1,"stats":{"Line":0}},{"line":145,"address":[10628503],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":39},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","metrics.rs"],"content":"use crate::shared::error::AppError;\nuse serde::Serialize;\n#[cfg(test)]\nuse std::cell::Cell;\nuse std::sync::atomic::{AtomicU64, Ordering};\n#[cfg(test)]\nuse std::sync::{Mutex, OnceLock};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nconst UNSET_TS: u64 = 0;\n\n#[derive(Debug)]\nstruct AtomicMetric {\n    success: AtomicU64,\n    failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n}\n\nimpl AtomicMetric {\n    const fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(UNSET_TS),\n            last_failure_ms: AtomicU64::new(UNSET_TS),\n        }\n    }\n\n    fn record_success(&self) {\n        self.success.fetch_add(1, Ordering::Relaxed);\n        self.last_success_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    fn record_failure(&self) {\n        self.failure.fetch_add(1, Ordering::Relaxed);\n        self.last_failure_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    fn snapshot(&self) -> GatewayMetricSnapshot {\n        GatewayMetricSnapshot {\n            total: self.success.load(Ordering::Relaxed),\n            failures: self.failure.load(Ordering::Relaxed),\n            last_success_ms: to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n        }\n    }\n\n    fn reset(&self) {\n        self.success.store(0, Ordering::Relaxed);\n        self.failure.store(0, Ordering::Relaxed);\n        self.last_success_ms.store(UNSET_TS, Ordering::Relaxed);\n        self.last_failure_ms.store(UNSET_TS, Ordering::Relaxed);\n    }\n}\n\nstatic INCOMING_EVENTS: AtomicMetric = AtomicMetric::new();\nstatic PUBLISH_TEXT: AtomicMetric = AtomicMetric::new();\nstatic PUBLISH_TOPIC: AtomicMetric = AtomicMetric::new();\nstatic SEND_REACTION: AtomicMetric = AtomicMetric::new();\nstatic UPDATE_METADATA: AtomicMetric = AtomicMetric::new();\nstatic DELETE_EVENTS: AtomicMetric = AtomicMetric::new();\nstatic DISCONNECT: AtomicMetric = AtomicMetric::new();\n\n#[cfg(test)]\nstatic TEST_LOCK: OnceLock<Mutex<()>> = OnceLock::new();\n#[cfg(test)]\nthread_local! {\n    static LOCK_DEPTH: Cell<u32> = Cell::new(0);\n}\n\n#[cfg(test)]\npub(crate) struct MetricsGuard {\n    guard: Option<std::sync::MutexGuard<'static, ()>>,\n}\n\n#[cfg(test)]\nimpl Drop for MetricsGuard {\n    fn drop(&mut self) {\n        LOCK_DEPTH.with(|depth| {\n            let current = depth.get();\n            depth.set(current.saturating_sub(1));\n        });\n    }\n}\n\n#[cfg(test)]\nfn lock_guard() -> MetricsGuard {\n    LOCK_DEPTH.with(|depth| {\n        let current = depth.get();\n        depth.set(current + 1);\n        if current == 0 {\n            MetricsGuard {\n                guard: Some(\n                    TEST_LOCK\n                        .get_or_init(|| Mutex::new(()))\n                        .lock()\n                        .expect(\"event metrics lock\"),\n                ),\n            }\n        } else {\n            MetricsGuard { guard: None }\n        }\n    })\n}\n\n#[cfg(not(test))]\nstruct MetricsGuard;\n\n#[cfg(not(test))]\nfn lock_guard() -> MetricsGuard {\n    MetricsGuard\n}\n\n#[cfg(test)]\npub fn test_guard() -> MetricsGuard {\n    lock_guard()\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum GatewayMetricKind {\n    Incoming,\n    PublishTextNote,\n    PublishTopicPost,\n    Reaction,\n    MetadataUpdate,\n    DeleteEvents,\n    Disconnect,\n}\n\nfn metric(kind: GatewayMetricKind) -> &'static AtomicMetric {\n    match kind {\n        GatewayMetricKind::Incoming => &INCOMING_EVENTS,\n        GatewayMetricKind::PublishTextNote => &PUBLISH_TEXT,\n        GatewayMetricKind::PublishTopicPost => &PUBLISH_TOPIC,\n        GatewayMetricKind::Reaction => &SEND_REACTION,\n        GatewayMetricKind::MetadataUpdate => &UPDATE_METADATA,\n        GatewayMetricKind::DeleteEvents => &DELETE_EVENTS,\n        GatewayMetricKind::Disconnect => &DISCONNECT,\n    }\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct GatewayMetricSnapshot {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct EventGatewayMetrics {\n    pub incoming: GatewayMetricSnapshot,\n    pub publish_text_note: GatewayMetricSnapshot,\n    pub publish_topic_post: GatewayMetricSnapshot,\n    pub reactions: GatewayMetricSnapshot,\n    pub metadata_updates: GatewayMetricSnapshot,\n    pub deletions: GatewayMetricSnapshot,\n    pub disconnects: GatewayMetricSnapshot,\n}\n\nfn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|duration| duration.as_millis() as u64)\n        .unwrap_or(UNSET_TS)\n}\n\nfn to_option(value: u64) -> Option<u64> {\n    if value == UNSET_TS { None } else { Some(value) }\n}\n\npub fn record_success(kind: GatewayMetricKind) {\n    let _guard = lock_guard();\n    metric(kind).record_success();\n}\n\npub fn record_failure(kind: GatewayMetricKind) {\n    let _guard = lock_guard();\n    metric(kind).record_failure();\n}\n\npub fn record_outcome<T>(\n    result: Result<T, AppError>,\n    kind: GatewayMetricKind,\n) -> Result<T, AppError> {\n    match result {\n        Ok(value) => {\n            record_success(kind);\n            Ok(value)\n        }\n        Err(err) => {\n            record_failure(kind);\n            Err(err)\n        }\n    }\n}\n\npub fn snapshot() -> EventGatewayMetrics {\n    let _guard = lock_guard();\n    EventGatewayMetrics {\n        incoming: INCOMING_EVENTS.snapshot(),\n        publish_text_note: PUBLISH_TEXT.snapshot(),\n        publish_topic_post: PUBLISH_TOPIC.snapshot(),\n        reactions: SEND_REACTION.snapshot(),\n        metadata_updates: UPDATE_METADATA.snapshot(),\n        deletions: DELETE_EVENTS.snapshot(),\n        disconnects: DISCONNECT.snapshot(),\n    }\n}\n\n#[allow(dead_code)]\npub fn reset() {\n    let _guard = lock_guard();\n    INCOMING_EVENTS.reset();\n    PUBLISH_TEXT.reset();\n    PUBLISH_TOPIC.reset();\n    SEND_REACTION.reset();\n    UPDATE_METADATA.reset();\n    DELETE_EVENTS.reset();\n    DISCONNECT.reset();\n}\n","traces":[{"line":21,"address":[16607216],"length":1,"stats":{"Line":0}},{"line":23,"address":[19442862],"length":1,"stats":{"Line":0}},{"line":24,"address":[18671654],"length":1,"stats":{"Line":0}},{"line":25,"address":[16607278],"length":1,"stats":{"Line":0}},{"line":26,"address":[19228838],"length":1,"stats":{"Line":0}},{"line":30,"address":[19228928],"length":1,"stats":{"Line":1}},{"line":31,"address":[19228942],"length":1,"stats":{"Line":1}},{"line":32,"address":[16607431,16607458],"length":1,"stats":{"Line":2}},{"line":33,"address":[13987200],"length":1,"stats":{"Line":1}},{"line":36,"address":[19443120],"length":1,"stats":{"Line":1}},{"line":37,"address":[16607502],"length":1,"stats":{"Line":1}},{"line":38,"address":[19202358,19202331],"length":1,"stats":{"Line":2}},{"line":39,"address":[19229076],"length":1,"stats":{"Line":1}},{"line":42,"address":[16607584],"length":1,"stats":{"Line":1}},{"line":44,"address":[19229150],"length":1,"stats":{"Line":1}},{"line":45,"address":[13987398],"length":1,"stats":{"Line":1}},{"line":46,"address":[16607666],"length":1,"stats":{"Line":1}},{"line":47,"address":[18672107],"length":1,"stats":{"Line":1}},{"line":51,"address":[19202608],"length":1,"stats":{"Line":1}},{"line":52,"address":[13987581],"length":1,"stats":{"Line":1}},{"line":53,"address":[19229380],"length":1,"stats":{"Line":1}},{"line":54,"address":[19443503],"length":1,"stats":{"Line":1}},{"line":55,"address":[19443530],"length":1,"stats":{"Line":1}},{"line":71,"address":[16799409],"length":1,"stats":{"Line":1}},{"line":90,"address":[16608032],"length":1,"stats":{"Line":1}},{"line":91,"address":[16608048,16608033],"length":1,"stats":{"Line":2}},{"line":92,"address":[16608062],"length":1,"stats":{"Line":1}},{"line":93,"address":[16608076,16608114],"length":1,"stats":{"Line":1}},{"line":94,"address":[16608215,16608107],"length":1,"stats":{"Line":2}},{"line":95,"address":[16608197],"length":1,"stats":{"Line":1}},{"line":96,"address":[16608185],"length":1,"stats":{"Line":1}},{"line":97,"address":[16608130],"length":1,"stats":{"Line":1}},{"line":98,"address":[16608256,16608260],"length":1,"stats":{"Line":2}},{"line":104,"address":[16608217],"length":1,"stats":{"Line":1}},{"line":118,"address":[16608304],"length":1,"stats":{"Line":1}},{"line":119,"address":[16608305],"length":1,"stats":{"Line":1}},{"line":133,"address":[18672352],"length":1,"stats":{"Line":1}},{"line":134,"address":[18672488,18672359],"length":1,"stats":{"Line":2}},{"line":135,"address":[13987752],"length":1,"stats":{"Line":1}},{"line":136,"address":[18672406],"length":1,"stats":{"Line":1}},{"line":137,"address":[18672420],"length":1,"stats":{"Line":0}},{"line":138,"address":[19443666],"length":1,"stats":{"Line":0}},{"line":139,"address":[19202848],"length":1,"stats":{"Line":0}},{"line":140,"address":[13987822],"length":1,"stats":{"Line":0}},{"line":141,"address":[19443708],"length":1,"stats":{"Line":0}},{"line":164,"address":[18672496],"length":1,"stats":{"Line":1}},{"line":165,"address":[19202900],"length":1,"stats":{"Line":1}},{"line":167,"address":[16608559,16608544],"length":1,"stats":{"Line":2}},{"line":171,"address":[19203008],"length":1,"stats":{"Line":1}},{"line":172,"address":[19203018],"length":1,"stats":{"Line":1}},{"line":175,"address":[19443904],"length":1,"stats":{"Line":1}},{"line":176,"address":[18672684],"length":1,"stats":{"Line":1}},{"line":177,"address":[16608724,16608676],"length":1,"stats":{"Line":2}},{"line":180,"address":[19229856],"length":1,"stats":{"Line":1}},{"line":181,"address":[18672732],"length":1,"stats":{"Line":1}},{"line":182,"address":[16608804,16608852],"length":1,"stats":{"Line":2}},{"line":185,"address":[19230042,19229904,19230169,19230192,19230441],"length":1,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[16609231],"length":1,"stats":{"Line":0}},{"line":191,"address":[18672821,18673137],"length":1,"stats":{"Line":1}},{"line":192,"address":[19203289,19203628],"length":1,"stats":{"Line":1}},{"line":194,"address":[18672839,18673155],"length":1,"stats":{"Line":2}},{"line":195,"address":[19229992,19230308],"length":1,"stats":{"Line":2}},{"line":196,"address":[18672953,18673370],"length":1,"stats":{"Line":2}},{"line":201,"address":[13988832],"length":1,"stats":{"Line":1}},{"line":202,"address":[19444720],"length":1,"stats":{"Line":1}},{"line":204,"address":[16609599],"length":1,"stats":{"Line":1}},{"line":205,"address":[19203910],"length":1,"stats":{"Line":1}},{"line":206,"address":[19203927],"length":1,"stats":{"Line":1}},{"line":207,"address":[19203944],"length":1,"stats":{"Line":1}},{"line":208,"address":[13988924],"length":1,"stats":{"Line":1}},{"line":209,"address":[19203984],"length":1,"stats":{"Line":1}},{"line":210,"address":[19444836],"length":1,"stats":{"Line":1}},{"line":215,"address":[16610032,16610191],"length":1,"stats":{"Line":1}},{"line":216,"address":[19445057],"length":1,"stats":{"Line":1}},{"line":217,"address":[19204230],"length":1,"stats":{"Line":1}},{"line":218,"address":[19204242],"length":1,"stats":{"Line":1}},{"line":219,"address":[13989214],"length":1,"stats":{"Line":1}},{"line":220,"address":[19204266],"length":1,"stats":{"Line":1}},{"line":221,"address":[16610134],"length":1,"stats":{"Line":1}},{"line":222,"address":[16610148],"length":1,"stats":{"Line":1}},{"line":223,"address":[16610162],"length":1,"stats":{"Line":1}}],"covered":71,"coverable":82},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","mod.rs"],"content":"pub mod event_manager_gateway;\npub mod manager_handle;\npub mod metrics;\npub mod subscription_invoker;\n\npub use event_manager_gateway::LegacyEventManagerGateway;\npub use manager_handle::{EventManagerHandle, LegacyEventManagerHandle};\npub use subscription_invoker::EventManagerSubscriptionInvoker;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","event","subscription_invoker.rs"],"content":"use crate::application::ports::subscription_invoker::SubscriptionInvoker;\nuse crate::infrastructure::event::EventManagerHandle;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse nostr_sdk::prelude::{PublicKey, Timestamp};\nuse std::sync::Arc;\n\npub struct EventManagerSubscriptionInvoker {\n    event_manager: Arc<dyn EventManagerHandle>,\n}\n\nimpl EventManagerSubscriptionInvoker {\n    pub fn new(event_manager: Arc<dyn EventManagerHandle>) -> Self {\n        Self { event_manager }\n    }\n}\n\n#[async_trait]\nimpl SubscriptionInvoker for EventManagerSubscriptionInvoker {\n    async fn subscribe_topic(\n        &self,\n        topic_id: &str,\n        since: Option<Timestamp>,\n    ) -> Result<(), AppError> {\n        self.event_manager\n            .subscribe_to_topic(topic_id, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n\n    async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError> {\n        let public_key = PublicKey::from_hex(pubkey)?;\n        self.event_manager\n            .subscribe_to_user(public_key, since)\n            .await\n            .map_err(|err| AppError::NostrError(err.to_string()))\n    }\n}\n","traces":[{"line":13,"address":[12458896],"length":1,"stats":{"Line":0}},{"line":25,"address":[12506924,12507322,12507238,12506981,12507043],"length":1,"stats":{"Line":0}},{"line":26,"address":[12747797],"length":1,"stats":{"Line":0}},{"line":27,"address":[10647140],"length":1,"stats":{"Line":0}},{"line":28,"address":[11977024,11977042],"length":1,"stats":{"Line":0}},{"line":31,"address":[16041632,16042034,16042493,16041772,16041581,16042800,16041670],"length":1,"stats":{"Line":0}},{"line":32,"address":[12749388,12749031,12749169],"length":1,"stats":{"Line":0}},{"line":33,"address":[12508796,12508410,12508512,12508712,12508316],"length":1,"stats":{"Line":0}},{"line":35,"address":[11183044],"length":1,"stats":{"Line":0}},{"line":36,"address":[16042816,16042834],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","mod.rs"],"content":"#![allow(dead_code)]\n\npub mod cache;\npub mod crypto;\npub mod database;\npub mod event;\npub mod offline;\npub mod p2p;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mappers.rs"],"content":"use crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateRecord,\n    SyncQueueItem, SyncResult, SyncStatusRecord,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionId, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, RemoteEventId, SyncQueueId, SyncQueueStatus, SyncStatus,\n};\nuse crate::shared::error::AppError;\nuse chrono::{DateTime, Utc};\nuse serde::Deserialize;\nuse sqlx::FromRow;\n\nuse super::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\n\n#[derive(Debug, Deserialize, FromRow)]\npub struct CacheTypeAggregate {\n    pub cache_type: String,\n    pub item_count: i64,\n    pub last_synced_at: Option<i64>,\n    pub is_stale: bool,\n}\n\npub fn offline_action_from_row(row: OfflineActionRow) -> Result<OfflineActionRecord, AppError> {\n    let action_id = OfflineActionId::parse(&row.local_id).map_err(AppError::ValidationError)?;\n    let public_key =\n        PublicKey::from_hex_str(&row.user_pubkey).map_err(AppError::ValidationError)?;\n    let action_type =\n        OfflineActionType::new(row.action_type.clone()).map_err(AppError::ValidationError)?;\n    let target_id = row\n        .target_id\n        .map(|id| EntityId::new(id).map_err(AppError::ValidationError))\n        .transpose()?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.action_data)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value).map_err(AppError::ValidationError)?;\n    let sync_status = if row.is_synced {\n        SyncStatus::FullySynced\n    } else {\n        SyncStatus::Pending\n    };\n    let created_at = timestamp_to_datetime(row.created_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n    let remote_id = row\n        .remote_id\n        .map(|id| RemoteEventId::new(id).map_err(AppError::ValidationError))\n        .transpose()?;\n\n    Ok(OfflineActionRecord::new(\n        Some(row.id),\n        action_id,\n        public_key,\n        action_type,\n        target_id,\n        payload,\n        sync_status,\n        created_at,\n        synced_at,\n        remote_id,\n    ))\n}\n\npub fn cache_status_from_aggregates(\n    total_items: i64,\n    stale_items: i64,\n    aggregates: Vec<CacheTypeAggregate>,\n) -> Result<CacheStatusSnapshot, AppError> {\n    let cache_types = aggregates\n        .into_iter()\n        .map(|aggregate| {\n            let cache_type =\n                CacheType::new(aggregate.cache_type).map_err(AppError::ValidationError)?;\n            Ok(crate::domain::entities::offline::CacheTypeStatus::new(\n                cache_type,\n                try_i64_to_u64(aggregate.item_count, \"item_count\")?,\n                aggregate.last_synced_at.map(timestamp_to_datetime),\n                aggregate.is_stale,\n            ))\n        })\n        .collect::<Result<Vec<_>, AppError>>()?;\n\n    Ok(CacheStatusSnapshot::new(\n        try_i64_to_u64(total_items, \"total_items\")?,\n        try_i64_to_u64(stale_items, \"stale_items\")?,\n        cache_types,\n    ))\n}\n\npub fn sync_result_from_counts(\n    synced: i32,\n    failed: i32,\n    pending: i32,\n) -> Result<SyncResult, AppError> {\n    Ok(SyncResult::new(\n        try_i32_to_u32(synced, \"synced_count\")?,\n        try_i32_to_u32(failed, \"failed_count\")?,\n        try_i32_to_u32(pending, \"pending_count\")?,\n    ))\n}\n\npub fn sync_queue_item_from_row(row: SyncQueueItemRow) -> Result<SyncQueueItem, AppError> {\n    let id = SyncQueueId::new(row.id).map_err(AppError::ValidationError)?;\n    let action_type = OfflineActionType::new(row.action_type).map_err(AppError::ValidationError)?;\n    let payload_value: serde_json::Value = serde_json::from_str(&row.payload)\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n    let payload = OfflinePayload::new(payload_value).map_err(AppError::ValidationError)?;\n    let status = SyncQueueStatus::from(row.status.as_str());\n    let created_at = timestamp_to_datetime(row.created_at);\n    let updated_at = timestamp_to_datetime(row.updated_at);\n    let synced_at = row.synced_at.map(timestamp_to_datetime);\n\n    Ok(SyncQueueItem::new(\n        id,\n        action_type,\n        payload,\n        status,\n        try_i32_to_u32(row.retry_count, \"retry_count\")?,\n        try_i32_to_u32(row.max_retries, \"max_retries\")?,\n        created_at,\n        updated_at,\n        synced_at,\n        row.error_message,\n    ))\n}\n\npub fn cache_metadata_from_row(row: CacheMetadataRow) -> Result<CacheMetadataRecord, AppError> {\n    let cache_key = CacheKey::new(row.cache_key).map_err(AppError::ValidationError)?;\n    let cache_type = CacheType::new(row.cache_type).map_err(AppError::ValidationError)?;\n    let last_synced_at = row.last_synced_at.map(timestamp_to_datetime);\n    let last_accessed_at = row.last_accessed_at.map(timestamp_to_datetime);\n    let expiry_time = row.expiry_time.map(timestamp_to_datetime);\n    let metadata = row\n        .metadata\n        .map(|value| serde_json::from_str(&value))\n        .transpose()\n        .map_err(|err| AppError::DeserializationError(err.to_string()))?;\n\n    Ok(CacheMetadataRecord {\n        record_id: row.id,\n        cache_key,\n        cache_type,\n        last_synced_at,\n        last_accessed_at,\n        data_version: row.data_version,\n        is_stale: row.is_stale,\n        expiry_time,\n        metadata,\n    })\n}\n\npub fn optimistic_update_from_row(\n    row: OptimisticUpdateRow,\n) -> Result<OptimisticUpdateRecord, AppError> {\n    let update_id = OptimisticUpdateId::new(row.update_id).map_err(AppError::ValidationError)?;\n    let entity_type = EntityType::new(row.entity_type).map_err(AppError::ValidationError)?;\n    let entity_id = EntityId::new(row.entity_id).map_err(AppError::ValidationError)?;\n    let original_data = row\n        .original_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n    let updated_data = payload_from_json_str(&row.updated_data)?;\n    let created_at = timestamp_to_datetime(row.created_at);\n    let confirmed_at = row.confirmed_at.map(timestamp_to_datetime);\n\n    Ok(OptimisticUpdateRecord {\n        record_id: row.id,\n        update_id,\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n        is_confirmed: row.is_confirmed,\n        created_at,\n        confirmed_at,\n    })\n}\n\npub fn sync_status_from_row(row: SyncStatusRow) -> Result<SyncStatusRecord, AppError> {\n    let entity_type = EntityType::new(row.entity_type).map_err(AppError::ValidationError)?;\n    let entity_id = EntityId::new(row.entity_id).map_err(AppError::ValidationError)?;\n    let sync_status = SyncStatus::from(row.sync_status.as_str());\n    let last_local_update = timestamp_to_datetime(row.last_local_update);\n    let last_remote_sync = row.last_remote_sync.map(timestamp_to_datetime);\n    let conflict_data = row\n        .conflict_data\n        .map(|value| payload_from_json_str(&value))\n        .transpose()?;\n\n    Ok(SyncStatusRecord {\n        record_id: row.id,\n        entity_type,\n        entity_id,\n        local_version: row.local_version,\n        remote_version: row.remote_version,\n        last_local_update,\n        last_remote_sync,\n        sync_status,\n        conflict_data,\n    })\n}\n\npub fn sync_queue_id_from_i64(value: i64) -> Result<SyncQueueId, AppError> {\n    SyncQueueId::new(value).map_err(AppError::ValidationError)\n}\n\npub fn optimistic_update_id_from_string(value: String) -> Result<OptimisticUpdateId, AppError> {\n    OptimisticUpdateId::new(value).map_err(AppError::ValidationError)\n}\n\npub fn payload_from_optional_json_str(\n    value: Option<String>,\n) -> Result<Option<OfflinePayload>, AppError> {\n    value.map(|json| payload_from_json_str(&json)).transpose()\n}\n\npub fn payload_from_json_str(json: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(json).map_err(AppError::ValidationError)\n}\n\npub fn payload_to_string(payload: &OfflinePayload) -> Result<String, AppError> {\n    serde_json::to_string(payload.as_json())\n        .map_err(|err| AppError::SerializationError(err.to_string()))\n}\n\npub fn timestamp_to_datetime(ts: i64) -> DateTime<Utc> {\n    DateTime::<Utc>::from_timestamp(ts, 0)\n        .or_else(|| DateTime::<Utc>::from_timestamp_millis(ts))\n        .unwrap_or_else(Utc::now)\n}\n\npub fn try_i32_to_u32(value: i32, label: &str) -> Result<u32, AppError> {\n    value\n        .try_into()\n        .map_err(|_| AppError::ValidationError(format!(\"{label} cannot be negative\")))\n}\n\npub fn try_i64_to_u64(value: i64, label: &str) -> Result<u64, AppError> {\n    value\n        .try_into()\n        .map_err(|_| AppError::ValidationError(format!(\"{label} cannot be negative\")))\n}\n","traces":[{"line":27,"address":[19234447,19231056],"length":1,"stats":{"Line":5}},{"line":28,"address":[19234889,19231460,19231258,19231086],"length":1,"stats":{"Line":10}},{"line":29,"address":[19231572,19234837,19231434,19231776],"length":1,"stats":{"Line":8}},{"line":31,"address":[16611030,16613798,16611253,16610888],"length":1,"stats":{"Line":8}},{"line":33,"address":[19205714,19205330,19207999,19205499],"length":1,"stats":{"Line":7}},{"line":35,"address":[19235421,19235408],"length":1,"stats":{"Line":5}},{"line":37,"address":[19448780,19446626,19446890,19446488],"length":1,"stats":{"Line":5}},{"line":38,"address":[16611854,16614448,16614466],"length":1,"stats":{"Line":0}},{"line":39,"address":[19205954,19207897,19206128,19206354],"length":1,"stats":{"Line":5}},{"line":40,"address":[18675938,18676041],"length":1,"stats":{"Line":4}},{"line":41,"address":[19447275],"length":1,"stats":{"Line":1}},{"line":43,"address":[16612227],"length":1,"stats":{"Line":3}},{"line":45,"address":[19447306],"length":1,"stats":{"Line":3}},{"line":46,"address":[19206542],"length":1,"stats":{"Line":2}},{"line":47,"address":[19447405,19448168],"length":1,"stats":{"Line":3}},{"line":49,"address":[19449741,19449728],"length":1,"stats":{"Line":0}},{"line":52,"address":[19234167,19233842],"length":1,"stats":{"Line":4}},{"line":53,"address":[13991759],"length":1,"stats":{"Line":2}},{"line":54,"address":[13991786],"length":1,"stats":{"Line":3}},{"line":55,"address":[19233602],"length":1,"stats":{"Line":2}},{"line":56,"address":[19447738],"length":1,"stats":{"Line":3}},{"line":57,"address":[13991906],"length":1,"stats":{"Line":2}},{"line":58,"address":[19447818],"length":1,"stats":{"Line":3}},{"line":59,"address":[16612822],"length":1,"stats":{"Line":2}},{"line":62,"address":[13992026],"length":1,"stats":{"Line":3}},{"line":66,"address":[16615468,16614656,16615443],"length":1,"stats":{"Line":1}},{"line":71,"address":[16614712,16614959],"length":1,"stats":{"Line":1}},{"line":73,"address":[19451495,19450656],"length":1,"stats":{"Line":1}},{"line":74,"address":[18679454],"length":1,"stats":{"Line":1}},{"line":75,"address":[13994830,13995087],"length":1,"stats":{"Line":1}},{"line":76,"address":[16616174,16616113],"length":1,"stats":{"Line":2}},{"line":77,"address":[16615710],"length":1,"stats":{"Line":1}},{"line":78,"address":[18679958,18679691,18679849],"length":1,"stats":{"Line":2}},{"line":79,"address":[13995287],"length":1,"stats":{"Line":1}},{"line":85,"address":[19236348,19236443],"length":1,"stats":{"Line":2}},{"line":86,"address":[16614875,16615131,16615041,16615431],"length":1,"stats":{"Line":2}},{"line":87,"address":[16615417,16615319,16615099,16615204],"length":1,"stats":{"Line":2}},{"line":88,"address":[13994538],"length":1,"stats":{"Line":1}},{"line":92,"address":[19237440],"length":1,"stats":{"Line":0}},{"line":97,"address":[18680797],"length":1,"stats":{"Line":0}},{"line":98,"address":[16616382,16616543],"length":1,"stats":{"Line":0}},{"line":99,"address":[19451662,19451918,19451818],"length":1,"stats":{"Line":0}},{"line":100,"address":[19237979,19237739,19237919],"length":1,"stats":{"Line":0}},{"line":104,"address":[19452176,19454681],"length":1,"stats":{"Line":2}},{"line":105,"address":[19241216,19238102,19238254,19238418],"length":1,"stats":{"Line":4}},{"line":106,"address":[19241202,19238476,19238354,19238659],"length":1,"stats":{"Line":4}},{"line":107,"address":[19211897,19212035,19214413,19212299],"length":1,"stats":{"Line":4}},{"line":108,"address":[18681867,18684400,18684418],"length":1,"stats":{"Line":0}},{"line":109,"address":[16617787,16619845,16618113,16617969],"length":1,"stats":{"Line":4}},{"line":110,"address":[13997609,13997471],"length":1,"stats":{"Line":4}},{"line":111,"address":[19212681],"length":1,"stats":{"Line":2}},{"line":112,"address":[18682343],"length":1,"stats":{"Line":2}},{"line":113,"address":[18682370],"length":1,"stats":{"Line":2}},{"line":115,"address":[13998319,13998685],"length":1,"stats":{"Line":4}},{"line":117,"address":[19453633],"length":1,"stats":{"Line":2}},{"line":118,"address":[16618413],"length":1,"stats":{"Line":2}},{"line":119,"address":[18682497],"length":1,"stats":{"Line":2}},{"line":120,"address":[19453854,19453777,19453968],"length":1,"stats":{"Line":4}},{"line":121,"address":[19240310,19239977,19239834],"length":1,"stats":{"Line":4}},{"line":125,"address":[13998287],"length":1,"stats":{"Line":2}},{"line":129,"address":[19243329,19241696,19243218],"length":1,"stats":{"Line":0}},{"line":130,"address":[19457337,19455938,19456127,19455814],"length":1,"stats":{"Line":0}},{"line":131,"address":[19456403,19457323,19456063,19456223],"length":1,"stats":{"Line":0}},{"line":132,"address":[18685140],"length":1,"stats":{"Line":0}},{"line":133,"address":[19456513],"length":1,"stats":{"Line":0}},{"line":134,"address":[18685313],"length":1,"stats":{"Line":0}},{"line":135,"address":[19456577,19457240],"length":1,"stats":{"Line":0}},{"line":137,"address":[14001648,14001675],"length":1,"stats":{"Line":0}},{"line":139,"address":[16621764,16622208,16622226],"length":1,"stats":{"Line":0}},{"line":141,"address":[18685677],"length":1,"stats":{"Line":0}},{"line":142,"address":[19456806],"length":1,"stats":{"Line":0}},{"line":143,"address":[16621366],"length":1,"stats":{"Line":0}},{"line":144,"address":[14000977],"length":1,"stats":{"Line":0}},{"line":147,"address":[19242801],"length":1,"stats":{"Line":0}},{"line":148,"address":[18685671],"length":1,"stats":{"Line":0}},{"line":154,"address":[16624599,16624950,16622368],"length":1,"stats":{"Line":0}},{"line":157,"address":[19457986,19460259,19458175,19457846],"length":1,"stats":{"Line":0}},{"line":158,"address":[16622992,16622643,16622807,16624669],"length":1,"stats":{"Line":0}},{"line":159,"address":[19244497,19244717,19244328,19246131],"length":1,"stats":{"Line":0}},{"line":160,"address":[19246110,19244822,19244650,19245014],"length":1,"stats":{"Line":0}},{"line":162,"address":[14004784,14004811],"length":1,"stats":{"Line":0}},{"line":164,"address":[16623516,16623657,16623794],"length":1,"stats":{"Line":0}},{"line":165,"address":[19245219],"length":1,"stats":{"Line":0}},{"line":166,"address":[19245356],"length":1,"stats":{"Line":0}},{"line":168,"address":[19459764],"length":1,"stats":{"Line":0}},{"line":169,"address":[16623928],"length":1,"stats":{"Line":0}},{"line":170,"address":[19459495],"length":1,"stats":{"Line":0}},{"line":171,"address":[19218702],"length":1,"stats":{"Line":0}},{"line":172,"address":[19218750],"length":1,"stats":{"Line":0}},{"line":173,"address":[18688398],"length":1,"stats":{"Line":0}},{"line":174,"address":[16624134],"length":1,"stats":{"Line":0}},{"line":175,"address":[19218926],"length":1,"stats":{"Line":0}},{"line":181,"address":[19219968,19221802,19221627],"length":1,"stats":{"Line":1}},{"line":182,"address":[19221650,19220303,19220114,19219990],"length":1,"stats":{"Line":2}},{"line":183,"address":[14006596,14005199,14005359,14005534],"length":1,"stats":{"Line":2}},{"line":184,"address":[19461380,19461521],"length":1,"stats":{"Line":2}},{"line":185,"address":[19247449],"length":1,"stats":{"Line":1}},{"line":186,"address":[18690381],"length":1,"stats":{"Line":1}},{"line":187,"address":[16626718,16626008],"length":1,"stats":{"Line":1}},{"line":189,"address":[14006907,14006880],"length":1,"stats":{"Line":0}},{"line":192,"address":[19247901],"length":1,"stats":{"Line":1}},{"line":193,"address":[16626198],"length":1,"stats":{"Line":1}},{"line":194,"address":[19247754],"length":1,"stats":{"Line":1}},{"line":195,"address":[19461889],"length":1,"stats":{"Line":1}},{"line":196,"address":[19461937],"length":1,"stats":{"Line":1}},{"line":197,"address":[16626295],"length":1,"stats":{"Line":1}},{"line":200,"address":[18690717],"length":1,"stats":{"Line":1}},{"line":205,"address":[14007024],"length":1,"stats":{"Line":3}},{"line":206,"address":[18691683],"length":1,"stats":{"Line":2}},{"line":209,"address":[14007088],"length":1,"stats":{"Line":1}},{"line":210,"address":[16627310],"length":1,"stats":{"Line":1}},{"line":213,"address":[19248928],"length":1,"stats":{"Line":1}},{"line":216,"address":[14007165,14007216,14007243],"length":1,"stats":{"Line":3}},{"line":219,"address":[19463232],"length":1,"stats":{"Line":1}},{"line":220,"address":[19249160],"length":1,"stats":{"Line":1}},{"line":223,"address":[14007424],"length":1,"stats":{"Line":3}},{"line":224,"address":[16627646],"length":1,"stats":{"Line":2}},{"line":225,"address":[14007522,14007504],"length":1,"stats":{"Line":0}},{"line":228,"address":[19249440],"length":1,"stats":{"Line":2}},{"line":229,"address":[19249459],"length":1,"stats":{"Line":3}},{"line":230,"address":[16627969,16627952],"length":1,"stats":{"Line":0}},{"line":234,"address":[16628000],"length":1,"stats":{"Line":2}},{"line":235,"address":[14007847],"length":1,"stats":{"Line":2}},{"line":237,"address":[19463782,19463760],"length":1,"stats":{"Line":0}},{"line":240,"address":[19223120],"length":1,"stats":{"Line":1}},{"line":241,"address":[16628314],"length":1,"stats":{"Line":1}},{"line":243,"address":[16628374,16628352],"length":1,"stats":{"Line":0}}],"covered":82,"coverable":127},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","mod.rs"],"content":"mod mappers;\npub mod reindex_job;\nmod rows;\npub mod sqlite_store;\n\npub use reindex_job::OfflineReindexJob;\npub use sqlite_store::SqliteOfflinePersistence;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","reindex_job.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{OfflineActionFilter, OfflineActionRecord};\nuse crate::infrastructure::offline::sqlite_store::SqliteOfflinePersistence;\nuse crate::shared::error::AppError;\nuse chrono::Utc;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse tauri::Emitter;\nuse tokio::sync::Mutex;\n\npub trait ReindexEventEmitter: Send + Sync {\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String>;\n    fn emit_failure(&self, message: &str) -> Result<(), String>;\n}\n\nstruct TauriEventEmitter {\n    handle: tauri::AppHandle,\n}\n\nimpl ReindexEventEmitter for TauriEventEmitter {\n    fn emit_report(&self, report: &OfflineReindexReport) -> Result<(), String> {\n        self.handle\n            .emit(\"offline://reindex_complete\", report)\n            .map_err(|err| err.to_string())\n    }\n\n    fn emit_failure(&self, message: &str) -> Result<(), String> {\n        self.handle\n            .emit(\"offline://reindex_failed\", message.to_string())\n            .map_err(|err| err.to_string())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncConflictDigest {\n    pub entity_type: String,\n    pub entity_id: String,\n    pub sync_status: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OfflineReindexReport {\n    pub offline_action_count: usize,\n    pub queued_action_count: usize,\n    pub pending_queue_count: usize,\n    pub stale_cache_keys: Vec<String>,\n    pub optimistic_update_ids: Vec<String>,\n    pub sync_conflicts: Vec<SyncConflictDigest>,\n    pub queued_offline_action_ids: Vec<String>,\n    pub emitted_at: i64,\n}\n\npub struct OfflineReindexJob {\n    event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\n    persistence: Arc<SqliteOfflinePersistence>,\n    gate: Mutex<()>,\n}\n\nimpl OfflineReindexJob {\n    pub fn create(\n        app_handle: Option<tauri::AppHandle>,\n        persistence: Arc<SqliteOfflinePersistence>,\n    ) -> Arc<Self> {\n        let emitter = app_handle\n            .map(|handle| Arc::new(TauriEventEmitter { handle }) as Arc<dyn ReindexEventEmitter>);\n        Self::with_emitter(emitter, persistence)\n    }\n\n    pub fn with_emitter(\n        event_emitter: Option<Arc<dyn ReindexEventEmitter>>,\n        persistence: Arc<SqliteOfflinePersistence>,\n    ) -> Arc<Self> {\n        Arc::new(Self {\n            event_emitter,\n            persistence,\n            gate: Mutex::new(()),\n        })\n    }\n\n    pub fn trigger(self: &Arc<Self>) {\n        let job = Arc::clone(self);\n        tauri::async_runtime::spawn(async move {\n            job.run_guarded().await;\n        });\n    }\n\n    pub async fn reindex_once(&self) -> Result<OfflineReindexReport, AppError> {\n        let unsynced = self\n            .persistence\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\n            .await?;\n\n        let mut queued_action_count = 0usize;\n        let mut queued_local_ids = Vec::new();\n\n        for action in &unsynced {\n            if self.ensure_action_in_queue(action).await? {\n                queued_action_count += 1;\n                queued_local_ids.push(action.action_id.to_string());\n            }\n        }\n\n        let pending_queue = self.persistence.list_pending_sync_queue().await?;\n        let stale_cache = self.persistence.list_stale_cache_entries().await?;\n        let optimistic_updates = self.persistence.list_unconfirmed_updates().await?;\n        let conflicts = self.persistence.list_sync_conflicts().await?;\n\n        let report = OfflineReindexReport {\n            offline_action_count: unsynced.len(),\n            queued_action_count,\n            pending_queue_count: pending_queue.len(),\n            stale_cache_keys: stale_cache\n                .into_iter()\n                .map(|entry| entry.cache_key.to_string())\n                .collect(),\n            optimistic_update_ids: optimistic_updates\n                .into_iter()\n                .map(|item| item.update_id.to_string())\n                .collect(),\n            sync_conflicts: conflicts\n                .into_iter()\n                .map(|record| SyncConflictDigest {\n                    entity_type: record.entity_type.to_string(),\n                    entity_id: record.entity_id.to_string(),\n                    sync_status: record.sync_status.as_str().to_string(),\n                })\n                .collect(),\n            queued_offline_action_ids: queued_local_ids,\n            emitted_at: Utc::now().timestamp_millis(),\n        };\n\n        Ok(report)\n    }\n\n    async fn ensure_action_in_queue(&self, action: &OfflineActionRecord) -> Result<bool, AppError> {\n        self.persistence.ensure_action_in_sync_queue(action).await\n    }\n\n    async fn run_guarded(self: Arc<Self>) {\n        let _guard = self.gate.lock().await;\n        match self.reindex_once().await {\n            Ok(report) => self.emit_success(&report),\n            Err(err) => self.emit_failure(&err.to_string()),\n        }\n    }\n\n    fn emit_success(&self, report: &OfflineReindexReport) {\n        if let Some(emitter) = &self.event_emitter {\n            if let Err(err) = emitter.emit_report(report) {\n                tracing::warn!(\n                    target: \"offline::reindex\",\n                    error = %err,\n                    \"failed to emit offline reindex completion event\"\n                );\n            }\n        }\n        tracing::info!(\n            target: \"offline::reindex\",\n            queued = report.queued_action_count,\n            pending = report.pending_queue_count,\n            \"offline reindex completed\"\n        );\n    }\n\n    fn emit_failure(&self, message: &str) {\n        if let Some(emitter) = &self.event_emitter {\n            if let Err(err) = emitter.emit_failure(message) {\n                tracing::warn!(\n                    target: \"offline::reindex\",\n                    error = %err,\n                    \"failed to emit offline reindex failure event\"\n                );\n            }\n        }\n        tracing::error!(\n            target: \"offline::reindex\",\n            error = message,\n            \"offline reindex job failed\"\n        );\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::offline::{OfflineActionDraft, OfflineActionFilter};\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{EntityId, OfflineActionType, OfflinePayload};\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    const PUBKEY: &str = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\n\n    async fn setup_persistence() -> Arc<SqliteOfflinePersistence> {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .unwrap();\n\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\n\n        Arc::new(SqliteOfflinePersistence::new(pool))\n    }\n\n    fn sample_draft(index: u32) -> OfflineActionDraft {\n        OfflineActionDraft::new(\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\n            OfflineActionType::new(\"queue_test\".to_string()).unwrap(),\n            Some(EntityId::new(format!(\"post_{index}\")).unwrap()),\n            OfflinePayload::from_json_str(&format!(\"{{\\\"idx\\\": {index}}}\")).unwrap(),\n        )\n    }\n\n    #[tokio::test]\n    async fn test_reindex_queues_unsynced_actions() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft(1)).await.unwrap();\n        persistence.save_action(sample_draft(2)).await.unwrap();\n\n        let job = OfflineReindexJob::with_emitter(None, persistence.clone());\n\n        let report = job.reindex_once().await.unwrap();\n        assert_eq!(report.offline_action_count, 2);\n        assert_eq!(report.queued_action_count, 2);\n        assert_eq!(report.pending_queue_count, 2);\n        assert_eq!(report.queued_offline_action_ids.len(), 2);\n\n        // 再実行すると新規キュー追加は発生しない\n        let report_second = job.reindex_once().await.unwrap();\n        assert_eq!(report_second.queued_action_count, 0);\n        assert_eq!(report_second.pending_queue_count, 2);\n\n        let unsynced_after = persistence\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\n            .await\n            .unwrap();\n        assert_eq!(unsynced_after.len(), 2);\n    }\n}\n","traces":[{"line":21,"address":[17522208],"length":1,"stats":{"Line":0}},{"line":22,"address":[12307195],"length":1,"stats":{"Line":0}},{"line":24,"address":[17549040,17549024],"length":1,"stats":{"Line":0}},{"line":27,"address":[17549136],"length":1,"stats":{"Line":0}},{"line":28,"address":[16992080],"length":1,"stats":{"Line":0}},{"line":29,"address":[12307424],"length":1,"stats":{"Line":0}},{"line":30,"address":[17763392,17763376],"length":1,"stats":{"Line":0}},{"line":60,"address":[17763607,17763633,17763488],"length":1,"stats":{"Line":0}},{"line":64,"address":[17522731,17522665],"length":1,"stats":{"Line":0}},{"line":65,"address":[16992416,16992448],"length":1,"stats":{"Line":0}},{"line":66,"address":[12307701],"length":1,"stats":{"Line":0}},{"line":69,"address":[16629387,16629200,16629366],"length":1,"stats":{"Line":1}},{"line":73,"address":[16992587],"length":1,"stats":{"Line":1}},{"line":74,"address":[17763743],"length":1,"stats":{"Line":1}},{"line":75,"address":[17549657],"length":1,"stats":{"Line":1}},{"line":76,"address":[16992526],"length":1,"stats":{"Line":1}},{"line":80,"address":[17523104],"length":1,"stats":{"Line":0}},{"line":81,"address":[12308079],"length":1,"stats":{"Line":0}},{"line":82,"address":[17523660,17523209,17523322,17523285,17523442,17523184,17523133],"length":1,"stats":{"Line":0}},{"line":83,"address":[12308222,12308272,12308434,12308329],"length":1,"stats":{"Line":0}},{"line":87,"address":[17550416,17551086,17550797,17550424,17550448,17550495,17550649,17551846],"length":1,"stats":{"Line":4}},{"line":88,"address":[12309746,12309555,12310014,12309163,12309257,12308840,12309451],"length":1,"stats":{"Line":5}},{"line":90,"address":[12309078],"length":1,"stats":{"Line":1}},{"line":91,"address":[11202577],"length":1,"stats":{"Line":4}},{"line":93,"address":[17551448],"length":1,"stats":{"Line":1}},{"line":94,"address":[16630980],"length":1,"stats":{"Line":1}},{"line":96,"address":[16994595,16994483,16995339,16995275],"length":1,"stats":{"Line":4}},{"line":97,"address":[11202600],"length":1,"stats":{"Line":4}},{"line":98,"address":[17766348,17766443],"length":1,"stats":{"Line":1}},{"line":99,"address":[17525561,17525636],"length":1,"stats":{"Line":2}},{"line":103,"address":[17766544,17766839,17766636,17764817,17767437,17767196],"length":1,"stats":{"Line":3}},{"line":104,"address":[17767330,17767808,17767166,17764838,17767442,17768046],"length":1,"stats":{"Line":3}},{"line":105,"address":[17767939,17768695,17767781,17768458,17768086,17764859],"length":1,"stats":{"Line":3}},{"line":106,"address":[14332679],"length":1,"stats":{"Line":3}},{"line":109,"address":[17769076],"length":1,"stats":{"Line":1}},{"line":111,"address":[17769231],"length":1,"stats":{"Line":1}},{"line":112,"address":[12313379],"length":1,"stats":{"Line":1}},{"line":116,"address":[17528544,17528665],"length":1,"stats":{"Line":2}},{"line":120,"address":[16998319,16998430],"length":1,"stats":{"Line":2}},{"line":129,"address":[16998528,16998591],"length":1,"stats":{"Line":2}},{"line":132,"address":[17529195],"length":1,"stats":{"Line":1}},{"line":135,"address":[12315200,12315267,12315374,12315559,12315232,12315411,12315213,12315859],"length":1,"stats":{"Line":4}},{"line":136,"address":[10438887],"length":1,"stats":{"Line":3}},{"line":139,"address":[17771752,17771760,17773355,17771872,17772470,17771744,17771785,17772076],"length":1,"stats":{"Line":0}},{"line":140,"address":[17531148,17531276,17531015,17531067],"length":1,"stats":{"Line":0}},{"line":141,"address":[11197788],"length":1,"stats":{"Line":0}},{"line":142,"address":[17531978,17532191],"length":1,"stats":{"Line":0}},{"line":143,"address":[17001731,17001901],"length":1,"stats":{"Line":0}},{"line":147,"address":[17774096,17773440,17775963],"length":1,"stats":{"Line":0}},{"line":148,"address":[12317599],"length":1,"stats":{"Line":0}},{"line":149,"address":[17559431,17559531],"length":1,"stats":{"Line":0}},{"line":150,"address":[12318226,12317882,12467535,12318359,12317787,12467401],"length":1,"stats":{"Line":0}},{"line":157,"address":[17923903,17773595,17777033,17775985,17923769],"length":1,"stats":{"Line":0}},{"line":165,"address":[17007528,17009389,17006864],"length":1,"stats":{"Line":0}},{"line":166,"address":[17564031],"length":1,"stats":{"Line":0}},{"line":167,"address":[17537459,17537351],"length":1,"stats":{"Line":0}},{"line":168,"address":[16643870,16808633,16643737,16643393,16808767,16643298],"length":1,"stats":{"Line":0}},{"line":175,"address":[16809263,16809129,16643234,16645618,16646469],"length":1,"stats":{"Line":0}}],"covered":28,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","rows.rs"],"content":"use serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OfflineActionRow {\n    pub id: i64,\n    pub user_pubkey: String,\n    pub action_type: String,\n    pub target_id: Option<String>,\n    pub action_data: String,\n    pub local_id: String,\n    pub remote_id: Option<String>,\n    pub is_synced: bool,\n    pub created_at: i64,\n    pub synced_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncQueueItemRow {\n    pub id: i64,\n    pub action_type: String,\n    pub payload: String,\n    pub status: String,\n    pub retry_count: i32,\n    pub max_retries: i32,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub synced_at: Option<i64>,\n    pub error_message: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct CacheMetadataRow {\n    pub id: i64,\n    pub cache_key: String,\n    pub cache_type: String,\n    pub last_synced_at: Option<i64>,\n    pub last_accessed_at: Option<i64>,\n    pub data_version: i32,\n    pub is_stale: bool,\n    pub expiry_time: Option<i64>,\n    pub metadata: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct OptimisticUpdateRow {\n    pub id: i64,\n    pub update_id: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub original_data: Option<String>,\n    pub updated_data: String,\n    pub is_confirmed: bool,\n    pub created_at: i64,\n    pub confirmed_at: Option<i64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]\npub struct SyncStatusRow {\n    pub id: i64,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub local_version: i32,\n    pub remote_version: Option<i32>,\n    pub last_local_update: i64,\n    pub last_remote_sync: Option<i64>,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","offline","sqlite_store.rs"],"content":"use crate::application::ports::offline_store::OfflinePersistence;\nuse crate::domain::entities::offline::{\n    CacheMetadataRecord, CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord,\n    OptimisticUpdateDraft, OptimisticUpdateRecord, SyncQueueItem, SyncQueueItemDraft, SyncResult,\n    SyncStatusRecord, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{OfflinePayload, OptimisticUpdateId, SyncQueueId};\nuse crate::infrastructure::offline::mappers::{\n    CacheTypeAggregate, cache_metadata_from_row, cache_status_from_aggregates,\n    offline_action_from_row, optimistic_update_from_row, optimistic_update_id_from_string,\n    payload_from_optional_json_str, payload_to_string, sync_queue_id_from_i64,\n    sync_queue_item_from_row, sync_status_from_row,\n};\nuse crate::infrastructure::offline::rows::{\n    CacheMetadataRow, OfflineActionRow, OptimisticUpdateRow, SyncQueueItemRow, SyncStatusRow,\n};\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse sqlx::{Pool, QueryBuilder, Row, Sqlite};\nuse std::convert::TryInto;\nuse uuid::Uuid;\n\npub struct SqliteOfflinePersistence {\n    pool: Pool<Sqlite>,\n}\n\nimpl SqliteOfflinePersistence {\n    pub fn new(pool: Pool<Sqlite>) -> Self {\n        Self { pool }\n    }\n\n    fn pool(&self) -> &Pool<Sqlite> {\n        &self.pool\n    }\n\n    pub async fn ensure_action_in_sync_queue(\n        &self,\n        action: &OfflineActionRecord,\n    ) -> Result<bool, AppError> {\n        let payload = payload_to_string(&action.payload)?;\n\n        let existing = sqlx::query(\n            r#\"\n            SELECT id FROM sync_queue\n            WHERE action_type = ?1 AND payload = ?2\n              AND status IN ('pending', 'failed')\n            LIMIT 1\n            \"#,\n        )\n        .bind(action.action_type.as_str())\n        .bind(&payload)\n        .fetch_optional(self.pool())\n        .await?;\n\n        if existing.is_some() {\n            return Ok(false);\n        }\n\n        self.enqueue_sync(SyncQueueItemDraft::new(\n            action.action_type.clone(),\n            action.payload.clone(),\n            None,\n        ))\n        .await?;\n\n        Ok(true)\n    }\n\n    pub async fn list_pending_sync_queue(&self) -> Result<Vec<SyncQueueItem>, AppError> {\n        let rows = sqlx::query_as::<_, SyncQueueItemRow>(\n            r#\"\n            SELECT * FROM sync_queue\n            WHERE status IN ('pending', 'failed')\n            ORDER BY updated_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_queue_item_from_row).collect()\n    }\n\n    pub async fn list_stale_cache_entries(&self) -> Result<Vec<CacheMetadataRecord>, AppError> {\n        let now = Utc::now().timestamp();\n        let rows = sqlx::query_as::<_, CacheMetadataRow>(\n            r#\"\n            SELECT * FROM cache_metadata\n            WHERE is_stale = 1\n               OR (expiry_time IS NOT NULL AND expiry_time < ?1)\n            ORDER BY COALESCE(last_synced_at, 0) ASC\n            \"#,\n        )\n        .bind(now)\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(cache_metadata_from_row).collect()\n    }\n\n    pub async fn list_unconfirmed_updates(&self) -> Result<Vec<OptimisticUpdateRecord>, AppError> {\n        let rows = sqlx::query_as::<_, OptimisticUpdateRow>(\n            r#\"\n            SELECT * FROM optimistic_updates\n            WHERE is_confirmed = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(optimistic_update_from_row).collect()\n    }\n\n    pub async fn list_sync_conflicts(&self) -> Result<Vec<SyncStatusRecord>, AppError> {\n        let rows = sqlx::query_as::<_, SyncStatusRow>(\n            r#\"\n            SELECT\n                rowid as id,\n                entity_type,\n                entity_id,\n                local_version,\n                NULL AS remote_version,\n                last_local_update,\n                NULL AS last_remote_sync,\n                sync_status,\n                conflict_data\n            FROM sync_status\n            WHERE sync_status IN ('conflict', 'failed', 'pending')\n            ORDER BY last_local_update DESC\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        rows.into_iter().map(sync_status_from_row).collect()\n    }\n\n    async fn get_offline_action_by_id(&self, id: i64) -> Result<OfflineActionRecord, AppError> {\n        let action = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE id = ?1\n            \"#,\n        )\n        .bind(id)\n        .fetch_one(self.pool())\n        .await?;\n\n        offline_action_from_row(action)\n    }\n}\n\n#[async_trait]\nimpl OfflinePersistence for SqliteOfflinePersistence {\n    async fn save_action(\n        &self,\n        draft: crate::domain::entities::offline::OfflineActionDraft,\n    ) -> Result<crate::domain::entities::offline::SavedOfflineAction, AppError> {\n        use crate::domain::entities::offline::{OfflineActionDraft, SavedOfflineAction};\n\n        let OfflineActionDraft {\n            user_pubkey,\n            action_type,\n            target_id,\n            payload,\n        } = draft;\n\n        let local_id = Uuid::new_v4().to_string();\n        let action_data = payload_to_string(&payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO offline_actions (\n                user_pubkey, action_type, target_id, action_data,\n                local_id, is_synced, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .bind(action_type.as_str())\n        .bind(target_id.as_ref().map(|value| value.to_string()))\n        .bind(&action_data)\n        .bind(&local_id)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        let id = result.last_insert_rowid();\n        let action = self.get_offline_action_by_id(id).await?;\n\n        Ok(SavedOfflineAction::new(action.action_id.clone(), action))\n    }\n\n    async fn list_actions(\n        &self,\n        filter: crate::domain::entities::offline::OfflineActionFilter,\n    ) -> Result<Vec<crate::domain::entities::offline::OfflineActionRecord>, AppError> {\n        let mut builder: QueryBuilder<Sqlite> =\n            QueryBuilder::new(\"SELECT * FROM offline_actions WHERE 1=1\");\n\n        if let Some(user_pubkey) = filter.user_pubkey.as_ref() {\n            builder.push(\" AND user_pubkey = \");\n            builder.push_bind(user_pubkey.as_hex());\n        }\n\n        if let Some(is_synced) = filter.include_synced {\n            builder.push(\" AND is_synced = \");\n            builder.push_bind(if is_synced { 1 } else { 0 });\n        }\n\n        builder.push(\" ORDER BY created_at DESC\");\n\n        if let Some(limit) = filter.limit {\n            builder.push(\" LIMIT \");\n            builder.push_bind(limit as i64);\n        }\n\n        let query = builder.build_query_as::<OfflineActionRow>();\n        let actions = query.fetch_all(self.pool()).await?;\n\n        actions.into_iter().map(offline_action_from_row).collect()\n    }\n\n    async fn sync_actions(&self, user_pubkey: PublicKey) -> Result<SyncResult, AppError> {\n        let unsynced_actions = sqlx::query_as::<_, OfflineActionRow>(\n            r#\"\n            SELECT * FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            ORDER BY created_at ASC\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_all(self.pool())\n        .await?;\n\n        let domain_actions = unsynced_actions\n            .into_iter()\n            .map(offline_action_from_row)\n            .collect::<Result<Vec<_>, AppError>>()?;\n\n        let mut synced_count: u32 = 0;\n\n        for action in domain_actions.iter() {\n            let enqueue_result = self\n                .enqueue_sync(SyncQueueItemDraft::new(\n                    action.action_type.clone(),\n                    action.payload.clone(),\n                    None,\n                ))\n                .await;\n\n            if enqueue_result.is_ok() {\n                let Some(record_id) = action.record_id else {\n                    continue;\n                };\n                let synced_at = Utc::now().timestamp();\n                sqlx::query(\n                    r#\"\n                    UPDATE offline_actions\n                    SET is_synced = 1, synced_at = ?1\n                    WHERE id = ?2\n                    \"#,\n                )\n                .bind(synced_at)\n                .bind(record_id)\n                .execute(self.pool())\n                .await?;\n                synced_count = synced_count.saturating_add(1);\n            }\n        }\n\n        let pending_result = sqlx::query(\n            r#\"\n            SELECT COUNT(*) as count\n            FROM offline_actions\n            WHERE user_pubkey = ?1 AND is_synced = 0\n            \"#,\n        )\n        .bind(user_pubkey.as_hex())\n        .fetch_one(self.pool())\n        .await?;\n\n        let pending_count: u32 = pending_result\n            .try_get::<i32, _>(\"count\")\n            .unwrap_or(0)\n            .try_into()\n            .unwrap_or(0);\n\n        Ok(SyncResult::new(synced_count, 0, pending_count))\n    }\n\n    async fn cache_status(&self) -> Result<CacheStatusSnapshot, AppError> {\n        let total_result = sqlx::query(r#\"SELECT COUNT(*) as count FROM cache_metadata\"#)\n            .fetch_one(self.pool())\n            .await?;\n        let total_items: i64 = total_result.try_get(\"count\").unwrap_or(0);\n\n        let stale_result =\n            sqlx::query(r#\"SELECT COUNT(*) as count FROM cache_metadata WHERE is_stale = 1\"#)\n                .fetch_one(self.pool())\n                .await?;\n        let stale_items: i64 = stale_result.try_get(\"count\").unwrap_or(0);\n\n        let cache_types = sqlx::query_as::<_, CacheTypeAggregate>(\n            r#\"\n            SELECT\n                cache_type,\n                COUNT(*) as item_count,\n                MAX(last_synced_at) as last_synced_at,\n                MAX(is_stale) as is_stale\n            FROM cache_metadata\n            GROUP BY cache_type\n            \"#,\n        )\n        .fetch_all(self.pool())\n        .await?;\n\n        cache_status_from_aggregates(total_items, stale_items, cache_types)\n    }\n\n    async fn enqueue_sync(&self, draft: SyncQueueItemDraft) -> Result<SyncQueueId, AppError> {\n        let payload_json = payload_to_string(&draft.payload)?;\n        let created_at = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            INSERT INTO sync_queue (action_type, payload, status, created_at, updated_at)\n            VALUES (?1, ?2, 'pending', ?3, ?3)\n            \"#,\n        )\n        .bind(draft.action_type.as_str())\n        .bind(&payload_json)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        sync_queue_id_from_i64(result.last_insert_rowid())\n    }\n\n    async fn upsert_cache_metadata(&self, update: CacheMetadataUpdate) -> Result<(), AppError> {\n        let now = Utc::now().timestamp();\n        let metadata = update\n            .metadata\n            .map(|value| serde_json::to_string(&value))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n        let expiry_time = update.expiry.map(|expiry| {\n            let seconds = expiry.signed_duration_since(Utc::now()).num_seconds();\n            now + seconds.max(0)\n        });\n\n        sqlx::query(\n            r#\"\n            INSERT INTO cache_metadata (\n                cache_key, cache_type, last_synced_at, last_accessed_at,\n                data_version, is_stale, expiry_time, metadata\n            ) VALUES (?1, ?2, ?3, ?3, 1, 0, ?4, ?5)\n            ON CONFLICT(cache_key) DO UPDATE SET\n                cache_type = excluded.cache_type,\n                last_synced_at = excluded.last_synced_at,\n                last_accessed_at = excluded.last_accessed_at,\n                data_version = data_version + 1,\n                expiry_time = excluded.expiry_time,\n                metadata = excluded.metadata\n            \"#,\n        )\n        .bind(update.cache_key.as_str())\n        .bind(update.cache_type.as_str())\n        .bind(now)\n        .bind(expiry_time)\n        .bind(metadata)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn save_optimistic_update(\n        &self,\n        draft: OptimisticUpdateDraft,\n    ) -> Result<OptimisticUpdateId, AppError> {\n        let update_id = Uuid::new_v4().to_string();\n        let created_at = Utc::now().timestamp();\n        let original = draft\n            .original_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated = payload_to_string(&draft.updated_data)?;\n\n        sqlx::query(\n            r#\"\n            INSERT INTO optimistic_updates (\n                update_id, entity_type, entity_id, original_data,\n                updated_data, is_confirmed, created_at\n            ) VALUES (?1, ?2, ?3, ?4, ?5, 0, ?6)\n            \"#,\n        )\n        .bind(&update_id)\n        .bind(draft.entity_type.as_str())\n        .bind(draft.entity_id.as_str())\n        .bind(&original)\n        .bind(&updated)\n        .bind(created_at)\n        .execute(self.pool())\n        .await?;\n\n        optimistic_update_id_from_string(update_id)\n    }\n\n    async fn confirm_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<(), AppError> {\n        let confirmed_at = Utc::now().timestamp();\n\n        sqlx::query(\n            r#\"\n            UPDATE optimistic_updates\n            SET is_confirmed = 1, confirmed_at = ?1\n            WHERE update_id = ?2\n            \"#,\n        )\n        .bind(confirmed_at)\n        .bind(update_id.as_str())\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n\n    async fn rollback_optimistic_update(\n        &self,\n        update_id: OptimisticUpdateId,\n    ) -> Result<Option<OfflinePayload>, AppError> {\n        let update = sqlx::query_as::<_, (Option<String>,)>(\n            r#\"\n                SELECT original_data FROM optimistic_updates\n                WHERE update_id = ?1\n                \"#,\n        )\n        .bind(update_id.as_str())\n        .fetch_optional(self.pool())\n        .await?;\n\n        if let Some((original_data,)) = update {\n            sqlx::query(r#\"DELETE FROM optimistic_updates WHERE update_id = ?1\"#)\n                .bind(update_id.as_str())\n                .execute(self.pool())\n                .await?;\n\n            return payload_from_optional_json_str(original_data);\n        }\n\n        Ok(None)\n    }\n\n    async fn cleanup_expired_cache(&self) -> Result<u32, AppError> {\n        let now = Utc::now().timestamp();\n\n        let result = sqlx::query(\n            r#\"\n            DELETE FROM cache_metadata\n            WHERE expiry_time IS NOT NULL AND expiry_time < ?1\n            \"#,\n        )\n        .bind(now)\n        .execute(self.pool())\n        .await?;\n\n        result\n            .rows_affected()\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed u32\".to_string()))\n    }\n\n    async fn update_sync_status(&self, update: SyncStatusUpdate) -> Result<(), AppError> {\n        let conflict_data = update\n            .conflict_data\n            .map(|payload| payload_to_string(&payload))\n            .transpose()?;\n        let updated_at = update.updated_at.timestamp();\n\n        sqlx::query(\n            r#\"\n            INSERT INTO sync_status (\n                entity_type, entity_id, local_version, last_local_update,\n                sync_status, conflict_data\n            ) VALUES (?1, ?2, 1, ?3, ?4, ?5)\n            ON CONFLICT(entity_type, entity_id) DO UPDATE SET\n                local_version = local_version + 1,\n                last_local_update = excluded.last_local_update,\n                sync_status = excluded.sync_status,\n                conflict_data = excluded.conflict_data\n            \"#,\n        )\n        .bind(update.entity_type.as_str())\n        .bind(update.entity_id.as_str())\n        .bind(updated_at)\n        .bind(update.sync_status.as_str())\n        .bind(&conflict_data)\n        .execute(self.pool())\n        .await?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::offline::{\n        CacheMetadataUpdate, OfflineActionDraft, OfflineActionFilter, OptimisticUpdateDraft,\n        SyncStatusUpdate,\n    };\n    use crate::domain::value_objects::event_gateway::PublicKey;\n    use crate::domain::value_objects::offline::{\n        CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n        SyncQueueStatus, SyncStatus,\n    };\n    use chrono::Utc;\n    use sqlx::sqlite::SqlitePoolOptions;\n\n    const PUBKEY: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    async fn setup_persistence() -> SqliteOfflinePersistence {\n        let pool = SqlitePoolOptions::new()\n            .max_connections(1)\n            .connect(\"sqlite::memory:\")\n            .await\n            .unwrap();\n\n        sqlx::migrate!(\"./migrations\").run(&pool).await.unwrap();\n\n        SqliteOfflinePersistence::new(pool)\n    }\n\n    fn sample_draft() -> OfflineActionDraft {\n        OfflineActionDraft::new(\n            PublicKey::from_hex_str(PUBKEY).unwrap(),\n            OfflineActionType::new(\"create_post\".to_string()).unwrap(),\n            Some(EntityId::new(\"post_123\".to_string()).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"content\":\"test\"}\"#).unwrap(),\n        )\n    }\n\n    #[tokio::test]\n    async fn test_save_offline_action() {\n        let persistence = setup_persistence().await;\n        let saved = persistence.save_action(sample_draft()).await.unwrap();\n\n        assert_eq!(saved.action.user_pubkey.as_hex(), PUBKEY);\n        assert_eq!(saved.action.sync_status, SyncStatus::Pending);\n        assert!(!saved.action.payload.as_json().is_null());\n    }\n\n    #[tokio::test]\n    async fn test_list_offline_actions() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let actions = persistence\n            .list_actions(OfflineActionFilter::new(\n                Some(PublicKey::from_hex_str(PUBKEY).unwrap()),\n                Some(false),\n                None,\n            ))\n            .await\n            .unwrap();\n\n        assert_eq!(actions.len(), 1);\n        assert_eq!(actions[0].user_pubkey.as_hex(), PUBKEY);\n    }\n\n    #[tokio::test]\n    async fn test_enqueue_and_pending_queue() {\n        let persistence = setup_persistence().await;\n        persistence.save_action(sample_draft()).await.unwrap();\n\n        let unsynced = persistence\n            .list_actions(OfflineActionFilter::new(None, Some(false), None))\n            .await\n            .unwrap();\n        let action = unsynced.first().unwrap();\n\n        let inserted = persistence\n            .ensure_action_in_sync_queue(action)\n            .await\n            .unwrap();\n        assert!(inserted);\n\n        // 重複登録は false を返す\n        let duplicated = persistence\n            .ensure_action_in_sync_queue(action)\n            .await\n            .unwrap();\n        assert!(!duplicated);\n\n        let pending = persistence.list_pending_sync_queue().await.unwrap();\n        assert_eq!(pending.len(), 1);\n        assert_eq!(pending[0].status, SyncQueueStatus::Pending);\n    }\n\n    #[tokio::test]\n    async fn test_cache_metadata_and_status() {\n        let persistence = setup_persistence().await;\n        persistence\n            .upsert_cache_metadata(CacheMetadataUpdate {\n                cache_key: CacheKey::new(\"posts\".to_string()).unwrap(),\n                cache_type: CacheType::new(\"topic\".to_string()).unwrap(),\n                metadata: Some(serde_json::json!({\"last_id\": \"1\"})),\n                expiry: Some(Utc::now()),\n            })\n            .await\n            .unwrap();\n\n        let status = persistence.cache_status().await.unwrap();\n        assert_eq!(status.total_items, 1);\n    }\n\n    #[tokio::test]\n    async fn test_optimistic_update_lifecycle() {\n        let persistence = setup_persistence().await;\n        let draft = OptimisticUpdateDraft::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_1\".to_string()).unwrap(),\n            Some(OfflinePayload::from_json_str(r#\"{\"likes\":10}\"#).unwrap()),\n            OfflinePayload::from_json_str(r#\"{\"likes\":11}\"#).unwrap(),\n        );\n\n        let update_id = persistence.save_optimistic_update(draft).await.unwrap();\n        persistence\n            .confirm_optimistic_update(update_id.clone())\n            .await\n            .unwrap();\n\n        let rollback_id = persistence\n            .save_optimistic_update(OptimisticUpdateDraft::new(\n                EntityType::new(\"post\".to_string()).unwrap(),\n                EntityId::new(\"post_2\".to_string()).unwrap(),\n                Some(OfflinePayload::from_json_str(r#\"{\"likes\":1}\"#).unwrap()),\n                OfflinePayload::from_json_str(r#\"{\"likes\":2}\"#).unwrap(),\n            ))\n            .await\n            .unwrap();\n\n        let rolled_back = persistence\n            .rollback_optimistic_update(rollback_id)\n            .await\n            .unwrap();\n        assert!(rolled_back.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_sync_status_update() {\n        let persistence = setup_persistence().await;\n        let update = SyncStatusUpdate::new(\n            EntityType::new(\"post\".to_string()).unwrap(),\n            EntityId::new(\"post_3\".to_string()).unwrap(),\n            SyncStatus::Pending,\n            None,\n            Utc::now(),\n        );\n        persistence.update_sync_status(update).await.unwrap();\n\n        let conflicts = persistence.list_sync_conflicts().await.unwrap();\n        assert_eq!(conflicts.len(), 1);\n        assert_eq!(conflicts[0].entity_id.to_string(), \"post_3\");\n    }\n}\n","traces":[{"line":30,"address":[11672176],"length":1,"stats":{"Line":5}},{"line":34,"address":[11886288],"length":1,"stats":{"Line":2}},{"line":38,"address":[11886304],"length":1,"stats":{"Line":1}},{"line":42,"address":[11116127,11115520,11115375,11115238],"length":1,"stats":{"Line":2}},{"line":52,"address":[13507353,13507845,13507396,13507509],"length":1,"stats":{"Line":2}},{"line":53,"address":[15017044,15016973],"length":1,"stats":{"Line":2}},{"line":54,"address":[13507814,13507687,13507549,13507592],"length":1,"stats":{"Line":2}},{"line":55,"address":[14370543],"length":1,"stats":{"Line":4}},{"line":57,"address":[11647133,11646972],"length":1,"stats":{"Line":2}},{"line":58,"address":[15017992],"length":1,"stats":{"Line":1}},{"line":61,"address":[13509178,13508456,13508635,13508769,13508715,13508959,13509057,13509231],"length":1,"stats":{"Line":11}},{"line":62,"address":[11887985,11888065],"length":1,"stats":{"Line":2}},{"line":63,"address":[11888073],"length":1,"stats":{"Line":1}},{"line":64,"address":[11888142],"length":1,"stats":{"Line":1}},{"line":66,"address":[11674601,11674438,11672454,11674169,11674213,11674304],"length":1,"stats":{"Line":8}},{"line":68,"address":[11117425],"length":1,"stats":{"Line":2}},{"line":71,"address":[11117584,11117619,11117737,11117962,11117568,11118079,11117576],"length":1,"stats":{"Line":4}},{"line":79,"address":[11675055,11675193,11674913,11674961],"length":1,"stats":{"Line":2}},{"line":80,"address":[11674900,11675415,11675646,11675063,11675256,11675169],"length":1,"stats":{"Line":7}},{"line":82,"address":[11675585,11675766],"length":1,"stats":{"Line":4}},{"line":85,"address":[11649216,11649251,11649821,11649208,11649354,11649394,11649200],"length":1,"stats":{"Line":4}},{"line":86,"address":[11649338,11649438],"length":1,"stats":{"Line":2}},{"line":95,"address":[15020391],"length":1,"stats":{"Line":1}},{"line":96,"address":[13510877,13510715,13510791,13510999],"length":1,"stats":{"Line":2}},{"line":97,"address":[11119622,11118981,11119285,11119462,11119374,11119865],"length":1,"stats":{"Line":4}},{"line":99,"address":[13511376,13511571],"length":1,"stats":{"Line":2}},{"line":102,"address":[11650576,11650729,11650954,11650611,11651071,11650560,11650568],"length":1,"stats":{"Line":4}},{"line":110,"address":[13512189,13511917,13512051,13511965],"length":1,"stats":{"Line":2}},{"line":111,"address":[10466820],"length":1,"stats":{"Line":4}},{"line":113,"address":[11651622,11651441],"length":1,"stats":{"Line":2}},{"line":116,"address":[11121400,11121392,11121786,11121903,11121561,11121408,11121443],"length":1,"stats":{"Line":4}},{"line":134,"address":[11679017,11678879,11678737,11678785],"length":1,"stats":{"Line":2}},{"line":135,"address":[11678887,11678993,11678724,11679470,11679080,11679239],"length":1,"stats":{"Line":4}},{"line":137,"address":[11652673,11652854],"length":1,"stats":{"Line":2}},{"line":140,"address":[15023840,15023872,15023907,15024050,15024428,15023853,15024307],"length":1,"stats":{"Line":14}},{"line":147,"address":[11894178],"length":1,"stats":{"Line":3}},{"line":148,"address":[11894106,11894280,11894186,11894422],"length":1,"stats":{"Line":7}},{"line":149,"address":[14365911],"length":1,"stats":{"Line":15}},{"line":151,"address":[11653993],"length":1,"stats":{"Line":5}},{"line":164,"address":[11687854],"length":1,"stats":{"Line":4}},{"line":165,"address":[11130753],"length":1,"stats":{"Line":4}},{"line":166,"address":[11902023],"length":1,"stats":{"Line":4}},{"line":167,"address":[11687965],"length":1,"stats":{"Line":4}},{"line":170,"address":[15032083,15032153],"length":1,"stats":{"Line":7}},{"line":171,"address":[15032187,15032414,15033546,15032272],"length":1,"stats":{"Line":4}},{"line":172,"address":[11131318,11131179],"length":1,"stats":{"Line":5}},{"line":182,"address":[13635334,13636212,13635489,13635377],"length":1,"stats":{"Line":5}},{"line":183,"address":[15032777,15032899,15033495],"length":1,"stats":{"Line":5}},{"line":184,"address":[11688835,11691408,11691424,11688974,11689383],"length":1,"stats":{"Line":10}},{"line":185,"address":[11688982],"length":1,"stats":{"Line":3}},{"line":186,"address":[13635847],"length":1,"stats":{"Line":2}},{"line":187,"address":[11131997],"length":1,"stats":{"Line":3}},{"line":188,"address":[11903346,11903448,11903237,11903120],"length":1,"stats":{"Line":5}},{"line":189,"address":[11122572],"length":1,"stats":{"Line":12}},{"line":191,"address":[11132868,11132747],"length":1,"stats":{"Line":7}},{"line":192,"address":[11122594],"length":1,"stats":{"Line":11}},{"line":194,"address":[15034618,15034751],"length":1,"stats":{"Line":5}},{"line":201,"address":[11906106],"length":1,"stats":{"Line":2}},{"line":204,"address":[11692159,11692087],"length":1,"stats":{"Line":4}},{"line":205,"address":[15036297],"length":1,"stats":{"Line":2}},{"line":206,"address":[11135146],"length":1,"stats":{"Line":2}},{"line":209,"address":[11692345,11692249],"length":1,"stats":{"Line":4}},{"line":210,"address":[11692366],"length":1,"stats":{"Line":2}},{"line":211,"address":[11135298],"length":1,"stats":{"Line":2}},{"line":214,"address":[13639130],"length":1,"stats":{"Line":2}},{"line":216,"address":[11692501],"length":1,"stats":{"Line":2}},{"line":217,"address":[13639258],"length":1,"stats":{"Line":0}},{"line":218,"address":[13639314],"length":1,"stats":{"Line":0}},{"line":221,"address":[11135430],"length":1,"stats":{"Line":2}},{"line":222,"address":[14495633],"length":1,"stats":{"Line":6}},{"line":224,"address":[11666603,11666796],"length":1,"stats":{"Line":4}},{"line":227,"address":[13641293,13641871,13640720,13640968,13640559,13640767,13641844,13646063],"length":1,"stats":{"Line":4}},{"line":235,"address":[15038726,15038897,15038769,15039237],"length":1,"stats":{"Line":2}},{"line":236,"address":[11695116,11694833,11694948],"length":1,"stats":{"Line":2}},{"line":237,"address":[11694956,11695079,11695380,11695674,11694262,11695211],"length":1,"stats":{"Line":4}},{"line":239,"address":[11138671,11139168,11138931,11138461],"length":1,"stats":{"Line":2}},{"line":244,"address":[11695978],"length":1,"stats":{"Line":1}},{"line":246,"address":[11910092,11910264,11911066,11911134],"length":1,"stats":{"Line":4}},{"line":247,"address":[11140674,11140604,11139922,11140813],"length":1,"stats":{"Line":4}},{"line":248,"address":[11140528],"length":1,"stats":{"Line":1}},{"line":249,"address":[13644152,13643671],"length":1,"stats":{"Line":2}},{"line":250,"address":[15041664],"length":1,"stats":{"Line":1}},{"line":251,"address":[15041736],"length":1,"stats":{"Line":1}},{"line":253,"address":[11137147,11139213,11140643,11140880,11140696],"length":1,"stats":{"Line":5}},{"line":255,"address":[11140952],"length":1,"stats":{"Line":1}},{"line":256,"address":[11671392],"length":1,"stats":{"Line":1}},{"line":259,"address":[11141039,11141084],"length":1,"stats":{"Line":2}},{"line":268,"address":[15042467],"length":1,"stats":{"Line":1}},{"line":269,"address":[11912673,11912600,11912491,11912384],"length":1,"stats":{"Line":2}},{"line":270,"address":[10612143],"length":1,"stats":{"Line":5}},{"line":271,"address":[15041002,15040883],"length":1,"stats":{"Line":2}},{"line":282,"address":[11140008,11139965,11140124,11140383],"length":1,"stats":{"Line":2}},{"line":283,"address":[11670751,11670649,11670540],"length":1,"stats":{"Line":2}},{"line":284,"address":[14495988],"length":1,"stats":{"Line":4}},{"line":286,"address":[11699034,11699205],"length":1,"stats":{"Line":2}},{"line":292,"address":[13645780],"length":1,"stats":{"Line":1}},{"line":295,"address":[11699695,11700098,11700437,11699779,11699744,11699910],"length":1,"stats":{"Line":3}},{"line":296,"address":[11144199,11143562,11143227,11143454,11143776,11143157,11143018,11143081],"length":1,"stats":{"Line":6}},{"line":297,"address":[15044265,15044408,15044495,15044305],"length":1,"stats":{"Line":2}},{"line":298,"address":[11124209],"length":1,"stats":{"Line":4}},{"line":299,"address":[15045074,15044901],"length":1,"stats":{"Line":2}},{"line":301,"address":[11144424,11143979,11144055,11144125,11144316,11143913,11145107,11144647],"length":1,"stats":{"Line":6}},{"line":303,"address":[11701313,11701123,11701080,11701226],"length":1,"stats":{"Line":2}},{"line":304,"address":[11674604,11674764,11674999,11674498,11673219,11674552],"length":1,"stats":{"Line":4}},{"line":305,"address":[13648361,13648190],"length":1,"stats":{"Line":2}},{"line":318,"address":[11144818,11144964,11144861,11145085],"length":1,"stats":{"Line":2}},{"line":319,"address":[14495065],"length":1,"stats":{"Line":4}},{"line":321,"address":[15046705],"length":1,"stats":{"Line":1}},{"line":324,"address":[11145936,11147316,11146101,11145855,11145971,11148060,11147372,11146349],"length":1,"stats":{"Line":12}},{"line":325,"address":[11676897,11677036,11676824,11677747],"length":1,"stats":{"Line":5}},{"line":326,"address":[11146753,11146617],"length":1,"stats":{"Line":4}},{"line":334,"address":[13650617,13650508,13650945,13650465],"length":1,"stats":{"Line":4}},{"line":335,"address":[11918217],"length":1,"stats":{"Line":2}},{"line":336,"address":[13650732],"length":1,"stats":{"Line":2}},{"line":337,"address":[11147024,11147198,11147294,11147104],"length":1,"stats":{"Line":4}},{"line":338,"address":[11151281],"length":1,"stats":{"Line":10}},{"line":340,"address":[15048953,15049075],"length":1,"stats":{"Line":6}},{"line":343,"address":[15052485,15049689,15051516,15049952,15051622,15049500,15049359,15049456],"length":1,"stats":{"Line":8}},{"line":344,"address":[13652618,13652555],"length":1,"stats":{"Line":4}},{"line":345,"address":[11150363,11149410,11148986,11149108],"length":1,"stats":{"Line":4}},{"line":347,"address":[13655024,13655040],"length":1,"stats":{"Line":4}},{"line":349,"address":[11920610,11922802,11922784],"length":1,"stats":{"Line":0}},{"line":350,"address":[11920737,11922944,11920530],"length":1,"stats":{"Line":6}},{"line":351,"address":[15052942],"length":1,"stats":{"Line":2}},{"line":352,"address":[15053017,15053071],"length":1,"stats":{"Line":2}},{"line":370,"address":[11680741,11680127,11680011,11679968],"length":1,"stats":{"Line":4}},{"line":371,"address":[11149743,11149862,11150309],"length":1,"stats":{"Line":4}},{"line":372,"address":[11921102],"length":1,"stats":{"Line":2}},{"line":374,"address":[11921216,11921303],"length":1,"stats":{"Line":4}},{"line":375,"address":[11707414,11707048,11707215,11707312],"length":1,"stats":{"Line":4}},{"line":376,"address":[11141105],"length":1,"stats":{"Line":8}},{"line":378,"address":[11707906],"length":1,"stats":{"Line":2}},{"line":385,"address":[11682974,11683050],"length":1,"stats":{"Line":2}},{"line":386,"address":[11709893,11709829],"length":1,"stats":{"Line":2}},{"line":387,"address":[11710214,11711365,11709930],"length":1,"stats":{"Line":1}},{"line":389,"address":[11155552,11155568],"length":1,"stats":{"Line":2}},{"line":391,"address":[15054379,15054530,15054231,15055420],"length":1,"stats":{"Line":2}},{"line":401,"address":[11710593,11710554],"length":1,"stats":{"Line":2}},{"line":402,"address":[15054681,15055398,15054794,15054599],"length":1,"stats":{"Line":2}},{"line":403,"address":[11925382,11924945,11924826],"length":1,"stats":{"Line":2}},{"line":404,"address":[11684121],"length":1,"stats":{"Line":1}},{"line":405,"address":[15055011],"length":1,"stats":{"Line":1}},{"line":406,"address":[11925103],"length":1,"stats":{"Line":1}},{"line":407,"address":[15055095,15054976,15055192,15055335],"length":1,"stats":{"Line":2}},{"line":408,"address":[11170241],"length":1,"stats":{"Line":4}},{"line":410,"address":[13658201],"length":1,"stats":{"Line":1}},{"line":417,"address":[11686669,11686605],"length":1,"stats":{"Line":2}},{"line":426,"address":[11686804],"length":1,"stats":{"Line":1}},{"line":427,"address":[11686812,11686930,11686737,11687174],"length":1,"stats":{"Line":2}},{"line":428,"address":[11156643,11156546,11156733],"length":1,"stats":{"Line":2}},{"line":429,"address":[10633837],"length":1,"stats":{"Line":4}},{"line":431,"address":[11687539],"length":1,"stats":{"Line":1}},{"line":444,"address":[15059371,15059215,15059258,15059675],"length":1,"stats":{"Line":2}},{"line":445,"address":[11688571,11688677,11688821],"length":1,"stats":{"Line":2}},{"line":446,"address":[11929905,11930164,11928998,11929625,11929745,11929517],"length":1,"stats":{"Line":4}},{"line":448,"address":[11930249,11930123],"length":1,"stats":{"Line":2}},{"line":449,"address":[15060499,15060272,15061410,15060733,15060621,15060413,15061105,15061207,15061459],"length":1,"stats":{"Line":7}},{"line":450,"address":[11159162,11159600,11159205,11159318],"length":1,"stats":{"Line":2}},{"line":451,"address":[11930803,11930566,11930672],"length":1,"stats":{"Line":2}},{"line":452,"address":[10635236],"length":1,"stats":{"Line":4}},{"line":454,"address":[11690628,11690485],"length":1,"stats":{"Line":2}},{"line":457,"address":[11716223],"length":1,"stats":{"Line":0}},{"line":460,"address":[11931737,11932154,11932589,11931811,11931906,11931776],"length":1,"stats":{"Line":3}},{"line":461,"address":[11718123],"length":1,"stats":{"Line":1}},{"line":469,"address":[15062362],"length":1,"stats":{"Line":1}},{"line":470,"address":[15062464,15062370,15062290,15062551],"length":1,"stats":{"Line":2}},{"line":471,"address":[11932542,11932488,11932790,11932630,11932978,11931933],"length":1,"stats":{"Line":4}},{"line":473,"address":[13665338,13665445],"length":1,"stats":{"Line":2}},{"line":476,"address":[11719104,11719118],"length":1,"stats":{"Line":0}},{"line":479,"address":[13667662,13665939,13668635,13665904,13666344,13667768,13665683,13666091],"length":1,"stats":{"Line":8}},{"line":480,"address":[11720217,11719903,11721227,11720010],"length":1,"stats":{"Line":4}},{"line":482,"address":[13668752,13668736],"length":1,"stats":{"Line":2}},{"line":484,"address":[11163171,11163021],"length":1,"stats":{"Line":4}},{"line":499,"address":[13666941,13666898,13667725,13667050],"length":1,"stats":{"Line":4}},{"line":500,"address":[11693782,11693906,11694437],"length":1,"stats":{"Line":4}},{"line":501,"address":[11693976],"length":1,"stats":{"Line":2}},{"line":502,"address":[13667221,13667376,13667671,13667264],"length":1,"stats":{"Line":4}},{"line":503,"address":[11935019,11934940],"length":1,"stats":{"Line":4}},{"line":504,"address":[11163747,11163984,11163795,11163889],"length":1,"stats":{"Line":4}},{"line":505,"address":[11164148,11164499,11163954,11162406,11164310,11163897],"length":1,"stats":{"Line":8}},{"line":507,"address":[13668104],"length":1,"stats":{"Line":2}}],"covered":176,"coverable":181},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","bootstrap_config.rs"],"content":"/// ブートストラップノード設定モジュール\nuse crate::shared::error::AppError;\nuse dirs;\nuse iroh::{NodeAddr, NodeId};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::net::SocketAddr;\nuse std::path::{Path, PathBuf};\nuse std::str::FromStr;\nuse tracing::{debug, info, warn};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfig {\n    pub development: EnvironmentConfig,\n    pub staging: EnvironmentConfig,\n    pub production: EnvironmentConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EnvironmentConfig {\n    pub description: String,\n    pub nodes: Vec<String>,\n}\n\nimpl BootstrapConfig {\n    /// 設定ファイルから読み込み\n    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, AppError> {\n        let content = fs::read_to_string(path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to read bootstrap config: {e}\"))\n        })?;\n\n        let config: BootstrapConfig = serde_json::from_str(&content).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to parse bootstrap config: {e}\"))\n        })?;\n\n        Ok(config)\n    }\n\n    /// デフォルト設定を取得\n    pub fn default_config() -> Self {\n        Self {\n            development: EnvironmentConfig {\n                description: \"Local development bootstrap nodes\".to_string(),\n                nodes: vec![\"localhost:11223\".to_string(), \"localhost:11224\".to_string()],\n            },\n            staging: EnvironmentConfig {\n                description: \"Staging environment bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n            production: EnvironmentConfig {\n                description: \"Production bootstrap nodes\".to_string(),\n                nodes: vec![],\n            },\n        }\n    }\n\n    /// 環境に応じたノードリストを取得\n    pub fn get_nodes(&self, environment: &str) -> Vec<String> {\n        match environment {\n            \"development\" | \"dev\" => self.development.nodes.clone(),\n            \"staging\" | \"stage\" => self.staging.nodes.clone(),\n            \"production\" | \"prod\" => self.production.nodes.clone(),\n            _ => {\n                warn!(\"Unknown environment: {}, using development\", environment);\n                self.development.nodes.clone()\n            }\n        }\n    }\n\n    /// ソケットアドレスのリストを取得\n    pub fn get_socket_addrs(&self, environment: &str) -> Vec<SocketAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut addrs = Vec::new();\n\n        for node in nodes {\n            match node.parse::<SocketAddr>() {\n                Ok(addr) => addrs.push(addr),\n                Err(e) => {\n                    debug!(\"Failed to parse address {}: {}\", node, e);\n                }\n            }\n        }\n\n        addrs\n    }\n\n    /// 形式: \"<node_id>@<host:port>\" のみ NodeAddr に変換する\n    /// SocketAddr のみの指定は警告を出してスキップ\n    pub fn get_node_addrs_with_id(&self, environment: &str) -> Vec<NodeAddr> {\n        let nodes = self.get_nodes(environment);\n        let mut out = Vec::new();\n\n        for node in nodes {\n            if let Some((id_part, addr_part)) = node.split_once('@') {\n                match (NodeId::from_str(id_part), addr_part.parse::<SocketAddr>()) {\n                    (Ok(node_id), Ok(sock)) => {\n                        out.push(NodeAddr::new(node_id).with_direct_addresses([sock]));\n                    }\n                    (id_res, addr_res) => {\n                        debug!(\n                            \"Invalid node entry '{}': id_ok={}, addr_ok={}\",\n                            node,\n                            id_res.is_ok(),\n                            addr_res.is_ok()\n                        );\n                    }\n                }\n            } else {\n                // SocketAddr 形式のみ → 警告しつつスキップ（仕様は node_id@addr 推奨）\n                if node.parse::<SocketAddr>().is_ok() {\n                    warn!(\n                        \"Bootstrap node '{}' lacks NodeId; expected '<node_id>@<host:port>'. Skipping.\",\n                        node\n                    );\n                } else {\n                    debug!(\"Unrecognized bootstrap node entry: {}\", node);\n                }\n            }\n        }\n\n        out\n    }\n}\n\n/// 現在の環境を取得\npub fn get_current_environment() -> String {\n    std::env::var(\"KUKURI_ENV\")\n        .or_else(|_| std::env::var(\"ENVIRONMENT\"))\n        .unwrap_or_else(|_| \"development\".to_string())\n}\n\n/// ブートストラップノードを読み込み\npub fn load_bootstrap_nodes() -> Result<Vec<SocketAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap nodes for environment: {}\", env);\n\n    // まず設定ファイルを探す\n    let config_path = \"bootstrap_nodes.json\";\n    let config = if Path::new(config_path).exists() {\n        BootstrapConfig::load_from_file(config_path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_socket_addrs(&env);\n\n    if addrs.is_empty() {\n        warn!(\"No bootstrap nodes configured for environment: {}\", env);\n    } else {\n        info!(\"Loaded {} bootstrap nodes\", addrs.len());\n    }\n\n    Ok(addrs)\n}\n\n/// NodeId を含むブートストラップノードを取得（NodeAddr）。\n/// NodeId がないエントリは警告してスキップする。\npub fn load_bootstrap_node_addrs() -> Result<Vec<NodeAddr>, AppError> {\n    let env = get_current_environment();\n    info!(\"Loading bootstrap NodeAddrs for environment: {}\", env);\n\n    let config_path = \"bootstrap_nodes.json\";\n    let config = if Path::new(config_path).exists() {\n        BootstrapConfig::load_from_file(config_path)?\n    } else {\n        info!(\"Bootstrap config file not found, using defaults\");\n        BootstrapConfig::default_config()\n    };\n\n    let addrs = config.get_node_addrs_with_id(&env);\n    if addrs.is_empty() {\n        warn!(\n            \"No valid NodeId@Addr bootstrap entries for environment: {}\",\n            env\n        );\n    } else {\n        info!(\"Loaded {} NodeId@Addr bootstrap entries\", addrs.len());\n    }\n    Ok(addrs)\n}\n\n/// 検証: JSONのノード配列のうち、NodeId@Addr と SocketAddr の件数をカウントしてログ出力\npub fn validate_bootstrap_config() -> Result<(), AppError> {\n    let env = get_current_environment();\n    let config_path = \"bootstrap_nodes.json\";\n    let config = if Path::new(config_path).exists() {\n        BootstrapConfig::load_from_file(config_path)?\n    } else {\n        BootstrapConfig::default_config()\n    };\n\n    let nodes = config.get_nodes(&env);\n    let mut with_id = 0usize;\n    let mut socket_only = 0usize;\n    let mut invalid = 0usize;\n\n    for node in nodes {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            if NodeId::from_str(id_part).is_ok() && addr_part.parse::<SocketAddr>().is_ok() {\n                with_id += 1;\n            } else {\n                invalid += 1;\n            }\n        } else if node.parse::<SocketAddr>().is_ok() {\n            socket_only += 1;\n        } else {\n            invalid += 1;\n        }\n    }\n\n    info!(\n        \"bootstrap_nodes.json validation (env={}): with_id={}, socket_only={}, invalid={}\",\n        env, with_id, socket_only, invalid\n    );\n\n    Ok(())\n}\n\n// =============== ユーザーUIによるブートストラップ指定 ===============\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct UserBootstrapConfig {\n    nodes: Vec<String>,\n}\n\nfn user_config_path() -> PathBuf {\n    let base = dirs::data_dir().unwrap_or_else(|| PathBuf::from(\".\"));\n    let dir = base.join(\"kukuri\");\n    let _ = fs::create_dir_all(&dir);\n    dir.join(\"user_bootstrap_nodes.json\")\n}\n\n/// ユーザー定義のブートストラップノード（NodeId@host:port）を保存\npub fn save_user_bootstrap_nodes(nodes: &[String]) -> Result<(), AppError> {\n    let path = user_config_path();\n    let cfg = UserBootstrapConfig {\n        nodes: nodes.to_vec(),\n    };\n    let json = serde_json::to_string_pretty(&cfg).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to serialize user bootstrap: {e}\"))\n    })?;\n    fs::write(&path, json).map_err(|e| {\n        AppError::ConfigurationError(format!(\"Failed to write user bootstrap file: {e}\"))\n    })?;\n    info!(\n        \"Saved user bootstrap nodes to {:?} ({} entries)\",\n        path,\n        nodes.len()\n    );\n    Ok(())\n}\n\n/// ユーザー定義のブートストラップノードを削除\npub fn clear_user_bootstrap_nodes() -> Result<(), AppError> {\n    let path = user_config_path();\n    if path.exists() {\n        fs::remove_file(&path).map_err(|e| {\n            AppError::ConfigurationError(format!(\"Failed to remove user bootstrap file: {e}\"))\n        })?;\n        info!(\"Removed user bootstrap config at {:?}\", path);\n    }\n    Ok(())\n}\n\n/// ユーザー定義のブートストラップノード（文字列）を読み込み\npub fn load_user_bootstrap_nodes() -> Vec<String> {\n    let path = user_config_path();\n    if !path.exists() {\n        return vec![];\n    }\n    match fs::read_to_string(&path) {\n        Ok(content) => match serde_json::from_str::<UserBootstrapConfig>(&content) {\n            Ok(cfg) => cfg.nodes,\n            Err(e) => {\n                warn!(\"Invalid user bootstrap json: {}\", e);\n                vec![]\n            }\n        },\n        Err(e) => {\n            debug!(\"Failed to read user bootstrap file: {}\", e);\n            vec![]\n        }\n    }\n}\n\n/// ユーザー定義のブートストラップノード（NodeAddr）\npub fn load_user_bootstrap_node_addrs() -> Vec<NodeAddr> {\n    let mut out = Vec::new();\n    for node in load_user_bootstrap_nodes() {\n        if let Some((id_part, addr_part)) = node.split_once('@') {\n            match (NodeId::from_str(id_part), addr_part.parse::<SocketAddr>()) {\n                (Ok(node_id), Ok(sock)) => {\n                    out.push(NodeAddr::new(node_id).with_direct_addresses([sock]))\n                }\n                _ => debug!(\"Invalid user bootstrap entry: {}\", node),\n            }\n        } else {\n            debug!(\"Skipping SocketAddr-only user bootstrap entry: {}\", node);\n        }\n    }\n    out\n}\n","traces":[{"line":27,"address":[18369184,18369748],"length":1,"stats":{"Line":0}},{"line":28,"address":[18370011,18369776,18369413,18369217],"length":1,"stats":{"Line":0}},{"line":29,"address":[15239879,15239814],"length":1,"stats":{"Line":0}},{"line":32,"address":[15239356,15240064,15240299,15239505,15239712],"length":1,"stats":{"Line":0}},{"line":33,"address":[14999254,14999319],"length":1,"stats":{"Line":0}},{"line":36,"address":[15025548],"length":1,"stats":{"Line":0}},{"line":40,"address":[14469104,14470091],"length":1,"stats":{"Line":0}},{"line":42,"address":[15026670],"length":1,"stats":{"Line":0}},{"line":46,"address":[15000109],"length":1,"stats":{"Line":0}},{"line":50,"address":[15241145],"length":1,"stats":{"Line":0}},{"line":58,"address":[15000528,15002014],"length":1,"stats":{"Line":0}},{"line":60,"address":[15241400],"length":1,"stats":{"Line":0}},{"line":61,"address":[15241496],"length":1,"stats":{"Line":0}},{"line":62,"address":[18371580],"length":1,"stats":{"Line":0}},{"line":64,"address":[15028007,15124121,15124255,15027719,15028752,15028173,15028877],"length":1,"stats":{"Line":0}},{"line":65,"address":[15028855],"length":1,"stats":{"Line":0}},{"line":71,"address":[18376996,18373696],"length":1,"stats":{"Line":0}},{"line":72,"address":[17730799],"length":1,"stats":{"Line":0}},{"line":73,"address":[18373776],"length":1,"stats":{"Line":0}},{"line":75,"address":[15003020,15003263,15003128,15003317],"length":1,"stats":{"Line":0}},{"line":76,"address":[15030243,15030093],"length":1,"stats":{"Line":0}},{"line":77,"address":[15244646,15244384],"length":1,"stats":{"Line":0}},{"line":78,"address":[14473253],"length":1,"stats":{"Line":0}},{"line":79,"address":[17849865,17731532,17849999,17731591,17732251],"length":1,"stats":{"Line":0}},{"line":84,"address":[14472996],"length":1,"stats":{"Line":0}},{"line":89,"address":[15251463,15247056,15256478],"length":1,"stats":{"Line":0}},{"line":90,"address":[15247118],"length":1,"stats":{"Line":0}},{"line":91,"address":[18377143],"length":1,"stats":{"Line":0}},{"line":93,"address":[18377446,18377500,18379488,18377311,18377203],"length":1,"stats":{"Line":0}},{"line":94,"address":[15033610,15033460,15037324],"length":1,"stats":{"Line":0}},{"line":95,"address":[17734309,17734378],"length":1,"stats":{"Line":0}},{"line":96,"address":[15034277],"length":1,"stats":{"Line":0}},{"line":97,"address":[15034341,15034441],"length":1,"stats":{"Line":0}},{"line":99,"address":[14476893],"length":1,"stats":{"Line":0}},{"line":100,"address":[17735067,17850393,17850527,17736945,17735738,17736344,17737010,17734711,17735411,17735543,17736409],"length":1,"stats":{"Line":0}},{"line":110,"address":[18377850,18381494],"length":1,"stats":{"Line":0}},{"line":111,"address":[15125609,15040468,15040667,15125743,15040135],"length":1,"stats":{"Line":0}},{"line":116,"address":[15037783,15038116,15126239,15126105,15038315],"length":1,"stats":{"Line":0}},{"line":121,"address":[17734065],"length":1,"stats":{"Line":0}},{"line":126,"address":[15256512],"length":1,"stats":{"Line":0}},{"line":127,"address":[15256526],"length":1,"stats":{"Line":0}},{"line":128,"address":[15042528,15042512],"length":1,"stats":{"Line":0}},{"line":129,"address":[18386720,18386704],"length":1,"stats":{"Line":0}},{"line":133,"address":[15267516,15256832,15267491],"length":1,"stats":{"Line":0}},{"line":134,"address":[18386854],"length":1,"stats":{"Line":0}},{"line":135,"address":[15016583,15016250,15017222,15099865,15017046,15016782,15099999],"length":1,"stats":{"Line":0}},{"line":138,"address":[15017160],"length":1,"stats":{"Line":0}},{"line":139,"address":[14486787,14490895,14488268],"length":1,"stats":{"Line":0}},{"line":140,"address":[15048044,15047917,15045582,15043780],"length":1,"stats":{"Line":0}},{"line":142,"address":[15046553,15127231,15127097,15045623,15046155,15045956],"length":1,"stats":{"Line":0}},{"line":143,"address":[18390611,18391961],"length":1,"stats":{"Line":0}},{"line":146,"address":[15261987,15262261],"length":1,"stats":{"Line":0}},{"line":148,"address":[18392349,18392272],"length":1,"stats":{"Line":0}},{"line":149,"address":[15024707,15024374,15100857,15100991,15024906],"length":1,"stats":{"Line":0}},{"line":151,"address":[15048586,15049587,15128089,15128223,15049118,15048919],"length":1,"stats":{"Line":0}},{"line":154,"address":[14492366],"length":1,"stats":{"Line":0}},{"line":159,"address":[15267536,15278195,15278220],"length":1,"stats":{"Line":0}},{"line":160,"address":[17750142],"length":1,"stats":{"Line":0}},{"line":161,"address":[14497526,14496554,14496887,14571449,14571583,14497350,14497086],"length":1,"stats":{"Line":0}},{"line":163,"address":[15027864],"length":1,"stats":{"Line":0}},{"line":164,"address":[15054627,15056108,15058735],"length":1,"stats":{"Line":0}},{"line":165,"address":[15054484,15056286,15058748,15058621],"length":1,"stats":{"Line":0}},{"line":167,"address":[15029591,15102479,15030123,15102345,15029924,15030521],"length":1,"stats":{"Line":0}},{"line":168,"address":[15271331,15272681],"length":1,"stats":{"Line":0}},{"line":171,"address":[18402949,18402675],"length":1,"stats":{"Line":0}},{"line":172,"address":[15272992,15273069],"length":1,"stats":{"Line":0}},{"line":173,"address":[17756658,17855145,17855279,17754535,17757316],"length":1,"stats":{"Line":0}},{"line":178,"address":[15032554,15033086,15033555,15103337,15103471,15032887],"length":1,"stats":{"Line":0}},{"line":180,"address":[15274302],"length":1,"stats":{"Line":0}},{"line":184,"address":[14507008,14511431,14511215],"length":1,"stats":{"Line":0}},{"line":185,"address":[15278263],"length":1,"stats":{"Line":0}},{"line":186,"address":[17758596],"length":1,"stats":{"Line":0}},{"line":187,"address":[15064303,15064211,15064530],"length":1,"stats":{"Line":0}},{"line":188,"address":[14507407,14507213,14507280],"length":1,"stats":{"Line":0}},{"line":190,"address":[14507194,14507244],"length":1,"stats":{"Line":0}},{"line":193,"address":[17759072,17758794],"length":1,"stats":{"Line":0}},{"line":194,"address":[17759079],"length":1,"stats":{"Line":0}},{"line":195,"address":[14507567],"length":1,"stats":{"Line":0}},{"line":196,"address":[14507579],"length":1,"stats":{"Line":0}},{"line":198,"address":[17759331,17759277,17759115],"length":1,"stats":{"Line":0}},{"line":199,"address":[17759371,17761702],"length":1,"stats":{"Line":0}},{"line":200,"address":[18412116,18412354,18412411,18412069,18412265],"length":1,"stats":{"Line":0}},{"line":201,"address":[17762057,17762143,17762153],"length":1,"stats":{"Line":0}},{"line":203,"address":[15068276,15068266,15068151],"length":1,"stats":{"Line":0}},{"line":205,"address":[18412450,18412563,18412096,18412602],"length":1,"stats":{"Line":0}},{"line":206,"address":[15041791,15041710,15041778],"length":1,"stats":{"Line":0}},{"line":208,"address":[17762291,17762304,17762238],"length":1,"stats":{"Line":0}},{"line":212,"address":[17759397,17759923,17856335,17856201,17760118],"length":1,"stats":{"Line":0}},{"line":217,"address":[15039343],"length":1,"stats":{"Line":0}},{"line":227,"address":[15068592,15068951],"length":1,"stats":{"Line":0}},{"line":228,"address":[15068988,15068609,15068976],"length":1,"stats":{"Line":0}},{"line":229,"address":[14511528,14511596],"length":1,"stats":{"Line":0}},{"line":230,"address":[17762629,17762565],"length":1,"stats":{"Line":0}},{"line":231,"address":[15282953],"length":1,"stats":{"Line":0}},{"line":235,"address":[18416493,18413104,18416520],"length":1,"stats":{"Line":0}},{"line":236,"address":[17762887],"length":1,"stats":{"Line":0}},{"line":238,"address":[17762932],"length":1,"stats":{"Line":0}},{"line":240,"address":[17763091,17763334,17763031,17765632,17765664,17765899],"length":1,"stats":{"Line":0}},{"line":241,"address":[15045815,15045750],"length":1,"stats":{"Line":0}},{"line":243,"address":[15069435,15072362,15069891,15069628,15072736,15072971],"length":1,"stats":{"Line":0}},{"line":244,"address":[14515687,14515622],"length":1,"stats":{"Line":0}},{"line":246,"address":[18416112,18415639],"length":1,"stats":{"Line":0}},{"line":251,"address":[18414925],"length":1,"stats":{"Line":0}},{"line":255,"address":[15049083,15046272],"length":1,"stats":{"Line":0}},{"line":256,"address":[15046311],"length":1,"stats":{"Line":0}},{"line":257,"address":[15046324,15046407],"length":1,"stats":{"Line":0}},{"line":258,"address":[15046468,15046766,15047596,15049120,15049355],"length":1,"stats":{"Line":0}},{"line":259,"address":[14518742,14518807],"length":1,"stats":{"Line":0}},{"line":261,"address":[15073871,15073538,15074070,15074334,15134697,15134831],"length":1,"stats":{"Line":0}},{"line":263,"address":[17766378],"length":1,"stats":{"Line":0}},{"line":267,"address":[18420208,18425906,18423562],"length":1,"stats":{"Line":0}},{"line":268,"address":[15049431],"length":1,"stats":{"Line":0}},{"line":269,"address":[15290359,15290276],"length":1,"stats":{"Line":0}},{"line":270,"address":[18420378],"length":1,"stats":{"Line":0}},{"line":272,"address":[14519173,14519230],"length":1,"stats":{"Line":0}},{"line":273,"address":[17769025,17769203],"length":1,"stats":{"Line":0}},{"line":274,"address":[17769253],"length":1,"stats":{"Line":0}},{"line":275,"address":[15076843],"length":1,"stats":{"Line":0}},{"line":276,"address":[15077611,15077079,15077412,15135193,15135327,15078011],"length":1,"stats":{"Line":0}},{"line":277,"address":[15292093],"length":1,"stats":{"Line":0}},{"line":280,"address":[18420547],"length":1,"stats":{"Line":0}},{"line":281,"address":[18424154,18423955,18424552,18479769,18423622,18479903],"length":1,"stats":{"Line":0}},{"line":282,"address":[17771955],"length":1,"stats":{"Line":0}},{"line":288,"address":[17776529,17773376,17778365],"length":1,"stats":{"Line":0}},{"line":289,"address":[17773399],"length":1,"stats":{"Line":0}},{"line":290,"address":[15082159,15081880,15082105,15081943,15084114],"length":1,"stats":{"Line":0}},{"line":291,"address":[15296295,15296437],"length":1,"stats":{"Line":0}},{"line":292,"address":[14525338,14525526],"length":1,"stats":{"Line":0}},{"line":293,"address":[15297117],"length":1,"stats":{"Line":0}},{"line":294,"address":[15297181,15297284],"length":1,"stats":{"Line":0}},{"line":296,"address":[15136185,15083320,15083653,15136319,15083852,15084116],"length":1,"stats":{"Line":0}},{"line":299,"address":[17774025,17776545,17862591,17777203,17862457],"length":1,"stats":{"Line":0}},{"line":302,"address":[17773770],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":133},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_bootstrap.rs"],"content":"//! DHT基盤のブートストラップ実装\n//! irohのビルトインDHTディスカバリーを使用した分散型ピア発見\nuse super::utils::parse_node_addr;\nuse crate::shared::error::AppError;\nuse iroh::Endpoint;\nuse iroh_gossip::{\n    api::{GossipSender, GossipTopic},\n    net::Gossip,\n    proto::TopicId,\n};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::{Mutex as TokioMutex, RwLock};\nuse tracing::{debug, info, warn};\n\nconst LOG_TARGET: &str = \"kukuri::p2p::dht\";\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\n\n/// DHT統合付きGossipサービス\npub struct DhtGossip {\n    gossip: Gossip,\n    endpoint: Arc<Endpoint>,\n    senders: Arc<RwLock<HashMap<String, Arc<TokioMutex<GossipSender>>>>>,\n}\n\nimpl DhtGossip {\n    /// DHT統合付きGossipを作成\n    pub async fn new(endpoint: Arc<Endpoint>) -> Result<Self, AppError> {\n        info!(target: LOG_TARGET, \"Initializing DHT-integrated Gossip service\");\n\n        // iroh-gossipを作成\n        let gossip = Gossip::builder().spawn(endpoint.as_ref().clone());\n\n        info!(target: LOG_TARGET, \"DHT-integrated Gossip initialized successfully\");\n\n        Ok(Self {\n            gossip,\n            endpoint,\n            senders: Arc::new(RwLock::new(HashMap::new())),\n        })\n    }\n\n    /// トピックに参加\n    pub async fn join_topic(\n        &self,\n        topic: &[u8],\n        neighbors: Vec<iroh::NodeAddr>,\n    ) -> Result<(), AppError> {\n        let topic_id = Self::make_topic_id(topic);\n        let topic_key = Self::topic_key(&topic_id);\n\n        // subscribe には NodeAddrのリストではなく、NodeIdのリストが必要\n        let peer_ids: Vec<_> = neighbors.iter().map(|addr| addr.node_id).collect();\n        let topic: GossipTopic = self\n            .gossip\n            .subscribe(topic_id, peer_ids)\n            .await\n            .map_err(|e| {\n                super::metrics::record_join_failure();\n                warn!(\n                    target: LOG_TARGET,\n                    topic = %Self::fmt_topic_id(&topic_id),\n                    error = ?e,\n                    \"Failed to join DHT topic\"\n                );\n                AppError::P2PError(format!(\"Failed to join topic: {e:?}\"))\n            })?;\n\n        // Sender を保存（Receiver は破棄しても参加状態は維持される）\n        let (sender, _receiver) = topic.split();\n        let sender = Arc::new(TokioMutex::new(sender));\n        let mut senders = self.senders.write().await;\n        senders.insert(topic_key, sender);\n\n        super::metrics::record_join_success();\n        let snap = super::metrics::snapshot();\n        info!(\n            target: METRICS_TARGET,\n            action = \"join\",\n            topic = %Self::fmt_topic_id(&topic_id),\n            joins = snap.joins,\n            join_failures = snap.join_details.failures,\n            leaves = snap.leaves,\n            broadcasts = snap.broadcasts_sent,\n            received = snap.messages_received,\n            \"Joined DHT topic\"\n        );\n        Ok(())\n    }\n\n    /// トピックから離脱\n    pub async fn leave_topic(&self, topic: &[u8]) -> Result<(), AppError> {\n        let topic_id = Self::make_topic_id(topic);\n        let topic_key = Self::topic_key(&topic_id);\n        let mut senders = self.senders.write().await;\n        if senders.remove(&topic_key).is_some() {\n            super::metrics::record_leave_success();\n            let snap = super::metrics::snapshot();\n            info!(\n                target: METRICS_TARGET,\n                action = \"leave\",\n                topic = %Self::fmt_topic_id(&topic_id),\n                leaves = snap.leaves,\n                leave_failures = snap.leave_details.failures,\n                joins = snap.joins,\n                broadcasts = snap.broadcasts_sent,\n                received = snap.messages_received,\n                \"Left DHT topic\"\n            );\n            Ok(())\n        } else {\n            super::metrics::record_leave_failure();\n            debug!(\n                target: LOG_TARGET,\n                topic = %Self::fmt_topic_id(&topic_id),\n                \"Leave requested for non-joined topic\"\n            );\n            Ok(())\n        }\n    }\n\n    /// メッセージをブロードキャスト\n    pub async fn broadcast(&self, topic: &[u8], message: Vec<u8>) -> Result<(), AppError> {\n        let topic_id = Self::make_topic_id(topic);\n        let topic_key = Self::topic_key(&topic_id);\n\n        // 既存 Sender を探す。なければ参加して作成。\n        let sender_opt = {\n            let senders = self.senders.read().await;\n            senders.get(&topic_key).cloned()\n        };\n\n        let sender = match sender_opt {\n            Some(s) => s,\n            None => {\n                // 近傍指定なしで join（Receiver は破棄）\n                let topic: GossipTopic =\n                    self.gossip.subscribe(topic_id, vec![]).await.map_err(|e| {\n                        super::metrics::record_broadcast_failure();\n                        super::metrics::record_mainline_route_failure();\n                        warn!(\n                            target: LOG_TARGET,\n                            topic = %Self::fmt_topic_id(&topic_id),\n                            error = ?e,\n                            \"Failed to lazily subscribe before broadcast\"\n                        );\n                        AppError::P2PError(format!(\"Failed to subscribe before broadcast: {e:?}\"))\n                    })?;\n                let (sender, _receiver) = topic.split();\n                let sender = Arc::new(TokioMutex::new(sender));\n                let mut senders = self.senders.write().await;\n                senders.insert(topic_key.clone(), sender.clone());\n                sender\n            }\n        };\n\n        // ブロードキャスト\n        let guard = sender.lock().await;\n        let res = guard.broadcast(message.into()).await;\n\n        match res {\n            Ok(()) => {\n                super::metrics::record_broadcast_success();\n                super::metrics::record_mainline_route_success();\n                let snap = super::metrics::snapshot();\n                debug!(\n                    target: METRICS_TARGET,\n                    action = \"broadcast\",\n                    topic = %Self::fmt_topic_id(&topic_id),\n                    broadcasts = snap.broadcasts_sent,\n                    broadcast_failures = snap.broadcast_details.failures,\n                    joins = snap.joins,\n                    leaves = snap.leaves,\n                    received = snap.messages_received,\n                    \"Broadcasted message on topic\"\n                );\n                Ok(())\n            }\n            Err(e) => {\n                super::metrics::record_broadcast_failure();\n                super::metrics::record_mainline_route_failure();\n                warn!(\n                    target: LOG_TARGET,\n                    topic = %Self::fmt_topic_id(&topic_id),\n                    error = ?e,\n                    \"Failed to broadcast gossip message\"\n                );\n                Err(AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))\n            }\n        }\n    }\n\n    /// Gossipインスタンスを取得\n    pub fn gossip(&self) -> &Gossip {\n        &self.gossip\n    }\n\n    fn make_topic_id(topic: &[u8]) -> TopicId {\n        let hash = blake3::hash(topic);\n        TopicId::from_bytes(*hash.as_bytes())\n    }\n\n    fn topic_key(topic_id: &TopicId) -> String {\n        use std::fmt::Write as _;\n        let bytes = topic_id.as_bytes();\n        let mut s = String::with_capacity(64);\n        for b in bytes {\n            let _ = write!(&mut s, \"{b:02x}\");\n        }\n        s\n    }\n\n    fn fmt_topic_id(topic_id: &TopicId) -> String {\n        Self::topic_key(topic_id)\n    }\n}\n\n/// 共有シークレット管理（シンプル版）\npub mod secret {\n    use super::*;\n    use keyring::Entry;\n    use rand::Rng;\n\n    const SERVICE_NAME: &str = \"kukuri\";\n    const SECRET_KEY: &str = \"dht_secret\";\n\n    /// シークレットを取得または生成\n    pub async fn get_or_create_secret() -> Result<Vec<u8>, AppError> {\n        // キーリングから取得を試みる\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\n            if let Ok(secret_str) = entry.get_password() {\n                use base64::prelude::*;\n                if let Ok(secret) = BASE64_STANDARD.decode(secret_str) {\n                    return Ok(secret);\n                }\n            }\n        }\n\n        // 新しいシークレットを生成\n        let mut rng = rand::thread_rng();\n        let mut secret = vec![0u8; 32];\n        rng.fill(&mut secret[..]);\n\n        // キーリングに保存\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\n            use base64::prelude::*;\n            let secret_str = BASE64_STANDARD.encode(&secret);\n            let _ = entry.set_password(&secret_str);\n        }\n\n        Ok(secret)\n    }\n\n    /// シークレットをローテーション\n    pub async fn rotate_secret() -> Result<Vec<u8>, AppError> {\n        let mut rng = rand::thread_rng();\n        let mut secret = vec![0u8; 32];\n        rng.fill(&mut secret[..]);\n\n        // キーリングに保存\n        if let Ok(entry) = Entry::new(SERVICE_NAME, SECRET_KEY) {\n            use base64::prelude::*;\n            let secret_str = BASE64_STANDARD.encode(&secret);\n            let _ = entry.set_password(&secret_str);\n        }\n\n        info!(\"DHT secret rotated\");\n        Ok(secret)\n    }\n}\n\n/// フォールバック機構\npub mod fallback {\n    use super::*;\n    use crate::infrastructure::p2p::bootstrap_config;\n    use crate::infrastructure::p2p::metrics;\n    use iroh::NodeAddr;\n\n    /// ハードコードされたブートストラップノード（将来的に設定ファイルから読み込み）\n    /// 形式: \"NodeId@Address\" (例: \"abc123...@192.168.1.1:11204\")\n    const FALLBACK_NODES: &[&str] = &[\n        // 本番環境用のブートストラップノードをここに追加\n        // 例: \"NodeId@IP:Port\"\n    ];\n\n    /// フォールバックノードに接続\n    pub async fn connect_to_fallback(endpoint: &Endpoint) -> Result<Vec<NodeAddr>, AppError> {\n        let mut connected_nodes = Vec::new();\n\n        for node_str in FALLBACK_NODES {\n            match parse_node_addr(node_str) {\n                Ok(node_addr) => {\n                    // ノードに接続を試みる\n                    match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\n                        Ok(_) => {\n                            info!(\"Connected to fallback node: {}\", node_str);\n                            metrics::record_mainline_connection_success();\n                            connected_nodes.push(node_addr);\n                        }\n                        Err(e) => {\n                            metrics::record_mainline_connection_failure();\n                            debug!(\"Failed to connect to fallback node {}: {:?}\", node_str, e);\n                        }\n                    }\n                }\n                Err(e) => {\n                    metrics::record_mainline_connection_failure();\n                    debug!(\"Failed to parse node address {}: {:?}\", node_str, e);\n                }\n            }\n        }\n\n        if connected_nodes.is_empty() {\n            return Err(AppError::P2PError(\n                \"Failed to connect to any fallback nodes\".to_string(),\n            ));\n        }\n\n        Ok(connected_nodes)\n    }\n\n    /// ユーザーUI設定 または 設定ファイル（bootstrap_nodes.json）から NodeId@Addr を読み込み接続\n    pub async fn connect_from_config(endpoint: &Endpoint) -> Result<Vec<NodeAddr>, AppError> {\n        // 1) ユーザー設定を優先\n        let mut node_addrs = bootstrap_config::load_user_bootstrap_node_addrs();\n        // 2) ユーザー設定が空なら、プロジェクト同梱のJSONを利用\n        if node_addrs.is_empty() {\n            node_addrs = bootstrap_config::load_bootstrap_node_addrs()?;\n        }\n        let mut connected = Vec::new();\n\n        for node_addr in node_addrs {\n            match endpoint.connect(node_addr.clone(), iroh_gossip::ALPN).await {\n                Ok(_) => {\n                    info!(\"Connected to config bootstrap node: {}\", node_addr.node_id);\n                    metrics::record_mainline_connection_success();\n                    connected.push(node_addr);\n                }\n                Err(e) => {\n                    metrics::record_mainline_connection_failure();\n                    debug!(\"Failed to connect to config bootstrap node: {:?}\", e);\n                }\n            }\n        }\n\n        if connected.is_empty() {\n            return Err(AppError::P2PError(\n                \"Failed to connect to nodes from bootstrap_nodes.json\".to_string(),\n            ));\n        }\n\n        Ok(connected)\n    }\n}\n","traces":[{"line":28,"address":[17015705,17011175,17011120,17015661,17011136,17015561,17011128,17011297],"length":1,"stats":{"Line":0}},{"line":29,"address":[15939324,15938725,15938823,16061305,16061439],"length":1,"stats":{"Line":0}},{"line":32,"address":[17543585,17542239,17546024],"length":1,"stats":{"Line":0}},{"line":34,"address":[17544419,17684921,17543870,17685055,17543794],"length":1,"stats":{"Line":0}},{"line":36,"address":[12330738],"length":1,"stats":{"Line":0}},{"line":37,"address":[17013942],"length":1,"stats":{"Line":0}},{"line":38,"address":[17785198],"length":1,"stats":{"Line":0}},{"line":39,"address":[17572435,17571126],"length":1,"stats":{"Line":0}},{"line":44,"address":[17015744],"length":1,"stats":{"Line":0}},{"line":49,"address":[15943505],"length":1,"stats":{"Line":0}},{"line":50,"address":[12331576,12331645],"length":1,"stats":{"Line":0}},{"line":53,"address":[17554208,17546700,17554221,17546818],"length":1,"stats":{"Line":0}},{"line":54,"address":[17016719,17017172,17017588,17016992,17016538,17016781],"length":1,"stats":{"Line":0}},{"line":56,"address":[17016640],"length":1,"stats":{"Line":0}},{"line":57,"address":[10329116],"length":1,"stats":{"Line":0}},{"line":58,"address":[17574296,17584109,17580992,17583022,17581463],"length":1,"stats":{"Line":0}},{"line":59,"address":[12339255],"length":1,"stats":{"Line":0}},{"line":60,"address":[17685417,17554350,17554873,17556303,17556641,17554729,17555746,17685551],"length":1,"stats":{"Line":0}},{"line":62,"address":[17026214,17025319],"length":1,"stats":{"Line":0}},{"line":66,"address":[17795683,17798024],"length":1,"stats":{"Line":0}},{"line":70,"address":[17574809,17574570],"length":1,"stats":{"Line":0}},{"line":71,"address":[15945268,15945141],"length":1,"stats":{"Line":0}},{"line":72,"address":[12333346,12333437,12331515,12333789],"length":1,"stats":{"Line":0}},{"line":73,"address":[17789912,17789991],"length":1,"stats":{"Line":0}},{"line":75,"address":[17018901],"length":1,"stats":{"Line":0}},{"line":76,"address":[17790144],"length":1,"stats":{"Line":0}},{"line":77,"address":[17550839,17552591],"length":1,"stats":{"Line":0}},{"line":88,"address":[17576574],"length":1,"stats":{"Line":0}},{"line":92,"address":[15954240,15954787,15954493,15954350,15954536,15954258,15954288,15957044],"length":1,"stats":{"Line":0}},{"line":93,"address":[17557626],"length":1,"stats":{"Line":0}},{"line":94,"address":[15954586],"length":1,"stats":{"Line":0}},{"line":95,"address":[15954700,15954620,15954523,15954819],"length":1,"stats":{"Line":0}},{"line":96,"address":[12343983,12346522,12343282,12343203],"length":1,"stats":{"Line":0}},{"line":97,"address":[17587749],"length":1,"stats":{"Line":0}},{"line":98,"address":[17587760],"length":1,"stats":{"Line":0}},{"line":99,"address":[17713145,17589301,17587779,17591053,17713279,17588310],"length":1,"stats":{"Line":0}},{"line":110,"address":[15958300],"length":1,"stats":{"Line":0}},{"line":112,"address":[15955271],"length":1,"stats":{"Line":0}},{"line":113,"address":[17586641,17587353],"length":1,"stats":{"Line":0}},{"line":118,"address":[17585747],"length":1,"stats":{"Line":0}},{"line":123,"address":[17565837,17567372,17565714,17566082,17565760,17566491,17565696,17568770],"length":1,"stats":{"Line":0}},{"line":124,"address":[17806888],"length":1,"stats":{"Line":0}},{"line":125,"address":[17035857],"length":1,"stats":{"Line":0}},{"line":129,"address":[12351483,12351338,12351072,12351247],"length":1,"stats":{"Line":0}},{"line":130,"address":[15963566,15963503],"length":1,"stats":{"Line":0}},{"line":133,"address":[15963672],"length":1,"stats":{"Line":0}},{"line":134,"address":[17807894],"length":1,"stats":{"Line":0}},{"line":137,"address":[17822728,17821641,17807863,17820082,17808213,17806965,17819600,17808921,17807979],"length":1,"stats":{"Line":0}},{"line":139,"address":[12363767],"length":1,"stats":{"Line":0}},{"line":140,"address":[12363822],"length":1,"stats":{"Line":0}},{"line":141,"address":[17714137,17606132,17605988,17605609,17607562,17607005,17714271,17607900],"length":1,"stats":{"Line":0}},{"line":143,"address":[17049842,17050737],"length":1,"stats":{"Line":0}},{"line":147,"address":[17606110,17608451],"length":1,"stats":{"Line":0}},{"line":149,"address":[17568174,17567935],"length":1,"stats":{"Line":0}},{"line":150,"address":[17595140,17595009],"length":1,"stats":{"Line":0}},{"line":151,"address":[10325822],"length":1,"stats":{"Line":0}},{"line":152,"address":[17595908,17596571,17595979],"length":1,"stats":{"Line":0}},{"line":153,"address":[17569480],"length":1,"stats":{"Line":0}},{"line":158,"address":[17810779,17810551,17807007,17808167],"length":1,"stats":{"Line":0}},{"line":159,"address":[17570181,17570266,17566196],"length":1,"stats":{"Line":0}},{"line":161,"address":[17570740],"length":1,"stats":{"Line":0}},{"line":163,"address":[15967307],"length":1,"stats":{"Line":0}},{"line":164,"address":[12355831],"length":1,"stats":{"Line":0}},{"line":165,"address":[17040482],"length":1,"stats":{"Line":0}},{"line":166,"address":[15968974,15970752],"length":1,"stats":{"Line":0}},{"line":177,"address":[17812240],"length":1,"stats":{"Line":0}},{"line":179,"address":[17040377],"length":1,"stats":{"Line":0}},{"line":180,"address":[17040457],"length":1,"stats":{"Line":0}},{"line":181,"address":[12360570],"length":1,"stats":{"Line":0}},{"line":182,"address":[12361125,12362877,12473353,12361987,12360581,12473487],"length":1,"stats":{"Line":0}},{"line":188,"address":[15974949,15972649],"length":1,"stats":{"Line":0}},{"line":194,"address":[17822752],"length":1,"stats":{"Line":0}},{"line":198,"address":[15978384],"length":1,"stats":{"Line":0}},{"line":199,"address":[17608696],"length":1,"stats":{"Line":0}},{"line":200,"address":[15978419],"length":1,"stats":{"Line":0}},{"line":203,"address":[17052261,17051648],"length":1,"stats":{"Line":0}},{"line":205,"address":[15978534],"length":1,"stats":{"Line":0}},{"line":206,"address":[17582118],"length":1,"stats":{"Line":0}},{"line":207,"address":[17051800,17051728,17051917],"length":1,"stats":{"Line":0}},{"line":208,"address":[15978781],"length":1,"stats":{"Line":0}},{"line":210,"address":[17051883],"length":1,"stats":{"Line":0}},{"line":213,"address":[12367648],"length":1,"stats":{"Line":0}},{"line":214,"address":[15979153],"length":1,"stats":{"Line":0}},{"line":228,"address":[18329872,18329856,18329902,18329976,18331736,18330869],"length":1,"stats":{"Line":0}},{"line":230,"address":[15501151,15501257],"length":1,"stats":{"Line":0}},{"line":231,"address":[12157325,12157235],"length":1,"stats":{"Line":0}},{"line":233,"address":[12130656,12130778],"length":1,"stats":{"Line":0}},{"line":234,"address":[11600465],"length":1,"stats":{"Line":0}},{"line":240,"address":[11600998,11600942],"length":1,"stats":{"Line":0}},{"line":241,"address":[12131406],"length":1,"stats":{"Line":0}},{"line":242,"address":[12372402,12372315],"length":1,"stats":{"Line":0}},{"line":245,"address":[12372421],"length":1,"stats":{"Line":0}},{"line":247,"address":[11601300],"length":1,"stats":{"Line":0}},{"line":248,"address":[12158612,12158544],"length":1,"stats":{"Line":0}},{"line":251,"address":[12372893],"length":1,"stats":{"Line":0}},{"line":255,"address":[12373088,12373188,12373127,12373992,12375919,12373072],"length":1,"stats":{"Line":0}},{"line":256,"address":[12159073,12159168],"length":1,"stats":{"Line":0}},{"line":257,"address":[11602040],"length":1,"stats":{"Line":0}},{"line":258,"address":[15503429,15503330],"length":1,"stats":{"Line":0}},{"line":261,"address":[18332164],"length":1,"stats":{"Line":0}},{"line":263,"address":[15503559],"length":1,"stats":{"Line":0}},{"line":264,"address":[12373683,12373763],"length":1,"stats":{"Line":0}},{"line":267,"address":[12373945,12374607,12404617,12404751,12374030],"length":1,"stats":{"Line":0}},{"line":268,"address":[12374502],"length":1,"stats":{"Line":0}},{"line":287,"address":[18146933,18139224,18138768,18139027,18138862,18138800,18138984,18138776],"length":1,"stats":{"Line":0}},{"line":288,"address":[18138961],"length":1,"stats":{"Line":0}},{"line":290,"address":[11327525,11332585,11332648,11327622],"length":1,"stats":{"Line":0}},{"line":291,"address":[18117905,18117530],"length":1,"stats":{"Line":0}},{"line":292,"address":[18117920],"length":1,"stats":{"Line":0}},{"line":294,"address":[11187031],"length":1,"stats":{"Line":0}},{"line":296,"address":[12957993,12958127,12898123,12898616,12897934],"length":1,"stats":{"Line":0}},{"line":297,"address":[18113635],"length":1,"stats":{"Line":0}},{"line":298,"address":[11330241],"length":1,"stats":{"Line":0}},{"line":300,"address":[12897965],"length":1,"stats":{"Line":0}},{"line":301,"address":[11328255],"length":1,"stats":{"Line":0}},{"line":302,"address":[11330957,11330421,11377289,11377423],"length":1,"stats":{"Line":0}},{"line":306,"address":[12902989],"length":1,"stats":{"Line":0}},{"line":307,"address":[18144803],"length":1,"stats":{"Line":0}},{"line":308,"address":[11333356,11333888,11377919,11377785],"length":1,"stats":{"Line":0}},{"line":313,"address":[18358312,18358406],"length":1,"stats":{"Line":0}},{"line":314,"address":[18358635],"length":1,"stats":{"Line":0}},{"line":315,"address":[18358518],"length":1,"stats":{"Line":0}},{"line":319,"address":[11332714],"length":1,"stats":{"Line":0}},{"line":323,"address":[11335587,11335392,11335454,11335645,11341850,11335360,11336402,11335368],"length":1,"stats":{"Line":0}},{"line":325,"address":[12905424],"length":1,"stats":{"Line":0}},{"line":327,"address":[12905555,12905655,12906031],"length":1,"stats":{"Line":0}},{"line":328,"address":[11336374,11335831],"length":1,"stats":{"Line":0}},{"line":330,"address":[17590301],"length":1,"stats":{"Line":0}},{"line":332,"address":[18367003,18361908,18362030,18366851,18366962],"length":1,"stats":{"Line":0}},{"line":333,"address":[10972567],"length":1,"stats":{"Line":0}},{"line":335,"address":[17591404,17644255,17592086,17591593,17644121],"length":1,"stats":{"Line":0}},{"line":336,"address":[18149201],"length":1,"stats":{"Line":0}},{"line":337,"address":[12908865],"length":1,"stats":{"Line":0}},{"line":339,"address":[18121835],"length":1,"stats":{"Line":0}},{"line":340,"address":[11336985],"length":1,"stats":{"Line":0}},{"line":341,"address":[18175151,18124625,18175017,18124089],"length":1,"stats":{"Line":0}},{"line":346,"address":[12911237],"length":1,"stats":{"Line":0}},{"line":347,"address":[18367397],"length":1,"stats":{"Line":0}},{"line":348,"address":[11341486],"length":1,"stats":{"Line":0}},{"line":352,"address":[11341356],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":140},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","dht_integration.rs"],"content":"//! DHT統合モジュール\n//! iroh-gossipとdistributed-topic-trackerの統合\nuse crate::domain::entities::Event;\nuse crate::infrastructure::p2p::dht_bootstrap::DhtGossip;\nuse crate::shared::error::AppError;\n// use iroh_gossip::proto::Event as GossipEvent;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{debug, error};\n\n/// DHTイベントハンドラー\npub struct DhtEventHandler {\n    event_tx: mpsc::Sender<Event>,\n    dht_gossip: Arc<DhtGossip>,\n}\n\nimpl DhtEventHandler {\n    /// 新しいハンドラーを作成\n    pub fn new(event_tx: mpsc::Sender<Event>, dht_gossip: Arc<DhtGossip>) -> Self {\n        Self {\n            event_tx,\n            dht_gossip,\n        }\n    }\n\n    /// Gossipメッセージを処理\n    pub async fn handle_message(&self, data: &[u8], from: Option<String>) -> Result<(), AppError> {\n        debug!(\"Received message from {:?}\", from);\n\n        // メッセージをデシリアライズ\n        if let Ok(event) = self.deserialize_message(data).await {\n            // イベントチャンネルに送信\n            if let Err(e) = self.event_tx.send(event).await {\n                error!(\"Failed to send event: {:?}\", e);\n            }\n        }\n        Ok(())\n    }\n\n    /// メッセージをデシリアライズ\n    async fn deserialize_message(&self, data: &[u8]) -> Result<Event, AppError> {\n        bincode::serde::decode_from_slice::<Event, _>(data, bincode::config::standard())\n            .map(|(event, _)| event)\n            .map_err(|e| AppError::DeserializationError(format!(\"Failed to deserialize: {e:?}\")))\n    }\n}\n\n/// DHT統合マネージャー\npub struct DhtIntegration {\n    dht_gossip: Arc<DhtGossip>,\n    event_handler: Option<DhtEventHandler>,\n}\n\nimpl DhtIntegration {\n    /// 新しい統合マネージャーを作成\n    pub fn new(dht_gossip: Arc<DhtGossip>) -> Self {\n        Self {\n            dht_gossip,\n            event_handler: None,\n        }\n    }\n\n    /// イベントハンドラーを設定\n    pub fn set_event_handler(&mut self, event_tx: mpsc::Sender<Event>) {\n        self.event_handler = Some(DhtEventHandler::new(event_tx, Arc::clone(&self.dht_gossip)));\n    }\n\n    /// トピックに参加\n    pub async fn join_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.dht_gossip.join_topic(topic.as_bytes(), vec![]).await?;\n        Ok(())\n    }\n\n    /// トピックから離脱\n    pub async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\n        self.dht_gossip.leave_topic(topic.as_bytes()).await?;\n        Ok(())\n    }\n\n    /// イベントをブロードキャスト\n    pub async fn broadcast_event(&self, topic: &str, event: &Event) -> Result<(), AppError> {\n        // イベントをシリアライズ\n        let message = bincode::serde::encode_to_vec(event, bincode::config::standard())\n            .map_err(|e| AppError::SerializationError(format!(\"Failed to serialize: {e:?}\")))?;\n\n        // DHTにブロードキャスト\n        self.dht_gossip.broadcast(topic.as_bytes(), message).await?;\n\n        debug!(\"Event broadcast to topic: {}\", topic);\n        Ok(())\n    }\n}\n\n/// NostrとDHTのブリッジ\npub mod bridge {\n    use super::*;\n    use nostr_sdk::Event as NostrEvent;\n\n    /// NostrイベントをKukuriイベントに変換\n    pub fn nostr_to_kukuri(_event: &NostrEvent) -> Result<Event, AppError> {\n        // TODO: 実装\n        Err(AppError::NotImplemented(\n            \"Conversion not implemented\".to_string(),\n        ))\n    }\n\n    /// KukuriイベントをNostrイベントに変換\n    pub fn kukuri_to_nostr(_event: &Event) -> Result<NostrEvent, AppError> {\n        // TODO: 実装\n        Err(AppError::NotImplemented(\n            \"Conversion not implemented\".to_string(),\n        ))\n    }\n}\n","traces":[{"line":19,"address":[12673024],"length":1,"stats":{"Line":0}},{"line":27,"address":[12434719,12435384,12432224,12437739,12432335,12432242,12432515,12432288],"length":1,"stats":{"Line":0}},{"line":28,"address":[12432487,12432634,12509247,12433163,12509113],"length":1,"stats":{"Line":0}},{"line":31,"address":[12461326,12461487,12459858,12459281],"length":1,"stats":{"Line":0}},{"line":33,"address":[11904725,11902166,11904993,11904852],"length":1,"stats":{"Line":0}},{"line":34,"address":[13056617,13032523,13032616,13033113,13056751],"length":1,"stats":{"Line":0}},{"line":37,"address":[11904946],"length":1,"stats":{"Line":0}},{"line":41,"address":[13035010,13034656,13034734,13034674,13034704,13034834],"length":1,"stats":{"Line":0}},{"line":42,"address":[15808974,15808887],"length":1,"stats":{"Line":0}},{"line":43,"address":[12438316,12438304],"length":1,"stats":{"Line":0}},{"line":44,"address":[13035088,13035118],"length":1,"stats":{"Line":0}},{"line":56,"address":[12465328],"length":1,"stats":{"Line":0}},{"line":64,"address":[11908240,11908472,11908498],"length":1,"stats":{"Line":0}},{"line":65,"address":[12438659,12438882],"length":1,"stats":{"Line":0}},{"line":69,"address":[13036515,13035891,13035731,13036112,13035696,13035666,13035851,13035648],"length":1,"stats":{"Line":0}},{"line":70,"address":[12439676,12439103,12439146,12439216,12439424,12439813],"length":1,"stats":{"Line":0}},{"line":71,"address":[12680494],"length":1,"stats":{"Line":0}},{"line":75,"address":[11909442,11909472,11909858,11909671,11909424,11909507,11910282,11909631],"length":1,"stats":{"Line":0}},{"line":76,"address":[12681122,12681512,12680890,12681375,12680960,12680847],"length":1,"stats":{"Line":0}},{"line":77,"address":[12467265],"length":1,"stats":{"Line":0}},{"line":81,"address":[12684855,12681647,12681536,12681559,12681894,12682519,12681600,12681836],"length":1,"stats":{"Line":0}},{"line":83,"address":[12682189,12681952,12681825,12682497],"length":1,"stats":{"Line":0}},{"line":84,"address":[13037965,13040686,13040656],"length":1,"stats":{"Line":0}},{"line":87,"address":[12684850,12681866,12682138,12682551,12682834,12682274],"length":1,"stats":{"Line":0}},{"line":89,"address":[12750937,12682910,12682806,12683421,12751071],"length":1,"stats":{"Line":0}},{"line":90,"address":[12683382],"length":1,"stats":{"Line":0}},{"line":100,"address":[13207392],"length":1,"stats":{"Line":0}},{"line":102,"address":[12436212],"length":1,"stats":{"Line":0}},{"line":103,"address":[16337395],"length":1,"stats":{"Line":0}},{"line":108,"address":[13207552],"length":1,"stats":{"Line":0}},{"line":110,"address":[17778596],"length":1,"stats":{"Line":0}},{"line":111,"address":[17778563],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","discovery_options.rs"],"content":"use crate::shared::config::NetworkConfig;\n\n/// P2Pネットワークのディスカバリー設定\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct DiscoveryOptions {\n    pub enable_dns: bool,\n    pub enable_mainline: bool,\n    pub enable_local: bool,\n}\n\nimpl DiscoveryOptions {\n    pub fn new(enable_dns: bool, enable_mainline: bool, enable_local: bool) -> Self {\n        Self {\n            enable_dns,\n            enable_mainline,\n            enable_local,\n        }\n    }\n\n    pub fn with_mainline(mut self, enabled: bool) -> Self {\n        self.enable_mainline = enabled;\n        self\n    }\n\n    pub fn enable_mainline(&self) -> bool {\n        self.enable_mainline\n    }\n\n    pub fn apply_to_builder(\n        &self,\n        mut builder: iroh::endpoint::Builder,\n    ) -> iroh::endpoint::Builder {\n        if self.enable_dns {\n            builder = builder.discovery_n0();\n        }\n        if self.enable_mainline {\n            builder = builder.discovery_dht();\n        }\n        if self.enable_local {\n            builder = builder.discovery_local_network();\n        }\n        builder\n    }\n}\n\nimpl Default for DiscoveryOptions {\n    fn default() -> Self {\n        Self {\n            enable_dns: true,\n            enable_mainline: true,\n            enable_local: false,\n        }\n    }\n}\n\nimpl From<&NetworkConfig> for DiscoveryOptions {\n    fn from(cfg: &NetworkConfig) -> Self {\n        Self {\n            enable_dns: cfg.enable_dns,\n            enable_mainline: cfg.enable_dht,\n            enable_local: cfg.enable_local,\n        }\n    }\n}\n","traces":[{"line":12,"address":[14530848],"length":1,"stats":{"Line":0}},{"line":20,"address":[15061312],"length":1,"stats":{"Line":0}},{"line":21,"address":[18432173],"length":1,"stats":{"Line":0}},{"line":22,"address":[14811441],"length":1,"stats":{"Line":0}},{"line":25,"address":[15088144],"length":1,"stats":{"Line":0}},{"line":26,"address":[15088149],"length":1,"stats":{"Line":0}},{"line":29,"address":[15088160],"length":1,"stats":{"Line":0}},{"line":33,"address":[15302383,15302305],"length":1,"stats":{"Line":0}},{"line":34,"address":[14811575],"length":1,"stats":{"Line":0}},{"line":36,"address":[15061483,15061632],"length":1,"stats":{"Line":0}},{"line":37,"address":[14811650],"length":1,"stats":{"Line":0}},{"line":39,"address":[15061558,15061732],"length":1,"stats":{"Line":0}},{"line":40,"address":[15302502],"length":1,"stats":{"Line":0}},{"line":42,"address":[15061643],"length":1,"stats":{"Line":0}},{"line":57,"address":[15302608],"length":1,"stats":{"Line":0}},{"line":59,"address":[18432600],"length":1,"stats":{"Line":0}},{"line":60,"address":[14811861],"length":1,"stats":{"Line":0}},{"line":61,"address":[14811867],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","event_distributor.rs"],"content":"use crate::domain::entities::Event;\nuse async_trait::async_trait;\nuse std::collections::VecDeque;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info};\n\n#[derive(Debug, Clone)]\npub enum DistributionStrategy {\n    Broadcast,      // 全ピアに配信\n    Gossip,         // Gossipプロトコルで配信\n    Direct(String), // 特定のピアに直接配信\n    Hybrid,         // NostrとP2Pの両方で配信\n    Nostr,          // Nostrリレー経由のみ\n    P2P,            // P2Pネットワークのみ\n}\n\n#[async_trait]\npub trait EventDistributor: Send + Sync {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn set_strategy(&self, strategy: DistributionStrategy);\n    async fn get_pending_events(\n        &self,\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>>;\n}\n\n/// デフォルトのEventDistributor実装\npub struct DefaultEventDistributor {\n    inner: Arc<RwLock<EventDistributorInner>>,\n}\n\nstruct EventDistributorInner {\n    strategy: DistributionStrategy,\n    pending_events: VecDeque<Event>,\n    failed_events: Vec<(Event, DistributionStrategy)>,\n    max_retries: u32,\n}\n\nimpl DefaultEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(EventDistributorInner {\n                strategy: DistributionStrategy::Hybrid,\n                pending_events: VecDeque::new(),\n                failed_events: Vec::new(),\n                max_retries: 3,\n            })),\n        }\n    }\n\n    pub fn with_strategy(strategy: DistributionStrategy) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(EventDistributorInner {\n                strategy,\n                pending_events: VecDeque::new(),\n                failed_events: Vec::new(),\n                max_retries: 3,\n            })),\n        }\n    }\n\n    /// 実際の配信処理（プライベートメソッド）\n    async fn distribute_internal(\n        &self,\n        event: &Event,\n        strategy: &DistributionStrategy,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        match strategy {\n            DistributionStrategy::Broadcast => {\n                debug!(\"Broadcasting event {} to all peers\", event.id);\n                // TODO: 実際のブロードキャスト実装\n                // 現在はモック実装\n                info!(\"Event {} broadcasted successfully\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Gossip => {\n                debug!(\"Distributing event {} via Gossip protocol\", event.id);\n                // TODO: Gossipプロトコルでの配信実装\n                // 現在はモック実装\n                info!(\"Event {} distributed via Gossip\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::Direct(peer_id) => {\n                debug!(\"Sending event {} directly to peer {}\", event.id, peer_id);\n                // TODO: 特定ピアへの直接送信実装\n                // 現在はモック実装\n                info!(\"Event {} sent to peer {}\", event.id, peer_id);\n                Ok(())\n            }\n            DistributionStrategy::Hybrid => {\n                debug!(\"Distributing event {} using hybrid strategy\", event.id);\n                // NostrとP2Pの両方で配信\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::Nostr)).await?;\n                Box::pin(self.distribute_internal(event, &DistributionStrategy::P2P)).await?;\n                Ok(())\n            }\n            DistributionStrategy::Nostr => {\n                debug!(\"Distributing event {} via Nostr relays\", event.id);\n                // TODO: Nostrリレーへの配信実装\n                // 現在はモック実装\n                info!(\"Event {} sent to Nostr relays\", event.id);\n                Ok(())\n            }\n            DistributionStrategy::P2P => {\n                debug!(\"Distributing event {} via P2P network\", event.id);\n                // TODO: P2Pネットワークへの配信実装\n                // 現在はモック実装\n                info!(\"Event {} distributed via P2P\", event.id);\n                Ok(())\n            }\n        }\n    }\n}\n\nimpl Default for DefaultEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for DefaultEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        strategy: DistributionStrategy,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        debug!(\n            \"Distributing event {} with strategy {:?}\",\n            event.id, strategy\n        );\n\n        // 配信を試行\n        match self.distribute_internal(event, &strategy).await {\n            Ok(()) => {\n                info!(\"Event {} distributed successfully\", event.id);\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"Failed to distribute event {}: {}\", event.id, e);\n\n                // 失敗したイベントを記録\n                let mut inner = self.inner.write().await;\n                inner.failed_events.push((event.clone(), strategy));\n\n                Err(e)\n            }\n        }\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        let mut inner = self.inner.write().await;\n        Ok(inner.pending_events.pop_front())\n    }\n\n    async fn set_strategy(&self, strategy: DistributionStrategy) {\n        let mut inner = self.inner.write().await;\n        debug!(\"Setting distribution strategy to {:?}\", strategy);\n        inner.strategy = strategy;\n    }\n\n    async fn get_pending_events(\n        &self,\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        let inner = self.inner.read().await;\n        Ok(inner.pending_events.iter().cloned().collect())\n    }\n\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\n        let mut inner = self.inner.write().await;\n        let failed_events = std::mem::take(&mut inner.failed_events);\n        let mut retry_count = 0;\n        let mut still_failed = Vec::new();\n\n        for (event, strategy) in failed_events {\n            debug!(\"Retrying distribution for event {}\", event.id);\n            match self.distribute_internal(&event, &strategy).await {\n                Ok(()) => {\n                    info!(\"Event {} successfully distributed on retry\", event.id);\n                    retry_count += 1;\n                }\n                Err(e) => {\n                    error!(\"Event {} failed again on retry: {}\", event.id, e);\n                    still_failed.push((event, strategy));\n                }\n            }\n        }\n\n        // まだ失敗しているイベントを戻す\n        inner.failed_events = still_failed;\n\n        Ok(retry_count)\n    }\n}\n\n/// P2P配信専用実装\npub struct P2PEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl P2PEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::P2P),\n        }\n    }\n}\n\nimpl Default for P2PEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for P2PEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy, // P2Pのみ使用\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor\n            .distribute(event, DistributionStrategy::P2P)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // P2P専用なので変更しない\n    }\n\n    async fn get_pending_events(\n        &self,\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.retry_failed().await\n    }\n}\n\n/// Nostr配信専用実装\npub struct NostrEventDistributor {\n    distributor: DefaultEventDistributor,\n}\n\nimpl NostrEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributor: DefaultEventDistributor::with_strategy(DistributionStrategy::Nostr),\n        }\n    }\n}\n\nimpl Default for NostrEventDistributor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl EventDistributor for NostrEventDistributor {\n    async fn distribute(\n        &self,\n        event: &Event,\n        _strategy: DistributionStrategy, // Nostrのみ使用\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor\n            .distribute(event, DistributionStrategy::Nostr)\n            .await\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.receive().await\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {\n        // Nostr専用なので変更しない\n    }\n\n    async fn get_pending_events(\n        &self,\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.get_pending_events().await\n    }\n\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\n        self.distributor.retry_failed().await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::entities::EventKind;\n\n    fn create_test_event() -> Event {\n        Event {\n            id: \"test_event_123\".to_string(),\n            pubkey: \"test_pubkey\".to_string(),\n            created_at: chrono::Utc::now(),\n            kind: EventKind::TextNote.into(),\n            tags: vec![],\n            content: \"Test event content\".to_string(),\n            sig: \"test_signature\".to_string(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_default_distributor_creation() {\n        let distributor = DefaultEventDistributor::new();\n        let inner = distributor.inner.read().await;\n        assert!(matches!(inner.strategy, DistributionStrategy::Hybrid));\n    }\n\n    #[tokio::test]\n    async fn test_set_strategy() {\n        let distributor = DefaultEventDistributor::new();\n        distributor.set_strategy(DistributionStrategy::P2P).await;\n\n        let inner = distributor.inner.read().await;\n        assert!(matches!(inner.strategy, DistributionStrategy::P2P));\n    }\n\n    #[tokio::test]\n    async fn test_distribute_event() {\n        let distributor = DefaultEventDistributor::new();\n        let event = create_test_event();\n\n        let result = distributor\n            .distribute(&event, DistributionStrategy::Broadcast)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_hybrid_distribution() {\n        let distributor = DefaultEventDistributor::new();\n        let event = create_test_event();\n\n        let result = distributor\n            .distribute(&event, DistributionStrategy::Hybrid)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_get_pending_events_empty() {\n        let distributor = DefaultEventDistributor::new();\n        let events = distributor.get_pending_events().await.unwrap();\n        assert_eq!(events.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_p2p_distributor() {\n        let distributor = P2PEventDistributor::new();\n        let event = create_test_event();\n\n        // P2P distributorは常にP2P戦略を使用\n        let result = distributor\n            .distribute(&event, DistributionStrategy::Broadcast)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_nostr_distributor() {\n        let distributor = NostrEventDistributor::new();\n        let event = create_test_event();\n\n        // Nostr distributorは常にNostr戦略を使用\n        let result = distributor\n            .distribute(&event, DistributionStrategy::P2P)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_retry_failed_with_no_failures() {\n        let distributor = DefaultEventDistributor::new();\n        let retry_count = distributor.retry_failed().await.unwrap();\n        assert_eq!(retry_count, 0);\n    }\n}\n","traces":[{"line":46,"address":[16236748,16236384],"length":1,"stats":{"Line":1}},{"line":48,"address":[12285268],"length":1,"stats":{"Line":1}},{"line":57,"address":[17008016,17008381],"length":1,"stats":{"Line":1}},{"line":59,"address":[12285641],"length":1,"stats":{"Line":1}},{"line":69,"address":[16794320],"length":1,"stats":{"Line":1}},{"line":74,"address":[16767830],"length":1,"stats":{"Line":1}},{"line":76,"address":[16794950,16795460,16905001,16794694,16905135],"length":1,"stats":{"Line":3}},{"line":79,"address":[11555614,11553646,11555118,11663721,11663855],"length":1,"stats":{"Line":3}},{"line":80,"address":[16240230],"length":1,"stats":{"Line":1}},{"line":83,"address":[16798891,16799401,16905993,16794725,16906127],"length":1,"stats":{"Line":0}},{"line":86,"address":[17013459,17014931,17015427,17120585,17120719],"length":1,"stats":{"Line":0}},{"line":87,"address":[11559531],"length":1,"stats":{"Line":0}},{"line":89,"address":[17008860],"length":1,"stats":{"Line":0}},{"line":90,"address":[17121081,17008868,17017371,17016861,17121215],"length":1,"stats":{"Line":0}},{"line":93,"address":[16907615,16803237,16804795,16805291,16907481],"length":1,"stats":{"Line":0}},{"line":94,"address":[16248131],"length":1,"stats":{"Line":0}},{"line":97,"address":[17122073,17008899,17020907,17021431,17122207],"length":1,"stats":{"Line":3}},{"line":99,"address":[11227857],"length":1,"stats":{"Line":2}},{"line":100,"address":[10987045],"length":1,"stats":{"Line":2}},{"line":101,"address":[16790713],"length":1,"stats":{"Line":1}},{"line":104,"address":[12300401,12395481,12300911,12286402,12395615],"length":1,"stats":{"Line":3}},{"line":107,"address":[16784085,16784581,16882367,16782613,16882233],"length":1,"stats":{"Line":3}},{"line":108,"address":[17025389],"length":1,"stats":{"Line":1}},{"line":111,"address":[12304267,12396607,12304777,12396473,12286433],"length":1,"stats":{"Line":3}},{"line":114,"address":[12304739,12306703,12397103,12306207,12396969],"length":1,"stats":{"Line":4}},{"line":115,"address":[17029263],"length":1,"stats":{"Line":2}},{"line":122,"address":[16817568],"length":1,"stats":{"Line":0}},{"line":123,"address":[16790833],"length":1,"stats":{"Line":0}},{"line":134,"address":[17125753,17146943,17146809,17125152,17125232],"length":1,"stats":{"Line":3}},{"line":140,"address":[16356038,16354472,16353575,16356158],"length":1,"stats":{"Line":2}},{"line":142,"address":[12419951,12419817,12400484,12400586,12401082],"length":1,"stats":{"Line":3}},{"line":143,"address":[16914109],"length":1,"stats":{"Line":1}},{"line":145,"address":[17127659],"length":1,"stats":{"Line":0}},{"line":146,"address":[17130272,17127695,17147801,17147935,17129759],"length":1,"stats":{"Line":0}},{"line":149,"address":[14497388],"length":1,"stats":{"Line":0}},{"line":150,"address":[11676205,11676278],"length":1,"stats":{"Line":0}},{"line":152,"address":[16918227],"length":1,"stats":{"Line":0}},{"line":157,"address":[16892257,16891753,16891926,16892691,16891792,16891827,16892078],"length":1,"stats":{"Line":0}},{"line":158,"address":[17133121,17132970,17132785],"length":1,"stats":{"Line":0}},{"line":159,"address":[17133424,17133351],"length":1,"stats":{"Line":0}},{"line":162,"address":[16362319,16362580,16365330,16365354,16362786,16362415,16362384],"length":1,"stats":{"Line":3}},{"line":163,"address":[16893218,16893079,16892961,16893010],"length":1,"stats":{"Line":2}},{"line":164,"address":[11678496,11692425,11692559,11679060,11678417],"length":1,"stats":{"Line":3}},{"line":165,"address":[16920744,16922172,16922434],"length":1,"stats":{"Line":1}},{"line":171,"address":[16896017,16896239,16896390],"length":1,"stats":{"Line":1}},{"line":172,"address":[12410128,12410191],"length":1,"stats":{"Line":2}},{"line":175,"address":[11683274,11681967,11682113,11682329,11681871,11681920,11682536],"length":1,"stats":{"Line":3}},{"line":176,"address":[16924167,16924344,16923919],"length":1,"stats":{"Line":1}},{"line":177,"address":[11682909,11682810],"length":1,"stats":{"Line":2}},{"line":178,"address":[16367584],"length":1,"stats":{"Line":1}},{"line":179,"address":[16367599],"length":1,"stats":{"Line":1}},{"line":181,"address":[11683039,11683167,11688122,11688305,11688237],"length":1,"stats":{"Line":3}},{"line":182,"address":[16934697,16930177,16930632,16931158,16934831],"length":1,"stats":{"Line":0}},{"line":183,"address":[11690707,11683283,11683560,11689328,11682164],"length":1,"stats":{"Line":0}},{"line":184,"address":[16900684],"length":1,"stats":{"Line":0}},{"line":185,"address":[16925463,16925979,16935193,16925365,16935327],"length":1,"stats":{"Line":0}},{"line":186,"address":[17140031,17141505,17141518],"length":1,"stats":{"Line":0}},{"line":188,"address":[17139489],"length":1,"stats":{"Line":0}},{"line":189,"address":[17142340,17149785,17149919,17139521,17141612],"length":1,"stats":{"Line":0}},{"line":190,"address":[17142087],"length":1,"stats":{"Line":0}},{"line":196,"address":[16903857,16903472],"length":1,"stats":{"Line":1}},{"line":198,"address":[17144575],"length":1,"stats":{"Line":1}},{"line":208,"address":[16260448],"length":1,"stats":{"Line":1}},{"line":210,"address":[16260452],"length":1,"stats":{"Line":1}},{"line":216,"address":[12309072],"length":1,"stats":{"Line":0}},{"line":217,"address":[16817617],"length":1,"stats":{"Line":0}},{"line":228,"address":[16379798,16379525,16379640],"length":1,"stats":{"Line":3}},{"line":229,"address":[16379498],"length":1,"stats":{"Line":1}},{"line":230,"address":[11695200,11694969,11695070,11694581,11695013],"length":1,"stats":{"Line":3}},{"line":233,"address":[16937879,16937168,16937203,16937302,16937129,16937454,16937614],"length":1,"stats":{"Line":0}},{"line":234,"address":[16380510,16380193,16380378],"length":1,"stats":{"Line":0}},{"line":237,"address":[16911216,16911230,16911392,16911161,16911316],"length":1,"stats":{"Line":0}},{"line":244,"address":[16381233,16381461,16381593],"length":1,"stats":{"Line":0}},{"line":247,"address":[16381955,16382345,16381881,16381920,16382024,16382186,16382565],"length":1,"stats":{"Line":0}},{"line":248,"address":[14494148],"length":1,"stats":{"Line":0}},{"line":258,"address":[11575856],"length":1,"stats":{"Line":1}},{"line":260,"address":[12309092],"length":1,"stats":{"Line":1}},{"line":266,"address":[16817664],"length":1,"stats":{"Line":0}},{"line":267,"address":[16260529],"length":1,"stats":{"Line":0}},{"line":278,"address":[17154456,17154614,17154341],"length":1,"stats":{"Line":3}},{"line":279,"address":[16913482],"length":1,"stats":{"Line":1}},{"line":280,"address":[11363966],"length":1,"stats":{"Line":3}},{"line":283,"address":[16384062,16383651,16383616,16383750,16383577,16383902,16384327],"length":1,"stats":{"Line":0}},{"line":284,"address":[11142868],"length":1,"stats":{"Line":0}},{"line":287,"address":[16941481,16941712,16941550,16941536,16941636],"length":1,"stats":{"Line":0}},{"line":294,"address":[11139332],"length":1,"stats":{"Line":0}},{"line":297,"address":[12429040,12429144,12429302,12429075,12429001,12429449,12429657],"length":1,"stats":{"Line":0}},{"line":298,"address":[10614004],"length":1,"stats":{"Line":0}}],"covered":47,"coverable":88},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","gossip_service.rs"],"content":"use crate::domain::entities::Event;\nuse crate::domain::p2p::TopicStats;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait GossipService: Send + Sync {\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError>;\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError>;\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError>;\r\n    async fn subscribe(&self, topic: &str) -> Result<tokio::sync::mpsc::Receiver<Event>, AppError>;\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError>;\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError>;\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError>;\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_gossip_service.rs"],"content":"use super::GossipService;\r\nuse crate::domain::entities::Event;\r\nuse crate::infrastructure::p2p::utils::{ParsedPeer, parse_peer_hint};\r\nuse crate::shared::error::AppError;\r\nuse async_trait::async_trait;\r\nuse futures::StreamExt;\r\nuse iroh::protocol::Router;\r\nuse iroh_gossip::{\r\n    ALPN as GOSSIP_ALPN,\r\n    api::{Event as GossipApiEvent, GossipSender, GossipTopic},\r\n    net::Gossip,\r\n    proto::TopicId,\r\n};\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\nuse std::sync::Mutex as StdMutex;\r\nuse std::time::Duration;\r\nuse tokio::sync::mpsc::UnboundedSender;\r\nuse tokio::sync::{Mutex as TokioMutex, RwLock, mpsc};\r\nuse tokio::time::timeout;\r\n\r\nuse crate::domain::p2p::events::P2PEvent;\nuse crate::domain::p2p::message::GossipMessage;\nuse crate::domain::p2p::{TopicMesh, TopicStats};\n\r\nconst LOG_TARGET: &str = \"kukuri::p2p::gossip\";\r\nconst METRICS_TARGET: &str = \"kukuri::p2p::metrics\";\r\n\r\npub struct IrohGossipService {\r\n    endpoint: Arc<iroh::Endpoint>,\r\n    gossip: Arc<Gossip>,\r\n    router: Arc<Router>,\r\n    topics: Arc<RwLock<HashMap<String, TopicHandle>>>,\r\n    event_tx: Option<Arc<StdMutex<UnboundedSender<P2PEvent>>>>,\r\n}\r\n\r\nstruct TopicHandle {\r\n    topic_id: String,\r\n    iroh_topic_id: TopicId,\r\n    sender: Arc<TokioMutex<GossipSender>>, // GossipSenderでbroadcast可能\r\n    receiver_task: tokio::task::JoinHandle<()>,\r\n    subscribers: Arc<RwLock<Vec<mpsc::Sender<Event>>>>,\r\n    mesh: Arc<TopicMesh>,\r\n}\r\n\r\nimpl IrohGossipService {\r\n    pub fn new(endpoint: Arc<iroh::Endpoint>) -> Result<Self, AppError> {\r\n        // Gossipインスタンスの作成\r\n        let gossip = Gossip::builder().spawn((*endpoint).clone());\r\n\r\n        // Routerの作成とGossipプロトコルの登録\r\n        let router = Router::builder((*endpoint).clone())\r\n            .accept(GOSSIP_ALPN, gossip.clone())\r\n            .spawn();\r\n\r\n        Ok(Self {\r\n            endpoint,\r\n            gossip: Arc::new(gossip),\r\n            router: Arc::new(router),\r\n            topics: Arc::new(RwLock::new(HashMap::new())),\r\n            event_tx: None,\r\n        })\r\n    }\r\n\r\n    pub fn set_event_sender(&mut self, tx: UnboundedSender<P2PEvent>) {\r\n        self.event_tx = Some(Arc::new(StdMutex::new(tx)));\r\n    }\r\n\r\n    pub fn local_peer_hint(&self) -> Option<String> {\r\n        let node_addr = self.endpoint.node_addr();\r\n        let node_id = node_addr.node_id.to_string();\r\n        node_addr\r\n            .direct_addresses()\r\n            .next()\r\n            .map(|addr| format!(\"{node_id}@{addr}\"))\r\n    }\r\n\r\n    fn create_topic_id(topic: &str) -> TopicId {\r\n        // トピック名からTopicIdを生成\r\n        use blake3::Hasher;\r\n        let mut hasher = Hasher::new();\r\n        hasher.update(topic.as_bytes());\r\n        let hash = hasher.finalize();\r\n        TopicId::from_bytes(*hash.as_bytes())\r\n    }\r\n\r\n    async fn apply_initial_peers(\r\n        &self,\r\n        topic: &str,\r\n        parsed_peers: &[ParsedPeer],\r\n    ) -> Result<(), AppError> {\r\n        if parsed_peers.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] applying {} initial peers to existing topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        for peer in parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] re-applying node addr {} for topic {}\",\r\n                    addr.node_id, topic\r\n                );\r\n                if let Err(e) = self\r\n                    .endpoint\r\n                    .add_node_addr_with_source(addr.clone(), \"gossip-bootstrap\")\r\n                {\r\n                    tracing::warn!(\"Failed to add node addr for {}: {:?}\", topic, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        if peer_ids.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        let topics = self.topics.read().await;\r\n        if let Some(handle) = topics.get(topic) {\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n            if let Err(e) = sender.lock().await.join_peers(peer_ids).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            }\r\n        } else {\r\n            tracing::debug!(\"Topic {} not found when applying initial peers\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl GossipService for IrohGossipService {\r\n    async fn join_topic(&self, topic: &str, initial_peers: Vec<String>) -> Result<(), AppError> {\r\n        eprintln!(\r\n            \"[iroh_gossip_service] join_topic start: {} (initial peers: {:?})\",\r\n            topic, initial_peers\r\n        );\r\n        let parsed_peers: Vec<ParsedPeer> = initial_peers\r\n            .into_iter()\r\n            .filter_map(|entry| match parse_peer_hint(&entry) {\r\n                Ok(parsed) => Some(parsed),\r\n                Err(e) => {\r\n                    tracing::warn!(\"Failed to parse initial peer '{}': {:?}\", entry, e);\r\n                    None\r\n                }\r\n            })\r\n            .collect();\r\n\r\n        eprintln!(\r\n            \"[iroh_gossip_service] parsed {} peers for topic {}\",\r\n            parsed_peers.len(),\r\n            topic\r\n        );\r\n\r\n        {\r\n            let topics = self.topics.read().await;\r\n            if topics.contains_key(topic) {\r\n                drop(topics);\r\n                self.apply_initial_peers(topic, &parsed_peers).await?;\r\n                return Ok(());\r\n            }\r\n            drop(topics);\r\n        }\r\n\r\n        for peer in &parsed_peers {\r\n            if let Some(addr) = &peer.node_addr {\r\n                if let Err(e) = self\r\n                    .endpoint\r\n                    .add_node_addr_with_source(addr.clone(), \"gossip-bootstrap\")\r\n                {\r\n                    tracing::warn!(\"Failed to add node addr for {}: {:?}\", topic, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        let topic_id = Self::create_topic_id(topic);\r\n        let peer_ids: Vec<_> = parsed_peers.iter().map(|p| p.node_id).collect();\r\n        eprintln!(\r\n            \"[iroh_gossip_service] subscribing topic {} with {} peer hints\",\r\n            topic,\r\n            peer_ids.len()\r\n        );\r\n\r\n        let gossip_topic: GossipTopic = self\r\n            .gossip\r\n            .subscribe(topic_id, peer_ids.clone())\r\n            .await\r\n            .map_err(|e| AppError::P2PError(format!(\"Failed to subscribe to topic: {e:?}\")))?;\r\n\r\n        let (sender_handle, mut receiver) = gossip_topic.split();\r\n\r\n        if !peer_ids.is_empty() {\r\n            if let Err(e) = sender_handle.join_peers(peer_ids.clone()).await {\r\n                tracing::warn!(\"Failed to join peers for topic {}: {:?}\", topic, e);\r\n            } else {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] join_peers issued for topic {} ({} peers)\",\r\n                    topic,\r\n                    peer_ids.len()\r\n                );\r\n            }\r\n        }\r\n\r\n        let wait_duration = Duration::from_secs(12);\r\n        match timeout(wait_duration, receiver.joined()).await {\r\n            Ok(Ok(peer)) => {\r\n                eprintln!(\r\n                    \"[iroh_gossip_service] first neighbor joined for topic {topic} ({peer:?})\"\r\n                );\r\n            }\r\n            Ok(Err(e)) => {\r\n                tracing::debug!(\"Waiting for neighbor on {} returned error: {:?}\", topic, e);\r\n            }\r\n            Err(_) => {\r\n                tracing::warn!(\r\n                    \"Timed out ({:?}) waiting for neighbor on {}\",\r\n                    wait_duration,\r\n                    topic\r\n                );\r\n            }\r\n        }\r\n\r\n        let sender = Arc::new(TokioMutex::new(sender_handle));\r\n        let mesh = Arc::new(TopicMesh::new(topic.to_string()));\r\n\r\n        // 受信タスクを起動（UI配信用にサブスクライバへ配布 & 任意でP2PEventを送出）\r\n        let topic_clone = topic.to_string();\r\n        let event_tx_clone = self.event_tx.clone();\r\n        let subscribers: Arc<RwLock<Vec<mpsc::Sender<Event>>>> = Arc::new(RwLock::new(Vec::new()));\r\n        let subscribers_for_task = subscribers.clone();\r\n        let mesh_for_task = mesh.clone();\r\n        let receiver_task = tokio::spawn(async move {\r\n            while let Some(event) = receiver.next().await {\r\n                match event {\r\n                    Ok(GossipApiEvent::Received(msg)) => {\r\n                        let decoded_message = match GossipMessage::from_bytes(&msg.content) {\r\n                            Ok(message) => Some(message),\r\n                            Err(e) => {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload into GossipMessage\"\r\n                                );\r\n                                None\r\n                            }\r\n                        };\r\n\r\n                        if let Some(message) = decoded_message.as_ref() {\r\n                            if let Err(e) = mesh_for_task.handle_message(message.clone()).await {\r\n                                tracing::debug!(\r\n                                    target: LOG_TARGET,\r\n                                    topic = %topic_clone,\r\n                                    error = ?e,\r\n                                    \"Failed to record gossip message in TopicMesh\"\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        if let (Some(tx), Some(message)) =\r\n                            (event_tx_clone.as_ref(), decoded_message.clone())\r\n                        {\r\n                            let _ = tx.lock().unwrap().send(P2PEvent::MessageReceived {\r\n                                topic_id: topic_clone.clone(),\r\n                                message,\r\n                                _from_peer: msg.delivered_from.as_bytes().to_vec(),\r\n                            });\r\n                        }\r\n\r\n                        match serde_json::from_slice::<Event>(&msg.content) {\r\n                            Ok(domain_event) => {\r\n                                match domain_event\r\n                                    .validate_nip01()\r\n                                    .and_then(|_| domain_event.validate_nip10_19())\r\n                                {\r\n                                    Ok(_) => {\r\n                                        super::metrics::record_receive_success();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::trace!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive\",\r\n                                            topic = %topic_clone,\r\n                                            received = snap.messages_received,\r\n                                            receive_failures = snap.receive_details.failures,\r\n                                            \"Validated gossip payload\"\r\n                                        );\r\n\r\n                                        let subs = subscribers_for_task.read().await;\r\n                                        for s in subs.iter() {\r\n                                            let _ = s.send(domain_event.clone()).await;\r\n                                        }\r\n                                    }\r\n                                    Err(e) => {\r\n                                        super::metrics::record_receive_failure();\r\n                                        let snap = super::metrics::snapshot();\r\n                                        tracing::warn!(\r\n                                            target: METRICS_TARGET,\r\n                                            action = \"receive_failure\",\r\n                                            topic = %topic_clone,\r\n                                            failures = snap.receive_details.failures,\r\n                                            error = %e,\r\n                                            \"Dropped invalid Nostr event after validation\"\r\n                                        );\r\n                                    }\r\n                                }\r\n                            }\r\n                            Err(e) => {\r\n                                super::metrics::record_receive_failure();\r\n                                let snap = super::metrics::snapshot();\r\n                                tracing::warn!(\r\n                                    target: METRICS_TARGET,\r\n                                    action = \"receive_failure\",\r\n                                    topic = %topic_clone,\r\n                                    failures = snap.receive_details.failures,\r\n                                    error = ?e,\r\n                                    \"Failed to decode gossip payload as Nostr event\"\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborUp(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.lock().unwrap().send(P2PEvent::PeerJoined {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor up on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, true).await;\r\n                    }\r\n                    Ok(GossipApiEvent::NeighborDown(peer)) => {\r\n                        let peer_bytes = peer.as_bytes().to_vec();\r\n                        if let Some(tx) = &event_tx_clone {\r\n                            let _ = tx.lock().unwrap().send(P2PEvent::PeerLeft {\r\n                                topic_id: topic_clone.clone(),\r\n                                peer_id: peer_bytes.clone(),\r\n                            });\r\n                        } else {\r\n                            tracing::info!(\"Neighbor down on {}: {:?}\", topic_clone, peer);\r\n                        }\r\n                        mesh_for_task.update_peer_status(peer_bytes, false).await;\r\n                    }\r\n                    Ok(GossipApiEvent::Lagged) => {\r\n                        tracing::warn!(\"Receiver lagged on topic {}\", topic_clone);\r\n                    }\r\n                    Err(e) => {\r\n                        tracing::error!(\"Gossip receiver error on {}: {:?}\", topic_clone, e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        let handle = TopicHandle {\r\n            topic_id: topic.to_string(),\r\n            iroh_topic_id: topic_id,\r\n            sender,\r\n            receiver_task,\r\n            subscribers,\r\n            mesh,\r\n        };\r\n\r\n        let mut topics = self.topics.write().await;\r\n        topics.insert(topic.to_string(), handle);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn leave_topic(&self, topic: &str) -> Result<(), AppError> {\r\n        let mut topics = self.topics.write().await;\r\n\r\n        if let Some(handle) = topics.remove(topic) {\r\n            // レシーバータスクをキャンセルし、Senderをドロップ\r\n            handle.receiver_task.abort();\r\n            drop(handle.sender);\r\n\r\n            tracing::info!(\"Left gossip topic: {}\", topic);\r\n        } else {\r\n            tracing::debug!(\"Topic not found: {}\", topic);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    async fn broadcast(&self, topic: &str, event: &Event) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(handle) = topics.get(topic) {\r\n            // イベントをシリアライズ\r\n            let message_bytes = serde_json::to_vec(event)?;\r\n\r\n            // Senderを取得してブロードキャスト\r\n            let sender = handle.sender.clone();\r\n            drop(topics);\r\n\r\n            let guard = sender.lock().await;\r\n            guard\r\n                .broadcast(message_bytes.into())\r\n                .await\r\n                .map_err(|e| AppError::P2PError(format!(\"Failed to broadcast: {e:?}\")))?;\r\n\r\n            tracing::debug!(\"Broadcasted event to topic {}\", topic);\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn subscribe(&self, topic: &str) -> Result<mpsc::Receiver<Event>, AppError> {\r\n        // トピックに参加していることを確認\r\n        self.join_topic(topic, vec![]).await?;\r\n\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(handle) = topics.get(topic) {\r\n            // 新しいレシーバーを作成し、サブスクライバに登録\r\n            let (tx, rx) = mpsc::channel(100);\r\n            {\r\n                let mut subs = handle.subscribers.write().await;\r\n                subs.push(tx);\r\n            }\r\n            Ok(rx)\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_joined_topics(&self) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n        Ok(topics.keys().cloned().collect())\r\n    }\r\n\r\n    async fn get_topic_peers(&self, topic: &str) -> Result<Vec<String>, AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // iroh-gossipのAPIでピアリストを取得\r\n            // Note: iroh-gossip doesn't expose a direct way to get topic peers\r\n            // Return empty list for now\r\n            Ok(Vec::new())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n\r\n    async fn get_topic_stats(&self, topic: &str) -> Result<Option<TopicStats>, AppError> {\r\n        let mesh = {\r\n            let topics = self.topics.read().await;\r\n            topics.get(topic).map(|handle| handle.mesh.clone())\r\n        };\r\n\r\n        if let Some(mesh) = mesh {\r\n            Ok(Some(mesh.get_stats().await))\r\n        } else {\r\n            Ok(None)\r\n        }\r\n    }\r\n\r\n    async fn broadcast_message(&self, topic: &str, message: &[u8]) -> Result<(), AppError> {\r\n        let topics = self.topics.read().await;\r\n\r\n        if let Some(_handle) = topics.get(topic) {\r\n            // メッセージをブロードキャスト\r\n            // Simplified - actual implementation needs proper API\r\n            tracing::debug!(\r\n                \"Broadcasting raw message to topic {}: {} bytes\",\r\n                topic,\r\n                message.len()\r\n            );\r\n            Ok(())\r\n        } else {\r\n            Err(format!(\"Not joined to topic: {topic}\").into())\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::domain::entities::Event;\r\n    use iroh::Endpoint;\r\n\r\n    fn should_run_p2p_tests(test_name: &str) -> bool {\r\n        if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\r\n            eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\r\n            false\r\n        } else {\r\n            true\r\n        }\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_broadcast_without_peers() {\r\n        if !should_run_p2p_tests(\"test_join_and_broadcast_without_peers\") {\r\n            return;\r\n        }\r\n        // エンドポイント作成（ローカル、ディスカバリ無し）\r\n        let endpoint = Arc::new(Endpoint::builder().bind().await.unwrap());\r\n        let service = IrohGossipService::new(endpoint).unwrap();\r\n\r\n        // トピック参加\r\n        let topic = \"test-topic-ig\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n\r\n        // ダミーイベントでブロードキャスト（ピア不在でもエラーにならない）\r\n        let event = Event::new(1, \"hello igossip\".to_string(), \"pubkey_test\".to_string());\r\n        let result = service.broadcast(topic, &event).await;\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_join_and_leave_topic() {\r\n        if !should_run_p2p_tests(\"test_join_and_leave_topic\") {\r\n            return;\r\n        }\r\n        let endpoint = Arc::new(Endpoint::builder().bind().await.unwrap());\r\n        let service = IrohGossipService::new(endpoint).unwrap();\r\n\r\n        let topic = \"test-topic-leave\";\r\n        service.join_topic(topic, vec![]).await.unwrap();\r\n        let result = service.leave_topic(topic).await;\r\n        assert!(result.is_ok());\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[18695473,18694336,18695368],"length":1,"stats":{"Line":0}},{"line":49,"address":[18908559,18909550,18908454],"length":1,"stats":{"Line":0}},{"line":52,"address":[11741478,11741544,11741700,11741649],"length":1,"stats":{"Line":0}},{"line":53,"address":[18694840,18695413,18694735],"length":1,"stats":{"Line":0}},{"line":56,"address":[13453473],"length":1,"stats":{"Line":0}},{"line":57,"address":[18668147],"length":1,"stats":{"Line":0}},{"line":58,"address":[13453206,13453128],"length":1,"stats":{"Line":0}},{"line":59,"address":[18695103,18694990],"length":1,"stats":{"Line":0}},{"line":60,"address":[18909207,18909267],"length":1,"stats":{"Line":0}},{"line":61,"address":[11742054],"length":1,"stats":{"Line":0}},{"line":65,"address":[18138368,18138457],"length":1,"stats":{"Line":0}},{"line":66,"address":[18138387,18138488],"length":1,"stats":{"Line":0}},{"line":69,"address":[13454155,13453872],"length":1,"stats":{"Line":0}},{"line":70,"address":[18138550],"length":1,"stats":{"Line":0}},{"line":71,"address":[18668986],"length":1,"stats":{"Line":0}},{"line":72,"address":[18695779,18695841],"length":1,"stats":{"Line":0}},{"line":75,"address":[18910090,18910064],"length":1,"stats":{"Line":0}},{"line":78,"address":[18696160,18696442],"length":1,"stats":{"Line":0}},{"line":81,"address":[18910299],"length":1,"stats":{"Line":0}},{"line":82,"address":[18139170],"length":1,"stats":{"Line":0}},{"line":83,"address":[18910418],"length":1,"stats":{"Line":0}},{"line":84,"address":[18910450],"length":1,"stats":{"Line":0}},{"line":87,"address":[18669728],"length":1,"stats":{"Line":0}},{"line":92,"address":[18670039,18670199],"length":1,"stats":{"Line":0}},{"line":93,"address":[13455208],"length":1,"stats":{"Line":0}},{"line":96,"address":[18911097,18911053],"length":1,"stats":{"Line":0}},{"line":102,"address":[11744071,11743909],"length":1,"stats":{"Line":0}},{"line":103,"address":[18671156,18670591],"length":1,"stats":{"Line":0}},{"line":104,"address":[18912008],"length":1,"stats":{"Line":0}},{"line":108,"address":[18912147,18912197],"length":1,"stats":{"Line":0}},{"line":110,"address":[18912182],"length":1,"stats":{"Line":0}},{"line":112,"address":[18698231,18698332,18744345,18744479,18698833],"length":1,"stats":{"Line":0}},{"line":117,"address":[13455621,13455500,13464493,13464480],"length":1,"stats":{"Line":0}},{"line":118,"address":[11744235,11744313],"length":1,"stats":{"Line":0}},{"line":119,"address":[18670858],"length":1,"stats":{"Line":0}},{"line":122,"address":[11008399],"length":1,"stats":{"Line":0}},{"line":123,"address":[13458965,13458881],"length":1,"stats":{"Line":0}},{"line":124,"address":[13459150,13459060],"length":1,"stats":{"Line":0}},{"line":125,"address":[18915025],"length":1,"stats":{"Line":0}},{"line":126,"address":[18139711,18143880,18146278,18145969],"length":1,"stats":{"Line":0}},{"line":127,"address":[18677282,18677884,18718105,18718239,18677383],"length":1,"stats":{"Line":0}},{"line":130,"address":[18701172,18701686,18745337,18700879,18745471],"length":1,"stats":{"Line":0}},{"line":133,"address":[18144508],"length":1,"stats":{"Line":0}},{"line":139,"address":[18719071,18719244,18719152,18726673,18719581,18719952,18720784,18724613],"length":1,"stats":{"Line":0}},{"line":140,"address":[18960932,18960853],"length":1,"stats":{"Line":0}},{"line":144,"address":[18961048],"length":1,"stats":{"Line":0}},{"line":146,"address":[18207168,18207218,18207301,18209462,18207883],"length":1,"stats":{"Line":0}},{"line":147,"address":[18764482],"length":1,"stats":{"Line":0}},{"line":148,"address":[11873652],"length":1,"stats":{"Line":0}},{"line":149,"address":[19035177,19035311,18978664,18979117,18979268,18978773],"length":1,"stats":{"Line":0}},{"line":150,"address":[18738407],"length":1,"stats":{"Line":0}},{"line":155,"address":[18720348,18720435],"length":1,"stats":{"Line":0}},{"line":162,"address":[10595631],"length":1,"stats":{"Line":0}},{"line":163,"address":[18961938,18962025],"length":1,"stats":{"Line":0}},{"line":164,"address":[18190882],"length":1,"stats":{"Line":0}},{"line":165,"address":[11136392],"length":1,"stats":{"Line":0}},{"line":166,"address":[13510075],"length":1,"stats":{"Line":0}},{"line":168,"address":[18962072],"length":1,"stats":{"Line":0}},{"line":171,"address":[11857548,11857386],"length":1,"stats":{"Line":0}},{"line":172,"address":[13506496,13507250],"length":1,"stats":{"Line":0}},{"line":173,"address":[18722372,18722310],"length":1,"stats":{"Line":0}},{"line":175,"address":[18749093],"length":1,"stats":{"Line":0}},{"line":177,"address":[13507462,13508064,13579801,13579935,13507563],"length":1,"stats":{"Line":0}},{"line":182,"address":[18191085],"length":1,"stats":{"Line":0}},{"line":183,"address":[13506511,13524861,13524848],"length":1,"stats":{"Line":0}},{"line":184,"address":[18721800],"length":1,"stats":{"Line":0}},{"line":190,"address":[18752698,18748698,18748948,18752282,18748886,18752114,18748783],"length":1,"stats":{"Line":0}},{"line":192,"address":[18191666],"length":1,"stats":{"Line":0}},{"line":193,"address":[18752210,18746389,18748921,18752002,18748981],"length":1,"stats":{"Line":0}},{"line":194,"address":[18739936,18725930,18739958],"length":1,"stats":{"Line":0}},{"line":196,"address":[18966640,18966879],"length":1,"stats":{"Line":0}},{"line":198,"address":[18967000,18967088],"length":1,"stats":{"Line":0}},{"line":199,"address":[11350538],"length":1,"stats":{"Line":0}},{"line":200,"address":[18727779,18795337,18727177,18795471,18727278],"length":1,"stats":{"Line":0}},{"line":202,"address":[18729369,18729288],"length":1,"stats":{"Line":0}},{"line":210,"address":[18726320,18729509],"length":1,"stats":{"Line":0}},{"line":211,"address":[18719695,18729515],"length":1,"stats":{"Line":0}},{"line":213,"address":[11866222,11866034],"length":1,"stats":{"Line":0}},{"line":217,"address":[11866068],"length":1,"stats":{"Line":0}},{"line":218,"address":[18200569,18265567,18199810,18200068,18265433],"length":1,"stats":{"Line":0}},{"line":221,"address":[18796329,18732485,18796463,18730065],"length":1,"stats":{"Line":0}},{"line":229,"address":[18204077,18204191],"length":1,"stats":{"Line":0}},{"line":230,"address":[11870611,11870725],"length":1,"stats":{"Line":0}},{"line":233,"address":[11870799,11870897],"length":1,"stats":{"Line":0}},{"line":234,"address":[13519912,13520012],"length":1,"stats":{"Line":0}},{"line":235,"address":[18761893,18761811],"length":1,"stats":{"Line":0}},{"line":236,"address":[13520321,13520222],"length":1,"stats":{"Line":0}},{"line":237,"address":[18976216,18976300],"length":1,"stats":{"Line":0}},{"line":238,"address":[13520436,13525548,13556984,13525152,13520722,13525243,13525366,13527733],"length":1,"stats":{"Line":0}},{"line":239,"address":[18981386,18982043,18981180,18981452,18981982,18981268],"length":1,"stats":{"Line":0}},{"line":240,"address":[18768235,18768296],"length":1,"stats":{"Line":0}},{"line":241,"address":[18741885],"length":1,"stats":{"Line":0}},{"line":242,"address":[11877795,11883891],"length":1,"stats":{"Line":0}},{"line":243,"address":[11883933],"length":1,"stats":{"Line":0}},{"line":244,"address":[18989078],"length":1,"stats":{"Line":0}},{"line":245,"address":[13533880,13533354,13581785,13581919,13533238],"length":1,"stats":{"Line":0}},{"line":251,"address":[13533826],"length":1,"stats":{"Line":0}},{"line":255,"address":[18751184,18748306],"length":1,"stats":{"Line":0}},{"line":256,"address":[18210257,18210057,18220926,18220845],"length":1,"stats":{"Line":0}},{"line":257,"address":[13536794,13536693,13537295,13582415,13582281],"length":1,"stats":{"Line":0}},{"line":266,"address":[11890440,11890381,11890416],"length":1,"stats":{"Line":0}},{"line":267,"address":[18995372,18992108,18995481],"length":1,"stats":{"Line":0}},{"line":269,"address":[18995690,18996202,18995758],"length":1,"stats":{"Line":0}},{"line":270,"address":[11890803],"length":1,"stats":{"Line":0}},{"line":271,"address":[18755116],"length":1,"stats":{"Line":0}},{"line":272,"address":[11891048,11890966],"length":1,"stats":{"Line":0}},{"line":276,"address":[18996467,18996575],"length":1,"stats":{"Line":0}},{"line":277,"address":[18225411],"length":1,"stats":{"Line":0}},{"line":278,"address":[18996682,18996822],"length":1,"stats":{"Line":0}},{"line":280,"address":[11907904,11907920,11891650],"length":1,"stats":{"Line":0}},{"line":283,"address":[18225658],"length":1,"stats":{"Line":0}},{"line":284,"address":[13541081],"length":1,"stats":{"Line":0}},{"line":285,"address":[18225747,18267551,18226291,18267417],"length":1,"stats":{"Line":0}},{"line":294,"address":[10642013],"length":1,"stats":{"Line":0}},{"line":295,"address":[19001100,19000844,19000751],"length":1,"stats":{"Line":0}},{"line":296,"address":[18760292,18760359,18740731,18740499],"length":1,"stats":{"Line":0}},{"line":299,"address":[18756069],"length":1,"stats":{"Line":0}},{"line":300,"address":[18782843],"length":1,"stats":{"Line":0}},{"line":301,"address":[11896407],"length":1,"stats":{"Line":0}},{"line":302,"address":[19039279,19001643,19002179,19039145],"length":1,"stats":{"Line":0}},{"line":313,"address":[18225484],"length":1,"stats":{"Line":0}},{"line":314,"address":[18755907],"length":1,"stats":{"Line":0}},{"line":315,"address":[18791079],"length":1,"stats":{"Line":0}},{"line":316,"address":[11899982,11934217,11934374,11900543],"length":1,"stats":{"Line":0}},{"line":327,"address":[11877563],"length":1,"stats":{"Line":0}},{"line":328,"address":[11877599,11877917],"length":1,"stats":{"Line":0}},{"line":329,"address":[18982971],"length":1,"stats":{"Line":0}},{"line":330,"address":[18769328,18768939,18769045],"length":1,"stats":{"Line":0}},{"line":331,"address":[11878276],"length":1,"stats":{"Line":0}},{"line":332,"address":[18983331],"length":1,"stats":{"Line":0}},{"line":335,"address":[18799439,18799305,18742222,18742789],"length":1,"stats":{"Line":0}},{"line":337,"address":[10642055],"length":1,"stats":{"Line":0}},{"line":339,"address":[18768548],"length":1,"stats":{"Line":0}},{"line":340,"address":[18741848,18745270],"length":1,"stats":{"Line":0}},{"line":341,"address":[18986148],"length":1,"stats":{"Line":0}},{"line":342,"address":[13530340,13530681,13530398],"length":1,"stats":{"Line":0}},{"line":343,"address":[18986433],"length":1,"stats":{"Line":0}},{"line":344,"address":[11881390],"length":1,"stats":{"Line":0}},{"line":347,"address":[18214999,18215509,18269401,18269535],"length":1,"stats":{"Line":0}},{"line":349,"address":[19208380],"length":1,"stats":{"Line":0}},{"line":352,"address":[18982844,19041263,19041129,19008714],"length":1,"stats":{"Line":0}},{"line":354,"address":[18211225],"length":1,"stats":{"Line":0}},{"line":355,"address":[18270527,18211308,18239934,18270393,18239433],"length":1,"stats":{"Line":0}},{"line":362,"address":[18762521],"length":1,"stats":{"Line":0}},{"line":370,"address":[19165212],"length":1,"stats":{"Line":0}},{"line":371,"address":[13521527,13521594],"length":1,"stats":{"Line":0}},{"line":373,"address":[18206440],"length":1,"stats":{"Line":0}},{"line":376,"address":[19013858,19013376,19016713,19013167,19013263,19013654,19013216],"length":1,"stats":{"Line":0}},{"line":377,"address":[18799310,18799624,18799794],"length":1,"stats":{"Line":0}},{"line":379,"address":[18773379,18773300],"length":1,"stats":{"Line":0}},{"line":381,"address":[11909165],"length":1,"stats":{"Line":0}},{"line":382,"address":[18773638],"length":1,"stats":{"Line":0}},{"line":384,"address":[11909822,11937014,11909261,11936857],"length":1,"stats":{"Line":0}},{"line":386,"address":[19042617,19016811,19042751],"length":1,"stats":{"Line":0}},{"line":389,"address":[18245447],"length":1,"stats":{"Line":0}},{"line":392,"address":[13563456,13563697,13565082,13562903,13563136,13563007,13562960],"length":1,"stats":{"Line":0}},{"line":393,"address":[11107457],"length":1,"stats":{"Line":0}},{"line":395,"address":[18805862,18809685,18805782],"length":1,"stats":{"Line":0}},{"line":397,"address":[13564190,13564483,13564824,13564294],"length":1,"stats":{"Line":0}},{"line":400,"address":[18249229,18249080],"length":1,"stats":{"Line":0}},{"line":401,"address":[18779632],"length":1,"stats":{"Line":0}},{"line":403,"address":[10593249],"length":1,"stats":{"Line":0}},{"line":404,"address":[11915877,11916420,11916034,11916536,11916088,11916258],"length":1,"stats":{"Line":0}},{"line":405,"address":[18807168],"length":1,"stats":{"Line":0}},{"line":406,"address":[11348329],"length":1,"stats":{"Line":0}},{"line":407,"address":[11918718,11916504,11918688],"length":1,"stats":{"Line":0}},{"line":409,"address":[13587241,13587375,13566549,13565928,13566032],"length":1,"stats":{"Line":0}},{"line":410,"address":[11917073],"length":1,"stats":{"Line":0}},{"line":412,"address":[11914833,11915441],"length":1,"stats":{"Line":0}},{"line":416,"address":[18810319,18811026,18810436,18811527,18810272,18810756,18810223],"length":1,"stats":{"Line":0}},{"line":418,"address":[11348737],"length":1,"stats":{"Line":0}},{"line":420,"address":[11920138,11920236,11919239,11920035],"length":1,"stats":{"Line":0}},{"line":422,"address":[18254723,18254650,18255751],"length":1,"stats":{"Line":0}},{"line":424,"address":[19026050,19026132],"length":1,"stats":{"Line":0}},{"line":426,"address":[14478761],"length":1,"stats":{"Line":0}},{"line":427,"address":[11921351,11921406],"length":1,"stats":{"Line":0}},{"line":429,"address":[18786107],"length":1,"stats":{"Line":0}},{"line":431,"address":[18785251,18785516],"length":1,"stats":{"Line":0}},{"line":435,"address":[18814165,18813194,18813436,18813107,18813619,18813033,18813072],"length":1,"stats":{"Line":0}},{"line":436,"address":[13571445,13571720,13571875],"length":1,"stats":{"Line":0}},{"line":437,"address":[11922471,11922536],"length":1,"stats":{"Line":0}},{"line":440,"address":[11924146,11922767,11922938,11923349,11922816,11922851,11923182],"length":1,"stats":{"Line":0}},{"line":441,"address":[11116244],"length":1,"stats":{"Line":0}},{"line":443,"address":[18815150,18815564,18815077],"length":1,"stats":{"Line":0}},{"line":447,"address":[18788501,18788548],"length":1,"stats":{"Line":0}},{"line":449,"address":[19029352,19029462],"length":1,"stats":{"Line":0}},{"line":453,"address":[18789290,18788943,18789507,18790311,18788992,18789027,18789120],"length":1,"stats":{"Line":0}},{"line":455,"address":[11357199],"length":1,"stats":{"Line":0}},{"line":456,"address":[19031529,19031520,19030607,19030680],"length":1,"stats":{"Line":0}},{"line":459,"address":[18816688,18816856],"length":1,"stats":{"Line":0}},{"line":460,"address":[11925200,11925496,11925371,11924413],"length":1,"stats":{"Line":0}},{"line":462,"address":[11925224],"length":1,"stats":{"Line":0}},{"line":466,"address":[18260432,18260868,18260587,18260367,18261075,18263869,18260479],"length":1,"stats":{"Line":0}},{"line":467,"address":[18791507,18791017,18791337],"length":1,"stats":{"Line":0}},{"line":469,"address":[18818512,18818591,18819240,18820931],"length":1,"stats":{"Line":0}},{"line":472,"address":[18802911,18792516,18791951,18802777,18793682,18792020,18793200],"length":1,"stats":{"Line":0}},{"line":477,"address":[11927625],"length":1,"stats":{"Line":0}},{"line":479,"address":[11927087,11929126],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":198},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","iroh_network_service.rs"],"content":"use super::{\n    DiscoveryOptions, NetworkService, NetworkStats, Peer,\n    dht_bootstrap::{DhtGossip, secret},\n};\nuse crate::shared::config::NetworkConfig as AppNetworkConfig;\nuse crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse iroh::{Endpoint, protocol::Router};\nuse std::sync::Arc;\nuse tokio::sync::{RwLock, broadcast};\nuse tracing;\n\n#[derive(Debug, Clone)]\npub enum ConnectionEvent {\n    Connected,\n    Disconnected,\n}\n\npub struct IrohNetworkService {\n    endpoint: Arc<Endpoint>,\n    router: Arc<Router>,\n    connected: Arc<RwLock<bool>>,\n    peers: Arc<RwLock<Vec<Peer>>>,\n    stats: Arc<RwLock<NetworkStats>>,\n    dht_gossip: Option<Arc<DhtGossip>>,\n    discovery_options: Arc<RwLock<DiscoveryOptions>>,\n    network_config: AppNetworkConfig,\n    connection_events: broadcast::Sender<ConnectionEvent>,\n}\n\nimpl IrohNetworkService {\n    pub async fn new(\n        secret_key: iroh::SecretKey,\n        net_cfg: AppNetworkConfig,\n        discovery_options: DiscoveryOptions,\n    ) -> Result<Self, AppError> {\n        // Endpointの作成（設定に応じてディスカバリーを有効化）\n        let builder = Endpoint::builder().secret_key(secret_key);\n        let builder = discovery_options.apply_to_builder(builder);\n        let endpoint = builder\n            .bind()\n            .await\n            .map_err(|e| AppError::P2PError(format!(\"Failed to bind endpoint: {e:?}\")))?;\n\n        // Routerの作成（Gossipプロトコルは別で設定）\n        let router = Router::builder(endpoint.clone()).spawn();\n\n        // ブートストラップ設定の検証（警告/件数ログのみ）\n        if let Err(e) = super::bootstrap_config::validate_bootstrap_config() {\n            tracing::warn!(\"bootstrap_nodes.json validation failed: {:?}\", e);\n        }\n\n        // DhtGossipの初期化\n        let dht_gossip = match DhtGossip::new(Arc::new(endpoint.clone())).await {\n            Ok(service) => Some(Arc::new(service)),\n            Err(e) => {\n                tracing::warn!(\"Failed to initialize DhtGossip: {:?}\", e);\n                None\n            }\n        };\n\n        let (connection_events, _) = broadcast::channel(16);\n\n        let service = Self {\n            endpoint: Arc::new(endpoint),\n            router: Arc::new(router),\n            connected: Arc::new(RwLock::new(false)),\n            peers: Arc::new(RwLock::new(Vec::new())),\n            stats: Arc::new(RwLock::new(NetworkStats {\n                connected_peers: 0,\n                total_messages_sent: 0,\n                total_messages_received: 0,\n                bandwidth_up: 0,\n                bandwidth_down: 0,\n            })),\n            dht_gossip,\n            discovery_options: Arc::new(RwLock::new(discovery_options)),\n            network_config: net_cfg,\n            connection_events,\n        };\n\n        service.apply_bootstrap_peers_from_config().await;\n\n        Ok(service)\n    }\n\n    pub fn endpoint(&self) -> &Arc<Endpoint> {\n        &self.endpoint\n    }\n\n    pub fn router(&self) -> &Arc<Router> {\n        &self.router\n    }\n\n    async fn apply_bootstrap_peers_from_config(&self) {\n        for peer in &self.network_config.bootstrap_peers {\n            let trimmed = peer.trim();\n            if trimmed.is_empty() {\n                continue;\n            }\n\n            match self.add_peer(trimmed).await {\n                Ok(_) => tracing::info!(\"Connected to bootstrap peer from config: {}\", trimmed),\n                Err(err) => {\n                    tracing::warn!(\"Failed to connect to bootstrap peer '{}': {}\", trimmed, err)\n                }\n            }\n        }\n    }\n\n    pub fn node_id(&self) -> String {\n        self.endpoint.node_id().to_string()\n    }\n\n    pub async fn discovery_options(&self) -> DiscoveryOptions {\n        *self.discovery_options.read().await\n    }\n\n    pub fn subscribe_connection_events(&self) -> broadcast::Receiver<ConnectionEvent> {\n        self.connection_events.subscribe()\n    }\n\n    pub async fn node_addr(&self) -> Result<Vec<String>, AppError> {\n        // 直接アドレスを解決し、`node_id@ip:port` 形式で返却\n        self.endpoint.online().await;\n        let node_id = self.endpoint.node_id().to_string();\n        let node_addr = self.endpoint.node_addr();\n        let mut out = Vec::new();\n        for addr in node_addr.direct_addresses() {\n            out.push(format!(\"{node_id}@{addr}\"));\n        }\n        if out.is_empty() {\n            out.push(node_id);\n        }\n        Ok(out)\n    }\n\n    /// DHTを使用してトピックに参加\n    pub async fn join_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\n        if let Some(ref dht_gossip) = self.dht_gossip {\n            dht_gossip.join_topic(topic_name.as_bytes(), vec![]).await?;\n            tracing::info!(\"Joined DHT topic: {}\", topic_name);\n        } else {\n            tracing::warn!(\"DHT service not available, using fallback\");\n            // フォールバックモードを使用\n            self.connect_fallback().await?;\n        }\n        Ok(())\n    }\n\n    /// DHTを使用してトピックから離脱\n    pub async fn leave_dht_topic(&self, topic_name: &str) -> Result<(), AppError> {\n        if let Some(ref dht_gossip) = self.dht_gossip {\n            dht_gossip.leave_topic(topic_name.as_bytes()).await?;\n            tracing::info!(\"Left DHT topic: {}\", topic_name);\n        }\n        Ok(())\n    }\n\n    /// DHTを使用してメッセージをブロードキャスト\n    pub async fn broadcast_dht(&self, topic_name: &str, message: Vec<u8>) -> Result<(), AppError> {\n        if let Some(ref dht_gossip) = self.dht_gossip {\n            dht_gossip.broadcast(topic_name.as_bytes(), message).await?;\n        } else {\n            return Err(AppError::P2PError(\"DHT service not available\".to_string()));\n        }\n        Ok(())\n    }\n\n    /// フォールバックモードでピアに接続\n    async fn connect_fallback(&self) -> Result<(), AppError> {\n        // 1) 設定ファイルからのブートストラップ接続を優先\n        let fallback_peers =\n            match super::dht_bootstrap::fallback::connect_from_config(&self.endpoint).await {\n                Ok(peers) => peers,\n                Err(_) => {\n                    // 2) ハードコードされたフォールバックに接続（なければ失敗）\n                    match super::dht_bootstrap::fallback::connect_to_fallback(&self.endpoint).await\n                    {\n                        Ok(peers) => peers,\n                        Err(err) => {\n                            super::metrics::record_mainline_reconnect_failure();\n                            return Err(err);\n                        }\n                    }\n                }\n            };\n\n        super::metrics::record_mainline_reconnect_success();\n\n        // フォールバックピアをピアリストに追加\n        let mut peers = self.peers.write().await;\n        let now = chrono::Utc::now().timestamp();\n\n        for node_addr in fallback_peers {\n            peers.push(Peer {\n                id: node_addr.node_id.to_string(),\n                address: format!(\"{}@fallback\", node_addr.node_id),\n                connected_at: now,\n                last_seen: now,\n            });\n        }\n\n        // 統計を更新\n        let mut stats = self.stats.write().await;\n        stats.connected_peers = peers.len();\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\n\n        Ok(())\n    }\n\n    /// 共有シークレットをローテーション\n    pub async fn rotate_dht_secret(&self) -> Result<(), AppError> {\n        secret::rotate_secret()\n            .await\n            .map_err(|e| AppError::P2PError(format!(\"Failed to rotate secret: {e:?}\")))?;\n        tracing::info!(\"DHT shared secret rotated\");\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl NetworkService for IrohNetworkService {\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n    async fn connect(&self) -> Result<(), AppError> {\n        let mut connected = self.connected.write().await;\n        let was_connected = *connected;\n        *connected = true;\n        drop(connected);\n        if !was_connected {\n            let _ = self.connection_events.send(ConnectionEvent::Connected);\n        }\n        tracing::info!(\"Network service connected\");\n        Ok(())\n    }\n\n    async fn disconnect(&self) -> Result<(), AppError> {\n        let mut connected = self.connected.write().await;\n        let was_connected = *connected;\n        *connected = false;\n        drop(connected);\n\n        // ピアリストをクリア\n        let mut peers = self.peers.write().await;\n        peers.clear();\n        super::metrics::set_mainline_connected_peers(0);\n\n        tracing::info!(\"Network service disconnected\");\n        if was_connected {\n            let _ = self.connection_events.send(ConnectionEvent::Disconnected);\n        }\n        Ok(())\n    }\n\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError> {\n        let peers = self.peers.read().await;\n        Ok(peers.clone())\n    }\n\n    async fn add_peer(&self, address: &str) -> Result<(), AppError> {\n        // アドレスからNodeIdを抽出（例: \"node_id@socket_addr\"）\n        use iroh::NodeId;\n        use std::net::SocketAddr;\n        use std::str::FromStr;\n\n        let parts: Vec<&str> = address.split('@').collect();\n        if parts.len() != 2 {\n            super::metrics::record_mainline_connection_failure();\n            return Err(\"Invalid address format: expected 'node_id@socket_addr'\".into());\n        }\n\n        let node_id = NodeId::from_str(parts[0]).map_err(|e| {\n            super::metrics::record_mainline_connection_failure();\n            AppError::from(format!(\"Failed to parse node ID: {e}\"))\n        })?;\n        let socket_addr: SocketAddr = parts[1].parse().map_err(|e| {\n            super::metrics::record_mainline_connection_failure();\n            AppError::from(format!(\"Failed to parse socket address: {e}\"))\n        })?;\n\n        // NodeAddrを構築\n        let node_addr = iroh::NodeAddr::new(node_id).with_direct_addresses([socket_addr]);\n\n        // ピアに接続\n        self.endpoint\n            .connect(node_addr.clone(), iroh_gossip::ALPN)\n            .await\n            .map_err(|e| {\n                super::metrics::record_mainline_connection_failure();\n                AppError::from(format!(\"Failed to connect to peer: {e}\"))\n            })?;\n\n        // ピアリストに追加\n        let mut peers = self.peers.write().await;\n        let now = chrono::Utc::now().timestamp();\n        peers.push(Peer {\n            id: node_id.to_string(),\n            address: address.to_string(),\n            connected_at: now,\n            last_seen: now,\n        });\n\n        // 統計を更新\n        let mut stats = self.stats.write().await;\n        stats.connected_peers = peers.len();\n        super::metrics::record_mainline_connection_success();\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\n\n        tracing::info!(\"Added peer: {}\", address);\n        Ok(())\n    }\n\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError> {\n        let mut peers = self.peers.write().await;\n        peers.retain(|p| p.id != peer_id);\n\n        // 統計を更新\n        let mut stats = self.stats.write().await;\n        stats.connected_peers = peers.len();\n        super::metrics::set_mainline_connected_peers(stats.connected_peers as u64);\n\n        tracing::info!(\"Removed peer: {}\", peer_id);\n        Ok(())\n    }\n\n    async fn get_stats(&self) -> Result<NetworkStats, AppError> {\n        let stats = self.stats.read().await;\n        Ok(stats.clone())\n    }\n\n    async fn is_connected(&self) -> bool {\n        let connected = self.connected.read().await;\n        *connected\n    }\n\n    async fn get_node_id(&self) -> Result<String, AppError> {\n        Ok(self.endpoint.node_id().to_string())\n    }\n\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError> {\n        self.node_addr().await\n    }\n}\n","traces":[{"line":32,"address":[18692992],"length":1,"stats":{"Line":0}},{"line":38,"address":[14009066,14008911],"length":1,"stats":{"Line":0}},{"line":39,"address":[14009154],"length":1,"stats":{"Line":0}},{"line":40,"address":[14009531,14009292,14010042,14009611,14009196],"length":1,"stats":{"Line":0}},{"line":42,"address":[19465405,19465263,19465197,19464835,19465137],"length":1,"stats":{"Line":0}},{"line":43,"address":[19465882,19473216,19473238],"length":1,"stats":{"Line":0}},{"line":46,"address":[19225017,19225182],"length":1,"stats":{"Line":0}},{"line":49,"address":[11754834,11754889],"length":1,"stats":{"Line":0}},{"line":50,"address":[19226161,19346249,19225985,19225484,19346383,19225383],"length":1,"stats":{"Line":0}},{"line":54,"address":[10977417],"length":1,"stats":{"Line":0}},{"line":55,"address":[18697832,18697705],"length":1,"stats":{"Line":0}},{"line":56,"address":[14013124],"length":1,"stats":{"Line":0}},{"line":57,"address":[19346911,19228868,19228196,19229044,19346777,19228340],"length":1,"stats":{"Line":0}},{"line":58,"address":[11758333],"length":1,"stats":{"Line":0}},{"line":62,"address":[11759810,11757759],"length":1,"stats":{"Line":0}},{"line":65,"address":[19230428],"length":1,"stats":{"Line":0}},{"line":66,"address":[19257476,19257349],"length":1,"stats":{"Line":0}},{"line":67,"address":[14015777,14015708],"length":1,"stats":{"Line":0}},{"line":68,"address":[19471686,19471746],"length":1,"stats":{"Line":0}},{"line":69,"address":[11760421,11760559],"length":1,"stats":{"Line":0}},{"line":77,"address":[11760772,11760615],"length":1,"stats":{"Line":0}},{"line":82,"address":[11761135,11753645,11761042,11761220],"length":1,"stats":{"Line":0}},{"line":84,"address":[19258752],"length":1,"stats":{"Line":0}},{"line":87,"address":[19473472],"length":1,"stats":{"Line":0}},{"line":88,"address":[19232648],"length":1,"stats":{"Line":0}},{"line":91,"address":[19473488],"length":1,"stats":{"Line":0}},{"line":92,"address":[14017624],"length":1,"stats":{"Line":0}},{"line":95,"address":[19259416,19264429,19259424,19259455,19259614,19259408,19259571,19259727],"length":1,"stats":{"Line":0}},{"line":96,"address":[19264188,19259532,19259677,19264114],"length":1,"stats":{"Line":0}},{"line":97,"address":[19478300],"length":1,"stats":{"Line":0}},{"line":98,"address":[11766887],"length":1,"stats":{"Line":0}},{"line":102,"address":[10479972],"length":1,"stats":{"Line":0}},{"line":103,"address":[14019000,14018241,14018339,14132265,14132399],"length":1,"stats":{"Line":0}},{"line":104,"address":[19474141],"length":1,"stats":{"Line":0}},{"line":105,"address":[19260077,19374703,19262604,19262780,19374569,19262103],"length":1,"stats":{"Line":0}},{"line":111,"address":[19264448],"length":1,"stats":{"Line":0}},{"line":112,"address":[14022704],"length":1,"stats":{"Line":0}},{"line":115,"address":[19478681,19478767,19478656,19478640,19479368,19478648,19478804,19478945],"length":1,"stats":{"Line":0}},{"line":116,"address":[14022875,14022981,14022922,14023105],"length":1,"stats":{"Line":0}},{"line":119,"address":[19265296],"length":1,"stats":{"Line":0}},{"line":120,"address":[11767845],"length":1,"stats":{"Line":0}},{"line":123,"address":[19479593,19479456,19480980,19479432,19479630,19479424,19479774,19479491],"length":1,"stats":{"Line":0}},{"line":125,"address":[11768226,11768110,11767996,11768048],"length":1,"stats":{"Line":0}},{"line":126,"address":[19480036,19479967],"length":1,"stats":{"Line":0}},{"line":127,"address":[14024293,14024218],"length":1,"stats":{"Line":0}},{"line":128,"address":[19266088],"length":1,"stats":{"Line":0}},{"line":129,"address":[11768858,11768648,11768716],"length":1,"stats":{"Line":0}},{"line":130,"address":[18709238,18709566],"length":1,"stats":{"Line":0}},{"line":132,"address":[19480431,19480504],"length":1,"stats":{"Line":0}},{"line":133,"address":[19480605],"length":1,"stats":{"Line":0}},{"line":135,"address":[11768914],"length":1,"stats":{"Line":0}},{"line":139,"address":[11772012,11769682,11769472,11774319,11769424,11769442,11769812,11769534],"length":1,"stats":{"Line":0}},{"line":140,"address":[18715012,18710122,18710023],"length":1,"stats":{"Line":0}},{"line":141,"address":[19243132,19245058,19242844,19240480,19240534,19240631],"length":1,"stats":{"Line":0}},{"line":142,"address":[14028064,14028840,14028168,14028664,14133321,14133455],"length":1,"stats":{"Line":0}},{"line":144,"address":[14025513,14026339,14025830,14026515,14133983,14133849],"length":1,"stats":{"Line":0}},{"line":146,"address":[19486249,19483553,19481333,19485984,19482182],"length":1,"stats":{"Line":0}},{"line":148,"address":[19243680],"length":1,"stats":{"Line":0}},{"line":152,"address":[19245536,19245833,19245488,19245506,19248379,19245734,19246053,19245583],"length":1,"stats":{"Line":0}},{"line":153,"address":[19272521,19272443],"length":1,"stats":{"Line":0}},{"line":154,"address":[11775237,11775047,11774932,11774965,11775512,11777505],"length":1,"stats":{"Line":0}},{"line":155,"address":[19273188,19273849,19376287,19376153,19273084],"length":1,"stats":{"Line":0}},{"line":157,"address":[19245816],"length":1,"stats":{"Line":0}},{"line":161,"address":[18718018,18718064,18718783,18719276,18718099,18718000,18718295],"length":1,"stats":{"Line":0}},{"line":162,"address":[18718268,18718340],"length":1,"stats":{"Line":0}},{"line":163,"address":[19248752,19248722,19249215,19249486,19249629,19248857],"length":1,"stats":{"Line":0}},{"line":165,"address":[19248768,19249036],"length":1,"stats":{"Line":0}},{"line":167,"address":[11778548],"length":1,"stats":{"Line":0}},{"line":171,"address":[19276528,19276587,19276815,19276971,19277608,19276709,19276504,19276496],"length":1,"stats":{"Line":0}},{"line":173,"address":[18719600,18719731,18719538,18719867],"length":1,"stats":{"Line":0}},{"line":175,"address":[19277267],"length":1,"stats":{"Line":0}},{"line":178,"address":[11779677,11779816,11779086,11779909],"length":1,"stats":{"Line":0}},{"line":180,"address":[19491943],"length":1,"stats":{"Line":0}},{"line":181,"address":[18720820],"length":1,"stats":{"Line":0}},{"line":182,"address":[19251252],"length":1,"stats":{"Line":0}},{"line":183,"address":[11780513],"length":1,"stats":{"Line":0}},{"line":189,"address":[14036226],"length":1,"stats":{"Line":0}},{"line":192,"address":[10980249],"length":1,"stats":{"Line":0}},{"line":193,"address":[19492962,19492895],"length":1,"stats":{"Line":0}},{"line":195,"address":[19252403,19252373,19252167],"length":1,"stats":{"Line":0}},{"line":196,"address":[11781427,11781831],"length":1,"stats":{"Line":0}},{"line":197,"address":[14037646],"length":1,"stats":{"Line":0}},{"line":198,"address":[18722381,18722313],"length":1,"stats":{"Line":0}},{"line":205,"address":[10980272],"length":1,"stats":{"Line":0}},{"line":206,"address":[18722935,18722858],"length":1,"stats":{"Line":0}},{"line":207,"address":[19494220],"length":1,"stats":{"Line":0}},{"line":209,"address":[11782331],"length":1,"stats":{"Line":0}},{"line":213,"address":[11782448,11782432,11782495,11785128,11782590,11782633,11782440,11782817],"length":1,"stats":{"Line":0}},{"line":214,"address":[19495199,19494716,19497102,19494906,19494627,19495004,19494512],"length":1,"stats":{"Line":0}},{"line":215,"address":[19253728,19253816,19253965,19253902,19254106],"length":1,"stats":{"Line":0}},{"line":216,"address":[19283024,19283046,19281052],"length":1,"stats":{"Line":0}},{"line":217,"address":[19495236,19590777,19495943,19495767,19590911],"length":1,"stats":{"Line":0}},{"line":218,"address":[11783796],"length":1,"stats":{"Line":0}},{"line":224,"address":[19591248],"length":1,"stats":{"Line":0}},{"line":227,"address":[19350447,19351178,19350543,19353596,19350934,19350496,19350656],"length":1,"stats":{"Line":0}},{"line":228,"address":[19377422,19377807,19377732,19377946],"length":1,"stats":{"Line":0}},{"line":229,"address":[19351460,19351536],"length":1,"stats":{"Line":0}},{"line":230,"address":[14136514],"length":1,"stats":{"Line":0}},{"line":231,"address":[19378328],"length":1,"stats":{"Line":0}},{"line":232,"address":[19351658],"length":1,"stats":{"Line":0}},{"line":233,"address":[18821264,18821346],"length":1,"stats":{"Line":0}},{"line":235,"address":[19378491,19379059,19378454,19379238,19398921,19399055],"length":1,"stats":{"Line":0}},{"line":236,"address":[19593059],"length":1,"stats":{"Line":0}},{"line":239,"address":[19353844,19353631,19353727,19354143,19353680,19354390,19355030],"length":1,"stats":{"Line":0}},{"line":240,"address":[19354205,19353874,19354283,19354422],"length":1,"stats":{"Line":0}},{"line":241,"address":[19381496,19381412],"length":1,"stats":{"Line":0}},{"line":242,"address":[19381512],"length":1,"stats":{"Line":0}},{"line":243,"address":[18824418],"length":1,"stats":{"Line":0}},{"line":246,"address":[11114850],"length":1,"stats":{"Line":0}},{"line":247,"address":[14140241,14140320],"length":1,"stats":{"Line":0}},{"line":248,"address":[19355371],"length":1,"stats":{"Line":0}},{"line":250,"address":[18842447,18825699,18824986,18825523,18842313],"length":1,"stats":{"Line":0}},{"line":251,"address":[18825493],"length":1,"stats":{"Line":0}},{"line":252,"address":[18826802],"length":1,"stats":{"Line":0}},{"line":254,"address":[14142131],"length":1,"stats":{"Line":0}},{"line":257,"address":[19384524,19384707,19385206,19384121,19384195,19384160,19384282],"length":1,"stats":{"Line":0}},{"line":258,"address":[14484516],"length":1,"stats":{"Line":0}},{"line":259,"address":[19599144,19599071],"length":1,"stats":{"Line":0}},{"line":262,"address":[19361014,19358730,19358511,19358560,19359053,19358622,19360344],"length":1,"stats":{"Line":0}},{"line":268,"address":[19359118],"length":1,"stats":{"Line":0}},{"line":269,"address":[19359189,19359276],"length":1,"stats":{"Line":0}},{"line":270,"address":[19359324],"length":1,"stats":{"Line":0}},{"line":271,"address":[14145197],"length":1,"stats":{"Line":0}},{"line":274,"address":[14149296,14145195,14144543,14144242,14144306,14149524],"length":1,"stats":{"Line":0}},{"line":275,"address":[11956838],"length":1,"stats":{"Line":0}},{"line":276,"address":[14149375],"length":1,"stats":{"Line":0}},{"line":278,"address":[19359628,19359508,19364592,19360207,19359844],"length":1,"stats":{"Line":0}},{"line":279,"address":[14149576],"length":1,"stats":{"Line":0}},{"line":280,"address":[18834222],"length":1,"stats":{"Line":0}},{"line":284,"address":[19359881,19359753],"length":1,"stats":{"Line":0}},{"line":287,"address":[14145030,14145448,14145600,14145755,14144912,14145097],"length":1,"stats":{"Line":0}},{"line":288,"address":[14144995],"length":1,"stats":{"Line":0}},{"line":289,"address":[11952754,11951432,11952794,11952989,11953173],"length":1,"stats":{"Line":0}},{"line":290,"address":[14149728,14149956],"length":1,"stats":{"Line":0}},{"line":291,"address":[11957254],"length":1,"stats":{"Line":0}},{"line":292,"address":[19605679],"length":1,"stats":{"Line":0}},{"line":296,"address":[19167355],"length":1,"stats":{"Line":0}},{"line":297,"address":[19388086,19388016],"length":1,"stats":{"Line":0}},{"line":298,"address":[19388129,19388289],"length":1,"stats":{"Line":0}},{"line":299,"address":[11953980],"length":1,"stats":{"Line":0}},{"line":300,"address":[14146418],"length":1,"stats":{"Line":0}},{"line":306,"address":[14146619,14143762],"length":1,"stats":{"Line":0}},{"line":307,"address":[19362066,19362152],"length":1,"stats":{"Line":0}},{"line":308,"address":[19388953],"length":1,"stats":{"Line":0}},{"line":309,"address":[19362228],"length":1,"stats":{"Line":0}},{"line":311,"address":[19389561,19389013,19399977,19389737,19400111],"length":1,"stats":{"Line":0}},{"line":312,"address":[19362784],"length":1,"stats":{"Line":0}},{"line":315,"address":[14150727,14151261,14150064,14150015,14150111,14150216,14150515],"length":1,"stats":{"Line":0}},{"line":316,"address":[11116703],"length":1,"stats":{"Line":0}},{"line":317,"address":[19392864,19395488,19392777,19395513],"length":1,"stats":{"Line":0}},{"line":320,"address":[14150267,14151111,14151270],"length":1,"stats":{"Line":0}},{"line":321,"address":[19366552,19366635],"length":1,"stats":{"Line":0}},{"line":322,"address":[19366700],"length":1,"stats":{"Line":0}},{"line":324,"address":[19608305,19608129,19614601,19614735,19607581],"length":1,"stats":{"Line":0}},{"line":325,"address":[19367256],"length":1,"stats":{"Line":0}},{"line":328,"address":[11961251,11961177,11961335,11961483,11961216,11962092,11961650],"length":1,"stats":{"Line":0}},{"line":329,"address":[19369334,19369179,19368994],"length":1,"stats":{"Line":0}},{"line":330,"address":[19369570,19369651],"length":1,"stats":{"Line":0}},{"line":333,"address":[11962185,11962397,11962160,11962264,11962526,11962872,11962121,11962331],"length":1,"stats":{"Line":0}},{"line":334,"address":[11359620],"length":1,"stats":{"Line":0}},{"line":335,"address":[19611375,19611308],"length":1,"stats":{"Line":0}},{"line":338,"address":[14155646,14155577,14155714,14156168,14155920,14155616],"length":1,"stats":{"Line":0}},{"line":339,"address":[19397756],"length":1,"stats":{"Line":0}},{"line":342,"address":[19398400,19397999,19398554,19398048,19398083,19398173,19398846],"length":1,"stats":{"Line":0}},{"line":343,"address":[11361191],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":165},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","metrics.rs"],"content":"use serde::Serialize;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nconst UNSET_TS: u64 = 0;\n\n#[derive(Debug)]\nstruct AtomicMetric {\n    success: AtomicU64,\n    failure: AtomicU64,\n    last_success_ms: AtomicU64,\n    last_failure_ms: AtomicU64,\n}\n\nimpl AtomicMetric {\n    const fn new() -> Self {\n        Self {\n            success: AtomicU64::new(0),\n            failure: AtomicU64::new(0),\n            last_success_ms: AtomicU64::new(UNSET_TS),\n            last_failure_ms: AtomicU64::new(UNSET_TS),\n        }\n    }\n\n    fn record_success(&self) {\n        self.success.fetch_add(1, Ordering::Relaxed);\n        self.last_success_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    fn record_failure(&self) {\n        self.failure.fetch_add(1, Ordering::Relaxed);\n        self.last_failure_ms\n            .store(current_unix_ms(), Ordering::Relaxed);\n    }\n\n    fn snapshot(&self) -> GossipMetricDetails {\n        GossipMetricDetails {\n            total: self.success.load(Ordering::Relaxed),\n            failures: self.failure.load(Ordering::Relaxed),\n            last_success_ms: to_option(self.last_success_ms.load(Ordering::Relaxed)),\n            last_failure_ms: to_option(self.last_failure_ms.load(Ordering::Relaxed)),\n        }\n    }\n\n    fn reset(&self) {\n        self.success.store(0, Ordering::Relaxed);\n        self.failure.store(0, Ordering::Relaxed);\n        self.last_success_ms.store(UNSET_TS, Ordering::Relaxed);\n        self.last_failure_ms.store(UNSET_TS, Ordering::Relaxed);\n    }\n}\n\nstatic JOIN_METRIC: AtomicMetric = AtomicMetric::new();\nstatic LEAVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic BROADCAST_METRIC: AtomicMetric = AtomicMetric::new();\nstatic RECEIVE_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_CONNECTION_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_ROUTING_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_RECONNECT_METRIC: AtomicMetric = AtomicMetric::new();\nstatic MAINLINE_CONNECTED_PEERS: AtomicU64 = AtomicU64::new(0);\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricDetails {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct GossipMetricsSnapshot {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetails,\n    pub leave_details: GossipMetricDetails,\n    pub broadcast_details: GossipMetricDetails,\n    pub receive_details: GossipMetricDetails,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct MainlineMetricsSnapshot {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct P2PMetricsSnapshot {\n    pub gossip: GossipMetricsSnapshot,\n    pub mainline: MainlineMetricsSnapshot,\n}\n\n#[inline]\nfn current_unix_ms() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map(|d| d.as_millis() as u64)\n        .unwrap_or(UNSET_TS)\n}\n\n#[inline]\nfn to_option(value: u64) -> Option<u64> {\n    if value == UNSET_TS { None } else { Some(value) }\n}\n\npub fn record_join_success() {\n    JOIN_METRIC.record_success();\n}\n\npub fn record_join_failure() {\n    JOIN_METRIC.record_failure();\n}\n\npub fn record_leave_success() {\n    LEAVE_METRIC.record_success();\n}\n\npub fn record_leave_failure() {\n    LEAVE_METRIC.record_failure();\n}\n\npub fn record_broadcast_success() {\n    BROADCAST_METRIC.record_success();\n}\n\npub fn record_broadcast_failure() {\n    BROADCAST_METRIC.record_failure();\n}\n\npub fn record_receive_success() {\n    RECEIVE_METRIC.record_success();\n}\n\npub fn record_receive_failure() {\n    RECEIVE_METRIC.record_failure();\n}\n\npub fn record_mainline_connection_success() {\n    MAINLINE_CONNECTION_METRIC.record_success();\n}\n\npub fn record_mainline_connection_failure() {\n    MAINLINE_CONNECTION_METRIC.record_failure();\n}\n\npub fn set_mainline_connected_peers(count: u64) {\n    MAINLINE_CONNECTED_PEERS.store(count, Ordering::Relaxed);\n}\n\npub fn record_mainline_route_success() {\n    MAINLINE_ROUTING_METRIC.record_success();\n}\n\npub fn record_mainline_route_failure() {\n    MAINLINE_ROUTING_METRIC.record_failure();\n}\n\npub fn record_mainline_reconnect_success() {\n    MAINLINE_RECONNECT_METRIC.record_success();\n}\n\npub fn record_mainline_reconnect_failure() {\n    MAINLINE_RECONNECT_METRIC.record_failure();\n}\n\n#[allow(dead_code)]\npub fn reset_all() {\n    JOIN_METRIC.reset();\n    LEAVE_METRIC.reset();\n    BROADCAST_METRIC.reset();\n    RECEIVE_METRIC.reset();\n    MAINLINE_CONNECTION_METRIC.reset();\n    MAINLINE_ROUTING_METRIC.reset();\n    MAINLINE_RECONNECT_METRIC.reset();\n    MAINLINE_CONNECTED_PEERS.store(0, Ordering::Relaxed);\n}\n\npub fn snapshot() -> GossipMetricsSnapshot {\n    let join_details = JOIN_METRIC.snapshot();\n    let leave_details = LEAVE_METRIC.snapshot();\n    let broadcast_details = BROADCAST_METRIC.snapshot();\n    let receive_details = RECEIVE_METRIC.snapshot();\n\n    GossipMetricsSnapshot {\n        joins: join_details.total,\n        leaves: leave_details.total,\n        broadcasts_sent: broadcast_details.total,\n        messages_received: receive_details.total,\n        join_details,\n        leave_details,\n        broadcast_details,\n        receive_details,\n    }\n}\n\npub fn mainline_snapshot() -> MainlineMetricsSnapshot {\n    let connection_details = MAINLINE_CONNECTION_METRIC.snapshot();\n    let routing_details = MAINLINE_ROUTING_METRIC.snapshot();\n    let reconnect_details = MAINLINE_RECONNECT_METRIC.snapshot();\n    let connected_peers = MAINLINE_CONNECTED_PEERS.load(Ordering::Relaxed);\n\n    let connection_attempts = connection_details.total + connection_details.failures;\n    let routing_attempts = routing_details.total + routing_details.failures;\n    let routing_success_rate = if routing_attempts == 0 {\n        0.0\n    } else {\n        routing_details.total as f64 / routing_attempts as f64\n    };\n    let reconnect_attempts = reconnect_details.total + reconnect_details.failures;\n\n    MainlineMetricsSnapshot {\n        connected_peers,\n        connection_attempts,\n        connection_successes: connection_details.total,\n        connection_failures: connection_details.failures,\n        connection_last_success_ms: connection_details.last_success_ms,\n        connection_last_failure_ms: connection_details.last_failure_ms,\n        routing_attempts,\n        routing_successes: routing_details.total,\n        routing_failures: routing_details.failures,\n        routing_success_rate,\n        routing_last_success_ms: routing_details.last_success_ms,\n        routing_last_failure_ms: routing_details.last_failure_ms,\n        reconnect_attempts,\n        reconnect_successes: reconnect_details.total,\n        reconnect_failures: reconnect_details.failures,\n        last_reconnect_success_ms: reconnect_details.last_success_ms,\n        last_reconnect_failure_ms: reconnect_details.last_failure_ms,\n    }\n}\n\npub fn snapshot_full() -> P2PMetricsSnapshot {\n    P2PMetricsSnapshot {\n        gossip: snapshot(),\n        mainline: mainline_snapshot(),\n    }\n}\n","traces":[{"line":16,"address":[15253168],"length":1,"stats":{"Line":0}},{"line":18,"address":[15810318],"length":1,"stats":{"Line":0}},{"line":19,"address":[18335270],"length":1,"stats":{"Line":0}},{"line":20,"address":[16024462],"length":1,"stats":{"Line":0}},{"line":21,"address":[18335318],"length":1,"stats":{"Line":0}},{"line":25,"address":[15810480],"length":1,"stats":{"Line":0}},{"line":26,"address":[15810494],"length":1,"stats":{"Line":0}},{"line":27,"address":[15810519,15810546],"length":1,"stats":{"Line":0}},{"line":28,"address":[18335456],"length":1,"stats":{"Line":0}},{"line":31,"address":[18335504],"length":1,"stats":{"Line":0}},{"line":32,"address":[10568814],"length":1,"stats":{"Line":0}},{"line":33,"address":[15253483,15253510],"length":1,"stats":{"Line":0}},{"line":34,"address":[15783892],"length":1,"stats":{"Line":0}},{"line":37,"address":[18335600],"length":1,"stats":{"Line":1}},{"line":39,"address":[18335630],"length":1,"stats":{"Line":1}},{"line":40,"address":[15810726],"length":1,"stats":{"Line":1}},{"line":41,"address":[16024850],"length":1,"stats":{"Line":1}},{"line":42,"address":[18335723],"length":1,"stats":{"Line":1}},{"line":46,"address":[15253760],"length":1,"stats":{"Line":1}},{"line":47,"address":[15253773],"length":1,"stats":{"Line":1}},{"line":48,"address":[15810932],"length":1,"stats":{"Line":1}},{"line":49,"address":[18335887],"length":1,"stats":{"Line":1}},{"line":50,"address":[18335914],"length":1,"stats":{"Line":1}},{"line":111,"address":[15784288],"length":1,"stats":{"Line":0}},{"line":112,"address":[10569252],"length":1,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[18336047,18336032],"length":1,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[15811136],"length":1,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[15811200],"length":1,"stats":{"Line":0}},{"line":124,"address":[10569425],"length":1,"stats":{"Line":0}},{"line":127,"address":[16025312],"length":1,"stats":{"Line":0}},{"line":128,"address":[15811217],"length":1,"stats":{"Line":0}},{"line":131,"address":[18336160],"length":1,"stats":{"Line":0}},{"line":132,"address":[15811233],"length":1,"stats":{"Line":0}},{"line":135,"address":[18336176],"length":1,"stats":{"Line":0}},{"line":136,"address":[16025345],"length":1,"stats":{"Line":0}},{"line":139,"address":[15784528],"length":1,"stats":{"Line":0}},{"line":140,"address":[15254129],"length":1,"stats":{"Line":0}},{"line":143,"address":[15811280],"length":1,"stats":{"Line":0}},{"line":144,"address":[15254145],"length":1,"stats":{"Line":0}},{"line":147,"address":[15784560],"length":1,"stats":{"Line":0}},{"line":148,"address":[15784561],"length":1,"stats":{"Line":0}},{"line":151,"address":[15811312],"length":1,"stats":{"Line":0}},{"line":152,"address":[10569537],"length":1,"stats":{"Line":0}},{"line":155,"address":[15254192],"length":1,"stats":{"Line":0}},{"line":156,"address":[16025425],"length":1,"stats":{"Line":0}},{"line":159,"address":[10569568],"length":1,"stats":{"Line":0}},{"line":160,"address":[16025441],"length":1,"stats":{"Line":0}},{"line":163,"address":[15784624],"length":1,"stats":{"Line":0}},{"line":164,"address":[15784636],"length":1,"stats":{"Line":0}},{"line":167,"address":[16025504],"length":1,"stats":{"Line":0}},{"line":168,"address":[15784673],"length":1,"stats":{"Line":0}},{"line":171,"address":[15784688],"length":1,"stats":{"Line":0}},{"line":172,"address":[15784689],"length":1,"stats":{"Line":0}},{"line":175,"address":[15254304],"length":1,"stats":{"Line":0}},{"line":176,"address":[10569665],"length":1,"stats":{"Line":0}},{"line":179,"address":[15811456],"length":1,"stats":{"Line":0}},{"line":180,"address":[10569681],"length":1,"stats":{"Line":0}},{"line":184,"address":[10569696],"length":1,"stats":{"Line":1}},{"line":185,"address":[10569697],"length":1,"stats":{"Line":1}},{"line":186,"address":[15784749],"length":1,"stats":{"Line":1}},{"line":187,"address":[18336425],"length":1,"stats":{"Line":1}},{"line":188,"address":[18336437],"length":1,"stats":{"Line":1}},{"line":189,"address":[10569745],"length":1,"stats":{"Line":1}},{"line":190,"address":[16025629],"length":1,"stats":{"Line":1}},{"line":191,"address":[18336473],"length":1,"stats":{"Line":1}},{"line":192,"address":[18336485],"length":1,"stats":{"Line":1}},{"line":195,"address":[15784864],"length":1,"stats":{"Line":1}},{"line":196,"address":[18336545],"length":1,"stats":{"Line":1}},{"line":197,"address":[15784898],"length":1,"stats":{"Line":1}},{"line":198,"address":[10569875],"length":1,"stats":{"Line":1}},{"line":199,"address":[15254532],"length":1,"stats":{"Line":1}},{"line":202,"address":[15784957],"length":1,"stats":{"Line":1}},{"line":203,"address":[18336626],"length":1,"stats":{"Line":1}},{"line":204,"address":[15254567],"length":1,"stats":{"Line":1}},{"line":205,"address":[16025807],"length":1,"stats":{"Line":1}},{"line":213,"address":[18336784],"length":1,"stats":{"Line":0}},{"line":214,"address":[15811883],"length":1,"stats":{"Line":0}},{"line":215,"address":[18336828],"length":1,"stats":{"Line":0}},{"line":216,"address":[15785184],"length":1,"stats":{"Line":0}},{"line":217,"address":[15254804],"length":1,"stats":{"Line":0}},{"line":219,"address":[10570205,10570269],"length":1,"stats":{"Line":0}},{"line":220,"address":[15785346,15785281,15785330],"length":1,"stats":{"Line":0}},{"line":221,"address":[16026206,16026170],"length":1,"stats":{"Line":0}},{"line":222,"address":[16026194],"length":1,"stats":{"Line":0}},{"line":224,"address":[15254981],"length":1,"stats":{"Line":0}},{"line":226,"address":[15255061,15255451],"length":1,"stats":{"Line":0}},{"line":231,"address":[15255114],"length":1,"stats":{"Line":0}},{"line":232,"address":[10570483],"length":1,"stats":{"Line":0}},{"line":233,"address":[10570496],"length":1,"stats":{"Line":0}},{"line":234,"address":[18337220],"length":1,"stats":{"Line":0}},{"line":236,"address":[15812307],"length":1,"stats":{"Line":0}},{"line":237,"address":[15812315],"length":1,"stats":{"Line":0}},{"line":239,"address":[10570556],"length":1,"stats":{"Line":0}},{"line":240,"address":[15812348],"length":1,"stats":{"Line":0}},{"line":242,"address":[15255228],"length":1,"stats":{"Line":0}},{"line":243,"address":[10570596],"length":1,"stats":{"Line":0}},{"line":244,"address":[15255244],"length":1,"stats":{"Line":0}},{"line":245,"address":[15812396],"length":1,"stats":{"Line":0}},{"line":249,"address":[15812608],"length":1,"stats":{"Line":0}},{"line":251,"address":[18337552],"length":1,"stats":{"Line":0}},{"line":252,"address":[18337562],"length":1,"stats":{"Line":0}}],"covered":30,"coverable":104},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","mod.rs"],"content":"pub mod bootstrap_config;\npub mod dht_bootstrap;\npub mod dht_integration;\npub mod discovery_options;\npub mod event_distributor;\npub mod gossip_service;\npub mod iroh_gossip_service;\npub mod iroh_network_service;\npub mod metrics;\npub mod network_service;\npub mod utils;\n\nuse serde::{Deserialize, Serialize};\n\npub use iroh_network_service::ConnectionEvent;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DistributionStrategy {\n    Hybrid,\n    Nostr,\n    P2P,\n}\n\npub use discovery_options::DiscoveryOptions;\npub use event_distributor::EventDistributor;\npub use gossip_service::GossipService;\npub use network_service::{NetworkService, NetworkStats, Peer};\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","network_service.rs"],"content":"use crate::shared::error::AppError;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Peer {\n    pub id: String,\n    pub address: String,\n    pub connected_at: i64,\n    pub last_seen: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkStats {\n    pub connected_peers: usize,\n    pub total_messages_sent: u64,\n    pub total_messages_received: u64,\n    pub bandwidth_up: u64,\n    pub bandwidth_down: u64,\n}\n\n#[async_trait]\npub trait NetworkService: Send + Sync {\n    // Type conversion helper for downcasting\n    fn as_any(&self) -> &dyn std::any::Any;\n\n    async fn connect(&self) -> Result<(), AppError>;\n    async fn disconnect(&self) -> Result<(), AppError>;\n    async fn get_peers(&self) -> Result<Vec<Peer>, AppError>;\n    async fn add_peer(&self, address: &str) -> Result<(), AppError>;\n    async fn remove_peer(&self, peer_id: &str) -> Result<(), AppError>;\n    async fn get_stats(&self) -> Result<NetworkStats, AppError>;\n    async fn is_connected(&self) -> bool;\n    async fn get_node_id(&self) -> Result<String, AppError>;\n    async fn get_addresses(&self) -> Result<Vec<String>, AppError>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","p2p","utils.rs"],"content":"use crate::shared::error::AppError;\nuse iroh::{NodeAddr, NodeId};\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\n#[derive(Debug, Clone)]\npub struct ParsedPeer {\n    pub node_id: NodeId,\n    pub node_addr: Option<NodeAddr>,\n}\n\npub fn parse_node_addr(value: &str) -> Result<NodeAddr, AppError> {\n    let (node_part, addr_part) = value\n        .split_once('@')\n        .ok_or_else(|| AppError::P2PError(format!(\"Invalid node address format: {value}\")))?;\n\n    let node_id = NodeId::from_str(node_part)\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n\n    let socket_addr: SocketAddr = addr_part\n        .parse()\n        .map_err(|e| AppError::P2PError(format!(\"Failed to parse socket address: {e}\")))?;\n\n    Ok(NodeAddr::new(node_id).with_direct_addresses([socket_addr]))\n}\n\npub fn parse_peer_hint(value: &str) -> Result<ParsedPeer, AppError> {\n    if value.contains('@') {\n        let node_addr = parse_node_addr(value)?;\n        Ok(ParsedPeer {\n            node_id: node_addr.node_id,\n            node_addr: Some(node_addr),\n        })\n    } else {\n        let node_id = NodeId::from_str(value)\n            .map_err(|e| AppError::P2PError(format!(\"Failed to parse node ID: {e}\")))?;\n        Ok(ParsedPeer {\n            node_id,\n            node_addr: None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_parse_node_addr() {\n        let addr = parse_node_addr(\n            \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef@127.0.0.1:1234\",\n        )\n        .unwrap();\n        assert_eq!(addr.direct_addresses().count(), 1);\n    }\n\n    #[test]\n    fn test_parse_peer_hint_node_id() {\n        let node_id =\n            NodeId::from_str(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n                .unwrap();\n        let parsed =\n            parse_peer_hint(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n                .unwrap();\n        assert_eq!(parsed.node_id, node_id);\n        assert!(parsed.node_addr.is_none());\n    }\n}\n","traces":[{"line":12,"address":[11123856],"length":1,"stats":{"Line":1}},{"line":13,"address":[11654283,11654628],"length":1,"stats":{"Line":1}},{"line":15,"address":[15026112,15025392,15026133],"length":1,"stats":{"Line":0}},{"line":17,"address":[14102802,14102424,14102595],"length":1,"stats":{"Line":2}},{"line":18,"address":[11682230,11682208,11681545],"length":1,"stats":{"Line":0}},{"line":20,"address":[11681989,11681464,11681635],"length":1,"stats":{"Line":2}},{"line":22,"address":[11682464,11681925,11682488],"length":1,"stats":{"Line":0}},{"line":24,"address":[11895795],"length":1,"stats":{"Line":1}},{"line":27,"address":[14103840],"length":1,"stats":{"Line":1}},{"line":28,"address":[11656679,11656328,11655979],"length":1,"stats":{"Line":2}},{"line":29,"address":[14104348,14104604,14104013],"length":1,"stats":{"Line":0}},{"line":30,"address":[11656566],"length":1,"stats":{"Line":0}},{"line":31,"address":[11897292],"length":1,"stats":{"Line":0}},{"line":32,"address":[11656524],"length":1,"stats":{"Line":0}},{"line":35,"address":[11896836,11896971,11897231],"length":1,"stats":{"Line":2}},{"line":36,"address":[15027151,15027606,15027584],"length":1,"stats":{"Line":0}},{"line":37,"address":[14104131],"length":1,"stats":{"Line":1}},{"line":39,"address":[14104119],"length":1,"stats":{"Line":1}}],"covered":10,"coverable":18},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","cache_storage.rs"],"content":"use async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CacheEntry<T> {\n    pub data: T,\n    pub created_at: i64,\n    pub expires_at: Option<i64>,\n}\n\n#[async_trait]\npub trait CacheStorage: Send + Sync {\n    async fn set<T: Serialize + Send + Sync>(\n        &self,\n        key: &str,\n        value: T,\n        ttl: Option<Duration>,\n    ) -> Result<(), Box<dyn std::error::Error>>;\n    async fn get<T: for<'de> Deserialize<'de>>(\n        &self,\n        key: &str,\n    ) -> Result<Option<T>, Box<dyn std::error::Error>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn cleanup_expired(&self) -> Result<u32, Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","file_storage.rs"],"content":"use async_trait::async_trait;\nuse std::path::{Path, PathBuf};\n\n#[async_trait]\npub trait FileStorage: Send + Sync {\n    async fn save_file(&self, path: &Path, data: &[u8]) -> Result<(), Box<dyn std::error::Error>>;\n    async fn read_file(&self, path: &Path) -> Result<Vec<u8>, Box<dyn std::error::Error>>;\n    async fn delete_file(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n    async fn file_exists(&self, path: &Path) -> Result<bool, Box<dyn std::error::Error>>;\n    async fn list_files(\n        &self,\n        directory: &Path,\n    ) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>>;\n    async fn create_directory(&self, path: &Path) -> Result<(), Box<dyn std::error::Error>>;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","mod.rs"],"content":"pub mod cache_storage;\npub mod file_storage;\npub mod secure_storage;\n\npub use secure_storage::SecureStorage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","infrastructure","storage","secure_storage.rs"],"content":"use crate::application::ports::secure_storage::SecureAccountStore;\nuse crate::domain::entities::{\n    AccountMetadata, AccountRegistration, AccountsMetadata, CurrentAccountSecret,\n};\nuse crate::shared::error::AppError;\nuse anyhow::{Context, Result};\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse keyring::Entry;\nuse tracing::{debug, error};\n\nconst SERVICE_NAME: &str = \"kukuri\";\nconst ACCOUNTS_KEY: &str = \"accounts_metadata\";\n\n/// セキュアストレージのトレイト\n#[async_trait]\npub trait SecureStorage: Send + Sync {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>>;\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n}\n\n/// デフォルトのSecureStorage実装\npub struct DefaultSecureStorage;\n\nimpl DefaultSecureStorage {\n    pub fn new() -> Self {\n        Self\n    }\n\n    #[cfg(debug_assertions)]\n    pub fn clear_all_accounts_for_test() -> Result<()> {\n        let metadata = Self::get_accounts_metadata()?;\n        for npub in metadata.accounts.keys() {\n            Self::delete_private_key(npub)?;\n        }\n\n        let entry =\n            Entry::new(SERVICE_NAME, ACCOUNTS_KEY).context(\"Failed to create keyring entry\")?;\n        match entry.delete_credential() {\n            Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n            Err(e) => Err(anyhow::anyhow!(\"Failed to delete accounts metadata: {e}\")),\n        }\n    }\n\n    /// 秘密鍵を保存（npubごとに個別保存）\n    pub fn save_private_key(npub: &str, nsec: &str) -> Result<()> {\n        debug!(\"SecureStorage: Saving private key for npub={npub}\");\n\n        let entry = Entry::new(SERVICE_NAME, npub).context(\"Failed to create keyring entry\")?;\n\n        match entry.set_password(nsec) {\n            Ok(_) => {\n                debug!(\"SecureStorage: Private key saved successfully for npub={npub}\");\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"SecureStorage: Failed to save private key: {e:?}\");\n                Err(anyhow::anyhow!(\n                    \"Failed to save private key to keyring: {e}\"\n                ))\n            }\n        }\n    }\n\n    /// 秘密鍵を取得\n    pub fn get_private_key(npub: &str) -> Result<Option<String>> {\n        let entry = Entry::new(SERVICE_NAME, npub).context(\"Failed to create keyring entry\")?;\n        match entry.get_password() {\n            Ok(password) => Ok(Some(password)),\n            Err(keyring::Error::NoEntry) => Ok(None),\n            Err(e) => Err(anyhow::anyhow!(\"Failed to get private key: {e}\")),\n        }\n    }\n\n    /// 秘密鍵を削除\n    pub fn delete_private_key(npub: &str) -> Result<()> {\n        let entry = Entry::new(SERVICE_NAME, npub).context(\"Failed to create keyring entry\")?;\n        match entry.delete_credential() {\n            Ok(()) => Ok(()),\n            Err(keyring::Error::NoEntry) => Ok(()), // 既に削除されている場合もOK\n            Err(e) => Err(anyhow::anyhow!(\"Failed to delete private key: {e}\")),\n        }\n    }\n\n    /// アカウントメタデータを保存（公開情報のみ）\n    pub fn save_accounts_metadata(metadata: &AccountsMetadata) -> Result<()> {\n        let json =\n            serde_json::to_string(metadata).context(\"Failed to serialize accounts metadata\")?;\n        debug!(\"SecureStorage: Saving metadata JSON: {json}\");\n\n        let entry =\n            Entry::new(SERVICE_NAME, ACCOUNTS_KEY).context(\"Failed to create keyring entry\")?;\n\n        match entry.set_password(&json) {\n            Ok(_) => {\n                debug!(\"SecureStorage: Metadata saved to keyring successfully\");\n\n                // デバッグ: 保存直後に読み取りテスト\n                debug!(\"SecureStorage: Testing immediate read after save...\");\n                let test_entry = Entry::new(SERVICE_NAME, ACCOUNTS_KEY)\n                    .context(\"Failed to create test entry\")?;\n\n                match test_entry.get_password() {\n                    Ok(test_json) => {\n                        debug!(\n                            \"SecureStorage: Immediate read test succeeded, data length: {}\",\n                            test_json.len()\n                        );\n                    }\n                    Err(e) => {\n                        error!(\"SecureStorage: Immediate read test failed: {e:?}\");\n                    }\n                }\n\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"SecureStorage: Failed to save metadata to keyring: {e:?}\");\n                Err(anyhow::anyhow!(\"Failed to save accounts metadata: {e}\"))\n            }\n        }\n    }\n\n    /// アカウントメタデータを取得\n    pub fn get_accounts_metadata() -> Result<AccountsMetadata> {\n        debug!(\"SecureStorage: Getting accounts metadata from keyring...\");\n\n        let entry =\n            Entry::new(SERVICE_NAME, ACCOUNTS_KEY).context(\"Failed to create keyring entry\")?;\n\n        match entry.get_password() {\n            Ok(json) => {\n                debug!(\"SecureStorage: Retrieved metadata JSON: {json}\");\n                let metadata: AccountsMetadata = serde_json::from_str(&json)\n                    .context(\"Failed to deserialize accounts metadata\")?;\n                debug!(\n                    \"SecureStorage: Deserialized metadata - current_npub: {:?}, accounts: {}\",\n                    metadata.current_npub,\n                    metadata.accounts.len()\n                );\n                Ok(metadata)\n            }\n            Err(keyring::Error::NoEntry) => {\n                debug!(\"SecureStorage: No metadata entry found in keyring, returning default\");\n                Ok(AccountsMetadata::default())\n            }\n            Err(e) => {\n                error!(\"SecureStorage: Failed to get metadata from keyring: {e:?}\");\n                Err(anyhow::anyhow!(\"Failed to get accounts metadata: {e}\"))\n            }\n        }\n    }\n}\n\nimpl Default for DefaultSecureStorage {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl SecureStorage for DefaultSecureStorage {\n    async fn store(\n        &self,\n        key: &str,\n        value: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        let entry = Entry::new(SERVICE_NAME, key).map_err(|e| e.to_string())?;\n        entry.set_password(value).map_err(|e| e.to_string())?;\n        Ok(())\n    }\n\n    async fn retrieve(\n        &self,\n        key: &str,\n    ) -> Result<Option<String>, Box<dyn std::error::Error + Send + Sync>> {\n        let entry = Entry::new(SERVICE_NAME, key).map_err(|e| e.to_string())?;\n        match entry.get_password() {\n            Ok(password) => Ok(Some(password)),\n            Err(keyring::Error::NoEntry) => Ok(None),\n            Err(e) => Err(Box::new(e) as Box<dyn std::error::Error + Send + Sync>),\n        }\n    }\n\n    async fn delete(&self, key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        let entry = Entry::new(SERVICE_NAME, key).map_err(|e| e.to_string())?;\n        match entry.delete_credential() {\n            Ok(()) => Ok(()),\n            Err(keyring::Error::NoEntry) => Ok(()), // Already deleted is OK\n            Err(e) => Err(Box::new(e) as Box<dyn std::error::Error + Send + Sync>),\n        }\n    }\n\n    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        let entry = Entry::new(SERVICE_NAME, key).map_err(|e| e.to_string())?;\n        match entry.get_password() {\n            Ok(_) => Ok(true),\n            Err(keyring::Error::NoEntry) => Ok(false),\n            Err(e) => Err(Box::new(e) as Box<dyn std::error::Error + Send + Sync>),\n        }\n    }\n\n    async fn list_keys(&self) -> Result<Vec<String>, Box<dyn std::error::Error + Send + Sync>> {\n        // keyringライブラリは直接的なキーのリストをサポートしていないため、\n        // アカウントメタデータから取得\n        let metadata = Self::get_accounts_metadata().map_err(|e| e.to_string())?;\n        Ok(metadata.accounts.keys().cloned().collect())\n    }\n\n    async fn clear(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        // 全アカウントの秘密鍵を削除\n        let metadata = Self::get_accounts_metadata().map_err(|e| e.to_string())?;\n        for npub in metadata.accounts.keys() {\n            Self::delete_private_key(npub).map_err(|e| e.to_string())?;\n        }\n        // メタデータをクリア\n        Self::save_accounts_metadata(&AccountsMetadata::default()).map_err(|e| e.to_string())?;\n        Ok(())\n    }\n}\n\nfn to_storage_error(err: anyhow::Error) -> AppError {\n    AppError::Storage(err.to_string())\n}\n\n#[async_trait]\nimpl SecureAccountStore for DefaultSecureStorage {\n    async fn add_account(\n        &self,\n        registration: AccountRegistration,\n    ) -> Result<AccountMetadata, AppError> {\n        let (mut metadata, nsec) = registration.into_metadata();\n        debug!(\"SecureStorage: Adding account npub={}\", metadata.npub);\n\n        Self::save_private_key(&metadata.npub, &nsec).map_err(to_storage_error)?;\n\n        let mut accounts = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.mark_used(Utc::now());\n        accounts\n            .accounts\n            .insert(metadata.npub.clone(), metadata.clone());\n        accounts.current_npub = Some(metadata.npub.clone());\n        Self::save_accounts_metadata(&accounts).map_err(to_storage_error)?;\n\n        Ok(metadata)\n    }\n\n    async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let mut accounts: Vec<AccountMetadata> = metadata.accounts.values().cloned().collect();\n        accounts.sort_by(|a, b| b.last_used.cmp(&a.last_used));\n        Ok(accounts)\n    }\n\n    async fn remove_account(&self, npub: &str) -> Result<(), AppError> {\n        Self::delete_private_key(npub).map_err(to_storage_error)?;\n\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        metadata.accounts.remove(npub);\n        if metadata.current_npub.as_deref() == Some(npub) {\n            metadata.current_npub = metadata.accounts.keys().next().cloned();\n        }\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n\n        Ok(())\n    }\n\n    async fn switch_account(&self, npub: &str) -> Result<AccountMetadata, AppError> {\n        let mut metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        let account = metadata\n            .accounts\n            .get_mut(npub)\n            .ok_or_else(|| AppError::NotFound(format!(\"Account not found: {npub}\")))?;\n        account.mark_used(Utc::now());\n        let updated = account.clone();\n        metadata.current_npub = Some(npub.to_string());\n        Self::save_accounts_metadata(&metadata).map_err(to_storage_error)?;\n\n        Ok(updated)\n    }\n\n    async fn get_private_key(&self, npub: &str) -> Result<Option<String>, AppError> {\n        Self::get_private_key(npub).map_err(to_storage_error)\n    }\n\n    async fn current_account(&self) -> Result<Option<CurrentAccountSecret>, AppError> {\n        let metadata = Self::get_accounts_metadata().map_err(to_storage_error)?;\n        if let Some(current) = metadata.current_npub.as_ref() {\n            if let Some(account) = metadata.accounts.get(current) {\n                if let Some(nsec) = Self::get_private_key(current).map_err(to_storage_error)? {\n                    return Ok(Some(CurrentAccountSecret {\n                        metadata: account.clone(),\n                        nsec,\n                    }));\n                }\n            }\n        }\n        Ok(None)\n    }\n}\n\n#[cfg(all(test, target_os = \"windows\"))]\nmod tests {\n    use super::*;\n    use crate::application::ports::secure_storage::SecureAccountStore;\n    use crate::domain::entities::AccountRegistration;\n\n    #[tokio::test]\n    async fn test_secure_storage_store_retrieve() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let result = storage.store(\"test_key\", \"test_value\").await;\n        assert!(result.is_ok());\n\n        // Retrieve the value\n        let result = storage.retrieve(\"test_key\").await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Some(\"test_value\".to_string()));\n\n        // Clean up\n        let _ = storage.delete(\"test_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_delete() {\n        let storage = DefaultSecureStorage::new();\n\n        // Store a value\n        let _ = storage.store(\"test_delete_key\", \"test_value\").await;\n\n        // Delete it\n        let result = storage.delete(\"test_delete_key\").await;\n        assert!(result.is_ok());\n\n        // Verify it's deleted\n        let result = storage.retrieve(\"test_delete_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_secure_storage_exists() {\n        let storage = DefaultSecureStorage::new();\n\n        // Check non-existent key\n        let result = storage.exists(\"non_existent_key\").await;\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n\n        // Store a value\n        let _ = storage.store(\"test_exists_key\", \"test_value\").await;\n\n        // Check it exists\n        let result = storage.exists(\"test_exists_key\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n\n        // Clean up\n        let _ = storage.delete(\"test_exists_key\").await;\n    }\n\n    #[tokio::test]\n    async fn test_add_account() {\n        let storage = DefaultSecureStorage::new();\n        let registration = AccountRegistration {\n            npub: \"npub1test\".to_string(),\n            nsec: \"nsec1test\".to_string(),\n            pubkey: \"pubkey_test\".to_string(),\n            name: \"test_user\".to_string(),\n            display_name: \"Test User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let result = SecureAccountStore::add_account(&storage, registration).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_list_accounts() {\n        let storage = DefaultSecureStorage::new();\n        // Add an account\n        let registration = AccountRegistration {\n            npub: \"npub1list\".to_string(),\n            nsec: \"nsec1list\".to_string(),\n            pubkey: \"pubkey_list\".to_string(),\n            name: \"list_user\".to_string(),\n            display_name: \"List User\".to_string(),\n            picture: None,\n        };\n        let npub = registration.npub.clone();\n        let _ = SecureAccountStore::add_account(&storage, registration).await;\n\n        let result = SecureAccountStore::list_accounts(&storage).await;\n\n        // Clean up\n        let _ = SecureAccountStore::remove_account(&storage, &npub).await;\n\n        assert!(result.is_ok());\n        let accounts = result.unwrap();\n        assert!(accounts.iter().any(|a| a.npub == \"npub1list\"));\n    }\n}\n","traces":[{"line":42,"address":[17582752,17584196,17584023],"length":1,"stats":{"Line":0}},{"line":43,"address":[17609495,17609752],"length":1,"stats":{"Line":0}},{"line":44,"address":[17823824,17823928,17824091],"length":1,"stats":{"Line":0}},{"line":45,"address":[17052875,17053665],"length":1,"stats":{"Line":0}},{"line":48,"address":[17610201,17609951,17610773,17610031],"length":1,"stats":{"Line":0}},{"line":50,"address":[12368511,12368565,12368398],"length":1,"stats":{"Line":0}},{"line":51,"address":[17583594],"length":1,"stats":{"Line":0}},{"line":52,"address":[17583645,17583772],"length":1,"stats":{"Line":0}},{"line":57,"address":[17053824,17059818],"length":1,"stats":{"Line":0}},{"line":58,"address":[17158489,17053879,17158623,17054772],"length":1,"stats":{"Line":0}},{"line":60,"address":[12370919,12370994,12369996],"length":1,"stats":{"Line":0}},{"line":62,"address":[17586120,17586007],"length":1,"stats":{"Line":0}},{"line":64,"address":[12371229,12371702,12371115,12474345,12474479],"length":1,"stats":{"Line":0}},{"line":65,"address":[12371685],"length":1,"stats":{"Line":0}},{"line":67,"address":[16650724],"length":1,"stats":{"Line":0}},{"line":68,"address":[17930713,17930847,17829074,17829560,17827063],"length":1,"stats":{"Line":0}},{"line":69,"address":[16653255,16654603],"length":1,"stats":{"Line":0}},{"line":77,"address":[17831072,17832014],"length":1,"stats":{"Line":0}},{"line":78,"address":[12375239,12375405],"length":1,"stats":{"Line":0}},{"line":79,"address":[17617438,17617152,17617253],"length":1,"stats":{"Line":0}},{"line":80,"address":[17590569],"length":1,"stats":{"Line":0}},{"line":81,"address":[17831625],"length":1,"stats":{"Line":0}},{"line":82,"address":[17590848],"length":1,"stats":{"Line":0}},{"line":87,"address":[17618687,17617952],"length":1,"stats":{"Line":0}},{"line":88,"address":[16655773,16655932],"length":1,"stats":{"Line":0}},{"line":89,"address":[17832369,17832315,17832214],"length":1,"stats":{"Line":0}},{"line":90,"address":[17061126],"length":1,"stats":{"Line":0}},{"line":91,"address":[12376583],"length":1,"stats":{"Line":0}},{"line":92,"address":[17618370],"length":1,"stats":{"Line":0}},{"line":97,"address":[16665339,16669425,16656496],"length":1,"stats":{"Line":0}},{"line":98,"address":[17592017,17592214],"length":1,"stats":{"Line":0}},{"line":100,"address":[17833018,17931209,17931343,17833139,17833644],"length":1,"stats":{"Line":0}},{"line":102,"address":[17594242,17594416,17604947,17592765],"length":1,"stats":{"Line":0}},{"line":105,"address":[17064121,17063993],"length":1,"stats":{"Line":0}},{"line":107,"address":[17595184,17691007,17594697,17594583,17690873],"length":1,"stats":{"Line":0}},{"line":110,"address":[16659650,16661016,16813241,16661519,16813375],"length":1,"stats":{"Line":0}},{"line":111,"address":[12387812,12383496,12383310,12381935],"length":1,"stats":{"Line":0}},{"line":114,"address":[17839441,17839325],"length":1,"stats":{"Line":0}},{"line":115,"address":[12383604],"length":1,"stats":{"Line":0}},{"line":116,"address":[12385469,12384991],"length":1,"stats":{"Line":0}},{"line":121,"address":[17625440],"length":1,"stats":{"Line":0}},{"line":122,"address":[12385874,12477455,12477321,12386352,12383712],"length":1,"stats":{"Line":0}},{"line":126,"address":[17070420],"length":1,"stats":{"Line":0}},{"line":128,"address":[12379571],"length":1,"stats":{"Line":0}},{"line":129,"address":[16667426,16814729,16659156,16667908,16814863],"length":1,"stats":{"Line":0}},{"line":130,"address":[17844237,17845613],"length":1,"stats":{"Line":0}},{"line":136,"address":[17856593,17845808,17852444],"length":1,"stats":{"Line":0}},{"line":137,"address":[17605014,17605850,17693353,17693487],"length":1,"stats":{"Line":0}},{"line":139,"address":[17606642,17605717,17606559],"length":1,"stats":{"Line":0}},{"line":142,"address":[17076423,17076207,17076320],"length":1,"stats":{"Line":0}},{"line":143,"address":[16671224],"length":1,"stats":{"Line":0}},{"line":144,"address":[17634149,17720585,17633531,17720719,17633659],"length":1,"stats":{"Line":0}},{"line":145,"address":[12393819,12392347,12394155],"length":1,"stats":{"Line":0}},{"line":147,"address":[12395598,12396123],"length":1,"stats":{"Line":0}},{"line":152,"address":[16674176],"length":1,"stats":{"Line":0}},{"line":155,"address":[17638536,17638414,17721711,17721577,17639010],"length":1,"stats":{"Line":0}},{"line":156,"address":[16678035,16676689],"length":1,"stats":{"Line":0}},{"line":158,"address":[17081306],"length":1,"stats":{"Line":0}},{"line":159,"address":[12398644,12399130,12480297,12480431,12396722],"length":1,"stats":{"Line":0}},{"line":160,"address":[17615522,17614140],"length":1,"stats":{"Line":0}},{"line":167,"address":[17615776],"length":1,"stats":{"Line":0}},{"line":168,"address":[16680193],"length":1,"stats":{"Line":0}},{"line":179,"address":[12481776,12481327,12481716,12481115,12481792],"length":1,"stats":{"Line":0}},{"line":180,"address":[17696944,17696593,17696928,17696330,17696479,17696702],"length":1,"stats":{"Line":0}},{"line":181,"address":[17166168],"length":1,"stats":{"Line":0}},{"line":188,"address":[17725245,17725296,17724192,17724391,17725312],"length":1,"stats":{"Line":0}},{"line":189,"address":[17697631,17697765,17697949],"length":1,"stats":{"Line":0}},{"line":190,"address":[17697812],"length":1,"stats":{"Line":0}},{"line":191,"address":[17167610],"length":1,"stats":{"Line":0}},{"line":192,"address":[17724926,17724805],"length":1,"stats":{"Line":0}},{"line":196,"address":[16821553,16820587,16820526,16820496,16820723,16821635,16820451],"length":1,"stats":{"Line":0}},{"line":197,"address":[16820783,16821680,16821696,16820965,16821614],"length":1,"stats":{"Line":0}},{"line":198,"address":[17699326,17699193,17699380],"length":1,"stats":{"Line":0}},{"line":199,"address":[17726105],"length":1,"stats":{"Line":0}},{"line":200,"address":[12484401],"length":1,"stats":{"Line":0}},{"line":201,"address":[17699452,17699573],"length":1,"stats":{"Line":0}},{"line":205,"address":[17169803,17170822,17169712,17169947,17169667,17170899,17169742],"length":1,"stats":{"Line":0}},{"line":206,"address":[17941429,17942192,17942126,17941239,17942176],"length":1,"stats":{"Line":0}},{"line":207,"address":[12485664,12485533,12485723],"length":1,"stats":{"Line":0}},{"line":208,"address":[17170347],"length":1,"stats":{"Line":0}},{"line":209,"address":[12485784],"length":1,"stats":{"Line":0}},{"line":210,"address":[17700840,17700961],"length":1,"stats":{"Line":0}},{"line":214,"address":[12486464,12486425,12486746,12486493,12487348,12487362,12486576],"length":1,"stats":{"Line":0}},{"line":217,"address":[12487408,12487357,12487098,12487424,12486814],"length":1,"stats":{"Line":0}},{"line":218,"address":[17171848,17171711],"length":1,"stats":{"Line":0}},{"line":221,"address":[12489059,12487529,12487568,12487651,12488809,12487598,12487797],"length":1,"stats":{"Line":0}},{"line":223,"address":[17173678,17172792,17173744,17173760,17172505],"length":1,"stats":{"Line":0}},{"line":224,"address":[12488926,12488267,12488125,12488401],"length":1,"stats":{"Line":0}},{"line":225,"address":[12488417,12489216,12488828,12488931,12489232],"length":1,"stats":{"Line":0}},{"line":228,"address":[12489328,12488445,12489344,12488394,12488752],"length":1,"stats":{"Line":0}},{"line":229,"address":[17703714],"length":1,"stats":{"Line":0}},{"line":233,"address":[16680340,16680208],"length":1,"stats":{"Line":0}},{"line":234,"address":[16680285,16680227],"length":1,"stats":{"Line":0}},{"line":243,"address":[17174580],"length":1,"stats":{"Line":0}},{"line":244,"address":[12490108,12490029,12490621,12501055,12500921],"length":1,"stats":{"Line":0}},{"line":246,"address":[16828741,16828608,16827156,16830056],"length":1,"stats":{"Line":0}},{"line":248,"address":[12492522,12493546,12492250,12492174],"length":1,"stats":{"Line":0}},{"line":249,"address":[16829051,16829191],"length":1,"stats":{"Line":0}},{"line":250,"address":[17948534,17948680],"length":1,"stats":{"Line":0}},{"line":252,"address":[17707891,17707715,17708555],"length":1,"stats":{"Line":0}},{"line":253,"address":[16829406],"length":1,"stats":{"Line":0}},{"line":254,"address":[17177711,17177897],"length":1,"stats":{"Line":0}},{"line":256,"address":[16829680],"length":1,"stats":{"Line":0}},{"line":259,"address":[12493854,12493824,12494908,12493922,12494894,12494128,12493785],"length":1,"stats":{"Line":0}},{"line":260,"address":[12494196,12494903,12494483],"length":1,"stats":{"Line":0}},{"line":261,"address":[17950328,17950468],"length":1,"stats":{"Line":0}},{"line":262,"address":[16831106,16831376,16831408,16831168],"length":1,"stats":{"Line":0}},{"line":263,"address":[16831175],"length":1,"stats":{"Line":0}},{"line":266,"address":[17950944,17950974,17951263,17950899,17951045,17952567,17952586],"length":1,"stats":{"Line":0}},{"line":267,"address":[17951440,17952581,17951323],"length":1,"stats":{"Line":0}},{"line":269,"address":[17952576,17951802,17951433,17951509],"length":1,"stats":{"Line":0}},{"line":270,"address":[17951915,17951762],"length":1,"stats":{"Line":0}},{"line":271,"address":[17737838,17738201],"length":1,"stats":{"Line":0}},{"line":272,"address":[17180850],"length":1,"stats":{"Line":0}},{"line":274,"address":[17737971,17738314,17738211],"length":1,"stats":{"Line":0}},{"line":276,"address":[12496507],"length":1,"stats":{"Line":0}},{"line":279,"address":[17952688,17952935,17954210,17954226,17952801,17952643,17952718],"length":1,"stats":{"Line":0}},{"line":280,"address":[17739204,17740125,17738907],"length":1,"stats":{"Line":0}},{"line":281,"address":[17953263,17953571,17953427,17954219,17953284],"length":1,"stats":{"Line":0}},{"line":283,"address":[12497399],"length":1,"stats":{"Line":0}},{"line":284,"address":[17183040,17183061,17182186,17182307],"length":1,"stats":{"Line":0}},{"line":285,"address":[12497648,12497741],"length":1,"stats":{"Line":0}},{"line":286,"address":[12497773],"length":1,"stats":{"Line":0}},{"line":287,"address":[17739632,17739556],"length":1,"stats":{"Line":0}},{"line":288,"address":[17739798,17739976],"length":1,"stats":{"Line":0}},{"line":290,"address":[17739930],"length":1,"stats":{"Line":0}},{"line":293,"address":[17740416,17740445,17740887,17740513,17740371,17740718],"length":1,"stats":{"Line":0}},{"line":294,"address":[12499002],"length":1,"stats":{"Line":0}},{"line":297,"address":[17742600,17740937,17740976,17741089,17741006,17741223,17742553],"length":1,"stats":{"Line":0}},{"line":298,"address":[17184439,17184155,17185459],"length":1,"stats":{"Line":0}},{"line":299,"address":[17741693,17741551],"length":1,"stats":{"Line":0}},{"line":300,"address":[12499975,12500074],"length":1,"stats":{"Line":0}},{"line":301,"address":[17742562,17741912],"length":1,"stats":{"Line":0}},{"line":302,"address":[17742405],"length":1,"stats":{"Line":0}},{"line":303,"address":[17956380],"length":1,"stats":{"Line":0}},{"line":304,"address":[16836813],"length":1,"stats":{"Line":0}},{"line":309,"address":[16836257],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":137},{"path":["/","app","kukuri-tauri","src-tauri","src","lib.rs"],"content":"use tauri::{Emitter, Manager};\r\nuse tracing::info;\r\n\r\n// モジュール定義\r\nmod application;\r\nmod domain;\r\nmod infrastructure;\r\nmod modules;\r\nmod presentation;\r\nmod shared;\nmod state;\n\n#[doc(hidden)]\npub mod test_support {\n    pub mod application {\n        pub use crate::application::ports;\n        pub use crate::application::services;\n        pub use crate::application::shared;\n    }\n    pub mod domain {\n        pub use crate::domain::entities;\n        pub use crate::domain::p2p;\n        pub use crate::domain::value_objects;\n    }\n    pub mod infrastructure {\n        pub use crate::infrastructure::offline;\n        pub use crate::infrastructure::p2p;\n    }\n    pub mod shared {\n        pub use crate::shared::config;\n    }\n}\n\n#[doc(hidden)]\npub mod contract_testing;\n\r\n// Tauriコマンドのインポート\r\n// v2アーキテクチャへの移行完了につき、旧コマンドのインポートは削除\r\nuse state::AppState;\r\n\r\n#[cfg_attr(mobile, tauri::mobile_entry_point)]\r\n/// Run the Tauri application\r\n///\r\n/// # Panics\r\n///\r\n/// Panics if the Tauri application fails to run\r\npub fn run() {\r\n    // ログ設定の初期化\r\n    init_logging();\r\n\r\n    info!(\"Kukuri Tauri application starting...\");\r\n\r\n    tauri::Builder::default()\r\n        .plugin(tauri_plugin_opener::init())\r\n        .invoke_handler(tauri::generate_handler![\r\n            // 認証関連コマンド\r\n            presentation::commands::generate_keypair,\r\n            presentation::commands::login,\r\n            presentation::commands::logout,\r\n            // セキュアストレージ関連コマンド\r\n            presentation::commands::add_account,\r\n            presentation::commands::list_accounts,\r\n            presentation::commands::switch_account,\r\n            presentation::commands::remove_account,\r\n            presentation::commands::get_current_account,\r\n            presentation::commands::secure_login,\r\n            // テスト用コマンド\r\n            presentation::commands::clear_all_accounts_for_test,\r\n            // トピック関連コマンド\r\n            presentation::commands::create_topic,\r\n            presentation::commands::get_topic,\r\n            presentation::commands::get_topics,\r\n            presentation::commands::get_joined_topics,\r\n            presentation::commands::update_topic,\r\n            presentation::commands::delete_topic,\r\n            presentation::commands::join_topic,\r\n            presentation::commands::leave_topic,\r\n            presentation::commands::get_topic_stats,\r\n            // ポスト関連コマンド\r\n            presentation::commands::create_post,\r\n            presentation::commands::get_posts,\r\n            presentation::commands::delete_post,\r\n            presentation::commands::react_to_post,\r\n            presentation::commands::bookmark_post,\r\n            presentation::commands::unbookmark_post,\r\n            presentation::commands::like_post,\r\n            presentation::commands::boost_post,\r\n            presentation::commands::get_bookmarked_post_ids,\r\n            presentation::commands::batch_get_posts,\r\n            presentation::commands::batch_react,\r\n            presentation::commands::batch_bookmark,\r\n            // Nostr関連コマンド\r\n            presentation::commands::initialize_nostr,\r\n            presentation::commands::publish_text_note,\r\n            presentation::commands::publish_topic_post,\r\n            presentation::commands::send_reaction,\r\n            presentation::commands::update_nostr_metadata,\r\n            presentation::commands::subscribe_to_topic,\r\n            presentation::commands::subscribe_to_user,\r\n            presentation::commands::get_nostr_pubkey,\r\n            presentation::commands::delete_events,\r\n            presentation::commands::disconnect_nostr,\r\n            presentation::commands::set_default_p2p_topic,\r\n            presentation::commands::list_nostr_subscriptions,\r\n            // P2P関連コマンド\r\n            presentation::commands::initialize_p2p,\r\n            presentation::commands::join_p2p_topic,\r\n            presentation::commands::leave_p2p_topic,\r\n            presentation::commands::broadcast_to_topic,\r\n            presentation::commands::get_p2p_status,\r\n            presentation::commands::get_node_address,\r\n            presentation::commands::join_topic_by_name,\r\n            presentation::commands::get_p2p_metrics,\r\n            // オフライン関連コマンド\r\n            presentation::commands::save_offline_action,\r\n            presentation::commands::get_offline_actions,\r\n            presentation::commands::sync_offline_actions,\r\n            presentation::commands::get_cache_status,\r\n            presentation::commands::add_to_sync_queue,\r\n            presentation::commands::update_cache_metadata,\r\n            presentation::commands::save_optimistic_update,\r\n            presentation::commands::confirm_optimistic_update,\r\n            presentation::commands::rollback_optimistic_update,\r\n            presentation::commands::cleanup_expired_cache,\r\n            presentation::commands::update_sync_status,\r\n            // ユーティリティコマンド\r\n            presentation::commands::pubkey_to_npub,\r\n            presentation::commands::npub_to_pubkey,\r\n            // Bootstrap UI commands\r\n            presentation::commands::get_bootstrap_config,\r\n            presentation::commands::set_bootstrap_nodes,\r\n            presentation::commands::clear_bootstrap_nodes,\r\n        ])\r\n        .setup(|app| {\r\n            // アプリケーション初期化処理\r\n            let app_handle = app.handle();\r\n\r\n            tauri::async_runtime::block_on(async move {\r\n                let app_state = AppState::new(app_handle)\r\n                    .await\r\n                    .expect(\"Failed to initialize app state\");\r\n\r\n                // P2P機能を初期化\n                if let Err(e) = app_state.initialize_p2p().await {\n                    tracing::warn!(\"Failed to initialize P2P: {}\", e);\n                }\n\r\n                // P2Pイベントハンドラーを起動\r\n                spawn_p2p_event_handler(app_handle.clone(), app_state.clone());\r\n\r\n                app_handle.manage(app_state);\r\n            });\r\n\r\n            info!(\"Application setup complete\");\r\n            Ok(())\r\n        })\r\n        .run(tauri::generate_context!())\r\n        .expect(\"error while running tauri application\");\r\n}\r\n\r\nfn init_logging() {\r\n    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\r\n\r\n    tracing_subscriber::registry()\r\n        .with(\r\n            tracing_subscriber::EnvFilter::try_from_default_env()\r\n                .unwrap_or_else(|_| \"kukuri=debug,info\".into()),\r\n        )\r\n        .with(tracing_subscriber::fmt::layer())\r\n        .init();\r\n}\r\n\r\n/// P2Pイベントハンドラーを起動\r\nfn spawn_p2p_event_handler(app_handle: tauri::AppHandle, app_state: AppState) {\r\n    use serde::Serialize;\r\n\r\n    #[derive(Debug, Clone, Serialize)]\r\n    struct P2PMessageEvent {\r\n        topic_id: String,\r\n        message_type: String,\r\n        payload: Vec<u8>,\r\n        sender: Vec<u8>,\r\n        timestamp: i64,\r\n    }\r\n\r\n    #[derive(Debug, Clone, Serialize)]\r\n    struct P2PPeerEvent {\r\n        topic_id: String,\r\n        peer_id: Vec<u8>,\r\n        event_type: String, // \"joined\" or \"left\"\r\n    }\r\n\r\n    tauri::async_runtime::spawn(async move {\r\n        // event_rxを取得してRwLockを即座に解放\r\n        let rx = {\r\n            let p2p_state = app_state.p2p_state.read().await;\r\n            let mut event_rx = p2p_state.event_rx.write().await;\r\n            event_rx.take()\r\n        };\r\n\r\n        if let Some(mut rx) = rx {\r\n            while let Some(event) = rx.recv().await {\r\n                match event {\r\n                    crate::domain::p2p::P2PEvent::MessageReceived {\n                        topic_id,\n                        message,\n                        _from_peer: _,\n                    } => {\n                        // 旧GossipMessage経路はUIの期待ペイロードと形状が異なるため、\r\n                        // 衝突回避のためイベント名を変更（デバッグ用途）\r\n                        let event_data = P2PMessageEvent {\r\n                            topic_id,\r\n                            message_type: format!(\"{:?}\", message.msg_type),\r\n                            payload: message.payload,\r\n                            sender: message.sender,\r\n                            timestamp: message.timestamp,\r\n                        };\r\n\r\n                        if let Err(e) = app_handle.emit(\"p2p://message/raw\", event_data) {\r\n                            tracing::error!(\"Failed to emit P2P raw message event: {}\", e);\r\n                        }\r\n                    }\r\n                    crate::domain::p2p::P2PEvent::PeerJoined { topic_id, peer_id } => {\n                        let event_data = P2PPeerEvent {\n                            topic_id,\n                            peer_id,\n                            event_type: \"joined\".to_string(),\n                        };\n\r\n                        if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\r\n                            tracing::error!(\"Failed to emit P2P peer joined event: {}\", e);\r\n                        }\r\n                    }\r\n                    crate::domain::p2p::P2PEvent::PeerLeft { topic_id, peer_id } => {\n                        let event_data = P2PPeerEvent {\n                            topic_id,\n                            peer_id,\n                            event_type: \"left\".to_string(),\n                        };\n\r\n                        if let Err(e) = app_handle.emit(\"p2p://peer\", event_data) {\r\n                            tracing::error!(\"Failed to emit P2P peer left event: {}\", e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            tracing::info!(\"P2P event handler terminated\");\r\n        }\r\n    });\r\n}\r\n","traces":[{"line":47,"address":[76100208],"length":1,"stats":{"Line":1}},{"line":49,"address":[58876061,58876666,58877101,58855950],"length":1,"stats":{"Line":2}},{"line":51,"address":[29729946],"length":1,"stats":{"Line":7}},{"line":53,"address":[63212184],"length":1,"stats":{"Line":5}},{"line":54,"address":[89672459],"length":1,"stats":{"Line":5}},{"line":55,"address":[84406819],"length":1,"stats":{"Line":0}},{"line":57,"address":[45512435,45512447,45536542,45512384],"length":1,"stats":{"Line":7}},{"line":58,"address":[29614409,29614265],"length":1,"stats":{"Line":7}},{"line":59,"address":[55824253],"length":1,"stats":{"Line":5}},{"line":61,"address":[44283515],"length":1,"stats":{"Line":0}},{"line":62,"address":[69658512],"length":1,"stats":{"Line":17}},{"line":63,"address":[33972455],"length":1,"stats":{"Line":5}},{"line":64,"address":[118251815],"length":1,"stats":{"Line":5}},{"line":65,"address":[40104752],"length":1,"stats":{"Line":5}},{"line":66,"address":[99830061,99830114],"length":1,"stats":{"Line":0}},{"line":68,"address":[84406930],"length":1,"stats":{"Line":0}},{"line":70,"address":[100183202,100181019,100181074,100183147],"length":1,"stats":{"Line":5}},{"line":71,"address":[42028536],"length":1,"stats":{"Line":5}},{"line":72,"address":[63607010],"length":1,"stats":{"Line":15}},{"line":73,"address":[45076597,45075680],"length":1,"stats":{"Line":0}},{"line":74,"address":[44681630],"length":1,"stats":{"Line":5}},{"line":75,"address":[69767276],"length":1,"stats":{"Line":0}},{"line":76,"address":[112662185,112661914,112662276],"length":1,"stats":{"Line":0}},{"line":77,"address":[44243527],"length":1,"stats":{"Line":0}},{"line":78,"address":[100089635,100090680],"length":1,"stats":{"Line":0}},{"line":80,"address":[107966704,107966635],"length":1,"stats":{"Line":15}},{"line":81,"address":[62478298,62478242],"length":1,"stats":{"Line":5}},{"line":82,"address":[110731297],"length":1,"stats":{"Line":1}},{"line":83,"address":[45001255,45001317],"length":1,"stats":{"Line":3}},{"line":84,"address":[30456444,30456427],"length":1,"stats":{"Line":7}},{"line":85,"address":[116452931,116452640],"length":1,"stats":{"Line":2}},{"line":86,"address":[94471088],"length":1,"stats":{"Line":2}},{"line":87,"address":[31389923],"length":1,"stats":{"Line":3}},{"line":88,"address":[55596080],"length":1,"stats":{"Line":1}},{"line":89,"address":[77200586,77201969],"length":1,"stats":{"Line":3}},{"line":90,"address":[68118743],"length":1,"stats":{"Line":1}},{"line":91,"address":[104427456],"length":1,"stats":{"Line":0}},{"line":93,"address":[69294960],"length":1,"stats":{"Line":5}},{"line":94,"address":[37157223],"length":1,"stats":{"Line":1}},{"line":95,"address":[60871161,60871295,60861737,60866201,60866335,60803355,60865343,60868185,60827601,60828082,60821016,60862729,60809335,60809415,60861871,60840285,60813755,60802830,60827521,60821541,60839760,60814280,60862863,60809896,60865209,60868319],"length":1,"stats":{"Line":0}},{"line":96,"address":[69998707],"length":1,"stats":{"Line":0}},{"line":97,"address":[107358722],"length":1,"stats":{"Line":2}},{"line":98,"address":[39472496],"length":1,"stats":{"Line":1}},{"line":99,"address":[83625845],"length":1,"stats":{"Line":1}},{"line":100,"address":[106712312],"length":1,"stats":{"Line":0}},{"line":101,"address":[39472639,39472728],"length":1,"stats":{"Line":0}},{"line":102,"address":[105483313],"length":1,"stats":{"Line":0}},{"line":103,"address":[69138705,69138112,69138539,69139007,69138222,69138011,69138576],"length":1,"stats":{"Line":2}},{"line":104,"address":[49746234],"length":1,"stats":{"Line":0}},{"line":106,"address":[90602688,90602704],"length":1,"stats":{"Line":1}},{"line":107,"address":[58900960],"length":1,"stats":{"Line":2}},{"line":108,"address":[57961004],"length":1,"stats":{"Line":3}},{"line":109,"address":[113547760,113547902,113547763,113547819],"length":1,"stats":{"Line":6}},{"line":110,"address":[99593907],"length":1,"stats":{"Line":2}},{"line":111,"address":[53592225],"length":1,"stats":{"Line":3}},{"line":112,"address":[60714816],"length":1,"stats":{"Line":1}},{"line":113,"address":[94471290],"length":1,"stats":{"Line":1}},{"line":115,"address":[107873760,107873793],"length":1,"stats":{"Line":1}},{"line":116,"address":[65243644],"length":1,"stats":{"Line":0}},{"line":117,"address":[41021088],"length":1,"stats":{"Line":0}},{"line":118,"address":[75476745],"length":1,"stats":{"Line":3}},{"line":119,"address":[57945646,57947774,57945543,57947671],"length":1,"stats":{"Line":0}},{"line":120,"address":[116071255],"length":1,"stats":{"Line":2}},{"line":121,"address":[116705712],"length":1,"stats":{"Line":4}},{"line":122,"address":[113406107],"length":1,"stats":{"Line":2}},{"line":123,"address":[42917390],"length":1,"stats":{"Line":0}},{"line":124,"address":[104586610],"length":1,"stats":{"Line":2}},{"line":125,"address":[65670784],"length":1,"stats":{"Line":3}},{"line":127,"address":[23290574],"length":1,"stats":{"Line":3}},{"line":128,"address":[57671793],"length":1,"stats":{"Line":3}},{"line":130,"address":[59166755],"length":1,"stats":{"Line":0}},{"line":131,"address":[107529548],"length":1,"stats":{"Line":3}},{"line":132,"address":[62246646],"length":1,"stats":{"Line":2}},{"line":134,"address":[43966159],"length":1,"stats":{"Line":0}},{"line":136,"address":[43131717],"length":1,"stats":{"Line":0}},{"line":138,"address":[116271656],"length":1,"stats":{"Line":0}},{"line":139,"address":[104399976],"length":1,"stats":{"Line":0}},{"line":140,"address":[30109985],"length":1,"stats":{"Line":0}},{"line":141,"address":[115323168],"length":1,"stats":{"Line":0}},{"line":144,"address":[30223672],"length":1,"stats":{"Line":0}},{"line":145,"address":[115605883],"length":1,"stats":{"Line":3}},{"line":149,"address":[55613070,55612842],"length":1,"stats":{"Line":5}},{"line":151,"address":[78098498],"length":1,"stats":{"Line":7}},{"line":154,"address":[117216624,117216629],"length":1,"stats":{"Line":138}},{"line":155,"address":[89555254,89555415],"length":1,"stats":{"Line":0}},{"line":157,"address":[43933501,43933366,43933316],"length":1,"stats":{"Line":3}},{"line":161,"address":[73614323],"length":1,"stats":{"Line":5}},{"line":164,"address":[102921550],"length":1,"stats":{"Line":2}},{"line":166,"address":[116611954,116611467,116612256,116611751,116612012],"length":1,"stats":{"Line":4}},{"line":167,"address":[112948543],"length":1,"stats":{"Line":0}},{"line":169,"address":[88326323],"length":1,"stats":{"Line":2}},{"line":174,"address":[75414886],"length":1,"stats":{"Line":4}},{"line":193,"address":[113462934,113461275,113469899,113461190,113461430,113468171,113469984,113471896,113466668,113473416,113464920,113470139,113464680,113473501,113464765,113463174,113468411,113471741,113473656,113463019,113466428,113471656,113466513,113468256],"length":1,"stats":{"Line":2}},{"line":195,"address":[29983824,29983696,29983760,29983888,29983632],"length":1,"stats":{"Line":8}},{"line":196,"address":[18672703,18672382,18672445,18672578],"length":1,"stats":{"Line":3}},{"line":197,"address":[79891852],"length":1,"stats":{"Line":13}},{"line":198,"address":[79452890],"length":1,"stats":{"Line":12}},{"line":201,"address":[42918147],"length":1,"stats":{"Line":1}},{"line":202,"address":[102802031],"length":1,"stats":{"Line":1}},{"line":203,"address":[84364344],"length":1,"stats":{"Line":2}},{"line":204,"address":[30031873],"length":1,"stats":{"Line":3}},{"line":205,"address":[44441509],"length":1,"stats":{"Line":0}},{"line":206,"address":[48379918],"length":1,"stats":{"Line":7}},{"line":207,"address":[113430416],"length":1,"stats":{"Line":0}},{"line":208,"address":[113754360,113759579,113752614,113750870,113756108,113757851,113761337,113763097],"length":1,"stats":{"Line":0}},{"line":211,"address":[91707621],"length":1,"stats":{"Line":2}},{"line":212,"address":[61270453,61270523],"length":1,"stats":{"Line":2}},{"line":213,"address":[23449792],"length":1,"stats":{"Line":2}},{"line":214,"address":[85304336],"length":1,"stats":{"Line":1}},{"line":215,"address":[29712744],"length":1,"stats":{"Line":0}},{"line":216,"address":[87464866],"length":1,"stats":{"Line":0}},{"line":219,"address":[102802404],"length":1,"stats":{"Line":0}},{"line":220,"address":[77201710],"length":1,"stats":{"Line":0}},{"line":223,"address":[44381356],"length":1,"stats":{"Line":0}},{"line":224,"address":[92809276],"length":1,"stats":{"Line":4}},{"line":225,"address":[70730151,70726454,70740258,70741264],"length":1,"stats":{"Line":3}},{"line":226,"address":[29712768],"length":1,"stats":{"Line":0}},{"line":227,"address":[61249649],"length":1,"stats":{"Line":0}},{"line":230,"address":[69344348,69344204,69344578,69344123],"length":1,"stats":{"Line":8}},{"line":231,"address":[103519953,103520326],"length":1,"stats":{"Line":6}},{"line":234,"address":[61249707],"length":1,"stats":{"Line":5}},{"line":235,"address":[24138843],"length":1,"stats":{"Line":1}},{"line":236,"address":[87717322],"length":1,"stats":{"Line":1}},{"line":237,"address":[102802880],"length":1,"stats":{"Line":0}},{"line":238,"address":[40903936,40903404],"length":1,"stats":{"Line":8}},{"line":241,"address":[84297472,84297480,84297520,84297525],"length":1,"stats":{"Line":8}},{"line":242,"address":[102266407],"length":1,"stats":{"Line":8}},{"line":248,"address":[112036617,112036297,112034109,112033500,112029730,112034412,112038669,112029471,112029235],"length":1,"stats":{"Line":2}}],"covered":87,"coverable":128},{"path":["/","app","kukuri-tauri","src-tauri","src","main.rs"],"content":"// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nfn main() {\n    kukuri_lib::run();\n}\n","traces":[{"line":4,"address":[10447600],"length":1,"stats":{"Line":0}},{"line":5,"address":[10447601],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","crypto","encryption.rs"],"content":"use aes_gcm::{\n    Aes256Gcm, Key, Nonce,\n    aead::{Aead, AeadCore, KeyInit, OsRng},\n};\nuse anyhow::{Result, anyhow};\nuse base64::{Engine as _, engine::general_purpose};\nuse sha2::{Digest, Sha256};\n\n#[allow(dead_code)]\n#[derive(Clone)]\npub struct EncryptionManager;\n\n#[allow(dead_code)]\nimpl EncryptionManager {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub fn encrypt(&self, plaintext: &[u8], password: &str) -> Result<String> {\n        encrypt(plaintext, password)\n    }\n\n    pub fn decrypt(&self, encrypted_data: &str, password: &str) -> Result<Vec<u8>> {\n        decrypt(encrypted_data, password)\n    }\n}\n\nfn encrypt(plaintext: &[u8], password: &str) -> Result<String> {\n    // Derive key from password\n    let key = derive_key_from_password(password);\n    let cipher = Aes256Gcm::new(&key);\n\n    // Generate random nonce\n    let nonce = Aes256Gcm::generate_nonce(&mut OsRng);\n\n    // Encrypt\n    let ciphertext = cipher\n        .encrypt(&nonce, plaintext)\n        .map_err(|e| anyhow!(\"Encryption failed: {}\", e))?;\n\n    // Combine nonce and ciphertext, then Base64 encode\n    let mut combined = nonce.to_vec();\n    combined.extend_from_slice(&ciphertext);\n\n    Ok(general_purpose::STANDARD.encode(&combined))\n}\n\nfn decrypt(encrypted_data: &str, password: &str) -> Result<Vec<u8>> {\n    // Base64 decode\n    let combined = general_purpose::STANDARD\n        .decode(encrypted_data)\n        .map_err(|e| anyhow!(\"Base64 decode failed: {}\", e))?;\n\n    // Separate nonce and ciphertext\n    if combined.len() < 12 {\n        return Err(anyhow!(\"Invalid encrypted data\"));\n    }\n\n    let (nonce_bytes, ciphertext) = combined.split_at(12);\n    let mut nonce = Nonce::default();\n    nonce.copy_from_slice(nonce_bytes);\n\n    // Derive key from password\n    let key = derive_key_from_password(password);\n    let cipher = Aes256Gcm::new(&key);\n\n    // Decrypt\n    cipher\n        .decrypt(&nonce, ciphertext)\n        .map_err(|e| anyhow!(\"Decryption failed: {}\", e))\n}\n\nfn derive_key_from_password(password: &str) -> Key<Aes256Gcm> {\n    let mut hasher = Sha256::new();\n    hasher.update(password.as_bytes());\n    let result = hasher.finalize();\n    let mut key = Key::<Aes256Gcm>::default();\n    key.copy_from_slice(&result);\n    key\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_encrypt_decrypt_roundtrip() {\n        let plaintext = b\"Hello, World! This is a test message.\";\n        let password = \"test_password_123\";\n\n        // Encrypt\n        let encrypted = encrypt(plaintext, password).unwrap();\n        assert!(!encrypted.is_empty());\n\n        // Decrypt\n        let decrypted = decrypt(&encrypted, password).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n\n    #[test]\n    fn test_encrypt_produces_different_results() {\n        let plaintext = b\"Test message\";\n        let password = \"password\";\n\n        // Encrypt twice\n        let encrypted1 = encrypt(plaintext, password).unwrap();\n        let encrypted2 = encrypt(plaintext, password).unwrap();\n\n        // Should be different due to random nonce\n        assert_ne!(encrypted1, encrypted2);\n\n        // But both should decrypt to same plaintext\n        let decrypted1 = decrypt(&encrypted1, password).unwrap();\n        let decrypted2 = decrypt(&encrypted2, password).unwrap();\n        assert_eq!(decrypted1, plaintext);\n        assert_eq!(decrypted2, plaintext);\n    }\n\n    #[test]\n    fn test_decrypt_with_wrong_password_fails() {\n        let plaintext = b\"Secret message\";\n        let password = \"correct_password\";\n        let wrong_password = \"wrong_password\";\n\n        // Encrypt with correct password\n        let encrypted = encrypt(plaintext, password).unwrap();\n\n        // Try to decrypt with wrong password\n        let result = decrypt(&encrypted, wrong_password);\n        assert!(result.is_err());\n        assert!(\n            result\n                .unwrap_err()\n                .to_string()\n                .contains(\"Decryption failed\")\n        );\n    }\n\n    #[test]\n    fn test_decrypt_invalid_base64_fails() {\n        let invalid_base64 = \"This is not valid base64!@#$\";\n        let password = \"password\";\n\n        let result = decrypt(invalid_base64, password);\n        assert!(result.is_err());\n        assert!(\n            result\n                .unwrap_err()\n                .to_string()\n                .contains(\"Base64 decode failed\")\n        );\n    }\n\n    #[test]\n    fn test_decrypt_too_short_data_fails() {\n        // Valid base64 but too short (less than 12 bytes for nonce)\n        let too_short = general_purpose::STANDARD.encode(b\"short\");\n        let password = \"password\";\n\n        let result = decrypt(&too_short, password);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), \"Invalid encrypted data\");\n    }\n\n    #[test]\n    fn test_encrypt_empty_plaintext() {\n        let plaintext = b\"\";\n        let password = \"password\";\n\n        // Should be able to encrypt empty data\n        let encrypted = encrypt(plaintext, password).unwrap();\n        let decrypted = decrypt(&encrypted, password).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n\n    #[test]\n    fn test_derive_key_consistency() {\n        let password = \"test_password\";\n\n        // Deriving key multiple times with same password should produce same key\n        let key1 = derive_key_from_password(password);\n        let key2 = derive_key_from_password(password);\n\n        assert_eq!(&*key1, &*key2);\n    }\n}\n","traces":[{"line":19,"address":[16026832],"length":1,"stats":{"Line":0}},{"line":20,"address":[15786089],"length":1,"stats":{"Line":0}},{"line":23,"address":[15786112],"length":1,"stats":{"Line":0}},{"line":24,"address":[15812937],"length":1,"stats":{"Line":0}},{"line":28,"address":[15256617,15255824,15256592],"length":1,"stats":{"Line":1}},{"line":30,"address":[12309471],"length":1,"stats":{"Line":1}},{"line":31,"address":[15255929],"length":1,"stats":{"Line":2}},{"line":34,"address":[12309510],"length":1,"stats":{"Line":3}},{"line":37,"address":[10571387,10571625],"length":1,"stats":{"Line":2}},{"line":39,"address":[15787040,15786649,15787047],"length":1,"stats":{"Line":0}},{"line":42,"address":[12309860,12309751],"length":1,"stats":{"Line":3}},{"line":43,"address":[15813495,15813575],"length":1,"stats":{"Line":3}},{"line":45,"address":[15256465],"length":1,"stats":{"Line":1}},{"line":48,"address":[15788095,15787168,15787998],"length":1,"stats":{"Line":1}},{"line":50,"address":[12310340,12310546],"length":1,"stats":{"Line":2}},{"line":52,"address":[15787429,15788112,15788122],"length":1,"stats":{"Line":3}},{"line":55,"address":[16028344,16028232],"length":1,"stats":{"Line":2}},{"line":56,"address":[15257147,15257615],"length":1,"stats":{"Line":2}},{"line":59,"address":[16028418,16028350],"length":1,"stats":{"Line":3}},{"line":60,"address":[15814437],"length":1,"stats":{"Line":2}},{"line":61,"address":[16028552],"length":1,"stats":{"Line":1}},{"line":64,"address":[16028637],"length":1,"stats":{"Line":2}},{"line":65,"address":[12310920],"length":1,"stats":{"Line":1}},{"line":68,"address":[16028765,16028681],"length":1,"stats":{"Line":3}},{"line":70,"address":[16029063,16029056],"length":1,"stats":{"Line":2}},{"line":73,"address":[16029184],"length":1,"stats":{"Line":1}},{"line":74,"address":[16029226],"length":1,"stats":{"Line":1}},{"line":75,"address":[15258014],"length":1,"stats":{"Line":1}},{"line":76,"address":[10573393],"length":1,"stats":{"Line":1}},{"line":77,"address":[16029310],"length":1,"stats":{"Line":1}},{"line":78,"address":[12311568],"length":1,"stats":{"Line":1}},{"line":79,"address":[12311651],"length":1,"stats":{"Line":1}}],"covered":27,"coverable":32},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","crypto","mod.rs"],"content":"pub mod encryption;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","handler.rs"],"content":"use crate::infrastructure::database::connection_pool::ConnectionPool;\nuse anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, info};\n\n/// イベントコールバックの型エイリアス\ntype EventCallback = Box<dyn Fn(Event) + Send + Sync>;\n\n/// Nostrイベントハンドラー\npub struct EventHandler {\n    event_callbacks: Arc<RwLock<Vec<EventCallback>>>,\n    connection_pool: Option<ConnectionPool>,\n}\n\nimpl EventHandler {\n    /// 新しいEventHandlerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            event_callbacks: Arc::new(RwLock::new(Vec::new())),\n            connection_pool: None,\n        }\n    }\n\n    /// データベースプールを設定\n    pub fn set_connection_pool(&mut self, pool: ConnectionPool) {\n        self.connection_pool = Some(pool);\n    }\n\n    /// イベントを処理\n    pub async fn handle_event(&self, event: Event) -> Result<()> {\n        debug!(\"Handling event: {}\", event.id);\n\n        let callbacks = self.event_callbacks.read().await;\n        for callback in callbacks.iter() {\n            callback(event.clone());\n        }\n\n        // イベントの種類に応じた処理\n        match event.kind {\n            Kind::TextNote => {\n                self.handle_text_note(&event).await?;\n            }\n            Kind::Metadata => {\n                self.handle_metadata(&event).await?;\n            }\n            Kind::ContactList => {\n                self.handle_contact_list(&event).await?;\n            }\n            Kind::Reaction => {\n                self.handle_reaction(&event).await?;\n            }\n            _ => {\n                debug!(\"Unhandled event kind: {:?}\", event.kind);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// テキストノートイベントを処理\n    async fn handle_text_note(&self, event: &Event) -> Result<()> {\n        info!(\n            \"Received text note from {}: {}\",\n            event.pubkey, event.content\n        );\n\n        // データベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let event_id = event.id.to_string();\n            let public_key = event.pubkey.to_string();\n            let created_at = event.created_at.as_u64() as i64;\n            let kind = event.kind.as_u16() as i64;\n            let content = event.content.clone();\n            let tags = serde_json::to_string(&event.tags)?;\n            let signature = event.sig.to_string();\n            let saved_at = chrono::Utc::now().timestamp();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO events (event_id, public_key, created_at, kind, content, tags, sig, saved_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(event_id) DO NOTHING\n                \"#,\n                event_id,\n                public_key,\n                created_at,\n                kind,\n                content,\n                tags,\n                signature,\n                saved_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Text note saved to database: {}\", event.id);\n\n            // イベントのタグからトピックIDを抽出し、マッピングを保存（冪等）\n            // 対象: Hashtag(\"t\") と Custom(\"topic\")\n            for tag in event.tags.iter() {\n                if let Some(nostr_sdk::TagStandard::Hashtag(topic)) = tag.as_standardized() {\n                    let _ = sqlx::query(\n                        r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                    )\n                    .bind(event.id.to_string())\n                    .bind(topic)\n                    .bind(chrono::Utc::now().timestamp_millis())\n                    .execute(pool.get_pool())\n                    .await;\n                }\n                // カスタムタグ 'topic'\n                if tag.kind().to_string() == \"topic\" {\n                    if let Some(content) = tag.content() {\n                        let _ = sqlx::query(\n                            r#\"INSERT OR IGNORE INTO event_topics (event_id, topic_id, created_at) VALUES (?1, ?2, ?3)\"#,\n                        )\n                        .bind(event.id.to_string())\n                        .bind(content)\n                        .bind(chrono::Utc::now().timestamp_millis())\n                        .execute(pool.get_pool())\n                        .await;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// メタデータイベントを処理\n    async fn handle_metadata(&self, event: &Event) -> Result<()> {\n        info!(\"Received metadata update from {}\", event.pubkey);\n\n        // メタデータをパースしてデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            let metadata: serde_json::Value = serde_json::from_str(&event.content)?;\n            let display_name = metadata\n                .get(\"name\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let about = metadata\n                .get(\"about\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let picture_url = metadata\n                .get(\"picture\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let banner_url = metadata\n                .get(\"banner\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let nip05 = metadata\n                .get(\"nip05\")\n                .and_then(|v| v.as_str())\n                .map(String::from);\n            let created_at = event.created_at.as_u64() as i64;\n            let updated_at = chrono::Utc::now().timestamp();\n            let public_key = event.pubkey.to_string();\n\n            sqlx::query!(\n                r#\"\n                INSERT INTO profiles (public_key, display_name, about, picture_url, banner_url, nip05, created_at, updated_at)\n                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)\n                ON CONFLICT(public_key) DO UPDATE SET\n                    display_name = excluded.display_name,\n                    about = excluded.about,\n                    picture_url = excluded.picture_url,\n                    banner_url = excluded.banner_url,\n                    nip05 = excluded.nip05,\n                    updated_at = excluded.updated_at\n                \"#,\n                public_key,\n                display_name,\n                about,\n                picture_url,\n                banner_url,\n                nip05,\n                created_at,\n                updated_at\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            debug!(\"Profile metadata saved to database for: {}\", event.pubkey);\n        }\n\n        Ok(())\n    }\n\n    /// コンタクトリストイベントを処理\n    async fn handle_contact_list(&self, event: &Event) -> Result<()> {\n        info!(\"Received contact list from {}\", event.pubkey);\n\n        // フォロー関係をデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            // 既存のフォロー関係を削除\n            let follower_pubkey = event.pubkey.to_string();\n            sqlx::query!(\n                \"DELETE FROM follows WHERE follower_pubkey = ?1\",\n                follower_pubkey\n            )\n            .execute(pool.get_pool())\n            .await?;\n\n            // 新しいフォロー関係を保存\n            let follower_pubkey_str = event.pubkey.to_string();\n            for tag in event.tags.iter() {\n                if let Some(nostr_sdk::TagStandard::PublicKey {\n                    public_key: pubkey, ..\n                }) = tag.as_standardized()\n                {\n                    let followed_pubkey = pubkey.to_hex();\n                    let created_at = chrono::Utc::now().timestamp();\n\n                    sqlx::query!(\n                        r#\"\n                        INSERT INTO follows (follower_pubkey, followed_pubkey, created_at)\n                        VALUES (?1, ?2, ?3)\n                        \"#,\n                        follower_pubkey_str,\n                        followed_pubkey,\n                        created_at\n                    )\n                    .execute(pool.get_pool())\n                    .await?;\n                }\n            }\n\n            debug!(\"Contact list saved to database for: {}\", event.pubkey);\n        }\n\n        Ok(())\n    }\n\n    /// リアクションイベントを処理\n    async fn handle_reaction(&self, event: &Event) -> Result<()> {\n        info!(\"Received reaction from {}: {}\", event.pubkey, event.content);\n\n        // リアクションをデータベースに保存\n        if let Some(pool) = &self.connection_pool {\n            // リアクション対象のイベントIDを取得\n            let mut target_event_id: Option<String> = None;\n            for tag in event.tags.iter() {\n                if let Some(nostr_sdk::TagStandard::Event { event_id, .. }) = tag.as_standardized()\n                {\n                    target_event_id = Some(event_id.to_hex());\n                    break;\n                }\n            }\n\n            if let Some(target_id) = target_event_id {\n                let reactor_pubkey = event.pubkey.to_string();\n                let reaction_content = event.content.clone();\n                let created_at = event.created_at.as_u64() as i64;\n\n                sqlx::query!(\n                    r#\"\n                    INSERT INTO reactions (reactor_pubkey, target_event_id, reaction_content, created_at)\n                    VALUES (?1, ?2, ?3, ?4)\n                    ON CONFLICT(reactor_pubkey, target_event_id) DO UPDATE SET\n                        reaction_content = excluded.reaction_content,\n                        created_at = excluded.created_at\n                    \"#,\n                    reactor_pubkey,\n                    target_id,\n                    reaction_content,\n                    created_at\n                )\n                .execute(pool.get_pool())\n                .await?;\n\n                debug!(\n                    \"Reaction saved to database: {} -> {}\",\n                    event.pubkey, target_id\n                );\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_event_handler_creation() {\n        let handler = EventHandler::new();\n        assert!(handler.event_callbacks.read().await.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_handle_text_note() {\n        let handler = EventHandler::new();\n        let keys = Keys::generate();\n\n        let event = EventBuilder::text_note(\"Test text note\")\n            .sign_with_keys(&keys)\n            .unwrap();\n\n        // テキストノートの処理が正常に完了することを確認\n        assert!(handler.handle_event(event).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_handle_metadata() {\n        let handler = EventHandler::new();\n        let keys = Keys::generate();\n\n        let metadata = Metadata::new().name(\"Test User\").about(\"Test about\");\n\n        let event = EventBuilder::metadata(&metadata)\n            .sign_with_keys(&keys)\n            .unwrap();\n\n        // メタデータイベントの処理が正常に完了することを確認\n        assert!(handler.handle_event(event).await.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_handle_reaction() {\n        let handler = EventHandler::new();\n        let keys = Keys::generate();\n        let _target_event_id = EventId::from_slice(&[1; 32]).unwrap();\n\n        // リアクション用の疑似イベントを作成\n        let target_event = EventBuilder::text_note(\"dummy\")\n            .sign_with_keys(&keys)\n            .unwrap();\n        let event = EventBuilder::reaction(&target_event, \"+\")\n            .sign_with_keys(&keys)\n            .unwrap();\n\n        // リアクションイベントの処理が正常に完了することを確認\n        assert!(handler.handle_event(event).await.is_ok());\n    }\n}\n","traces":[{"line":19,"address":[13367232],"length":1,"stats":{"Line":1}},{"line":21,"address":[13924372],"length":1,"stats":{"Line":1}},{"line":27,"address":[13897728,13897781],"length":1,"stats":{"Line":0}},{"line":28,"address":[13367347,13367412],"length":1,"stats":{"Line":0}},{"line":32,"address":[13521151,13515427,13515668,13515392,13515472,13515518,13517895,13522549],"length":1,"stats":{"Line":4}},{"line":33,"address":[13898085,13962521,13898301,13898842,13962678],"length":1,"stats":{"Line":3}},{"line":35,"address":[13924882,13925534,13927164,13927019],"length":1,"stats":{"Line":2}},{"line":36,"address":[17271893,17271530,17271623],"length":1,"stats":{"Line":2}},{"line":37,"address":[13901101,13903750],"length":1,"stats":{"Line":0}},{"line":41,"address":[17271840],"length":1,"stats":{"Line":1}},{"line":42,"address":[13373703],"length":1,"stats":{"Line":1}},{"line":43,"address":[14250492],"length":1,"stats":{"Line":2}},{"line":45,"address":[13521816],"length":1,"stats":{"Line":1}},{"line":46,"address":[13928077,13930931,13927901,13931222,13924924],"length":1,"stats":{"Line":2}},{"line":48,"address":[13374429],"length":1,"stats":{"Line":0}},{"line":49,"address":[14145666,14142367,14145375,14139041,14142085],"length":1,"stats":{"Line":0}},{"line":51,"address":[17275993],"length":1,"stats":{"Line":1}},{"line":52,"address":[10906490],"length":1,"stats":{"Line":2}},{"line":55,"address":[13370734,13371336,13432649,13371881,13432806],"length":1,"stats":{"Line":0}},{"line":59,"address":[14143065],"length":1,"stats":{"Line":1}},{"line":63,"address":[13932526,13937175,13932160,13932192,13937248,13932238,13932173,13932441],"length":1,"stats":{"Line":4}},{"line":64,"address":[13990470,13933144,13932583,13932410,13990313],"length":1,"stats":{"Line":3}},{"line":70,"address":[14147184,14148785],"length":1,"stats":{"Line":1}},{"line":71,"address":[13525232],"length":1,"stats":{"Line":0}},{"line":72,"address":[14148845],"length":1,"stats":{"Line":0}},{"line":73,"address":[13908179,13908092],"length":1,"stats":{"Line":0}},{"line":74,"address":[13908191],"length":1,"stats":{"Line":0}},{"line":75,"address":[17279064],"length":1,"stats":{"Line":0}},{"line":76,"address":[17279095,17281294,17279174,17279340],"length":1,"stats":{"Line":0}},{"line":77,"address":[13525746],"length":1,"stats":{"Line":0}},{"line":78,"address":[13525872,13525939],"length":1,"stats":{"Line":0}},{"line":80,"address":[13939828,13935782,13937696,13937526,13935488,13937401,13937184,13937073,13937003],"length":1,"stats":{"Line":0}},{"line":95,"address":[14151239,14151019,14151134,14149835],"length":1,"stats":{"Line":0}},{"line":96,"address":[13937046,13937280,13932471,13937648,13937449,13937106],"length":1,"stats":{"Line":0}},{"line":98,"address":[13380484,13381146,13435654,13380604,13435497],"length":1,"stats":{"Line":0}},{"line":102,"address":[17283813,17284464,17282317,17284527],"length":1,"stats":{"Line":0}},{"line":103,"address":[13530860,13531100,13530987],"length":1,"stats":{"Line":0}},{"line":107,"address":[14154862,14155822,14154905,14155026],"length":1,"stats":{"Line":0}},{"line":108,"address":[17285088],"length":1,"stats":{"Line":0}},{"line":109,"address":[13941154,13941697,13941016,13940965],"length":1,"stats":{"Line":0}},{"line":110,"address":[17285250,17285053,17285745,17285359],"length":1,"stats":{"Line":0}},{"line":111,"address":[10321188],"length":1,"stats":{"Line":0}},{"line":114,"address":[17285828,17284757],"length":1,"stats":{"Line":0}},{"line":115,"address":[13532325],"length":1,"stats":{"Line":0}},{"line":119,"address":[13915403,13915572,13916053,13915446],"length":1,"stats":{"Line":0}},{"line":120,"address":[13385250],"length":1,"stats":{"Line":0}},{"line":121,"address":[13915796,13915607,13915658,13916024],"length":1,"stats":{"Line":0}},{"line":122,"address":[13385592,13385519,13385215,13385412],"length":1,"stats":{"Line":0}},{"line":123,"address":[13385587,13382899,13375377,13385527,13383144],"length":1,"stats":{"Line":0}},{"line":129,"address":[13934732],"length":1,"stats":{"Line":1}},{"line":133,"address":[13533215,13538398,13533152,13533410,13533367,13533184,13533165,13538512],"length":1,"stats":{"Line":4}},{"line":134,"address":[14157227,14207414,14207257,14157788,14157099],"length":1,"stats":{"Line":3}},{"line":137,"address":[13535442,13533947],"length":1,"stats":{"Line":1}},{"line":138,"address":[17292309,17289223,17289473,17289295],"length":1,"stats":{"Line":0}},{"line":139,"address":[14159446,14159590],"length":1,"stats":{"Line":0}},{"line":141,"address":[14165104,14165113],"length":1,"stats":{"Line":0}},{"line":143,"address":[13388523,13388424],"length":1,"stats":{"Line":0}},{"line":145,"address":[17295120,17295129],"length":1,"stats":{"Line":0}},{"line":147,"address":[14159821,14159920],"length":1,"stats":{"Line":0}},{"line":149,"address":[13393936,13393945],"length":1,"stats":{"Line":0}},{"line":151,"address":[13536181,13536280],"length":1,"stats":{"Line":0}},{"line":153,"address":[13924377,13924368],"length":1,"stats":{"Line":0}},{"line":155,"address":[17290135,17290234],"length":1,"stats":{"Line":0}},{"line":157,"address":[14165232,14165241],"length":1,"stats":{"Line":0}},{"line":159,"address":[13919487,13919580],"length":1,"stats":{"Line":0}},{"line":160,"address":[13946331],"length":1,"stats":{"Line":0}},{"line":161,"address":[13946418],"length":1,"stats":{"Line":0}},{"line":163,"address":[13393682,13391616,13391321,13391446,13390952,13389614,13390831,13391063,13389316],"length":1,"stats":{"Line":0}},{"line":184,"address":[13948158,13946707,13948002,13947899],"length":1,"stats":{"Line":0}},{"line":185,"address":[13391369,13385925,13390985,13391200,13391568,13390874],"length":1,"stats":{"Line":0}},{"line":187,"address":[13995638,13949329,13948796,13948676,13995481],"length":1,"stats":{"Line":0}},{"line":190,"address":[17289262],"length":1,"stats":{"Line":1}},{"line":194,"address":[13394260,13397166,13394045,13394324,13397197,13394064,13394032,13394095],"length":1,"stats":{"Line":0}},{"line":195,"address":[13541674,13542210,13680809,13541528,13680943],"length":1,"stats":{"Line":0}},{"line":198,"address":[17297598,17296099],"length":1,"stats":{"Line":0}},{"line":200,"address":[13953530],"length":1,"stats":{"Line":0}},{"line":201,"address":[13544210,13544418,13544320,13543803,13544582,13544870,13543709,13544697,13545106],"length":1,"stats":{"Line":0}},{"line":205,"address":[13953629,13954011,13954126,13954273],"length":1,"stats":{"Line":0}},{"line":206,"address":[10925935],"length":1,"stats":{"Line":0}},{"line":209,"address":[14168792],"length":1,"stats":{"Line":0}},{"line":210,"address":[13398516,13397775,13398451,13397676],"length":1,"stats":{"Line":0}},{"line":211,"address":[13400637,13400596,13398532],"length":1,"stats":{"Line":0}},{"line":212,"address":[17301900],"length":1,"stats":{"Line":0}},{"line":215,"address":[14171936],"length":1,"stats":{"Line":0}},{"line":216,"address":[17301939],"length":1,"stats":{"Line":0}},{"line":218,"address":[14172166,14169470,14172827,14169300,14169638,14172897,14172757,14172028],"length":1,"stats":{"Line":0}},{"line":227,"address":[13931294,13931853,13932033,13931960],"length":1,"stats":{"Line":0}},{"line":228,"address":[10332782],"length":1,"stats":{"Line":0}},{"line":232,"address":[14211686,14211529,14169789,14170319,14169720],"length":1,"stats":{"Line":0}},{"line":235,"address":[13926825],"length":1,"stats":{"Line":0}},{"line":239,"address":[17303272,17302976,17307653,17303229,17302989,17303024,17307622,17303055],"length":1,"stats":{"Line":4}},{"line":240,"address":[14212214,14173345,14212057,14173217,14173906],"length":1,"stats":{"Line":3}},{"line":243,"address":[13939363,13933018,13934619],"length":1,"stats":{"Line":1}},{"line":245,"address":[13961363],"length":1,"stats":{"Line":0}},{"line":246,"address":[13404264,13404402,13404581],"length":1,"stats":{"Line":0}},{"line":247,"address":[13404597],"length":1,"stats":{"Line":0}},{"line":249,"address":[13935136],"length":1,"stats":{"Line":0}},{"line":254,"address":[13552071,13551656],"length":1,"stats":{"Line":0}},{"line":255,"address":[13404990],"length":1,"stats":{"Line":0}},{"line":256,"address":[14176352],"length":1,"stats":{"Line":0}},{"line":257,"address":[13552325,13552415],"length":1,"stats":{"Line":0}},{"line":259,"address":[13552614,13553946,13556150,13553347,13553662,13553502,13552430,13553409,13553776],"length":1,"stats":{"Line":0}},{"line":272,"address":[14177515,14177412,14176680,14177606],"length":1,"stats":{"Line":0}},{"line":273,"address":[13553402,13549195,13553435,13553556,13553710,13553898],"length":1,"stats":{"Line":0}},{"line":275,"address":[13937848,13972649,13972806,13937195,13937315],"length":1,"stats":{"Line":0}},{"line":282,"address":[13551422],"length":1,"stats":{"Line":1}}],"covered":26,"coverable":106},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","core.rs"],"content":"use crate::application::ports::key_manager::KeyManager;\nuse crate::application::shared::default_topics::DefaultTopicsRegistry;\nuse crate::application::shared::nostr::EventPublisher;\nuse crate::infrastructure::database::{\n    EventRepository as InfraEventRepository, connection_pool::ConnectionPool,\n};\nuse crate::infrastructure::p2p::GossipService;\nuse crate::modules::event::handler::EventHandler;\nuse crate::modules::event::nostr_client::NostrClientManager;\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrイベントマネージャー - イベント処理の中心的な管理者\npub struct EventManager {\n    pub(crate) client_manager: Arc<RwLock<NostrClientManager>>,\n    pub(crate) event_handler: Arc<EventHandler>,\n    pub(crate) event_publisher: Arc<RwLock<EventPublisher>>,\n    pub(crate) default_topics: Arc<DefaultTopicsRegistry>,\n    is_initialized: Arc<RwLock<bool>>,\n    /// P2P配信用のGossipService（任意）\n    pub(crate) gossip_service: Arc<RwLock<Option<Arc<dyn GossipService>>>>,\n    /// 参照トピック解決用のEventRepository（任意）\n    pub(crate) event_repository: Arc<RwLock<Option<Arc<dyn InfraEventRepository>>>>,\n}\n\nimpl EventManager {\n    /// 新しいEventManagerインスタンスを作成\n    #[allow(dead_code)]\n    pub fn new() -> Self {\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(EventHandler::new()),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\"public\".into()])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_repository: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 新しいEventManagerインスタンスをConnectionPoolと共に作成\n    pub fn new_with_connection_pool(pool: ConnectionPool) -> Self {\n        let mut event_handler = EventHandler::new();\n        event_handler.set_connection_pool(pool);\n\n        Self {\n            client_manager: Arc::new(RwLock::new(NostrClientManager::new())),\n            event_handler: Arc::new(event_handler),\n            event_publisher: Arc::new(RwLock::new(EventPublisher::new())),\n            default_topics: Arc::new(DefaultTopicsRegistry::with_topics([\"public\".into()])),\n            is_initialized: Arc::new(RwLock::new(false)),\n            gossip_service: Arc::new(RwLock::new(None)),\n            event_repository: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// 既定の配信先トピックIDを設定\n    pub async fn set_default_p2p_topic_id(&self, topic_id: impl Into<String>) {\n        self.default_topics\n            .replace_with_single(topic_id.into())\n            .await;\n    }\n\n    /// 既定配信先トピックを一括設定（複数）\n    pub async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        self.default_topics.replace_all(topics).await;\n    }\n\n    /// 既定配信先トピックを追加\n    pub async fn add_default_p2p_topic(&self, topic_id: impl Into<String>) {\n        self.default_topics.add(topic_id.into()).await;\n    }\n\n    /// 既定配信先トピックを削除\n    pub async fn remove_default_p2p_topic(&self, topic_id: &str) {\n        self.default_topics.remove(topic_id).await;\n    }\n\n    /// 既定配信先トピック一覧を取得\n    pub async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.default_topics.list().await\n    }\n\n    /// KeyManagerからの秘密鍵でマネージャーを初期化\n    pub async fn initialize_with_key_manager(\n        &self,\n        key_manager: &(dyn KeyManager + Send + Sync),\n    ) -> Result<()> {\n        let keypair = key_manager\n            .current_keypair()\n            .await\n            .map_err(|e| anyhow!(\"Failed to load current keypair: {e}\"))?;\n        let secret_key = SecretKey::from_bech32(&keypair.nsec)\n            .map_err(|e| anyhow!(\"Invalid secret key: {e}\"))?;\n        let keys = Keys::new(secret_key);\n\n        // クライアントマネージャーを初期化\n        let mut client_manager = self.client_manager.write().await;\n        client_manager.init_with_keys(keys.secret_key()).await?;\n\n        // パブリッシャーに鍵を設定\n        let mut publisher = self.event_publisher.write().await;\n        publisher.set_keys(keys);\n\n        *self.is_initialized.write().await = true;\n\n        info!(\"EventManager initialized successfully\");\n        Ok(())\n    }\n\n    /// 特定のトピックをサブスクライブ\n    pub async fn subscribe_to_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().hashtag(topic_id).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to topic: {}\", topic_id);\n        Ok(())\n    }\n\n    /// ユーザーの投稿をサブスクライブ\n    pub async fn subscribe_to_user(\n        &self,\n        pubkey: PublicKey,\n        since: Option<Timestamp>,\n    ) -> Result<()> {\n        self.ensure_initialized().await?;\n\n        let mut filter = Filter::new().author(pubkey).kind(Kind::TextNote);\n        if let Some(since_ts) = since {\n            filter = filter.since(since_ts);\n        }\n\n        let client_manager = self.client_manager.read().await;\n        client_manager.subscribe(vec![filter]).await?;\n\n        info!(\"Subscribed to user: {}\", pubkey);\n        Ok(())\n    }\n\n    /// 初期化状態を確認\n    pub(crate) async fn ensure_initialized(&self) -> Result<()> {\n        if !*self.is_initialized.read().await {\n            Err(anyhow!(\"EventManager not initialized\"))\n        } else {\n            Ok(())\n        }\n    }\n\n    /// 公開鍵を取得\n    pub async fn get_public_key(&self) -> Option<PublicKey> {\n        let publisher = self.event_publisher.read().await;\n        publisher.get_public_key()\n    }\n\n    /// 切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_manager = self.client_manager.read().await;\n        client_manager.disconnect().await?;\n        *self.is_initialized.write().await = false;\n        Ok(())\n    }\n}\n\nimpl Default for EventManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n","traces":[{"line":32,"address":[15259198,15258240],"length":1,"stats":{"Line":1}},{"line":34,"address":[16029489],"length":1,"stats":{"Line":1}},{"line":35,"address":[16029561,16029633],"length":1,"stats":{"Line":2}},{"line":36,"address":[10573790,10573850],"length":1,"stats":{"Line":2}},{"line":37,"address":[10573921,10574003],"length":1,"stats":{"Line":2}},{"line":38,"address":[15789139,15789211],"length":1,"stats":{"Line":2}},{"line":39,"address":[16030178,16030080],"length":1,"stats":{"Line":2}},{"line":40,"address":[15258983,15259081],"length":1,"stats":{"Line":2}},{"line":45,"address":[15817544,15817516,15816368],"length":1,"stats":{"Line":0}},{"line":46,"address":[10574614,10574710],"length":1,"stats":{"Line":0}},{"line":47,"address":[10574720],"length":1,"stats":{"Line":0}},{"line":50,"address":[15789835],"length":1,"stats":{"Line":0}},{"line":51,"address":[15816652,15816732],"length":1,"stats":{"Line":0}},{"line":52,"address":[15816740,15816800],"length":1,"stats":{"Line":0}},{"line":53,"address":[15816871,15816953],"length":1,"stats":{"Line":0}},{"line":54,"address":[15790385,15790313],"length":1,"stats":{"Line":0}},{"line":55,"address":[16031352,16031254],"length":1,"stats":{"Line":0}},{"line":56,"address":[10575615,10575517],"length":1,"stats":{"Line":0}},{"line":61,"address":[15260521,15260683,15260496,15260448,15261135,15260466,15261156,15260913],"length":1,"stats":{"Line":0}},{"line":62,"address":[15817799,15818008,15817957],"length":1,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[15260710,15260848,15260945,15260892],"length":1,"stats":{"Line":0}},{"line":68,"address":[10577232,10576592,10576753,10576544,10576552,10576617,10577211,10576981],"length":1,"stats":{"Line":4}},{"line":69,"address":[11194308],"length":1,"stats":{"Line":2}},{"line":73,"address":[18341136,18341537,18341319,18341088,18341106,18341161,18341747,18341768],"length":1,"stats":{"Line":4}},{"line":74,"address":[18341569,18341303,18341346,18341414],"length":1,"stats":{"Line":2}},{"line":78,"address":[10577298,10577481,10577328,10577353,10577675,10577893,10577280,10577521],"length":1,"stats":{"Line":4}},{"line":79,"address":[15262101,15262347,15262223,15262148],"length":1,"stats":{"Line":2}},{"line":83,"address":[16033950,16033784,16034090,16033792,16033776,16033827,16034387,16033913],"length":1,"stats":{"Line":4}},{"line":84,"address":[10957252],"length":1,"stats":{"Line":2}},{"line":88,"address":[15263168],"length":1,"stats":{"Line":1}},{"line":92,"address":[15263671,15263408,15264053,15264372,15265111,15263880],"length":1,"stats":{"Line":4}},{"line":94,"address":[16034991,16034860,16034697,16035208,16034925],"length":1,"stats":{"Line":3}},{"line":95,"address":[15799631,15794756,15799616],"length":1,"stats":{"Line":0}},{"line":96,"address":[15264743,15265061,15264476,15264321],"length":1,"stats":{"Line":2}},{"line":97,"address":[15269439,15264727,15269424],"length":1,"stats":{"Line":0}},{"line":98,"address":[15264650,15264835],"length":1,"stats":{"Line":2}},{"line":101,"address":[10580210,10580555,10578846,10580297],"length":1,"stats":{"Line":4}},{"line":102,"address":[16036686,16037443,16036765,16037269,16034739],"length":1,"stats":{"Line":4}},{"line":105,"address":[18345793,18343349,18345708,18345970],"length":1,"stats":{"Line":4}},{"line":106,"address":[15823771,15823686],"length":1,"stats":{"Line":4}},{"line":108,"address":[18346380,18343370],"length":1,"stats":{"Line":2}},{"line":110,"address":[16039633,16038870,16095981,16039566,16039048,16040008,16038467,16038715,16095847,16039300],"length":1,"stats":{"Line":4}},{"line":111,"address":[10583128],"length":1,"stats":{"Line":2}},{"line":115,"address":[18349277,18349529,18349656,18349444,18349180,18349152,18350615,18349216],"length":1,"stats":{"Line":4}},{"line":116,"address":[10375201],"length":1,"stats":{"Line":4}},{"line":118,"address":[15827716,15827625],"length":1,"stats":{"Line":0}},{"line":119,"address":[15801091,15801343],"length":1,"stats":{"Line":0}},{"line":120,"address":[16042130,16041966],"length":1,"stats":{"Line":0}},{"line":123,"address":[15827115,15828288,15828089,15827958],"length":1,"stats":{"Line":0}},{"line":124,"address":[10587534,10589527,10586872,10585360,10586783],"length":1,"stats":{"Line":0}},{"line":126,"address":[10587954,10588381,10588708,10587506,10640621,10588641,10640487,10587586,10589138,10588129,10587799],"length":1,"stats":{"Line":0}},{"line":127,"address":[15829860],"length":1,"stats":{"Line":0}},{"line":131,"address":[18353584],"length":1,"stats":{"Line":0}},{"line":136,"address":[18353928,18354049,18354151,18354464,18355060,18353868],"length":1,"stats":{"Line":0}},{"line":138,"address":[10590513,10590607],"length":1,"stats":{"Line":0}},{"line":139,"address":[15275381,15275642],"length":1,"stats":{"Line":0}},{"line":140,"address":[16046656,16046826],"length":1,"stats":{"Line":0}},{"line":143,"address":[18987435],"length":1,"stats":{"Line":0}},{"line":144,"address":[15805046,15806543,15806632,15807312,15809308],"length":1,"stats":{"Line":0}},{"line":146,"address":[15278019,15277177,15276964,15277332,15325773,15325639,15276884,15277507,15278516,15277759,15278086],"length":1,"stats":{"Line":0}},{"line":147,"address":[16048694],"length":1,"stats":{"Line":0}},{"line":151,"address":[15809400,15809433,15809519,15810213,15809697,15809392,15809556,15809408],"length":1,"stats":{"Line":4}},{"line":152,"address":[10936260],"length":1,"stats":{"Line":3}},{"line":153,"address":[18358776],"length":1,"stats":{"Line":1}},{"line":155,"address":[10595159],"length":1,"stats":{"Line":1}},{"line":160,"address":[16051371,16051193,16051776,16051064,16051230,16051056,16051072,16051107],"length":1,"stats":{"Line":6}},{"line":161,"address":[18957236],"length":1,"stats":{"Line":4}},{"line":162,"address":[10595757,10595824],"length":1,"stats":{"Line":4}},{"line":166,"address":[16051800,16052637,16051836,16051792,16052008,16051808,16052164,16051932],"length":1,"stats":{"Line":4}},{"line":167,"address":[15837863,15837808,15837964,15838100],"length":1,"stats":{"Line":2}},{"line":168,"address":[10890325],"length":1,"stats":{"Line":2}},{"line":169,"address":[10597124,10597048,10596123,10597331],"length":1,"stats":{"Line":2}},{"line":170,"address":[10597668],"length":1,"stats":{"Line":1}},{"line":175,"address":[18361312],"length":1,"stats":{"Line":0}},{"line":176,"address":[18361320],"length":1,"stats":{"Line":0}}],"covered":42,"coverable":76},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","mod.rs"],"content":"mod core;\nmod p2p;\nmod publishing;\n\n#[cfg(test)]\nmod tests;\n\npub use core::EventManager;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","p2p.rs"],"content":"use std::collections::HashSet;\nuse std::sync::Arc;\n\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse tracing::error;\n\nuse super::EventManager;\nuse crate::application::shared::mappers::nostr_event_to_domain_event;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::database::EventRepository as InfraEventRepository;\nuse crate::infrastructure::p2p::GossipService;\n\nimpl EventManager {\n    /// GossipServiceを接続（P2P配信用）。未設定でも動作は継続。\n    pub async fn set_gossip_service(&self, gossip: Arc<dyn GossipService>) {\n        let mut gs = self.gossip_service.write().await;\n        *gs = Some(gossip);\n    }\n\n    /// EventRepositoryを接続（参照トピック解決用）。未設定でも動作は継続。\n    pub async fn set_event_repository(&self, repo: Arc<dyn InfraEventRepository>) {\n        let mut r = self.event_repository.write().await;\n        *r = Some(repo);\n    }\n\n    /// P2Pネットワークから受信したNostrイベントを処理\n    pub async fn handle_p2p_event(&self, event: Event) -> Result<()> {\n        if let Err(e) = self.event_handler.handle_event(event.clone()).await {\n            error!(\"Error handling P2P event: {}\", e);\n            return Err(e);\n        }\n\n        Ok(())\n    }\n\n    /// 複数トピックへ冪等Join + 重複排除つきでブロードキャスト\n    pub(crate) async fn broadcast_to_topics(\n        &self,\n        gossip: &Arc<dyn GossipService>,\n        topics: &[String],\n        nostr_event: &Event,\n    ) -> Result<()> {\n        let mut uniq: HashSet<String> = HashSet::new();\n        for t in topics {\n            if !t.is_empty() {\n                uniq.insert(t.clone());\n            }\n        }\n        if uniq.is_empty() {\n            return Ok(());\n        }\n\n        let domain_event =\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\n        for topic in uniq.into_iter() {\n            let _ = gossip.join_topic(&topic, vec![]).await;\n            if let Err(e) = gossip.broadcast(&topic, &domain_event).await {\n                error!(\"Failed to broadcast to topic {}: {}\", topic, e);\n            }\n        }\n        Ok(())\n    }\n\n    pub(crate) async fn broadcast_to_topic(\n        &self,\n        gossip: &Arc<dyn GossipService>,\n        topic_id: &str,\n        nostr_event: &Event,\n    ) -> Result<()> {\n        let domain_event =\n            nostr_event_to_domain_event(nostr_event).map_err(|err| anyhow!(err.to_string()))?;\n        let _ = gossip.join_topic(topic_id, vec![]).await;\n        gossip\n            .broadcast(topic_id, &domain_event)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"{}\", e))?;\n        Ok(())\n    }\n\n    pub(crate) async fn resolve_topics_for_referenced_event(\n        &self,\n        event_id: &str,\n    ) -> Option<Vec<String>> {\n        if let Some(repo) = self.event_repository.read().await.as_ref().cloned() {\n            match repo.get_event_topics(event_id).await {\n                Ok(v) if !v.is_empty() => return Some(v),\n                _ => {}\n            }\n        }\n        None\n    }\n\n    pub(crate) async fn default_topics_with_user_topic(&self) -> Vec<String> {\n        let mut topics = self.default_topics.snapshot().await;\n        if let Some(pk) = self.get_public_key().await {\n            topics.insert(user_topic_id(&pk.to_string()));\n        }\n        topics.into_iter().collect()\n    }\n}\n","traces":[{"line":16,"address":[15812857,15812784,15812802,15812832,15813174,15813770,15813003,15813749],"length":1,"stats":{"Line":4}},{"line":17,"address":[11285749],"length":1,"stats":{"Line":2}},{"line":18,"address":[14105497,14105806,14105775],"length":1,"stats":{"Line":1}},{"line":22,"address":[15840779,15840608,15840578,15840633,15840950,15841546,15841525,15840560],"length":1,"stats":{"Line":0}},{"line":23,"address":[11288901],"length":1,"stats":{"Line":0}},{"line":24,"address":[15284053,15284370,15284343],"length":1,"stats":{"Line":0}},{"line":28,"address":[10602686,10599935,10599824,10600094,10600347,10602803,10599904,10599859],"length":1,"stats":{"Line":4}},{"line":29,"address":[14413441],"length":1,"stats":{"Line":2}},{"line":30,"address":[15844100,15842438,15843341,15842752,15843607,15883421,15842539,15842907,15883287,15843089,15843674],"length":1,"stats":{"Line":0}},{"line":31,"address":[10601261],"length":1,"stats":{"Line":0}},{"line":34,"address":[15287452],"length":1,"stats":{"Line":1}},{"line":38,"address":[15844640],"length":1,"stats":{"Line":1}},{"line":44,"address":[15818219],"length":1,"stats":{"Line":1}},{"line":45,"address":[14110082,14110188,14110306],"length":1,"stats":{"Line":3}},{"line":46,"address":[14110952,14110330],"length":1,"stats":{"Line":2}},{"line":47,"address":[15846049],"length":1,"stats":{"Line":1}},{"line":50,"address":[16059416,16059494],"length":1,"stats":{"Line":2}},{"line":51,"address":[14110383],"length":1,"stats":{"Line":0}},{"line":54,"address":[15288586,15292672,15288312,15288775,15288276,15292687],"length":1,"stats":{"Line":2}},{"line":56,"address":[14110763,14113661,14110580,14113718],"length":1,"stats":{"Line":4}},{"line":57,"address":[10607179,10607311,10603235,10604376],"length":1,"stats":{"Line":3}},{"line":58,"address":[10529428],"length":1,"stats":{"Line":3}},{"line":59,"address":[15289918,15290077,15326663,15290722,15291222,15290329,15326797,15290643,15289550,15289763,15289449],"length":1,"stats":{"Line":0}},{"line":62,"address":[16063093],"length":1,"stats":{"Line":1}},{"line":65,"address":[15850096],"length":1,"stats":{"Line":0}},{"line":71,"address":[10608692,10610255,10608916,10609249,10608559,10610240],"length":1,"stats":{"Line":0}},{"line":73,"address":[11285508],"length":1,"stats":{"Line":0}},{"line":74,"address":[15851523,15851464,15851944,15851694,15851803,15851401],"length":1,"stats":{"Line":0}},{"line":75,"address":[15851444],"length":1,"stats":{"Line":0}},{"line":76,"address":[15851726,15851585,15851545,15850405,15851492],"length":1,"stats":{"Line":0}},{"line":77,"address":[14116896,14116532,14116919],"length":1,"stats":{"Line":0}},{"line":78,"address":[15825154],"length":1,"stats":{"Line":0}},{"line":81,"address":[16066624],"length":1,"stats":{"Line":0}},{"line":85,"address":[14117321,14117272,14117418,14117852,14117534],"length":1,"stats":{"Line":0}},{"line":86,"address":[16067695,16066898,16067869,16067578],"length":1,"stats":{"Line":0}},{"line":87,"address":[15827305,15827406],"length":1,"stats":{"Line":0}},{"line":91,"address":[16067837],"length":1,"stats":{"Line":0}},{"line":94,"address":[15827795,15827760,15828104,15827728,15827736,15828548,15827896,15827963],"length":1,"stats":{"Line":0}},{"line":95,"address":[19117631],"length":1,"stats":{"Line":0}},{"line":96,"address":[11088930],"length":1,"stats":{"Line":0}},{"line":97,"address":[16069647,16069771],"length":1,"stats":{"Line":0}},{"line":99,"address":[14120167,14119936],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":42},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","publishing.rs"],"content":"use std::collections::HashSet;\n\nuse anyhow::{Result, anyhow};\nuse nostr_sdk::prelude::*;\nuse tracing::error;\n\nuse super::EventManager;\n\nimpl EventManager {\n    /// テキストノートを投稿\n    pub async fn publish_text_note(&self, content: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_text_note(content, vec![])?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast to P2P (text_note): {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// トピック投稿を作成・送信\n    pub async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<EventId>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_topic_post(topic_id, content, reply_to)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            if let Err(e) = self.broadcast_to_topic(&gossip, topic_id, &event).await {\n                error!(\"Failed to broadcast to P2P (topic {}): {}\", topic_id, e);\n            }\n        }\n\n        if let Some(repo) = self.event_repository.read().await.as_ref().cloned() {\n            let _ = repo.add_event_topic(&event.id.to_string(), topic_id).await;\n        }\n\n        Ok(event_id)\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(&self, event_id: &EventId, reaction: &str) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_reaction(event_id, reaction)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topic_list = if let Some(resolved_topics) = self\n                .resolve_topics_for_referenced_event(&event_id.to_hex())\n                .await\n            {\n                if resolved_topics.is_empty() {\n                    self.default_topics_with_user_topic().await\n                } else {\n                    let unique: HashSet<_> = resolved_topics.into_iter().collect();\n                    unique.into_iter().collect()\n                }\n            } else {\n                self.default_topics_with_user_topic().await\n            };\n\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topic_list, &event).await {\n                error!(\"Failed to broadcast reaction to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n\n    /// 指定したイベントを削除するための削除イベントを発行\n    pub async fn delete_events(\n        &self,\n        target_ids: Vec<EventId>,\n        reason: Option<String>,\n    ) -> Result<EventId> {\n        self.ensure_initialized().await?;\n        if target_ids.is_empty() {\n            return Err(anyhow!(\"No event IDs provided\"));\n        }\n\n        let publisher = self.event_publisher.read().await;\n        let deletion_event = publisher.create_deletion(target_ids.clone(), reason.as_deref())?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let deletion_event_id = client_manager.publish_event(deletion_event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let mut topics: HashSet<String> = HashSet::new();\n            for event_id in &target_ids {\n                if let Some(resolved_topics) = self\n                    .resolve_topics_for_referenced_event(&event_id.to_hex())\n                    .await\n                {\n                    topics.extend(resolved_topics);\n                }\n            }\n\n            if topics.is_empty() {\n                topics.extend(self.default_topics_with_user_topic().await);\n            }\n\n            let topic_list: Vec<String> = topics.into_iter().collect();\n            if let Err(e) = self\n                .broadcast_to_topics(&gossip, &topic_list, &deletion_event)\n                .await\n            {\n                error!(\"Failed to broadcast deletion to P2P: {}\", e);\n            }\n        }\n\n        Ok(deletion_event_id)\n    }\n\n    /// リポスト（ブースト）を送信\n    /// 任意のイベントを発行\n    #[allow(dead_code)]\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let client_manager = self.client_manager.read().await;\n        let event_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast generic event to P2P: {}\", e);\n            }\n        }\n\n        Ok(event_id)\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(&self, metadata: Metadata) -> Result<EventId> {\n        self.ensure_initialized().await?;\n\n        let publisher = self.event_publisher.read().await;\n        let event = publisher.create_metadata(metadata)?;\n        drop(publisher);\n\n        let client_manager = self.client_manager.read().await;\n        let result_id = client_manager.publish_event(event.clone()).await?;\n        drop(client_manager);\n\n        if let Some(gossip) = self.gossip_service.read().await.as_ref().cloned() {\n            let topics = self.default_topics_with_user_topic().await;\n            if let Err(e) = self.broadcast_to_topics(&gossip, &topics, &event).await {\n                error!(\"Failed to broadcast metadata to P2P: {}\", e);\n            }\n        }\n\n        Ok(result_id)\n    }\n}\n","traces":[{"line":11,"address":[16725536,16726754,16725972,16726116,16725803,16725613],"length":1,"stats":{"Line":4}},{"line":12,"address":[13354950,13355206,13355332,13355879,13355671,13355017],"length":1,"stats":{"Line":4}},{"line":14,"address":[14425870],"length":1,"stats":{"Line":0}},{"line":15,"address":[13356239,13356914,13356631,13356321],"length":1,"stats":{"Line":0}},{"line":16,"address":[12826183],"length":1,"stats":{"Line":0}},{"line":18,"address":[11295912],"length":1,"stats":{"Line":0}},{"line":19,"address":[11081842],"length":1,"stats":{"Line":0}},{"line":20,"address":[16728626],"length":1,"stats":{"Line":0}},{"line":22,"address":[10538508],"length":1,"stats":{"Line":0}},{"line":23,"address":[12828437,12828323,12824722,12828675],"length":1,"stats":{"Line":0}},{"line":24,"address":[14426000],"length":1,"stats":{"Line":0}},{"line":25,"address":[18598648,18724411,18598496,18597834,18598366,18598807,18599056,18599806,18724545,18598167,18599319,18599383],"length":1,"stats":{"Line":0}},{"line":29,"address":[13385696],"length":1,"stats":{"Line":0}},{"line":33,"address":[18361792],"length":1,"stats":{"Line":1}},{"line":39,"address":[14427092],"length":1,"stats":{"Line":4}},{"line":41,"address":[11083038],"length":1,"stats":{"Line":0}},{"line":42,"address":[13390344,13391033,13390434,13390750],"length":1,"stats":{"Line":0}},{"line":43,"address":[18602234],"length":1,"stats":{"Line":0}},{"line":45,"address":[11056328],"length":1,"stats":{"Line":0}},{"line":46,"address":[11083090],"length":1,"stats":{"Line":0}},{"line":47,"address":[18603393],"length":1,"stats":{"Line":0}},{"line":49,"address":[11297212],"length":1,"stats":{"Line":0}},{"line":50,"address":[11056406],"length":1,"stats":{"Line":0}},{"line":51,"address":[13393415,13522649,13393516,13394017,13522783],"length":1,"stats":{"Line":0}},{"line":55,"address":[16737180,16733307,16739679,16740162],"length":1,"stats":{"Line":0}},{"line":56,"address":[19112443,19111914],"length":1,"stats":{"Line":0}},{"line":59,"address":[13369936],"length":1,"stats":{"Line":0}},{"line":63,"address":[15298999,15298976],"length":1,"stats":{"Line":0}},{"line":64,"address":[11076404],"length":1,"stats":{"Line":0}},{"line":66,"address":[11049694],"length":1,"stats":{"Line":0}},{"line":67,"address":[13399452,13398829,13398919,13399169],"length":1,"stats":{"Line":0}},{"line":68,"address":[13613217],"length":1,"stats":{"Line":0}},{"line":70,"address":[14420536],"length":1,"stats":{"Line":0}},{"line":71,"address":[13373036,13373660,13370892,13373118],"length":1,"stats":{"Line":0}},{"line":72,"address":[13400348],"length":1,"stats":{"Line":0}},{"line":74,"address":[14420588],"length":1,"stats":{"Line":0}},{"line":75,"address":[13401541,13401873,13402011,13401261,13401495],"length":1,"stats":{"Line":0}},{"line":76,"address":[13615481,13615380],"length":1,"stats":{"Line":0}},{"line":77,"address":[16745594,16745654,16741750,16745832,16746023],"length":1,"stats":{"Line":0}},{"line":79,"address":[13616200,13616317],"length":1,"stats":{"Line":0}},{"line":80,"address":[13616553,13611787,13616807,13616403],"length":1,"stats":{"Line":0}},{"line":82,"address":[18613993,18613867],"length":1,"stats":{"Line":0}},{"line":83,"address":[13402368],"length":1,"stats":{"Line":0}},{"line":86,"address":[14420666],"length":1,"stats":{"Line":0}},{"line":89,"address":[12846397,12840597,12845946],"length":1,"stats":{"Line":0}},{"line":90,"address":[13403928,13404530,13523279,13523145,13404029],"length":1,"stats":{"Line":0}},{"line":94,"address":[13615733],"length":1,"stats":{"Line":0}},{"line":98,"address":[15829440],"length":1,"stats":{"Line":0}},{"line":103,"address":[18618509,18618449,18619154,18619526,18618733,18618835],"length":1,"stats":{"Line":0}},{"line":104,"address":[13406988,13407070],"length":1,"stats":{"Line":0}},{"line":105,"address":[13380375,13380578],"length":1,"stats":{"Line":0}},{"line":108,"address":[16751501,16751270,16751156,16750454],"length":1,"stats":{"Line":0}},{"line":109,"address":[13622616,13622304,13621803,13621882,13622588],"length":1,"stats":{"Line":0}},{"line":110,"address":[13622262],"length":1,"stats":{"Line":0}},{"line":112,"address":[10531470],"length":1,"stats":{"Line":0}},{"line":113,"address":[12851780,12849280,12852326,12851698],"length":1,"stats":{"Line":0}},{"line":114,"address":[12852278],"length":1,"stats":{"Line":0}},{"line":116,"address":[13624047,13624417,13620533,13623603],"length":1,"stats":{"Line":0}},{"line":117,"address":[13624596],"length":1,"stats":{"Line":0}},{"line":118,"address":[13411537,13410621,13410739,13411467],"length":1,"stats":{"Line":0}},{"line":119,"address":[16755361,16755633,16755996,16755178,16756042],"length":1,"stats":{"Line":0}},{"line":120,"address":[13625950,13625669],"length":1,"stats":{"Line":0}},{"line":121,"address":[13620554,13625258,13626031,13625039,13626091],"length":1,"stats":{"Line":0}},{"line":123,"address":[12854212],"length":1,"stats":{"Line":0}},{"line":127,"address":[13625600,13625693],"length":1,"stats":{"Line":0}},{"line":128,"address":[13406479,13411701,13412000],"length":1,"stats":{"Line":0}},{"line":131,"address":[13385524,13384867],"length":1,"stats":{"Line":0}},{"line":132,"address":[13626556,13626602,13626390,13626806,13626898],"length":1,"stats":{"Line":0}},{"line":133,"address":[13626410,13626544],"length":1,"stats":{"Line":0}},{"line":134,"address":[11289320],"length":1,"stats":{"Line":0}},{"line":136,"address":[13737737,13737871,13627545,13626943,13627044],"length":1,"stats":{"Line":0}},{"line":140,"address":[13410824],"length":1,"stats":{"Line":0}},{"line":146,"address":[15829520,15829555],"length":1,"stats":{"Line":0}},{"line":147,"address":[12858099,12858166,12859004,12858461,12858335,12858796],"length":1,"stats":{"Line":0}},{"line":149,"address":[13416180,13415898,13416027,13415323],"length":1,"stats":{"Line":0}},{"line":150,"address":[18628958,18627804,18628880,18629475],"length":1,"stats":{"Line":0}},{"line":151,"address":[13631151],"length":1,"stats":{"Line":0}},{"line":153,"address":[16761543,16761228,16761913,16759445],"length":1,"stats":{"Line":0}},{"line":154,"address":[13391390,13391635,13391276,13388650],"length":1,"stats":{"Line":0}},{"line":155,"address":[16762867,16762710,16759487],"length":1,"stats":{"Line":0}},{"line":156,"address":[13419290,13524137,13524271,13419189,13419791],"length":1,"stats":{"Line":0}},{"line":160,"address":[13632345],"length":1,"stats":{"Line":0}},{"line":164,"address":[13394573,13395707,13394789,13394496,13395100,13398016],"length":1,"stats":{"Line":0}},{"line":165,"address":[11079554],"length":1,"stats":{"Line":0}},{"line":167,"address":[12865166,12865033,12864440,12865316],"length":1,"stats":{"Line":0}},{"line":168,"address":[13396090,13396394,13396684,13396008],"length":1,"stats":{"Line":0}},{"line":169,"address":[12865946],"length":1,"stats":{"Line":0}},{"line":171,"address":[13637544,13635693,13637322,13637403],"length":1,"stats":{"Line":0}},{"line":172,"address":[13424371,13423740,13421618,13423822],"length":1,"stats":{"Line":0}},{"line":173,"address":[18637063],"length":1,"stats":{"Line":0}},{"line":175,"address":[11079658],"length":1,"stats":{"Line":0}},{"line":176,"address":[19108404],"length":1,"stats":{"Line":0}},{"line":177,"address":[11079710],"length":1,"stats":{"Line":0}},{"line":178,"address":[13399950,13400451,13498031,13497897,13399849],"length":1,"stats":{"Line":0}},{"line":182,"address":[18638301],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":95},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","tests","mod.rs"],"content":"use super::*;\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::domain::p2p::user_topic_id;\nuse crate::infrastructure::{crypto::DefaultKeyManager, p2p::GossipService};\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\n\nmod support;\n\nuse support::mocks::TestGossipService;\n\n#[tokio::test]\nasync fn test_event_manager_initialization() {\n    let manager = EventManager::new();\n    let key_manager = DefaultKeyManager::new();\n\n    key_manager.generate_keypair().await.unwrap();\n\n    assert!(\n        manager\n            .initialize_with_key_manager(&key_manager)\n            .await\n            .is_ok()\n    );\n    assert!(manager.get_public_key().await.is_some());\n}\n\n#[tokio::test]\nasync fn test_event_manager_not_initialized() {\n    let manager = EventManager::new();\n\n    assert!(manager.publish_text_note(\"test\").await.is_err());\n    assert!(\n        manager\n            .publish_topic_post(\"topic\", \"content\", None)\n            .await\n            .is_err()\n    );\n    assert!(manager.subscribe_to_topic(\"topic\", None).await.is_err());\n}\n\n#[tokio::test]\nasync fn test_initialize_and_disconnect() {\n    let manager = EventManager::new();\n    let key_manager = DefaultKeyManager::new();\n\n    key_manager.generate_keypair().await.unwrap();\n\n    manager\n        .initialize_with_key_manager(&key_manager)\n        .await\n        .unwrap();\n    assert!(manager.ensure_initialized().await.is_ok());\n\n    manager.disconnect().await.unwrap();\n    assert!(manager.ensure_initialized().await.is_err());\n}\n\n#[tokio::test]\nasync fn test_get_public_key() {\n    let manager = EventManager::new();\n    let key_manager = DefaultKeyManager::new();\n\n    assert!(manager.get_public_key().await.is_none());\n\n    key_manager.generate_keypair().await.unwrap();\n    manager\n        .initialize_with_key_manager(&key_manager)\n        .await\n        .unwrap();\n\n    let public_key = manager.get_public_key().await.unwrap();\n    let current_pubkey = key_manager.current_keypair().await.unwrap().public_key;\n    let expected = PublicKey::from_hex(&current_pubkey).expect(\"valid pubkey hex\");\n    assert_eq!(public_key, expected);\n}\n\n#[tokio::test]\nasync fn test_create_events() {\n    let manager = EventManager::new();\n    let key_manager = DefaultKeyManager::new();\n\n    key_manager.generate_keypair().await.unwrap();\n    manager\n        .initialize_with_key_manager(&key_manager)\n        .await\n        .unwrap();\n\n    let publisher = manager.event_publisher.read().await;\n\n    let text_event = publisher.create_text_note(\"Test note\", vec![]).unwrap();\n    assert_eq!(text_event.kind, Kind::TextNote);\n\n    let metadata = Metadata::new().name(\"Test User\");\n    let metadata_event = publisher.create_metadata(metadata).unwrap();\n    assert_eq!(metadata_event.kind, Kind::Metadata);\n\n    let event_id = EventId::from_slice(&[1; 32]).unwrap();\n    let reaction_event = publisher.create_reaction(&event_id, \"+\").unwrap();\n    assert_eq!(reaction_event.kind, Kind::Reaction);\n}\n\n#[tokio::test]\nasync fn test_ensure_initialized() {\n    let manager = EventManager::new();\n\n    assert!(manager.ensure_initialized().await.is_err());\n\n    let key_manager = DefaultKeyManager::new();\n    key_manager.generate_keypair().await.unwrap();\n    manager\n        .initialize_with_key_manager(&key_manager)\n        .await\n        .unwrap();\n\n    assert!(manager.ensure_initialized().await.is_ok());\n}\n\n#[tokio::test]\nasync fn test_default_topics_api() {\n    let manager = EventManager::new();\n\n    let mut topics = manager.list_default_p2p_topics().await;\n    topics.sort();\n    assert_eq!(topics, vec![\"public\".to_string()]);\n\n    manager\n        .set_default_p2p_topics(vec![\"a\".into(), \"b\".into()])\n        .await;\n    let mut topics = manager.list_default_p2p_topics().await;\n    topics.sort();\n    assert_eq!(topics, vec![\"a\".to_string(), \"b\".to_string()]);\n\n    manager.add_default_p2p_topic(\"c\").await;\n    manager.remove_default_p2p_topic(\"b\").await;\n    let mut topics = manager.list_default_p2p_topics().await;\n    topics.sort();\n    assert_eq!(topics, vec![\"a\".to_string(), \"c\".to_string()]);\n}\n\n#[tokio::test]\nasync fn test_routing_non_topic_includes_user_and_defaults() {\n    let manager = EventManager::new();\n    let key_manager = DefaultKeyManager::new();\n\n    key_manager.generate_keypair().await.unwrap();\n    manager\n        .initialize_with_key_manager(&key_manager)\n        .await\n        .unwrap();\n\n    manager\n        .set_default_p2p_topics(vec![\"t1\".into(), \"t2\".into()])\n        .await;\n\n    let gossip = Arc::new(TestGossipService::new());\n    manager.set_gossip_service(gossip.clone()).await;\n\n    let publisher = manager.event_publisher.read().await;\n    let nostr_event = publisher.create_text_note(\"hello\", vec![]).unwrap();\n    drop(publisher);\n\n    let mut topics = manager.list_default_p2p_topics().await;\n    if let Some(pk) = manager.get_public_key().await {\n        topics.push(user_topic_id(&pk.to_string()));\n    }\n    manager\n        .broadcast_to_topics(\n            &(gossip.clone() as Arc<dyn GossipService>),\n            &topics,\n            &nostr_event,\n        )\n        .await\n        .unwrap();\n\n    let joined = gossip.joined_topics().await;\n    let pubkey = manager.get_public_key().await.unwrap();\n    let user_topic = user_topic_id(&pubkey.to_string());\n    assert!(joined.contains(\"t1\"));\n    assert!(joined.contains(\"t2\"));\n    assert!(joined.contains(&user_topic));\n\n    let mut b = gossip.broadcasted_topics().await;\n    b.sort();\n    assert_eq!(b, {\n        let mut v = vec![\"t1\".to_string(), \"t2\".to_string(), user_topic];\n        v.sort();\n        v\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","manager","tests","support","mod.rs"],"content":"pub(crate) use crate::application::shared::tests::event::mocks;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","mod.rs"],"content":"pub mod handler;\npub mod manager;\npub mod nostr_client;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","event","nostr_client.rs"],"content":"use anyhow::Result;\nuse nostr_sdk::prelude::*;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::info;\n\n/// Nostrクライアントの管理構造体\npub struct NostrClientManager {\n    client: Arc<RwLock<Option<Client>>>,\n    keys: Option<Keys>,\n}\n\nimpl NostrClientManager {\n    /// 新しいNostrClientManagerインスタンスを作成\n    pub fn new() -> Self {\n        Self {\n            client: Arc::new(RwLock::new(None)),\n            keys: None,\n        }\n    }\n\n    /// 秘密鍵からクライアントを初期化\n    pub async fn init_with_keys(&mut self, secret_key: &SecretKey) -> Result<()> {\n        let keys = Keys::new(secret_key.clone());\n        self.keys = Some(keys.clone());\n\n        let client = Client::new(keys.clone());\n\n        *self.client.write().await = Some(client);\n\n        info!(\"Nostr client initialized with keys\");\n        Ok(())\n    }\n\n    /// 全てのリレーから切断\n    pub async fn disconnect(&self) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            client.disconnect().await;\n            info!(\"Disconnected from all relays\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// カスタムイベントを投稿\n    pub async fn publish_event(&self, event: Event) -> Result<EventId> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            let output = client.send_event(&event).await?;\n            let event_id = output.id();\n            info!(\"Published event: {}\", event_id);\n            Ok(*event_id)\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// イベントをサブスクライブ\n    pub async fn subscribe(&self, filters: Vec<Filter>) -> Result<()> {\n        let client_guard = self.client.read().await;\n        if let Some(client) = client_guard.as_ref() {\n            for filter in filters {\n                client.subscribe(filter, None).await?;\n            }\n            info!(\"Subscribed to filters\");\n            Ok(())\n        } else {\n            Err(anyhow::anyhow!(\"Client not initialized\"))\n        }\n    }\n\n    /// 公開鍵を取得\n    #[allow(dead_code)]\n    pub fn get_public_key(&self) -> Option<PublicKey> {\n        self.keys.as_ref().map(|k| k.public_key())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_client_initialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        assert!(manager.init_with_keys(&secret_key).await.is_ok());\n        assert!(manager.get_public_key().is_some());\n    }\n\n    #[tokio::test]\n    async fn test_client_not_initialized_error() {\n        let manager = NostrClientManager::new();\n\n        // クライアントが初期化されていない状態でのテスト\n        assert!(manager.disconnect().await.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_public_key_generation() {\n        let mut manager = NostrClientManager::new();\n        let secret_key = SecretKey::generate();\n\n        // 初期化前は公開鍵がない\n        assert!(manager.get_public_key().is_none());\n\n        // 初期化後は公開鍵が取得できる\n        manager.init_with_keys(&secret_key).await.unwrap();\n        let public_key = manager.get_public_key().unwrap();\n        assert_eq!(public_key, Keys::new(secret_key).public_key());\n    }\n\n    #[tokio::test]\n    async fn test_client_reinitialization() {\n        let mut manager = NostrClientManager::new();\n        let secret_key1 = SecretKey::generate();\n        let secret_key2 = SecretKey::generate();\n\n        // 最初の初期化\n        manager.init_with_keys(&secret_key1).await.unwrap();\n        let public_key1 = manager.get_public_key().unwrap();\n\n        // 再初期化\n        manager.init_with_keys(&secret_key2).await.unwrap();\n        let public_key2 = manager.get_public_key().unwrap();\n\n        // 公開鍵が更新されていることを確認\n        assert_ne!(public_key1, public_key2);\n        assert_eq!(public_key2, Keys::new(secret_key2).public_key());\n    }\n}\n","traces":[{"line":15,"address":[13464528],"length":1,"stats":{"Line":1}},{"line":17,"address":[18679584],"length":1,"stats":{"Line":1}},{"line":23,"address":[18149375,18149309,18149296,18149567,18150166,18149524,18149344,18150195],"length":1,"stats":{"Line":8}},{"line":24,"address":[18920749,18920849],"length":1,"stats":{"Line":4}},{"line":25,"address":[18920879,18920960],"length":1,"stats":{"Line":3}},{"line":27,"address":[18707007],"length":1,"stats":{"Line":2}},{"line":29,"address":[10941305,10941191],"length":1,"stats":{"Line":2}},{"line":31,"address":[18707899,18830143,18830009,18708454],"length":1,"stats":{"Line":4}},{"line":32,"address":[18922502],"length":1,"stats":{"Line":2}},{"line":36,"address":[18152688,18152696,18152842,18153068,18152735,18152906,18152704,18153766],"length":1,"stats":{"Line":4}},{"line":37,"address":[10931153],"length":1,"stats":{"Line":3}},{"line":38,"address":[18710507,18710594,18711617],"length":1,"stats":{"Line":5}},{"line":39,"address":[18683979,18684175,18683946,18683293],"length":1,"stats":{"Line":2}},{"line":40,"address":[18711098,18711629,18830505,18830639],"length":1,"stats":{"Line":2}},{"line":41,"address":[18711605],"length":1,"stats":{"Line":1}},{"line":43,"address":[13469038,13468913],"length":1,"stats":{"Line":2}},{"line":48,"address":[13471691,13475191,13471216,13472433,13471171,13471136,13471293,13471455],"length":1,"stats":{"Line":0}},{"line":49,"address":[10375580],"length":1,"stats":{"Line":0}},{"line":50,"address":[18687040,18687133],"length":1,"stats":{"Line":0}},{"line":51,"address":[18157721,18156869,18156813,18157082,18156146],"length":1,"stats":{"Line":0}},{"line":52,"address":[18929090,18928935],"length":1,"stats":{"Line":0}},{"line":53,"address":[13565426,13564819,13685577,13685711],"length":1,"stats":{"Line":0}},{"line":54,"address":[18929605],"length":1,"stats":{"Line":0}},{"line":56,"address":[18713979,18714110],"length":1,"stats":{"Line":0}},{"line":61,"address":[13475469,13475360,13476607,13475408,13475368,13479428,13475848,13475624],"length":1,"stats":{"Line":0}},{"line":62,"address":[18717374,18717430,18717517,18717656],"length":1,"stats":{"Line":0}},{"line":63,"address":[18718014,18719902,18717927],"length":1,"stats":{"Line":0}},{"line":64,"address":[18691362,18692485,18691459,18692541],"length":1,"stats":{"Line":0}},{"line":65,"address":[13567255,13569054,13571051,13568548,13568148],"length":1,"stats":{"Line":0}},{"line":67,"address":[18933479,19045727,19045593,18934010],"length":1,"stats":{"Line":0}},{"line":68,"address":[18693154],"length":1,"stats":{"Line":0}},{"line":70,"address":[18718295,18718169],"length":1,"stats":{"Line":0}},{"line":76,"address":[13571200],"length":1,"stats":{"Line":1}},{"line":77,"address":[13571264,13571280,13571232],"length":1,"stats":{"Line":3}}],"covered":18,"coverable":34},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","mod.rs"],"content":"#![allow(dead_code)]\n\npub mod crypto;\npub mod event;\npub mod post;\npub mod topic;\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","post","mod.rs"],"content":"\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","topic","mod.rs"],"content":"\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","modules","utils","mod.rs"],"content":"\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","auth_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            auth_dto::{LoginResponse, LoginWithNsecRequest},\n        },\n        handlers::AuthHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse tauri::State;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GenerateKeypairResponse {\n    pub public_key: String,\n    pub nsec: String,\n    pub npub: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginRequest {\n    pub nsec: String,\n}\n\n/// 新しいキーペアを生成する\n#[tauri::command]\npub async fn generate_keypair(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<GenerateKeypairResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let response = handler.create_account().await?;\n\n    Ok(ApiResponse::success(GenerateKeypairResponse {\n        public_key: response.pubkey,\n        nsec: response.nsec,\n        npub: response.npub,\n    }))\n}\n\n/// nsecで既存アカウントにログイン\n#[tauri::command]\npub async fn login(\n    state: State<'_, AppState>,\n    request: LoginRequest,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let login_request = LoginWithNsecRequest { nsec: request.nsec };\n\n    let result = handler.login_with_nsec(login_request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ログアウト\n#[tauri::command]\npub async fn logout(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let handler = AuthHandler::new(state.auth_service.clone());\n    let current_user = handler.get_current_user().await?;\n\n    if let Some(user) = current_user {\n        handler.logout(user.npub).await?;\n    }\n\n    Ok(ApiResponse::success(()))\n}\n\n/// アカウント作成（旧APIとの互換性のため）\n#[tauri::command]\npub async fn create_account(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let user = state.auth_service.create_account().await?;\n\n    Ok(ApiResponse::success(LoginResponse {\n        success: true,\n        npub: user.npub,\n        pubkey: user.pubkey,\n    }))\n}\n\n/// nsecでログイン（旧APIとの互換性のため）\n#[tauri::command]\npub async fn login_with_nsec(\n    nsec: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let user = state.auth_service.login_with_nsec(&nsec).await?;\n\n    Ok(ApiResponse::success(LoginResponse {\n        success: true,\n        npub: user.npub,\n        pubkey: user.pubkey,\n    }))\n}\n\n/// npubでログイン\n#[tauri::command]\npub async fn login_with_npub(\n    npub: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let user = state.auth_service.login_with_npub(&npub).await?;\n\n    Ok(ApiResponse::success(LoginResponse {\n        success: true,\n        npub: user.npub,\n        pubkey: user.pubkey,\n    }))\n}\n\n/// 現在のユーザーを取得\n#[tauri::command]\npub async fn get_current_user(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = state\n        .auth_service\n        .get_current_user()\n        .await\n        .and_then(|user| {\n            user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .transpose()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 認証状態を確認\n#[tauri::command]\npub async fn is_authenticated(state: State<'_, AppState>) -> Result<ApiResponse<bool>, AppError> {\n    Ok(ApiResponse::success(\n        state.auth_service.is_authenticated().await,\n    ))\n}\n\n/// 秘密鍵をエクスポート\n#[tauri::command]\npub async fn export_private_key(\n    npub: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<String>, AppError> {\n    let result = state.auth_service.export_private_key(&npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":30,"address":[11699680],"length":1,"stats":{"Line":0}},{"line":33,"address":[15070652,15070769],"length":1,"stats":{"Line":0}},{"line":34,"address":[11726760,11726967,11726857,11726624,11727693],"length":1,"stats":{"Line":0}},{"line":36,"address":[11700834,11701067],"length":1,"stats":{"Line":0}},{"line":37,"address":[14887034],"length":1,"stats":{"Line":0}},{"line":38,"address":[11170366],"length":1,"stats":{"Line":0}},{"line":39,"address":[11727536],"length":1,"stats":{"Line":0}},{"line":45,"address":[14887728],"length":1,"stats":{"Line":0}},{"line":49,"address":[11728468,11728353],"length":1,"stats":{"Line":0}},{"line":50,"address":[11942635],"length":1,"stats":{"Line":0}},{"line":52,"address":[14888242,14888328,14887969,14888156],"length":1,"stats":{"Line":0}},{"line":53,"address":[15073106],"length":1,"stats":{"Line":0}},{"line":58,"address":[11943625,11943906,11943475,11943408,11943567,11943416,11944695,11943440],"length":1,"stats":{"Line":0}},{"line":59,"address":[11702842,11702714],"length":1,"stats":{"Line":0}},{"line":60,"address":[14889247,14889157,14890021,14889014,14889334,14889710],"length":1,"stats":{"Line":0}},{"line":62,"address":[11703457,11703561],"length":1,"stats":{"Line":0}},{"line":63,"address":[15073596,15074561,15074688,15074431,15074964],"length":1,"stats":{"Line":0}},{"line":66,"address":[11944510,11945116],"length":1,"stats":{"Line":0}},{"line":71,"address":[14890672],"length":1,"stats":{"Line":0}},{"line":74,"address":[11946307,11945492,11945544,11945783,11945625],"length":1,"stats":{"Line":0}},{"line":76,"address":[15076401,15076192],"length":1,"stats":{"Line":0}},{"line":78,"address":[11174905],"length":1,"stats":{"Line":0}},{"line":79,"address":[11732075],"length":1,"stats":{"Line":0}},{"line":85,"address":[11175728],"length":1,"stats":{"Line":0}},{"line":89,"address":[11175913,11175965,11176238,11176044,11176768],"length":1,"stats":{"Line":0}},{"line":91,"address":[14893330,14893129],"length":1,"stats":{"Line":0}},{"line":93,"address":[11947824],"length":1,"stats":{"Line":0}},{"line":94,"address":[11947861],"length":1,"stats":{"Line":0}},{"line":100,"address":[11948736],"length":1,"stats":{"Line":0}},{"line":104,"address":[14894185,14894442,14894264,14894137,14894952],"length":1,"stats":{"Line":0}},{"line":106,"address":[11708845,11709054],"length":1,"stats":{"Line":0}},{"line":108,"address":[11949600],"length":1,"stats":{"Line":0}},{"line":109,"address":[11735541],"length":1,"stats":{"Line":0}},{"line":115,"address":[14895680],"length":1,"stats":{"Line":0}},{"line":118,"address":[11179819,11179412,11179884,11179529,11179600],"length":1,"stats":{"Line":0}},{"line":121,"address":[14896060,14895977,14896008,14896193,14895860],"length":1,"stats":{"Line":0}},{"line":122,"address":[11180016],"length":1,"stats":{"Line":0}},{"line":123,"address":[15081296,15081309,15081246],"length":1,"stats":{"Line":0}},{"line":126,"address":[15081124],"length":1,"stats":{"Line":0}},{"line":131,"address":[11710595,11710552,11710682,11710544,11710560,11710722,11711238,11710923],"length":1,"stats":{"Line":0}},{"line":132,"address":[11180748],"length":1,"stats":{"Line":0}},{"line":133,"address":[11710657,11710955,11710771,11710709],"length":1,"stats":{"Line":0}},{"line":139,"address":[11952080],"length":1,"stats":{"Line":0}},{"line":143,"address":[14897382,14897445,14897334,14897616],"length":1,"stats":{"Line":0}},{"line":144,"address":[14897814],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","event_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::event::{\n    DeleteEventsRequest, EventResponse, NostrMetadataDto, PublishTextNoteRequest,\n    PublishTopicPostRequest, SendReactionRequest, SetDefaultP2PTopicRequest, SubscribeRequest,\n    UpdateMetadataRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// Nostrクライアントを初期化（ログイン時に呼び出す）\n#[tauri::command]\npub async fn initialize_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.initialize_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// テキストノートを投稿\n#[tauri::command]\npub async fn publish_text_note(\n    content: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTextNoteRequest { content };\n\n    let result = state.event_handler.publish_text_note(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピック投稿を作成\n#[tauri::command]\npub async fn publish_topic_post(\n    topic_id: String,\n    content: String,\n    reply_to: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = PublishTopicPostRequest {\n        topic_id,\n        content,\n        reply_to,\n    };\n\n    let result = state.event_handler.publish_topic_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// リアクションを送信\n#[tauri::command]\npub async fn send_reaction(\n    event_id: String,\n    reaction: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = SendReactionRequest { event_id, reaction };\n\n    let result = state.event_handler.send_reaction(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// メタデータを更新\n#[tauri::command]\npub async fn update_nostr_metadata(\n    metadata: NostrMetadataDto,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = UpdateMetadataRequest { metadata };\n\n    let result = state.event_handler.update_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_topic(\n    topic_id: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let request = SubscribeRequest { topic_id };\n\n    let result = state.event_handler.subscribe_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ユーザーをサブスクライブ\n#[tauri::command]\npub async fn subscribe_to_user(\n    pubkey: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.subscribe_to_user(pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のNostr購読状態を取得\n#[tauri::command]\npub async fn list_nostr_subscriptions(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.list_subscriptions().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// Nostr公開鍵を取得\n#[tauri::command]\npub async fn get_nostr_pubkey(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.get_nostr_pubkey().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// イベントを削除\n#[tauri::command]\npub async fn delete_events(\n    event_ids: Vec<String>,\n    reason: Option<String>,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<EventResponse>, AppError> {\n    let request = DeleteEventsRequest { event_ids, reason };\n\n    let result = state.event_handler.delete_events(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// Nostrクライアントを切断\n#[tauri::command]\npub async fn disconnect_nostr(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let result = state.event_handler.disconnect_nostr().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 既定のP2P配信トピックを設定\n#[tauri::command]\npub async fn set_default_p2p_topic(\n    topic_id: String,\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<serde_json::Value>, AppError> {\n    let request = SetDefaultP2PTopicRequest { topic_id };\n    let result = state.event_handler.set_default_p2p_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":14,"address":[18843840],"length":1,"stats":{"Line":0}},{"line":17,"address":[10921044],"length":1,"stats":{"Line":0}},{"line":18,"address":[12430281],"length":1,"stats":{"Line":0}},{"line":23,"address":[14159920],"length":1,"stats":{"Line":0}},{"line":27,"address":[19401873],"length":1,"stats":{"Line":0}},{"line":29,"address":[18952462],"length":1,"stats":{"Line":0}},{"line":30,"address":[12431105],"length":1,"stats":{"Line":0}},{"line":35,"address":[18845488],"length":1,"stats":{"Line":0}},{"line":47,"address":[18955009],"length":1,"stats":{"Line":0}},{"line":48,"address":[19617709],"length":1,"stats":{"Line":0}},{"line":53,"address":[19377056],"length":1,"stats":{"Line":0}},{"line":58,"address":[19404030],"length":1,"stats":{"Line":0}},{"line":60,"address":[19404094,19404434,19404146,19404209],"length":1,"stats":{"Line":0}},{"line":61,"address":[12433248],"length":1,"stats":{"Line":0}},{"line":66,"address":[19618960],"length":1,"stats":{"Line":0}},{"line":70,"address":[19378381],"length":1,"stats":{"Line":0}},{"line":72,"address":[12433797,12433997,12433734,12433683],"length":1,"stats":{"Line":0}},{"line":73,"address":[12434246],"length":1,"stats":{"Line":0}},{"line":78,"address":[19620000],"length":1,"stats":{"Line":0}},{"line":82,"address":[18848945],"length":1,"stats":{"Line":0}},{"line":84,"address":[19406162,19406422,19406110,19406222],"length":1,"stats":{"Line":0}},{"line":85,"address":[14164856],"length":1,"stats":{"Line":0}},{"line":90,"address":[19406800],"length":1,"stats":{"Line":0}},{"line":94,"address":[18952622],"length":1,"stats":{"Line":0}},{"line":95,"address":[14165726],"length":1,"stats":{"Line":0}},{"line":100,"address":[19407680],"length":1,"stats":{"Line":0}},{"line":103,"address":[18996884],"length":1,"stats":{"Line":0}},{"line":104,"address":[19381545],"length":1,"stats":{"Line":0}},{"line":109,"address":[19381664],"length":1,"stats":{"Line":0}},{"line":112,"address":[14167014,14166851,14166789,14166737],"length":1,"stats":{"Line":0}},{"line":113,"address":[14167225],"length":1,"stats":{"Line":0}},{"line":118,"address":[19623216],"length":1,"stats":{"Line":0}},{"line":123,"address":[14167582],"length":1,"stats":{"Line":0}},{"line":125,"address":[14167761,14167646,14167986,14167698],"length":1,"stats":{"Line":0}},{"line":126,"address":[12438304],"length":1,"stats":{"Line":0}},{"line":131,"address":[12438464],"length":1,"stats":{"Line":0}},{"line":134,"address":[12438625,12438687,12438577,12438834],"length":1,"stats":{"Line":0}},{"line":135,"address":[19410793],"length":1,"stats":{"Line":0}},{"line":140,"address":[14169136],"length":1,"stats":{"Line":0}},{"line":144,"address":[12439313],"length":1,"stats":{"Line":0}},{"line":145,"address":[10935950],"length":1,"stats":{"Line":0}},{"line":146,"address":[12439848],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","mod.rs"],"content":"#![allow(unused_imports)]\r\n\r\npub mod auth_commands;\r\npub mod event_commands;\r\npub mod offline_commands;\r\npub mod p2p_commands;\r\npub mod post_commands;\r\npub mod secure_storage_commands;\r\npub mod sync_commands;\r\npub mod topic_commands;\r\npub mod user_commands;\r\npub mod utils_commands;\r\n\r\npub use auth_commands::*;\r\npub use event_commands::*;\r\npub use offline_commands::*;\r\npub use p2p_commands::*;\r\npub use post_commands::*;\r\npub use secure_storage_commands::*;\r\npub use sync_commands::*;\r\npub use topic_commands::*;\r\npub use user_commands::*;\r\npub use utils_commands::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","offline_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, GetOfflineActionsRequest, OfflineAction,\n    OptimisticUpdateRequest, SaveOfflineActionRequest, SaveOfflineActionResponse,\n    SyncOfflineActionsRequest, SyncOfflineActionsResponse, UpdateCacheMetadataRequest,\n    UpdateSyncStatusRequest,\n};\nuse crate::shared::AppError;\nuse crate::state::AppState;\nuse serde_json::Value;\nuse tauri::State;\n\n/// オフラインアクションを保存\n#[tauri::command]\npub async fn save_offline_action(\n    state: State<'_, AppState>,\n    request: SaveOfflineActionRequest,\n) -> Result<ApiResponse<SaveOfflineActionResponse>, AppError> {\n    let result = state.offline_handler.save_offline_action(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを取得\n#[tauri::command]\npub async fn get_offline_actions(\n    state: State<'_, AppState>,\n    request: GetOfflineActionsRequest,\n) -> Result<ApiResponse<Vec<OfflineAction>>, AppError> {\n    let result = state.offline_handler.get_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// オフラインアクションを同期\n#[tauri::command]\npub async fn sync_offline_actions(\n    state: State<'_, AppState>,\n    request: SyncOfflineActionsRequest,\n) -> Result<ApiResponse<SyncOfflineActionsResponse>, AppError> {\n    let result = state.offline_handler.sync_offline_actions(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュステータスを取得\n#[tauri::command]\npub async fn get_cache_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<CacheStatusResponse>, AppError> {\n    let result = state.offline_handler.get_cache_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期キューに追加\n#[tauri::command]\npub async fn add_to_sync_queue(\n    state: State<'_, AppState>,\n    request: AddToSyncQueueRequest,\n) -> Result<ApiResponse<i64>, AppError> {\n    let result = state.offline_handler.add_to_sync_queue(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// キャッシュメタデータを更新\n#[tauri::command]\npub async fn update_cache_metadata(\n    state: State<'_, AppState>,\n    request: UpdateCacheMetadataRequest,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state.offline_handler.update_cache_metadata(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を保存\n#[tauri::command]\npub async fn save_optimistic_update(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    original_data: Option<String>,\n    updated_data: String,\n) -> Result<ApiResponse<String>, AppError> {\n    let request = OptimisticUpdateRequest {\n        entity_type,\n        entity_id,\n        original_data,\n        updated_data,\n    };\n\n    let result = state.offline_handler.save_optimistic_update(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新を確定\n#[tauri::command]\npub async fn confirm_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Value>, AppError> {\n    let result = state\n        .offline_handler\n        .confirm_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 楽観的更新をロールバック\n#[tauri::command]\npub async fn rollback_optimistic_update(\n    state: State<'_, AppState>,\n    update_id: String,\n) -> Result<ApiResponse<Option<String>>, AppError> {\n    let result = state\n        .offline_handler\n        .rollback_optimistic_update(update_id)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 期限切れキャッシュをクリーンアップ\n#[tauri::command]\npub async fn cleanup_expired_cache(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<i32>, AppError> {\n    let result = state.offline_handler.cleanup_expired_cache().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 同期ステータスを更新\n#[tauri::command]\npub async fn update_sync_status(\n    state: State<'_, AppState>,\n    entity_type: String,\n    entity_id: String,\n    sync_status: String,\n    conflict_data: Option<String>,\n) -> Result<ApiResponse<Value>, AppError> {\n    let request = UpdateSyncStatusRequest {\n        entity_type,\n        entity_id,\n        sync_status,\n        conflict_data,\n    };\n\n    let result = state.offline_handler.update_sync_status(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":15,"address":[16386512],"length":1,"stats":{"Line":0}},{"line":19,"address":[16944004,16943952,16944370,16944067],"length":1,"stats":{"Line":0}},{"line":20,"address":[17158662],"length":1,"stats":{"Line":0}},{"line":25,"address":[17158848],"length":1,"stats":{"Line":0}},{"line":29,"address":[17390316,17390364,17390427,17390621],"length":1,"stats":{"Line":0}},{"line":30,"address":[16918774],"length":1,"stats":{"Line":0}},{"line":35,"address":[11703920],"length":1,"stats":{"Line":0}},{"line":39,"address":[10370458],"length":1,"stats":{"Line":0}},{"line":40,"address":[17160478],"length":1,"stats":{"Line":0}},{"line":45,"address":[17160656],"length":1,"stats":{"Line":0}},{"line":48,"address":[11705011,11704897,11704949,11705174],"length":1,"stats":{"Line":0}},{"line":49,"address":[16947170],"length":1,"stats":{"Line":0}},{"line":54,"address":[16947280],"length":1,"stats":{"Line":0}},{"line":58,"address":[11143265],"length":1,"stats":{"Line":0}},{"line":59,"address":[17162156],"length":1,"stats":{"Line":0}},{"line":64,"address":[17162336],"length":1,"stats":{"Line":0}},{"line":68,"address":[17393677,17393725,17393788,17394033],"length":1,"stats":{"Line":0}},{"line":69,"address":[16391962],"length":1,"stats":{"Line":0}},{"line":74,"address":[17163376],"length":1,"stats":{"Line":0}},{"line":88,"address":[16949736,16949788,16950124,16949851],"length":1,"stats":{"Line":0}},{"line":89,"address":[16950321],"length":1,"stats":{"Line":0}},{"line":94,"address":[16393376],"length":1,"stats":{"Line":0}},{"line":98,"address":[16393788,16393674,16393737,16393562,16393970],"length":1,"stats":{"Line":0}},{"line":100,"address":[11709062],"length":1,"stats":{"Line":0}},{"line":101,"address":[17165044,17165100,17164996,17164846,17165250],"length":1,"stats":{"Line":0}},{"line":102,"address":[16394078],"length":1,"stats":{"Line":0}},{"line":107,"address":[16924656],"length":1,"stats":{"Line":0}},{"line":111,"address":[16394554,16394850,16394617,16394668,16394442],"length":1,"stats":{"Line":0}},{"line":113,"address":[16924982],"length":1,"stats":{"Line":0}},{"line":114,"address":[11709854,11710004,11710052,11710108,11710242],"length":1,"stats":{"Line":0}},{"line":115,"address":[17166174],"length":1,"stats":{"Line":0}},{"line":120,"address":[17166352],"length":1,"stats":{"Line":0}},{"line":123,"address":[10963828],"length":1,"stats":{"Line":0}},{"line":124,"address":[16395703],"length":1,"stats":{"Line":0}},{"line":129,"address":[16926224],"length":1,"stats":{"Line":0}},{"line":143,"address":[16396668,16396280,16396395,16396332],"length":1,"stats":{"Line":0}},{"line":144,"address":[17398945],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","p2p_commands.rs"],"content":"use crate::{\n    infrastructure::p2p::metrics::GossipMetricDetails,\n    presentation::dto::{\n        ApiResponse,\n        p2p::{\n            BootstrapConfigResponse, BroadcastRequest, GossipMetricDetailsResponse,\n            GossipMetricsResponse, JoinTopicByNameRequest, JoinTopicByNameResponse,\n            JoinTopicRequest, LeaveTopicRequest, MainlineMetricsResponse, NodeAddressResponse,\n            P2PMetricsResponse, P2PStatusResponse,\n        },\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\n/// P2P機能を初期化\n#[tauri::command]\npub async fn initialize_p2p(state: State<'_, AppState>) -> Result<ApiResponse<()>, AppError> {\n    let result = state.p2p_handler.initialize_p2p().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pトピックに参加\n#[tauri::command]\npub async fn join_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    #[allow(non_snake_case)] initialPeers: Vec<String>,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = JoinTopicRequest {\n        topic_id: topicId.clone(),\n        initial_peers: initialPeers,\n    };\n    let topic_id = request.topic_id.clone();\n\n    match state.p2p_handler.join_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.ensure_ui_subscription(&topic_id).await {\n                tracing::warn!(\"Failed to ensure UI subscription for {}: {}\", topic_id, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// P2Pトピックから離脱\n#[tauri::command]\npub async fn leave_p2p_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = LeaveTopicRequest {\n        topic_id: topicId.clone(),\n    };\n    match state.p2p_handler.leave_topic(request).await {\n        Ok(_) => {\n            if let Err(e) = state.stop_ui_subscription(&topicId).await {\n                tracing::warn!(\"Failed to stop UI subscription for {}: {}\", topicId, e);\n            }\n            Ok(ApiResponse::success(()))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n/// トピックにメッセージをブロードキャスト\n#[tauri::command]\npub async fn broadcast_to_topic(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicId: String,\n    content: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = BroadcastRequest {\n        topic_id: topicId,\n        content,\n    };\n    let result = state.p2p_handler.broadcast_to_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// P2Pステータスを取得\n#[tauri::command]\npub async fn get_p2p_status(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<P2PStatusResponse>, AppError> {\n    let result = state.p2p_handler.get_p2p_status().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ノードアドレスを取得\n#[tauri::command]\npub async fn get_node_address(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<NodeAddressResponse>, AppError> {\n    let result = state.p2p_handler.get_node_address().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピック名で参加\n#[tauri::command]\npub async fn join_topic_by_name(\n    state: State<'_, AppState>,\n    #[allow(non_snake_case)] topicName: String,\n    #[allow(non_snake_case)] initialPeers: Vec<String>,\n) -> Result<ApiResponse<JoinTopicByNameResponse>, AppError> {\n    let request = JoinTopicByNameRequest {\n        topic_name: topicName,\n        initial_peers: initialPeers,\n    };\n    match state.p2p_handler.join_topic_by_name(request).await {\n        Ok(response) => {\n            if let Err(e) = state.ensure_ui_subscription(&response.topic_id).await {\n                tracing::warn!(\n                    \"Failed to ensure UI subscription for {}: {}\",\n                    response.topic_id,\n                    e\n                );\n            }\n            Ok(ApiResponse::success(response))\n        }\n        Err(err) => Ok(ApiResponse::from_app_error(err)),\n    }\n}\n\n// ================= Bootstrap UI コマンド =================\n\n#[tauri::command]\npub async fn get_bootstrap_config() -> Result<ApiResponse<BootstrapConfigResponse>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n    let nodes = bootstrap_config::load_user_bootstrap_nodes();\n    let mode = if nodes.is_empty() {\n        \"default\".to_string()\n    } else {\n        \"custom\".to_string()\n    };\n    Ok(ApiResponse::success(BootstrapConfigResponse {\n        mode,\n        nodes,\n    }))\n}\n\n#[tauri::command]\npub async fn set_bootstrap_nodes(nodes: Vec<String>) -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n    bootstrap_config::save_user_bootstrap_nodes(&nodes)\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n#[tauri::command]\npub async fn clear_bootstrap_nodes() -> Result<ApiResponse<()>, AppError> {\n    use crate::infrastructure::p2p::bootstrap_config;\n    bootstrap_config::clear_user_bootstrap_nodes()\n        .map_err(|e| AppError::ConfigurationError(e.to_string()))?;\n    Ok(ApiResponse::success(()))\n}\n\n/// Gossipメトリクスを取得\n#[tauri::command]\npub async fn get_p2p_metrics() -> Result<ApiResponse<P2PMetricsResponse>, AppError> {\n    use crate::infrastructure::p2p::metrics;\n    let snap = metrics::snapshot_full();\n    let response = P2PMetricsResponse {\n        gossip: GossipMetricsResponse {\n            joins: snap.gossip.joins,\n            leaves: snap.gossip.leaves,\n            broadcasts_sent: snap.gossip.broadcasts_sent,\n            messages_received: snap.gossip.messages_received,\n            join_details: to_response_details(&snap.gossip.join_details),\n            leave_details: to_response_details(&snap.gossip.leave_details),\n            broadcast_details: to_response_details(&snap.gossip.broadcast_details),\n            receive_details: to_response_details(&snap.gossip.receive_details),\n        },\n        mainline: MainlineMetricsResponse {\n            connected_peers: snap.mainline.connected_peers,\n            connection_attempts: snap.mainline.connection_attempts,\n            connection_successes: snap.mainline.connection_successes,\n            connection_failures: snap.mainline.connection_failures,\n            connection_last_success_ms: snap.mainline.connection_last_success_ms,\n            connection_last_failure_ms: snap.mainline.connection_last_failure_ms,\n            routing_attempts: snap.mainline.routing_attempts,\n            routing_successes: snap.mainline.routing_successes,\n            routing_failures: snap.mainline.routing_failures,\n            routing_success_rate: snap.mainline.routing_success_rate,\n            routing_last_success_ms: snap.mainline.routing_last_success_ms,\n            routing_last_failure_ms: snap.mainline.routing_last_failure_ms,\n            reconnect_attempts: snap.mainline.reconnect_attempts,\n            reconnect_successes: snap.mainline.reconnect_successes,\n            reconnect_failures: snap.mainline.reconnect_failures,\n            last_reconnect_success_ms: snap.mainline.last_reconnect_success_ms,\n            last_reconnect_failure_ms: snap.mainline.last_reconnect_failure_ms,\n        },\n    };\n    Ok(ApiResponse::success(response))\n}\n\nfn to_response_details(details: &GossipMetricDetails) -> GossipMetricDetailsResponse {\n    GossipMetricDetailsResponse {\n        total: details.total,\n        failures: details.failures,\n        last_success_ms: details.last_success_ms,\n        last_failure_ms: details.last_failure_ms,\n    }\n}\n","traces":[{"line":19,"address":[16379283,16379240,16379232,16379410,16379589,16379248,16379370,16379913],"length":1,"stats":{"Line":0}},{"line":20,"address":[16379459,16379397,16379345,16379621],"length":1,"stats":{"Line":0}},{"line":21,"address":[13249831],"length":1,"stats":{"Line":0}},{"line":26,"address":[12478720],"length":1,"stats":{"Line":0}},{"line":32,"address":[13036164],"length":1,"stats":{"Line":0}},{"line":35,"address":[16380523],"length":1,"stats":{"Line":0}},{"line":37,"address":[10907980],"length":1,"stats":{"Line":0}},{"line":39,"address":[13036246,13037150,13037249,13037488],"length":1,"stats":{"Line":0}},{"line":40,"address":[16382454,16381852,16381953,16384233,16384367],"length":1,"stats":{"Line":0}},{"line":42,"address":[13013059],"length":1,"stats":{"Line":0}},{"line":44,"address":[18729369,18729596],"length":1,"stats":{"Line":0}},{"line":50,"address":[13040592],"length":1,"stats":{"Line":0}},{"line":55,"address":[16384880],"length":1,"stats":{"Line":0}},{"line":57,"address":[18940329],"length":1,"stats":{"Line":0}},{"line":59,"address":[13014940,13014146,13015179,13014847],"length":1,"stats":{"Line":0}},{"line":60,"address":[13042792,13042190,13044441,13042291,13044575],"length":1,"stats":{"Line":0}},{"line":62,"address":[13017471],"length":1,"stats":{"Line":0}},{"line":64,"address":[13041614,13041842],"length":1,"stats":{"Line":0}},{"line":70,"address":[12487744],"length":1,"stats":{"Line":0}},{"line":79,"address":[12488046,12488098,12488386,12488161],"length":1,"stats":{"Line":0}},{"line":80,"address":[13045719],"length":1,"stats":{"Line":0}},{"line":85,"address":[18739216],"length":1,"stats":{"Line":0}},{"line":88,"address":[10880996],"length":1,"stats":{"Line":0}},{"line":89,"address":[13260656],"length":1,"stats":{"Line":0}},{"line":94,"address":[13046672],"length":1,"stats":{"Line":0}},{"line":97,"address":[13046837,13046899,13046785,13047061],"length":1,"stats":{"Line":0}},{"line":98,"address":[13047255],"length":1,"stats":{"Line":0}},{"line":103,"address":[16391456],"length":1,"stats":{"Line":0}},{"line":112,"address":[13047876,13047728,13047789,13048117],"length":1,"stats":{"Line":0}},{"line":113,"address":[16392472],"length":1,"stats":{"Line":0}},{"line":114,"address":[16392646,16391890,16392508,16392919],"length":1,"stats":{"Line":0}},{"line":115,"address":[13265631,13263210,13265497,13263812,13263311],"length":1,"stats":{"Line":0}},{"line":121,"address":[13265227],"length":1,"stats":{"Line":0}},{"line":123,"address":[13048738,13048459],"length":1,"stats":{"Line":0}},{"line":130,"address":[13025150,13025207,13025120,13025104,13025237,13025664],"length":1,"stats":{"Line":0}},{"line":132,"address":[16395999],"length":1,"stats":{"Line":0}},{"line":133,"address":[13266112,13266182],"length":1,"stats":{"Line":0}},{"line":134,"address":[18745908,18746085],"length":1,"stats":{"Line":0}},{"line":136,"address":[13052092,13052151],"length":1,"stats":{"Line":0}},{"line":138,"address":[16396293,16396386],"length":1,"stats":{"Line":0}},{"line":139,"address":[12495017],"length":1,"stats":{"Line":0}},{"line":140,"address":[18745967],"length":1,"stats":{"Line":0}},{"line":145,"address":[18746240,18746789,18746243,18746302,18746272,18746383,18746684],"length":1,"stats":{"Line":0}},{"line":147,"address":[13266891,13266662,13266759],"length":1,"stats":{"Line":0}},{"line":148,"address":[12495936,12495954,12495633],"length":1,"stats":{"Line":0}},{"line":149,"address":[18746604,18746538],"length":1,"stats":{"Line":0}},{"line":153,"address":[16397670,16397296,16397312,16397390,16397341],"length":1,"stats":{"Line":0}},{"line":155,"address":[13026852,13026749,13026558,13026639],"length":1,"stats":{"Line":0}},{"line":156,"address":[18747376,18747399,18747203],"length":1,"stats":{"Line":0}},{"line":157,"address":[18747259,18747196],"length":1,"stats":{"Line":0}},{"line":162,"address":[13053896,13054991,13053776,13053792,13053835],"length":1,"stats":{"Line":0}},{"line":164,"address":[18747629],"length":1,"stats":{"Line":0}},{"line":166,"address":[13027408],"length":1,"stats":{"Line":0}},{"line":176,"address":[16398676],"length":1,"stats":{"Line":0}},{"line":196,"address":[18748621],"length":1,"stats":{"Line":0}},{"line":199,"address":[12436480],"length":1,"stats":{"Line":0}},{"line":201,"address":[16337707],"length":1,"stats":{"Line":0}},{"line":202,"address":[18641967],"length":1,"stats":{"Line":0}},{"line":203,"address":[18641971],"length":1,"stats":{"Line":0}},{"line":204,"address":[18641978],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","post_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            post_dto::{\n                BatchBookmarkRequest, BatchGetPostsRequest, BatchReactRequest, BookmarkPostRequest,\n                CreatePostRequest, DeletePostRequest, GetPostsRequest, PostResponse,\n                ReactToPostRequest,\n            },\n        },\n        handlers::PostHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// 投稿を作成する\n#[tauri::command]\npub async fn create_post(\n    state: State<'_, AppState>,\n    request: CreatePostRequest,\n) -> Result<ApiResponse<PostResponse>, AppError> {\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.create_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を取得する\n#[tauri::command]\npub async fn get_posts(\n    state: State<'_, AppState>,\n    request: GetPostsRequest,\n) -> Result<ApiResponse<Vec<PostResponse>>, AppError> {\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.get_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿を削除する\n#[tauri::command]\npub async fn delete_post(\n    state: State<'_, AppState>,\n    request: DeletePostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.delete_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にリアクションする\n#[tauri::command]\npub async fn react_to_post(\n    state: State<'_, AppState>,\n    request: ReactToPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.react_to_post(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブックマークする\n#[tauri::command]\npub async fn bookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.bookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// ブックマークを解除する\n#[tauri::command]\npub async fn unbookmark_post(\n    state: State<'_, AppState>,\n    request: BookmarkPostRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.unbookmark_post(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿にいいねする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn like_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"+\".to_string(),\n    };\n\n    react_to_post(state, request).await\n}\n\n/// ブックマーク済み投稿IDを取得する\n#[tauri::command]\npub async fn get_bookmarked_post_ids(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<String>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.get_bookmarked_post_ids(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n// バッチ処理コマンド\n\n/// 複数の投稿を一括取得する\n#[tauri::command]\npub async fn batch_get_posts(\n    state: State<'_, AppState>,\n    request: BatchGetPostsRequest,\n) -> Result<ApiResponse<Vec<PostResponse>>, AppError> {\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.batch_get_posts(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 複数のリアクションを一括処理する\n#[tauri::command]\npub async fn batch_react(\n    state: State<'_, AppState>,\n    request: BatchReactRequest,\n) -> Result<ApiResponse<Vec<Result<(), String>>>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.batch_react(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 複数のブックマークを一括処理する\n#[tauri::command]\npub async fn batch_bookmark(\n    state: State<'_, AppState>,\n    request: BatchBookmarkRequest,\n) -> Result<ApiResponse<Vec<Result<(), String>>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = PostHandler::new(state.post_service.clone(), state.auth_service.clone());\n    let result = handler.batch_bookmark(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 投稿をブーストする（旧APIとの互換性のため）\n#[tauri::command]\npub async fn boost_post(\n    state: State<'_, AppState>,\n    post_id: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let request = ReactToPostRequest {\n        post_id,\n        reaction: \"boost\".to_string(),\n    };\n\n    react_to_post(state, request).await\n}\n\n/// 単一の投稿を取得する（旧APIとの互換性のため）\n#[tauri::command]\npub async fn get_post(\n    state: State<'_, AppState>,\n    id: String,\n) -> Result<Option<serde_json::Value>, AppError> {\n    state\n        .post_service\n        .get_post(&id)\n        .await?\n        .map(|p| serde_json::to_value(p).map_err(AppError::from))\n        .transpose()\n}\n\n/// トピック別の投稿を取得する（旧APIとの互換性のため）\n#[tauri::command]\npub async fn get_posts_by_topic(\n    state: State<'_, AppState>,\n    topic_id: String,\n    limit: Option<usize>,\n) -> Result<Vec<serde_json::Value>, AppError> {\n    let posts = state\n        .post_service\n        .get_posts_by_topic(&topic_id, limit.unwrap_or(50))\n        .await?;\n\n    posts\n        .into_iter()\n        .map(|p| serde_json::to_value(p).map_err(AppError::from))\n        .collect()\n}\n\n/// 保留中の投稿を同期する\n#[tauri::command]\npub async fn sync_posts(state: State<'_, AppState>) -> Result<u32, AppError> {\n    state.post_service.sync_pending_posts().await\n}\n","traces":[{"line":18,"address":[11914277,11914693,11914093,11913971,11913936,11913928,11914053,11913920],"length":1,"stats":{"Line":0}},{"line":19,"address":[15815358,15815787,15815637,15815253,15815455],"length":1,"stats":{"Line":0}},{"line":22,"address":[11143428],"length":1,"stats":{"Line":0}},{"line":23,"address":[12471856,12471840],"length":1,"stats":{"Line":0}},{"line":24,"address":[12471974,12471952],"length":1,"stats":{"Line":0}},{"line":29,"address":[12537280],"length":1,"stats":{"Line":0}},{"line":33,"address":[12751730,12752244,12751665],"length":1,"stats":{"Line":0}},{"line":34,"address":[12511505,12510885,12511162,12511330],"length":1,"stats":{"Line":0}},{"line":35,"address":[12538446],"length":1,"stats":{"Line":0}},{"line":40,"address":[12538672],"length":1,"stats":{"Line":0}},{"line":44,"address":[11981863,11982361,11981798],"length":1,"stats":{"Line":0}},{"line":45,"address":[14244385],"length":1,"stats":{"Line":0}},{"line":46,"address":[12513052],"length":1,"stats":{"Line":0}},{"line":51,"address":[15884144],"length":1,"stats":{"Line":0}},{"line":55,"address":[19941914,19941975,19942428],"length":1,"stats":{"Line":0}},{"line":56,"address":[12754875,12755050,12754462,12754739],"length":1,"stats":{"Line":0}},{"line":57,"address":[19942719],"length":1,"stats":{"Line":0}},{"line":62,"address":[19942944],"length":1,"stats":{"Line":0}},{"line":66,"address":[12541783,12541655,12541710,12541935],"length":1,"stats":{"Line":0}},{"line":67,"address":[12756431,12756930],"length":1,"stats":{"Line":0}},{"line":68,"address":[15886833,15886704,15887082,15885808],"length":1,"stats":{"Line":0}},{"line":69,"address":[15887276],"length":1,"stats":{"Line":0}},{"line":74,"address":[15887424],"length":1,"stats":{"Line":0}},{"line":78,"address":[10908489],"length":1,"stats":{"Line":0}},{"line":79,"address":[11987036,11987133,11987769],"length":1,"stats":{"Line":0}},{"line":80,"address":[18937228],"length":1,"stats":{"Line":0}},{"line":81,"address":[11988170],"length":1,"stats":{"Line":0}},{"line":86,"address":[11988384],"length":1,"stats":{"Line":0}},{"line":90,"address":[10888089],"length":1,"stats":{"Line":0}},{"line":91,"address":[11989309,11989945,11989212],"length":1,"stats":{"Line":0}},{"line":92,"address":[18943564],"length":1,"stats":{"Line":0}},{"line":93,"address":[12520746],"length":1,"stats":{"Line":0}},{"line":98,"address":[12761792],"length":1,"stats":{"Line":0}},{"line":104,"address":[15891994],"length":1,"stats":{"Line":0}},{"line":107,"address":[12548277,12548157,12547972,12548086],"length":1,"stats":{"Line":0}},{"line":112,"address":[19949808],"length":1,"stats":{"Line":0}},{"line":115,"address":[10932511],"length":1,"stats":{"Line":0}},{"line":116,"address":[12763408,12763505,12763993],"length":1,"stats":{"Line":0}},{"line":117,"address":[11173362],"length":1,"stats":{"Line":0}},{"line":118,"address":[19951385],"length":1,"stats":{"Line":0}},{"line":125,"address":[12523664],"length":1,"stats":{"Line":0}},{"line":129,"address":[11993470,11994001,11993535],"length":1,"stats":{"Line":0}},{"line":130,"address":[11993799,11993522,11993919,11994094],"length":1,"stats":{"Line":0}},{"line":131,"address":[12551428],"length":1,"stats":{"Line":0}},{"line":136,"address":[15895776],"length":1,"stats":{"Line":0}},{"line":140,"address":[12552153,12552016,12551888,12551943],"length":1,"stats":{"Line":0}},{"line":141,"address":[19953606,19954060],"length":1,"stats":{"Line":0}},{"line":142,"address":[10903916],"length":1,"stats":{"Line":0}},{"line":143,"address":[12553396],"length":1,"stats":{"Line":0}},{"line":148,"address":[12526832],"length":1,"stats":{"Line":0}},{"line":152,"address":[14256041],"length":1,"stats":{"Line":0}},{"line":153,"address":[12555135,12554402,12554499],"length":1,"stats":{"Line":0}},{"line":154,"address":[10315444],"length":1,"stats":{"Line":0}},{"line":155,"address":[11998400],"length":1,"stats":{"Line":0}},{"line":160,"address":[12529024],"length":1,"stats":{"Line":0}},{"line":166,"address":[12770074],"length":1,"stats":{"Line":0}},{"line":169,"address":[19957129,19957228,19956932,19957059],"length":1,"stats":{"Line":0}},{"line":174,"address":[12556640],"length":1,"stats":{"Line":0}},{"line":178,"address":[12770920,12771035,12771099,12771145,12771369,12771428,12771578],"length":1,"stats":{"Line":0}},{"line":180,"address":[12771058],"length":1,"stats":{"Line":0}},{"line":181,"address":[15901213,15900956,15901355,15901156,15901530,15901102],"length":1,"stats":{"Line":0}},{"line":182,"address":[15901789,15901776],"length":1,"stats":{"Line":0}},{"line":188,"address":[12771856],"length":1,"stats":{"Line":0}},{"line":193,"address":[12531821,12531499,12531256,12531379,12531545,12531732,12532049],"length":1,"stats":{"Line":0}},{"line":195,"address":[15902218],"length":1,"stats":{"Line":0}},{"line":196,"address":[15902334,15902833,15902388,15902124,15902445,15902580],"length":1,"stats":{"Line":0}},{"line":198,"address":[12001550,12001727],"length":1,"stats":{"Line":0}},{"line":200,"address":[12532432,12532400],"length":1,"stats":{"Line":0}},{"line":206,"address":[19960035,19959968,19959976,19960000,19960319,19960161,19960607,19960121],"length":1,"stats":{"Line":0}},{"line":207,"address":[19960100,19960351,19960148,19960213],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":70},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","secure_storage_commands.rs"],"content":"use crate::{\n    domain::entities::AccountMetadata,\n    presentation::{\n        dto::{ApiResponse, auth_dto::LoginResponse},\n        handlers::secure_storage_handler::{\n            AddAccountRequest, AddAccountResponse, GetCurrentAccountResponse, SecureStorageHandler,\n            SwitchAccountResponse,\n        },\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\n/// アカウントを追加\n#[tauri::command]\npub async fn add_account(\n    state: State<'_, AppState>,\n    request: AddAccountRequest,\n) -> Result<ApiResponse<AddAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.add_account(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウント一覧を取得\n#[tauri::command]\npub async fn list_accounts(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<AccountMetadata>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.list_accounts().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを切り替え\n#[tauri::command]\npub async fn switch_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<SwitchAccountResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.switch_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// アカウントを削除\n#[tauri::command]\npub async fn remove_account(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<()>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.remove_account(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 現在のアカウントを取得\n#[tauri::command]\npub async fn get_current_account(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Option<GetCurrentAccountResponse>>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.get_current_account().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// セキュアログイン\n#[tauri::command]\npub async fn secure_login(\n    state: State<'_, AppState>,\n    npub: String,\n) -> Result<ApiResponse<LoginResponse>, AppError> {\n    let handler = state.secure_storage_handler.clone();\n    let result = handler.secure_login(npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 全てのアカウントデータをクリア（テスト用）\n#[tauri::command]\npub async fn clear_all_accounts_for_test(\n    _state: State<'_, AppState>,\n) -> Result<ApiResponse<()>, AppError> {\n    #[cfg(not(debug_assertions))]\n    {\n        return Err(AppError::ConfigurationError(\n            \"This command is only available in debug builds\".to_string(),\n        ));\n    }\n\n    #[cfg(debug_assertions)]\n    {\n        use crate::infrastructure::storage::secure_storage::DefaultSecureStorage;\n\n        DefaultSecureStorage::clear_all_accounts_for_test()\n            .map_err(|e| AppError::Storage(e.to_string()))?;\n        Ok(ApiResponse::success(()))\n    }\n}\n","traces":[{"line":17,"address":[15903984],"length":1,"stats":{"Line":0}},{"line":21,"address":[12003155,12003040],"length":1,"stats":{"Line":0}},{"line":22,"address":[12003516,12003205,12003280,12003092],"length":1,"stats":{"Line":0}},{"line":23,"address":[12003738],"length":1,"stats":{"Line":0}},{"line":28,"address":[12561168],"length":1,"stats":{"Line":0}},{"line":31,"address":[12561281,12561395],"length":1,"stats":{"Line":0}},{"line":32,"address":[12561333,12561520,12561445,12561654],"length":1,"stats":{"Line":0}},{"line":33,"address":[12535112],"length":1,"stats":{"Line":0}},{"line":38,"address":[15906112],"length":1,"stats":{"Line":0}},{"line":42,"address":[15906307,15906422],"length":1,"stats":{"Line":0}},{"line":43,"address":[12562467,12562636,12562279,12562392],"length":1,"stats":{"Line":0}},{"line":44,"address":[12562858],"length":1,"stats":{"Line":0}},{"line":49,"address":[12563152],"length":1,"stats":{"Line":0}},{"line":53,"address":[12536611,12536726],"length":1,"stats":{"Line":0}},{"line":54,"address":[10376577],"length":1,"stats":{"Line":0}},{"line":55,"address":[12563953],"length":1,"stats":{"Line":0}},{"line":60,"address":[12778288],"length":1,"stats":{"Line":0}},{"line":63,"address":[12537720,12537603],"length":1,"stats":{"Line":0}},{"line":64,"address":[12537845,12537770,12537655,12537969],"length":1,"stats":{"Line":0}},{"line":65,"address":[12564910],"length":1,"stats":{"Line":0}},{"line":70,"address":[13691408],"length":1,"stats":{"Line":0}},{"line":74,"address":[12538515,12538630],"length":1,"stats":{"Line":0}},{"line":75,"address":[12565660,12565303,12565491,12565416],"length":1,"stats":{"Line":0}},{"line":76,"address":[15909978],"length":1,"stats":{"Line":0}},{"line":81,"address":[12780288],"length":1,"stats":{"Line":0}},{"line":95,"address":[12566477,12566288,12566579,12566375],"length":1,"stats":{"Line":0}},{"line":96,"address":[13692742,13692930,13692912],"length":1,"stats":{"Line":0}},{"line":97,"address":[13692735,13692792],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","sync_commands.rs"],"content":"use crate::application::services::SyncService;\nuse crate::presentation::dto::ApiResponse;\nuse crate::shared::AppError;\nuse serde_json::Value;\nuse std::sync::Arc;\nuse tauri::State;\n\n#[tauri::command]\npub async fn start_sync(\n    sync_service: State<'_, Arc<SyncService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = sync_service.start_sync().await.map_err(AppError::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn stop_sync(\n    sync_service: State<'_, Arc<SyncService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = sync_service.stop_sync().await.map_err(AppError::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_sync_status(\n    sync_service: State<'_, Arc<SyncService>>,\n) -> Result<ApiResponse<Value>, AppError> {\n    let status = sync_service.get_status().await;\n    let value = serde_json::to_value(status).map_err(AppError::from)?;\n    Ok(ApiResponse::success(value))\n}\n\n#[tauri::command]\npub async fn reset_sync(\n    sync_service: State<'_, Arc<SyncService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = sync_service.reset_sync().await.map_err(AppError::from);\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn schedule_sync(\n    interval_secs: u64,\n    sync_service: State<'_, Arc<SyncService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    sync_service.schedule_sync(interval_secs).await;\n    Ok(ApiResponse::success(()))\n}\n","traces":[{"line":9,"address":[14898032],"length":1,"stats":{"Line":0}},{"line":12,"address":[14898212,14898164,14898406,14898277],"length":1,"stats":{"Line":0}},{"line":13,"address":[12501971],"length":1,"stats":{"Line":0}},{"line":17,"address":[17743856],"length":1,"stats":{"Line":0}},{"line":20,"address":[17186904,17186852,17186969,17187114],"length":1,"stats":{"Line":0}},{"line":21,"address":[17717731],"length":1,"stats":{"Line":0}},{"line":25,"address":[17187440],"length":1,"stats":{"Line":0}},{"line":28,"address":[14899596,14899789,14899661,14899548],"length":1,"stats":{"Line":0}},{"line":29,"address":[17188038,17188100,17188308],"length":1,"stats":{"Line":0}},{"line":30,"address":[17959646,17959473],"length":1,"stats":{"Line":0}},{"line":34,"address":[14900464],"length":1,"stats":{"Line":0}},{"line":37,"address":[17188676,17188728,17188793,17188938],"length":1,"stats":{"Line":0}},{"line":38,"address":[17746291],"length":1,"stats":{"Line":0}},{"line":42,"address":[12504624],"length":1,"stats":{"Line":0}},{"line":46,"address":[14901549,14901303,14901413,14901351],"length":1,"stats":{"Line":0}},{"line":47,"address":[14901709],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","topic_commands.rs"],"content":"use crate::{\n    presentation::{\n        dto::{\n            ApiResponse,\n            topic_dto::{\n                CreateTopicRequest, DeleteTopicRequest, GetTopicStatsRequest, JoinTopicRequest,\n                TopicResponse, TopicStatsResponse, UpdateTopicRequest,\n            },\n        },\n        handlers::TopicHandler,\n    },\n    shared::AppError,\n    state::AppState,\n};\nuse tauri::State;\n\nasync fn ensure_authenticated(state: &State<'_, AppState>) -> Result<String, AppError> {\n    state\n        .key_manager\n        .current_keypair()\n        .await\n        .map(|pair| pair.public_key.clone())\n        .map_err(|e| AppError::Unauthorized(format!(\"ログインが必要です: {e}\")))\n}\n\n/// トピックを作成する\n#[tauri::command]\npub async fn create_topic(\n    state: State<'_, AppState>,\n    request: CreateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.create_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 単一のトピックを取得する\n#[tauri::command]\npub async fn get_topic(\n    state: State<'_, AppState>,\n    id: String,\n) -> Result<ApiResponse<Option<TopicResponse>>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_topic(&id).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// すべてのトピックを取得する\n#[tauri::command]\npub async fn get_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<TopicResponse>>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_all_topics().await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// 参加中のトピックを取得する\n#[tauri::command]\npub async fn get_joined_topics(\n    state: State<'_, AppState>,\n) -> Result<ApiResponse<Vec<TopicResponse>>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_joined_topics(&user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを更新する\n#[tauri::command]\npub async fn update_topic(\n    state: State<'_, AppState>,\n    request: UpdateTopicRequest,\n) -> Result<ApiResponse<TopicResponse>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.update_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックを削除する\n#[tauri::command]\npub async fn delete_topic(\n    state: State<'_, AppState>,\n    request: DeleteTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.delete_topic(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックに参加する\n#[tauri::command]\npub async fn join_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.join_topic(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックから離脱する\n#[tauri::command]\npub async fn leave_topic(\n    state: State<'_, AppState>,\n    request: JoinTopicRequest,\n) -> Result<ApiResponse<()>, AppError> {\n    let user_pubkey = ensure_authenticated(&state).await?;\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.leave_topic(request, &user_pubkey).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n/// トピックの統計情報を取得する\n#[tauri::command]\npub async fn get_topic_stats(\n    state: State<'_, AppState>,\n    request: GetTopicStatsRequest,\n) -> Result<ApiResponse<TopicStatsResponse>, AppError> {\n    let handler = TopicHandler::new(state.topic_service.clone());\n    let result = handler.get_topic_stats(request).await;\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":17,"address":[12911872,12912005,12911880,12912228,12912045,12911923,12912644,12911888],"length":1,"stats":{"Line":0}},{"line":18,"address":[18368063,18368394,18367966,18368244,18367861],"length":1,"stats":{"Line":0}},{"line":21,"address":[15979541,15979741,15979448,15979488,15979324],"length":1,"stats":{"Line":0}},{"line":22,"address":[18154448,18154432],"length":1,"stats":{"Line":0}},{"line":23,"address":[18368640,18368662],"length":1,"stats":{"Line":0}},{"line":28,"address":[18416288],"length":1,"stats":{"Line":0}},{"line":32,"address":[18416820,18416542,18416670,18416597],"length":1,"stats":{"Line":0}},{"line":33,"address":[18176385],"length":1,"stats":{"Line":0}},{"line":34,"address":[10312215],"length":1,"stats":{"Line":0}},{"line":35,"address":[16067366],"length":1,"stats":{"Line":0}},{"line":40,"address":[18177296],"length":1,"stats":{"Line":0}},{"line":44,"address":[18418412,18418297],"length":1,"stats":{"Line":0}},{"line":45,"address":[11115793],"length":1,"stats":{"Line":0}},{"line":46,"address":[16068316],"length":1,"stats":{"Line":0}},{"line":51,"address":[17647984],"length":1,"stats":{"Line":0}},{"line":54,"address":[18205347,18205233],"length":1,"stats":{"Line":0}},{"line":55,"address":[11118804],"length":1,"stats":{"Line":0}},{"line":56,"address":[18179052],"length":1,"stats":{"Line":0}},{"line":61,"address":[18179248],"length":1,"stats":{"Line":0}},{"line":64,"address":[14268223],"length":1,"stats":{"Line":0}},{"line":65,"address":[12965028,12964887],"length":1,"stats":{"Line":0}},{"line":66,"address":[16069494,16070160,16070262,16070395],"length":1,"stats":{"Line":0}},{"line":67,"address":[18421415],"length":1,"stats":{"Line":0}},{"line":72,"address":[18207472],"length":1,"stats":{"Line":0}},{"line":76,"address":[17650607,17650662,17650735,17650885],"length":1,"stats":{"Line":0}},{"line":77,"address":[17651282],"length":1,"stats":{"Line":0}},{"line":78,"address":[14254159],"length":1,"stats":{"Line":0}},{"line":79,"address":[16072415],"length":1,"stats":{"Line":0}},{"line":84,"address":[18423440],"length":1,"stats":{"Line":0}},{"line":88,"address":[14253753,14253821],"length":1,"stats":{"Line":0}},{"line":89,"address":[18424279],"length":1,"stats":{"Line":0}},{"line":90,"address":[14253772],"length":1,"stats":{"Line":0}},{"line":91,"address":[18424909],"length":1,"stats":{"Line":0}},{"line":96,"address":[18210976],"length":1,"stats":{"Line":0}},{"line":100,"address":[18184560,18184432,18185024,18184487,18184699],"length":1,"stats":{"Line":0}},{"line":101,"address":[18425831,18425972],"length":1,"stats":{"Line":0}},{"line":102,"address":[11119020],"length":1,"stats":{"Line":0}},{"line":103,"address":[18212614],"length":1,"stats":{"Line":0}},{"line":108,"address":[18212784],"length":1,"stats":{"Line":0}},{"line":112,"address":[18427072,18427200,18427127,18427339,18427664],"length":1,"stats":{"Line":0}},{"line":113,"address":[18427780,18427639],"length":1,"stats":{"Line":0}},{"line":114,"address":[18427851,18427145,18428159,18428106,18428324],"length":1,"stats":{"Line":0}},{"line":115,"address":[18214422],"length":1,"stats":{"Line":0}},{"line":120,"address":[17657456],"length":1,"stats":{"Line":0}},{"line":124,"address":[18214902,18214787],"length":1,"stats":{"Line":0}},{"line":125,"address":[17657837,17658057,17657954,17657703],"length":1,"stats":{"Line":0}},{"line":126,"address":[16078304],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","user_commands.rs"],"content":"use crate::application::services::UserService;\nuse crate::domain::entities::UserMetadata;\nuse crate::presentation::dto::ApiResponse;\nuse crate::shared::AppError;\nuse serde_json::Value;\nuse std::sync::Arc;\nuse tauri::State;\n\n#[tauri::command]\npub async fn get_user(\n    npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service.get_user(&npub).await.and_then(|user| {\n        user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n            .transpose()\n    });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_user_by_pubkey(\n    pubkey: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Option<Value>>, AppError> {\n    let result = user_service\n        .get_user_by_pubkey(&pubkey)\n        .await\n        .and_then(|user| {\n            user.map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .transpose()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn update_profile(\n    npub: String,\n    metadata: UserMetadata,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service.update_profile(&npub, metadata).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn follow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service.follow_user(&follower_npub, &target_npub).await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn unfollow_user(\n    follower_npub: String,\n    target_npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<()>, AppError> {\n    let result = user_service\n        .unfollow_user(&follower_npub, &target_npub)\n        .await;\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_followers(\n    npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Vec<Value>>, AppError> {\n    let result = user_service\n        .get_followers(&npub)\n        .await\n        .and_then(|followers| {\n            followers\n                .into_iter()\n                .map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .collect::<Result<Vec<_>, _>>()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n\n#[tauri::command]\npub async fn get_following(\n    npub: String,\n    user_service: State<'_, Arc<UserService>>,\n) -> Result<ApiResponse<Vec<Value>>, AppError> {\n    let result = user_service\n        .get_following(&npub)\n        .await\n        .and_then(|following| {\n            following\n                .into_iter()\n                .map(|u| serde_json::to_value(u).map_err(AppError::from))\n                .collect::<Result<Vec<_>, _>>()\n        });\n    Ok(ApiResponse::from_result(result))\n}\n","traces":[{"line":10,"address":[14571024],"length":1,"stats":{"Line":0}},{"line":14,"address":[14812784,14812074,14812137,14812317,14812022],"length":1,"stats":{"Line":0}},{"line":15,"address":[14571966,14572016,14572029],"length":1,"stats":{"Line":0}},{"line":18,"address":[17942526],"length":1,"stats":{"Line":0}},{"line":22,"address":[14598816],"length":1,"stats":{"Line":0}},{"line":26,"address":[17943234,17943496,17943558,17943177,17943277,17943062],"length":1,"stats":{"Line":0}},{"line":27,"address":[17943193],"length":1,"stats":{"Line":0}},{"line":28,"address":[14813514,14813269,14813317,14813373,14813130],"length":1,"stats":{"Line":0}},{"line":29,"address":[14573008],"length":1,"stats":{"Line":0}},{"line":30,"address":[14573072,14573022,14573085],"length":1,"stats":{"Line":0}},{"line":33,"address":[16080231],"length":1,"stats":{"Line":0}},{"line":37,"address":[14573136],"length":1,"stats":{"Line":0}},{"line":42,"address":[14573488,14573433,14573551,14573796],"length":1,"stats":{"Line":0}},{"line":43,"address":[17944816],"length":1,"stats":{"Line":0}},{"line":47,"address":[16081696],"length":1,"stats":{"Line":0}},{"line":52,"address":[17945326,17945441,17945378,17945677],"length":1,"stats":{"Line":0}},{"line":53,"address":[14601794],"length":1,"stats":{"Line":0}},{"line":57,"address":[16082720],"length":1,"stats":{"Line":0}},{"line":62,"address":[14816398,14816626,14816513,14816669,14816851],"length":1,"stats":{"Line":0}},{"line":63,"address":[14575697],"length":1,"stats":{"Line":0}},{"line":64,"address":[14575917,14575861,14575618,14575813,14576051],"length":1,"stats":{"Line":0}},{"line":65,"address":[14576114],"length":1,"stats":{"Line":0}},{"line":69,"address":[14817232],"length":1,"stats":{"Line":0}},{"line":73,"address":[14603302,14603517,14603699,14603791,14603474,14603417],"length":1,"stats":{"Line":0}},{"line":74,"address":[14576697],"length":1,"stats":{"Line":0}},{"line":75,"address":[17947573,17947621,17947811,17947434,17947677],"length":1,"stats":{"Line":0}},{"line":76,"address":[14577312],"length":1,"stats":{"Line":0}},{"line":77,"address":[14577325],"length":1,"stats":{"Line":0}},{"line":79,"address":[14577392,14577424],"length":1,"stats":{"Line":0}},{"line":82,"address":[14577079],"length":1,"stats":{"Line":0}},{"line":86,"address":[14577472],"length":1,"stats":{"Line":0}},{"line":90,"address":[17948851,17948569,17948626,17948454,17948943,17948669],"length":1,"stats":{"Line":0}},{"line":91,"address":[16085041],"length":1,"stats":{"Line":0}},{"line":92,"address":[17948883,17948645,17948693,17948506,17948749],"length":1,"stats":{"Line":0}},{"line":93,"address":[16085616],"length":1,"stats":{"Line":0}},{"line":94,"address":[17949213],"length":1,"stats":{"Line":0}},{"line":96,"address":[16085680,16085712],"length":1,"stats":{"Line":0}},{"line":99,"address":[16085408],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","commands","utils_commands.rs"],"content":"use crate::presentation::dto::ApiResponse;\nuse crate::shared::AppError;\nuse nostr_sdk::prelude::*;\n\n/// 16進数の公開鍵をnpub（Bech32形式）に変換\n#[tauri::command]\npub fn pubkey_to_npub(pubkey: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_hex(&pubkey)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効な公開鍵: {e}\")))?;\n\n    let npub = public_key\n        .to_bech32()\n        .map_err(|e| AppError::InvalidInput(format!(\"Bech32変換エラー: {e}\")))?;\n\n    Ok(ApiResponse::success(npub))\n}\n\n/// npub（Bech32形式）を16進数の公開鍵に変換\n#[tauri::command]\npub fn npub_to_pubkey(npub: String) -> Result<ApiResponse<String>, AppError> {\n    let public_key = PublicKey::from_bech32(&npub)\n        .map_err(|e| AppError::InvalidInput(format!(\"無効なnpub: {e}\")))?;\n\n    Ok(ApiResponse::success(public_key.to_hex()))\n}\n","traces":[{"line":7,"address":[13029015,13028288,13029047],"length":1,"stats":{"Line":0}},{"line":8,"address":[12440030,12440290,12440729,12440106],"length":1,"stats":{"Line":0}},{"line":9,"address":[13269392,13269904,13269920],"length":1,"stats":{"Line":0}},{"line":11,"address":[13269707,13269447,13269363],"length":1,"stats":{"Line":0}},{"line":13,"address":[13056001,13055579,13055984],"length":1,"stats":{"Line":0}},{"line":15,"address":[13028771,13028943],"length":1,"stats":{"Line":0}},{"line":20,"address":[13056575,13056176],"length":1,"stats":{"Line":0}},{"line":21,"address":[13029538,13029470,13029726],"length":1,"stats":{"Line":0}},{"line":22,"address":[12441504,12441534,12441340],"length":1,"stats":{"Line":0}},{"line":24,"address":[12441328,12441404],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","auth_dto.rs"],"content":"use super::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginResponse {\n    pub success: bool,\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct LoginWithNsecRequest {\n    pub nsec: String,\n}\n\nimpl Validate for LoginWithNsecRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.trim().is_empty() {\n            return Err(\"秘密鍵が必要です\".to_string());\n        }\n        if !self.nsec.starts_with(\"nsec1\") {\n            return Err(\"無効な秘密鍵形式です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n}\n","traces":[{"line":17,"address":[17597664],"length":1,"stats":{"Line":0}},{"line":18,"address":[18154832],"length":1,"stats":{"Line":0}},{"line":19,"address":[17597767],"length":1,"stats":{"Line":0}},{"line":21,"address":[12913092],"length":1,"stats":{"Line":0}},{"line":22,"address":[18362383],"length":1,"stats":{"Line":0}},{"line":24,"address":[18362444],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event.rs"],"content":"use crate::application::services::{SubscriptionRecord, SubscriptionTarget};\r\nuse crate::presentation::dto::Validate;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct NostrMetadataDto {\r\n    pub name: Option<String>,\r\n    pub display_name: Option<String>,\r\n    pub about: Option<String>,\r\n    pub picture: Option<String>,\r\n    pub banner: Option<String>,\r\n    pub nip05: Option<String>,\r\n    pub lud16: Option<String>,\r\n    pub website: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTextNoteRequest {\r\n    pub content: String,\r\n}\r\n\r\nimpl Validate for PublishTextNoteRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct PublishTopicPostRequest {\r\n    pub topic_id: String,\r\n    pub content: String,\r\n    pub reply_to: Option<String>,\r\n}\r\n\r\nimpl Validate for PublishTopicPostRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        if self.content.is_empty() {\r\n            return Err(\"Content cannot be empty\".to_string());\r\n        }\r\n        if self.content.len() > 10000 {\r\n            return Err(\"Content is too long (max 10000 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SendReactionRequest {\r\n    pub event_id: String,\r\n    pub reaction: String,\r\n}\r\n\r\nimpl Validate for SendReactionRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.event_id.is_empty() {\r\n            return Err(\"Event ID is required\".to_string());\r\n        }\r\n        if self.reaction.is_empty() {\r\n            return Err(\"Reaction cannot be empty\".to_string());\r\n        }\r\n        if self.reaction.len() > 20 {\r\n            return Err(\"Reaction is too long (max 20 characters)\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct UpdateMetadataRequest {\r\n    pub metadata: NostrMetadataDto,\r\n}\r\n\r\nimpl Validate for UpdateMetadataRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        // 各フィールドの長さチェック\r\n        if let Some(name) = &self.metadata.name {\r\n            if name.len() > 100 {\r\n                return Err(\"Name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(display_name) = &self.metadata.display_name {\r\n            if display_name.len() > 100 {\r\n                return Err(\"Display name is too long (max 100 characters)\".to_string());\r\n            }\r\n        }\r\n        if let Some(about) = &self.metadata.about {\r\n            if about.len() > 1000 {\r\n                return Err(\"About is too long (max 1000 characters)\".to_string());\r\n            }\r\n        }\r\n        // URLの検証は省略（実際の実装では必要に応じて追加）\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SubscribeRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for SubscribeRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct DeleteEventsRequest {\r\n    pub event_ids: Vec<String>,\r\n    pub reason: Option<String>,\r\n}\r\n\r\nimpl Validate for DeleteEventsRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.event_ids.is_empty() {\r\n            return Err(\"At least one event ID is required\".to_string());\r\n        }\r\n        if self.event_ids.len() > 100 {\r\n            return Err(\"Too many events to delete (max 100)\".to_string());\r\n        }\r\n        if let Some(reason) = &self.reason {\r\n            if reason.len() > 500 {\r\n                return Err(\"Reason is too long (max 500 characters)\".to_string());\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct EventResponse {\r\n    pub event_id: String,\r\n    pub success: bool,\r\n    pub message: Option<String>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SetDefaultP2PTopicRequest {\r\n    pub topic_id: String,\r\n}\r\n\r\nimpl Validate for SetDefaultP2PTopicRequest {\r\n    fn validate(&self) -> Result<(), String> {\r\n        if self.topic_id.is_empty() {\r\n            return Err(\"Topic ID is required\".to_string());\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct NostrSubscriptionStateDto {\r\n    pub target: String,\r\n    pub target_type: String,\r\n    pub status: String,\r\n    pub last_synced_at: Option<i64>,\r\n    pub last_attempt_at: Option<i64>,\r\n    pub failure_count: i64,\r\n    pub error_message: Option<String>,\r\n}\r\n\r\nimpl From<SubscriptionRecord> for NostrSubscriptionStateDto {\r\n    fn from(record: SubscriptionRecord) -> Self {\r\n        let (target_type, target_value) = match record.target {\r\n            SubscriptionTarget::Topic(id) => (\"topic\".to_string(), id),\r\n            SubscriptionTarget::User(id) => (\"user\".to_string(), id),\r\n        };\r\n        Self {\r\n            target: target_value,\r\n            target_type,\r\n            status: record.status.as_str().to_string(),\r\n            last_synced_at: record.last_synced_at,\r\n            last_attempt_at: record.last_attempt_at,\r\n            failure_count: record.failure_count,\r\n            error_message: record.error_message,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[12871584],"length":1,"stats":{"Line":0}},{"line":24,"address":[16772832],"length":1,"stats":{"Line":0}},{"line":25,"address":[12871645],"length":1,"stats":{"Line":0}},{"line":27,"address":[12871630],"length":1,"stats":{"Line":0}},{"line":28,"address":[13428857],"length":1,"stats":{"Line":0}},{"line":30,"address":[16772922],"length":1,"stats":{"Line":0}},{"line":42,"address":[13402192],"length":1,"stats":{"Line":0}},{"line":43,"address":[13402222],"length":1,"stats":{"Line":0}},{"line":44,"address":[13428986],"length":1,"stats":{"Line":0}},{"line":46,"address":[13402235],"length":1,"stats":{"Line":0}},{"line":47,"address":[16773148],"length":1,"stats":{"Line":0}},{"line":49,"address":[13402313],"length":1,"stats":{"Line":0}},{"line":50,"address":[13429144],"length":1,"stats":{"Line":0}},{"line":52,"address":[13643225],"length":1,"stats":{"Line":0}},{"line":63,"address":[12872080],"length":1,"stats":{"Line":0}},{"line":64,"address":[11785934],"length":1,"stats":{"Line":0}},{"line":65,"address":[13402538],"length":1,"stats":{"Line":0}},{"line":67,"address":[13643355],"length":1,"stats":{"Line":0}},{"line":68,"address":[12872218],"length":1,"stats":{"Line":0}},{"line":70,"address":[16773417],"length":1,"stats":{"Line":0}},{"line":71,"address":[11786118],"length":1,"stats":{"Line":0}},{"line":73,"address":[13429415],"length":1,"stats":{"Line":0}},{"line":83,"address":[11786192],"length":1,"stats":{"Line":0}},{"line":85,"address":[13643627],"length":1,"stats":{"Line":0}},{"line":86,"address":[13402838],"length":1,"stats":{"Line":0}},{"line":87,"address":[11786323],"length":1,"stats":{"Line":0}},{"line":90,"address":[16773670,16773787],"length":1,"stats":{"Line":0}},{"line":91,"address":[12872579],"length":1,"stats":{"Line":0}},{"line":92,"address":[16773856],"length":1,"stats":{"Line":0}},{"line":95,"address":[13402995,13403104],"length":1,"stats":{"Line":0}},{"line":96,"address":[11786536],"length":1,"stats":{"Line":0}},{"line":97,"address":[16773964],"length":1,"stats":{"Line":0}},{"line":101,"address":[11786554],"length":1,"stats":{"Line":0}},{"line":111,"address":[12872816],"length":1,"stats":{"Line":0}},{"line":112,"address":[13429982],"length":1,"stats":{"Line":0}},{"line":113,"address":[13430011],"length":1,"stats":{"Line":0}},{"line":115,"address":[13429996],"length":1,"stats":{"Line":0}},{"line":126,"address":[11786768],"length":1,"stats":{"Line":0}},{"line":127,"address":[13644208],"length":1,"stats":{"Line":0}},{"line":128,"address":[16774221],"length":1,"stats":{"Line":0}},{"line":130,"address":[11786815],"length":1,"stats":{"Line":0}},{"line":131,"address":[16774329],"length":1,"stats":{"Line":0}},{"line":133,"address":[12873173,12873069],"length":1,"stats":{"Line":0}},{"line":134,"address":[11787002],"length":1,"stats":{"Line":0}},{"line":135,"address":[16774427],"length":1,"stats":{"Line":0}},{"line":138,"address":[13644428],"length":1,"stats":{"Line":0}},{"line":155,"address":[13403680],"length":1,"stats":{"Line":0}},{"line":156,"address":[16774526],"length":1,"stats":{"Line":0}},{"line":157,"address":[11787163],"length":1,"stats":{"Line":0}},{"line":159,"address":[16774540],"length":1,"stats":{"Line":0}},{"line":175,"address":[13645784,13644640,13645155],"length":1,"stats":{"Line":0}},{"line":176,"address":[13644662,13644994],"length":1,"stats":{"Line":0}},{"line":177,"address":[13430711,13430593],"length":1,"stats":{"Line":0}},{"line":178,"address":[12873517,12873955],"length":1,"stats":{"Line":0}},{"line":183,"address":[13645127,13645425],"length":1,"stats":{"Line":0}},{"line":184,"address":[13645459],"length":1,"stats":{"Line":0}},{"line":185,"address":[11788055],"length":1,"stats":{"Line":0}},{"line":186,"address":[11788063],"length":1,"stats":{"Line":0}},{"line":187,"address":[11788067],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","event_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct EventResponse {\n    pub id: String,\n    pub kind: u32,\n    pub pubkey: String,\n    pub content: String,\n    pub tags: Vec<Vec<String>>,\n    pub created_at: i64,\n    pub sig: String,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","mod.rs"],"content":"// DTOモジュール\npub mod auth_dto;\npub mod event;\npub mod offline;\npub mod p2p;\npub mod post_dto;\npub mod topic_dto;\npub mod user_dto;\n\n// 共通のレスポンス型\nuse crate::shared::AppError;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ApiResponse<T> {\n    pub success: bool,\n    pub data: Option<T>,\n    pub error: Option<String>,\n    pub error_code: Option<String>,\n}\n\nimpl<T> ApiResponse<T> {\n    pub fn success(data: T) -> Self {\n        Self {\n            success: true,\n            data: Some(data),\n            error: None,\n            error_code: None,\n        }\n    }\n\n    pub fn error(error: String) -> Self {\n        Self {\n            success: false,\n            data: None,\n            error: Some(error),\n            error_code: None,\n        }\n    }\n\n    pub fn from_app_error(error: AppError) -> Self {\n        Self {\n            success: false,\n            data: None,\n            error: Some(error.user_message()),\n            error_code: Some(error.code().to_string()),\n        }\n    }\n\n    pub fn from_result(result: crate::shared::Result<T>) -> Self {\n        match result {\n            Ok(data) => Self::success(data),\n            Err(err) => Self::from_app_error(err),\n        }\n    }\n}\n\n// ページネーション\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PaginationRequest {\n    pub limit: Option<u32>,\n    pub offset: Option<u32>,\n}\n\nimpl Default for PaginationRequest {\n    fn default() -> Self {\n        Self {\n            limit: Some(50),\n            offset: Some(0),\n        }\n    }\n}\n\n// バリデーショントレイト\npub trait Validate {\n    fn validate(&self) -> Result<(), String>;\n}\n","traces":[{"line":23,"address":[11579424,11578032,11578336,11575904,11578176,11577168,11576480,11580048,11579744,11576048,11579616,11576848,11580256,11579072,11577472,11576336,11578704,11576720,11579888,11580560,11580848,11579216,11577680,11577328,11576608,11576192,11578528,11580704,11577840,11578864,11581024,11577008,11580400],"length":1,"stats":{"Line":0}},{"line":26,"address":[16793920,16793393,16794787,16795454,16792528,16791528,16793230,16794273,16792897,16791775,16790947,16791904,16795747,16792062,16793757,16791651,16796067,16793075,16794481,16795105,16792371,16792733,16791379,16791235,16795603,16794115,16791091,16793571,16794663,16794942,16795299,16795891,16792221],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[17783968,17794896,17792064,17789200,17784324,17784749,17785562,17786816,17787216,17785145,17787616,17784345,17791567,17793220,17793650,17794441,17785600,17784768,17792043,17785583,17794020,17786416,17794420,17788032,17786375,17793664,17788800,17792822,17795655,17794464,17789991,17792843,17792864,17790756,17795676,17794041,17788384,17788004,17795239,17789177,17789586,17794064,17792416,17785124,17793264,17786772,17788754,17787597,17793629,17795264,17791616,17794862,17791200,17788775,17790777,17789565,17784368,17785967,17786396,17790374,17790800,17792381,17784728,17787983,17788356,17789600,17790012,17790032,17785988,17794883,17787203,17787182,17785168,17791588,17787576,17789156,17790400,17791181,17793241,17786016,17786793,17791160,17792022],"length":1,"stats":{"Line":0}},{"line":45,"address":[16270942,16274613,16270507,16272149,16276795,16265910,16268435,16270569,16275477,16276389,16276857,16277654,16270101,16269734,16267125,16268789,16272949,16271317,16269253,16271733,16266709,16274259,16267187,16272621,16272211,16273365,16271795,16269315,16275984,16277589,16272559,16273011,16273846,16268373,16277227,16275542,16274197,16270163,16276451,16268044,16271379,16268854,16275045,16277289,16275110,16266771,16273781,16266326,16269669,16267982,16266261,16267541,16274678,16273427,16265845,16271004,16267606,16275919],"length":1,"stats":{"Line":0}},{"line":46,"address":[17041415,17042698,17042323,17043463,17046368,17044330,17048112,17047770,17048181,17045578,17044679,17042256,17048990,17047703,17037662,17044263,17043114,17047318,17038942,17047248,17042631,17045936,17041824,17043047,17043942,17040190,17046806,17048541,17043530,17040634,17044746,17039687,17038439,17039296,17037590,17037235,17041061,17040118,17037168,17038093,17039754,17039365,17040992,17046878,17038870,17041893,17043873,17046437,17048918,17046005,17040567,17045171,17038026,17045104,17048608,17041482,17038506,17045511],"length":1,"stats":{"Line":0}},{"line":50,"address":[16837248,16835152,16835312,16837424,16838544,16838704,16837584,16839184,16839472,16838880,16835952,16839312,16835472,16837904,16838064,16839024,16836576,16837744,16836896,16836416,16837072,16838400,16838224,16836736,16835792,16836256,16835632,16836112],"length":1,"stats":{"Line":0}},{"line":51,"address":[16278835,16280133,16280467,16281907,16282067,16282195,16282357,16279957,16281283,16279781,16278995,16279299,16278195,16278675,16281589,16278514,16279139,16278035,16280306,16280627,16280787,16281110,16279618,16281427,16281762,16279458,16278355,16280946],"length":1,"stats":{"Line":0}},{"line":52,"address":[17052690,17052855,17053174,17053325,17053024,17053458,17049298,17051399,17050884,17053623,17050406,17050098,17052050,17052546,17052368,17050562,17049458,17050258,17049618,17050705,17049780,17049942,17051047,17051223,17051572,17051730,17051890,17052193],"length":1,"stats":{"Line":0}},{"line":53,"address":[16808676,16811739,16808516,16812065,16812385,16812511,16811579,16809453,16809780,16810257,16810782,16811268,16809931,16811908,16812833,16809153,16808990,16810433,16812676,16809617,16809316,16812230,16810094,16811108,16810609,16810948,16811419,16808836],"length":1,"stats":{"Line":0}},{"line":66,"address":[16839648],"length":1,"stats":{"Line":0}},{"line":68,"address":[17800195],"length":1,"stats":{"Line":0}},{"line":69,"address":[17800211],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline.rs"],"content":"use crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OfflineAction {\n    pub id: i64,\n    pub user_pubkey: String,\n    pub action_type: String,\n    pub target_id: Option<String>,\n    pub action_data: String,\n    pub local_id: String,\n    pub remote_id: Option<String>,\n    pub is_synced: bool,\n    pub created_at: i64,\n    pub synced_at: Option<i64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub error_message: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SaveOfflineActionRequest {\n    pub user_pubkey: String,\n    pub action_type: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub data: String,\n}\n\nimpl Validate for SaveOfflineActionRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.user_pubkey.is_empty() {\n            return Err(\"User pubkey is required\".to_string());\n        }\n        if self.action_type.is_empty() {\n            return Err(\"Action type is required\".to_string());\n        }\n        if self.entity_type.is_empty() {\n            return Err(\"Entity type is required\".to_string());\n        }\n        if self.entity_id.is_empty() {\n            return Err(\"Entity ID is required\".to_string());\n        }\n        if self.data.is_empty() {\n            return Err(\"Data is required\".to_string());\n        }\n        if self.data.len() > 200_000 {\n            return Err(\"Data is too large (max 200KB)\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SaveOfflineActionResponse {\n    pub local_id: String,\n    pub action: OfflineAction,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct GetOfflineActionsRequest {\n    pub user_pubkey: Option<String>,\n    pub is_synced: Option<bool>,\n    pub limit: Option<i32>,\n}\n\nimpl Validate for GetOfflineActionsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if let Some(limit) = self.limit {\n            if limit <= 0 || limit > 1000 {\n                return Err(\"Limit must be between 1 and 1000\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncOfflineActionsRequest {\n    pub user_pubkey: String,\n}\n\nimpl Validate for SyncOfflineActionsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.user_pubkey.is_empty() {\n            return Err(\"User pubkey is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct SyncOfflineActionsResponse {\n    pub synced_count: i32,\n    pub failed_count: i32,\n    pub pending_count: i32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CacheTypeStatus {\n    pub cache_type: String,\n    pub item_count: i64,\n    pub last_synced_at: Option<i64>,\n    pub is_stale: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CacheStatusResponse {\n    pub total_items: i64,\n    pub stale_items: i64,\n    pub cache_types: Vec<CacheTypeStatus>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct AddToSyncQueueRequest {\n    pub action_type: String,\n    pub payload: serde_json::Value,\n    pub priority: Option<i32>,\n}\n\nimpl Validate for AddToSyncQueueRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.action_type.is_empty() {\n            return Err(\"Action type is required\".to_string());\n        }\n        if let Some(priority) = self.priority {\n            if !(0..=10).contains(&priority) {\n                return Err(\"Priority must be between 0 and 10\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UpdateCacheMetadataRequest {\n    pub cache_key: String,\n    pub cache_type: String,\n    pub metadata: Option<serde_json::Value>,\n    pub expiry_seconds: Option<i64>,\n}\n\nimpl Validate for UpdateCacheMetadataRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.cache_key.is_empty() {\n            return Err(\"Cache key is required\".to_string());\n        }\n        if self.cache_type.is_empty() {\n            return Err(\"Cache type is required\".to_string());\n        }\n        if let Some(ttl) = self.expiry_seconds {\n            if ttl <= 0 {\n                return Err(\"Expiry seconds must be positive\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OptimisticUpdateRequest {\n    pub entity_type: String,\n    pub entity_id: String,\n    pub original_data: Option<String>,\n    pub updated_data: String,\n}\n\nimpl Validate for OptimisticUpdateRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.entity_type.is_empty() {\n            return Err(\"Entity type is required\".to_string());\n        }\n        if self.entity_id.is_empty() {\n            return Err(\"Entity ID is required\".to_string());\n        }\n        if self.updated_data.is_empty() {\n            return Err(\"Updated data is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct UpdateSyncStatusRequest {\n    pub entity_type: String,\n    pub entity_id: String,\n    pub sync_status: String,\n    pub conflict_data: Option<String>,\n}\n\nimpl Validate for UpdateSyncStatusRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.entity_type.is_empty() {\n            return Err(\"Entity type is required\".to_string());\n        }\n        if self.entity_id.is_empty() {\n            return Err(\"Entity ID is required\".to_string());\n        }\n        if self.sync_status.is_empty() {\n            return Err(\"Sync status is required\".to_string());\n        }\n        let valid_statuses = [\"pending\", \"syncing\", \"synced\", \"failed\", \"conflict\"];\n        if !valid_statuses.contains(&self.sync_status.as_str()) {\n            return Err(format!(\n                \"Invalid sync status. Must be one of: {valid_statuses:?}\"\n            ));\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":32,"address":[15088576],"length":1,"stats":{"Line":0}},{"line":33,"address":[18432694],"length":1,"stats":{"Line":0}},{"line":34,"address":[15088643],"length":1,"stats":{"Line":0}},{"line":36,"address":[15088628],"length":1,"stats":{"Line":0}},{"line":37,"address":[15061986],"length":1,"stats":{"Line":0}},{"line":39,"address":[15302803],"length":1,"stats":{"Line":0}},{"line":40,"address":[15302897],"length":1,"stats":{"Line":0}},{"line":42,"address":[14120482],"length":1,"stats":{"Line":0}},{"line":43,"address":[15302976],"length":1,"stats":{"Line":0}},{"line":45,"address":[15302961],"length":1,"stats":{"Line":0}},{"line":46,"address":[15303059],"length":1,"stats":{"Line":0}},{"line":48,"address":[18433024],"length":1,"stats":{"Line":0}},{"line":49,"address":[14531915],"length":1,"stats":{"Line":0}},{"line":51,"address":[15062300],"length":1,"stats":{"Line":0}},{"line":71,"address":[14120832],"length":1,"stats":{"Line":0}},{"line":72,"address":[15303256],"length":1,"stats":{"Line":0}},{"line":73,"address":[14120881,14120912],"length":1,"stats":{"Line":0}},{"line":74,"address":[15062487],"length":1,"stats":{"Line":0}},{"line":77,"address":[15089197],"length":1,"stats":{"Line":0}},{"line":88,"address":[15089296],"length":1,"stats":{"Line":0}},{"line":89,"address":[15062590],"length":1,"stats":{"Line":0}},{"line":90,"address":[15089355],"length":1,"stats":{"Line":0}},{"line":92,"address":[15089340],"length":1,"stats":{"Line":0}},{"line":130,"address":[14121120],"length":1,"stats":{"Line":0}},{"line":131,"address":[14532318],"length":1,"stats":{"Line":0}},{"line":132,"address":[15089478],"length":1,"stats":{"Line":0}},{"line":134,"address":[15303563,15303634],"length":1,"stats":{"Line":0}},{"line":135,"address":[18433625],"length":1,"stats":{"Line":0}},{"line":136,"address":[14121285],"length":1,"stats":{"Line":0}},{"line":139,"address":[15089574],"length":1,"stats":{"Line":0}},{"line":153,"address":[15089664],"length":1,"stats":{"Line":0}},{"line":154,"address":[14121392],"length":1,"stats":{"Line":0}},{"line":155,"address":[15062993],"length":1,"stats":{"Line":0}},{"line":157,"address":[15303810],"length":1,"stats":{"Line":0}},{"line":158,"address":[14532665],"length":1,"stats":{"Line":0}},{"line":160,"address":[18433942,18433873],"length":1,"stats":{"Line":0}},{"line":161,"address":[15063135],"length":1,"stats":{"Line":0}},{"line":162,"address":[18433977],"length":1,"stats":{"Line":0}},{"line":165,"address":[15063146],"length":1,"stats":{"Line":0}},{"line":179,"address":[14532832],"length":1,"stats":{"Line":0}},{"line":180,"address":[14121694],"length":1,"stats":{"Line":0}},{"line":181,"address":[14121722],"length":1,"stats":{"Line":0}},{"line":183,"address":[15063275],"length":1,"stats":{"Line":0}},{"line":184,"address":[14121800],"length":1,"stats":{"Line":0}},{"line":186,"address":[15090089],"length":1,"stats":{"Line":0}},{"line":187,"address":[18434260],"length":1,"stats":{"Line":0}},{"line":189,"address":[15063429],"length":1,"stats":{"Line":0}},{"line":203,"address":[14121952],"length":1,"stats":{"Line":0}},{"line":204,"address":[15090292],"length":1,"stats":{"Line":0}},{"line":205,"address":[15090320],"length":1,"stats":{"Line":0}},{"line":207,"address":[15090305],"length":1,"stats":{"Line":0}},{"line":208,"address":[14122098],"length":1,"stats":{"Line":0}},{"line":210,"address":[14122079],"length":1,"stats":{"Line":0}},{"line":211,"address":[14122343],"length":1,"stats":{"Line":0}},{"line":213,"address":[18434545],"length":1,"stats":{"Line":0}},{"line":214,"address":[15063852],"length":1,"stats":{"Line":0}},{"line":215,"address":[14122402],"length":1,"stats":{"Line":0}},{"line":219,"address":[14122571],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":58},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","offline_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OfflineActionResponse {\n    pub id: String,\n    pub action_type: String,\n    pub entity_type: String,\n    pub entity_id: String,\n    pub payload: serde_json::Value,\n    pub created_at: i64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p.rs"],"content":"use crate::presentation::dto::Validate;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub connected: bool,\n    pub endpoint_id: String,\n    pub active_topics: Vec<TopicStatus>,\n    pub peer_count: usize,\n    pub metrics_summary: GossipMetricsSummaryResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TopicStatus {\n    pub topic_id: String,\n    pub peer_count: usize,\n    pub message_count: usize,\n    pub last_activity: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinTopicRequest {\n    pub topic_id: String,\n    pub initial_peers: Vec<String>,\n}\n\nimpl Validate for JoinTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        // 初期ピアのフォーマット検証は省略（実際には必要に応じて追加）\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LeaveTopicRequest {\n    pub topic_id: String,\n}\n\nimpl Validate for LeaveTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BroadcastRequest {\n    pub topic_id: String,\n    pub content: String,\n}\n\nimpl Validate for BroadcastRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.is_empty() {\n            return Err(\"Topic ID is required\".to_string());\n        }\n        if self.content.is_empty() {\n            return Err(\"Content cannot be empty\".to_string());\n        }\n        if self.content.len() > 50000 {\n            return Err(\"Content is too large (max 50000 bytes)\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NodeAddressResponse {\n    pub addresses: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BootstrapConfigResponse {\n    pub mode: String,\n    pub nodes: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n    pub join_details: GossipMetricDetailsResponse,\n    pub leave_details: GossipMetricDetailsResponse,\n    pub broadcast_details: GossipMetricDetailsResponse,\n    pub receive_details: GossipMetricDetailsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricDetailsResponse {\n    pub total: u64,\n    pub failures: u64,\n    pub last_success_ms: Option<u64>,\n    pub last_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MainlineMetricsResponse {\n    pub connected_peers: u64,\n    pub connection_attempts: u64,\n    pub connection_successes: u64,\n    pub connection_failures: u64,\n    pub connection_last_success_ms: Option<u64>,\n    pub connection_last_failure_ms: Option<u64>,\n    pub routing_attempts: u64,\n    pub routing_successes: u64,\n    pub routing_failures: u64,\n    pub routing_success_rate: f64,\n    pub routing_last_success_ms: Option<u64>,\n    pub routing_last_failure_ms: Option<u64>,\n    pub reconnect_attempts: u64,\n    pub reconnect_successes: u64,\n    pub reconnect_failures: u64,\n    pub last_reconnect_success_ms: Option<u64>,\n    pub last_reconnect_failure_ms: Option<u64>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct P2PMetricsResponse {\n    pub gossip: GossipMetricsResponse,\n    pub mainline: MainlineMetricsResponse,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMetricsSummaryResponse {\n    pub joins: u64,\n    pub leaves: u64,\n    pub broadcasts_sent: u64,\n    pub messages_received: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinTopicByNameRequest {\n    pub topic_name: String,\n    pub initial_peers: Vec<String>,\n}\n\nimpl Validate for JoinTopicByNameRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_name.is_empty() {\n            return Err(\"Topic name is required\".to_string());\n        }\n        if self.topic_name.len() > 100 {\n            return Err(\"Topic name is too long (max 100 characters)\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JoinTopicByNameResponse {\n    pub topic_id: String,\n}\n","traces":[{"line":28,"address":[17310480],"length":1,"stats":{"Line":0}},{"line":29,"address":[17310510],"length":1,"stats":{"Line":0}},{"line":30,"address":[13409323],"length":1,"stats":{"Line":0}},{"line":33,"address":[14180540],"length":1,"stats":{"Line":0}},{"line":43,"address":[14180624],"length":1,"stats":{"Line":0}},{"line":44,"address":[13939822],"length":1,"stats":{"Line":0}},{"line":45,"address":[13041099],"length":1,"stats":{"Line":0}},{"line":47,"address":[13939836],"length":1,"stats":{"Line":0}},{"line":58,"address":[13409520],"length":1,"stats":{"Line":0}},{"line":59,"address":[13041198],"length":1,"stats":{"Line":0}},{"line":60,"address":[13939978],"length":1,"stats":{"Line":0}},{"line":62,"address":[13966699],"length":1,"stats":{"Line":0}},{"line":63,"address":[14180892],"length":1,"stats":{"Line":0}},{"line":65,"address":[13409641],"length":1,"stats":{"Line":0}},{"line":66,"address":[17310952],"length":1,"stats":{"Line":0}},{"line":68,"address":[17310937],"length":1,"stats":{"Line":0}},{"line":145,"address":[13940208],"length":1,"stats":{"Line":0}},{"line":146,"address":[13940240],"length":1,"stats":{"Line":0}},{"line":147,"address":[13041515],"length":1,"stats":{"Line":0}},{"line":149,"address":[13940254],"length":1,"stats":{"Line":0}},{"line":150,"address":[13041591],"length":1,"stats":{"Line":0}},{"line":152,"address":[13041576],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","p2p_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStatusResponse {\n    pub node_id: String,\n    pub connected_peers: Vec<String>,\n    pub subscribed_topics: Vec<String>,\n    pub stats: P2PStats,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct P2PStats {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub bytes_sent: u64,\n    pub bytes_received: u64,\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","post_dto.rs"],"content":"use super::{PaginationRequest, Validate};\nuse serde::{Deserialize, Serialize};\n\n// レスポンスDTO\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PostResponse {\n    pub id: String,\n    pub content: String,\n    pub author_pubkey: String,\n    pub author_npub: String,\n    pub topic_id: String,\n    pub created_at: i64,\n    pub likes: u32,\n    pub boosts: u32,\n    pub replies: u32,\n    pub is_synced: bool,\n}\n\n// リクエストDTO\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreatePostRequest {\n    pub content: String,\n    pub topic_id: String,\n    pub media_urls: Option<Vec<String>>,\n}\n\nimpl Validate for CreatePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.content.trim().is_empty() {\n            return Err(\"投稿内容が空です\".to_string());\n        }\n        if self.content.len() > 5000 {\n            return Err(\"投稿内容が長すぎます（最大5000文字）\".to_string());\n        }\n        if self.topic_id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetPostsRequest {\n    pub topic_id: Option<String>,\n    pub author_pubkey: Option<String>,\n    pub pagination: Option<PaginationRequest>,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DeletePostRequest {\n    pub post_id: String,\n    pub reason: Option<String>,\n}\n\nimpl Validate for DeletePostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ReactToPostRequest {\n    pub post_id: String,\n    pub reaction: String,\n}\n\nimpl Validate for ReactToPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        if self.reaction.trim().is_empty() {\n            return Err(\"リアクションが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BookmarkPostRequest {\n    pub post_id: String,\n}\n\nimpl Validate for BookmarkPostRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_id.trim().is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n// バッチ処理用リクエストDTO\n#[derive(Debug, Serialize, Deserialize)]\npub struct BatchGetPostsRequest {\n    pub post_ids: Vec<String>,\n}\n\nimpl Validate for BatchGetPostsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_ids.is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        if self.post_ids.len() > 100 {\n            return Err(\"一度に取得できる投稿は100件までです\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BatchReactRequest {\n    pub reactions: Vec<ReactToPostRequest>,\n}\n\nimpl Validate for BatchReactRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.reactions.is_empty() {\n            return Err(\"リアクションが必要です\".to_string());\n        }\n        if self.reactions.len() > 50 {\n            return Err(\"一度に処理できるリアクションは50件までです\".to_string());\n        }\n        // 各リアクションの検証\n        for reaction in &self.reactions {\n            reaction.validate()?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct BatchBookmarkRequest {\n    pub post_ids: Vec<String>,\n    pub action: BookmarkAction,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum BookmarkAction {\n    Add,\n    Remove,\n}\n\nimpl Validate for BatchBookmarkRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.post_ids.is_empty() {\n            return Err(\"投稿IDが必要です\".to_string());\n        }\n        if self.post_ids.len() > 100 {\n            return Err(\"一度に処理できるブックマークは100件までです\".to_string());\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":28,"address":[15611520],"length":1,"stats":{"Line":0}},{"line":29,"address":[15611550],"length":1,"stats":{"Line":0}},{"line":30,"address":[15852432],"length":1,"stats":{"Line":0}},{"line":32,"address":[18982401],"length":1,"stats":{"Line":0}},{"line":33,"address":[15852532],"length":1,"stats":{"Line":0}},{"line":35,"address":[18982479],"length":1,"stats":{"Line":0}},{"line":36,"address":[15980528],"length":1,"stats":{"Line":0}},{"line":38,"address":[15852593],"length":1,"stats":{"Line":0}},{"line":56,"address":[15081440],"length":1,"stats":{"Line":0}},{"line":57,"address":[15611870],"length":1,"stats":{"Line":0}},{"line":58,"address":[18982737],"length":1,"stats":{"Line":0}},{"line":60,"address":[18982722],"length":1,"stats":{"Line":0}},{"line":71,"address":[18982816],"length":1,"stats":{"Line":0}},{"line":72,"address":[18982848],"length":1,"stats":{"Line":0}},{"line":73,"address":[15852937],"length":1,"stats":{"Line":0}},{"line":75,"address":[15852900],"length":1,"stats":{"Line":0}},{"line":76,"address":[15853013],"length":1,"stats":{"Line":0}},{"line":78,"address":[18982982],"length":1,"stats":{"Line":0}},{"line":88,"address":[15853088],"length":1,"stats":{"Line":0}},{"line":89,"address":[15081886],"length":1,"stats":{"Line":0}},{"line":90,"address":[15853169],"length":1,"stats":{"Line":0}},{"line":92,"address":[15081922],"length":1,"stats":{"Line":0}},{"line":103,"address":[15639152],"length":1,"stats":{"Line":0}},{"line":104,"address":[18983264],"length":1,"stats":{"Line":0}},{"line":105,"address":[15853309],"length":1,"stats":{"Line":0}},{"line":107,"address":[15981215],"length":1,"stats":{"Line":0}},{"line":108,"address":[15853385],"length":1,"stats":{"Line":0}},{"line":110,"address":[15639274],"length":1,"stats":{"Line":0}},{"line":120,"address":[15853456],"length":1,"stats":{"Line":0}},{"line":121,"address":[15082262],"length":1,"stats":{"Line":0}},{"line":122,"address":[15612691],"length":1,"stats":{"Line":0}},{"line":124,"address":[15082277],"length":1,"stats":{"Line":0}},{"line":125,"address":[15612773],"length":1,"stats":{"Line":0}},{"line":128,"address":[15639491,15639568,15639630],"length":1,"stats":{"Line":0}},{"line":129,"address":[15981743,15981655],"length":1,"stats":{"Line":0}},{"line":131,"address":[15853711],"length":1,"stats":{"Line":0}},{"line":148,"address":[15981808],"length":1,"stats":{"Line":0}},{"line":149,"address":[15981840],"length":1,"stats":{"Line":0}},{"line":150,"address":[15981869],"length":1,"stats":{"Line":0}},{"line":152,"address":[15639855],"length":1,"stats":{"Line":0}},{"line":153,"address":[15981945],"length":1,"stats":{"Line":0}},{"line":155,"address":[15981930],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","topic_dto.rs"],"content":"use super::Validate;\nuse serde::{Deserialize, Serialize};\n\n// レスポンスDTO\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TopicResponse {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub image_url: Option<String>,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub is_joined: bool,\n    pub created_at: i64,\n    pub updated_at: i64,\n}\n\n// リクエストDTO\n#[derive(Debug, Serialize, Deserialize)]\npub struct CreateTopicRequest {\n    pub name: String,\n    pub description: String,\n    pub image_url: Option<String>,\n}\n\nimpl Validate for CreateTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.name.trim().is_empty() {\n            return Err(\"トピック名が必要です\".to_string());\n        }\n        if self.name.len() > 100 {\n            return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\n        }\n        if self.description.len() > 500 {\n            return Err(\"説明が長すぎます（最大500文字）\".to_string());\n        }\n\n        // URLのバリデーション（もし提供されている場合）\n        if let Some(url) = &self.image_url {\n            if !url.is_empty() && !url.starts_with(\"http\") {\n                return Err(\"無効な画像URLです\".to_string());\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct UpdateTopicRequest {\n    pub id: String,\n    pub name: Option<String>,\n    pub description: Option<String>,\n    pub image_url: Option<String>,\n}\n\nimpl Validate for UpdateTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n\n        if let Some(name) = &self.name {\n            if name.len() > 100 {\n                return Err(\"トピック名が長すぎます（最大100文字）\".to_string());\n            }\n        }\n\n        if let Some(desc) = &self.description {\n            if desc.len() > 500 {\n                return Err(\"説明が長すぎます（最大500文字）\".to_string());\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct JoinTopicRequest {\n    pub topic_id: String,\n}\n\nimpl Validate for JoinTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetTopicStatsRequest {\n    pub topic_id: String,\n}\n\nimpl Validate for GetTopicStatsRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.topic_id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct DeleteTopicRequest {\n    pub id: String,\n}\n\nimpl Validate for DeleteTopicRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.id.trim().is_empty() {\n            return Err(\"トピックIDが必要です\".to_string());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct TopicStatsResponse {\n    pub topic_id: String,\n    pub member_count: u32,\n    pub post_count: u32,\n    pub active_users_24h: u32,\n    pub trending_score: f64,\n}\n","traces":[{"line":27,"address":[13410016],"length":1,"stats":{"Line":0}},{"line":28,"address":[14181286],"length":1,"stats":{"Line":0}},{"line":29,"address":[17311319],"length":1,"stats":{"Line":0}},{"line":31,"address":[13940490],"length":1,"stats":{"Line":0}},{"line":32,"address":[17311402],"length":1,"stats":{"Line":0}},{"line":34,"address":[17330615],"length":1,"stats":{"Line":0}},{"line":35,"address":[14181527],"length":1,"stats":{"Line":0}},{"line":39,"address":[17330698,17330807],"length":1,"stats":{"Line":0}},{"line":40,"address":[17311583,17311619],"length":1,"stats":{"Line":0}},{"line":41,"address":[13410436],"length":1,"stats":{"Line":0}},{"line":45,"address":[17311599],"length":1,"stats":{"Line":0}},{"line":58,"address":[13967648],"length":1,"stats":{"Line":0}},{"line":59,"address":[17311763],"length":1,"stats":{"Line":0}},{"line":60,"address":[13410628],"length":1,"stats":{"Line":0}},{"line":63,"address":[14181921,14181815],"length":1,"stats":{"Line":0}},{"line":64,"address":[17331142],"length":1,"stats":{"Line":0}},{"line":65,"address":[17331202],"length":1,"stats":{"Line":0}},{"line":69,"address":[13967961,13967846],"length":1,"stats":{"Line":0}},{"line":70,"address":[13967969],"length":1,"stats":{"Line":0}},{"line":71,"address":[17331314],"length":1,"stats":{"Line":0}},{"line":75,"address":[13941251],"length":1,"stats":{"Line":0}},{"line":85,"address":[14182160],"length":1,"stats":{"Line":0}},{"line":86,"address":[13968094],"length":1,"stats":{"Line":0}},{"line":87,"address":[14182241],"length":1,"stats":{"Line":0}},{"line":89,"address":[17312210],"length":1,"stats":{"Line":0}},{"line":99,"address":[17331536],"length":1,"stats":{"Line":0}},{"line":100,"address":[17331566],"length":1,"stats":{"Line":0}},{"line":101,"address":[13941569],"length":1,"stats":{"Line":0}},{"line":103,"address":[13941554],"length":1,"stats":{"Line":0}},{"line":113,"address":[13968384],"length":1,"stats":{"Line":0}},{"line":114,"address":[14182510],"length":1,"stats":{"Line":0}},{"line":115,"address":[17331777],"length":1,"stats":{"Line":0}},{"line":117,"address":[17331762],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","dto","user_dto.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UserProfile {\n    pub npub: String,\n    pub pubkey: String,\n    pub name: Option<String>,\n    pub display_name: Option<String>,\n    pub about: Option<String>,\n    pub picture: Option<String>,\n    pub banner: Option<String>,\n    pub website: Option<String>,\n    pub nip05: Option<String>,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","auth_handler.rs"],"content":"use crate::{\r\n    application::services::AuthService,\r\n    presentation::dto::{\r\n        Validate,\r\n        auth_dto::{CreateAccountResponse, LoginResponse, LoginWithNsecRequest},\r\n    },\r\n    shared::error::AppError,\r\n};\r\nuse std::sync::Arc;\r\n\r\npub struct AuthHandler {\r\n    auth_service: Arc<AuthService>,\r\n}\r\n\r\nimpl AuthHandler {\r\n    pub fn new(auth_service: Arc<AuthService>) -> Self {\r\n        Self { auth_service }\r\n    }\r\n\r\n    pub async fn create_account(&self) -> Result<CreateAccountResponse, AppError> {\r\n        let user = self.auth_service.create_account().await?;\r\n\r\n        // nsecの生成（実際の実装では秘密鍵から生成）\r\n        let nsec = format!(\"nsec1{}\", &user.pubkey[..32]); // 仮実装\r\n\r\n        Ok(CreateAccountResponse {\r\n            npub: user.npub,\r\n            nsec,\r\n            pubkey: user.pubkey,\r\n        })\r\n    }\r\n\r\n    pub async fn login_with_nsec(\r\n        &self,\r\n        request: LoginWithNsecRequest,\r\n    ) -> Result<LoginResponse, AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        let user = self.auth_service.login_with_nsec(&request.nsec).await?;\r\n\r\n        Ok(LoginResponse {\r\n            success: true,\r\n            npub: user.npub,\r\n            pubkey: user.pubkey,\r\n        })\r\n    }\r\n\r\n    pub async fn login_with_npub(&self, npub: String) -> Result<LoginResponse, AppError> {\r\n        let user = self.auth_service.login_with_npub(&npub).await?;\r\n\r\n        Ok(LoginResponse {\r\n            success: true,\r\n            npub: user.npub,\r\n            pubkey: user.pubkey,\r\n        })\r\n    }\r\n\r\n    pub async fn logout(&self, npub: String) -> Result<(), AppError> {\r\n        // npubは使用しない（現在のユーザーをログアウト）\r\n        let _ = npub;\r\n        self.auth_service.logout().await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn get_current_user(&self) -> Result<Option<LoginResponse>, AppError> {\r\n        match self.auth_service.get_current_user().await? {\r\n            Some(user) => Ok(Some(LoginResponse {\r\n                success: true,\r\n                npub: user.npub,\r\n                pubkey: user.pubkey,\r\n            })),\r\n            None => Ok(None),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[13404976],"length":1,"stats":{"Line":0}},{"line":20,"address":[12876077,12874744,12874931,12874659,12874592,12874600,12874781,12874624],"length":1,"stats":{"Line":0}},{"line":21,"address":[10389047],"length":1,"stats":{"Line":0}},{"line":24,"address":[13405853,13405695],"length":1,"stats":{"Line":0}},{"line":26,"address":[17332891],"length":1,"stats":{"Line":0}},{"line":27,"address":[16776812],"length":1,"stats":{"Line":0}},{"line":29,"address":[17332862],"length":1,"stats":{"Line":0}},{"line":33,"address":[17333328],"length":1,"stats":{"Line":0}},{"line":37,"address":[13433618,13433410,13433820,13433523],"length":1,"stats":{"Line":0}},{"line":39,"address":[13647561,13647777,13647698,13648531,13648907,13647973],"length":1,"stats":{"Line":0}},{"line":41,"address":[13648376],"length":1,"stats":{"Line":0}},{"line":43,"address":[16778296],"length":1,"stats":{"Line":0}},{"line":44,"address":[13434248],"length":1,"stats":{"Line":0}},{"line":48,"address":[16778979,16778944,16778904,16779309,16780254,16778896,16779085,16780159],"length":1,"stats":{"Line":0}},{"line":49,"address":[13409071,13408296,13408253,13408525,13408354],"length":1,"stats":{"Line":0}},{"line":51,"address":[13649748],"length":1,"stats":{"Line":0}},{"line":53,"address":[13435597],"length":1,"stats":{"Line":0}},{"line":54,"address":[13408887],"length":1,"stats":{"Line":0}},{"line":58,"address":[13409472,13409658,13409857,13410217,13409520,13409480,13409555,13410355],"length":1,"stats":{"Line":0}},{"line":61,"address":[16780705,16780973,16780501,16780458,16780564],"length":1,"stats":{"Line":0}},{"line":62,"address":[17336826],"length":1,"stats":{"Line":0}},{"line":65,"address":[13410435,13410557,13410706,13411717,13410376,13410400,13410520,13410368],"length":1,"stats":{"Line":0}},{"line":66,"address":[13410547,13410738,13410504,13411726,13410609],"length":1,"stats":{"Line":0}},{"line":67,"address":[13652096,13652030],"length":1,"stats":{"Line":0}},{"line":69,"address":[13411200],"length":1,"stats":{"Line":0}},{"line":70,"address":[17337900],"length":1,"stats":{"Line":0}},{"line":72,"address":[17337789],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","event_handler.rs"],"content":"use crate::application::services::event_service::EventServiceTrait;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::event::{\n    DeleteEventsRequest, EventResponse, NostrMetadataDto, NostrSubscriptionStateDto,\n    PublishTextNoteRequest, PublishTopicPostRequest, SendReactionRequest,\n    SetDefaultP2PTopicRequest, SubscribeRequest, UpdateMetadataRequest,\n};\nuse crate::shared::error::AppError;\nuse serde_json::json;\nuse std::sync::Arc;\n\npub struct EventHandler {\n    event_service: Arc<dyn EventServiceTrait>,\n}\n\nimpl EventHandler {\n    pub fn new(event_service: Arc<dyn EventServiceTrait>) -> Self {\n        Self { event_service }\n    }\n\n    /// Nostrクライアントを初期化\n    pub async fn initialize_nostr(&self) -> Result<serde_json::Value, AppError> {\n        self.event_service.initialize().await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// テキストノートを投稿\n    pub async fn publish_text_note(\n        &self,\n        request: PublishTextNoteRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_text_note(&request.content)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Text note published successfully\".to_string()),\n        })\n    }\n\n    /// トピック投稿を作成\n    pub async fn publish_topic_post(\n        &self,\n        request: PublishTopicPostRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .publish_topic_post(\n                &request.topic_id,\n                &request.content,\n                request.reply_to.as_deref(),\n            )\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Topic post published successfully\".to_string()),\n        })\n    }\n\n    /// リアクションを送信\n    pub async fn send_reaction(\n        &self,\n        request: SendReactionRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .send_reaction(&request.event_id, &request.reaction)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Reaction sent successfully\".to_string()),\n        })\n    }\n\n    /// メタデータを更新\n    pub async fn update_metadata(\n        &self,\n        request: UpdateMetadataRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let metadata = NostrMetadataDto {\n            name: request.metadata.name,\n            display_name: request.metadata.display_name,\n            about: request.metadata.about,\n            picture: request.metadata.picture,\n            banner: request.metadata.banner,\n            nip05: request.metadata.nip05,\n            lud16: request.metadata.lud16,\n            website: request.metadata.website,\n        };\n\n        let event_id = self.event_service.update_metadata(metadata).await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Metadata updated successfully\".to_string()),\n        })\n    }\n\n    /// トピックをサブスクライブ\n    pub async fn subscribe_to_topic(\n        &self,\n        request: SubscribeRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        request.validate()?;\n\n        self.event_service\n            .subscribe_to_topic(&request.topic_id)\n            .await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// ユーザーをサブスクライブ\n    pub async fn subscribe_to_user(&self, pubkey: String) -> Result<serde_json::Value, AppError> {\n        if pubkey.is_empty() {\n            return Err(AppError::ValidationError(\n                \"Public key is required\".to_string(),\n            ));\n        }\n\n        self.event_service.subscribe_to_user(&pubkey).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// Nostr公開鍵を取得\n    pub async fn get_nostr_pubkey(&self) -> Result<serde_json::Value, AppError> {\n        let pubkey = self.event_service.get_public_key().await?;\n\n        Ok(json!({\n            \"pubkey\": pubkey\n        }))\n    }\n\n    /// イベントを削除\n    pub async fn delete_events(\n        &self,\n        request: DeleteEventsRequest,\n    ) -> Result<EventResponse, AppError> {\n        request.validate()?;\n\n        let event_id = self\n            .event_service\n            .delete_events(request.event_ids, request.reason)\n            .await?;\n\n        Ok(EventResponse {\n            event_id: event_id.to_string(),\n            success: true,\n            message: Some(\"Events deleted successfully\".to_string()),\n        })\n    }\n\n    /// Nostrクライアントを切断\n    pub async fn disconnect_nostr(&self) -> Result<serde_json::Value, AppError> {\n        self.event_service.disconnect().await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// 既定のP2P配信トピックを設定\n    pub async fn set_default_p2p_topic(\n        &self,\n        request: SetDefaultP2PTopicRequest,\n    ) -> Result<serde_json::Value, AppError> {\n        request.validate()?;\n        self.event_service\n            .set_default_p2p_topic(&request.topic_id)\n            .await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    /// 現在のNostr購読状態一覧を取得\n    pub async fn list_subscriptions(&self) -> Result<serde_json::Value, AppError> {\n        let records = self.event_service.list_subscriptions().await?;\n        let subscriptions: Vec<NostrSubscriptionStateDto> =\n            records.into_iter().map(Into::into).collect();\n        Ok(json!({ \"subscriptions\": subscriptions }))\n    }\n}\n","traces":[{"line":17,"address":[16680368],"length":1,"stats":{"Line":0}},{"line":22,"address":[16681419,16680408,16680451,16680400,16680713,16680416,16680534,16680571],"length":1,"stats":{"Line":0}},{"line":23,"address":[14333622],"length":1,"stats":{"Line":0}},{"line":24,"address":[12994382,12994312],"length":1,"stats":{"Line":0}},{"line":28,"address":[13208880],"length":1,"stats":{"Line":0}},{"line":32,"address":[12994977,12995096,12995184,12995425],"length":1,"stats":{"Line":0}},{"line":34,"address":[12995163,12995591,12996332,12995689,12995865,12995322,12995381],"length":1,"stats":{"Line":0}},{"line":36,"address":[12968537],"length":1,"stats":{"Line":0}},{"line":37,"address":[12437899,12438349,12438697,12438487,12438214,12438261],"length":1,"stats":{"Line":0}},{"line":39,"address":[16340130],"length":1,"stats":{"Line":0}},{"line":40,"address":[16339886],"length":1,"stats":{"Line":0}},{"line":42,"address":[12969210,12969282],"length":1,"stats":{"Line":0}},{"line":47,"address":[12969616],"length":1,"stats":{"Line":0}},{"line":51,"address":[12439716,12439497,12439619,12440118],"length":1,"stats":{"Line":0}},{"line":53,"address":[16342268,16341613,16341281,16341216,16341789,16340905,16341503],"length":1,"stats":{"Line":0}},{"line":56,"address":[12970214],"length":1,"stats":{"Line":0}},{"line":57,"address":[12997011],"length":1,"stats":{"Line":0}},{"line":58,"address":[16683636],"length":1,"stats":{"Line":0}},{"line":60,"address":[16341303,16340774,16341394,16341535,16341757,16341250],"length":1,"stats":{"Line":0}},{"line":62,"address":[13211990],"length":1,"stats":{"Line":0}},{"line":63,"address":[13211746],"length":1,"stats":{"Line":0}},{"line":65,"address":[12440654,12440726],"length":1,"stats":{"Line":0}},{"line":70,"address":[16342288],"length":1,"stats":{"Line":0}},{"line":74,"address":[13213065,13212765,13212552,13212674],"length":1,"stats":{"Line":0}},{"line":76,"address":[12972130,12972189,12972679,12973152,12972399,12971912,12972503],"length":1,"stats":{"Line":0}},{"line":78,"address":[12441622],"length":1,"stats":{"Line":0}},{"line":79,"address":[16342974,16342597,16343463,16343109,16343247,16343021],"length":1,"stats":{"Line":0}},{"line":81,"address":[16343680],"length":1,"stats":{"Line":0}},{"line":82,"address":[13213452],"length":1,"stats":{"Line":0}},{"line":84,"address":[16343576,16343648],"length":1,"stats":{"Line":0}},{"line":89,"address":[13214000],"length":1,"stats":{"Line":0}},{"line":93,"address":[16344410,16345256,16345534,16344526],"length":1,"stats":{"Line":0}},{"line":96,"address":[13000511],"length":1,"stats":{"Line":0}},{"line":97,"address":[13214654],"length":1,"stats":{"Line":0}},{"line":98,"address":[13000605],"length":1,"stats":{"Line":0}},{"line":99,"address":[16344732],"length":1,"stats":{"Line":0}},{"line":100,"address":[16687159],"length":1,"stats":{"Line":0}},{"line":101,"address":[13000746],"length":1,"stats":{"Line":0}},{"line":102,"address":[16687253],"length":1,"stats":{"Line":0}},{"line":103,"address":[13214936],"length":1,"stats":{"Line":0}},{"line":106,"address":[13215251,13215383,13215954,13215607,13214484],"length":1,"stats":{"Line":0}},{"line":108,"address":[12975339],"length":1,"stats":{"Line":0}},{"line":109,"address":[16345911],"length":1,"stats":{"Line":0}},{"line":111,"address":[16688387,16688459],"length":1,"stats":{"Line":0}},{"line":116,"address":[16347856],"length":1,"stats":{"Line":0}},{"line":120,"address":[12977681,12977440,12977233,12977352],"length":1,"stats":{"Line":0}},{"line":122,"address":[16348394,16348855,16349291,16348453,16348663,16348235,16348755],"length":1,"stats":{"Line":0}},{"line":123,"address":[13218361],"length":1,"stats":{"Line":0}},{"line":124,"address":[14336161],"length":1,"stats":{"Line":0}},{"line":126,"address":[16691180,16691108],"length":1,"stats":{"Line":0}},{"line":130,"address":[13005930,13006693,13005224,13005216,13006595,13005264,13005305,13005435],"length":1,"stats":{"Line":0}},{"line":131,"address":[13005412,13005527],"length":1,"stats":{"Line":0}},{"line":132,"address":[13005768],"length":1,"stats":{"Line":0}},{"line":133,"address":[13219655],"length":1,"stats":{"Line":0}},{"line":137,"address":[12979495,12979966,12978877,12979226,12978726,12978802],"length":1,"stats":{"Line":0}},{"line":139,"address":[13220320,13220396],"length":1,"stats":{"Line":0}},{"line":143,"address":[13006736,13007053,13008003,13006771,13006866,13006903,13006728,13006720],"length":1,"stats":{"Line":0}},{"line":144,"address":[10409204],"length":1,"stats":{"Line":0}},{"line":146,"address":[12450845,12450373,12450256],"length":1,"stats":{"Line":0}},{"line":152,"address":[16694320],"length":1,"stats":{"Line":0}},{"line":156,"address":[16694571,16695008,16694677,16694755],"length":1,"stats":{"Line":0}},{"line":158,"address":[16352518,16352961,16352691,16352766,16353229,16353053,16353641],"length":1,"stats":{"Line":0}},{"line":160,"address":[16694827],"length":1,"stats":{"Line":0}},{"line":161,"address":[12981919,12982381,12981963,12981586,12982177,12982042],"length":1,"stats":{"Line":0}},{"line":163,"address":[13009334],"length":1,"stats":{"Line":0}},{"line":164,"address":[16695374],"length":1,"stats":{"Line":0}},{"line":166,"address":[12452166,12452094],"length":1,"stats":{"Line":0}},{"line":171,"address":[13224095,13223920,13224058,13224245,13224971,13223936,13223971,13223928],"length":1,"stats":{"Line":0}},{"line":172,"address":[14333398],"length":1,"stats":{"Line":0}},{"line":174,"address":[16354504,16354574],"length":1,"stats":{"Line":0}},{"line":178,"address":[13010896],"length":1,"stats":{"Line":0}},{"line":182,"address":[16355288,16355617,16355169,16355376],"length":1,"stats":{"Line":0}},{"line":183,"address":[16697642,16697491,16697995,16698075,16697891,16698503,16697697],"length":1,"stats":{"Line":0}},{"line":184,"address":[12454249],"length":1,"stats":{"Line":0}},{"line":185,"address":[10996049],"length":1,"stats":{"Line":0}},{"line":186,"address":[13225952,13226028],"length":1,"stats":{"Line":0}},{"line":190,"address":[12987083,12985608,12985754,12985600,12985802,12985651,12985952,12985616],"length":1,"stats":{"Line":0}},{"line":191,"address":[11205844],"length":1,"stats":{"Line":0}},{"line":192,"address":[13013198,13013027],"length":1,"stats":{"Line":0}},{"line":194,"address":[16699914,16699392,16699436],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":80},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","mod.rs"],"content":"#![allow(unused_imports)]\r\n\r\npub mod auth_handler;\r\npub mod event_handler;\r\npub mod offline_handler;\r\npub mod p2p_handler;\r\npub mod post_handler;\r\npub mod secure_storage_handler;\r\npub mod topic_handler;\r\npub mod user_handler;\r\n\r\npub use auth_handler::AuthHandler;\r\npub use event_handler::EventHandler;\r\npub use offline_handler::OfflineHandler;\r\npub use p2p_handler::P2PHandler;\r\npub use post_handler::PostHandler;\r\npub use secure_storage_handler::SecureStorageHandler;\r\npub use topic_handler::TopicHandler;\r\npub use user_handler::UserHandler;\r\n\r\nuse crate::shared::error::AppError;\r\n\r\n/// エラーをAPIレスポンスに変換\r\npub fn handle_error<T>(result: Result<T, AppError>) -> Result<T, String> {\r\n    result.map_err(|e| e.to_string())\r\n}\r\n\r\n/// 入力検証を実行\r\npub fn validate_input<T: super::dto::Validate>(input: &T) -> Result<(), String> {\r\n    input.validate()\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","offline_handler.rs"],"content":"use crate::application::services::offline_service::{\n    OfflineActionsQuery, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse crate::domain::entities::offline::{\n    CacheMetadataUpdate, CacheStatusSnapshot, OfflineActionRecord, OptimisticUpdateDraft,\n    SyncQueueItemDraft, SyncStatusUpdate,\n};\nuse crate::domain::value_objects::event_gateway::PublicKey;\nuse crate::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload,\n    OptimisticUpdateId, SyncQueueId, SyncStatus,\n};\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::offline::{\n    AddToSyncQueueRequest, CacheStatusResponse, CacheTypeStatus, GetOfflineActionsRequest,\n    OfflineAction, OptimisticUpdateRequest, SaveOfflineActionRequest, SaveOfflineActionResponse,\n    SyncOfflineActionsRequest, SyncOfflineActionsResponse, UpdateCacheMetadataRequest,\n    UpdateSyncStatusRequest,\n};\nuse crate::shared::error::AppError;\nuse chrono::{Duration, Utc};\nuse serde_json::{Value, json};\nuse std::convert::{TryFrom, TryInto};\nuse std::sync::Arc;\n\npub struct OfflineHandler {\n    offline_service: Arc<dyn OfflineServiceTrait>,\n}\n\nimpl OfflineHandler {\n    pub fn new(offline_service: Arc<dyn OfflineServiceTrait>) -> Self {\n        Self { offline_service }\n    }\n    pub async fn save_offline_action(\n        &self,\n        request: SaveOfflineActionRequest,\n    ) -> Result<SaveOfflineActionResponse, AppError> {\n        request.validate()?;\n\n        let params = SaveOfflineActionParams {\n            user_pubkey: parse_public_key(&request.user_pubkey)?,\n            action_type: parse_action_type(&request.action_type)?,\n            entity_type: parse_entity_type(&request.entity_type)?,\n            entity_id: parse_entity_id(&request.entity_id)?,\n            payload: parse_payload(&request.data)?,\n        };\n\n        let saved = self.offline_service.save_action(params).await?;\n        let action = map_action_record(&saved.action)?;\n\n        Ok(SaveOfflineActionResponse {\n            local_id: saved.local_id.to_string(),\n            action,\n        })\n    }\n\n    pub async fn get_offline_actions(\n        &self,\n        request: GetOfflineActionsRequest,\n    ) -> Result<Vec<OfflineAction>, AppError> {\n        request.validate()?;\n\n        let query = OfflineActionsQuery {\n            user_pubkey: match request.user_pubkey.as_deref() {\n                Some(value) => Some(parse_public_key(value)?),\n                None => None,\n            },\n            include_synced: request.is_synced,\n            limit: request.limit.map(|value| value as u32),\n        };\n\n        let actions = self.offline_service.list_actions(query).await?;\n        actions\n            .iter()\n            .map(map_action_record)\n            .collect::<Result<Vec<_>, _>>()\n    }\n\n    pub async fn sync_offline_actions(\n        &self,\n        request: SyncOfflineActionsRequest,\n    ) -> Result<SyncOfflineActionsResponse, AppError> {\n        request.validate()?;\n\n        let pubkey = parse_public_key(&request.user_pubkey)?;\n        let result = self.offline_service.sync_actions(pubkey).await?;\n\n        Ok(SyncOfflineActionsResponse {\n            synced_count: i32::try_from(result.synced_count)\n                .map_err(|_| AppError::Internal(\"Synced count overflowed i32\".to_string()))?,\n            failed_count: i32::try_from(result.failed_count)\n                .map_err(|_| AppError::Internal(\"Failed count overflowed i32\".to_string()))?,\n            pending_count: i32::try_from(result.pending_count)\n                .map_err(|_| AppError::Internal(\"Pending count overflowed i32\".to_string()))?,\n        })\n    }\n\n    pub async fn get_cache_status(&self) -> Result<CacheStatusResponse, AppError> {\n        let snapshot = self.offline_service.cache_status().await?;\n        map_cache_status(snapshot)\n    }\n\n    pub async fn add_to_sync_queue(&self, request: AddToSyncQueueRequest) -> Result<i64, AppError> {\n        request.validate()?;\n\n        let draft = SyncQueueItemDraft::new(\n            parse_action_type(&request.action_type)?,\n            OfflinePayload::new(request.payload.clone()).map_err(AppError::ValidationError)?,\n            request\n                .priority\n                .map(|value| {\n                    u8::try_from(value)\n                        .map_err(|_| AppError::ValidationError(\"Priority must fit in u8\".into()))\n                })\n                .transpose()?,\n        );\n        let queue_id = self.offline_service.enqueue_sync(draft).await?;\n        Ok(queue_id.value())\n    }\n\n    pub async fn update_cache_metadata(\n        &self,\n        request: UpdateCacheMetadataRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = CacheMetadataUpdate {\n            cache_key: CacheKey::new(request.cache_key).map_err(AppError::ValidationError)?,\n            cache_type: CacheType::new(request.cache_type).map_err(AppError::ValidationError)?,\n            metadata: request.metadata,\n            expiry: request\n                .expiry_seconds\n                .map(|seconds| {\n                    if seconds <= 0 {\n                        return Err(AppError::ValidationError(\n                            \"Expiry seconds must be positive\".to_string(),\n                        ));\n                    }\n                    Ok(Utc::now() + Duration::seconds(seconds))\n                })\n                .transpose()?,\n        };\n\n        self.offline_service.upsert_cache_metadata(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn save_optimistic_update(\n        &self,\n        request: OptimisticUpdateRequest,\n    ) -> Result<String, AppError> {\n        request.validate()?;\n\n        let draft = OptimisticUpdateDraft::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            match request.original_data {\n                Some(ref data) => Some(parse_payload(data)?),\n                None => None,\n            },\n            parse_payload(&request.updated_data)?,\n        );\n\n        let update_id = self.offline_service.save_optimistic_update(draft).await?;\n        Ok(update_id.to_string())\n    }\n\n    pub async fn confirm_optimistic_update(&self, update_id: String) -> Result<Value, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::ValidationError(\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id).map_err(AppError::ValidationError)?;\n        self.offline_service.confirm_optimistic_update(id).await?;\n\n        Ok(json!({ \"success\": true }))\n    }\n\n    pub async fn rollback_optimistic_update(\n        &self,\n        update_id: String,\n    ) -> Result<Option<String>, AppError> {\n        if update_id.is_empty() {\n            return Err(AppError::ValidationError(\n                \"Update ID is required\".to_string(),\n            ));\n        }\n\n        let id = OptimisticUpdateId::new(update_id).map_err(AppError::ValidationError)?;\n        let original = self.offline_service.rollback_optimistic_update(id).await?;\n\n        let serialized = original\n            .map(|payload| serde_json::to_string(&payload.into_inner()))\n            .transpose()\n            .map_err(|err| AppError::SerializationError(err.to_string()))?;\n\n        Ok(serialized)\n    }\n\n    pub async fn cleanup_expired_cache(&self) -> Result<i32, AppError> {\n        let cleaned = self.offline_service.cleanup_expired_cache().await?;\n        cleaned\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Cleanup count overflowed i32\".to_string()))\n    }\n\n    pub async fn update_sync_status(\n        &self,\n        request: UpdateSyncStatusRequest,\n    ) -> Result<Value, AppError> {\n        request.validate()?;\n\n        let update = SyncStatusUpdate::new(\n            parse_entity_type(&request.entity_type)?,\n            parse_entity_id(&request.entity_id)?,\n            map_sync_status(&request.sync_status),\n            parse_optional_payload(request.conflict_data)?,\n            Utc::now(),\n        );\n\n        self.offline_service.update_sync_status(update).await?;\n        Ok(json!({ \"success\": true }))\n    }\n}\n\nfn parse_public_key(value: &str) -> Result<PublicKey, AppError> {\n    PublicKey::from_hex_str(value).map_err(AppError::ValidationError)\n}\n\nfn parse_action_type(value: &str) -> Result<OfflineActionType, AppError> {\n    OfflineActionType::new(value.to_string()).map_err(AppError::ValidationError)\n}\n\nfn parse_entity_type(value: &str) -> Result<EntityType, AppError> {\n    EntityType::new(value.to_string()).map_err(AppError::ValidationError)\n}\n\nfn parse_entity_id(value: &str) -> Result<EntityId, AppError> {\n    EntityId::new(value.to_string()).map_err(AppError::ValidationError)\n}\n\nfn parse_payload(data: &str) -> Result<OfflinePayload, AppError> {\n    OfflinePayload::from_json_str(data).map_err(AppError::ValidationError)\n}\n\nfn parse_optional_payload(data: Option<String>) -> Result<Option<OfflinePayload>, AppError> {\n    match data {\n        Some(raw) => {\n            let parsed =\n                serde_json::from_str::<Value>(&raw).unwrap_or_else(|_| Value::String(raw.clone()));\n            OfflinePayload::new(parsed)\n                .map(Some)\n                .map_err(AppError::ValidationError)\n        }\n        None => Ok(None),\n    }\n}\n\nfn map_action_record(record: &OfflineActionRecord) -> Result<OfflineAction, AppError> {\n    Ok(OfflineAction {\n        id: record.record_id.unwrap_or_default(),\n        user_pubkey: record.user_pubkey.as_hex().to_string(),\n        action_type: record.action_type.as_str().to_string(),\n        target_id: record.target_id.as_ref().map(ToString::to_string),\n        action_data: serde_json::to_string(record.payload.as_json())\n            .map_err(|err| AppError::SerializationError(err.to_string()))?,\n        local_id: record.action_id.to_string(),\n        remote_id: record.remote_id.as_ref().map(ToString::to_string),\n        is_synced: matches!(record.sync_status, SyncStatus::FullySynced),\n        created_at: record.created_at.timestamp(),\n        synced_at: record.synced_at.map(|ts| ts.timestamp()),\n        error_message: record.error_message.clone(),\n    })\n}\n\nfn map_cache_status(snapshot: CacheStatusSnapshot) -> Result<CacheStatusResponse, AppError> {\n    let cache_types = snapshot\n        .cache_types\n        .into_iter()\n        .map(|status| {\n            Ok(CacheTypeStatus {\n                cache_type: status.cache_type.to_string(),\n                item_count: status.item_count.try_into().map_err(|_| {\n                    AppError::Internal(\"Cache item count overflowed i64\".to_string())\n                })?,\n                last_synced_at: status.last_synced_at.map(|dt| dt.timestamp()),\n                is_stale: status.is_stale,\n            })\n        })\n        .collect::<Result<Vec<_>, AppError>>()?;\n\n    Ok(CacheStatusResponse {\n        total_items: snapshot\n            .total_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Total items overflowed i64\".to_string()))?,\n        stale_items: snapshot\n            .stale_items\n            .try_into()\n            .map_err(|_| AppError::Internal(\"Stale items overflowed i64\".to_string()))?,\n        cache_types,\n    })\n}\n\nfn map_sync_status(value: &str) -> SyncStatus {\n    match value {\n        \"pending\" => SyncStatus::Pending,\n        \"syncing\" => SyncStatus::SentToP2P,\n        \"synced\" => SyncStatus::FullySynced,\n        \"failed\" => SyncStatus::Failed,\n        \"conflict\" => SyncStatus::Conflict,\n        other => SyncStatus::from(other),\n    }\n}\n","traces":[{"line":31,"address":[15816288],"length":1,"stats":{"Line":0}},{"line":34,"address":[15816320],"length":1,"stats":{"Line":0}},{"line":38,"address":[15819717,15816673,15816892,15816795],"length":1,"stats":{"Line":0}},{"line":41,"address":[14812805,14812481,14815140,14812647],"length":1,"stats":{"Line":0}},{"line":42,"address":[15817496,15817322,15817155],"length":1,"stats":{"Line":0}},{"line":43,"address":[12446809,12446983,12446642],"length":1,"stats":{"Line":0}},{"line":44,"address":[12447286,12447112,12446945],"length":1,"stats":{"Line":0}},{"line":45,"address":[12447718,12447248,12447415],"length":1,"stats":{"Line":0}},{"line":48,"address":[12476754,12475697,12474587,12474427,12472654,12476060],"length":1,"stats":{"Line":0}},{"line":49,"address":[12476323,12476041,12476173],"length":1,"stats":{"Line":0}},{"line":51,"address":[12449760],"length":1,"stats":{"Line":0}},{"line":52,"address":[12690392],"length":1,"stats":{"Line":0}},{"line":53,"address":[12476479],"length":1,"stats":{"Line":0}},{"line":57,"address":[11919648],"length":1,"stats":{"Line":0}},{"line":61,"address":[12477044,12477166,12477267,12478177],"length":1,"stats":{"Line":0}},{"line":64,"address":[12477228,12477391],"length":1,"stats":{"Line":0}},{"line":68,"address":[12477507],"length":1,"stats":{"Line":0}},{"line":69,"address":[12450786,12452278,12452272],"length":1,"stats":{"Line":0}},{"line":72,"address":[11213841],"length":1,"stats":{"Line":0}},{"line":73,"address":[11921574,11921422],"length":1,"stats":{"Line":0}},{"line":79,"address":[12479024],"length":1,"stats":{"Line":0}},{"line":83,"address":[12479235,12479354,12480032,12479445],"length":1,"stats":{"Line":0}},{"line":85,"address":[12452827,12452680,12453001,12453280],"length":1,"stats":{"Line":0}},{"line":86,"address":[11922956,11924126,11922580,11922725,11922157,11923265],"length":1,"stats":{"Line":0}},{"line":88,"address":[14820218],"length":1,"stats":{"Line":0}},{"line":89,"address":[12695353,12694475,12694574,12694718],"length":1,"stats":{"Line":0}},{"line":90,"address":[12480590,12481312,12481326],"length":1,"stats":{"Line":0}},{"line":91,"address":[14819963,14820091,14819860,14820512],"length":1,"stats":{"Line":0}},{"line":92,"address":[11924286,11923643,11924272],"length":1,"stats":{"Line":0}},{"line":93,"address":[15824936,15824837,15825160,15825327],"length":1,"stats":{"Line":0}},{"line":94,"address":[12454768,12454312,12454782],"length":1,"stats":{"Line":0}},{"line":98,"address":[15825688,15825680,15825731,15825826,15826691,15826024,15825874,15825696],"length":1,"stats":{"Line":0}},{"line":99,"address":[12481976,12481848,12481773,12482436,12481725],"length":1,"stats":{"Line":0}},{"line":100,"address":[12455623],"length":1,"stats":{"Line":0}},{"line":103,"address":[12458654,12456022,12457884,12455904,12455939,12455984,12456215,12458182],"length":1,"stats":{"Line":0}},{"line":104,"address":[12458154,12456394,12456184,12456303],"length":1,"stats":{"Line":0}},{"line":107,"address":[12483415,12483101,12483244],"length":1,"stats":{"Line":0}},{"line":108,"address":[14822724,14822889,14822568],"length":1,"stats":{"Line":0}},{"line":109,"address":[11926915,11926809,11926710,11926564,11926798],"length":1,"stats":{"Line":0}},{"line":111,"address":[12699648],"length":1,"stats":{"Line":0}},{"line":112,"address":[15829661],"length":1,"stats":{"Line":0}},{"line":113,"address":[14824686,14824672],"length":1,"stats":{"Line":0}},{"line":115,"address":[12698115],"length":1,"stats":{"Line":0}},{"line":117,"address":[14824038,14824580,14823372,14824326,14822174,14823297],"length":1,"stats":{"Line":0}},{"line":118,"address":[12699330,12699428],"length":1,"stats":{"Line":0}},{"line":121,"address":[12485728],"length":1,"stats":{"Line":0}},{"line":125,"address":[12459335,12461296,12459448,12459575],"length":1,"stats":{"Line":0}},{"line":128,"address":[12700512,12700734,12700336,12702123],"length":1,"stats":{"Line":0}},{"line":129,"address":[12486978,12486564,12486751],"length":1,"stats":{"Line":0}},{"line":130,"address":[12700995],"length":1,"stats":{"Line":0}},{"line":131,"address":[12701042,12701497,12701187],"length":1,"stats":{"Line":0}},{"line":144,"address":[11004596],"length":1,"stats":{"Line":0}},{"line":145,"address":[12461687,12461611],"length":1,"stats":{"Line":0}},{"line":148,"address":[15833664],"length":1,"stats":{"Line":0}},{"line":152,"address":[11932901,11932992,11932779,11935427],"length":1,"stats":{"Line":0}},{"line":155,"address":[15834179,15834322,15834495],"length":1,"stats":{"Line":0}},{"line":156,"address":[11933634,11933410,11935316,11933250],"length":1,"stats":{"Line":0}},{"line":157,"address":[11933590],"length":1,"stats":{"Line":0}},{"line":158,"address":[14829870,14829729],"length":1,"stats":{"Line":0}},{"line":159,"address":[14829711],"length":1,"stats":{"Line":0}},{"line":161,"address":[12705415,12704993,12705579],"length":1,"stats":{"Line":0}},{"line":164,"address":[12705812,12707425,12706719,12704072,12705733,12707075],"length":1,"stats":{"Line":0}},{"line":165,"address":[15837032,15837172],"length":1,"stats":{"Line":0}},{"line":168,"address":[12495235,12493582,12494424,12495181,12493443,12493360,12493408,12493368],"length":1,"stats":{"Line":0}},{"line":169,"address":[11936532,11936426],"length":1,"stats":{"Line":0}},{"line":170,"address":[15838354],"length":1,"stats":{"Line":0}},{"line":171,"address":[12467003],"length":1,"stats":{"Line":0}},{"line":175,"address":[11936673,11936852,11936538,11937122],"length":1,"stats":{"Line":0}},{"line":176,"address":[11225201],"length":1,"stats":{"Line":0}},{"line":178,"address":[12708878,12708802],"length":1,"stats":{"Line":0}},{"line":181,"address":[11938192],"length":1,"stats":{"Line":0}},{"line":185,"address":[12709740,12709634],"length":1,"stats":{"Line":0}},{"line":186,"address":[14834915],"length":1,"stats":{"Line":0}},{"line":187,"address":[12468979],"length":1,"stats":{"Line":0}},{"line":191,"address":[12709881,12709746,12710060,12710338],"length":1,"stats":{"Line":0}},{"line":192,"address":[15840173,15841434,15840023,15840505,15840891,15839665],"length":1,"stats":{"Line":0}},{"line":194,"address":[12497308,12496921,12496744,12497200],"length":1,"stats":{"Line":0}},{"line":195,"address":[12711584,12711598],"length":1,"stats":{"Line":0}},{"line":197,"address":[12470432,12470898,12470880],"length":1,"stats":{"Line":0}},{"line":199,"address":[12711176],"length":1,"stats":{"Line":0}},{"line":202,"address":[12711888,12711880,12712047,12712664,12712198,12711872,12711923,12712010],"length":1,"stats":{"Line":0}},{"line":203,"address":[15842214,15842085,15842480,15841973,15842646,15842021],"length":1,"stats":{"Line":0}},{"line":204,"address":[11941335,11941245],"length":1,"stats":{"Line":0}},{"line":206,"address":[12498592,12498606],"length":1,"stats":{"Line":0}},{"line":209,"address":[12712784],"length":1,"stats":{"Line":0}},{"line":213,"address":[14837624,14837830,14839996,14837739],"length":1,"stats":{"Line":0}},{"line":216,"address":[14838105,14837948,14837801],"length":1,"stats":{"Line":0}},{"line":217,"address":[15843932,15843756,15843596],"length":1,"stats":{"Line":0}},{"line":218,"address":[12499820,12499983],"length":1,"stats":{"Line":0}},{"line":219,"address":[14838682,14838791,14838542],"length":1,"stats":{"Line":0}},{"line":220,"address":[12500252],"length":1,"stats":{"Line":0}},{"line":223,"address":[10423584],"length":1,"stats":{"Line":0}},{"line":224,"address":[12715973,12716049],"length":1,"stats":{"Line":0}},{"line":228,"address":[15847040],"length":1,"stats":{"Line":0}},{"line":229,"address":[11945848],"length":1,"stats":{"Line":0}},{"line":232,"address":[15847104],"length":1,"stats":{"Line":0}},{"line":233,"address":[12717143],"length":1,"stats":{"Line":0}},{"line":236,"address":[12717200],"length":1,"stats":{"Line":0}},{"line":237,"address":[11945991],"length":1,"stats":{"Line":0}},{"line":240,"address":[15847264],"length":1,"stats":{"Line":0}},{"line":241,"address":[14841623],"length":1,"stats":{"Line":0}},{"line":244,"address":[15847344],"length":1,"stats":{"Line":0}},{"line":245,"address":[14841704],"length":1,"stats":{"Line":0}},{"line":248,"address":[11946562,11946192],"length":1,"stats":{"Line":0}},{"line":249,"address":[12476614],"length":1,"stats":{"Line":0}},{"line":250,"address":[15847535],"length":1,"stats":{"Line":0}},{"line":251,"address":[11946592,11946341,11946615,11946422],"length":1,"stats":{"Line":0}},{"line":253,"address":[12476871],"length":1,"stats":{"Line":0}},{"line":257,"address":[15847465],"length":1,"stats":{"Line":0}},{"line":261,"address":[12717984,12719396,12719585],"length":1,"stats":{"Line":0}},{"line":262,"address":[15848975],"length":1,"stats":{"Line":0}},{"line":263,"address":[14842318],"length":1,"stats":{"Line":0}},{"line":264,"address":[14842340],"length":1,"stats":{"Line":0}},{"line":265,"address":[12477246,12477325],"length":1,"stats":{"Line":0}},{"line":266,"address":[12477349,12477415],"length":1,"stats":{"Line":0}},{"line":267,"address":[12477439,12477508,12477736],"length":1,"stats":{"Line":0}},{"line":268,"address":[12719600,12718536,12719618],"length":1,"stats":{"Line":0}},{"line":269,"address":[12718508],"length":1,"stats":{"Line":0}},{"line":270,"address":[12477814,12477880],"length":1,"stats":{"Line":0}},{"line":271,"address":[12718736],"length":1,"stats":{"Line":0}},{"line":272,"address":[11947551],"length":1,"stats":{"Line":0}},{"line":273,"address":[15849745,15848839,15849744],"length":1,"stats":{"Line":0}},{"line":274,"address":[12478104],"length":1,"stats":{"Line":0}},{"line":278,"address":[12506641,12505680,12506612],"length":1,"stats":{"Line":0}},{"line":279,"address":[12479258,12478966],"length":1,"stats":{"Line":0}},{"line":282,"address":[15850736,15851316],"length":1,"stats":{"Line":0}},{"line":283,"address":[14845407],"length":1,"stats":{"Line":0}},{"line":284,"address":[15850774],"length":1,"stats":{"Line":0}},{"line":285,"address":[12720852,12721110,12721360,12720925],"length":1,"stats":{"Line":0}},{"line":286,"address":[12721374],"length":1,"stats":{"Line":0}},{"line":288,"address":[15851441,15851006,15851440],"length":1,"stats":{"Line":0}},{"line":289,"address":[12480372],"length":1,"stats":{"Line":0}},{"line":294,"address":[12479681],"length":1,"stats":{"Line":0}},{"line":295,"address":[12720326,12720696,12720008,12720167],"length":1,"stats":{"Line":0}},{"line":298,"address":[12480640,12480654,12479462],"length":1,"stats":{"Line":0}},{"line":299,"address":[12720365,12720681,12720264,12720642],"length":1,"stats":{"Line":0}},{"line":302,"address":[12479778,12480736,12480750],"length":1,"stats":{"Line":0}},{"line":303,"address":[12479634],"length":1,"stats":{"Line":0}},{"line":307,"address":[12507568],"length":1,"stats":{"Line":0}},{"line":309,"address":[15851757,15851698],"length":1,"stats":{"Line":0}},{"line":310,"address":[15851813,15851729],"length":1,"stats":{"Line":0}},{"line":311,"address":[15851869,15851785],"length":1,"stats":{"Line":0}},{"line":312,"address":[12481025,12481106],"length":1,"stats":{"Line":0}},{"line":313,"address":[14846102,14846172],"length":1,"stats":{"Line":0}},{"line":314,"address":[14846160],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":145},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","p2p_handler.rs"],"content":"use crate::application::services::p2p_service::P2PServiceTrait;\nuse crate::presentation::dto::Validate;\nuse crate::presentation::dto::p2p::{\n    BroadcastRequest, GossipMetricsSummaryResponse, JoinTopicByNameRequest,\n    JoinTopicByNameResponse, JoinTopicRequest, LeaveTopicRequest, NodeAddressResponse,\n    P2PStatusResponse, TopicStatus,\n};\nuse crate::shared::error::AppError;\nuse std::sync::Arc;\n\npub struct P2PHandler {\n    p2p_service: Arc<dyn P2PServiceTrait>,\n}\n\nimpl P2PHandler {\n    pub fn new(p2p_service: Arc<dyn P2PServiceTrait>) -> Self {\n        Self { p2p_service }\n    }\n\n    /// P2Pネットワークを初期化\n    pub async fn initialize_p2p(&self) -> Result<(), AppError> {\n        self.p2p_service.initialize().await\n    }\n\n    /// P2Pトピックに参加\n    pub async fn join_topic(&self, request: JoinTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .join_topic(&request.topic_id, request.initial_peers)\n            .await\n    }\n\n    /// P2Pトピックから離脱\n    pub async fn leave_topic(&self, request: LeaveTopicRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service.leave_topic(&request.topic_id).await\n    }\n\n    /// トピックにメッセージをブロードキャスト\n    pub async fn broadcast_to_topic(&self, request: BroadcastRequest) -> Result<(), AppError> {\n        request.validate()?;\n\n        self.p2p_service\n            .broadcast_message(&request.topic_id, &request.content)\n            .await\n    }\n\n    /// P2Pステータスを取得\n    pub async fn get_p2p_status(&self) -> Result<P2PStatusResponse, AppError> {\n        let status = self.p2p_service.get_status().await?;\n        let crate::application::services::p2p_service::P2PStatus {\n            connected,\n            endpoint_id,\n            active_topics,\n            peer_count,\n            metrics_summary,\n        } = status;\n\n        // サービスから取得したステータスをDTOに変換\n        let topic_statuses: Vec<TopicStatus> = active_topics\n            .into_iter()\n            .map(|topic| TopicStatus {\n                topic_id: topic.id,\n                peer_count: topic.peer_count,\n                message_count: topic.message_count,\n                last_activity: topic.last_activity,\n            })\n            .collect();\n\n        Ok(P2PStatusResponse {\n            connected,\n            endpoint_id,\n            active_topics: topic_statuses,\n            peer_count,\n            metrics_summary: GossipMetricsSummaryResponse {\n                joins: metrics_summary.joins,\n                leaves: metrics_summary.leaves,\n                broadcasts_sent: metrics_summary.broadcasts_sent,\n                messages_received: metrics_summary.messages_received,\n            },\n        })\n    }\n\n    /// ノードアドレスを取得\n    pub async fn get_node_address(&self) -> Result<NodeAddressResponse, AppError> {\n        let addresses = self.p2p_service.get_node_addresses().await?;\n\n        Ok(NodeAddressResponse { addresses })\n    }\n\n    /// トピック名で参加\n    pub async fn join_topic_by_name(\n        &self,\n        request: JoinTopicByNameRequest,\n    ) -> Result<JoinTopicByNameResponse, AppError> {\n        request.validate()?;\n\n        let topic_id = self.p2p_service.generate_topic_id(&request.topic_name);\n\n        self.p2p_service\n            .join_topic(&topic_id, request.initial_peers)\n            .await?;\n\n        Ok(JoinTopicByNameResponse { topic_id })\n    }\n}\n","traces":[{"line":16,"address":[17615952],"length":1,"stats":{"Line":0}},{"line":21,"address":[17643327,17642736,17642720,17642728,17642771,17642895,17643045,17642858],"length":1,"stats":{"Line":0}},{"line":22,"address":[17857173,17857045,17856981,17856933],"length":1,"stats":{"Line":0}},{"line":26,"address":[15983411,15982720,15982640,15982675,15982924,15983547,15983837,15982758],"length":1,"stats":{"Line":0}},{"line":27,"address":[15982897,15983096,15983012],"length":1,"stats":{"Line":0}},{"line":29,"address":[12402281,12402011,12402637,12402214],"length":1,"stats":{"Line":0}},{"line":30,"address":[15983181],"length":1,"stats":{"Line":0}},{"line":31,"address":[17643659,17644307,17644073,17644477,17644026],"length":1,"stats":{"Line":0}},{"line":35,"address":[17645719,17644688,17644640,17644726,17645307,17644864,17644648,17645431],"length":1,"stats":{"Line":0}},{"line":36,"address":[17859136,17859048,17858929],"length":1,"stats":{"Line":0}},{"line":38,"address":[10932209],"length":1,"stats":{"Line":0}},{"line":42,"address":[17646007,17645763,17646515,17645808,17645855,17646939,17645728,17646645],"length":1,"stats":{"Line":0}},{"line":43,"address":[12404322,12404200,12404413],"length":1,"stats":{"Line":0}},{"line":45,"address":[12404610,12404392,12404669,12405007],"length":1,"stats":{"Line":0}},{"line":46,"address":[12404502],"length":1,"stats":{"Line":0}},{"line":47,"address":[12404638,12404261,12404901,12404685,12405071],"length":1,"stats":{"Line":0}},{"line":51,"address":[17620224,17620275,17620240,17620378,17620232,17620585,17621886,17620434],"length":1,"stats":{"Line":0}},{"line":52,"address":[12405365,12405448,12405317,12406293,12405577],"length":1,"stats":{"Line":0}},{"line":54,"address":[12406116],"length":1,"stats":{"Line":0}},{"line":55,"address":[15987068],"length":1,"stats":{"Line":0}},{"line":56,"address":[15987105],"length":1,"stats":{"Line":0}},{"line":57,"address":[17647989],"length":1,"stats":{"Line":0}},{"line":58,"address":[17862106],"length":1,"stats":{"Line":0}},{"line":62,"address":[17648182,17648042],"length":1,"stats":{"Line":0}},{"line":64,"address":[17648769,17648720],"length":1,"stats":{"Line":0}},{"line":65,"address":[17862827],"length":1,"stats":{"Line":0}},{"line":66,"address":[17622021],"length":1,"stats":{"Line":0}},{"line":67,"address":[17862857],"length":1,"stats":{"Line":0}},{"line":68,"address":[17091629],"length":1,"stats":{"Line":0}},{"line":72,"address":[17862453],"length":1,"stats":{"Line":0}},{"line":74,"address":[17648245],"length":1,"stats":{"Line":0}},{"line":77,"address":[17091189],"length":1,"stats":{"Line":0}},{"line":78,"address":[17862389],"length":1,"stats":{"Line":0}},{"line":79,"address":[17621565],"length":1,"stats":{"Line":0}},{"line":80,"address":[12406533],"length":1,"stats":{"Line":0}},{"line":81,"address":[17648317],"length":1,"stats":{"Line":0}},{"line":87,"address":[17862928,17862912,17863087,17863050,17862920,17863237,17863793,17862963],"length":1,"stats":{"Line":0}},{"line":88,"address":[11187444],"length":1,"stats":{"Line":0}},{"line":90,"address":[12407675],"length":1,"stats":{"Line":0}},{"line":94,"address":[17649712],"length":1,"stats":{"Line":0}},{"line":98,"address":[17650212,17649993,17650115,17650686],"length":1,"stats":{"Line":0}},{"line":100,"address":[17864403,17864281],"length":1,"stats":{"Line":0}},{"line":102,"address":[17864948,17865049,17864480,17865272,17864665,17864732],"length":1,"stats":{"Line":0}},{"line":103,"address":[17864569],"length":1,"stats":{"Line":0}},{"line":104,"address":[11194996],"length":1,"stats":{"Line":0}},{"line":106,"address":[15990074],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","post_handler.rs"],"content":"use crate::{\r\n    application::services::{AuthService, PostService},\r\n    presentation::dto::{\r\n        Validate,\r\n        post_dto::{\r\n            BatchBookmarkRequest, BatchGetPostsRequest, BatchReactRequest, BookmarkAction,\r\n            BookmarkPostRequest, CreatePostRequest, DeletePostRequest, GetPostsRequest,\r\n            PostResponse, ReactToPostRequest,\r\n        },\r\n    },\r\n    shared::error::AppError,\r\n};\r\nuse futures::future::join_all;\r\nuse std::sync::Arc;\r\n\r\npub struct PostHandler {\r\n    post_service: Arc<PostService>,\r\n    auth_service: Arc<AuthService>,\r\n}\r\n\r\nimpl PostHandler {\r\n    pub fn new(post_service: Arc<PostService>, auth_service: Arc<AuthService>) -> Self {\r\n        Self {\r\n            post_service,\r\n            auth_service,\r\n        }\r\n    }\r\n\r\n    pub async fn create_post(&self, request: CreatePostRequest) -> Result<PostResponse, AppError> {\r\n        // 入力検証\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        // 現在のユーザーを取得\r\n        let current_user =\r\n            self.auth_service.get_current_user().await?.ok_or_else(|| {\r\n                AppError::Unauthorized(\"ユーザーが認証されていません\".to_string())\r\n            })?;\r\n\r\n        // サービス層を呼び出し\r\n        let post = self\r\n            .post_service\r\n            .create_post(request.content, current_user, request.topic_id)\r\n            .await?;\r\n\r\n        // DTOに変換\r\n        Ok(PostResponse {\r\n            id: post.id.to_string(),\r\n            content: post.content,\r\n            author_pubkey: post.author.pubkey.clone(),\r\n            author_npub: {\r\n                use nostr_sdk::prelude::*;\r\n                PublicKey::from_hex(&post.author.pubkey)\r\n                    .ok()\r\n                    .and_then(|pk| pk.to_bech32().ok())\r\n                    .unwrap_or_else(|| post.author.pubkey.clone())\r\n            },\r\n            topic_id: post.topic_id,\r\n            created_at: post.created_at.timestamp(),\r\n            likes: post.likes,\r\n            boosts: post.boosts,\r\n            replies: post.replies.len() as u32,\r\n            is_synced: post.is_synced,\r\n        })\r\n    }\r\n\r\n    pub async fn get_posts(&self, request: GetPostsRequest) -> Result<Vec<PostResponse>, AppError> {\r\n        let pagination = request.pagination.unwrap_or_default();\r\n\r\n        let posts = if let Some(topic_id) = request.topic_id {\r\n            self.post_service\r\n                .get_posts_by_topic(&topic_id, pagination.limit.unwrap_or(50) as usize)\r\n                .await?\r\n        } else if let Some(author) = request.author_pubkey {\r\n            self.post_service\r\n                .get_posts_by_author(&author, pagination.limit.unwrap_or(50) as usize)\r\n                .await?\r\n        } else {\r\n            self.post_service\r\n                .get_recent_posts(pagination.limit.unwrap_or(50) as usize)\r\n                .await?\r\n        };\r\n\r\n        // 並行処理でnpub変換を行う\r\n        let futures = posts.into_iter().map(|post| {\r\n            async move {\r\n                // npub変換をブロッキングタスクで並行実行\r\n                let npub = tokio::task::spawn_blocking({\r\n                    let pubkey = post.author.pubkey.clone();\r\n                    move || {\r\n                        use nostr_sdk::prelude::*;\r\n                        PublicKey::from_hex(&pubkey)\r\n                            .ok()\r\n                            .and_then(|pk| pk.to_bech32().ok())\r\n                            .unwrap_or(pubkey)\r\n                    }\r\n                })\r\n                .await\r\n                .unwrap_or_else(|_| post.author.pubkey.clone());\r\n\r\n                PostResponse {\r\n                    id: post.id.to_string(),\r\n                    content: post.content,\r\n                    author_pubkey: post.author.pubkey.clone(),\r\n                    author_npub: npub,\r\n                    topic_id: post.topic_id,\r\n                    created_at: post.created_at.timestamp(),\r\n                    likes: post.likes,\r\n                    boosts: post.boosts,\r\n                    replies: post.replies.len() as u32,\r\n                    is_synced: post.is_synced,\r\n                }\r\n            }\r\n        });\r\n\r\n        // すべての変換を並行実行\r\n        let results = join_all(futures).await;\r\n        Ok(results)\r\n    }\r\n\r\n    pub async fn delete_post(&self, request: DeletePostRequest) -> Result<(), AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        self.post_service.delete_post(&request.post_id).await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn react_to_post(&self, request: ReactToPostRequest) -> Result<(), AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        self.post_service\r\n            .react_to_post(&request.post_id, &request.reaction)\r\n            .await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn bookmark_post(\r\n        &self,\r\n        request: BookmarkPostRequest,\r\n        user_pubkey: &str,\r\n    ) -> Result<(), AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        self.post_service\r\n            .bookmark_post(&request.post_id, user_pubkey)\r\n            .await?;\r\n        Ok(())\r\n    }\r\n\r\n    pub async fn unbookmark_post(\r\n        &self,\r\n        request: BookmarkPostRequest,\r\n        user_pubkey: &str,\r\n    ) -> Result<(), AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        self.post_service\r\n            .unbookmark_post(&request.post_id, user_pubkey)\r\n            .await?;\r\n        Ok(())\r\n    }\r\n\r\n    /// ユーザーのブックマーク済み投稿IDを取得\r\n    pub async fn get_bookmarked_post_ids(\r\n        &self,\r\n        user_pubkey: &str,\r\n    ) -> Result<Vec<String>, AppError> {\r\n        let post_ids = self\r\n            .post_service\r\n            .get_bookmarked_post_ids(user_pubkey)\r\n            .await?;\r\n        Ok(post_ids)\r\n    }\r\n\r\n    // バッチ処理メソッド\r\n    pub async fn batch_get_posts(\r\n        &self,\r\n        request: BatchGetPostsRequest,\r\n    ) -> Result<Vec<PostResponse>, AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        // 並行して複数の投稿を取得\r\n        let futures = request.post_ids.iter().map(|post_id| {\r\n            let service = self.post_service.clone();\r\n            let id = post_id.clone();\r\n            async move { service.get_post(&id).await }\r\n        });\r\n\r\n        let results = join_all(futures).await;\r\n\r\n        let mut posts = Vec::new();\r\n        for post in results\r\n            .into_iter()\r\n            .filter_map(|result| result.ok().flatten())\r\n        {\r\n            // npub変換を並行実行\r\n            let author_pubkey = post.author.pubkey.clone();\r\n            let npub = tokio::task::spawn_blocking({\r\n                let pubkey = author_pubkey.clone();\r\n                move || {\r\n                    use nostr_sdk::prelude::*;\r\n                    PublicKey::from_hex(&pubkey)\r\n                        .ok()\r\n                        .and_then(|pk| pk.to_bech32().ok())\r\n                        .unwrap_or(pubkey)\r\n                }\r\n            })\r\n            .await\r\n            .unwrap_or(author_pubkey.clone());\r\n\r\n            posts.push(PostResponse {\r\n                id: post.id.to_string(),\r\n                content: post.content,\r\n                author_pubkey: post.author.pubkey.clone(),\r\n                author_npub: npub,\r\n                topic_id: post.topic_id,\r\n                created_at: post.created_at.timestamp(),\r\n                likes: post.likes,\r\n                boosts: post.boosts,\r\n                replies: post.replies.len() as u32,\r\n                is_synced: post.is_synced,\r\n            });\r\n        }\r\n\r\n        Ok(posts)\r\n    }\r\n\r\n    pub async fn batch_react(\r\n        &self,\r\n        request: BatchReactRequest,\r\n    ) -> Result<Vec<Result<(), String>>, AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        // 並行して複数のリアクションを処理\r\n        let futures = request.reactions.iter().map(|reaction| {\r\n            let service = self.post_service.clone();\r\n            let req = reaction.clone();\r\n            async move {\r\n                service\r\n                    .react_to_post(&req.post_id, &req.reaction)\r\n                    .await\r\n                    .map_err(|e| e.to_string())\r\n            }\r\n        });\r\n\r\n        let results = join_all(futures).await;\r\n        Ok(results)\r\n    }\r\n\r\n    pub async fn batch_bookmark(\r\n        &self,\r\n        request: BatchBookmarkRequest,\r\n        user_pubkey: &str,\r\n    ) -> Result<Vec<Result<(), String>>, AppError> {\r\n        request.validate().map_err(AppError::InvalidInput)?;\r\n\r\n        // 並行して複数のブックマークを処理\r\n        let futures = request.post_ids.iter().map(|post_id| {\r\n            let service = self.post_service.clone();\r\n            let id = post_id.clone();\r\n            let pubkey = user_pubkey.to_string();\r\n            let action = request.action.clone();\r\n\r\n            async move {\r\n                match action {\r\n                    BookmarkAction::Add => service\r\n                        .bookmark_post(&id, &pubkey)\r\n                        .await\r\n                        .map_err(|e| e.to_string()),\r\n                    BookmarkAction::Remove => service\r\n                        .unbookmark_post(&id, &pubkey)\r\n                        .await\r\n                        .map_err(|e| e.to_string()),\r\n                }\r\n            }\r\n        });\r\n\r\n        let results = join_all(futures).await;\r\n        Ok(results)\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[16282576],"length":1,"stats":{"Line":0}},{"line":29,"address":[17053997,17053875,17053920,17057468,17053840,17054748,17055823,17054261],"length":1,"stats":{"Line":0}},{"line":31,"address":[17054488,17054373,17054230,17054720],"length":1,"stats":{"Line":0}},{"line":34,"address":[16284589,16283548,16283221,16284567,16286960,16284183,16283375,16283059],"length":1,"stats":{"Line":0}},{"line":36,"address":[16844110],"length":1,"stats":{"Line":0}},{"line":40,"address":[16841577,16841256,16842171,16841639,16841882,16841962],"length":1,"stats":{"Line":0}},{"line":42,"address":[16284284],"length":1,"stats":{"Line":0}},{"line":43,"address":[18989014],"length":1,"stats":{"Line":0}},{"line":46,"address":[11600959],"length":1,"stats":{"Line":0}},{"line":47,"address":[11600344],"length":1,"stats":{"Line":0}},{"line":48,"address":[17340840],"length":1,"stats":{"Line":0}},{"line":49,"address":[16842292],"length":1,"stats":{"Line":0}},{"line":52,"address":[16285227,16285303,16285384],"length":1,"stats":{"Line":0}},{"line":54,"address":[11602416,11602430],"length":1,"stats":{"Line":0}},{"line":55,"address":[16817537,16815776,16817520],"length":1,"stats":{"Line":0}},{"line":57,"address":[17056650],"length":1,"stats":{"Line":0}},{"line":58,"address":[17056690],"length":1,"stats":{"Line":0}},{"line":59,"address":[16842662],"length":1,"stats":{"Line":0}},{"line":60,"address":[17056769],"length":1,"stats":{"Line":0}},{"line":61,"address":[16285548],"length":1,"stats":{"Line":0}},{"line":62,"address":[11600952],"length":1,"stats":{"Line":0}},{"line":66,"address":[16844681,16844384,16846425,16844431,16845835,16844339,16844304,16847675],"length":1,"stats":{"Line":0}},{"line":67,"address":[17058727],"length":1,"stats":{"Line":0}},{"line":69,"address":[17058953],"length":1,"stats":{"Line":0}},{"line":70,"address":[16288102,16288056,16288840,16289119,16288944,16287813],"length":1,"stats":{"Line":0}},{"line":71,"address":[17059163],"length":1,"stats":{"Line":0}},{"line":72,"address":[10932428],"length":1,"stats":{"Line":0}},{"line":73,"address":[11603537,11603192,11604421,11604575,11605474],"length":1,"stats":{"Line":0}},{"line":74,"address":[16818872,16819807,16818622,16820089,16819911,16818826],"length":1,"stats":{"Line":0}},{"line":75,"address":[17343968],"length":1,"stats":{"Line":0}},{"line":76,"address":[11146549],"length":1,"stats":{"Line":0}},{"line":78,"address":[16845768,16847101,16845722,16846997,16847472,16845382,16847287],"length":1,"stats":{"Line":0}},{"line":79,"address":[11603899],"length":1,"stats":{"Line":0}},{"line":80,"address":[10340530],"length":1,"stats":{"Line":0}},{"line":84,"address":[17344761,17347040,17347675,17345768],"length":1,"stats":{"Line":0}},{"line":85,"address":[16824069,16823974,16822611,16821934,16822576,16822748,16822954],"length":1,"stats":{"Line":0}},{"line":87,"address":[16292466,16292264,16292520,16292793,16292689],"length":1,"stats":{"Line":0}},{"line":88,"address":[17063552],"length":1,"stats":{"Line":0}},{"line":89,"address":[16851008,16851255,16849573,16851283],"length":1,"stats":{"Line":0}},{"line":91,"address":[16293900,16294082,16293984],"length":1,"stats":{"Line":0}},{"line":93,"address":[16851296,16851310],"length":1,"stats":{"Line":0}},{"line":94,"address":[11609411],"length":1,"stats":{"Line":0}},{"line":97,"address":[16292499,16292529,16292375,16292721,16292586],"length":1,"stats":{"Line":0}},{"line":98,"address":[16849920,16849960,16851381,16851360],"length":1,"stats":{"Line":0}},{"line":100,"address":[17064460],"length":1,"stats":{"Line":0}},{"line":101,"address":[16823232],"length":1,"stats":{"Line":0}},{"line":102,"address":[17064129],"length":1,"stats":{"Line":0}},{"line":103,"address":[16292938],"length":1,"stats":{"Line":0}},{"line":104,"address":[16823410],"length":1,"stats":{"Line":0}},{"line":105,"address":[17348536],"length":1,"stats":{"Line":0}},{"line":106,"address":[11608445],"length":1,"stats":{"Line":0}},{"line":107,"address":[16823554],"length":1,"stats":{"Line":0}},{"line":108,"address":[16293168],"length":1,"stats":{"Line":0}},{"line":109,"address":[17064410],"length":1,"stats":{"Line":0}},{"line":110,"address":[16293217],"length":1,"stats":{"Line":0}},{"line":116,"address":[11602998,11605575,11606133],"length":1,"stats":{"Line":0}},{"line":117,"address":[11606355],"length":1,"stats":{"Line":0}},{"line":120,"address":[17065603,17065568,17066719,17065648,17066215,17066590,17065683,17065814],"length":1,"stats":{"Line":0}},{"line":121,"address":[16825067,16825156,16824954,16825358],"length":1,"stats":{"Line":0}},{"line":123,"address":[10960884],"length":1,"stats":{"Line":0}},{"line":124,"address":[16825660],"length":1,"stats":{"Line":0}},{"line":127,"address":[17066736,17067448,17067952,17066771,17066982,17066816,17066851,17067823],"length":1,"stats":{"Line":0}},{"line":128,"address":[17067067,17066954,17067423,17067162],"length":1,"stats":{"Line":0}},{"line":130,"address":[17351828,17351531,17351921,17351322,17351727,17351501,17352075],"length":1,"stats":{"Line":0}},{"line":131,"address":[17351396],"length":1,"stats":{"Line":0}},{"line":132,"address":[10969172],"length":1,"stats":{"Line":0}},{"line":133,"address":[16826893],"length":1,"stats":{"Line":0}},{"line":136,"address":[16296736],"length":1,"stats":{"Line":0}},{"line":141,"address":[16827369,16827577,16827482,16827789],"length":1,"stats":{"Line":0}},{"line":143,"address":[17352861,17352635,17352665,17353209,17352505,17352962,17353055],"length":1,"stats":{"Line":0}},{"line":144,"address":[16827640],"length":1,"stats":{"Line":0}},{"line":145,"address":[11613083,11612806,11612670,11612384,11612941,11612724],"length":1,"stats":{"Line":0}},{"line":146,"address":[17352995],"length":1,"stats":{"Line":0}},{"line":149,"address":[11613296],"length":1,"stats":{"Line":0}},{"line":154,"address":[17353465,17353849,17353653,17353586],"length":1,"stats":{"Line":0}},{"line":156,"address":[17069723,17069593,17070070,17070187,17070345,17069769,17069981],"length":1,"stats":{"Line":0}},{"line":157,"address":[16298440],"length":1,"stats":{"Line":0}},{"line":158,"address":[14323508],"length":1,"stats":{"Line":0}},{"line":159,"address":[16298891],"length":1,"stats":{"Line":0}},{"line":163,"address":[16299136],"length":1,"stats":{"Line":0}},{"line":167,"address":[16856572,16856799,16856615,16856885,16856460,16857059,16857167],"length":1,"stats":{"Line":0}},{"line":170,"address":[19025188],"length":1,"stats":{"Line":0}},{"line":171,"address":[16299835],"length":1,"stats":{"Line":0}},{"line":175,"address":[17355248],"length":1,"stats":{"Line":0}},{"line":179,"address":[16857682,16857432,16857569],"length":1,"stats":{"Line":0}},{"line":182,"address":[16304208,16300513,16304362,16300625],"length":1,"stats":{"Line":0}},{"line":183,"address":[16861372],"length":1,"stats":{"Line":0}},{"line":184,"address":[17359294],"length":1,"stats":{"Line":0}},{"line":185,"address":[17359424,17359347,17359459],"length":1,"stats":{"Line":0}},{"line":188,"address":[14322860],"length":1,"stats":{"Line":0}},{"line":190,"address":[16858406],"length":1,"stats":{"Line":0}},{"line":191,"address":[16860507,16860451,16858474,16858593,16860572],"length":1,"stats":{"Line":0}},{"line":193,"address":[16862324,16862288],"length":1,"stats":{"Line":0}},{"line":196,"address":[16833896],"length":1,"stats":{"Line":0}},{"line":197,"address":[17072996,17075036,17073241,17074979],"length":1,"stats":{"Line":0}},{"line":198,"address":[17358714],"length":1,"stats":{"Line":0}},{"line":199,"address":[17076464,17074947,17076739,17076711],"length":1,"stats":{"Line":0}},{"line":201,"address":[16862578,16862396,16862480],"length":1,"stats":{"Line":0}},{"line":203,"address":[16835934,16835920],"length":1,"stats":{"Line":0}},{"line":204,"address":[16835811],"length":1,"stats":{"Line":0}},{"line":207,"address":[19007520],"length":1,"stats":{"Line":0}},{"line":208,"address":[19007700,19007651],"length":1,"stats":{"Line":0}},{"line":210,"address":[17357638,17357172],"length":1,"stats":{"Line":0}},{"line":211,"address":[16859224],"length":1,"stats":{"Line":0}},{"line":212,"address":[17073387],"length":1,"stats":{"Line":0}},{"line":213,"address":[11617565],"length":1,"stats":{"Line":0}},{"line":214,"address":[17357387],"length":1,"stats":{"Line":0}},{"line":215,"address":[16832723],"length":1,"stats":{"Line":0}},{"line":216,"address":[16832773],"length":1,"stats":{"Line":0}},{"line":217,"address":[11617808],"length":1,"stats":{"Line":0}},{"line":218,"address":[17357570],"length":1,"stats":{"Line":0}},{"line":219,"address":[11617836],"length":1,"stats":{"Line":0}},{"line":220,"address":[16859660],"length":1,"stats":{"Line":0}},{"line":224,"address":[16303532],"length":1,"stats":{"Line":0}},{"line":227,"address":[16862720],"length":1,"stats":{"Line":0}},{"line":231,"address":[17077205,17076994,17077107],"length":1,"stats":{"Line":0}},{"line":234,"address":[17077904,17077175,17078094,17077278,17078120],"length":1,"stats":{"Line":0}},{"line":235,"address":[16863836],"length":1,"stats":{"Line":0}},{"line":236,"address":[16306737],"length":1,"stats":{"Line":0}},{"line":237,"address":[17079032,17078920,17078144,17078010,17078257,17078527,17078179],"length":1,"stats":{"Line":0}},{"line":238,"address":[17362314,17362421,17362115,17361912,17362142],"length":1,"stats":{"Line":0}},{"line":239,"address":[16307110],"length":1,"stats":{"Line":0}},{"line":240,"address":[17078502,17078694,17078284,17078454,17078559],"length":1,"stats":{"Line":0}},{"line":241,"address":[16838272,16838256],"length":1,"stats":{"Line":0}},{"line":245,"address":[16836217,16836785,16836501],"length":1,"stats":{"Line":0}},{"line":246,"address":[17361517],"length":1,"stats":{"Line":0}},{"line":249,"address":[16865104],"length":1,"stats":{"Line":0}},{"line":254,"address":[16308217,16308330,16308434],"length":1,"stats":{"Line":0}},{"line":257,"address":[16309184,16308507,16309516,16308404],"length":1,"stats":{"Line":0}},{"line":258,"address":[17364021],"length":1,"stats":{"Line":0}},{"line":259,"address":[17364039],"length":1,"stats":{"Line":0}},{"line":260,"address":[11624659],"length":1,"stats":{"Line":0}},{"line":261,"address":[16309360,16309421],"length":1,"stats":{"Line":0}},{"line":263,"address":[16866719,16867691,16868070,16866672,16866572,16867394,16866805],"length":1,"stats":{"Line":0}},{"line":264,"address":[16840045],"length":1,"stats":{"Line":0}},{"line":265,"address":[11625351,11625860,11625756,11625093,11625305],"length":1,"stats":{"Line":0}},{"line":266,"address":[17081075],"length":1,"stats":{"Line":0}},{"line":267,"address":[16840099,16840828,16840421,16840690,16840364],"length":1,"stats":{"Line":0}},{"line":268,"address":[16311104,16311120],"length":1,"stats":{"Line":0}},{"line":269,"address":[16867806,16867910,16867333,16866900,16867287],"length":1,"stats":{"Line":0}},{"line":270,"address":[16840452],"length":1,"stats":{"Line":0}},{"line":271,"address":[16310227,16310564,16309720,16310170,16310702],"length":1,"stats":{"Line":0}},{"line":272,"address":[17365936,17365952],"length":1,"stats":{"Line":0}},{"line":277,"address":[16308905,16308272,16308621],"length":1,"stats":{"Line":0}},{"line":278,"address":[17363901],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":145},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","secure_storage_handler.rs"],"content":"use crate::{\n    application::ports::secure_storage::SecureAccountStore,\n    application::services::AuthService,\n    domain::entities::{AccountMetadata, AccountRegistration},\n    presentation::dto::{Validate, auth_dto::LoginResponse},\n    shared::error::AppError,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountRequest {\n    pub nsec: String,\n    pub name: String,\n    pub display_name: String,\n    pub picture: Option<String>,\n}\n\nimpl Validate for AddAccountRequest {\n    fn validate(&self) -> Result<(), String> {\n        if self.nsec.is_empty() {\n            return Err(\"nsec is required\".into());\n        }\n        if self.name.is_empty() {\n            return Err(\"name is required\".into());\n        }\n        if self.display_name.is_empty() {\n            return Err(\"display_name is required\".into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct AddAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SwitchAccountResponse {\n    pub npub: String,\n    pub pubkey: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct GetCurrentAccountResponse {\n    pub npub: String,\n    pub nsec: String,\n    pub pubkey: String,\n    pub metadata: AccountMetadata,\n}\n\npub struct SecureStorageHandler {\n    auth_service: Arc<AuthService>,\n    secure_store: Arc<dyn SecureAccountStore>,\n}\n\nimpl SecureStorageHandler {\n    pub fn new(auth_service: Arc<AuthService>, secure_store: Arc<dyn SecureAccountStore>) -> Self {\n        Self {\n            auth_service,\n            secure_store,\n        }\n    }\n\n    pub async fn add_account(\n        &self,\n        request: AddAccountRequest,\n    ) -> Result<AddAccountResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n        let AddAccountRequest {\n            nsec,\n            name,\n            display_name,\n            picture,\n        } = request;\n\n        // nsecから公開鍵とnpubを生成\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        // セキュアストレージに保存\n        let registration = AccountRegistration {\n            npub: user.npub.clone(),\n            nsec,\n            pubkey: user.pubkey.clone(),\n            name,\n            display_name,\n            picture,\n        };\n        self.secure_store.add_account(registration).await?;\n\n        Ok(AddAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn list_accounts(&self) -> Result<Vec<AccountMetadata>, AppError> {\n        self.secure_store.list_accounts().await\n    }\n\n    pub async fn switch_account(&self, npub: String) -> Result<SwitchAccountResponse, AppError> {\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // 秘密鍵を取得してログイン\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(SwitchAccountResponse {\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n\n    pub async fn remove_account(&self, npub: String) -> Result<(), AppError> {\n        self.secure_store.remove_account(&npub).await\n    }\n\n    pub async fn get_current_account(&self) -> Result<Option<GetCurrentAccountResponse>, AppError> {\n        if let Some(current) = self.secure_store.current_account().await? {\n            let user = self.auth_service.login_with_nsec(&current.nsec).await?;\n\n            Ok(Some(GetCurrentAccountResponse {\n                npub: user.npub,\n                nsec: current.nsec,\n                pubkey: user.pubkey,\n                metadata: current.metadata,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub async fn secure_login(&self, npub: String) -> Result<LoginResponse, AppError> {\n        // セキュアストレージから秘密鍵を取得\n        let nsec = self\n            .secure_store\n            .get_private_key(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Private key not found\".into()))?;\n\n        // アカウントを切り替え\n        self.secure_store.switch_account(&npub).await?;\n\n        // ログイン処理\n        let user = self.auth_service.login_with_nsec(&nsec).await?;\n\n        Ok(LoginResponse {\n            success: true,\n            npub: user.npub,\n            pubkey: user.pubkey,\n        })\n    }\n}\n","traces":[{"line":20,"address":[19497376],"length":1,"stats":{"Line":0}},{"line":21,"address":[19497406],"length":1,"stats":{"Line":0}},{"line":22,"address":[15421834],"length":1,"stats":{"Line":0}},{"line":24,"address":[14041547],"length":1,"stats":{"Line":0}},{"line":25,"address":[19256687],"length":1,"stats":{"Line":0}},{"line":27,"address":[18726272],"length":1,"stats":{"Line":0}},{"line":28,"address":[19256770],"length":1,"stats":{"Line":0}},{"line":30,"address":[19256755],"length":1,"stats":{"Line":0}},{"line":60,"address":[19256848],"length":1,"stats":{"Line":0}},{"line":67,"address":[19256880],"length":1,"stats":{"Line":0}},{"line":71,"address":[19257895,19258184,19257376,19257519],"length":1,"stats":{"Line":0}},{"line":73,"address":[19257603],"length":1,"stats":{"Line":0}},{"line":74,"address":[19498498],"length":1,"stats":{"Line":0}},{"line":75,"address":[19284468],"length":1,"stats":{"Line":0}},{"line":76,"address":[15423018],"length":1,"stats":{"Line":0}},{"line":80,"address":[10446123],"length":1,"stats":{"Line":0}},{"line":84,"address":[14043569],"length":1,"stats":{"Line":0}},{"line":86,"address":[19499666],"length":1,"stats":{"Line":0}},{"line":91,"address":[19500110,19500195,19500431,19498290],"length":1,"stats":{"Line":0}},{"line":93,"address":[15425258],"length":1,"stats":{"Line":0}},{"line":94,"address":[18729645],"length":1,"stats":{"Line":0}},{"line":95,"address":[18729683],"length":1,"stats":{"Line":0}},{"line":99,"address":[19502915,19502864,19503043,19503193,19502872,19503475,19503006,19502880],"length":1,"stats":{"Line":0}},{"line":100,"address":[14356932],"length":1,"stats":{"Line":0}},{"line":103,"address":[19263275,19264022,19262913,19262766,19265686,19262704,19262656,19262664],"length":1,"stats":{"Line":0}},{"line":105,"address":[10987624,10987532],"length":1,"stats":{"Line":0}},{"line":108,"address":[14048910,14049097,14049201,14049345,14048851,14049792,14048733,14049559],"length":1,"stats":{"Line":0}},{"line":110,"address":[19290578],"length":1,"stats":{"Line":0}},{"line":111,"address":[19504863,19503796,19504751,19505001,19505185,19504798],"length":1,"stats":{"Line":0}},{"line":112,"address":[10987705],"length":1,"stats":{"Line":0}},{"line":114,"address":[14047945,14050348,14049802,14049644,14049499],"length":1,"stats":{"Line":0}},{"line":116,"address":[18734857],"length":1,"stats":{"Line":0}},{"line":117,"address":[19291929],"length":1,"stats":{"Line":0}},{"line":118,"address":[19506057],"length":1,"stats":{"Line":0}},{"line":122,"address":[18735962,18735603,18735528,18736320,18735520,18735715,18735568,18736202],"length":1,"stats":{"Line":0}},{"line":123,"address":[19506922,19507226,19506974,19507052],"length":1,"stats":{"Line":0}},{"line":126,"address":[18736368,18736336,18737740,18736573,18736637,18736344,18736430,18736809],"length":1,"stats":{"Line":0}},{"line":127,"address":[19507763,19507835,19508970,19509984,19507932,19508073],"length":1,"stats":{"Line":0}},{"line":128,"address":[14366274],"length":1,"stats":{"Line":0}},{"line":130,"address":[18738288],"length":1,"stats":{"Line":0}},{"line":131,"address":[19268507],"length":1,"stats":{"Line":0}},{"line":132,"address":[19509371],"length":1,"stats":{"Line":0}},{"line":133,"address":[19268589],"length":1,"stats":{"Line":0}},{"line":134,"address":[15433529],"length":1,"stats":{"Line":0}},{"line":137,"address":[18737640],"length":1,"stats":{"Line":0}},{"line":141,"address":[19510176,19510433,19510795,19510184,19511730,19510286,19510224,19513250],"length":1,"stats":{"Line":0}},{"line":143,"address":[19269555,19270896,19269916,19269833,19270104,19270208,19270868,19270352,19270581],"length":1,"stats":{"Line":0}},{"line":145,"address":[19269766],"length":1,"stats":{"Line":0}},{"line":146,"address":[19269873,19269932,19269631,19269995,19270320,19270136],"length":1,"stats":{"Line":0}},{"line":147,"address":[18742128,18742142,18740149],"length":1,"stats":{"Line":0}},{"line":150,"address":[10448636,10448781],"length":1,"stats":{"Line":0}},{"line":153,"address":[14057479,14056306,14056510,14054633,14057080],"length":1,"stats":{"Line":0}},{"line":155,"address":[14056925],"length":1,"stats":{"Line":0}},{"line":157,"address":[15436685],"length":1,"stats":{"Line":0}},{"line":158,"address":[15436717],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","topic_handler.rs"],"content":"use crate::{\n    application::services::TopicService,\n    presentation::dto::{\n        Validate,\n        topic_dto::{\n            CreateTopicRequest, DeleteTopicRequest, GetTopicStatsRequest, JoinTopicRequest,\n            TopicResponse, TopicStatsResponse, UpdateTopicRequest,\n        },\n    },\n    shared::error::AppError,\n};\nuse chrono::Utc;\nuse std::sync::Arc;\n\npub struct TopicHandler {\n    topic_service: Arc<TopicService>,\n}\n\nimpl TopicHandler {\n    pub fn new(topic_service: Arc<TopicService>) -> Self {\n        Self { topic_service }\n    }\n\n    pub async fn create_topic(\n        &self,\n        request: CreateTopicRequest,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let topic = self\n            .topic_service\n            .create_topic(request.name, Some(request.description))\n            .await?;\n\n        Ok(TopicResponse {\n            id: topic.id.to_string(),\n            name: topic.name,\n            description: topic.description.unwrap_or_default(),\n            image_url: topic.image_url,\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn get_topic(&self, id: &str) -> Result<Option<TopicResponse>, AppError> {\n        let topic = self.topic_service.get_topic(id).await?;\n\n        Ok(topic.map(|t| TopicResponse {\n            id: t.id.to_string(),\n            name: t.name,\n            description: t.description.unwrap_or_default(),\n            image_url: t.image_url,\n            member_count: t.member_count,\n            post_count: t.post_count,\n            is_joined: t.is_joined,\n            created_at: t.created_at.timestamp(),\n            updated_at: t.updated_at.timestamp(),\n        }))\n    }\n\n    pub async fn update_topic(\n        &self,\n        request: UpdateTopicRequest,\n    ) -> Result<TopicResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let mut topic = self\n            .topic_service\n            .get_topic(&request.id)\n            .await?\n            .ok_or_else(|| AppError::NotFound(\"Topic not found\".to_string()))?;\n\n        if let Some(name) = request.name {\n            topic.name = name;\n        }\n        if let Some(description) = request.description {\n            topic.description = Some(description);\n        }\n        if let Some(image_url) = request.image_url {\n            topic.image_url = if image_url.is_empty() {\n                None\n            } else {\n                Some(image_url)\n            };\n        }\n        topic.updated_at = Utc::now();\n\n        self.topic_service.update_topic(&topic).await?;\n\n        Ok(TopicResponse {\n            id: topic.id.clone(),\n            name: topic.name.clone(),\n            description: topic.description.clone().unwrap_or_default(),\n            image_url: topic.image_url.clone(),\n            member_count: topic.member_count,\n            post_count: topic.post_count,\n            is_joined: topic.is_joined,\n            created_at: topic.created_at.timestamp(),\n            updated_at: topic.updated_at.timestamp(),\n        })\n    }\n\n    pub async fn delete_topic(&self, request: DeleteTopicRequest) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service.delete_topic(&request.id).await?;\n        Ok(())\n    }\n\n    pub async fn get_all_topics(&self) -> Result<Vec<TopicResponse>, AppError> {\n        let topics = self.topic_service.get_all_topics().await?;\n\n        Ok(topics\n            .into_iter()\n            .map(|t| TopicResponse {\n                id: t.id.to_string(),\n                name: t.name,\n                description: t.description.unwrap_or_default(),\n                image_url: t.image_url,\n                member_count: t.member_count,\n                post_count: t.post_count,\n                is_joined: t.is_joined,\n                created_at: t.created_at.timestamp(),\n                updated_at: t.updated_at.timestamp(),\n            })\n            .collect())\n    }\n\n    pub async fn get_joined_topics(\n        &self,\n        user_pubkey: &str,\n    ) -> Result<Vec<TopicResponse>, AppError> {\n        let topics = self.topic_service.get_joined_topics(user_pubkey).await?;\n\n        Ok(topics\n            .into_iter()\n            .map(|t| TopicResponse {\n                id: t.id.to_string(),\n                name: t.name,\n                description: t.description.unwrap_or_default(),\n                image_url: t.image_url,\n                member_count: t.member_count,\n                post_count: t.post_count,\n                is_joined: true,\n                created_at: t.created_at.timestamp(),\n                updated_at: t.updated_at.timestamp(),\n            })\n            .collect())\n    }\n\n    pub async fn join_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .join_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn leave_topic(\n        &self,\n        request: JoinTopicRequest,\n        user_pubkey: &str,\n    ) -> Result<(), AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        self.topic_service\n            .leave_topic(&request.topic_id, user_pubkey)\n            .await?;\n        Ok(())\n    }\n\n    pub async fn get_topic_stats(\n        &self,\n        request: GetTopicStatsRequest,\n    ) -> Result<TopicStatsResponse, AppError> {\n        request.validate().map_err(AppError::InvalidInput)?;\n\n        let (member_count, post_count) = self\n            .topic_service\n            .get_topic_stats(&request.topic_id)\n            .await?;\n\n        let active_users_24h = member_count.min(post_count);\n        let trending_score = if member_count == 0 && post_count == 0 {\n            0.0\n        } else {\n            (post_count as f64 * 0.6) + (member_count as f64 * 0.4)\n        };\n\n        Ok(TopicStatsResponse {\n            topic_id: request.topic_id,\n            member_count,\n            post_count,\n            active_users_24h,\n            trending_score,\n        })\n    }\n}\n","traces":[{"line":20,"address":[19299360],"length":1,"stats":{"Line":0}},{"line":24,"address":[14057600],"length":1,"stats":{"Line":0}},{"line":28,"address":[19299937,19299717,19300314,19299836],"length":1,"stats":{"Line":0}},{"line":30,"address":[19514017,19514346,19514284,19514616,19514690,19514907],"length":1,"stats":{"Line":0}},{"line":32,"address":[18742926],"length":1,"stats":{"Line":0}},{"line":33,"address":[19299775,19300374,19300223,19300522,19300283,19300779],"length":1,"stats":{"Line":0}},{"line":35,"address":[19301228],"length":1,"stats":{"Line":0}},{"line":36,"address":[18743624],"length":1,"stats":{"Line":0}},{"line":37,"address":[18643496],"length":1,"stats":{"Line":0}},{"line":38,"address":[19515028],"length":1,"stats":{"Line":0}},{"line":39,"address":[18743907],"length":1,"stats":{"Line":0}},{"line":40,"address":[19515179],"length":1,"stats":{"Line":0}},{"line":41,"address":[14059318],"length":1,"stats":{"Line":0}},{"line":42,"address":[19301105],"length":1,"stats":{"Line":0}},{"line":43,"address":[18643720],"length":1,"stats":{"Line":0}},{"line":44,"address":[19515280],"length":1,"stats":{"Line":0}},{"line":48,"address":[18745216,18745299,18745428,18745633,18745476,18745264,18745234,18746277],"length":1,"stats":{"Line":0}},{"line":49,"address":[19302671,19302548,19302591,19302801,19303209],"length":1,"stats":{"Line":0}},{"line":51,"address":[18646000,18646447,18645883,18646629,18645738],"length":1,"stats":{"Line":0}},{"line":52,"address":[14061686],"length":1,"stats":{"Line":0}},{"line":53,"address":[19303572],"length":1,"stats":{"Line":0}},{"line":54,"address":[19303598],"length":1,"stats":{"Line":0}},{"line":55,"address":[19303700],"length":1,"stats":{"Line":0}},{"line":56,"address":[19517828],"length":1,"stats":{"Line":0}},{"line":57,"address":[14061966],"length":1,"stats":{"Line":0}},{"line":58,"address":[19517848],"length":1,"stats":{"Line":0}},{"line":59,"address":[19303762],"length":1,"stats":{"Line":0}},{"line":60,"address":[19517927],"length":1,"stats":{"Line":0}},{"line":64,"address":[19518352],"length":1,"stats":{"Line":0}},{"line":68,"address":[19277892,19278360,19278137,19278029],"length":1,"stats":{"Line":0}},{"line":70,"address":[19519475,19518941,19519628,19519398,19519865,19521262,19519128,19519082],"length":1,"stats":{"Line":0}},{"line":72,"address":[19278206],"length":1,"stats":{"Line":0}},{"line":73,"address":[18647242,18647557,18647597,18647684,18647824,18648008],"length":1,"stats":{"Line":0}},{"line":74,"address":[19519833,19524192,19524206],"length":1,"stats":{"Line":0}},{"line":76,"address":[19305690,19306069,19305806],"length":1,"stats":{"Line":0}},{"line":77,"address":[18648355,18648435],"length":1,"stats":{"Line":0}},{"line":79,"address":[19279367,19279665,19279152],"length":1,"stats":{"Line":0}},{"line":80,"address":[19279532,19279420],"length":1,"stats":{"Line":0}},{"line":82,"address":[19280124,19279481,19279670],"length":1,"stats":{"Line":0}},{"line":83,"address":[18749339,18749653,18749417,18749547,18749527],"length":1,"stats":{"Line":0}},{"line":84,"address":[18649157],"length":1,"stats":{"Line":0}},{"line":86,"address":[19520655],"length":1,"stats":{"Line":0}},{"line":89,"address":[19306972,19306486],"length":1,"stats":{"Line":0}},{"line":91,"address":[19307479,19307176,19307008,19304704],"length":1,"stats":{"Line":0}},{"line":93,"address":[18750822],"length":1,"stats":{"Line":0}},{"line":94,"address":[18750309],"length":1,"stats":{"Line":0}},{"line":95,"address":[14065772],"length":1,"stats":{"Line":0}},{"line":96,"address":[18750490,18750565],"length":1,"stats":{"Line":0}},{"line":97,"address":[19521824],"length":1,"stats":{"Line":0}},{"line":98,"address":[19307803],"length":1,"stats":{"Line":0}},{"line":99,"address":[18650277],"length":1,"stats":{"Line":0}},{"line":100,"address":[19307831],"length":1,"stats":{"Line":0}},{"line":101,"address":[18650297],"length":1,"stats":{"Line":0}},{"line":102,"address":[19522001],"length":1,"stats":{"Line":0}},{"line":106,"address":[19283456,19284063,19284438,19283464,19283504,19284567,19283662,19283539],"length":1,"stats":{"Line":0}},{"line":107,"address":[14068594,14068796,14068998,14068707],"length":1,"stats":{"Line":0}},{"line":109,"address":[10973972],"length":1,"stats":{"Line":0}},{"line":110,"address":[18753940],"length":1,"stats":{"Line":0}},{"line":113,"address":[19311674,19311320,19311312,19311453,19311363,19311501,19312382,19311328],"length":1,"stats":{"Line":0}},{"line":114,"address":[14325268],"length":1,"stats":{"Line":0}},{"line":116,"address":[14070391,14070226],"length":1,"stats":{"Line":0}},{"line":118,"address":[18655381,18654736,18655199],"length":1,"stats":{"Line":0}},{"line":119,"address":[19285718],"length":1,"stats":{"Line":0}},{"line":120,"address":[14070788],"length":1,"stats":{"Line":0}},{"line":121,"address":[19285854],"length":1,"stats":{"Line":0}},{"line":122,"address":[14070916],"length":1,"stats":{"Line":0}},{"line":123,"address":[18655044],"length":1,"stats":{"Line":0}},{"line":124,"address":[14070958],"length":1,"stats":{"Line":0}},{"line":125,"address":[19312744],"length":1,"stats":{"Line":0}},{"line":126,"address":[19526850],"length":1,"stats":{"Line":0}},{"line":127,"address":[19286087],"length":1,"stats":{"Line":0}},{"line":132,"address":[14071472],"length":1,"stats":{"Line":0}},{"line":136,"address":[10990612],"length":1,"stats":{"Line":0}},{"line":138,"address":[14072220,14072388],"length":1,"stats":{"Line":0}},{"line":140,"address":[19528945,19528496,19529122],"length":1,"stats":{"Line":0}},{"line":141,"address":[19287702],"length":1,"stats":{"Line":0}},{"line":142,"address":[18757412],"length":1,"stats":{"Line":0}},{"line":143,"address":[19314574],"length":1,"stats":{"Line":0}},{"line":144,"address":[19314676],"length":1,"stats":{"Line":0}},{"line":145,"address":[18757572],"length":1,"stats":{"Line":0}},{"line":146,"address":[18656990],"length":1,"stats":{"Line":0}},{"line":148,"address":[18757592],"length":1,"stats":{"Line":0}},{"line":149,"address":[14073021],"length":1,"stats":{"Line":0}},{"line":154,"address":[19315216],"length":1,"stats":{"Line":0}},{"line":159,"address":[18657721,18657909,18657842,18658105],"length":1,"stats":{"Line":0}},{"line":161,"address":[19529737,19530331,19530214,19530489,19530125,19529913,19529867],"length":1,"stats":{"Line":0}},{"line":162,"address":[18758584],"length":1,"stats":{"Line":0}},{"line":163,"address":[19530022,19530299,19530157,19529600,19529886,19529940],"length":1,"stats":{"Line":0}},{"line":164,"address":[14074395],"length":1,"stats":{"Line":0}},{"line":167,"address":[18658624],"length":1,"stats":{"Line":0}},{"line":172,"address":[18659241,18659045,18658978,18658857],"length":1,"stats":{"Line":0}},{"line":174,"address":[18659490,18659583,18659389,18659737,18659033,18659163,18659193],"length":1,"stats":{"Line":0}},{"line":175,"address":[14075144],"length":1,"stats":{"Line":0}},{"line":176,"address":[11183476],"length":1,"stats":{"Line":0}},{"line":177,"address":[19317371],"length":1,"stats":{"Line":0}},{"line":180,"address":[18760480],"length":1,"stats":{"Line":0}},{"line":184,"address":[19532297,19532000,19532095,19531887],"length":1,"stats":{"Line":0}},{"line":186,"address":[18660111,18660558,18661034,18660454,18660258,18660688,18660228],"length":1,"stats":{"Line":0}},{"line":188,"address":[19318062],"length":1,"stats":{"Line":0}},{"line":189,"address":[10958481],"length":1,"stats":{"Line":0}},{"line":191,"address":[18761512,18761420],"length":1,"stats":{"Line":0}},{"line":192,"address":[19532824,19532751],"length":1,"stats":{"Line":0}},{"line":193,"address":[14076954],"length":1,"stats":{"Line":0}},{"line":195,"address":[19532773],"length":1,"stats":{"Line":0}},{"line":198,"address":[19292068],"length":1,"stats":{"Line":0}},{"line":199,"address":[18660835],"length":1,"stats":{"Line":0}},{"line":203,"address":[18660876],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":107},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","handlers","user_handler.rs"],"content":"use crate::{\n    application::services::UserService, presentation::dto::user_dto::UserProfile,\n    shared::error::AppError,\n};\nuse std::sync::Arc;\n\npub struct UserHandler {\n    user_service: Arc<UserService>,\n}\n\nimpl UserHandler {\n    pub fn new(user_service: Arc<UserService>) -> Self {\n        Self { user_service }\n    }\n\n    pub async fn get_user_profile(&self, npub: String) -> Result<UserProfile, AppError> {\n        let user = self\n            .user_service\n            .get_user(&npub)\n            .await?\n            .ok_or_else(|| AppError::NotFound(format!(\"User not found: {npub}\")))?;\n\n        Ok(UserProfile {\n            npub: user.npub.clone(),\n            pubkey: user.pubkey.clone(),\n            name: user.name.clone(),\n            display_name: user.profile.display_name.clone().into(),\n            about: user.profile.bio.clone().into(),\n            picture: user.profile.avatar_url.clone(),\n            banner: None,\n            website: None,\n            nip05: user.nip05.clone(),\n        })\n    }\n\n    pub async fn update_user_profile(&self, profile: UserProfile) -> Result<(), AppError> {\n        let user = crate::domain::entities::user::User {\n            npub: profile.npub,\n            pubkey: profile.pubkey,\n            profile: crate::domain::entities::user::UserProfile {\n                display_name: profile.display_name.unwrap_or_default(),\n                bio: profile.about.unwrap_or_default(),\n                avatar_url: profile.picture,\n            },\n            name: profile.name,\n            nip05: profile.nip05,\n            lud16: None,\n            created_at: chrono::Utc::now(),\n            updated_at: chrono::Utc::now(),\n        };\n\n        self.user_service.update_user(user).await?;\n        Ok(())\n    }\n\n    pub async fn get_followers(&self, npub: String) -> Result<Vec<UserProfile>, AppError> {\n        let followers = self.user_service.get_followers(&npub).await?;\n\n        Ok(followers\n            .into_iter()\n            .map(|user| UserProfile {\n                npub: user.npub,\n                pubkey: user.pubkey,\n                name: user.name,\n                display_name: Some(user.profile.display_name),\n                about: Some(user.profile.bio),\n                picture: user.profile.avatar_url,\n                banner: None,\n                website: None,\n                nip05: user.nip05,\n            })\n            .collect())\n    }\n\n    pub async fn get_following(&self, npub: String) -> Result<Vec<UserProfile>, AppError> {\n        let following = self.user_service.get_following(&npub).await?;\n\n        Ok(following\n            .into_iter()\n            .map(|user| UserProfile {\n                npub: user.npub,\n                pubkey: user.pubkey,\n                name: user.name,\n                display_name: Some(user.profile.display_name),\n                about: Some(user.profile.bio),\n                picture: user.profile.avatar_url,\n                banner: None,\n                website: None,\n                nip05: user.nip05,\n            })\n            .collect())\n    }\n}\n","traces":[{"line":12,"address":[15640016],"length":1,"stats":{"Line":0}},{"line":16,"address":[18986080,18984120,18984522,18984298,18984160,18986169,18984195,18984112],"length":1,"stats":{"Line":0}},{"line":17,"address":[15083254,15083927,15085025,15083478,15083540,15083702,15083208,15085003,15083651,15083066],"length":1,"stats":{"Line":0}},{"line":19,"address":[15613567],"length":1,"stats":{"Line":0}},{"line":20,"address":[15437633,15437984,15438162,15437763,15437850,15437797],"length":1,"stats":{"Line":0}},{"line":21,"address":[15614295,15615461,15614042,15615440],"length":1,"stats":{"Line":0}},{"line":23,"address":[15614910],"length":1,"stats":{"Line":0}},{"line":24,"address":[15614276],"length":1,"stats":{"Line":0}},{"line":25,"address":[15641141],"length":1,"stats":{"Line":0}},{"line":26,"address":[15438549],"length":1,"stats":{"Line":0}},{"line":27,"address":[18985425,18985357],"length":1,"stats":{"Line":0}},{"line":28,"address":[15084311,15084243],"length":1,"stats":{"Line":0}},{"line":29,"address":[15438813],"length":1,"stats":{"Line":0}},{"line":30,"address":[15438891],"length":1,"stats":{"Line":0}},{"line":31,"address":[18985647],"length":1,"stats":{"Line":0}},{"line":32,"address":[15614839],"length":1,"stats":{"Line":0}},{"line":36,"address":[15643880,15642387,15642467,15644518,15642352,15642814,15644003,15642432],"length":1,"stats":{"Line":0}},{"line":38,"address":[15085546],"length":1,"stats":{"Line":0}},{"line":39,"address":[15642717],"length":1,"stats":{"Line":0}},{"line":40,"address":[15440391],"length":1,"stats":{"Line":0}},{"line":45,"address":[15857255],"length":1,"stats":{"Line":0}},{"line":46,"address":[15643206],"length":1,"stats":{"Line":0}},{"line":48,"address":[15440599],"length":1,"stats":{"Line":0}},{"line":49,"address":[15643334],"length":1,"stats":{"Line":0}},{"line":52,"address":[18987738,18987799,18986921,18988115,18988413],"length":1,"stats":{"Line":0}},{"line":53,"address":[15087150],"length":1,"stats":{"Line":0}},{"line":56,"address":[15087936,15088362,15087944,15089124,15088130,15087984,15088019,15088987],"length":1,"stats":{"Line":0}},{"line":57,"address":[15859986,15859346,15859455,15859626,15859389],"length":1,"stats":{"Line":0}},{"line":59,"address":[15443077,15443253],"length":1,"stats":{"Line":0}},{"line":61,"address":[15646304,15646696],"length":1,"stats":{"Line":0}},{"line":62,"address":[15443572],"length":1,"stats":{"Line":0}},{"line":63,"address":[15089230],"length":1,"stats":{"Line":0}},{"line":64,"address":[15619657],"length":1,"stats":{"Line":0}},{"line":65,"address":[15443658],"length":1,"stats":{"Line":0}},{"line":66,"address":[18990575],"length":1,"stats":{"Line":0}},{"line":67,"address":[15646579],"length":1,"stats":{"Line":0}},{"line":68,"address":[15646615],"length":1,"stats":{"Line":0}},{"line":69,"address":[15619897],"length":1,"stats":{"Line":0}},{"line":70,"address":[15646651],"length":1,"stats":{"Line":0}},{"line":75,"address":[15861578,15862340,15861346,15861235,15861160,15862203,15861200,15861152],"length":1,"stats":{"Line":0}},{"line":76,"address":[15620498,15620607,15620541,15621138,15620778],"length":1,"stats":{"Line":0}},{"line":78,"address":[15090677,15090845],"length":1,"stats":{"Line":0}},{"line":80,"address":[18992760,18992368],"length":1,"stats":{"Line":0}},{"line":81,"address":[15648324],"length":1,"stats":{"Line":0}},{"line":82,"address":[15621614],"length":1,"stats":{"Line":0}},{"line":83,"address":[15862473],"length":1,"stats":{"Line":0}},{"line":84,"address":[15445594],"length":1,"stats":{"Line":0}},{"line":85,"address":[15862575],"length":1,"stats":{"Line":0}},{"line":86,"address":[15862659],"length":1,"stats":{"Line":0}},{"line":87,"address":[15621863],"length":1,"stats":{"Line":0}},{"line":88,"address":[15445801],"length":1,"stats":{"Line":0}},{"line":89,"address":[15445819],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","app","kukuri-tauri","src-tauri","src","presentation","mod.rs"],"content":"#![allow(dead_code)]\n\npub mod commands;\npub mod dto;\npub mod handlers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","config.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AppConfig {\n    pub database: DatabaseConfig,\n    pub network: NetworkConfig,\n    pub sync: SyncConfig,\n    pub storage: StorageConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    pub url: String,\n    pub max_connections: u32,\n    pub connection_timeout: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NetworkConfig {\n    pub bootstrap_peers: Vec<String>,\n    pub max_peers: u32,\n    pub connection_timeout: u64,\n    pub retry_interval: u64,\n    // DHT/Discovery 関連フラグ\n    pub enable_dht: bool,\n    pub enable_dns: bool,\n    pub enable_local: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SyncConfig {\n    pub auto_sync: bool,\n    pub sync_interval: u64,\n    pub max_retry: u32,\n    pub batch_size: u32,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StorageConfig {\n    pub data_dir: String,\n    pub cache_size: u64,\n    pub cache_ttl: u64,\n}\n\nimpl Default for AppConfig {\n    fn default() -> Self {\n        Self {\n            database: DatabaseConfig {\n                url: \"sqlite:data/kukuri.db\".to_string(),\n                max_connections: 5,\n                connection_timeout: 30,\n            },\n            network: NetworkConfig {\n                bootstrap_peers: vec![],\n                max_peers: 50,\n                connection_timeout: 30,\n                retry_interval: 60,\n                enable_dht: true,\n                enable_dns: true,\n                enable_local: false,\n            },\n            sync: SyncConfig {\n                auto_sync: true,\n                sync_interval: 300, // 5 minutes\n                max_retry: 3,\n                batch_size: 100,\n            },\n            storage: StorageConfig {\n                data_dir: \"./data\".to_string(),\n                cache_size: 100 * 1024 * 1024, // 100MB\n                cache_ttl: 3600,               // 1 hour\n            },\n        }\n    }\n}\n\nimpl AppConfig {\n    pub fn from_env() -> Self {\n        // 既定値\n        let mut cfg = Self::default();\n\n        // ネットワーク設定の環境変数反映\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DHT\") {\n            cfg.network.enable_dht = parse_bool(&v, cfg.network.enable_dht);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_DNS\") {\n            cfg.network.enable_dns = parse_bool(&v, cfg.network.enable_dns);\n        }\n        if let Ok(v) = std::env::var(\"KUKURI_ENABLE_LOCAL\") {\n            cfg.network.enable_local = parse_bool(&v, cfg.network.enable_local);\n        }\n\n        if let Ok(v) = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\") {\n            let peers: Vec<String> = v\n                .split(',')\n                .map(|s| s.trim().to_string())\n                .filter(|s| !s.is_empty())\n                .collect();\n            if !peers.is_empty() {\n                cfg.network.bootstrap_peers = peers;\n            }\n        }\n\n        cfg\n    }\n\n    pub fn validate(&self) -> Result<(), String> {\n        if self.database.max_connections == 0 {\n            return Err(\"Database max_connections must be greater than 0\".to_string());\n        }\n        if self.network.max_peers == 0 {\n            return Err(\"Network max_peers must be greater than 0\".to_string());\n        }\n        Ok(())\n    }\n}\n\nfn parse_bool(s: &str, default: bool) -> bool {\n    match s.to_ascii_lowercase().as_str() {\n        \"1\" | \"true\" | \"yes\" | \"on\" => true,\n        \"0\" | \"false\" | \"no\" | \"off\" => false,\n        _ => default,\n    }\n}\n","traces":[{"line":46,"address":[12987809,12987136],"length":1,"stats":{"Line":1}},{"line":48,"address":[13013915],"length":1,"stats":{"Line":1}},{"line":53,"address":[13228108],"length":1,"stats":{"Line":1}},{"line":62,"address":[13041882],"length":1,"stats":{"Line":1}},{"line":68,"address":[13014332],"length":1,"stats":{"Line":1}},{"line":78,"address":[13228672,13229078,13230472],"length":1,"stats":{"Line":0}},{"line":80,"address":[16358673],"length":1,"stats":{"Line":0}},{"line":83,"address":[13042455,13042387],"length":1,"stats":{"Line":0}},{"line":84,"address":[16358818,16358908],"length":1,"stats":{"Line":0}},{"line":86,"address":[13015013,13014932],"length":1,"stats":{"Line":0}},{"line":87,"address":[12988418,12988328],"length":1,"stats":{"Line":0}},{"line":89,"address":[13229354,13229426],"length":1,"stats":{"Line":0}},{"line":90,"address":[16359551,16359461],"length":1,"stats":{"Line":0}},{"line":93,"address":[13229671,13229743],"length":1,"stats":{"Line":0}},{"line":94,"address":[13229794,13229887],"length":1,"stats":{"Line":0}},{"line":96,"address":[16360533,16360480],"length":1,"stats":{"Line":0}},{"line":97,"address":[12989760,12989785],"length":1,"stats":{"Line":0}},{"line":99,"address":[13230068,13230275,13230000],"length":1,"stats":{"Line":0}},{"line":100,"address":[13230074,13230152],"length":1,"stats":{"Line":0}},{"line":104,"address":[12989549],"length":1,"stats":{"Line":0}},{"line":107,"address":[12989808],"length":1,"stats":{"Line":0}},{"line":108,"address":[13230664],"length":1,"stats":{"Line":0}},{"line":109,"address":[16360654],"length":1,"stats":{"Line":0}},{"line":111,"address":[13016635],"length":1,"stats":{"Line":0}},{"line":112,"address":[13044413],"length":1,"stats":{"Line":0}},{"line":114,"address":[13044474],"length":1,"stats":{"Line":0}},{"line":118,"address":[13231354,13230832],"length":1,"stats":{"Line":0}},{"line":119,"address":[13230952,13230877],"length":1,"stats":{"Line":0}},{"line":120,"address":[13230968],"length":1,"stats":{"Line":0}},{"line":121,"address":[13044814],"length":1,"stats":{"Line":0}},{"line":122,"address":[13044987],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":31},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","error.rs"],"content":"use serde::Serialize;\nuse thiserror::Error;\n\n#[derive(Debug, Error, Serialize)]\npub enum AppError {\n    #[error(\"Database error: {0}\")]\n    Database(String),\n    #[error(\"Network error: {0}\")]\n    Network(String),\n    #[error(\"Crypto error: {0}\")]\n    Crypto(String),\n    #[error(\"Storage error: {0}\")]\n    Storage(String),\n    #[error(\"Auth error: {0}\")]\n    Auth(String),\n    #[error(\"Unauthorized: {0}\")]\n    Unauthorized(String),\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n    #[error(\"Validation error: {0}\")]\n    ValidationError(String),\n    #[error(\"Nostr error: {0}\")]\n    NostrError(String),\n    #[error(\"P2P error: {0}\")]\n    P2PError(String),\n    #[error(\"Configuration error: {0}\")]\n    ConfigurationError(String),\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n    #[error(\"Deserialization error: {0}\")]\n    DeserializationError(String),\n    #[error(\"Not implemented: {0}\")]\n    NotImplemented(String),\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n}\n\nimpl AppError {\n    pub fn code(&self) -> &'static str {\n        match self {\n            AppError::Database(_) => \"DATABASE_ERROR\",\n            AppError::Network(_) => \"NETWORK_ERROR\",\n            AppError::Crypto(_) => \"CRYPTO_ERROR\",\n            AppError::Storage(_) => \"STORAGE_ERROR\",\n            AppError::Auth(_) => \"AUTH_ERROR\",\n            AppError::Unauthorized(_) => \"UNAUTHORIZED\",\n            AppError::NotFound(_) => \"NOT_FOUND\",\n            AppError::InvalidInput(_) => \"INVALID_INPUT\",\n            AppError::ValidationError(_) => \"VALIDATION_ERROR\",\n            AppError::NostrError(_) => \"NOSTR_ERROR\",\n            AppError::P2PError(_) => \"P2P_ERROR\",\n            AppError::ConfigurationError(_) => \"CONFIGURATION_ERROR\",\n            AppError::SerializationError(_) => \"SERIALIZATION_ERROR\",\n            AppError::DeserializationError(_) => \"DESERIALIZATION_ERROR\",\n            AppError::NotImplemented(_) => \"NOT_IMPLEMENTED\",\n            AppError::Internal(_) => \"INTERNAL_ERROR\",\n        }\n    }\n\n    pub fn user_message(&self) -> String {\n        match self {\n            AppError::Database(_) => \"データベース処理中にエラーが発生しました。\",\n            AppError::Network(_) => \"ネットワーク通信でエラーが発生しました。\",\n            AppError::Crypto(_) => \"暗号処理でエラーが発生しました。\",\n            AppError::Storage(_) => \"ストレージ操作でエラーが発生しました。\",\n            AppError::Auth(_) => \"認証処理に失敗しました。\",\n            AppError::Unauthorized(_) => \"この操作を行うにはログインが必要です。\",\n            AppError::NotFound(_) => \"対象のデータが見つかりませんでした。\",\n            AppError::InvalidInput(_) => \"入力値に誤りがあります。\",\n            AppError::ValidationError(_) => \"入力の検証でエラーが発生しました。\",\n            AppError::NostrError(_) => \"Nostr処理でエラーが発生しました。\",\n            AppError::P2PError(_) => \"P2P処理でエラーが発生しました。\",\n            AppError::ConfigurationError(_) => \"アプリ設定に問題があります。\",\n            AppError::SerializationError(_) => \"データ変換でエラーが発生しました。\",\n            AppError::DeserializationError(_) => \"データ読み込みでエラーが発生しました。\",\n            AppError::NotImplemented(_) => \"この機能はまだ実装されていません。\",\n            AppError::Internal(_) => \"内部エラーが発生しました。\",\n        }\n        .to_string()\n    }\n}\n\nimpl From<sqlx::Error> for AppError {\n    fn from(err: sqlx::Error) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error>> for AppError {\n    fn from(err: Box<dyn std::error::Error>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<Box<dyn std::error::Error + Send + Sync>> for AppError {\n    fn from(err: Box<dyn std::error::Error + Send + Sync>) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<String> for AppError {\n    fn from(err: String) -> Self {\n        AppError::Internal(err)\n    }\n}\n\nimpl From<&str> for AppError {\n    fn from(err: &str) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::EventId> for AppError {\n    fn from(_: nostr_sdk::prelude::EventId) -> Self {\n        AppError::NostrError(\"Invalid EventId conversion\".to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::Error> for AppError {\n    fn from(err: nostr_sdk::event::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::prelude::secp256k1::Error> for AppError {\n    fn from(err: nostr_sdk::prelude::secp256k1::Error) -> Self {\n        AppError::Crypto(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::key::Error> for AppError {\n    fn from(err: nostr_sdk::key::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<nostr_sdk::event::builder::Error> for AppError {\n    fn from(err: nostr_sdk::event::builder::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\nimpl From<serde_json::Error> for AppError {\n    fn from(err: serde_json::Error) -> Self {\n        AppError::Internal(err.to_string())\n    }\n}\n\nimpl From<anyhow::Error> for AppError {\n    fn from(err: anyhow::Error) -> Self {\n        AppError::P2PError(err.to_string())\n    }\n}\n\nimpl From<sqlx::migrate::MigrateError> for AppError {\n    fn from(err: sqlx::migrate::MigrateError) -> Self {\n        AppError::Database(err.to_string())\n    }\n}\n\nimpl From<iroh::endpoint::Builder> for AppError {\n    fn from(err: iroh::endpoint::Builder) -> Self {\n        AppError::P2PError(format!(\"Endpoint builder error: {err:?}\"))\n    }\n}\n\nimpl From<nostr_sdk::key::vanity::Error> for AppError {\n    fn from(err: nostr_sdk::key::vanity::Error) -> Self {\n        AppError::NostrError(err.to_string())\n    }\n}\n\npub type Result<T> = std::result::Result<T, AppError>;\n","traces":[{"line":41,"address":[14000032],"length":1,"stats":{"Line":0}},{"line":42,"address":[15446229],"length":1,"stats":{"Line":0}},{"line":43,"address":[14000068],"length":1,"stats":{"Line":0}},{"line":44,"address":[17901310],"length":1,"stats":{"Line":0}},{"line":45,"address":[14557256],"length":1,"stats":{"Line":0}},{"line":46,"address":[14530546],"length":1,"stats":{"Line":0}},{"line":47,"address":[14000172],"length":1,"stats":{"Line":0}},{"line":48,"address":[17901414],"length":1,"stats":{"Line":0}},{"line":49,"address":[14530624],"length":1,"stats":{"Line":0}},{"line":50,"address":[17901466],"length":1,"stats":{"Line":0}},{"line":51,"address":[14557412],"length":1,"stats":{"Line":0}},{"line":52,"address":[14530702],"length":1,"stats":{"Line":0}},{"line":53,"address":[14557464],"length":1,"stats":{"Line":0}},{"line":54,"address":[14771583],"length":1,"stats":{"Line":0}},{"line":55,"address":[15446566],"length":1,"stats":{"Line":0}},{"line":56,"address":[14000397],"length":1,"stats":{"Line":0}},{"line":57,"address":[15446612],"length":1,"stats":{"Line":0}},{"line":58,"address":[14530843],"length":1,"stats":{"Line":0}},{"line":62,"address":[14530880],"length":1,"stats":{"Line":0}},{"line":63,"address":[15446691,15447123],"length":1,"stats":{"Line":0}},{"line":64,"address":[15446722],"length":1,"stats":{"Line":0}},{"line":65,"address":[14000556],"length":1,"stats":{"Line":0}},{"line":66,"address":[14557718],"length":1,"stats":{"Line":0}},{"line":67,"address":[14557744],"length":1,"stats":{"Line":0}},{"line":68,"address":[14000634],"length":1,"stats":{"Line":0}},{"line":69,"address":[17901876],"length":1,"stats":{"Line":0}},{"line":70,"address":[15446878],"length":1,"stats":{"Line":0}},{"line":71,"address":[14771944],"length":1,"stats":{"Line":0}},{"line":72,"address":[14531138],"length":1,"stats":{"Line":0}},{"line":73,"address":[17901980],"length":1,"stats":{"Line":0}},{"line":74,"address":[17902006],"length":1,"stats":{"Line":0}},{"line":75,"address":[14557949],"length":1,"stats":{"Line":0}},{"line":76,"address":[17902052],"length":1,"stats":{"Line":0}},{"line":77,"address":[17902075],"length":1,"stats":{"Line":0}},{"line":78,"address":[17902098],"length":1,"stats":{"Line":0}},{"line":79,"address":[15447097],"length":1,"stats":{"Line":0}},{"line":86,"address":[14531360,14531487],"length":1,"stats":{"Line":0}},{"line":87,"address":[15447225,15447176],"length":1,"stats":{"Line":0}},{"line":92,"address":[14001255,14001120],"length":1,"stats":{"Line":0}},{"line":93,"address":[14772432,14772375],"length":1,"stats":{"Line":0}},{"line":98,"address":[17902496,17902631],"length":1,"stats":{"Line":0}},{"line":99,"address":[15447532,15447489],"length":1,"stats":{"Line":0}},{"line":104,"address":[14558576],"length":1,"stats":{"Line":0}},{"line":105,"address":[14772675],"length":1,"stats":{"Line":0}},{"line":110,"address":[17902704],"length":1,"stats":{"Line":0}},{"line":111,"address":[14001511],"length":1,"stats":{"Line":0}},{"line":116,"address":[15447760],"length":1,"stats":{"Line":0}},{"line":117,"address":[14001597],"length":1,"stats":{"Line":0}},{"line":122,"address":[14001807,14001680],"length":1,"stats":{"Line":0}},{"line":123,"address":[14001699,14001757],"length":1,"stats":{"Line":0}},{"line":128,"address":[14001840],"length":1,"stats":{"Line":0}},{"line":129,"address":[15448038],"length":1,"stats":{"Line":0}},{"line":134,"address":[15448112],"length":1,"stats":{"Line":0}},{"line":135,"address":[14773181],"length":1,"stats":{"Line":0}},{"line":140,"address":[14559152,14559279],"length":1,"stats":{"Line":0}},{"line":141,"address":[15448216,15448265],"length":1,"stats":{"Line":0}},{"line":146,"address":[14773540,14773408],"length":1,"stats":{"Line":0}},{"line":147,"address":[14773427,14773485],"length":1,"stats":{"Line":0}},{"line":152,"address":[17903684,17903552],"length":1,"stats":{"Line":0}},{"line":153,"address":[15448573,15448515],"length":1,"stats":{"Line":0}},{"line":158,"address":[15448779,15448656],"length":1,"stats":{"Line":0}},{"line":159,"address":[14773747,14773805],"length":1,"stats":{"Line":0}},{"line":164,"address":[14533056,14533286],"length":1,"stats":{"Line":0}},{"line":165,"address":[15448830,15448878],"length":1,"stats":{"Line":0}},{"line":170,"address":[15449056],"length":1,"stats":{"Line":0}},{"line":171,"address":[15449074],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":66},{"path":["/","app","kukuri-tauri","src-tauri","src","shared","mod.rs"],"content":"#![allow(unused_imports)]\n#![allow(dead_code)]\n\r\npub mod config;\r\npub mod error;\r\n\r\npub use config::AppConfig;\r\npub use error::{AppError, Result};\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","src","state","application_container.rs"],"content":"use crate::application::services::p2p_service::{P2PService, P2PStack};\nuse crate::domain::p2p::P2PEvent;\nuse crate::shared::config::AppConfig;\nuse anyhow::Context;\nuse base64::prelude::*;\nuse rand_core::{OsRng, TryRngCore};\nuse std::convert::TryInto;\nuse std::io::ErrorKind;\nuse std::path::{Path, PathBuf};\nuse tauri::Manager;\nuse tokio::fs;\nuse tokio::sync::mpsc::UnboundedSender;\n\n/// アプリケーション全体の初期化を担うDIコンテナ\npub struct ApplicationContainer {\n    app_data_dir: PathBuf,\n    config: AppConfig,\n}\n\nimpl ApplicationContainer {\n    /// AppHandleからコンテナを初期化し、必要なディレクトリや設定を確保する\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\n        let app_data_dir = app_handle\n            .path()\n            .app_data_dir()\n            .map_err(|e| anyhow::anyhow!(\"Failed to get app data dir: {}\", e))?;\n\n        tracing::info!(\"App data directory: {:?}\", app_data_dir);\n\n        if !app_data_dir.exists() {\n            tracing::info!(\"Creating app data directory...\");\n            fs::create_dir_all(&app_data_dir)\n                .await\n                .with_context(|| format!(\"Failed to create app data dir at {app_data_dir:?}\"))?;\n            tracing::info!(\"App data directory created successfully\");\n        } else {\n            tracing::info!(\"App data directory already exists\");\n        }\n\n        let config = AppConfig::from_env();\n        if let Err(err) = config.validate() {\n            return Err(anyhow::anyhow!(\n                \"Invalid application configuration: {}\",\n                err\n            ));\n        }\n\n        Ok(Self {\n            app_data_dir,\n            config,\n        })\n    }\n\n    /// app_data_dirを返す\n    pub fn app_data_dir(&self) -> &Path {\n        &self.app_data_dir\n    }\n\n    /// アプリケーション設定を返す\n    pub fn config(&self) -> &AppConfig {\n        &self.config\n    }\n\n    fn node_key_path(&self) -> PathBuf {\n        self.app_data_dir.join(\"p2p_node_secret.key\")\n    }\n\n    /// P2Pスタックを構築し、ネットワークサービス・Gossipサービスを返す\n    pub async fn build_p2p_stack(\n        &self,\n        event_sender: UnboundedSender<P2PEvent>,\n    ) -> anyhow::Result<P2PStack> {\n        let secret_key = self.ensure_iroh_secret_key().await?;\n        let builder = P2PService::builder(secret_key, self.config.network.clone())\n            .with_event_sender(event_sender);\n\n        builder\n            .build()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to build P2P stack: {}\", e))\n    }\n\n    async fn ensure_iroh_secret_key(&self) -> anyhow::Result<iroh::SecretKey> {\n        let path = self.node_key_path();\n        match fs::read_to_string(&path).await {\n            Ok(contents) => {\n                let trimmed = contents.trim();\n                if trimmed.is_empty() {\n                    tracing::warn!(\n                        \"Persisted iroh secret key at {:?} was empty; regenerating\",\n                        path\n                    );\n                    return self.generate_and_store_secret(&path).await;\n                }\n\n                let bytes = BASE64_STANDARD.decode(trimmed).map_err(|e| {\n                    anyhow::anyhow!(\"Failed to decode persisted iroh secret key: {}\", e)\n                })?;\n                let secret_bytes: [u8; 32] = bytes\n                    .try_into()\n                    .map_err(|_| anyhow::anyhow!(\"Invalid iroh secret key length\"))?;\n                tracing::info!(\"Loaded persisted iroh secret key from {:?}\", path);\n                Ok(iroh::SecretKey::from_bytes(&secret_bytes))\n            }\n            Err(err) if err.kind() == ErrorKind::NotFound => {\n                self.generate_and_store_secret(&path).await\n            }\n            Err(err) => {\n                tracing::warn!(\n                    \"Failed to read persisted iroh secret key at {:?}: {}. Regenerating.\",\n                    path,\n                    err\n                );\n                self.generate_and_store_secret(&path).await\n            }\n        }\n    }\n\n    async fn generate_and_store_secret(&self, path: &Path) -> anyhow::Result<iroh::SecretKey> {\n        let mut secret_bytes = [0u8; 32];\n        OsRng\n            .try_fill_bytes(&mut secret_bytes)\n            .map_err(|e| anyhow::anyhow!(\"Failed to generate iroh secret key: {:?}\", e))?;\n        let encoded = BASE64_STANDARD.encode(secret_bytes);\n\n        if let Some(parent) = path.parent() {\n            fs::create_dir_all(parent).await?;\n        }\n\n        fs::write(path, encoded)\n            .await\n            .with_context(|| format!(\"Failed to write iroh secret key to {path:?}\"))?;\n\n        tracing::info!(\"Generated new iroh secret key at {:?}\", path);\n        Ok(iroh::SecretKey::from_bytes(&secret_bytes))\n    }\n\n    #[cfg(test)]\n    pub fn from_parts(app_data_dir: PathBuf, config: AppConfig) -> Self {\n        Self {\n            app_data_dir,\n            config,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    fn test_container(temp_dir: &TempDir) -> ApplicationContainer {\n        ApplicationContainer::from_parts(temp_dir.path().to_path_buf(), AppConfig::default())\n    }\n\n    #[tokio::test]\n    async fn generates_secret_if_missing() {\n        let dir = TempDir::new().unwrap();\n        let container = test_container(&dir);\n        let secret = container.ensure_iroh_secret_key().await.unwrap();\n\n        let stored = tokio::fs::read_to_string(container.node_key_path())\n            .await\n            .unwrap();\n        let stored_bytes = BASE64_STANDARD.decode(stored.trim()).unwrap();\n        let stored_secret =\n            iroh::SecretKey::from_bytes(&stored_bytes.try_into().expect(\"invalid length\"));\n\n        assert_eq!(secret.to_bytes(), stored_secret.to_bytes());\n    }\n\n    #[tokio::test]\n    async fn reuses_existing_secret() {\n        let dir = TempDir::new().unwrap();\n        let container = test_container(&dir);\n        let first = container.ensure_iroh_secret_key().await.unwrap();\n        let second = container.ensure_iroh_secret_key().await.unwrap();\n\n        assert_eq!(first.to_bytes(), second.to_bytes());\n    }\n}\n","traces":[{"line":22,"address":[19328168,19319032,19319024,19319245,19325530,19319102,19319202,19319040],"length":1,"stats":{"Line":0}},{"line":23,"address":[19533279,19533612,19533396,19539570],"length":1,"stats":{"Line":0}},{"line":26,"address":[19301632,19301647,19292764],"length":1,"stats":{"Line":0}},{"line":28,"address":[19533568,19637641,19637775,19534389,19533696,19534213],"length":1,"stats":{"Line":0}},{"line":30,"address":[19320072,19321585],"length":1,"stats":{"Line":0}},{"line":31,"address":[19535708,19536287,19536463,19638169,19638303,19535774],"length":1,"stats":{"Line":0}},{"line":32,"address":[19299211,19296824,19299076,19295414,19298960,19301620],"length":1,"stats":{"Line":0}},{"line":33,"address":[18946454],"length":1,"stats":{"Line":0}},{"line":34,"address":[19539896,19540027,19542688,19542710],"length":1,"stats":{"Line":0}},{"line":35,"address":[18768767,18768847,18769508,18867465,18867599],"length":1,"stats":{"Line":0}},{"line":37,"address":[19297572,19398527,19398393,19296895,19297396,19294904],"length":1,"stats":{"Line":0}},{"line":40,"address":[19538199],"length":1,"stats":{"Line":0}},{"line":41,"address":[18770584,18770655],"length":1,"stats":{"Line":0}},{"line":42,"address":[19542047,19541954],"length":1,"stats":{"Line":0}},{"line":48,"address":[19328247],"length":1,"stats":{"Line":0}},{"line":49,"address":[14086401],"length":1,"stats":{"Line":0}},{"line":50,"address":[19301485],"length":1,"stats":{"Line":0}},{"line":55,"address":[18771584],"length":1,"stats":{"Line":0}},{"line":56,"address":[14086949],"length":1,"stats":{"Line":0}},{"line":60,"address":[14086960],"length":1,"stats":{"Line":0}},{"line":61,"address":[14086968],"length":1,"stats":{"Line":0}},{"line":64,"address":[14132160],"length":1,"stats":{"Line":1}},{"line":65,"address":[19328784],"length":1,"stats":{"Line":1}},{"line":69,"address":[14132240],"length":1,"stats":{"Line":0}},{"line":73,"address":[19010045],"length":1,"stats":{"Line":0}},{"line":74,"address":[18772711,18772888,18772502,18772601],"length":1,"stats":{"Line":0}},{"line":75,"address":[19543925],"length":1,"stats":{"Line":0}},{"line":77,"address":[18773192,18772834,18772780,18773278],"length":1,"stats":{"Line":0}},{"line":79,"address":[18772002,18773090,18772861,18773224,18772807],"length":1,"stats":{"Line":0}},{"line":80,"address":[14133840,14133863],"length":1,"stats":{"Line":0}},{"line":83,"address":[19548794,19545381,19544926,19545052,19544832,19544864,19545158,19544840],"length":1,"stats":{"Line":4}},{"line":84,"address":[19304191],"length":1,"stats":{"Line":1}},{"line":85,"address":[19545082,19545293,19545205,19545413],"length":1,"stats":{"Line":4}},{"line":86,"address":[14089840],"length":1,"stats":{"Line":1}},{"line":87,"address":[14135076,14134940],"length":1,"stats":{"Line":2}},{"line":88,"address":[14090077],"length":1,"stats":{"Line":1}},{"line":89,"address":[19308710,19308534,19308006,19398921,19305186,19399055],"length":1,"stats":{"Line":0}},{"line":93,"address":[10996613],"length":1,"stats":{"Line":0}},{"line":96,"address":[18777571,18774760,18775100,18774852,18783248],"length":1,"stats":{"Line":2}},{"line":97,"address":[19340394],"length":1,"stats":{"Line":0}},{"line":99,"address":[19305570,19307928,19305750,19305417],"length":1,"stats":{"Line":2}},{"line":101,"address":[14143625,14135746,14143616],"length":1,"stats":{"Line":0}},{"line":102,"address":[19332522,19333031,19332442,19333207,19426185,19426319],"length":1,"stats":{"Line":3}},{"line":103,"address":[14137726,14136266],"length":1,"stats":{"Line":2}},{"line":105,"address":[14134975,14140065,14140170],"length":1,"stats":{"Line":6}},{"line":106,"address":[10969900],"length":1,"stats":{"Line":6}},{"line":108,"address":[14095136],"length":1,"stats":{"Line":0}},{"line":109,"address":[19310364,19400111,19310892,19399977,19310204,19311068],"length":1,"stats":{"Line":0}},{"line":114,"address":[19313329,19310836,19312438,19304313],"length":1,"stats":{"Line":0}},{"line":119,"address":[19554784,19554754,19555002,19556290,19555066,19554831,19554736,19555802],"length":1,"stats":{"Line":6}},{"line":120,"address":[19554949],"length":1,"stats":{"Line":1}},{"line":121,"address":[18784064,18783756,18783888,18784514],"length":1,"stats":{"Line":2}},{"line":122,"address":[14099095],"length":1,"stats":{"Line":1}},{"line":123,"address":[14102859,14099408,14102848],"length":1,"stats":{"Line":0}},{"line":124,"address":[14144231,14144376],"length":1,"stats":{"Line":2}},{"line":126,"address":[19314544,19314645,19315298],"length":1,"stats":{"Line":4}},{"line":127,"address":[14346193],"length":1,"stats":{"Line":4}},{"line":130,"address":[18784972,18785311,18787412,18785446,18784341,18785201],"length":1,"stats":{"Line":8}},{"line":131,"address":[18785067,18784945,18783821,18785002,18785225],"length":1,"stats":{"Line":8}},{"line":132,"address":[19556662,19558864,19556531,19558886],"length":1,"stats":{"Line":2}},{"line":134,"address":[14145590,14145666,14330383,14146175,14330249],"length":1,"stats":{"Line":6}},{"line":135,"address":[14146138,14147500],"length":1,"stats":{"Line":4}},{"line":139,"address":[14147888],"length":1,"stats":{"Line":1}}],"covered":27,"coverable":63},{"path":["/","app","kukuri-tauri","src-tauri","src","state.rs"],"content":"#![allow(dead_code)]\n\nmod application_container;\n\nuse crate::application::ports::key_manager::KeyManager;\nuse crate::domain::p2p::P2PEvent;\nuse crate::infrastructure::p2p::ConnectionEvent;\nuse application_container::ApplicationContainer;\n\n// アプリケーションサービスのインポート\nuse crate::application::ports::offline_store::OfflinePersistence;\nuse crate::application::ports::secure_storage::SecureAccountStore;\nuse crate::application::ports::subscription_state_repository::SubscriptionStateRepository;\nuse crate::application::services::{\n    AuthService, EventService, OfflineService, P2PService, PostService, SubscriptionStateMachine,\n    SyncService, TopicService, UserService,\n};\n// プレゼンテーション層のハンドラーのインポート\nuse crate::infrastructure::{\n    crypto::{\n        DefaultEncryptionService, DefaultKeyManager, DefaultSignatureService, EncryptionService,\n        SignatureService,\n    },\n    database::{\n        BookmarkRepository, EventRepository, PostRepository, Repository,\n        SqliteSubscriptionStateRepository, TopicRepository, UserRepository,\n        connection_pool::ConnectionPool, sqlite_repository::SqliteRepository,\n    },\n    event::{\n        EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\n        LegacyEventManagerHandle,\n    },\n    offline::{OfflineReindexJob, SqliteOfflinePersistence},\n    p2p::{\n        GossipService, NetworkService,\n        event_distributor::{DefaultEventDistributor, EventDistributor},\n    },\n    storage::{SecureStorage, secure_storage::DefaultSecureStorage},\n};\nuse crate::presentation::handlers::{\n    event_handler::EventHandler, offline_handler::OfflineHandler, p2p_handler::P2PHandler,\n    secure_storage_handler::SecureStorageHandler, user_handler::UserHandler,\n};\n\nuse std::collections::{HashSet as StdHashSet, VecDeque as StdVecDeque};\nuse std::sync::Arc;\nuse tauri::Emitter;\nuse tokio::sync::RwLock;\nuse tokio::sync::mpsc;\n\nconst P2P_DEDUP_MAX: usize = 8192;\n\n/// P2P関連の状態\npub struct P2PState {\n    /// Message event channel\n    pub event_rx: Arc<RwLock<Option<mpsc::UnboundedReceiver<P2PEvent>>>>,\n    /// GossipService 本体（UI購読導線で使用）\n    pub gossip_service: Arc<dyn GossipService>,\n    /// UI購読済みトピック集合（重複購読防止）\n    pub ui_subscribed_topics: Arc<RwLock<std::collections::HashSet<String>>>,\n    /// 受信イベントIDの重複排除用セット\n    pub seen_event_ids: Arc<RwLock<StdHashSet<String>>>,\n    /// 受信イベントIDの順序（容量制御用）\n    pub seen_event_order: Arc<RwLock<StdVecDeque<String>>>,\n}\n\n/// アプリケーション全体の状態を管理する構造体\n#[derive(Clone)]\npub struct AppState {\n    pub app_handle: tauri::AppHandle,\n    // 既存のマネージャー（Phase5でArc<dyn KeyManager>へ移行済み）\n    pub key_manager: Arc<dyn KeyManager>,\n    #[allow(dead_code)]\n    pub encryption_service: Arc<dyn EncryptionService>,\n    pub event_manager: Arc<dyn EventManagerHandle>,\n    pub p2p_state: Arc<RwLock<P2PState>>,\n    pub offline_reindex_job: Arc<OfflineReindexJob>,\n\n    // 新アーキテクチャのサービス層\n    pub auth_service: Arc<AuthService>,\n    pub post_service: Arc<PostService>,\n    pub topic_service: Arc<TopicService>,\n    pub user_service: Arc<UserService>,\n    pub event_service: Arc<EventService>,\n    pub sync_service: Arc<SyncService>,\n    pub p2p_service: Arc<P2PService>,\n    pub offline_service: Arc<OfflineService>,\n\n    // プレゼンテーション層のハンドラー（最適化用）\n    pub user_handler: Arc<UserHandler>,\n    pub secure_storage_handler: Arc<SecureStorageHandler>,\n    pub event_handler: Arc<EventHandler>,\n    pub p2p_handler: Arc<P2PHandler>,\n    pub offline_handler: Arc<OfflineHandler>,\n}\n\nimpl AppState {\n    pub async fn new(app_handle: &tauri::AppHandle) -> anyhow::Result<Self> {\n        let container = ApplicationContainer::new(app_handle).await?;\n        let app_data_dir = container.app_data_dir().to_path_buf();\n\n        // Use absolute path for database\n        let db_path = app_data_dir.join(\"kukuri.db\");\n\n        // Debug logging\n        tracing::info!(\"Database path: {:?}\", db_path);\n\n        // Ensure the database file path is canonical\n        let db_path_str = db_path\n            .to_str()\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid database path encoding\"))?;\n\n        // Format database URL for sqlx\n        // On Windows, sqlx may need a specific format\n        let db_url = if cfg!(windows) {\n            // Try Windows-specific format\n            tracing::info!(\"Using Windows database URL format\");\n            format!(\"sqlite:{}?mode=rwc\", db_path_str.replace('\\\\', \"/\"))\n        } else {\n            format!(\"sqlite://{db_path_str}?mode=rwc\")\n        };\n\n        tracing::info!(\"Database URL: {db_url}\");\n\n        // 新アーキテクチャのリポジトリとサービスを初期化\n        let connection_pool = ConnectionPool::new(&db_url).await?;\n        let repository = Arc::new(SqliteRepository::new(connection_pool.clone()));\n        let subscription_repository: Arc<dyn SubscriptionStateRepository> = Arc::new(\n            SqliteSubscriptionStateRepository::new(connection_pool.clone()),\n        );\n\n        // リポジトリのマイグレーションを実行\n        repository.initialize().await?;\n\n        let sqlite_pool = connection_pool.get_pool().clone();\n\n        let encryption_service: Arc<dyn EncryptionService> =\n            Arc::new(DefaultEncryptionService::new());\n        let event_manager: Arc<dyn EventManagerHandle> = Arc::new(\n            LegacyEventManagerHandle::new_with_connection_pool(connection_pool.clone()),\n        );\n        let offline_persistence_concrete =\n            Arc::new(SqliteOfflinePersistence::new(sqlite_pool.clone()));\n        let offline_reindex_job = OfflineReindexJob::create(\n            Some(app_handle.clone()),\n            Arc::clone(&offline_persistence_concrete),\n        );\n        offline_reindex_job.trigger();\n\n        // インフラストラクチャサービスの初期化\n        let key_manager: Arc<dyn KeyManager> = Arc::new(DefaultKeyManager::new());\n        let secure_storage_impl = Arc::new(DefaultSecureStorage::new());\n        let secure_storage: Arc<dyn SecureStorage> = secure_storage_impl.clone();\n        let secure_account_store: Arc<dyn SecureAccountStore> = secure_storage_impl.clone();\n        let signature_service: Arc<dyn SignatureService> = Arc::new(DefaultSignatureService::new());\n        let event_distributor: Arc<dyn EventDistributor> = Arc::new(DefaultEventDistributor::new());\n\n        // P2Pサービスの初期化\n        let (p2p_event_tx, p2p_event_rx) = mpsc::unbounded_channel();\n        let p2p_stack = container.build_p2p_stack(p2p_event_tx).await?;\n\n        let network_service: Arc<dyn NetworkService> = p2p_stack.network_service.clone();\n        let gossip_service_concrete = p2p_stack.gossip_service.clone();\n        let gossip_service: Arc<dyn GossipService> = gossip_service_concrete.clone();\n        let p2p_service = Arc::clone(&p2p_stack.p2p_service);\n        // EventManagerへGossipServiceを接続（P2P配信経路の直結）\n        event_manager\n            .set_gossip_service(Arc::clone(&gossip_service))\n            .await;\n        // EventManagerへEventRepositoryを接続（参照トピック解決用）\n        event_manager\n            .set_event_repository(Arc::clone(&repository) as Arc<dyn EventRepository>)\n            .await;\n\n        // UserServiceを先に初期化（他のサービスの依存）\n        let user_service = Arc::new(UserService::new(\n            Arc::clone(&repository) as Arc<dyn UserRepository>\n        ));\n\n        // TopicServiceを初期化（AuthServiceの依存）\n        let topic_service = Arc::new(TopicService::new(\n            Arc::clone(&repository) as Arc<dyn TopicRepository>,\n            Arc::clone(&gossip_service),\n        ));\n        // 既定トピック（public）を保証し、EventManagerの既定配信先に設定\n        topic_service\n            .ensure_public_topic()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to ensure public topic: {}\", e))?;\n        event_manager.set_default_p2p_topic_id(\"public\").await;\n\n        // AuthServiceの初期化（UserServiceとTopicServiceが必要）\n        let auth_service = Arc::new(AuthService::new(\n            Arc::clone(&key_manager),\n            Arc::clone(&secure_storage),\n            Arc::clone(&user_service),\n            Arc::clone(&topic_service),\n        ));\n\n        // PostServiceの初期化\n        let post_service = Arc::new(PostService::new(\n            Arc::clone(&repository) as Arc<dyn PostRepository>,\n            Arc::clone(&repository) as Arc<dyn BookmarkRepository>,\n            Arc::clone(&event_distributor),\n        ));\n\n        let subscription_state = Arc::new(SubscriptionStateMachine::new(Arc::clone(\n            &subscription_repository,\n        )));\n\n        // EventServiceの初期化\n        let legacy_event_gateway =\n            Arc::new(LegacyEventManagerGateway::new(Arc::clone(&event_manager)));\n        let event_gateway: Arc<dyn crate::application::ports::event_gateway::EventGateway> =\n            legacy_event_gateway.clone();\n        let mut event_service_inner = EventService::new(\n            Arc::clone(&repository) as Arc<dyn EventRepository>,\n            Arc::clone(&signature_service),\n            Arc::clone(&event_distributor),\n            event_gateway,\n            Arc::clone(&subscription_state)\n                as Arc<dyn crate::application::services::SubscriptionStateStore>,\n        );\n        event_service_inner.set_subscription_invoker(Arc::new(\n            EventManagerSubscriptionInvoker::new(Arc::clone(&event_manager)),\n        ));\n        legacy_event_gateway\n            .set_app_handle(app_handle.clone())\n            .await;\n        let event_service = Arc::new(event_service_inner);\n\n        // SyncServiceの初期化（PostServiceとEventServiceが必要）\n        let sync_service = Arc::new(SyncService::new(\n            Arc::clone(&network_service),\n            Arc::clone(&post_service),\n            Arc::clone(&event_service),\n        ));\n\n        // OfflineServiceの初期化\n        let offline_persistence: Arc<dyn OfflinePersistence> = offline_persistence_concrete.clone();\n        let offline_service = Arc::new(OfflineService::new(offline_persistence));\n\n        // プレゼンテーション層のハンドラーを初期化\n        let user_handler = Arc::new(UserHandler::new(Arc::clone(&user_service)));\n        let secure_storage_handler = Arc::new(SecureStorageHandler::new(\n            Arc::clone(&auth_service),\n            Arc::clone(&secure_account_store),\n        ));\n        let event_handler = Arc::new(EventHandler::new(Arc::clone(&event_service)\n            as Arc<dyn crate::application::services::event_service::EventServiceTrait>));\n        let p2p_handler = Arc::new(P2PHandler::new(Arc::clone(&p2p_service)\n            as Arc<dyn crate::application::services::p2p_service::P2PServiceTrait>));\n        let offline_handler = Arc::new(OfflineHandler::new(Arc::clone(&offline_service)\n            as Arc<dyn crate::application::services::offline_service::OfflineServiceTrait>));\n\n        // P2P接続イベントを監視し、再接続時に再索引ジョブをトリガー\n        {\n            let mut connection_rx = p2p_stack.network_service.subscribe_connection_events();\n            let job = Arc::clone(&offline_reindex_job);\n            tauri::async_runtime::spawn(async move {\n                while let Ok(event) = connection_rx.recv().await {\n                    if matches!(event, ConnectionEvent::Connected) {\n                        job.trigger();\n                    }\n                }\n            });\n        }\n\n        {\n            let mut connection_rx = p2p_stack.network_service.subscribe_connection_events();\n            let event_service_clone = Arc::clone(&event_service);\n            tauri::async_runtime::spawn(async move {\n                while let Ok(event) = connection_rx.recv().await {\n                    match event {\n                        ConnectionEvent::Disconnected => {\n                            if let Err(e) = event_service_clone.handle_network_disconnected().await\n                            {\n                                tracing::warn!(\"Failed to mark subscriptions for resync: {}\", e);\n                            }\n                        }\n                        ConnectionEvent::Connected => {\n                            if let Err(e) = event_service_clone.handle_network_connected().await {\n                                tracing::warn!(\n                                    \"Failed to restore subscriptions after reconnect: {}\",\n                                    e\n                                );\n                            }\n                        }\n                    }\n                }\n            });\n        }\n\n        // P2P状態の初期化\n        let p2p_state = Arc::new(RwLock::new(P2PState {\n            event_rx: Arc::new(RwLock::new(Some(p2p_event_rx))),\n            gossip_service: Arc::clone(&gossip_service),\n            ui_subscribed_topics: Arc::new(RwLock::new(Default::default())),\n            seen_event_ids: Arc::new(RwLock::new(Default::default())),\n            seen_event_order: Arc::new(RwLock::new(Default::default())),\n        }));\n\n        // 既定トピック`public`に対するUI購読を張る（冪等）\n        // TopicService.ensure_public_topic でjoinは保証済\n        let this_handle = app_handle.clone();\n        let this = Self {\n            app_handle: this_handle,\n            key_manager,\n            encryption_service,\n            event_manager,\n            p2p_state,\n            offline_reindex_job,\n            auth_service,\n            post_service,\n            topic_service,\n            user_service,\n            event_service,\n            sync_service,\n            p2p_service,\n            offline_service,\n            user_handler,\n            secure_storage_handler,\n            event_handler,\n            p2p_handler,\n            offline_handler,\n        };\n\n        // 起動時に既定＋ユーザー固有トピックの購読を確立\n        {\n            let this_clone = this.clone();\n            tauri::async_runtime::spawn(async move {\n                if let Err(e) = this_clone.ensure_default_and_user_subscriptions().await {\n                    tracing::warn!(\"Failed to ensure default/user subscriptions: {}\", e);\n                }\n            });\n        }\n\n        Ok(this)\n    }\n\n    /// P2P機能を初期化\n    pub async fn initialize_p2p(&self) -> anyhow::Result<()> {\n        // 旧GossipManager経路は無効化。IrohGossipService経由で運用。\n        // 互換のため成功扱いで何もしない。\n        Ok(())\n    }\n\n    // Event loop for P2P messages is now handled via UI emitter in lib.rs using event_rx\n\n    /// UI向けに指定トピックの購読を確立（冪等）\n    pub async fn ensure_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\n        // 重複購読チェック\n        {\n            let p2p_state = self.p2p_state.read().await;\n            let subs = p2p_state.ui_subscribed_topics.read().await;\n            if subs.contains(topic_id) {\n                return Ok(());\n            }\n        }\n\n        // 購読開始（joinはTopicService側で行われるが、冪等joinは吸収される）\n        let (gossip, event_manager, p2p_state_arc, app_handle, topic) = {\n            let p2p_state = self.p2p_state.read().await;\n            (\n                Arc::clone(&p2p_state.gossip_service),\n                Arc::clone(&self.event_manager),\n                Arc::clone(&self.p2p_state),\n                self.app_handle.clone(),\n                topic_id.to_string(),\n            )\n        };\n\n        // 先にフラグを立てる（競合回避）\n        {\n            let ui_arc = {\n                let p2p = p2p_state_arc.read().await;\n                Arc::clone(&p2p.ui_subscribed_topics)\n            };\n            let mut subs = ui_arc.write().await;\n            subs.insert(topic.clone());\n        }\n\n        tauri::async_runtime::spawn(async move {\n            match gossip.subscribe(&topic).await {\n                Ok(mut rx) => {\n                    tracing::info!(\"UI subscribed to topic {}\", topic);\n                    while let Some(evt) = rx.recv().await {\n                        // 重複排除（イベントID）\n                        let evt_id = evt.id.clone();\n                        let (set_arc, order_arc) = {\n                            let p2p = p2p_state_arc.read().await;\n                            (\n                                Arc::clone(&p2p.seen_event_ids),\n                                Arc::clone(&p2p.seen_event_order),\n                            )\n                        };\n                        {\n                            let mut set = set_arc.write().await;\n                            if set.contains(&evt_id) {\n                                continue;\n                            }\n                            set.insert(evt_id.clone());\n                        }\n                        {\n                            let mut order = order_arc.write().await;\n                            order.push_back(evt_id.clone());\n                            if order.len() > P2P_DEDUP_MAX {\n                                if let Some(old_id) = order.pop_front() {\n                                    let mut set = set_arc.write().await;\n                                    set.remove(&old_id);\n                                }\n                            }\n                        }\n                        // 受信: domain::entities::Event\n                        // UIへemit（p2p://message）\n                        #[derive(serde::Serialize, Clone)]\n                        struct UiMsg {\n                            id: String,\n                            author: String,\n                            content: String,\n                            timestamp: i64,\n                            signature: String,\n                        }\n                        #[derive(serde::Serialize, Clone)]\n                        struct UiP2PMessageEvent {\n                            topic_id: String,\n                            message: UiMsg,\n                        }\n\n                        let payload = UiP2PMessageEvent {\n                            topic_id: topic.clone(),\n                            message: UiMsg {\n                                id: evt.id.clone(),\n                                author: evt.pubkey.clone(),\n                                content: evt.content.clone(),\n                                timestamp: evt.created_at.timestamp_millis(),\n                                signature: evt.sig.clone(),\n                            },\n                        };\n                        if let Err(e) = app_handle.emit(\"p2p://message\", payload) {\n                            tracing::error!(\"Failed to emit UI P2P message: {}\", e);\n                        }\n\n                        // 既存Nostr系導線へも流す（必要に応じて）\n                        // domain::Event -> NostrEventPayload 相当はEventManager内にあるが、\n                        // ここではDB保存・加工は後段で検討するためスキップ\n                        let _ = event_manager; // 未来の拡張用プレースホルダ\n                    }\n                    // チャネルクローズ時、購読フラグを解除\n                    let ui_arc = {\n                        let p2p = p2p_state_arc.read().await;\n                        Arc::clone(&p2p.ui_subscribed_topics)\n                    };\n                    let mut subs = ui_arc.write().await;\n                    subs.remove(&topic);\n                    tracing::info!(\"UI subscription ended for topic {}\", topic);\n                }\n                Err(e) => {\n                    tracing::error!(\"Failed to subscribe to topic {}: {}\", topic, e);\n                    let ui_arc = {\n                        let p2p = p2p_state_arc.read().await;\n                        Arc::clone(&p2p.ui_subscribed_topics)\n                    };\n                    let mut subs = ui_arc.write().await;\n                    subs.remove(&topic);\n                }\n            }\n        });\n\n        Ok(())\n    }\n\n    /// 既定トピックとユーザー固有トピックの購読を確立（冪等）\n    pub async fn ensure_default_and_user_subscriptions(&self) -> anyhow::Result<()> {\n        let mut topics = self.event_manager.list_default_p2p_topics().await;\n        if let Some(pk) = self.event_manager.get_public_key().await {\n            let user_topic = crate::domain::p2p::user_topic_id(&pk.to_string());\n            topics.push(user_topic);\n        }\n        for t in topics {\n            if let Err(e) = self.ensure_ui_subscription(&t).await {\n                tracing::warn!(\"Failed to ensure subscription for {}: {}\", t, e);\n            }\n        }\n        Ok(())\n    }\n\n    /// UI向け購読を停止（存在しなければ何もしない）\n    pub async fn stop_ui_subscription(&self, topic_id: &str) -> anyhow::Result<()> {\n        // フラグのみ除去（購読タスクはチャネルクローズにより自然終了）\n        let ui_subs_arc = {\n            let p2p_state = self.p2p_state.read().await;\n            Arc::clone(&p2p_state.ui_subscribed_topics)\n        };\n        let mut subs = ui_subs_arc.write().await;\n        subs.remove(topic_id);\n        Ok(())\n    }\n}\n","traces":[{"line":97,"address":[81453133],"length":1,"stats":{"Line":0}},{"line":98,"address":[16782754,16782560,16789001,16783452,16782568,16782592,16783596,16783241],"length":1,"stats":{"Line":0}},{"line":99,"address":[13439422,13439548,13439124,13439966,13444852,13439191],"length":1,"stats":{"Line":0}},{"line":100,"address":[12882935,12882795],"length":1,"stats":{"Line":0}},{"line":103,"address":[13440097,13440202],"length":1,"stats":{"Line":0}},{"line":106,"address":[13654943,13654337,13764649,13654423,13764783],"length":1,"stats":{"Line":0}},{"line":109,"address":[16786594,16788901,16784879,16786376],"length":1,"stats":{"Line":0}},{"line":111,"address":[12905264,12905268,12885362],"length":1,"stats":{"Line":0}},{"line":117,"address":[13524313,13524447],"length":1,"stats":{"Line":0}},{"line":118,"address":[42206656,42206569,42205840,42208146,42208192,42207472,42205813,42205041,42207397,42205778,42204288,42205120,42206615,42205087,42207443],"length":1,"stats":{"Line":0}},{"line":120,"address":[13656639,13656560],"length":1,"stats":{"Line":0}},{"line":123,"address":[14152688,14333641,14333775,14152082,14152168],"length":1,"stats":{"Line":0}},{"line":126,"address":[11264974],"length":1,"stats":{"Line":0}},{"line":127,"address":[13445274,13445451],"length":1,"stats":{"Line":0}},{"line":129,"address":[42208005,42204900,42205637,42207256,42206428],"length":1,"stats":{"Line":0}},{"line":133,"address":[11291736],"length":1,"stats":{"Line":0}},{"line":135,"address":[12889119,12889230],"length":1,"stats":{"Line":0}},{"line":137,"address":[13660522,13660599],"length":1,"stats":{"Line":0}},{"line":140,"address":[13660670,13660771],"length":1,"stats":{"Line":0}},{"line":142,"address":[13446773,13446863],"length":1,"stats":{"Line":0}},{"line":145,"address":[13447019,13446950],"length":1,"stats":{"Line":0}},{"line":146,"address":[12889921],"length":1,"stats":{"Line":0}},{"line":148,"address":[12890103],"length":1,"stats":{"Line":0}},{"line":151,"address":[13420643,13420577],"length":1,"stats":{"Line":0}},{"line":152,"address":[13661546,13661605],"length":1,"stats":{"Line":0}},{"line":153,"address":[12890433,12890526],"length":1,"stats":{"Line":0}},{"line":154,"address":[16791864,16791771],"length":1,"stats":{"Line":0}},{"line":155,"address":[16791893,16791952],"length":1,"stats":{"Line":0}},{"line":156,"address":[13662024,13662102],"length":1,"stats":{"Line":0}},{"line":159,"address":[14157286,14157372],"length":1,"stats":{"Line":0}},{"line":160,"address":[11505858],"length":1,"stats":{"Line":0}},{"line":162,"address":[82030190,82029062,82029662,82029134,82028606,82028534,82029590,82030118],"length":1,"stats":{"Line":0}},{"line":163,"address":[13663218,13663100],"length":1,"stats":{"Line":0}},{"line":164,"address":[14158363,14158281],"length":1,"stats":{"Line":0}},{"line":165,"address":[42209089,42209039,42210145,42208561,42209617,42210095,42208511,42209567],"length":1,"stats":{"Line":0}},{"line":167,"address":[14158535,14158806,14158723],"length":1,"stats":{"Line":0}},{"line":168,"address":[16793600],"length":1,"stats":{"Line":0}},{"line":169,"address":[13422898,13412539,13423028,13422963],"length":1,"stats":{"Line":0}},{"line":171,"address":[81458631,81458103,81459112,81459159,81458056,81458584,81457528,81457575],"length":1,"stats":{"Line":0}},{"line":172,"address":[81458613,81459141,81457557,81458085],"length":1,"stats":{"Line":0}},{"line":173,"address":[83257611,83259195,83259582,83258139,83257998,83259530,83258503,83258526,83259002,83259559,83259054,83257975,83258667,83259031,83257946,83258474],"length":1,"stats":{"Line":0}},{"line":176,"address":[14159641],"length":1,"stats":{"Line":0}},{"line":177,"address":[14159561],"length":1,"stats":{"Line":0}},{"line":181,"address":[13424124,13424175,13424303],"length":1,"stats":{"Line":0}},{"line":182,"address":[12893594,12893517],"length":1,"stats":{"Line":0}},{"line":183,"address":[14159862],"length":1,"stats":{"Line":0}},{"line":186,"address":[16795755,16795137,16795227,16795273,16795484,16795598],"length":1,"stats":{"Line":0}},{"line":188,"address":[19320560],"length":1,"stats":{"Line":0}},{"line":189,"address":[13451659,13462464,13462479],"length":1,"stats":{"Line":0}},{"line":190,"address":[10770710],"length":1,"stats":{"Line":0}},{"line":193,"address":[13426583,13426696,13426803],"length":1,"stats":{"Line":0}},{"line":194,"address":[12895739,12895832],"length":1,"stats":{"Line":0}},{"line":195,"address":[12895856,12895966],"length":1,"stats":{"Line":0}},{"line":196,"address":[13453220,13453126],"length":1,"stats":{"Line":0}},{"line":197,"address":[13667332],"length":1,"stats":{"Line":0}},{"line":201,"address":[14162891,14163015,14162806],"length":1,"stats":{"Line":0}},{"line":202,"address":[12896498,12896421],"length":1,"stats":{"Line":0}},{"line":203,"address":[14162680,14162594],"length":1,"stats":{"Line":0}},{"line":204,"address":[14162711],"length":1,"stats":{"Line":0}},{"line":207,"address":[12897003,12897094],"length":1,"stats":{"Line":0}},{"line":208,"address":[13454124],"length":1,"stats":{"Line":0}},{"line":212,"address":[13427706,13427597],"length":1,"stats":{"Line":0}},{"line":214,"address":[13427901,13427793],"length":1,"stats":{"Line":0}},{"line":217,"address":[16798755,16798860],"length":1,"stats":{"Line":0}},{"line":218,"address":[12897769,12897667],"length":1,"stats":{"Line":0}},{"line":219,"address":[16799001,16799103],"length":1,"stats":{"Line":0}},{"line":220,"address":[13669135],"length":1,"stats":{"Line":0}},{"line":221,"address":[12897950],"length":1,"stats":{"Line":0}},{"line":224,"address":[13669568,13669402],"length":1,"stats":{"Line":0}},{"line":225,"address":[12898195,12898293],"length":1,"stats":{"Line":0}},{"line":227,"address":[13669621,13669751,13669697],"length":1,"stats":{"Line":0}},{"line":228,"address":[12898423],"length":1,"stats":{"Line":0}},{"line":229,"address":[11265156],"length":1,"stats":{"Line":0}},{"line":230,"address":[13670351,13670534],"length":1,"stats":{"Line":0}},{"line":233,"address":[13456757,13456916,13456832],"length":1,"stats":{"Line":0}},{"line":234,"address":[13670550,13670643],"length":1,"stats":{"Line":0}},{"line":235,"address":[16800651,16800745],"length":1,"stats":{"Line":0}},{"line":236,"address":[12899545],"length":1,"stats":{"Line":0}},{"line":240,"address":[13430196,13430276],"length":1,"stats":{"Line":0}},{"line":241,"address":[12899899,12899974],"length":1,"stats":{"Line":0}},{"line":244,"address":[13671340,13671249],"length":1,"stats":{"Line":0}},{"line":245,"address":[14166318,14166246,14166199],"length":1,"stats":{"Line":0}},{"line":246,"address":[13430578,13430655],"length":1,"stats":{"Line":0}},{"line":247,"address":[16801487],"length":1,"stats":{"Line":0}},{"line":249,"address":[12900594,12900513],"length":1,"stats":{"Line":0}},{"line":250,"address":[14166488],"length":1,"stats":{"Line":0}},{"line":251,"address":[12900778,12900687],"length":1,"stats":{"Line":0}},{"line":252,"address":[13457999],"length":1,"stats":{"Line":0}},{"line":253,"address":[12900955,12900871],"length":1,"stats":{"Line":0}},{"line":254,"address":[12901040],"length":1,"stats":{"Line":0}},{"line":258,"address":[13431448,13431525],"length":1,"stats":{"Line":0}},{"line":259,"address":[12901192,12901275],"length":1,"stats":{"Line":0}},{"line":260,"address":[13458419,13462713,13462820,13462688,13463305,13463377,13462765],"length":1,"stats":{"Line":0}},{"line":261,"address":[18931262],"length":1,"stats":{"Line":0}},{"line":262,"address":[13463127,13463183],"length":1,"stats":{"Line":0}},{"line":263,"address":[16807243,16807268],"length":1,"stats":{"Line":0}},{"line":270,"address":[13458545,13458622],"length":1,"stats":{"Line":0}},{"line":271,"address":[14167322,14167386],"length":1,"stats":{"Line":0}},{"line":272,"address":[13463408,13458773,13463439,13463606,13466093,13468989,13463503],"length":1,"stats":{"Line":0}},{"line":273,"address":[13436765,13436840,13439366,13436902,13436791],"length":1,"stats":{"Line":0}},{"line":274,"address":[13466391],"length":1,"stats":{"Line":0}},{"line":276,"address":[14246239],"length":1,"stats":{"Line":0}},{"line":278,"address":[14175785,14175195,14334271,14175288,14334137],"length":1,"stats":{"Line":0}},{"line":282,"address":[13464014,13463706,13466433,13466503,13463563],"length":1,"stats":{"Line":0}},{"line":283,"address":[14334767,14334633,14172357,14172450,14172947],"length":1,"stats":{"Line":0}},{"line":295,"address":[108590247,108593838],"length":1,"stats":{"Line":0}},{"line":296,"address":[108882970,108883040,108879379],"length":1,"stats":{"Line":0}},{"line":297,"address":[13459049,13459151],"length":1,"stats":{"Line":0}},{"line":298,"address":[16803307,16803247],"length":1,"stats":{"Line":0}},{"line":299,"address":[16803384,16803447],"length":1,"stats":{"Line":0}},{"line":300,"address":[13432708,13432771],"length":1,"stats":{"Line":0}},{"line":305,"address":[109819487,109823144],"length":1,"stats":{"Line":0}},{"line":330,"address":[16804723],"length":1,"stats":{"Line":0}},{"line":331,"address":[12914526,12912269,12903591,12911968,12912091,12914515,12911999],"length":1,"stats":{"Line":0}},{"line":332,"address":[12912064,12912301,12914524,12912175,12912121],"length":1,"stats":{"Line":0}},{"line":333,"address":[14177857,14177954,14335129,14335263,14178455],"length":1,"stats":{"Line":0}},{"line":338,"address":[13434097],"length":1,"stats":{"Line":0}},{"line":342,"address":[13471760,13471790,13471869,13471776,13471768],"length":1,"stats":{"Line":0}},{"line":345,"address":[13471817],"length":1,"stats":{"Line":0}},{"line":351,"address":[13445772,13445216,13445474,13445168,13445186,13445601,13446327,13445247],"length":1,"stats":{"Line":0}},{"line":354,"address":[14180527,14180652,14180294,14180364],"length":1,"stats":{"Line":0}},{"line":355,"address":[10861448],"length":1,"stats":{"Line":0}},{"line":356,"address":[12916216,12916295],"length":1,"stats":{"Line":0}},{"line":357,"address":[12916367],"length":1,"stats":{"Line":0}},{"line":362,"address":[108880672,108884422],"length":1,"stats":{"Line":0}},{"line":363,"address":[108020264,108024014],"length":1,"stats":{"Line":0}},{"line":365,"address":[109820664,109824414],"length":1,"stats":{"Line":0}},{"line":366,"address":[108020288,108024038],"length":1,"stats":{"Line":0}},{"line":367,"address":[108591624,108595374],"length":1,"stats":{"Line":0}},{"line":368,"address":[12917306],"length":1,"stats":{"Line":0}},{"line":369,"address":[13447781],"length":1,"stats":{"Line":0}},{"line":376,"address":[10888234],"length":1,"stats":{"Line":0}},{"line":377,"address":[16819599,16819526],"length":1,"stats":{"Line":0}},{"line":379,"address":[14232339],"length":1,"stats":{"Line":0}},{"line":380,"address":[13449304,13449372],"length":1,"stats":{"Line":0}},{"line":383,"address":[12919852,12920376,12919075,12925044,12936032,12919742,12919696],"length":1,"stats":{"Line":0}},{"line":384,"address":[13477303,13476943,13477544,13477018],"length":1,"stats":{"Line":0}},{"line":385,"address":[12920689],"length":1,"stats":{"Line":0}},{"line":386,"address":[14186336,14185675,14335759,14185824,14335625],"length":1,"stats":{"Line":0}},{"line":387,"address":[10985475],"length":1,"stats":{"Line":0}},{"line":389,"address":[12929315],"length":1,"stats":{"Line":0}},{"line":390,"address":[14194799],"length":1,"stats":{"Line":0}},{"line":391,"address":[13691156,13696322,13700612],"length":1,"stats":{"Line":0}},{"line":393,"address":[65014546,65018259,65018348,65018425,65014626],"length":1,"stats":{"Line":0}},{"line":394,"address":[108597272],"length":1,"stats":{"Line":0}},{"line":398,"address":[16821161,16831292,16826343],"length":1,"stats":{"Line":0}},{"line":399,"address":[12930447,12930526],"length":1,"stats":{"Line":0}},{"line":402,"address":[12930572,12930621],"length":1,"stats":{"Line":0}},{"line":405,"address":[12925164,12930701,12919966],"length":1,"stats":{"Line":0}},{"line":406,"address":[12931078],"length":1,"stats":{"Line":0}},{"line":407,"address":[13702412],"length":1,"stats":{"Line":0}},{"line":408,"address":[13702493],"length":1,"stats":{"Line":0}},{"line":409,"address":[12919987,12931407,12925201,12931478],"length":1,"stats":{"Line":0}},{"line":410,"address":[13455931,13456007],"length":1,"stats":{"Line":0}},{"line":416,"address":[14338122,14336519,14336064,14336480,14337984,14338194,14338056,14336092],"length":1,"stats":{"Line":0}},{"line":418,"address":[16900014],"length":1,"stats":{"Line":0}},{"line":419,"address":[13555963],"length":1,"stats":{"Line":0}},{"line":420,"address":[16900102],"length":1,"stats":{"Line":0}},{"line":421,"address":[65018574,65019086],"length":1,"stats":{"Line":0}},{"line":422,"address":[13770190],"length":1,"stats":{"Line":0}},{"line":424,"address":[108026156,108026668],"length":1,"stats":{"Line":0}},{"line":425,"address":[109827062,109826550],"length":1,"stats":{"Line":0}},{"line":426,"address":[13530414],"length":1,"stats":{"Line":0}},{"line":427,"address":[13000033],"length":1,"stats":{"Line":0}},{"line":430,"address":[108598056,108597544],"length":1,"stats":{"Line":0}},{"line":431,"address":[108887154,108886642],"length":1,"stats":{"Line":0}},{"line":432,"address":[13483318],"length":1,"stats":{"Line":0}},{"line":433,"address":[108026246,108026758],"length":1,"stats":{"Line":0}},{"line":434,"address":[12925915],"length":1,"stats":{"Line":0}},{"line":435,"address":[12925990],"length":1,"stats":{"Line":0}},{"line":436,"address":[109827217,109827257,109826745,109826705],"length":1,"stats":{"Line":0}},{"line":437,"address":[13697372],"length":1,"stats":{"Line":0}},{"line":440,"address":[108279187,108278675],"length":1,"stats":{"Line":0}},{"line":441,"address":[108886878,108887390],"length":1,"stats":{"Line":0}},{"line":447,"address":[108279313,108278801],"length":1,"stats":{"Line":0}},{"line":450,"address":[109827910,109827534,109827574,109827870],"length":1,"stats":{"Line":0}},{"line":451,"address":[13488805,13477144],"length":1,"stats":{"Line":0}},{"line":452,"address":[108888007,108887967,108887631,108887671],"length":1,"stats":{"Line":0}},{"line":454,"address":[13462655,13462748,13450429],"length":1,"stats":{"Line":0}},{"line":455,"address":[108887722,108888058],"length":1,"stats":{"Line":0}},{"line":456,"address":[12932811,13000729,12933347,13000863],"length":1,"stats":{"Line":0}},{"line":458,"address":[108279569,108279905],"length":1,"stats":{"Line":0}},{"line":459,"address":[13001225,12923387,13001359,12922871,12920775],"length":1,"stats":{"Line":0}},{"line":460,"address":[65019869,65020205],"length":1,"stats":{"Line":0}},{"line":461,"address":[10403813],"length":1,"stats":{"Line":0}},{"line":462,"address":[14199595,14199652],"length":1,"stats":{"Line":0}},{"line":464,"address":[108888606,108888238],"length":1,"stats":{"Line":0}},{"line":465,"address":[13706956,13706885],"length":1,"stats":{"Line":0}},{"line":470,"address":[108888777,108888409],"length":1,"stats":{"Line":0}},{"line":474,"address":[108888539,108888907],"length":1,"stats":{"Line":0}},{"line":475,"address":[13493504,13493582,13493874,13493712],"length":1,"stats":{"Line":0}},{"line":476,"address":[13467403,13466867,13467509,13468316,13467648],"length":1,"stats":{"Line":0}},{"line":477,"address":[13708755,13708899],"length":1,"stats":{"Line":0}},{"line":478,"address":[14202210],"length":1,"stats":{"Line":0}},{"line":480,"address":[13497650,13495079,13497715,13494686],"length":1,"stats":{"Line":0}},{"line":481,"address":[13709279,13709587,13711835,13711973,13707720],"length":1,"stats":{"Line":0}},{"line":482,"address":[14202764,14341071,14202861,14340937,14203362],"length":1,"stats":{"Line":0}},{"line":485,"address":[14204995],"length":1,"stats":{"Line":0}},{"line":489,"address":[13471296,13471431,13471489,13471321,13471636,13472218,13471266,13471248],"length":1,"stats":{"Line":0}},{"line":492,"address":[12941008,12941058,12941138,12941268],"length":1,"stats":{"Line":0}},{"line":493,"address":[13471979,13471906],"length":1,"stats":{"Line":0}},{"line":495,"address":[13498856,13498781,13498963,13498212],"length":1,"stats":{"Line":0}},{"line":496,"address":[16843342,16843269],"length":1,"stats":{"Line":0}},{"line":497,"address":[14206414],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":204},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","fixtures","mod.rs"],"content":"use serde_json::json;\n\npub fn create_test_user(npub: &str) -> serde_json::Value {\n    json!({\n        \"npub\": npub,\n        \"pubkey\": format!(\"pubkey_{}\", npub),\n        \"name\": format!(\"Test User {}\", npub),\n        \"display_name\": format!(\"Test {}\", npub),\n        \"about\": \"Test user for unit tests\",\n        \"picture\": \"https://example.com/avatar.jpg\",\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890\n    })\n}\n\npub fn create_test_post(id: &str, author_npub: &str, topic_id: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"content\": format!(\"Test post content {}\", id),\n        \"author\": create_test_user(author_npub),\n        \"topic_id\": topic_id,\n        \"created_at\": 1234567890,\n        \"tags\": [\"test\", \"fixture\"],\n        \"likes\": 0,\n        \"boosts\": 0,\n        \"replies\": [],\n        \"is_synced\": false,\n        \"is_boosted\": false,\n        \"is_bookmarked\": false,\n        \"local_id\": id,\n        \"event_id\": null\n    })\n}\n\npub fn create_test_topic(id: &str, name: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"name\": name,\n        \"description\": format!(\"Test topic {}\", name),\n        \"created_at\": 1234567890,\n        \"updated_at\": 1234567890,\n        \"is_joined\": false,\n        \"member_count\": 0,\n        \"post_count\": 0,\n        \"is_public\": true,\n        \"owner\": null\n    })\n}\n\npub fn create_test_event(id: &str, kind: u32, content: &str, pubkey: &str) -> serde_json::Value {\n    json!({\n        \"id\": id,\n        \"pubkey\": pubkey,\n        \"created_at\": 1234567890,\n        \"kind\": kind,\n        \"tags\": [],\n        \"content\": content,\n        \"sig\": format!(\"signature_{}\", id)\n    })\n}\n\npub fn create_test_keypair() -> (String, String, String, String) {\n    let id = uuid::Uuid::new_v4().to_string();\n    let npub = format!(\"npub1{}\", &id[..59]);\n    let nsec = format!(\"nsec1{}\", &id[..59]);\n    let pubkey = format!(\"pubkey_{}\", id);\n    let privkey = format!(\"privkey_{}\", id);\n    \n    (npub, nsec, pubkey, privkey)\n}\n\npub fn create_test_database_url() -> String {\n    \":memory:\".to_string()\n}\n\npub fn create_test_config() -> serde_json::Value {\n    json!({\n        \"database\": {\n            \"url\": \":memory:\",\n            \"max_connections\": 5,\n            \"connection_timeout\": 30\n        },\n        \"network\": {\n            \"bootstrap_peers\": [],\n            \"max_peers\": 50,\n            \"connection_timeout\": 30,\n            \"retry_interval\": 60\n        },\n        \"sync\": {\n            \"auto_sync\": true,\n            \"sync_interval\": 300,\n            \"max_retry\": 3,\n            \"batch_size\": 100\n        },\n        \"storage\": {\n            \"data_dir\": \"./test_data\",\n            \"cache_size\": 100000000,\n            \"cache_ttl\": 3600\n        }\n    })\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_gateway.rs"],"content":"﻿use async_trait::async_trait;\nuse mockall::mock;\n\nuse kukuri_lib::application::ports::event_gateway::EventGateway;\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, ProfileMetadata};\nuse kukuri_lib::domain::value_objects::event_gateway::{PublicKey, ReactionValue, TopicContent};\nuse kukuri_lib::domain::value_objects::{EventId, TopicId};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventGatewayPort {}\n\n    #[async_trait]\n    impl EventGateway for EventGatewayPort {\n        async fn handle_incoming_event(&self, event: DomainEvent) -> Result<(), AppError>;\n        async fn publish_text_note(&self, content: &str) -> Result<EventId, AppError>;\n        async fn publish_topic_post(\n            &self,\n            topic_id: &TopicId,\n            content: &TopicContent,\n            reply_to: Option<&EventId>,\n        ) -> Result<EventId, AppError>;\n        async fn send_reaction(\n            &self,\n            target: &EventId,\n            reaction: &ReactionValue,\n        ) -> Result<EventId, AppError>;\n        async fn update_profile_metadata(\n            &self,\n            metadata: &ProfileMetadata,\n        ) -> Result<EventId, AppError>;\n        async fn delete_events(\n            &self,\n            targets: &[EventId],\n            reason: Option<&str>,\n        ) -> Result<EventId, AppError>;\n        async fn disconnect(&self) -> Result<(), AppError>;\n        async fn get_public_key(&self) -> Result<Option<PublicKey>, AppError>;\n        async fn set_default_topics(&self, topics: &[TopicId]) -> Result<(), AppError>;\n        async fn list_default_topics(&self) -> Result<Vec<TopicId>, AppError>;\n    }\n}\n\npub type MockEventGateway = MockEventGatewayPort;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","event_service.rs"],"content":"use async_trait::async_trait;\nuse mockall::mock;\nuse nostr_sdk::prelude::Timestamp;\n\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{SubscriptionRecord, SubscriptionTarget};\nuse kukuri_lib::domain::entities::Event;\nuse kukuri_lib::infrastructure::crypto::SignatureService;\nuse kukuri_lib::infrastructure::database::EventRepository;\nuse kukuri_lib::infrastructure::p2p::{event_distributor::DistributionStrategy, EventDistributor};\nuse kukuri_lib::shared::error::AppError;\n\nmock! {\n    pub EventRepo {}\n\n    #[async_trait]\n    impl EventRepository for EventRepo {\n        async fn create_event(&self, event: &Event) -> Result<(), AppError>;\n        async fn get_event(&self, id: &str) -> Result<Option<Event>, AppError>;\n        async fn get_events_by_kind(&self, kind: u32, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn get_events_by_author(&self, pubkey: &str, limit: usize) -> Result<Vec<Event>, AppError>;\n        async fn delete_event(&self, id: &str) -> Result<(), AppError>;\n        async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError>;\n        async fn mark_event_synced(&self, id: &str) -> Result<(), AppError>;\n        async fn add_event_topic(&self, event_id: &str, topic_id: &str) -> Result<(), AppError>;\n        async fn get_event_topics(&self, event_id: &str) -> Result<Vec<String>, AppError>;\n    }\n}\n\nmock! {\n    pub SignatureServ {}\n\n    #[async_trait]\n    impl SignatureService for SignatureServ {\n        async fn sign_event(&self, event: &mut Event, private_key: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_event(&self, event: &Event) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n        async fn sign_message(&self, message: &str, private_key: &str) -> Result<String, Box<dyn std::error::Error + Send + Sync>>;\n        async fn verify_message(&self, message: &str, signature: &str, public_key: &str) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub EventDist {}\n\n    #[async_trait]\n    impl EventDistributor for EventDist {\n        async fn distribute(&self, event: &Event, strategy: DistributionStrategy) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;\n        async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn set_strategy(&self, strategy: DistributionStrategy);\n        async fn get_pending_events(&self) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>>;\n        async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>>;\n    }\n}\n\nmock! {\n    pub SubscriptionStateMock {}\n\n    #[async_trait]\n    impl SubscriptionStateStore for SubscriptionStateMock {\n        async fn record_request(&self, target: SubscriptionTarget) -> Result<SubscriptionRecord, AppError>;\n        async fn mark_subscribed(&self, target: &SubscriptionTarget, synced_at: i64) -> Result<(), AppError>;\n        async fn mark_failure(&self, target: &SubscriptionTarget, error: &str) -> Result<(), AppError>;\n        async fn mark_all_need_resync(&self) -> Result<(), AppError>;\n        async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n        async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError>;\n    }\n}\n\nmock! {\n    pub SubscriptionInvokerMock {}\n\n    #[async_trait]\n    impl SubscriptionInvoker for SubscriptionInvokerMock {\n        async fn subscribe_topic(&self, topic_id: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n        async fn subscribe_user(&self, pubkey: &str, since: Option<Timestamp>) -> Result<(), AppError>;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_crypto.rs"],"content":"use std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockKeyManager {\n    keypairs: Arc<RwLock<HashMap<String, MockKeyPair>>>,\n}\n\n#[derive(Debug, Clone)]\npub struct MockKeyPair {\n    pub npub: String,\n    pub nsec: String,\n    pub public_key: String,\n    pub private_key: String,\n}\n\nimpl MockKeyManager {\n    pub fn new() -> Self {\n        Self {\n            keypairs: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn generate_keypair(&self) -> MockKeyPair {\n        let id = uuid::Uuid::new_v4().to_string();\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", &id[..59]),\n            nsec: format!(\"nsec1{}\", &id[..59]),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        keypair\n    }\n\n    pub async fn import_private_key(&self, nsec: &str) -> Result<MockKeyPair, String> {\n        if !nsec.starts_with(\"nsec1\") {\n            return Err(\"Invalid nsec format\".to_string());\n        }\n        \n        let id = &nsec[5..];\n        let keypair = MockKeyPair {\n            npub: format!(\"npub1{}\", id),\n            nsec: nsec.to_string(),\n            public_key: format!(\"pubkey_{}\", id),\n            private_key: format!(\"privkey_{}\", id),\n        };\n        \n        self.keypairs.write().await.insert(keypair.npub.clone(), keypair.clone());\n        Ok(keypair)\n    }\n\n    pub async fn get_keypair(&self, npub: &str) -> Option<MockKeyPair> {\n        self.keypairs.read().await.get(npub).cloned()\n    }\n\n    pub async fn list_npubs(&self) -> Vec<String> {\n        self.keypairs.read().await.keys().cloned().collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSignatureService;\n\nimpl MockSignatureService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn sign_event(&self, event_id: &str, _private_key: &str) -> String {\n        format!(\"signature_for_{}\", event_id)\n    }\n\n    pub async fn verify_event(&self, _event_id: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n\n    pub async fn sign_message(&self, message: &str, _private_key: &str) -> String {\n        format!(\"sig_{}\", &message[..message.len().min(10)])\n    }\n\n    pub async fn verify_message(&self, _message: &str, _signature: &str, _public_key: &str) -> bool {\n        true // Always return true in mock\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEncryptionService;\n\nimpl MockEncryptionService {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub async fn encrypt(&self, data: &[u8], _recipient_pubkey: &str) -> Vec<u8> {\n        // Simple mock: just reverse the bytes\n        data.iter().rev().cloned().collect()\n    }\n\n    pub async fn decrypt(&self, encrypted_data: &[u8], _sender_pubkey: &str) -> Vec<u8> {\n        // Simple mock: reverse back\n        encrypted_data.iter().rev().cloned().collect()\n    }\n\n    pub async fn encrypt_symmetric(&self, data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR with password hash\n        let key = password.bytes().cycle();\n        data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n\n    pub async fn decrypt_symmetric(&self, encrypted_data: &[u8], password: &str) -> Vec<u8> {\n        // Simple mock: XOR back with password hash\n        let key = password.bytes().cycle();\n        encrypted_data.iter().zip(key).map(|(d, k)| d ^ k).collect()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockSecureStorage {\n    storage: Arc<RwLock<HashMap<String, String>>>,\n}\n\nimpl MockSecureStorage {\n    pub fn new() -> Self {\n        Self {\n            storage: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub async fn store(&self, key: &str, value: &str) -> Result<(), String> {\n        self.storage.write().await.insert(key.to_string(), value.to_string());\n        Ok(())\n    }\n\n    pub async fn retrieve(&self, key: &str) -> Result<Option<String>, String> {\n        Ok(self.storage.read().await.get(key).cloned())\n    }\n\n    pub async fn delete(&self, key: &str) -> Result<(), String> {\n        self.storage.write().await.remove(key);\n        Ok(())\n    }\n\n    pub async fn exists(&self, key: &str) -> bool {\n        self.storage.read().await.contains_key(key)\n    }\n\n    pub async fn list_keys(&self) -> Vec<String> {\n        self.storage.read().await.keys().cloned().collect()\n    }\n\n    pub async fn clear(&self) -> Result<(), String> {\n        self.storage.write().await.clear();\n        Ok(())\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_network.rs"],"content":"use async_trait::async_trait;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone)]\npub struct MockNetworkService {\n    is_connected: Arc<RwLock<bool>>,\n    peers: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockNetworkService {\n    pub fn new() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(false)),\n            peers: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn connected() -> Self {\n        Self {\n            is_connected: Arc::new(RwLock::new(true)),\n            peers: Arc::new(RwLock::new(vec![\"peer1\".to_string(), \"peer2\".to_string()])),\n        }\n    }\n\n    pub async fn set_connected(&self, connected: bool) {\n        *self.is_connected.write().await = connected;\n    }\n\n    pub async fn add_peer(&self, peer: String) {\n        self.peers.write().await.push(peer);\n    }\n\n    pub async fn is_connected(&self) -> bool {\n        *self.is_connected.read().await\n    }\n\n    pub async fn get_peers(&self) -> Vec<String> {\n        self.peers.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockGossipService {\n    topics: Arc<RwLock<Vec<String>>>,\n    messages: Arc<RwLock<Vec<(String, String)>>>, // (topic, message)\n}\n\nimpl MockGossipService {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(Vec::new())),\n            messages: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn join_topic(&self, topic: String) {\n        self.topics.write().await.push(topic);\n    }\n\n    pub async fn leave_topic(&self, topic: &str) {\n        self.topics.write().await.retain(|t| t != topic);\n    }\n\n    pub async fn broadcast(&self, topic: String, message: String) {\n        self.messages.write().await.push((topic, message));\n    }\n\n    pub async fn get_joined_topics(&self) -> Vec<String> {\n        self.topics.read().await.clone()\n    }\n\n    pub async fn get_messages(&self) -> Vec<(String, String)> {\n        self.messages.read().await.clone()\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MockEventDistributor {\n    distributed_events: Arc<RwLock<Vec<String>>>,\n    pending_events: Arc<RwLock<Vec<String>>>,\n}\n\nimpl MockEventDistributor {\n    pub fn new() -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub fn with_pending(events: Vec<String>) -> Self {\n        Self {\n            distributed_events: Arc::new(RwLock::new(Vec::new())),\n            pending_events: Arc::new(RwLock::new(events)),\n        }\n    }\n\n    pub async fn distribute(&self, event_id: String) {\n        self.distributed_events.write().await.push(event_id.clone());\n        self.pending_events.write().await.retain(|e| e != &event_id);\n    }\n\n    pub async fn get_distributed_events(&self) -> Vec<String> {\n        self.distributed_events.read().await.clone()\n    }\n\n    pub async fn get_pending_events(&self) -> Vec<String> {\n        self.pending_events.read().await.clone()\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mock_repository.rs"],"content":"use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n// Note: These types would need to be imported from the actual application\n// For now, we'll use placeholder types\ntype Post = serde_json::Value;\ntype Topic = serde_json::Value;\ntype User = serde_json::Value;\ntype Event = serde_json::Value;\n\npub struct MockPostRepository {\n    posts: Arc<RwLock<HashMap<String, Post>>>,\n}\n\nimpl MockPostRepository {\n    pub fn new() -> Self {\n        Self {\n            posts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_posts(posts: Vec<Post>) -> Self {\n        let mut map = HashMap::new();\n        for post in posts {\n            if let Some(id) = post.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), post);\n            }\n        }\n        Self {\n            posts: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockTopicRepository {\n    topics: Arc<RwLock<HashMap<String, Topic>>>,\n}\n\nimpl MockTopicRepository {\n    pub fn new() -> Self {\n        Self {\n            topics: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_topics(topics: Vec<Topic>) -> Self {\n        let mut map = HashMap::new();\n        for topic in topics {\n            if let Some(id) = topic.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), topic);\n            }\n        }\n        Self {\n            topics: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockUserRepository {\n    users: Arc<RwLock<HashMap<String, User>>>,\n}\n\nimpl MockUserRepository {\n    pub fn new() -> Self {\n        Self {\n            users: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_users(users: Vec<User>) -> Self {\n        let mut map = HashMap::new();\n        for user in users {\n            if let Some(npub) = user.get(\"npub\").and_then(|v| v.as_str()) {\n                map.insert(npub.to_string(), user);\n            }\n        }\n        Self {\n            users: Arc::new(RwLock::new(map)),\n        }\n    }\n}\n\npub struct MockEventRepository {\n    events: Arc<RwLock<HashMap<String, Event>>>,\n}\n\nimpl MockEventRepository {\n    pub fn new() -> Self {\n        Self {\n            events: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    pub fn with_events(events: Vec<Event>) -> Self {\n        let mut map = HashMap::new();\n        for event in events {\n            if let Some(id) = event.get(\"id\").and_then(|v| v.as_str()) {\n                map.insert(id.to_string(), event);\n            }\n        }\n        Self {\n            events: Arc::new(RwLock::new(map)),\n        }\n    }\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mocks","mod.rs"],"content":"pub mod event_gateway;\npub mod event_service;\npub mod mock_repository;\npub mod mock_network;\npub mod mock_crypto;\n\npub use event_gateway::*;\npub use event_service::*;\npub use mock_repository::*;\npub use mock_network::*;\npub use mock_crypto::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","common","mod.rs"],"content":"pub mod mocks;\npub mod fixtures;","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract","nip10.rs"],"content":"use kukuri_lib::contract_testing::validate_nip10_tags;\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct Nip10Case {\n    name: String,\n    description: Option<String>,\n    tags: Vec<Vec<String>>,\n    expected: bool,\n}\n\n#[test]\nfn nip10_contract_cases_align_with_rust_validation() {\n    let data = include_str!(concat!(\n        env!(\"CARGO_MANIFEST_DIR\"),\n        \"/../testdata/nip10_contract_cases.json\"\n    ));\n    let cases: Vec<Nip10Case> =\n        serde_json::from_str(data).expect(\"nip10 contract cases json should parse\");\n\n    for case in cases {\n        let result = validate_nip10_tags(case.tags.clone());\n        if case.expected {\n            assert!(\n                result.is_ok(),\n                \"case '{}' expected success but got error: {:?}\",\n                case.name,\n                result.err()\n            );\n        } else {\n            assert!(\n                result.is_err(),\n                \"case '{}' expected failure but succeeded\",\n                case.name\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","contract.rs"],"content":"#[path = \"contract/nip10.rs\"]\nmod nip10;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","offline","mod.rs"],"content":"use std::sync::Arc;\n\nuse chrono::{Duration, Utc};\nuse kukuri_lib::test_support::application::ports::offline_store::OfflinePersistence;\nuse kukuri_lib::test_support::application::services::offline_service::{\n    OfflineActionsQuery, OfflineService, OfflineServiceTrait, SaveOfflineActionParams,\n};\nuse kukuri_lib::test_support::domain::entities::offline::{CacheMetadataUpdate, SyncStatusUpdate};\nuse kukuri_lib::test_support::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::test_support::domain::value_objects::offline::{\n    CacheKey, CacheType, EntityId, EntityType, OfflineActionType, OfflinePayload, SyncStatus,\n};\nuse kukuri_lib::test_support::infrastructure::offline::SqliteOfflinePersistence;\nuse serde_json::Value;\nuse sqlx::{Executor, Pool, Sqlite, sqlite::SqlitePoolOptions};\n\nconst PUBKEY_HEX: &str = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\nasync fn setup_service() -> (OfflineService, Pool<Sqlite>) {\n    let pool = SqlitePoolOptions::new()\n        .max_connections(1)\n        .connect(\"sqlite::memory:?cache=shared\")\n        .await\n        .expect(\"in-memory sqlite\");\n\n    initialize_schema(&pool).await;\n\n    let persistence: Arc<dyn OfflinePersistence> =\n        Arc::new(SqliteOfflinePersistence::new(pool.clone()));\n    (OfflineService::new(persistence), pool)\n}\n\nasync fn initialize_schema(pool: &Pool<Sqlite>) {\n    pool.execute(\n        r#\"\n        CREATE TABLE IF NOT EXISTS offline_actions (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_pubkey TEXT NOT NULL,\n            action_type TEXT NOT NULL,\n            target_id TEXT,\n            action_data TEXT NOT NULL,\n            local_id TEXT NOT NULL,\n            remote_id TEXT,\n            is_synced INTEGER DEFAULT 0,\n            created_at INTEGER NOT NULL,\n            synced_at INTEGER\n        )\n        \"#,\n    )\n    .await\n    .expect(\"offline_actions table\");\n\n    pool.execute(\n        r#\"\n        CREATE TABLE IF NOT EXISTS sync_queue (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            action_type TEXT NOT NULL,\n            payload TEXT NOT NULL,\n            status TEXT NOT NULL,\n            retry_count INTEGER DEFAULT 0,\n            max_retries INTEGER DEFAULT 3,\n            created_at INTEGER NOT NULL,\n            updated_at INTEGER NOT NULL,\n            synced_at INTEGER,\n            error_message TEXT\n        )\n        \"#,\n    )\n    .await\n    .expect(\"sync_queue table\");\n\n    pool.execute(\n        r#\"\n        CREATE TABLE IF NOT EXISTS cache_metadata (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            cache_key TEXT NOT NULL UNIQUE,\n            cache_type TEXT NOT NULL,\n            last_synced_at INTEGER,\n            last_accessed_at INTEGER,\n            data_version INTEGER DEFAULT 1,\n            is_stale INTEGER DEFAULT 0,\n            expiry_time INTEGER,\n            metadata TEXT\n        )\n        \"#,\n    )\n    .await\n    .expect(\"cache_metadata table\");\n\n    pool.execute(\n        r#\"\n        CREATE TABLE IF NOT EXISTS optimistic_updates (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            update_id TEXT NOT NULL UNIQUE,\n            entity_type TEXT NOT NULL,\n            entity_id TEXT NOT NULL,\n            original_data TEXT,\n            updated_data TEXT NOT NULL,\n            is_confirmed INTEGER DEFAULT 0,\n            created_at INTEGER NOT NULL,\n            confirmed_at INTEGER\n        )\n        \"#,\n    )\n    .await\n    .expect(\"optimistic_updates table\");\n\n    pool.execute(\n        r#\"\n        CREATE TABLE IF NOT EXISTS sync_status (\n            entity_type TEXT NOT NULL,\n            entity_id TEXT NOT NULL,\n            local_version INTEGER NOT NULL,\n            last_local_update INTEGER NOT NULL,\n            sync_status TEXT NOT NULL,\n            conflict_data TEXT,\n            PRIMARY KEY (entity_type, entity_id)\n        )\n        \"#,\n    )\n    .await\n    .expect(\"sync_status table\");\n}\n\nfn sample_save_params() -> SaveOfflineActionParams {\n    SaveOfflineActionParams {\n        user_pubkey: PublicKey::from_hex_str(PUBKEY_HEX).expect(\"pubkey\"),\n        action_type: OfflineActionType::new(\"create_post\".into()).expect(\"action type\"),\n        entity_type: EntityType::new(\"post\".into()).expect(\"entity type\"),\n        entity_id: EntityId::new(\"post123\".into()).expect(\"entity id\"),\n        payload: OfflinePayload::from_json_str(r#\"{\"content\":\"Hello\"}\"#).expect(\"payload\"),\n    }\n}\n\n#[tokio::test]\nasync fn save_action_persists_record() {\n    let (service, pool) = setup_service().await;\n\n    let saved = service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save\");\n\n    assert_eq!(saved.action.user_pubkey.as_hex(), PUBKEY_HEX);\n    assert_eq!(\n        saved\n            .action\n            .target_id\n            .as_ref()\n            .map(ToString::to_string)\n            .as_deref(),\n        Some(\"post123\")\n    );\n    assert_eq!(saved.action.action_type.as_str(), \"create_post\");\n\n    let (count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM offline_actions\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"offline_actions count\");\n    assert_eq!(count, 1);\n}\n\n#[tokio::test]\nasync fn list_actions_applies_sync_filter() {\n    let (service, pool) = setup_service().await;\n\n    let first = service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save first\");\n    let mut second_params = sample_save_params();\n    second_params.entity_id = EntityId::new(\"post124\".into()).expect(\"entity id\");\n    service\n        .save_action(second_params)\n        .await\n        .expect(\"save second\");\n\n    sqlx::query(\"UPDATE offline_actions SET is_synced = 1 WHERE id = ?1\")\n        .bind(first.action.record_id.expect(\"record id\"))\n        .execute(&pool)\n        .await\n        .expect(\"mark synced\");\n\n    let synced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(true),\n            limit: None,\n        })\n        .await\n        .expect(\"list synced\");\n    assert_eq!(synced.len(), 1);\n\n    let unsynced = service\n        .list_actions(OfflineActionsQuery {\n            user_pubkey: Some(PublicKey::from_hex_str(PUBKEY_HEX).expect(\"pubkey\")),\n            include_synced: Some(false),\n            limit: None,\n        })\n        .await\n        .expect(\"list unsynced\");\n    assert_eq!(unsynced.len(), 1);\n}\n\n#[tokio::test]\nasync fn sync_actions_marks_records_and_enqueues() {\n    let (service, pool) = setup_service().await;\n\n    service\n        .save_action(sample_save_params())\n        .await\n        .expect(\"save action\");\n\n    let result = service\n        .sync_actions(PublicKey::from_hex_str(PUBKEY_HEX).expect(\"pubkey\"))\n        .await\n        .expect(\"sync actions\");\n    assert_eq!(result.synced_count, 1);\n    assert_eq!(result.failed_count, 0);\n\n    let (is_synced,): (i64,) = sqlx::query_as(\"SELECT is_synced FROM offline_actions LIMIT 1\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"synced flag\");\n    assert_eq!(is_synced, 1);\n\n    let (queue_count,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM sync_queue\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"queue count\");\n    assert_eq!(queue_count, 1);\n}\n\n#[tokio::test]\nasync fn cache_metadata_upsert_and_cleanup() {\n    let (service, pool) = setup_service().await;\n\n    let update = CacheMetadataUpdate {\n        cache_key: CacheKey::new(\"cache:topics\".into()).expect(\"cache key\"),\n        cache_type: CacheType::new(\"topics\".into()).expect(\"cache type\"),\n        metadata: Some(serde_json::json!({\"version\": 1})),\n        expiry: Some(Utc::now() + Duration::seconds(1)),\n    };\n\n    service\n        .upsert_cache_metadata(update)\n        .await\n        .expect(\"upsert cache\");\n\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n    let removed = service.cleanup_expired_cache().await.expect(\"cleanup\");\n    assert_eq!(removed, 1);\n\n    let (remaining,): (i64,) = sqlx::query_as(\"SELECT COUNT(*) FROM cache_metadata\")\n        .fetch_one(&pool)\n        .await\n        .expect(\"remaining cache rows\");\n    assert_eq!(remaining, 0);\n}\n\n#[tokio::test]\nasync fn update_sync_status_performs_upsert() {\n    let (service, pool) = setup_service().await;\n\n    let pending = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"pending\"),\n        Some(OfflinePayload::new(Value::String(\"conflict\".into())).expect(\"payload\")),\n        Utc::now(),\n    );\n    service\n        .update_sync_status(pending)\n        .await\n        .expect(\"initial update\");\n\n    let resolved = SyncStatusUpdate::new(\n        EntityType::new(\"post\".into()).expect(\"entity type\"),\n        EntityId::new(\"p1\".into()).expect(\"entity id\"),\n        SyncStatus::from(\"resolved\"),\n        None,\n        Utc::now(),\n    );\n    service\n        .update_sync_status(resolved)\n        .await\n        .expect(\"second update\");\n\n    let (local_version, sync_status, conflict_data): (i64, String, Option<String>) =\n        sqlx::query_as(\n            r#\"\n            SELECT local_version, sync_status, conflict_data\n            FROM sync_status\n            WHERE entity_type = 'post' AND entity_id = 'p1'\n            \"#,\n        )\n        .fetch_one(&pool)\n        .await\n        .expect(\"sync_status row\");\n\n    assert_eq!(local_version, 2);\n    assert_eq!(sync_status, \"resolved\");\n    assert!(conflict_data.is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_auth.rs"],"content":"// Example integration test for authentication\nuse crate::common::fixtures;\nuse crate::common::mocks::{MockKeyManager, MockSecureStorage};\n\n#[tokio::test]\nasync fn test_create_account() {\n    let key_manager = MockKeyManager::new();\n    let secure_storage = MockSecureStorage::new();\n    \n    // Generate keypair\n    let keypair = key_manager.generate_keypair().await;\n    \n    // Store in secure storage\n    secure_storage\n        .store(\"current_npub\", &keypair.npub)\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify storage\n    let stored_npub = secure_storage\n        .retrieve(\"current_npub\")\n        .await\n        .expect(\"Failed to retrieve npub\");\n    \n    assert_eq!(stored_npub, Some(keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_login_with_nsec() {\n    let key_manager = MockKeyManager::new();\n    let nsec = \"nsec1test1234567890abcdefghijklmnopqrstuvwxyz1234567890abcdef\";\n    \n    // Import private key\n    let result = key_manager.import_private_key(nsec).await;\n    \n    assert!(result.is_ok());\n    let keypair = result.unwrap();\n    assert_eq!(keypair.nsec, nsec);\n    \n    // Verify it was stored\n    let npubs = key_manager.list_npubs().await;\n    assert!(npubs.contains(&keypair.npub));\n}\n\n#[tokio::test]\nasync fn test_logout() {\n    let secure_storage = MockSecureStorage::new();\n    \n    // Store npub\n    secure_storage\n        .store(\"current_npub\", \"npub1test\")\n        .await\n        .expect(\"Failed to store npub\");\n    \n    // Verify it exists\n    assert!(secure_storage.exists(\"current_npub\").await);\n    \n    // Logout (delete)\n    secure_storage\n        .delete(\"current_npub\")\n        .await\n        .expect(\"Failed to delete npub\");\n    \n    // Verify it's gone\n    assert!(!secure_storage.exists(\"current_npub\").await);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_gateway.rs"],"content":"use chrono::Utc;\nuse kukuri_lib::domain::entities::event_gateway::{DomainEvent, EventTag};\nuse kukuri_lib::domain::entities::EventKind;\nuse kukuri_lib::domain::value_objects::event_gateway::PublicKey;\nuse kukuri_lib::domain::value_objects::EventId;\nuse kukuri_lib::infrastructure::database::{\n    connection_pool::ConnectionPool, sqlite_repository::SqliteRepository, EventRepository,\n};\nuse kukuri_lib::infrastructure::event::{\n    EventManagerHandle, LegacyEventManagerGateway, LegacyEventManagerHandle,\n};\nuse sqlx::Row;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tempfile::tempdir;\n\n#[tokio::test]\nasync fn gateway_persists_p2p_events_via_event_manager() -> anyhow::Result<()> {\n    let temp_dir = tempdir()?;\n    let db_path = temp_dir.path().join(\"event_gateway.db\");\n    let db_url = format_sqlite_url(&db_path);\n    let pool = ConnectionPool::new(&db_url).await?;\n\n    let repository = Arc::new(SqliteRepository::new(pool.clone()));\n    repository.initialize().await?;\n\n    let event_manager: Arc<dyn EventManagerHandle> =\n        Arc::new(LegacyEventManagerHandle::new_with_connection_pool(pool.clone()));\n    event_manager\n        .set_event_repository(Arc::clone(&repository) as Arc<dyn EventRepository>)\n        .await;\n\n    let gateway = LegacyEventManagerGateway::new(Arc::clone(&event_manager));\n\n    let event_id =\n        EventId::from_hex(&\"a\".repeat(64)).expect(\"64 hex characters produce a valid event id\");\n    let public_key =\n        PublicKey::from_hex_str(&\"b\".repeat(64)).expect(\"64 hex characters produce a public key\");\n    let topic_tag = EventTag::new(\"t\", vec![\"public\".to_string()]).expect(\"tag construction\");\n    let signature = \"c\".repeat(128);\n    let payload = DomainEvent::new(\n        event_id.clone(),\n        public_key.clone(),\n        EventKind::TextNote,\n        Utc::now(),\n        \"hello-mainline-gateway\".to_string(),\n        vec![topic_tag],\n        signature,\n    )\n    .expect(\"domain event creation\");\n\n    gateway\n        .handle_incoming_event(payload)\n        .await\n        .expect(\"gateway should accept domain events\");\n\n    let stored = sqlx::query(\"SELECT event_id, content FROM events WHERE event_id = ?1\")\n        .bind(event_id.to_hex())\n        .fetch_optional(pool.get_pool())\n        .await?;\n    assert!(stored.is_some(), \"event record should exist after gateway call\");\n    let row = stored.unwrap();\n    let stored_id: String = row.try_get(\"event_id\")?;\n    let stored_content: String = row.try_get(\"content\")?;\n    assert_eq!(stored_id, event_id.to_hex());\n    assert_eq!(stored_content, \"hello-mainline-gateway\");\n\n    let topics = sqlx::query(\"SELECT topic_id FROM event_topics WHERE event_id = ?1\")\n        .bind(event_id.to_hex())\n        .fetch_all(pool.get_pool())\n        .await?;\n    assert_eq!(\n        topics.len(),\n        1,\n        \"event_topics should receive a single hashtag mapping\"\n    );\n    assert_eq!(topics[0].try_get::<String, _>(\"topic_id\")?, \"public\");\n\n    pool.close().await;\n    Ok(())\n}\n\nfn format_sqlite_url(path: &Path) -> String {\n    let mut value = path.to_string_lossy().to_string();\n    if cfg!(windows) {\n        value = value.replace('\\\\', \"/\");\n    }\n    format!(\"sqlite://{}?mode=rwc\", value)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_event_service_gateway.rs"],"content":"use async_trait::async_trait;\nuse kukuri_lib::application::services::event_service::EventService;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse kukuri_lib::domain::entities::Event;\nuse kukuri_lib::domain::value_objects::EventId;\nuse kukuri_lib::infrastructure::crypto::SignatureService;\nuse kukuri_lib::infrastructure::database::EventRepository;\nuse kukuri_lib::infrastructure::event::{\n    EventManagerHandle, EventManagerSubscriptionInvoker, LegacyEventManagerGateway,\n};\nuse kukuri_lib::infrastructure::p2p::GossipService;\nuse kukuri_lib::infrastructure::p2p::event_distributor::{\n    DistributionStrategy, EventDistributor,\n};\nuse kukuri_lib::presentation::dto::event::NostrMetadataDto;\nuse kukuri_lib::shared::error::AppError;\nuse nostr_sdk::prelude::{EventId as NostrEventId, Keys, Metadata, PublicKey};\nuse nostr_sdk::Timestamp;\nuse serde_json::Value;\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\nfn repeating_hex(ch: char) -> String {\n    std::iter::repeat(ch).take(64).collect()\n}\n\nfn to_event_id(hex: &str) -> EventId {\n    EventId::from_hex(hex).expect(\"valid hex event id\")\n}\n\n#[tokio::test]\nasync fn publish_text_note_routes_through_gateway() {\n    let (service, manager, _) = build_service().await;\n    let event_id = service\n        .publish_text_note(\"phase5-text-note\")\n        .await\n        .expect(\"publish text note\");\n\n    assert_eq!(\n        event_id.to_hex(),\n        manager.last_event_id().await.expect(\"event id recorded\")\n    );\n    let notes = manager.text_notes().await;\n    assert_eq!(notes, vec![\"phase5-text-note\".to_string()]);\n}\n\n#[tokio::test]\nasync fn publish_topic_post_converts_topic_and_reply() {\n    let (service, manager, _) = build_service().await;\n    let reply_id = repeating_hex('b');\n    service\n        .publish_topic_post(\"public\", \"phase5 topic body\", Some(&reply_id))\n        .await\n        .expect(\"publish topic post\");\n\n    let posts = manager.topic_posts().await;\n    assert_eq!(posts.len(), 1);\n    let post = &posts[0];\n    assert_eq!(post.topic_id, \"public\");\n    assert_eq!(post.content, \"phase5 topic body\");\n    assert_eq!(post.reply_to_hex.as_deref(), Some(&reply_id));\n}\n\n#[tokio::test]\nasync fn send_reaction_uses_gateway_and_passes_parameters() {\n    let (service, manager, _) = build_service().await;\n    let target = repeating_hex('c');\n    service\n        .send_reaction(&target, \":+1:\")\n        .await\n        .expect(\"send reaction\");\n\n    let reactions = manager.reactions().await;\n    assert_eq!(reactions, vec![(target, \":+1:\".to_string())]);\n}\n\n#[tokio::test]\nasync fn update_metadata_flows_through_conversion() {\n    let (service, manager, _) = build_service().await;\n    let dto = NostrMetadataDto {\n        name: Some(\"Alice\".into()),\n        display_name: Some(\"Alice / Phase5\".into()),\n        about: Some(\"updating metadata\".into()),\n        picture: Some(\"https://example.com/p.png\".into()),\n        banner: None,\n        nip05: None,\n        lud16: Some(\"alice@getalby.com\".into()),\n        website: Some(\"https://kukuri.app\".into()),\n    };\n\n    service\n        .update_metadata(dto.clone())\n        .await\n        .expect(\"update metadata succeeds\");\n\n    let metadata = manager.metadata().await;\n    assert_eq!(metadata.len(), 1);\n    let serialized: Value =\n        serde_json::to_value(&metadata[0]).expect(\"metadata serializable to json\");\n    assert_eq!(serialized[\"name\"], dto.name.unwrap().into());\n    assert_eq!(serialized[\"display_name\"], dto.display_name.unwrap().into());\n    assert_eq!(serialized[\"about\"], dto.about.unwrap().into());\n    assert_eq!(serialized[\"picture\"], dto.picture.unwrap().into());\n    assert_eq!(serialized[\"lud16\"], dto.lud16.unwrap().into());\n    assert_eq!(serialized[\"website\"], dto.website.unwrap().into());\n}\n\n#[tokio::test]\nasync fn delete_events_invokes_gateway_and_repository_cleanup() {\n    let (service, manager, repo) = build_service().await;\n    let targets = vec![repeating_hex('d'), repeating_hex('e')];\n    service\n        .delete_events(targets.clone(), Some(\"cleanup\".into()))\n        .await\n        .expect(\"delete events\");\n\n    let deletions = manager.deletions().await;\n    assert_eq!(deletions.len(), 1);\n    assert_eq!(deletions[0].targets, targets);\n    assert_eq!(deletions[0].reason.as_deref(), Some(\"cleanup\"));\n\n    let deleted_ids = repo.deleted_ids().await;\n    assert_eq!(deleted_ids, targets);\n}\n\nasync fn build_service(\n) -> (\n    EventService,\n    Arc<RecordingEventManager>,\n    Arc<RecordingEventRepository>,\n) {\n    let manager = Arc::new(RecordingEventManager::new());\n    let repository = Arc::new(RecordingEventRepository::default());\n    let manager_trait: Arc<dyn EventManagerHandle> = Arc::clone(&manager);\n    let event_gateway = Arc::new(LegacyEventManagerGateway::new(Arc::clone(&manager_trait)));\n\n    let mut service = EventService::new(\n        Arc::clone(&repository) as Arc<dyn EventRepository>,\n        Arc::new(NoopSignatureService),\n        Arc::new(NoopEventDistributor),\n        event_gateway,\n        Arc::new(NoopSubscriptionStateStore),\n    );\n    service.set_subscription_invoker(Arc::new(EventManagerSubscriptionInvoker::new(\n        Arc::clone(&manager_trait),\n    )));\n\n    (service, manager, repository)\n}\n\n#[derive(Clone)]\nstruct RecordingEventManager {\n    text_notes: Arc<Mutex<Vec<String>>>,\n    topic_posts: Arc<Mutex<Vec<TopicPostRecord>>>,\n    reactions: Arc<Mutex<Vec<(String, String)>>>,\n    metadata: Arc<Mutex<Vec<Metadata>>>,\n    deletions: Arc<Mutex<Vec<DeletionRecord>>>,\n    default_topics: Arc<Mutex<Vec<String>>>,\n    public_key: PublicKey,\n    counter: Arc<AtomicU32>,\n    last_event_hex: Arc<Mutex<Option<String>>>,\n}\n\nimpl RecordingEventManager {\n    fn new() -> Self {\n        let keys = Keys::generate();\n        Self {\n            text_notes: Arc::new(Mutex::new(Vec::new())),\n            topic_posts: Arc::new(Mutex::new(Vec::new())),\n            reactions: Arc::new(Mutex::new(Vec::new())),\n            metadata: Arc::new(Mutex::new(Vec::new())),\n            deletions: Arc::new(Mutex::new(Vec::new())),\n            default_topics: Arc::new(Mutex::new(vec![\"public\".into()])),\n            public_key: keys.public_key(),\n            counter: Arc::new(AtomicU32::new(1)),\n            last_event_hex: Arc::new(Mutex::new(None)),\n        }\n    }\n\n    async fn record_event_id(&self, id: &NostrEventId) {\n        let mut guard = self.last_event_hex.lock().await;\n        *guard = Some(id.to_hex());\n    }\n\n    async fn last_event_id(&self) -> Option<String> {\n        self.last_event_hex.lock().await.clone()\n    }\n\n    async fn text_notes(&self) -> Vec<String> {\n        self.text_notes.lock().await.clone()\n    }\n\n    async fn topic_posts(&self) -> Vec<TopicPostRecord> {\n        self.topic_posts.lock().await.clone()\n    }\n\n    async fn reactions(&self) -> Vec<(String, String)> {\n        self.reactions.lock().await.clone()\n    }\n\n    async fn metadata(&self) -> Vec<Metadata> {\n        self.metadata.lock().await.clone()\n    }\n\n    async fn deletions(&self) -> Vec<DeletionRecord> {\n        self.deletions.lock().await.clone()\n    }\n\n    fn next_event_id(&self) -> NostrEventId {\n        let next = self.counter.fetch_add(1, Ordering::Relaxed);\n        let mut bytes = [0u8; 32];\n        bytes[..4].copy_from_slice(&next.to_be_bytes());\n        NostrEventId::from_slice(&bytes).expect(\"event id from counter\")\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct TopicPostRecord {\n    topic_id: String,\n    content: String,\n    reply_to_hex: Option<String>,\n}\n\n#[derive(Clone, Debug, PartialEq, Eq)]\nstruct DeletionRecord {\n    targets: Vec<String>,\n    reason: Option<String>,\n}\n\n#[async_trait]\nimpl EventManagerHandle for RecordingEventManager {\n    async fn set_gossip_service(&self, _gossip: Arc<dyn GossipService>) {}\n\n    async fn set_event_repository(&self, _repo: Arc<dyn EventRepository>) {}\n\n    async fn set_default_p2p_topic_id(&self, topic_id: &str) {\n        let mut guard = self.default_topics.lock().await;\n        guard.clear();\n        guard.push(topic_id.to_string());\n    }\n\n    async fn set_default_p2p_topics(&self, topics: Vec<String>) {\n        let mut guard = self.default_topics.lock().await;\n        *guard = topics;\n    }\n\n    async fn list_default_p2p_topics(&self) -> Vec<String> {\n        self.default_topics.lock().await.clone()\n    }\n\n    async fn handle_p2p_event(&self, _event: nostr_sdk::Event) -> anyhow::Result<()> {\n        Ok(())\n    }\n\n    async fn publish_text_note(&self, content: &str) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\n        self.record_event_id(&event_id).await;\n        self.text_notes.lock().await.push(content.to_string());\n        Ok(event_id)\n    }\n\n    async fn publish_topic_post(\n        &self,\n        topic_id: &str,\n        content: &str,\n        reply_to: Option<NostrEventId>,\n    ) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\n        self.record_event_id(&event_id).await;\n        self.topic_posts.lock().await.push(TopicPostRecord {\n            topic_id: topic_id.to_string(),\n            content: content.to_string(),\n            reply_to_hex: reply_to.map(|id| id.to_hex()),\n        });\n        Ok(event_id)\n    }\n\n    async fn send_reaction(\n        &self,\n        target: &NostrEventId,\n        reaction: &str,\n    ) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\n        self.record_event_id(&event_id).await;\n        self.reactions\n            .lock()\n            .await\n            .push((target.to_hex(), reaction.to_string()));\n        Ok(event_id)\n    }\n\n    async fn update_metadata(&self, metadata: Metadata) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\n        self.record_event_id(&event_id).await;\n        self.metadata.lock().await.push(metadata);\n        Ok(event_id)\n    }\n\n    async fn delete_events(\n        &self,\n        target_ids: Vec<NostrEventId>,\n        reason: Option<String>,\n    ) -> anyhow::Result<NostrEventId> {\n        let event_id = self.next_event_id();\n        self.record_event_id(&event_id).await;\n        self.deletions.lock().await.push(DeletionRecord {\n            targets: target_ids.into_iter().map(|id| id.to_hex()).collect(),\n            reason,\n        });\n        Ok(event_id)\n    }\n\n    async fn disconnect(&self) -> anyhow::Result<()> {\n        Ok(())\n    }\n\n    async fn get_public_key(&self) -> Option<PublicKey> {\n        Some(self.public_key)\n    }\n\n    async fn subscribe_to_topic(\n        &self,\n        _topic_id: &str,\n        _since: Option<Timestamp>,\n    ) -> anyhow::Result<()> {\n        Ok(())\n    }\n\n    async fn subscribe_to_user(\n        &self,\n        _pubkey: PublicKey,\n        _since: Option<Timestamp>,\n    ) -> anyhow::Result<()> {\n        Ok(())\n    }\n}\n\n#[derive(Default)]\nstruct RecordingEventRepository {\n    deleted: Mutex<Vec<String>>,\n}\n\nimpl RecordingEventRepository {\n    async fn deleted_ids(&self) -> Vec<String> {\n        self.deleted.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl EventRepository for RecordingEventRepository {\n    async fn create_event(&self, _event: &Event) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn get_event(&self, _id: &str) -> Result<Option<Event>, AppError> {\n        Ok(None)\n    }\n\n    async fn get_events_by_kind(\n        &self,\n        _kind: u32,\n        _limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn get_events_by_author(\n        &self,\n        _pubkey: &str,\n        _limit: usize,\n    ) -> Result<Vec<Event>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn delete_event(&self, id: &str) -> Result<(), AppError> {\n        self.deleted.lock().await.push(id.to_string());\n        Ok(())\n    }\n\n    async fn get_unsync_events(&self) -> Result<Vec<Event>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn mark_event_synced(&self, _id: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n}\n\nstruct NoopSignatureService;\n\n#[async_trait]\nimpl SignatureService for NoopSignatureService {\n    async fn sign_event(\n        &self,\n        _event: &mut Event,\n        _private_key: &str,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        Ok(())\n    }\n\n    async fn verify_event(\n        &self,\n        _event: &Event,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(true)\n    }\n\n    async fn sign_message(\n        &self,\n        message: &str,\n        _private_key: &str,\n    ) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(message.to_string())\n    }\n\n    async fn verify_message(\n        &self,\n        _message: &str,\n        _signature: &str,\n        _public_key: &str,\n    ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(true)\n    }\n}\n\nstruct NoopEventDistributor;\n\n#[async_trait]\nimpl EventDistributor for NoopEventDistributor {\n    async fn distribute(\n        &self,\n        _event: &Event,\n        _strategy: DistributionStrategy,\n    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n        Ok(())\n    }\n\n    async fn receive(&self) -> Result<Option<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(None)\n    }\n\n    async fn set_strategy(&self, _strategy: DistributionStrategy) {}\n\n    async fn get_pending_events(\n        &self,\n    ) -> Result<Vec<Event>, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(vec![])\n    }\n\n    async fn retry_failed(&self) -> Result<u32, Box<dyn std::error::Error + Send + Sync>> {\n        Ok(0)\n    }\n}\n\nstruct NoopSubscriptionStateStore;\n\n#[async_trait]\nimpl SubscriptionStateStore for NoopSubscriptionStateStore {\n    async fn record_request(\n        &self,\n        target: SubscriptionTarget,\n    ) -> Result<SubscriptionRecord, AppError> {\n        Ok(SubscriptionRecord {\n            target,\n            status: SubscriptionStatus::Pending,\n            last_synced_at: None,\n            last_attempt_at: None,\n            failure_count: 0,\n            error_message: None,\n        })\n    }\n\n    async fn mark_subscribed(\n        &self,\n        _target: &SubscriptionTarget,\n        _synced_at: i64,\n    ) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn mark_failure(&self, _target: &SubscriptionTarget, _error: &str) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn mark_all_need_resync(&self) -> Result<(), AppError> {\n        Ok(())\n    }\n\n    async fn list_for_restore(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        Ok(vec![])\n    }\n\n    async fn list_all(&self) -> Result<Vec<SubscriptionRecord>, AppError> {\n        Ok(vec![])\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","integration","test_p2p_mainline.rs"],"content":"use iroh::SecretKey;\nuse kukuri_lib::application::services::p2p_service::P2PService;\nuse kukuri_lib::infrastructure::p2p::DiscoveryOptions;\nuse kukuri_lib::shared::config::NetworkConfig as AppNetworkConfig;\n\nfn mainline_ready_config() -> AppNetworkConfig {\n    AppNetworkConfig {\n        bootstrap_peers: vec![\"peer1.example:1337\".into()],\n        max_peers: 24,\n        connection_timeout: 30,\n        retry_interval: 10,\n        enable_dht: true,\n        enable_dns: false,\n        enable_local: true,\n    }\n}\n\n#[test]\nfn builder_enables_mainline_when_configured() {\n    let config = mainline_ready_config();\n    let secret = SecretKey::from_bytes(&[1u8; 32]);\n\n    let builder = P2PService::builder(secret, config.clone());\n    let options = builder.discovery_options();\n\n    assert!(options.enable_mainline(), \"mainline should be enabled\");\n    assert!(!options.enable_dns, \"DNS discovery stays disabled\");\n    assert!(options.enable_local, \"local discovery remains enabled\");\n}\n\n#[test]\nfn builder_can_disable_mainline_via_toggle() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    let secret = SecretKey::from_bytes(&[2u8; 32]);\n\n    let builder = P2PService::builder(secret, config).enable_mainline(false);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options,\n        DiscoveryOptions::new(false, false, true),\n        \"explicit toggle should override configuration flags\"\n    );\n}\n\n#[test]\nfn builder_honors_custom_discovery_overrides() {\n    let mut config = mainline_ready_config();\n    config.enable_dht = false;\n    config.enable_dns = true;\n    config.enable_local = false;\n    let secret = SecretKey::from_bytes(&[3u8; 32]);\n\n    let custom = DiscoveryOptions::new(true, true, false);\n    let builder = P2PService::builder(secret, config).with_discovery_options(custom);\n    let options = builder.discovery_options();\n\n    assert_eq!(\n        options, custom,\n        \"custom discovery options should take precedence over network config\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","offline_integration.rs"],"content":"﻿#[path = \"integration/offline/mod.rs\"]\nmod offline;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_gossip_smoke.rs"],"content":"use kukuri_lib::test_support::application::shared::tests::p2p::bootstrap::{\n    DEFAULT_EVENT_TIMEOUT, DEFAULT_JOIN_TIMEOUT, build_peer_hints, create_service,\n    wait_for_peer_join_event, wait_for_topic_membership,\n};\nuse kukuri_lib::test_support::application::shared::tests::p2p::config::load_bootstrap_context;\nuse kukuri_lib::test_support::application::shared::tests::p2p::fixtures::nostr_to_domain;\nuse kukuri_lib::test_support::application::shared::tests::p2p::logging::init_tracing;\nuse kukuri_lib::test_support::domain::p2p::generate_topic_id;\nuse kukuri_lib::test_support::infrastructure::p2p::gossip_service::GossipService;\nuse nostr_sdk::prelude::*;\nuse tokio::sync::mpsc::unbounded_channel;\nuse tokio::time::{Duration, sleep, timeout};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {\n        tracing::info!(target: \"iroh_tests\", $($arg)*);\n    };\n}\n\n/// subscribe → join の最小シナリオで接続確認を行う\n#[tokio::test]\nasync fn test_two_nodes_connect_and_join() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_connect_and_join\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_connect_and_join start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-two-nodes\");\n    log_step!(\"joining topic {} on both services\", topic);\n\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined topic {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined topic {}\", topic);\n\n    let _rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"both services joined topic {}\", topic);\n\n    let joined_a = svc_a.get_joined_topics().await.unwrap();\n    let joined_b = svc_b.get_joined_topics().await.unwrap();\n    assert!(joined_a.contains(&topic));\n    assert!(joined_b.contains(&topic));\n    log_step!(\"--- test_two_nodes_connect_and_join end ---\");\n}\n\n/// 双方向にメッセージをやり取りし、近接で安定して届くことを検証する\n#[tokio::test]\nasync fn test_peer_connection_stability_bidirectional() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_peer_connection_stability_bidirectional\") else {\n        return;\n    };\n    log_step!(\"--- test_peer_connection_stability_bidirectional start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-stability\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, mut rx_a_evt) = unbounded_channel();\n    let (tx_b_evt, mut rx_b_evt) = unbounded_channel();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for stability test, continuing optimistically\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting ping sequence on topic {}\", topic);\n\n    for i in 0..5u32 {\n        let keys = Keys::generate();\n        let ne = EventBuilder::text_note(format!(\"ping-{i}\"))\n            .sign_with_keys(&keys)\n            .unwrap();\n        let ev = nostr_to_domain(&ne);\n        if i % 2 == 0 {\n            svc_a.broadcast(&topic, &ev).await.unwrap();\n        } else {\n            svc_b.broadcast(&topic, &ev).await.unwrap();\n        }\n    }\n\n    let mut count_a = 0;\n    let mut count_b = 0;\n    let start = tokio::time::Instant::now();\n    while start.elapsed() < Duration::from_secs(12) && (count_a < 3 || count_b < 3) {\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_a.recv().await }).await\n        {\n            count_a += 1;\n        }\n        if let Ok(Some(_)) = timeout(Duration::from_millis(150), async { rx_b.recv().await }).await\n        {\n            count_b += 1;\n        }\n    }\n\n    assert!(\n        count_a >= 3 || count_b >= 3,\n        \"insufficient messages received: a={count_a}, b={count_b}\"\n    );\n    log_step!(\n        \"--- test_peer_connection_stability_bidirectional end (counts a={}, b={}) ---\",\n        count_a,\n        count_b\n    );\n}\n\n/// 二ノード間でのブロードキャスト配送を検証する\n#[tokio::test]\nasync fn test_two_nodes_broadcast_and_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_two_nodes_broadcast_and_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_two_nodes_broadcast_and_receive start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let (tx_a, mut rx_a_evt) = unbounded_channel();\n    let (tx_b, mut rx_b_evt) = unbounded_channel();\n    svc_a.set_event_sender(tx_a);\n    svc_b.set_event_sender(tx_b);\n\n    let topic = generate_topic_id(\"iroh-int-recv\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let _rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    log_step!(\"services joined topic {}, waiting for peer events\", topic);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed, continuing after grace period\");\n    }\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"sending broadcast message on topic {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-int\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"receive timeout\");\n    assert!(r.is_some());\n    assert_eq!(r.unwrap().content, \"hello-int\");\n    log_step!(\"--- test_two_nodes_broadcast_and_receive end ---\");\n}\n\n/// 複数購読者が同一トピックのイベントを受け取れることを検証\n#[tokio::test]\nasync fn test_multiple_subscribers_receive() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multiple_subscribers_receive\") else {\n        return;\n    };\n    log_step!(\"--- test_multiple_subscribers_receive start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-subs\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx1 = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx2 = svc_b.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting multi-subscriber event on {}\", topic);\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-multi\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r1 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx1.recv().await })\n        .await\n        .expect(\"rx1 timeout\");\n    let r2 = timeout(DEFAULT_EVENT_TIMEOUT, async { rx2.recv().await })\n        .await\n        .expect(\"rx2 timeout\");\n\n    assert!(r1.is_some() && r2.is_some());\n    assert_eq!(r1.unwrap().content, \"hello-multi\");\n    assert_eq!(r2.unwrap().content, \"hello-multi\");\n    log_step!(\"--- test_multiple_subscribers_receive end ---\");\n}\n\n/// P2P経路のみで返信イベントが伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_reply_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_reply_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_reply_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-reply-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, mut rx_a_evt) = unbounded_channel();\n    let (tx_b_evt, mut rx_b_evt) = unbounded_channel();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for reply flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"reply-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let root_id = base_event.id.clone();\n    let root_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending reply\");\n\n    let reply_event_tag = Tag::from_standardized(TagStandard::Event {\n        event_id: base_note.id,\n        relay_url: None,\n        marker: Some(Marker::Reply),\n        public_key: None,\n        uppercase: false,\n    });\n    let reply_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let reply_keys = Keys::generate();\n    let reply_note = EventBuilder::text_note(\"reply-post\")\n        .tags([reply_event_tag, reply_pubkey_tag])\n        .sign_with_keys(&reply_keys)\n        .unwrap();\n\n    let reply_event = nostr_to_domain(&reply_note);\n    svc_b.broadcast(&topic, &reply_event).await.unwrap();\n\n    let received_reply = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"reply receive timeout\")\n        .expect(\"reply channel closed\");\n    assert_eq!(received_reply.content, \"reply-post\");\n\n    let e_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"e\"))\n        .expect(\"reply event missing e tag\");\n    assert_eq!(e_tag.get(1).map(|s| s.as_str()), Some(root_id.as_str()));\n    assert_eq!(e_tag.get(3).map(|s| s.as_str()), Some(\"reply\"));\n\n    let p_tag = received_reply\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"reply event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(root_pubkey.as_str()));\n    log_step!(\"--- test_p2p_reply_flow end ---\");\n}\n\n/// P2P経路のみで引用イベント（mention）が伝搬されることを検証\n#[tokio::test]\nasync fn test_p2p_quote_flow() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_p2p_quote_flow\") else {\n        return;\n    };\n    log_step!(\"--- test_p2p_quote_flow start ---\");\n\n    let mut svc_a = create_service(&ctx).await;\n    let mut svc_b = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-quote-flow\");\n    let local_hints = vec![svc_a.local_peer_hint(), svc_b.local_peer_hint()];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n\n    let mut rx_a = svc_a.subscribe(&topic).await.unwrap();\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n\n    let (tx_a_evt, mut rx_a_evt) = unbounded_channel();\n    let (tx_b_evt, mut rx_b_evt) = unbounded_channel();\n    svc_a.set_event_sender(tx_a_evt);\n    svc_b.set_event_sender(tx_b_evt);\n\n    let mut event_receivers = [&mut rx_a_evt, &mut rx_b_evt];\n    if !wait_for_peer_join_event(&mut event_receivers, Duration::from_secs(20)).await {\n        log_step!(\"peer join event not observed for quote flow, continuing optimistically\");\n    }\n    sleep(Duration::from_secs(1)).await;\n    log_step!(\"broadcasting base event on topic {}\", topic);\n\n    let base_keys = Keys::generate();\n    let base_note = EventBuilder::text_note(\"quote-root\")\n        .sign_with_keys(&base_keys)\n        .unwrap();\n    let base_event = nostr_to_domain(&base_note);\n    let base_id = base_event.id.clone();\n    let base_pubkey = base_event.pubkey.clone();\n    svc_a.broadcast(&topic, &base_event).await.unwrap();\n\n    let _ = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"base receive timeout\")\n        .expect(\"base channel closed\");\n    log_step!(\"base event received, sending quote\");\n\n    let mention_tag = Tag::from_standardized(TagStandard::Event {\n        event_id: base_note.id,\n        relay_url: None,\n        marker: Some(Marker::Mention),\n        public_key: None,\n        uppercase: false,\n    });\n    let mention_pubkey_tag = Tag::from_standardized(TagStandard::public_key(base_note.pubkey));\n    let quote_keys = Keys::generate();\n    let quote_note = EventBuilder::text_note(\"quote-post\")\n        .tags([mention_tag, mention_pubkey_tag])\n        .sign_with_keys(&quote_keys)\n        .unwrap();\n    let quote_event = nostr_to_domain(&quote_note);\n    svc_b.broadcast(&topic, &quote_event).await.unwrap();\n\n    let received_quote = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_a.recv().await })\n        .await\n        .expect(\"quote receive timeout\")\n        .expect(\"quote channel closed\");\n    assert_eq!(received_quote.content, \"quote-post\");\n\n    let e_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"e\"))\n        .expect(\"quote event missing e tag\");\n    assert_eq!(e_tag.get(1).map(|s| s.as_str()), Some(base_id.as_str()));\n    assert_eq!(e_tag.get(3).map(|s| s.as_str()), Some(\"mention\"));\n\n    let p_tag = received_quote\n        .tags\n        .iter()\n        .find(|tag| tag.first().map(|s| s.as_str()) == Some(\"p\"))\n        .expect(\"quote event missing p tag\");\n    assert_eq!(p_tag.get(1).map(|s| s.as_str()), Some(base_pubkey.as_str()));\n    log_step!(\"--- test_p2p_quote_flow end ---\");\n}\n\n/// 3ノード構成でA->(B,C)へブロードキャストが届くことを検証\n#[tokio::test]\nasync fn test_multi_node_broadcast_three_nodes() {\n    init_tracing();\n    let Some(ctx) = load_bootstrap_context(\"test_multi_node_broadcast_three_nodes\") else {\n        return;\n    };\n    log_step!(\"--- test_multi_node_broadcast_three_nodes start ---\");\n\n    let svc_a = create_service(&ctx).await;\n    let svc_b = create_service(&ctx).await;\n    let svc_c = create_service(&ctx).await;\n\n    let topic = generate_topic_id(\"iroh-int-multi-node\");\n    let local_hints = vec![\n        svc_a.local_peer_hint(),\n        svc_b.local_peer_hint(),\n        svc_c.local_peer_hint(),\n    ];\n    let hints_a = build_peer_hints(&ctx.hints, &local_hints, 0);\n    let hints_b = build_peer_hints(&ctx.hints, &local_hints, 1);\n    let hints_c = build_peer_hints(&ctx.hints, &local_hints, 2);\n\n    svc_a.join_topic(&topic, hints_a).await.unwrap();\n    log_step!(\"svc_a joined {}\", topic);\n    svc_b.join_topic(&topic, hints_b).await.unwrap();\n    log_step!(\"svc_b joined {}\", topic);\n    svc_c.join_topic(&topic, hints_c).await.unwrap();\n    log_step!(\"svc_c joined {}\", topic);\n\n    let mut rx_b = svc_b.subscribe(&topic).await.unwrap();\n    let mut rx_c = svc_c.subscribe(&topic).await.unwrap();\n\n    assert!(\n        wait_for_topic_membership(&svc_b, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_b failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_c, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_c failed to join topic {topic}\"\n    );\n    assert!(\n        wait_for_topic_membership(&svc_a, &topic, DEFAULT_JOIN_TIMEOUT).await,\n        \"svc_a failed to join topic {topic}\"\n    );\n    log_step!(\"all nodes joined topic {}\", topic);\n\n    sleep(Duration::from_secs(1)).await;\n\n    let keys = Keys::generate();\n    let ne = EventBuilder::text_note(\"hello-3nodes\")\n        .sign_with_keys(&keys)\n        .unwrap();\n    let ev = nostr_to_domain(&ne);\n    svc_a.broadcast(&topic, &ev).await.unwrap();\n\n    let r_b = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_b.recv().await })\n        .await\n        .expect(\"B receive timeout\");\n    let r_c = timeout(DEFAULT_EVENT_TIMEOUT, async { rx_c.recv().await })\n        .await\n        .expect(\"C receive timeout\");\n\n    assert!(r_b.is_some() && r_c.is_some());\n    assert_eq!(r_b.unwrap().content, \"hello-3nodes\");\n    assert_eq!(r_c.unwrap().content, \"hello-3nodes\");\n    log_step!(\"--- test_multi_node_broadcast_three_nodes end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","p2p_mainline_smoke.rs"],"content":"use chrono::Utc;\nuse iroh::SecretKey;\nuse kukuri_lib::test_support::application::services::p2p_service::{P2PService, P2PServiceTrait};\nuse kukuri_lib::test_support::infrastructure::p2p::{\n    DiscoveryOptions, NetworkService, gossip_service::GossipService,\n    iroh_gossip_service::IrohGossipService, iroh_network_service::IrohNetworkService,\n};\nuse kukuri_lib::test_support::shared::config::{AppConfig, NetworkConfig as AppNetworkConfig};\nuse rand::{RngCore, SeedableRng, rngs::StdRng};\nuse tokio::time::{Duration, Instant, sleep};\n\nmacro_rules! log_step {\n    ($($arg:tt)*) => {{\n        eprintln!(\"[p2p_mainline_smoke] {}\", format!($($arg)*));\n    }};\n}\n\nstruct MainlineContext {\n    hints: Vec<String>,\n    network_config: AppNetworkConfig,\n}\n\nfn prepare_context(test_name: &str) -> Option<MainlineContext> {\n    if std::env::var(\"ENABLE_P2P_INTEGRATION\").unwrap_or_default() != \"1\" {\n        eprintln!(\"skipping {test_name} (ENABLE_P2P_INTEGRATION!=1)\");\n        return None;\n    }\n    let raw = std::env::var(\"KUKURI_BOOTSTRAP_PEERS\").unwrap_or_default();\n    let hints: Vec<String> = raw\n        .split(',')\n        .map(|s| s.trim().to_string())\n        .filter(|s| !s.is_empty())\n        .collect();\n    if hints.is_empty() {\n        eprintln!(\"skipping {test_name} (KUKURI_BOOTSTRAP_PEERS not set)\");\n        return None;\n    }\n\n    let app_cfg = AppConfig::from_env();\n    let mut network_config = app_cfg.network.clone();\n    if network_config.bootstrap_peers.is_empty() {\n        network_config.bootstrap_peers = hints.clone();\n    }\n    network_config.enable_dht = true;\n    network_config.enable_dns = false;\n    network_config.enable_local = true;\n\n    Some(MainlineContext {\n        hints,\n        network_config,\n    })\n}\n\nfn random_secret(rng: &mut StdRng) -> SecretKey {\n    let mut bytes = [0u8; 32];\n    rng.fill_bytes(&mut bytes);\n    SecretKey::from_bytes(&bytes)\n}\n\nasync fn wait_for_bootstrap_peer(\n    service: &IrohNetworkService,\n    min_peers: usize,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Ok(peers) = service.get_peers().await {\n            if peers.len() >= min_peers {\n                return true;\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\nasync fn wait_for_local_peer_hint(\n    service: &IrohGossipService,\n    deadline: Duration,\n) -> Option<String> {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        if let Some(hint) = service.local_peer_hint() {\n            return Some(hint);\n        }\n        sleep(Duration::from_millis(150)).await;\n    }\n    None\n}\n\nasync fn wait_for_topic_membership(\n    service: &IrohGossipService,\n    topic: &str,\n    deadline: Duration,\n) -> bool {\n    let start = Instant::now();\n    while start.elapsed() < deadline {\n        match service.get_joined_topics().await {\n            Ok(joined) if joined.iter().any(|t| t == topic) => return true,\n            Ok(_) => {}\n            Err(err) => {\n                log_step!(\"get_joined_topics error for {}: {:?}\", topic, err);\n            }\n        }\n        sleep(Duration::from_millis(200)).await;\n    }\n    false\n}\n\n#[tokio::test]\nasync fn test_mainline_dht_handshake_and_routing() {\n    let Some(ctx) = prepare_context(\"test_mainline_dht_handshake_and_routing\") else {\n        return;\n    };\n    log_step!(\"--- mainline handshake start ---\");\n\n    let discovery = DiscoveryOptions::new(false, true, true);\n\n    let mut rng = StdRng::from_entropy();\n    let secret_a = random_secret(&mut rng);\n    let secret_b = random_secret(&mut rng);\n\n    let stack_a = P2PService::builder(secret_a, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack A\");\n    let stack_b = P2PService::builder(secret_b, ctx.network_config.clone())\n        .with_discovery_options(discovery)\n        .build()\n        .await\n        .expect(\"build stack B\");\n\n    stack_a\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network A\");\n    stack_b\n        .network_service\n        .connect()\n        .await\n        .expect(\"connect network B\");\n\n    assert!(\n        wait_for_bootstrap_peer(&stack_a.network_service, 1, Duration::from_secs(20)).await,\n        \"A failed to discover bootstrap peer via mainline DHT\"\n    );\n    assert!(\n        wait_for_bootstrap_peer(&stack_b.network_service, 1, Duration::from_secs(20)).await,\n        \"B failed to discover bootstrap peer via mainline DHT\"\n    );\n\n    let hint_a = wait_for_local_peer_hint(&stack_a.gossip_service, Duration::from_secs(5)).await;\n    let hint_b = wait_for_local_peer_hint(&stack_b.gossip_service, Duration::from_secs(5)).await;\n\n    let mut hints_for_a = ctx.hints.clone();\n    let mut hints_for_b = ctx.hints.clone();\n    if let Some(h) = &hint_b {\n        hints_for_a.push(h.clone());\n    }\n    if let Some(h) = &hint_a {\n        hints_for_b.push(h.clone());\n    }\n    hints_for_a.sort();\n    hints_for_a.dedup();\n    hints_for_b.sort();\n    hints_for_b.dedup();\n\n    let topic_seed = format!(\n        \"mainline-handshake-routing-{}\",\n        Utc::now().timestamp_nanos_opt().unwrap_or_default()\n    );\n    let topic_id = stack_a.p2p_service.generate_topic_id(&topic_seed);\n\n    stack_a\n        .p2p_service\n        .join_topic(&topic_id, hints_for_a.clone())\n        .await\n        .expect(\"join topic on A\");\n    stack_b\n        .p2p_service\n        .join_topic(&topic_id, hints_for_b.clone())\n        .await\n        .expect(\"join topic on B\");\n\n    assert!(\n        wait_for_topic_membership(&stack_a.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"A did not observe topic membership via DHT routing\"\n    );\n    assert!(\n        wait_for_topic_membership(&stack_b.gossip_service, &topic_id, Duration::from_secs(45))\n            .await,\n        \"B did not observe topic membership via DHT routing\"\n    );\n\n    let stats_a = stack_a\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from A\");\n    assert!(\n        stats_a.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    let stats_b = stack_b\n        .network_service\n        .get_stats()\n        .await\n        .expect(\"fetch stats from B\");\n    assert!(\n        stats_b.connected_peers >= 1,\n        \"expected at least one connected peer after handshake\"\n    );\n\n    stack_a\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic A\");\n    stack_b\n        .p2p_service\n        .leave_topic(&topic_id)\n        .await\n        .expect(\"leave topic B\");\n\n    log_step!(\"--- mainline handshake end ---\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","performance_tests.rs"],"content":"#[cfg(test)]\nmod performance_tests {\n    // パフォーマンステストは一時的に無効化\n    // TODO: 新アーキテクチャに対応後に再実装\n\n    #[tokio::test]\n    #[ignore]\n    async fn test_cache_performance() {\n        // TODO: 新アーキテクチャに対応後に再実装\n    }\n\n    #[tokio::test]\n    #[ignore]\n    async fn test_parallel_processing_performance() {\n        // TODO: 新アーキテクチャに対応後に再実装\n    }\n\n    #[tokio::test]\n    #[ignore]\n    async fn test_batch_processing_performance() {\n        // TODO: 新アーキテクチャに対応後に再実装\n    }\n\n    #[tokio::test]\n    #[ignore]\n    async fn test_memory_cache_ttl() {\n        // TODO: 新アーキテクチャに対応後に再実装\n    }\n\n    #[tokio::test]\n    #[ignore]\n    async fn test_cache_cleanup_performance() {\n        // TODO: 新アーキテクチャに対応後に再実装\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","event_service","mod.rs"],"content":"﻿#[path = \"../../../common/mod.rs\"]\r\nmod common;\r\n\r\nuse std::sync::Arc;\r\n\r\nuse common::mocks::{\r\n    MockEventDist, MockEventGateway, MockEventRepo, MockSignatureServ, MockSubscriptionInvokerMock,\r\n    MockSubscriptionStateMock,\r\n};\r\nuse kukuri_lib::application::ports::subscription_invoker::SubscriptionInvoker;\nuse kukuri_lib::application::services::event_service::EventService;\nuse kukuri_lib::application::services::subscription_state::SubscriptionStateStore;\nuse kukuri_lib::domain::value_objects::subscription::{\n    SubscriptionRecord, SubscriptionStatus, SubscriptionTarget,\n};\nuse kukuri_lib::domain::entities::Event;\r\nuse kukuri_lib::infrastructure::crypto::SignatureService;\r\nuse kukuri_lib::infrastructure::database::EventRepository;\r\nuse kukuri_lib::infrastructure::p2p::EventDistributor;\r\nuse kukuri_lib::shared::error::AppError;\r\nuse mockall::predicate::*;\r\n\r\nfn create_test_event() -> Event {\r\n    Event::new(1, \"Test content\".into(), \"test_pubkey\".into())\r\n}\r\n\r\nfn service_with_state(\r\n    repo: MockEventRepo,\r\n    signature: MockSignatureServ,\r\n    distributor: MockEventDist,\r\n    state: MockSubscriptionStateMock,\r\n    gateway: MockEventGateway,\r\n) -> EventService {\r\n    EventService::new(\r\n        Arc::new(repo) as Arc<dyn EventRepository>,\r\n        Arc::new(signature) as Arc<dyn SignatureService>,\r\n        Arc::new(distributor) as Arc<dyn EventDistributor>,\r\n        Arc::new(gateway)\r\n            as Arc<dyn kukuri_lib::application::ports::event_gateway::EventGateway>,\r\n        Arc::new(state) as Arc<dyn SubscriptionStateStore>,\r\n    )\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_create_event_success() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let event = service\r\n        .create_event(\r\n            1,\r\n            \"Test content\".to_string(),\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"create_event should succeed\");\r\n\r\n    assert_eq!(event.content, \"Test content\");\r\n    assert_eq!(event.pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_valid_signature() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(true));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_handle_incoming_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_ok());\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_process_received_event_invalid_signature() {\r\n    let mock_repo = MockEventRepo::new();\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_verify_event()\r\n        .times(1)\r\n        .returning(|_| Ok(false));\r\n\r\n    let mock_distributor = MockEventDist::new();\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let result = service.process_received_event(create_test_event()).await;\r\n\r\n    assert!(result.is_err());\r\n    assert!(\r\n        result\r\n            .unwrap_err()\r\n            .to_string()\r\n            .contains(\"Invalid event signature\")\r\n    );\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_requires_ids() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(Vec::new(), None)\r\n        .await\r\n        .expect_err(\"empty ids should result in validation error\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_with_invalid_id() {\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let err = service\r\n        .delete_events(vec![\"invalid\".to_string()], None)\r\n        .await\r\n        .expect_err(\"invalid id should fail\");\r\n\r\n    assert!(matches!(err, AppError::ValidationError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_events_gateway_failure_maps_to_nostr_error() {\r\n    let mut mock_gateway = MockEventGateway::new();\r\n    mock_gateway\r\n        .expect_delete_events()\r\n        .times(1)\r\n        .returning(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let service = service_with_state(\r\n        MockEventRepo::new(),\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        mock_gateway,\r\n    );\r\n\r\n    let valid_id = format!(\"{:064x}\", 1);\r\n    let err = service\r\n        .delete_events(vec![valid_id], Some(\"cleanup\".to_string()))\r\n        .await\r\n        .expect_err(\"gateway failure should map to nostr error\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let event = create_test_event();\r\n    let cloned = event.clone();\r\n\r\n    mock_repo\r\n        .expect_get_event()\r\n        .with(eq(\"test_id\"))\r\n        .times(1)\r\n        .returning(move |_| Ok(Some(cloned.clone())));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_event(\"test_id\")\r\n        .await\r\n        .expect(\"get_event should succeed\");\r\n\r\n    assert!(fetched.is_some());\r\n    assert_eq!(fetched.unwrap().content, \"Test content\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_kind() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_kind()\r\n        .with(eq(1u32), eq(10usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_kind(1, 10)\r\n        .await\r\n        .expect(\"get_events_by_kind should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_get_events_by_author() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_events_by_author()\r\n        .with(eq(\"test_pubkey\"), eq(5usize))\r\n        .times(1)\r\n        .returning(move |_, _| Ok(cloned.clone()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        MockEventDist::new(),\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let fetched = service\r\n        .get_events_by_author(\"test_pubkey\", 5)\r\n        .await\r\n        .expect(\"get_events_by_author should succeed\");\r\n\r\n    assert_eq!(fetched.len(), 1);\r\n    assert_eq!(fetched[0].pubkey, \"test_pubkey\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_delete_event() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    mock_repo\r\n        .expect_create_event()\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n    mock_repo\r\n        .expect_delete_event()\r\n        .with(eq(\"event_to_delete\"))\r\n        .times(1)\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_signature = MockSignatureServ::new();\r\n    mock_signature\r\n        .expect_sign_event()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(1)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        mock_signature,\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    service\r\n        .delete_event(\r\n            \"event_to_delete\",\r\n            \"test_pubkey\".to_string(),\r\n            \"test_private_key\",\r\n        )\r\n        .await\r\n        .expect(\"delete_event should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_sync_pending_events() {\r\n    let mut mock_repo = MockEventRepo::new();\r\n    let events = vec![create_test_event(), create_test_event()];\r\n    let cloned = events.clone();\r\n\r\n    mock_repo\r\n        .expect_get_unsync_events()\r\n        .times(1)\r\n        .returning(move || Ok(cloned.clone()));\r\n\r\n    mock_repo\r\n        .expect_mark_event_synced()\r\n        .times(events.len())\r\n        .returning(|_| Ok(()));\r\n\r\n    let mut mock_distributor = MockEventDist::new();\r\n    mock_distributor\r\n        .expect_distribute()\r\n        .times(events.len())\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let service = service_with_state(\r\n        mock_repo,\r\n        MockSignatureServ::new(),\r\n        mock_distributor,\r\n        MockSubscriptionStateMock::new(),\r\n        MockEventGateway::new(),\r\n    );\r\n\r\n    let synced = service\r\n        .sync_pending_events()\r\n        .await\r\n        .expect(\"sync_pending_events should succeed\");\r\n\r\n    assert_eq!(synced, 2);\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_uses_state_machine_and_invoker() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .withf(|target| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(1)\r\n        .withf(|target, _| matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\"))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect(\"subscribe_to_topic should succeed\");\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_subscribe_to_topic_failure_marks_state() {\r\n    let record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_record_request()\r\n        .times(1)\r\n        .return_once(move |_| Ok(record.clone()));\r\n    mock_state\r\n        .expect_mark_failure()\r\n        .times(1)\r\n        .withf(|target, message| {\r\n            matches!(target, SubscriptionTarget::Topic(t) if t == \"topic\")\r\n                && message.contains(\"failed\")\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .return_once(|_, _| Err(AppError::NostrError(\"failed\".into())));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    let err = service\r\n        .subscribe_to_topic(\"topic\")\r\n        .await\r\n        .expect_err(\"subscription failure should bubble up\");\r\n\r\n    assert!(matches!(err, AppError::NostrError(_)));\r\n}\r\n\r\n#[tokio::test]\r\nasync fn test_handle_network_connected_restores_subscriptions() {\r\n    let topic_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::Topic(\"topic\".into()),\r\n        status: SubscriptionStatus::NeedsResync,\r\n        last_synced_at: None,\r\n        last_attempt_at: None,\r\n        failure_count: 0,\r\n        error_message: None,\r\n    };\r\n    let user_record = SubscriptionRecord {\r\n        target: SubscriptionTarget::User(\"user\".into()),\r\n        status: SubscriptionStatus::Pending,\r\n        last_synced_at: Some(3600),\r\n        last_attempt_at: None,\r\n        failure_count: 1,\r\n        error_message: Some(\"previous failure\".into()),\r\n    };\r\n    let list_topic = topic_record.clone();\r\n    let list_user = user_record.clone();\r\n    let predicate_user = user_record.clone();\r\n\r\n    let mut mock_state = MockSubscriptionStateMock::new();\r\n    mock_state\r\n        .expect_list_for_restore()\r\n        .times(1)\r\n        .return_once(move || Ok(vec![list_topic, list_user]));\r\n    mock_state\r\n        .expect_mark_subscribed()\r\n        .times(2)\r\n        .returning(|_, _| Ok(()));\r\n\r\n    let mut mock_invoker = MockSubscriptionInvokerMock::new();\r\n    mock_invoker\r\n        .expect_subscribe_topic()\r\n        .times(1)\r\n        .with(eq(\"topic\"), eq(None))\r\n        .return_once(|_, _| Ok(()));\r\n    mock_invoker\r\n        .expect_subscribe_user()\r\n        .times(1)\r\n        .withf(move |pubkey, since| {\r\n            pubkey == \"user\"\r\n                && since.map(|ts| ts.as_u64())\r\n                    == predicate_user\r\n                        .last_synced_at\r\n                        .map(|value| (value - 300) as u64)\r\n        })\r\n        .return_once(|_, _| Ok(()));\r\n\r\n    let mut service = service_with_state(\n        MockEventRepo::new(),\n        MockSignatureServ::new(),\n        MockEventDist::new(),\n        mock_state,\n        MockEventGateway::new(),\n    );\n    service.set_subscription_invoker(Arc::new(mock_invoker) as Arc<dyn SubscriptionInvoker>);\r\n\r\n    service\r\n        .handle_network_connected()\r\n        .await\r\n        .expect(\"handle_network_connected should succeed\");\r\n}\r\n\r\n\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","application","mod.rs"],"content":"mod event_service;\n","traces":[],"covered":0,"coverable":0},{"path":["/","app","kukuri-tauri","src-tauri","tests","unit","mod.rs"],"content":"mod application;\n","traces":[],"covered":0,"coverable":0}],"coverage":25.232198142414862,"covered":1630,"coverable":6460}